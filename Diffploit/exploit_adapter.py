from pathlib import Path
from logger import log
from error_manager import ErrorManager
from diff_manager import DiffManager
from exploit_repair import RepairModule
import shutil
import os
from llm_client import LLMClient

class ExploitAdapter:
    def __init__(self, cve_id, processor):
        self.cve_id = cve_id
        self.expected_reproduced_behavior = processor.get_reproduced_behavior()
        self.expected_reproduced_detail = processor.get_reproduced_detail() or []
        self.version_processor = processor
        self.cve_processor = processor
        self.llm_client = LLMClient()


    def adapt(self, from_version: str, to_version: str, executor) -> bool:
        log("Adapter",f'Start adapting exploit from {from_version} to {to_version}"',   "info")

        diff_path = f"/PoCAdaptation/library/diff/{self.cve_id}/{to_version}-{from_version}.diff"
        diff_mgr = DiffManager(diff_path)



        src_dir = f"/PoCAdaptation/exploit/pending/{self.cve_id}/{to_version}"
        dst_dir = f"/PoCAdaptation/exploit/result/{self.cve_id}/{to_version}"
        os.makedirs(os.path.dirname(dst_dir), exist_ok=True)
        if os.path.exists(dst_dir):
            shutil.rmtree(dst_dir)
        shutil.copytree(src_dir, dst_dir)


        while True:
            if executor.execute_adapted(to_version):
                log("Adapter", f"Adaptation from {from_version} to {to_version} successful.", "success")
                return True
            error_mgr = ErrorManager(executor.get_error_log())

            pom_path = Path(f"/PoCAdaptation/exploit/result/{self.cve_processor.cve_id}/{to_version}/exploit/pom.xml")
            if not pom_path.exists():
                log("RepairModule", f"[Adapter] âœ— pom.xml not found at {pom_path}")
                return False

            fix_position = self.locate_fix_position(executor.get_error_log(), from_version, to_version, pom_path)
            
            if 'HV000028' in executor.get_error_log():
                fix_position = 'pom'


            grouped = error_mgr.get_grouped_errors()
            first_group = next(iter(grouped.items()), None)
            if first_group:
                group_key, errors = first_group
                if errors:
                    err = errors[0]

                    if  fix_position == "pom":
                        
                        with open(pom_path, 'r', encoding='utf-8') as file:
                            pom_content = file.read()

                        log("Adapter", "Fix position is in pom.xml.", "info")
                        cause = error_mgr.extract_root_cause_from_llm(err, from_version, to_version, executor.get_error_log())
                        related_diffs = diff_mgr.select_related_diff_pom(cause)

                        

                        repair = RepairModule(group_key, cause, err, related_diffs, diff_mgr, executor, error_mgr, self.cve_processor, from_version, to_version)
                        if repair.repair_pom() and executor.execute_adapted(to_version):
                            return True
                        else:
                            with open(pom_path, 'w', encoding='utf-8') as file:
                                file.write(pom_content)

                        
                            
                    cause = error_mgr.extract_root_cause_from_llm(err, from_version, to_version, executor.get_error_log())
                        
                    log("Adapter", f"Try to solve error: {err} with cause: {cause}", "info")
                    related_diffs = diff_mgr.select_related_diff_test(group_key, cause)

                    if not related_diffs:
                        cause = error_mgr.re_extract_root_cause_from_llm(err, from_version, to_version, executor.get_error_log(),cause)
                        related_diffs = diff_mgr.select_related_diff_pom(cause)

                    else:
                        best_diff_id, best_score = related_diffs[0]
                        if best_score < 0.1:
                            cause = error_mgr.re_extract_root_cause_from_llm(err, from_version, to_version, executor.get_error_log(),cause)
                            related_diffs = diff_mgr.select_related_diff_pom(cause)
                        
                    log("Adapter", f"Related diffs for error: {related_diffs}", "info")

                    log("Adapter", "Fix position is in test code.", "info")
                    repair = RepairModule(group_key, cause, err, related_diffs, diff_mgr, executor, error_mgr, self.cve_processor, from_version, to_version)
                    repair.repair_test()
                    log("Adapter", "Test code repair attempted.", "info")
            else:
                log("Adapter", "No errors found in initial adaptation.", "info")
                if 'BUILD SUCCESS' in executor.get_error_log():
                    log("Adapter", "Assertion Failure.", "error")

                    init_file_dir = f"/PoCAdaptation/exploit/pending/{self.cve_processor.cve_id}/{to_version}/exploit/src/test/java/edu/vision/se/Testcase1.java"
                    with open(init_file_dir, 'r', encoding='utf-8') as file:
                        init = file.read()

                    cause = error_mgr.extract_trace_from_llm(from_version, to_version, init, self.cve_processor)
                    print(f"Cause: {cause}")
                    related_diffs = diff_mgr.select_related_diff_assert(cause)
                    print(f"Related Diffs: {related_diffs}")
                    repair = RepairModule(None, None, None, related_diffs, diff_mgr, executor, error_mgr, self.cve_processor, from_version, to_version)
                    repair.repair_assert()
                else:
                    break

        if executor.execute_adapted(to_version):
            log("Adapter", f"Adaptation from {from_version} to {to_version} successful.", "success")
            return True
        else:
            log("Adapter", f"Adaptation from {from_version} to {to_version} failed.", "error")
            return False

    def locate_fix_position(self, error_log: str, from_version: str, to_version: str, pom_path: str) -> str:
        log("Adapter", "Locating fix position in error log.", "info")
        with open(pom_path, 'r', encoding='utf-8') as file:
            pom_content = file.read()

        prompt = (
                f"You are given a Java error log when executing 'mvn test' in a project with dependency version {to_version}:"
                f"{self.cve_processor.get_group_id()}:{self.cve_processor.get_artifact_id()}.\n"
                f"This test file compiles and runs successfully with version {from_version}.\n\n"
                f"Your task is to:\n"
                f"1. Analyze why this issue occurs with the *{from_version}* but not with the *{to_version} version*.\n"
                f"2. Consider how to resolve the issue **without updating this library**.\n"
                f"3. Determine and output the location in the project that should be modified to fix the problem.\n\n"
                f"Please return 'pom' if the fix is in the pom.xml file, or 'test' if the fix is in the test code.\n"
                f"Do not return any other text, just 'pom' or 'test'.\n\n"
                f"The error log is:\n{error_log}\n"
                f"current_pom file is:"
                f"{pom_content}"
            )

        response = self.llm_client.ask(prompt)

        with open('/PoCAdaptation/log.txt', 'a', encoding='utf-8') as f:
                f.write("-----locate fix position-----\n")
                f.write("=== Prompt ===\n")
                f.write(prompt + "\n")
                f.write("=== Response ===\n")
                f.write(response + "\n")
                f.write("----------\n") 


       
        log("Adapter", f"LLM response for fix position: {response}", "info")
        if "pom" in response.lower():
            return "pom"
        elif "test" in response.lower():
            return "test"
        else:
            log("Adapter", "LLM did not return a valid fix position. Defaulting to 'test'.", "warning")
            return "test"