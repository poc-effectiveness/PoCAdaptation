from pathlib import Path
import subprocess
from typing import List
from logger import log 


class ExploitExecutor:
    
    def __init__(self, cve_id: str, reproduced_behavior: str = None, reproduced_detail: List[str] = None):
        self.cve_id = cve_id
        self.reproduced_behavior = reproduced_behavior
        self.reproduced_detail = reproduced_detail or []
        self.origin_exploit_dir = Path(f"/PoCAdaptation/exploit/origin/{cve_id}/exploit")
        self.last_log = ""
        self.initial_test_log = ""
        self.initial_test_success = False
        self.initial_test_returncode = None
        self.initial_test_verified = False
        self._run_initial_exploit()
        
        
        
    def _run_initial_exploit(self):
        if not self.origin_exploit_dir.exists():
            log("Executor", f"Origin exploit directory not found: {self.origin_exploit_dir}", "error")
            return
        
        log("Executor", f"Running initial exploit mvn test in {self.origin_exploit_dir}", "info")
        cmd = ["mvn", "--batch-mode", "clean", "test"]
        
        try:
            result = subprocess.run(cmd, cwd=self.origin_exploit_dir, capture_output=True, text=True, timeout=300)
            self.initial_test_log = result.stdout + "\n" + result.stderr
            self.initial_test_returncode = result.returncode
            self.initial_test_success = (result.returncode == 0)
            log("Executor", f"Initial exploit execution finished with return code {result.returncode}", 
                "success" if self.initial_test_success else "error")
        except subprocess.TimeoutExpired:
            self.initial_test_log = "Timeout expired during initial exploit test execution."
            self.initial_test_success = False
            self.initial_test_returncode = -1
            log("Executor", "Initial exploit execution timed out.", "error")
        except Exception as e:
            self.initial_test_log = f"Exception during initial exploit execution: {e}"
            self.initial_test_success = False
            self.initial_test_returncode = -1
            log("Executor", f"Exception during initial exploit execution: {e}", "error")
            
        self.initial_test_verified = self.verify_reproduction(self.initial_test_log)
        if self.initial_test_verified:
            log("Verifier", "Initial exploit behavior verified successfully.", "success")
        else:
            log("Verifier", "Initial exploit behavior does NOT match expected reproduction.", "error")


    def run_exploit_test(self, version: str) -> str:
        exploit_dir = Path(f"/PoCAdaptation/exploit/pending/{self.cve_id}/{version}/exploit")
        if not exploit_dir.exists():
            raise FileNotFoundError(f"Exploit directory not found: {exploit_dir}")

        cmd = ["mvn", "--batch-mode", "clean", "test"]
        try:
            result = subprocess.run(cmd, cwd=exploit_dir, capture_output=True, text=True, timeout=300)
            return result.stdout + "\n" + result.stderr
        except subprocess.TimeoutExpired:
            raise RuntimeError("Execution timed out.")
        except Exception as e:
            raise RuntimeError(f"Execution failed: {e}")


    def verify_reproduction(self, log_text: str) -> bool:
        log("Verifier", "Verifying reproduction...", "info")
        if self.reproduced_behavior:
            if self.reproduced_behavior in log_text:
                log("Verifier", f"✓ Behavior matched: '{self.reproduced_behavior}'", "success")
            else:
                log("Verifier", f"✗ Behavior not found: '{self.reproduced_behavior}'", "error")
                return False

        for detail in self.reproduced_detail:
            if detail in log_text:
                log("Verifier", f"✓ Detail matched: '{detail}'", "success")
            else:
                log("Verifier", f"✗ Detail not found: '{detail}'", "error")
                return False

        log("Verifier", "✓ All reproduction indicators matched.", "success")
        return True
    
    
    def run_exploit_test_adapted(self, version: str) -> str:
        exploit_dir = Path(f"/PoCAdaptation/exploit/result/{self.cve_id}/{version}/exploit")
        if not exploit_dir.exists():
            raise FileNotFoundError(f"Exploit directory not found: {exploit_dir}")

        cmd = ["mvn", "--batch-mode", "clean", "test"]
        try:
            result = subprocess.run(cmd, cwd=exploit_dir, capture_output=True, text=True, timeout=300)
            return result.stdout + "\n" + result.stderr
        except subprocess.TimeoutExpired:
            raise RuntimeError("Execution timed out.")
        except Exception as e:
            raise RuntimeError(f"Execution failed: {e}")
    
    
    def execute(self, version: str) -> bool:
        log("Executor", f"Executing exploit for {self.cve_id} on version {version}...", "info")
        try:
            log_text = self.run_exploit_test(version)
        except Exception as e:
            log("Executor", f"Execution error: {e}", "error")
            return False

        self.last_log = log_text
        success = self.verify_reproduction(log_text)
        log("Executor", f"Reproduction result: {'Success' if success else 'Failure'}", 
            "success" if success else "error")
        return success
    
    
    def execute_adapted(self, version: str) -> bool:
        log("Executor", f"Executing exploit for {self.cve_id} on version {version}...", "info")
        try:
            log_text = self.run_exploit_test_adapted(version)
        except Exception as e:
            log("Executor", f"Execution error: {e}", "error")
            return False

        self.last_log = log_text
        success = self.verify_reproduction(log_text)
        log("Executor", f"Reproduction result: {'Success' if success else 'Failure'}", 
            "success" if success else "error")
        
        if self.cve_id == 'CVE-2016-7051':
            if 'Should not try to resolve external DTD subset' in log_text:
                log("Executor", "Success! As Assertion Failed", "success")
                success = True
            if 'milliseconds' in log_text:
                log("Executor", "Success! As Timeout", "success")
                success = True
        return success

    def get_error_log(self) -> str:
        return self.last_log
