import os
from pathlib import Path
import shutil
import subprocess
from logger import log 

class ExploitPreparer:
    def __init__(self, cve_id: str, group_id: str, artifact_id: str):
        self.cve_id = cve_id
        self.group_id = group_id
        self.artifact_id = artifact_id
        self.gav = f"{group_id}:{artifact_id}" 
        self.pending_dir = Path(f"/PoCAdaptation/exploit/pending/{cve_id}")
        self._create_pending_dir()

    def _create_pending_dir(self):
        if not self.pending_dir.exists():
            self.pending_dir.mkdir(parents=True)
            log("Preparer", f"Created pending directory: {self.pending_dir}", "success")
        else:
            log("Preparer", f"Pending directory already exists: {self.pending_dir}", "info")

    def prepare_adaptation_version(self, origin_version: str, adaptation_version: str, all_versions: list) -> bool:
        if not self.copy_exploit_to_pending(origin_version, adaptation_version, all_versions):
            return False

        if not self.update_dependency_version(adaptation_version):
            log("Preparer", f"Warning: Failed to update dependency version for {adaptation_version}", "warning")
        return True


    def levenshtein(self, s1, s2):
        if len(s1) < len(s2):
            return self.levenshtein(s2, s1)

        if len(s2) == 0:
            return len(s1)
        previous_row = range(len(s2) + 1)
        for i, c1 in enumerate(s1):
            current_row = [i + 1]
            for j, c2 in enumerate(s2):
                insertions = previous_row[j + 1] + 1 
                deletions = current_row[j] + 1      
                substitutions = previous_row[j] + (c1 != c2) 
                current_row.append(min(insertions, deletions, substitutions))
            previous_row = current_row
        return previous_row[-1]
    
    
    def copy_exploit_to_pending(self, origin_version: str, adaptation_version: str, all_versions: list) -> bool:
        pending_version_dir = self.pending_dir / adaptation_version
        pending_version_dir.mkdir(parents=True, exist_ok=True)

        valid_exploit_dir = Path(f"/PoCAdaptation/exploit/valid/{self.cve_id}/{origin_version}/exploit")
        origin_exploit_dir = Path(f"/PoCAdaptation/exploit/origin/{self.cve_id}/exploit")
        
        valid_base_dir = Path(f"/PoCAdaptation/exploit/valid/{self.cve_id}")


        if valid_exploit_dir.exists():
            source_dir = valid_exploit_dir
            log("Preparer", f"Using exploit from valid: {source_dir}", "info")
            
        elif valid_base_dir.exists():   
            existing_versions = {
                d.name for d in valid_base_dir.iterdir()
                if d.is_dir() and (d / "exploit").exists()
            }         
            ordered_existing_versions = [
                v for v in all_versions if v in existing_versions
            ]
            
            if ordered_existing_versions:
                closest_version = None
                for v in ordered_existing_versions:
                    if v >= adaptation_version:
                        break
                    closest_version = v
                if closest_version is None:
                    closest_version = ordered_existing_versions[0]
                candidate = valid_base_dir / closest_version / "exploit"
                source_dir = candidate
                log("Preparer", f"Using closest existing exploit version: {candidate}", "info")
            else:
                source_dir = origin_exploit_dir
                log("Preparer", f"No usable exploit dirs found under {valid_base_dir}", "warning")
                
                
        elif origin_exploit_dir.exists():
            source_dir = origin_exploit_dir
            log("Preparer", f"Using exploit from origin: {origin_exploit_dir}", "info")
        else:
            log("Preparer", f"No exploit found for origin version {origin_version}", "error")
            return False

        destination_dir = pending_version_dir / "exploit"
        if destination_dir.exists():
            shutil.rmtree(destination_dir)
        shutil.copytree(source_dir, destination_dir)
        log("Preparer", f"Copied exploit to: {destination_dir}", "success")
        return True

    def update_dependency_version(self, adaptation_version: str) -> bool:
        pom_file = self.pending_dir / adaptation_version / "exploit" / "pom.xml"
        if not pom_file.exists():
            log("Preparer", f"pom.xml not found at {pom_file}, skipping version update.", "warning")
            return False

        cmd = [
            "mvn", "versions:use-dep-version",
            f"-Dincludes={self.gav}",
            f"-DdepVersion={adaptation_version}",
            "-f", str(pom_file)
        ]
        try:
            log("Preparer", f"Updating dependency version to {adaptation_version} in {pom_file}", "info")
            subprocess.run(cmd, check=True, capture_output=True, text=True)
            log("Preparer", f"Updated dependency version to {adaptation_version} in {pom_file}", "success")
            return True
        except subprocess.CalledProcessError as e:
            log("Preparer", f"Failed to update version in {pom_file}: {e}", "error")
            log("Preparer", f"stdout:\n{e.stdout}", "error")
            log("Preparer", f"stderr:\n{e.stderr}", "error")
            return False
