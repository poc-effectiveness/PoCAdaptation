from pathlib import Path
import random
import math
from error_manager import ErrorManager
from llm_client import LLMClient
from logger import log
import xml.etree.ElementTree as ET


class RepairModule:
    def __init__(self, group_key, cause, err, related_diffs, diff_mgr, executor, error_mgr, cve_processor, from_version, to_version):
        self.group_key = group_key
        self.cause = cause
        self.related_diffs = related_diffs
        self.err = err 
        self.diff_mgr = diff_mgr
        self.executor = executor
        self.error_mgr = error_mgr
        self.llm_client = LLMClient()
        self.cve_processor = cve_processor
        self.pending_file_path = f"/PoCAdaptation/exploit/pending/{cve_processor.cve_id}/{to_version}/exploit/src/test/java/edu/vision/se/Testcase1.java"
        self.result_file_path = f"/PoCAdaptation/exploit/result/{cve_processor.cve_id}/{to_version}/exploit/src/test/java/edu/vision/se/Testcase1.java"
        self.from_version = from_version
        self.to_version = to_version
        
        
    def _build_diff_combinations(self, top_k=5):
        top_diffs = sorted(self.diff_scores.items(), key=lambda x: -x[1])[:top_k]
        combos = []
        for i in range(len(top_diffs)):
            for j in range(i + 1, len(top_diffs)):
                id1, s1 = top_diffs[i]
                id2, s2 = top_diffs[j]
                avg_score = (s1 + s2) / 2
                combos.append(((id1, id2), avg_score))
        return combos



    def repair_assert(self):
        log("RepairModule", f"Start repair")

        temperature = 1.0
        cooling_rate = 0.7
        min_temperature = 0.1
        iteration = 0

        with open(self.result_file_path, "r") as f:
                original_code = f.read()

        self.diff_scores = {diff_id: score for diff_id, score in self.related_diffs}
        self.diff_combinations = self._build_diff_combinations(top_k=5)

        log("RepairModule", f"Start repair")

        while temperature > min_temperature:
            iteration += 1
            diff_id, score = self.anneal_select_diff(temperature)
            log("RepairModule", f"Start repair")

            prompt = (
                f"You are given an assertion unmatch when executing test in in {self.to_version}:{self.cve_processor.get_group_id()}:{self.cve_processor.get_artifact_id()}\n"
                f"This test file reproduced successfully in {self.from_version}. with an {self.cve_processor.reproduced_behavior}\n\n"
                f"The reproduction beahavior is {self.cve_processor.reproduced_behavior} {self.cve_processor.reproduced_detail}.\n"
                f"However, in {self.to_version}, the test passed, which is not expected.\n"
                f"Your task is to solve the problem and reproduced the expected behavior in {self.to_version}. Your are not to change assertion logic.\n"
                f"Current test file is {original_code}\n"
                "Your task is 1. Analyze the cause of the errors 2. Decide fix position of the test 3. Output only the updated test without explanation\n\n"
                "If you want to open an attact target server, you can open it in @BeforeClass"
            )
            log("RepairModule", f"Start repair")
            try:
                response = self.llm_client.ask(prompt)
            except Exception as e:
                log("RepairModule", f"LLM request failed: {e}", "error")
                return False
            
            if not self.apply_modified_code(response):
                return False
            
            verified = self.executor.execute_adapted(self.to_version)

            if verified:
                log("RepairModule", "Repair success!", "success")
                return True
            else:
                i = 0
                with open(self.result_file_path, "r") as f:
                    modified_code = f.read()
                while i < 3:
                    i += 1
                    log("RepairModule", f"Repair failed, retrying {i}/3", "warning")
                    prompt = (
                        f"You are given an error when executing test in in {self.to_version}:{self.cve_processor.get_group_id()}:{self.cve_processor.get_artifact_id()}\n"
                        f"This test file compiles and runs successfully in {self.from_version}.\n\n"
                        f"The reproduction beahavior is {self.cve_processor.reproduced_behavior} {self.cve_processor.reproduced_detail}.\n"
                        f"However, in {self.to_version}, the test failed with {self.executor.get_error_log()}\n"
                        "Your task is to solve the problem"
                        f"Current test file is {modified_code}\n"
                        "Output only the updated test without explanation"
                        "If you want to open an target server, you can only open it by 'python -m http.server' in @BeforeClass"
                    )
                    try:
                        response = self.llm_client.ask(prompt)
                    except Exception as e:
                        log("RepairModule", f"LLM request failed: {e}", "error")
                        return False
                    if not self.apply_modified_code(response):
                        return False
                    
                    verified = self.executor.execute_adapted(self.to_version)
                    if verified:
                        log("RepairModule", "Repair success on retry!", "success")
                        return True
                    

                with open(self.result_file_path, "w") as f:
                    f.write(modified_code)

                exit()
            

    def repair_pom(self):
        log("RepairModule", f"Start repair")
        pom_path = Path(f"/PoCAdaptation/exploit/result/{self.cve_processor.cve_id}/{self.to_version}/exploit/pom.xml")
        if not pom_path.exists():
            log("RepairModule", f"[Adapter] ✗ pom.xml not found at {pom_path}")
            return False
        
        with open(pom_path, 'r', encoding='utf-8') as file:
            pom_content = file.read()

        temperature = 1.0
        cooling_rate = 0.7
        min_temperature = 0.1
        iteration = 0

        self.diff_scores = {diff_id: score for diff_id, score in self.related_diffs}
        self.diff_combinations = self._build_diff_combinations(top_k=5)


        while temperature > min_temperature:
            iteration += 1
            diff_id, score = self.anneal_select_diff(temperature)

            log("RepairModule", f"Iteration {iteration}, temperature {temperature:.3f}: Trying diff #{diff_id} with score {score:.2f}", "info")
            
            if isinstance(diff_id, tuple): 
                id1, id2 = diff_id
                diff_text = self.diff_mgr.get_diff_by_id(id1) + '\n' + self.diff_mgr.get_diff_by_id(id2)

            else:
                diff_text = self.diff_mgr.get_diff_by_id(diff_id)

            prompt = (
                f"You are given an error when executing test in in {self.to_version}:{self.cve_processor.get_group_id()}:{self.cve_processor.get_artifact_id()}\n"
                f"This test file compiles and runs successfully in {self.from_version}.\n\n"
                f"Related diff is {diff_text}\n\n"
                f"You are NOT allowed to change the version of the dependency {self.cve_processor.get_group_id()}:{self.cve_processor.get_artifact_id()}.\n"
                "Your task is to solve the problem by changing the pom file of the project\n"
                f"Current pom file is {pom_content}\n"
                "Your task is 1. Analyze the cause of the errors 2. Decide fix position of the pom file according to the cause 3. Output only the updated partion of pom.xml entries without explanation\n\n"
                f"### Compilation Errors:\n"
                + self.executor.get_error_log() 
            )
            
            response = self.llm_client.ask(prompt)

            with open('/PoCAdaptation/log.txt', 'a', encoding='utf-8') as f:
                # 尝试信息
                f.write("----------\n")
                f.write("=== Prompt ===\n")
                f.write(prompt + "\n")
                f.write("=== Response ===\n")
                f.write(response + "\n")
                f.write("----------\n")  

            self.update_pom_with_llm_response(pom_path, response)

            if self.executor.execute_adapted(self.to_version):
                return True
            elif self.err["message"] not in self.executor.get_error_log():
                return True
            else:
                with open(pom_path, 'r', encoding='utf-8') as file:
                    pom_tmp = file.read()
                prompt = (
                    f"You are given an error when executing test in in {self.to_version}:{self.cve_processor.get_group_id()}:{self.cve_processor.get_artifact_id()}\n"
                    f"This test file compiles and runs successfully in {self.from_version}.\n\n"
                    f"You are NOT allowed to change the version of the dependency {self.cve_processor.get_group_id()}:{self.cve_processor.get_artifact_id()}.\n"
                    "Your task is to solve the problem by changing the pom file of the project. You can update other library to any versions\n"
                    f"Current pom file is {pom_tmp}\n"
                    "Your task is 1. Analyze the cause of the errors 2. Decide fix position of the pom file according to the cause 3. Output only the updated partion of pom.xml entries without explanation\n\n"
                    f"### Compilation Errors:\n"
                    + self.executor.get_error_log() 
                )
                response = self.llm_client.ask(prompt)
                self.update_pom_with_llm_response(pom_path, response)
                if self.executor.execute_adapted(self.to_version):
                    return True
            
            if isinstance(diff_id, tuple):
                for idx, (did, score)  in enumerate(self.diff_combinations):
                    if did == diff_id:
                        new_score = score / 2
                        self.diff_combinations[idx] = (did, new_score)
                        self.diff_combinations.sort(key=lambda x: x[1], reverse=True)
                        break
            else:
                for idx, (did, score) in enumerate(self.related_diffs):
                    if did == diff_id:
                        new_score = score / 2
                        self.related_diffs[idx] = (did, new_score)
                        self.related_diffs.sort(key=lambda x: x[1], reverse=True)
                        break
                
            
            with open(pom_path, 'w', encoding='utf-8') as file:
                file.write(pom_content)

            temperature *= cooling_rate

        return False



    def repair_test(self):

        no_diff_flag = False
        log("RepairModule", f"Start repair for group: {self.group_key} cause: {self.cause}", "info")

        if self.related_diffs:
            best_diff_id, best_score = self.related_diffs[0]
            self.diff_scores = {diff_id: score for diff_id, score in self.related_diffs}
        else:
            best_diff_id, best_score = None, 0
            self.diff_scores = {}

        log("RepairModule", f"Trying best diff #{best_diff_id} with score {best_score:.2f}", "info")
        
        with open(self.result_file_path, "r") as f:
                original_code = f.read()
                
        # do not start this logic
        if best_score > 2 and self.try_diff(best_diff_id, 0):
            log("RepairModule", "Repair success with best diff!", "success")
            return True
        elif best_score < 0: 
            content = self.remove_deprecated_code(original_code, self.err)
            if content:
                with open(self.result_file_path, "w") as f:
                    f.write(content)
            if self.try_diff(None, 0):
                log("RepairModule", "Repair success with no diff!", "success")
                return True
 


        with open(self.result_file_path, "w") as f:
            f.write(original_code)

        temperature = 1.0
        cooling_rate = 0.9
        min_temperature = 0.1
        iteration = 0


        
        self.diff_combinations = self._build_diff_combinations(top_k=5)
        log("RepairModule", f"Found {len(self.diff_combinations)} diff combinations for annealing.", "info")
    
        while temperature > min_temperature:
            iteration += 1
            diff_id, score = self.anneal_select_diff(temperature)


            if no_diff_flag and diff_id is None:
                log("RepairModule", "No more diffs to try, stopping repair.", "error")
                return False

            if diff_id is None:
                no_diff_flag = True
                log("RepairModule", f"Iteration {iteration}, temperature {temperature:.3f}: No diff selected.", "info")
                
            log("RepairModule", f"Iteration {iteration}, temperature {temperature:.3f}: Trying diff #{diff_id} with score {score:.2f}", "info")

                
            if isinstance(diff_id, tuple): 
                id1, id2 = diff_id
                success = self.try_combined_diff(id1, id2, temperature)
                if success:
                    log("RepairModule", f"Repair success with diff #{diff_id} at iteration {iteration}!", "success")
                    return True
                else: 
                    for idx, (did, score)  in enumerate(self.diff_combinations):
                        if did == diff_id:
                            new_score = score / 2
                            self.diff_combinations[idx] = (did, new_score)
                            self.diff_combinations.sort(key=lambda x: x[1], reverse=True)
                            break


            else: 
                success = self.try_diff(diff_id, temperature)
                if success:
                    log("RepairModule", f"Repair success with diff #{diff_id} at iteration {iteration}!", "success")
                    return True
                else:
                    for idx, (did, score) in enumerate(self.related_diffs):
                        if did == diff_id:
                            new_score = score / 2
                            self.related_diffs[idx] = (did, new_score)
                            self.related_diffs.sort(key=lambda x: x[1], reverse=True)
                            break
            

            with open(self.result_file_path, "w") as f:
                f.write(original_code)
            
            temperature *= cooling_rate

        log("RepairModule", "Repair failed after simulated annealing.", "error")
        return False



    def try_combined_diff(self, diff_id1, diff_id2, temperature):
        diff_text1 = self.diff_mgr.get_diff_by_id(diff_id1)
        diff_text2 = self.diff_mgr.get_diff_by_id(diff_id2)
        if not diff_text1 or not diff_text2:
            log("RepairModule", f"One of the diffs #{diff_id1} or #{diff_id2} content empty, skipping", "warning")
            return self.try_diff_text("", temperature)
        return self.try_diff_text(diff_text1 + "\n" + diff_text2, temperature)
        
            
    def try_diff(self, diff_id, temperature):
        diff_text = self.diff_mgr.get_diff_by_id(diff_id)
        if not diff_text:
            log("RepairModule", f"Diff #{diff_id} content empty", "warning")
            return self.try_diff_text("", temperature)
        return self.try_diff_text(diff_text, temperature)
    
    
    def try_diff_simple(self, diff_id, err):
        diff_text = self.diff_mgr.get_diff_by_id(diff_id)
        if not diff_text:
            log("RepairModule", f"Diff #{diff_id} content empty", "warning")
            return False
        
        return self.try_diff_text_simple(diff_text, err, diff_id)


    def try_diff_text_simple(self, diff_text, err, diff_id):

        prompt = self.construct_prompt_simple(diff_text, err)
        try:
            response = self.llm_client.ask(prompt)
        except Exception as e:
            log("RepairModule", f"LLM request failed: {e}", "error")
            return False
        
        if not self.apply_modified_code(response):
            return False
        
        with open('/PoCAdaptation/log.txt', 'a', encoding='utf-8') as f:
            # 尝试信息
            f.write(f"---diff id {diff_id}-------\n")
            f.write("=== Prompt ===\n")
            f.write(prompt + "\n")
            f.write("=== Response ===\n")
            f.write(response + "\n")
            f.write("----------\n")  
    
    
        self.executor.execute_adapted(self.to_version)
        new_error_log = self.executor.get_error_log()

        if err['message'] in new_error_log:
            log("RepairModule", f"Simple repair Error {err['message']} still exists after applying diff.", "error")
            return False
        
        return True
        
    def remove_deprecated_code(self, code_str, error_log):
        prompt = (
            "You are given a Java test file that may contain a complication error.\n"
            "Your task is to remove code related to the issue from this file.\n"
            "Only output the modified version of the test file without any explanations.\n\n"
            f"### Compilation Errors:\n"
            f"message: {self.err['message']}, symbol: {self.err['symbol']}, location: {self.err['location']}\n"
            f"{error_log}"

            f"### Test File Content:\n{code_str}\n\n"    
        )
        
        try:
            response = self.llm_client.ask(prompt)
        except Exception as e:
            log("RepairModule", f"LLM request failed: {e}", "error")
            return None
        
        if not response.strip():
            log("RepairModule", "LLM returned empty response for removing deprecated code.", "warning")
            return None
        
        return response.strip()
    

        
    def try_diff_text(self, diff_text, temperature):
        prompt = self.construct_prompt(diff_text)
        try:
            response = self.llm_client.ask(prompt)
        except Exception as e:
            log("RepairModule", f"LLM request failed: {e}", "error")
            return False
        
        if not self.apply_modified_code(response):
            return False
        
        
        with open('/PoCAdaptation/log.txt', 'a', encoding='utf-8') as f:
            f.write("----------\n")
            f.write("=== Prompt ===\n")
            f.write(prompt + "\n")
            f.write("=== Response ===\n")
            f.write(response + "\n")
            f.write("----------\n") 
    
        old_log = self.executor.get_error_log()
        verified = self.executor.execute_adapted(self.to_version)

        if verified:
            log("RepairModule", "Repair success!", "success")
            return True
        
        new_error_log = self.executor.get_error_log()

        new_error_mgr = ErrorManager(new_error_log)
        grouped_errors = new_error_mgr.get_grouped_errors()
        
        old_grouped_keys = set(self.error_mgr.get_grouped_errors().keys())
        new_grouped_keys = set(grouped_errors.keys())
        newly_introduced_keys = new_grouped_keys - old_grouped_keys

        print(f"[RepairModule] Old grouped keys: {old_grouped_keys}")
        print(f"[RepairModule] New grouped keys: {new_grouped_keys}")
        if newly_introduced_keys:
            cause_line = self.err["line"]
            for key in newly_introduced_keys:
                if "There are test failures" in key:
                    continue
                for err in grouped_errors[key]: 
                    position = (
                        "before" if err["line"] < cause_line
                        else "after" if err["line"] > cause_line
                        else "same"
                    ) 
                    new_error_info = (
                            f"[Analyzer] New error:\n"
                            f"  File     : {err['file']}\n"
                            f"  Line     : {err['line']}, Column: {err['column']}\n"
                            f"  Message  : {err['message']}\n"
                            f"  Symbol   : {err.get('symbol')}\n"
                            f"  Location : {err.get('location')}\n"
                            f"  Code     : {err.get('code_line', '').strip()}\n"
                            f"  Position : {position} the fixing line ({cause_line})"
                        )
                    log("RepairModule", new_error_info, "warning")

                    if 'before' in position:
                        log("RepairModule", f"[Analyzer] New error introduced before the fixing line, might be caused by the diff.", "warning")                  
                        if random.random() > temperature:
                            log("RepairModule", f"[Analyzer] Stop to handle the error due to temperature {temperature}.", "warning")
                            return False
                        else: 
                            if not self.simple_repair(err, grouped_errors[key]):
                                log("RepairModule", f"[Analyzer] Simple repair failed for error: {err}", "error")
                                return False
        # else:
        #     if all("There are test failures." in key for key in old_grouped_keys) and all("There are test failures." in key for key in new_grouped_keys):
        #         if old_log != new_error_log:
        #             log("RepairModule", f"New error log detected after applying diff: {new_error_log}", "warning")
        #             if self.simple_repair(self.err, grouped_errors.get(self.group_key, [])):
        #                 log("RepairModule", f"[Analyzer] Simple repair failed for error: {self.err}", "error")
        #                 return True
        #         return False
                

        def error_exists_in_group(error_to_check, grouped_errors, group_key):
            errors = grouped_errors.get(group_key, [])
            for err in errors:
                if (err.get("file") == error_to_check.get("file") and
                    err.get("line") == error_to_check.get("line") and
                    err.get("message") == error_to_check.get("message")):
                    return True
            return False


        
        if error_exists_in_group(self.err, grouped_errors, self.group_key):
            log("RepairModule", f"Error {self.err['message']} still exists in group {self.group_key} after applying diff.", "error")
            return False
        else:
            log("RepairModule", f"Error {self.err['message']} resolved after applying diff.", "success")
            return True
        
        
    def simple_repair(self, err, group):
        log("RepairModule", f"Simple repair for error: {err}", "info")
        log("RepairModule", f"Group : {group}", "info")
        
        first = group[0]
        message = first['message']
        symbol = first.get('symbol') or ''
        group_key = f"{message} | {symbol}".strip()
        log("RepairModule", f"Group key : {group_key}", "info")    
        cause = self.error_mgr.extract_root_cause_from_llm(err, self.from_version, self.to_version, self.executor.get_error_log() )
        log("RepairModule", f"Extracted cause: {cause}", "info")
        related_diffs = self.diff_mgr.select_related_diff_test(group_key, cause)
        log("RepairModule", f"Related diffs for simple repair: {related_diffs}", "info")

        for diff_id, score in related_diffs[:2]:
            log("RepairModule", f"Trying diff #{diff_id} with score {score:.2f} for simple repair", "info")
            if self.try_diff_simple(diff_id, err):
                log("RepairModule", "Simple repair success!", "success")
                return True

        return False
        
    
    def reverse_diff(self, diff_text: str) -> str:
        reversed_lines = []
        for line in diff_text.splitlines():
            if line.startswith('+++ '):
                reversed_lines.append(line)
            elif line.startswith('--- '):
                reversed_lines.append(line)
            elif line.startswith('+') and not line.startswith('+++'):
                reversed_lines.append('-' + line[1:])
            elif line.startswith('-') and not line.startswith('---'):
                reversed_lines.append('+' + line[1:])
            else:
                reversed_lines.append(line)
        return '\n'.join(reversed_lines)



    def construct_prompt(self, diff_text: str) -> str:
        with open(self.result_file_path, encoding="utf-8") as f:
            testcase_content = f.read()
        from_version = self.from_version
        to_version = self.to_version
        group_id = self.cve_processor.get_group_id()
        artifact_id = self.cve_processor.get_artifact_id()
        if "There are test failures" in self.err['message']:
            prompt = (
                f"You are given a Java test file with compilation errors in version {to_version}:{group_id}:{artifact_id}.\n"
                f"This test file compiles and runs successfully in {from_version}.\n\n"
                f"The diff is related to the diff.\n"
                "Your task has three steps:\n"
                " 1. Locate the code where the compilation error occurs.\n"
                f" 2. Analyze the diff from {from_version} to {to_version}.\n"
                " 3. Fix the error in the error position only when diff is helpful. Add import statement when needed according to the diff. If mocking, access fields via reflection if they exist. \n\n"
                "Only output the modified version of the test file according to the diff. No explanations. \n"
                "### Compilation Errors:\n"
                f"message: {self.executor.get_error_log() }"
                f"### Error Position:\n"
                f"{self.err.get('code_line')}\n\n"

                f"### Related Diff:\n"
                f"{self.reverse_diff(diff_text)}\n\n"

                "### Test File Content:\n"
                f"{testcase_content}\n\n"
            )
        else:
            prompt = (
                f"You are given a Java test file with compilation errors in version {to_version}:{group_id}:{artifact_id}.\n"
                f"This test file compiles and runs successfully in {from_version}.\n\n"
                f"The diff is related to the diff.\n"
                "Your task has three steps:\n"
                " 1. Locate the code where the compilation error occurs.\n"
                f" 2. Analyze the diff from {from_version} to {to_version}.\n"
                " 3. Fix the error in the error position only when diff is helpful. Add import statement when needed according to the diff. \n\n"

                "Only output the modified version of the test file according to the diff. No explanations. If mocking, access fields via reflection if they exist.\n"
                "### Compilation Errors:\n"
                f"message: {self.err['message']}, symble: {self.err['symbol']}, location: {self.err['location']}\n\n"

                f"### Error Position:\n"
                f"{self.err.get('code_line')}\n\n"
                
                f"### Related Diff:\n"
                f"{self.reverse_diff(diff_text)}\n\n"
                
                "### Test File Content:\n"
                f"{testcase_content}\n\n"
            )
        return prompt
    
    
    def construct_prompt_simple(self, diff_text: str, err)-> str:
        with open(self.result_file_path, encoding="utf-8") as f:
            testcase_content = f.read()
        
        from_version = self.from_version
        to_version = self.to_version
        group_id = self.cve_processor.get_group_id()
        artifact_id = self.cve_processor.get_artifact_id()
        prompt = (
            f"You are given a Java test file with compilation errors in version {to_version}:{group_id}:{artifact_id}.\n"
            f"This test file compiles and runs successfully in {from_version}.\n\n"
            f"The diff is related to the diff.\n"
            "Your task has three steps:\n"
            " 1. Locate the code where the compilation error occurs.\n"
            f" 2. Analyze the diff from {from_version} to {to_version}.\n"
            " 3. Fix the error in the error position only when diff is helpful. Add import statement when needed according to the diff. If mocking, access fields via reflection if they exist.\n\n"

            "Only output the modified version of the test file. No explanations. \n"
            "### Compilation Errors:\n"
            f"{err['message']} in {err['code_line']}"

            

           
            f"### Related Diff:\n"
            f"{self.reverse_diff(diff_text)}\n\n"
            
            "### Test File Content:\n"
            f"{testcase_content}\n\n"
        )
        return prompt
    

    def anneal_select_diff(self, temperature):
        all_diffs = self.related_diffs + self.diff_combinations

        if not all_diffs:
            return None, 0

        nonzero_diffs = [(diff_id, score) for diff_id, score in all_diffs if score > 0]

        if not nonzero_diffs:
            return None, 0

        max_score = max(score for _, score in nonzero_diffs)

        weights = []
        for _, score in nonzero_diffs:
            weight = math.exp(score / max_score / temperature)
            weights.append(weight)

        total = sum(weights)
        probs = [w / total for w in weights]

        chosen = random.choices(nonzero_diffs, weights=probs, k=1)[0]
        return chosen



    def apply_modified_code(self, code_str):
        # 写文件简化示例，真实环境按需求写
        try:
            target_file = self.result_file_path
            with open(target_file, "w", encoding="utf-8") as f:
                f.write(code_str)
            log("RepairModule", f"Wrote modified code to {target_file}", "info")
            return True
        except Exception as e:
            log("RepairModule", f"Failed to write modified code: {e}", "error")
            return False
        

    def apply_or_update_dependency(self, root, new_dep, ns):
        group_id = new_dep.findtext("groupId")
        artifact_id = new_dep.findtext("artifactId")
        version = new_dep.findtext("version")

        # Find existing dependency
        for dep in root.findall(".//m:dependencies/m:dependency", ns):
            gid = dep.findtext("m:groupId", namespaces=ns)
            aid = dep.findtext("m:artifactId", namespaces=ns)

            if gid == group_id and aid == artifact_id:
                ver_elem = dep.find("m:version", namespaces=ns)
                if ver_elem is not None:
                    print(f"[Adapter] ~ Updating version of {gid}:{aid} to {version}")
                    ver_elem.text = version
                else:
                    print(f"[Adapter] + Adding version to {gid}:{aid}")
                    new_ver = ET.Element("version")
                    new_ver.text = version
                    dep.append(new_ver)
                return

        # Not found, add new dependency
        print(f"[Adapter] + Adding new dependency {group_id}:{artifact_id}:{version}")
        dependencies_elem = root.find(".//m:dependencies", ns)
        if dependencies_elem is None:
            dependencies_elem = ET.SubElement(root, "dependencies")
        dependencies_elem.append(new_dep)


    def update_pom_with_llm_response(self, pom_path: str, llm_response: str):
        # 1. Parse original pom.xml
        tree = ET.parse(pom_path)
        root = tree.getroot()
        ns = {'m': 'http://maven.apache.org/POM/4.0.0'}
        ET.register_namespace('', ns['m'])

        try:
            # Wrap if needed
            wrapped = f"<root>{llm_response.strip()}</root>" if not llm_response.strip().startswith("<root>") else llm_response
            patch_root = ET.fromstring(wrapped)
        except ET.ParseError as e:
            print("[Adapter] ✗ Failed to parse LLM XML:", e)
            return

        for elem in patch_root:
            tag = elem.tag.strip()

            if tag == "dependencies":
                for dep in elem.findall("dependency"):
                    self.apply_or_update_dependency(root, dep, ns)
            elif tag == "dependency":
                self.apply_or_update_dependency(root, elem, ns)
            else:
                if root.find(f"m:{tag}", ns) is None:
                    print(f"[Adapter] + Adding tag <{tag}> to pom.xml")
                    root.append(elem)
                else:
                    print(f"[Adapter] ~ Updating existing tag <{tag}> in pom.xml")
                    existing = root.find(f"m:{tag}", ns)
                    for child in list(existing):
                        existing.remove(child)
                    for sub_elem in list(elem):
                        existing.append(sub_elem)

        tree.write(pom_path, encoding="utf-8", xml_declaration=True)
        print("[Adapter] ✓ pom.xml successfully updated.")
