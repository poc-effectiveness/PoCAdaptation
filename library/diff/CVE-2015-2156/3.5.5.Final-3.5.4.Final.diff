diff --git a/pom.xml b/pom.xml
index 704e9c0895f1..cca98906be6f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>io.netty</groupId>
   <artifactId>netty</artifactId>
   <packaging>bundle</packaging>
-  <version>3.5.4.Final</version>
+  <version>3.5.5.Final</version>
 
   <name>The Netty Project</name>
   <url>http://netty.io/</url>
diff --git a/src/main/java/org/jboss/netty/buffer/BigEndianHeapChannelBuffer.java b/src/main/java/org/jboss/netty/buffer/BigEndianHeapChannelBuffer.java
index 1d8ec4bae5ee..a414eba93e26 100644
--- a/src/main/java/org/jboss/netty/buffer/BigEndianHeapChannelBuffer.java
+++ b/src/main/java/org/jboss/netty/buffer/BigEndianHeapChannelBuffer.java
@@ -62,14 +62,14 @@ public short getShort(int index) {
     public int getUnsignedMedium(int index) {
         return  (array[index]     & 0xff) << 16 |
                 (array[index + 1] & 0xff) <<  8 |
+                (array[index + 2] & 0xff) <<  0;
-                (array[index + 2] & 0xff);
     }
 
     public int getInt(int index) {
         return  (array[index]     & 0xff) << 24 |
                 (array[index + 1] & 0xff) << 16 |
                 (array[index + 2] & 0xff) <<  8 |
+                (array[index + 3] & 0xff) <<  0;
-                (array[index + 3] & 0xff);
     }
 
     public long getLong(int index) {
@@ -80,25 +80,25 @@ public long getLong(int index) {
                 ((long) array[index + 4] & 0xff) << 24 |
                 ((long) array[index + 5] & 0xff) << 16 |
                 ((long) array[index + 6] & 0xff) <<  8 |
+                ((long) array[index + 7] & 0xff) <<  0;
-                ((long) array[index + 7] & 0xff);
     }
 
     public void setShort(int index, int value) {
         array[index]     = (byte) (value >>> 8);
+        array[index + 1] = (byte) (value >>> 0);
-        array[index + 1] = (byte) value;
     }
 
     public void setMedium(int index, int   value) {
         array[index]     = (byte) (value >>> 16);
         array[index + 1] = (byte) (value >>> 8);
+        array[index + 2] = (byte) (value >>> 0);
-        array[index + 2] = (byte) value;
     }
 
     public void setInt(int index, int   value) {
         array[index]     = (byte) (value >>> 24);
         array[index + 1] = (byte) (value >>> 16);
         array[index + 2] = (byte) (value >>> 8);
+        array[index + 3] = (byte) (value >>> 0);
-        array[index + 3] = (byte) value;
     }
 
     public void setLong(int index, long  value) {
@@ -109,7 +109,7 @@ public void setLong(int index, long  value) {
         array[index + 4] = (byte) (value >>> 24);
         array[index + 5] = (byte) (value >>> 16);
         array[index + 6] = (byte) (value >>> 8);
+        array[index + 7] = (byte) (value >>> 0);
-        array[index + 7] = (byte) value;
     }
 
     public ChannelBuffer duplicate() {
diff --git a/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java
index bf43cff284e2..eea2dac3aa2d 100644
--- a/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java
+++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java
@@ -99,7 +99,7 @@ public short getShort(int index) {
     public int getUnsignedMedium(int index) {
         return  (getByte(index)     & 0xff) << 16 |
                 (getByte(index + 1) & 0xff) <<  8 |
+                (getByte(index + 2) & 0xff) <<  0;
-                (getByte(index + 2) & 0xff);
     }
 
     public int getInt(int index) {
@@ -158,7 +158,7 @@ public void setShort(int index, int value) {
     public void setMedium(int index, int   value) {
         setByte(index,     (byte) (value >>> 16));
         setByte(index + 1, (byte) (value >>>  8));
+        setByte(index + 2, (byte) (value >>>  0));
-        setByte(index + 2, (byte) value);
     }
 
     public void setInt(int index, int   value) {
diff --git a/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
index 0c5597ce0e6e..8bcd13583d8f 100644
--- a/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
+++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java
@@ -107,8 +107,8 @@ public final class ChannelBuffers {
     static {
         final char[] DIGITS = "0123456789abcdef".toCharArray();
         for (int i = 0; i < 256; i ++) {
+            HEXDUMP_TABLE[(i << 1) + 0] = DIGITS[i >>> 4 & 0x0F];
+            HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i >>> 0 & 0x0F];
-            HEXDUMP_TABLE[i << 1] = DIGITS[i >>> 4 & 0x0F];
-            HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F];
         }
     }
 
diff --git a/src/main/java/org/jboss/netty/buffer/LittleEndianHeapChannelBuffer.java b/src/main/java/org/jboss/netty/buffer/LittleEndianHeapChannelBuffer.java
index a7a2dc05f3a2..4b89ccbd9a01 100644
--- a/src/main/java/org/jboss/netty/buffer/LittleEndianHeapChannelBuffer.java
+++ b/src/main/java/org/jboss/netty/buffer/LittleEndianHeapChannelBuffer.java
@@ -60,20 +60,20 @@ public short getShort(int index) {
     }
 
     public int getUnsignedMedium(int index) {
+        return (array[index]     & 0xff) <<  0 |
-        return (array[index] & 0xff) |
                (array[index + 1] & 0xff) <<  8 |
                (array[index + 2] & 0xff) << 16;
     }
 
     public int getInt(int index) {
+        return (array[index]     & 0xff) <<  0 |
-        return (array[index] & 0xff) |
                (array[index + 1] & 0xff) <<  8 |
                (array[index + 2] & 0xff) << 16 |
                (array[index + 3] & 0xff) << 24;
     }
 
     public long getLong(int index) {
+        return ((long) array[index]     & 0xff) <<  0 |
-        return ((long) array[index] & 0xff) |
                ((long) array[index + 1] & 0xff) <<  8 |
                ((long) array[index + 2] & 0xff) << 16 |
                ((long) array[index + 3] & 0xff) << 24 |
@@ -84,25 +84,25 @@ public long getLong(int index) {
     }
 
     public void setShort(int index, int value) {
+        array[index]     = (byte) (value >>> 0);
-        array[index]     = (byte) value;
         array[index + 1] = (byte) (value >>> 8);
     }
 
     public void setMedium(int index, int   value) {
+        array[index]     = (byte) (value >>> 0);
-        array[index]     = (byte) value;
         array[index + 1] = (byte) (value >>> 8);
         array[index + 2] = (byte) (value >>> 16);
     }
 
     public void setInt(int index, int   value) {
+        array[index]     = (byte) (value >>> 0);
-        array[index]     = (byte) value;
         array[index + 1] = (byte) (value >>> 8);
         array[index + 2] = (byte) (value >>> 16);
         array[index + 3] = (byte) (value >>> 24);
     }
 
     public void setLong(int index, long  value) {
+        array[index]     = (byte) (value >>> 0);
-        array[index]     = (byte) value;
         array[index + 1] = (byte) (value >>> 8);
         array[index + 2] = (byte) (value >>> 16);
         array[index + 3] = (byte) (value >>> 24);
diff --git a/src/main/java/org/jboss/netty/channel/AbstractChannel.java b/src/main/java/org/jboss/netty/channel/AbstractChannel.java
index adb826e62c29..6de954403eea 100644
--- a/src/main/java/org/jboss/netty/channel/AbstractChannel.java
+++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java
@@ -28,7 +28,7 @@ public abstract class AbstractChannel implements Channel {
     static final ConcurrentMap<Integer, Channel> allChannels = new ConcurrentHashMap<Integer, Channel>();
 
     private static Integer allocateId(Channel channel) {
+        Integer id = Integer.valueOf(System.identityHashCode(channel));
-        Integer id = System.identityHashCode(channel);
         for (;;) {
             // Loop until a unique ID is acquired.
             // It should be found in one loop practically.
@@ -37,7 +37,7 @@ private static Integer allocateId(Channel channel) {
                 return id;
             } else {
                 // Taken by other channel at almost the same moment.
+                id = Integer.valueOf(id.intValue() + 1);
-                id = id.intValue() + 1;
             }
         }
     }
diff --git a/src/main/java/org/jboss/netty/channel/Channels.java b/src/main/java/org/jboss/netty/channel/Channels.java
index e2dec2637ba0..46ac56e72abe 100644
--- a/src/main/java/org/jboss/netty/channel/Channels.java
+++ b/src/main/java/org/jboss/netty/channel/Channels.java
@@ -751,7 +751,7 @@ public static ChannelFuture setInterestOps(Channel channel, int interestOps) {
 
         ChannelFuture future = future(channel);
         channel.getPipeline().sendDownstream(new DownstreamChannelStateEvent(
+                channel, future, ChannelState.INTEREST_OPS, Integer.valueOf(interestOps)));
-                channel, future, ChannelState.INTEREST_OPS, interestOps));
         return future;
     }
 
@@ -772,8 +772,7 @@ public static void setInterestOps(
 
         ctx.sendDownstream(
                 new DownstreamChannelStateEvent(
+                        ctx.getChannel(), future, ChannelState.INTEREST_OPS,
+                        Integer.valueOf(interestOps)));
-                        ctx.getChannel(), future, ChannelState.INTEREST_OPS, interestOps));
     }
 
     /**
diff --git a/src/main/java/org/jboss/netty/example/factorial/FactorialClientHandler.java b/src/main/java/org/jboss/netty/example/factorial/FactorialClientHandler.java
index 90deefc2cce9..05d78660d556 100644
--- a/src/main/java/org/jboss/netty/example/factorial/FactorialClientHandler.java
+++ b/src/main/java/org/jboss/netty/example/factorial/FactorialClientHandler.java
@@ -116,7 +116,7 @@ private void sendNumbers(ChannelStateEvent e) {
         Channel channel = e.getChannel();
         while (channel.isWritable()) {
             if (i <= count) {
+                channel.write(Integer.valueOf(i));
-                channel.write(i);
                 i ++;
             } else {
                 break;
diff --git a/src/main/java/org/jboss/netty/example/objectecho/ObjectEchoClientHandler.java b/src/main/java/org/jboss/netty/example/objectecho/ObjectEchoClientHandler.java
index 61b0ef6d26ff..2c868adfe9ba 100644
--- a/src/main/java/org/jboss/netty/example/objectecho/ObjectEchoClientHandler.java
+++ b/src/main/java/org/jboss/netty/example/objectecho/ObjectEchoClientHandler.java
@@ -52,7 +52,7 @@ public ObjectEchoClientHandler(int firstMessageSize) {
         }
         firstMessage = new ArrayList<Integer>(firstMessageSize);
         for (int i = 0; i < firstMessageSize; i ++) {
+            firstMessage.add(Integer.valueOf(i));
-            firstMessage.add(i);
         }
     }
 
diff --git a/src/main/java/org/jboss/netty/handler/codec/embedder/EmbeddedChannel.java b/src/main/java/org/jboss/netty/handler/codec/embedder/EmbeddedChannel.java
index 81e8f307e21b..80a446214ffd 100644
--- a/src/main/java/org/jboss/netty/handler/codec/embedder/EmbeddedChannel.java
+++ b/src/main/java/org/jboss/netty/handler/codec/embedder/EmbeddedChannel.java
@@ -30,7 +30,7 @@
  */
 class EmbeddedChannel extends AbstractChannel {
 
+    private static final Integer DUMMY_ID = Integer.valueOf(0);
-    private static final Integer DUMMY_ID = 0;
 
     private final ChannelConfig config;
     private final SocketAddress localAddress = new EmbeddedSocketAddress();
diff --git a/src/main/java/org/jboss/netty/handler/codec/http/CookieDecoder.java b/src/main/java/org/jboss/netty/handler/codec/http/CookieDecoder.java
index f8638993d1bc..9439f2583f79 100644
--- a/src/main/java/org/jboss/netty/handler/codec/http/CookieDecoder.java
+++ b/src/main/java/org/jboss/netty/handler/codec/http/CookieDecoder.java
@@ -108,7 +108,7 @@ public Set<Cookie> decode(String header) {
             String commentURL = null;
             String domain = null;
             String path = null;
+            int maxAge = -1;
-            int maxAge = Integer.MIN_VALUE;
             List<Integer> ports = new ArrayList<Integer>(2);
 
             for (int j = i + 1; j < names.size(); j++, i++) {
diff --git a/src/main/java/org/jboss/netty/handler/codec/http/DefaultCookie.java b/src/main/java/org/jboss/netty/handler/codec/http/DefaultCookie.java
index cb0a2a974140..47cfe89af77b 100644
--- a/src/main/java/org/jboss/netty/handler/codec/http/DefaultCookie.java
+++ b/src/main/java/org/jboss/netty/handler/codec/http/DefaultCookie.java
@@ -153,7 +153,7 @@ public void setPorts(int... ports) {
                 if (p <= 0 || p > 65535) {
                     throw new IllegalArgumentException("port out of range: " + p);
                 }
+                newPorts.add(Integer.valueOf(p));
-                newPorts.add(p);
             }
             this.ports = newPorts;
             unmodifiablePorts = null;
@@ -166,7 +166,7 @@ public void setPorts(Iterable<Integer> ports) {
             if (p <= 0 || p > 65535) {
                 throw new IllegalArgumentException("port out of range: " + p);
             }
+            newPorts.add(Integer.valueOf(p));
-            newPorts.add(p);
         }
         if (newPorts.isEmpty()) {
             unmodifiablePorts = this.ports = Collections.emptySet();
@@ -181,11 +181,6 @@ public int getMaxAge() {
     }
 
     public void setMaxAge(int maxAge) {
+        if (maxAge < -1) {
+            throw new IllegalArgumentException(
+                    "maxAge must be either -1, 0, or a positive integer: " +
+                    maxAge);
+        }
         this.maxAge = maxAge;
     }
 
diff --git a/src/main/java/org/jboss/netty/handler/codec/http/HttpContentDecoder.java b/src/main/java/org/jboss/netty/handler/codec/http/HttpContentDecoder.java
index abe065839d2c..36d5137a1228 100644
--- a/src/main/java/org/jboss/netty/handler/codec/http/HttpContentDecoder.java
+++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpContentDecoder.java
@@ -18,7 +18,9 @@
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelStateEvent;
 import org.jboss.netty.channel.Channels;
+import org.jboss.netty.channel.LifeCycleAwareChannelHandler;
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
 import org.jboss.netty.handler.codec.embedder.DecoderEmbedder;
@@ -42,7 +44,8 @@
  * so that this handler can intercept HTTP requests after {@link HttpMessageDecoder}
  * converts {@link ChannelBuffer}s into HTTP requests.
  */
-public abstract class HttpContentDecoder extends SimpleChannelUpstreamHandler {
+public abstract class HttpContentDecoder extends SimpleChannelUpstreamHandler
-                                         implements LifeCycleAwareChannelHandler {
 
     private DecoderEmbedder<ChannelBuffer> decoder;
 
@@ -62,7 +65,8 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
         } else if (msg instanceof HttpMessage) {
             HttpMessage m = (HttpMessage) msg;
 
+            decoder = null;
-            // Clean-up the previous decoder if not cleaned up correctly.
-            finishDecode();
 
             // Determine the content encoding.
             String contentEncoding = m.getHeader(HttpHeaders.Names.CONTENT_ENCODING);
@@ -131,6 +135,14 @@ public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Ex
         }
     }
 
-    @Override
-    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
-        // Clean-up the previous decoder if not cleaned up correctly.
-        finishDecode();
+
-        super.channelClosed(ctx, e);
-    }
+
     /**
      * Returns a new {@link DecoderEmbedder} that decodes the HTTP message
      * content encoded in the specified <tt>contentEncoding</tt>.
@@ -160,6 +172,10 @@ private ChannelBuffer decode(ChannelBuffer buf) {
     }
 
     private ChannelBuffer finishDecode() {
-        if (decoder == null) {
-            return ChannelBuffers.EMPTY_BUFFER;
-        }
+
         ChannelBuffer result;
         if (decoder.finish()) {
             result = ChannelBuffers.wrappedBuffer(decoder.pollAll(new ChannelBuffer[decoder.size()]));
@@ -169,4 +185,20 @@ private ChannelBuffer finishDecode() {
         decoder = null;
         return result;
     }
+
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
-        // NOOP
-    }
+
-    public void afterAdd(ChannelHandlerContext ctx) throws Exception {
-        // NOOP
-    }
+
-    public void beforeRemove(ChannelHandlerContext ctx) throws Exception {
-        // NOOP
-    }
+
-    public void afterRemove(ChannelHandlerContext ctx) throws Exception {
-        finishDecode();
-    }
 }
diff --git a/src/main/java/org/jboss/netty/handler/codec/http/HttpContentEncoder.java b/src/main/java/org/jboss/netty/handler/codec/http/HttpContentEncoder.java
index e570b137ccaa..184ff6b0d8c7 100644
--- a/src/main/java/org/jboss/netty/handler/codec/http/HttpContentEncoder.java
+++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpContentEncoder.java
@@ -21,7 +21,9 @@
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.buffer.ChannelBuffers;
 import org.jboss.netty.channel.ChannelHandlerContext;
+import org.jboss.netty.channel.ChannelStateEvent;
 import org.jboss.netty.channel.Channels;
+import org.jboss.netty.channel.LifeCycleAwareChannelHandler;
 import org.jboss.netty.channel.MessageEvent;
 import org.jboss.netty.channel.SimpleChannelHandler;
 import org.jboss.netty.handler.codec.embedder.EncoderEmbedder;
@@ -47,7 +49,8 @@
  * so that this handler can intercept HTTP responses before {@link HttpMessageEncoder}
  * converts them into {@link ChannelBuffer}s.
  */
-public abstract class HttpContentEncoder extends SimpleChannelHandler {
+public abstract class HttpContentEncoder extends SimpleChannelHandler
-                                         implements LifeCycleAwareChannelHandler {
 
     private final Queue<String> acceptEncodingQueue = new ConcurrentLinkedQueue<String>();
     private volatile EncoderEmbedder<ChannelBuffer> encoder;
@@ -90,7 +93,8 @@ public void writeRequested(ChannelHandlerContext ctx, MessageEvent e)
         } else  if (msg instanceof HttpMessage) {
             HttpMessage m = (HttpMessage) msg;
 
+            encoder = null;
-            // Clean-up the previous encoder if not cleaned up correctly.
-            finishEncode();
 
             String acceptEncoding = acceptEncodingQueue.poll();
             if (acceptEncoding == null) {
@@ -165,6 +169,14 @@ public void writeRequested(ChannelHandlerContext ctx, MessageEvent e)
         }
     }
 
-    @Override
-    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
-        // Clean-up the previous encoder if not cleaned up correctly.
-        finishEncode();
+
-        super.channelClosed(ctx, e);
-    }
+
     /**
      * Returns a new {@link EncoderEmbedder} that encodes the HTTP message
      * content.
@@ -192,6 +204,10 @@ private ChannelBuffer encode(ChannelBuffer buf) {
     }
 
     private ChannelBuffer finishEncode() {
-        if (encoder == null) {
-            return ChannelBuffers.EMPTY_BUFFER;
-        }
+
         ChannelBuffer result;
         if (encoder.finish()) {
             result = ChannelBuffers.wrappedBuffer(encoder.pollAll(new ChannelBuffer[encoder.size()]));
@@ -201,4 +217,20 @@ private ChannelBuffer finishEncode() {
         encoder = null;
         return result;
     }
+
-    public void beforeAdd(ChannelHandlerContext ctx) throws Exception {
-        // NOOP
-    }
+
-    public void afterAdd(ChannelHandlerContext ctx) throws Exception {
-        // NOOP
-    }
+
-    public void beforeRemove(ChannelHandlerContext ctx) throws Exception {
-        // NOOP
-    }
+
-    public void afterRemove(ChannelHandlerContext ctx) throws Exception {
-        finishEncode();
-    }
 }
diff --git a/src/main/java/org/jboss/netty/handler/codec/http/HttpMessageEncoder.java b/src/main/java/org/jboss/netty/handler/codec/http/HttpMessageEncoder.java
index 6dcb3694bfac..27a51b0e188c 100644
--- a/src/main/java/org/jboss/netty/handler/codec/http/HttpMessageEncoder.java
+++ b/src/main/java/org/jboss/netty/handler/codec/http/HttpMessageEncoder.java
@@ -50,7 +50,7 @@ public abstract class HttpMessageEncoder extends OneToOneEncoder {
     private static final ChannelBuffer LAST_CHUNK =
         copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII);
 
+    private volatile boolean chunked;
-    private volatile boolean transferEncodingChunked;
 
     /**
      * Creates a new instance.
@@ -63,11 +63,12 @@ protected HttpMessageEncoder() {
     protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws Exception {
         if (msg instanceof HttpMessage) {
             HttpMessage m = (HttpMessage) msg;
+            boolean chunked;
-            boolean contentMustBeEmpty;
             if (m.isChunked()) {
                 // if Content-Length is set then the message can't be HTTP chunked
                 if (HttpCodecUtil.isContentLengthSet(m)) {
+                    chunked = this.chunked = false;
-                    contentMustBeEmpty = false;
-                    transferEncodingChunked = false;
                     HttpCodecUtil.removeTransferEncodingChunked(m);
                 } else {
                     // check if the Transfer-Encoding is set to chunked already.
@@ -75,11 +76,13 @@ protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)
                     if (!HttpCodecUtil.isTransferEncodingChunked(m)) {
                         m.addHeader(Names.TRANSFER_ENCODING, Values.CHUNKED);
                     }
+                    chunked = this.chunked = true;
-                    contentMustBeEmpty = true;
-                    transferEncodingChunked = true;
                 }
             } else {
+                chunked = this.chunked = HttpCodecUtil.isTransferEncodingChunked(m);
-                transferEncodingChunked = contentMustBeEmpty = HttpCodecUtil.isTransferEncodingChunked(m);
             }
+
             ChannelBuffer header = ChannelBuffers.dynamicBuffer(
                     channel.getConfig().getBufferFactory());
             encodeInitialLine(header, m);
@@ -90,7 +93,7 @@ protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)
             ChannelBuffer content = m.getContent();
             if (!content.readable()) {
                 return header; // no content
+            } else if (chunked) {
-            } else if (contentMustBeEmpty) {
                 throw new IllegalArgumentException(
                         "HttpMessage.content must be empty " +
                         "if Transfer-Encoding is chunked.");
@@ -101,9 +104,9 @@ protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg)
 
         if (msg instanceof HttpChunk) {
             HttpChunk chunk = (HttpChunk) msg;
+            if (chunked) {
-            if (transferEncodingChunked) {
                 if (chunk.isLast()) {
+                    chunked = false;
-                    transferEncodingChunked = false;
                     if (chunk instanceof HttpChunkTrailer) {
                         ChannelBuffer trailer = ChannelBuffers.dynamicBuffer(
                                 channel.getConfig().getBufferFactory());
diff --git a/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestEncoder.java b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestEncoder.java
index 23db3d4f370b..a378733e29cf 100644
--- a/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestEncoder.java
+++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestEncoder.java
@@ -32,7 +32,7 @@ protected void encodeInitialLine(ChannelBuffer buf, HttpMessage message)
         HttpRequest request = (HttpRequest) message;
         buf.writeBytes(request.getMethod().toString().getBytes("ASCII"));
         buf.writeByte((byte) ' ');
+        buf.writeBytes(request.getUri().getBytes("ASCII"));
-        buf.writeBytes(request.getUri().getBytes("UTF-8"));
         buf.writeByte((byte) ' ');
         buf.writeBytes(request.getProtocolVersion().toString().getBytes("ASCII"));
         buf.writeByte((byte) '\r');
diff --git a/src/main/java/org/jboss/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java b/src/main/java/org/jboss/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
index d0c7177fa59f..7282757d55ab 100644
--- a/src/main/java/org/jboss/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
+++ b/src/main/java/org/jboss/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
@@ -44,12 +44,12 @@ public Set<Integer> getIds() {
     }
 
     public boolean isSet(int ID) {
+        Integer key = new Integer(ID);
-        Integer key = ID;
         return settingsMap.containsKey(key);
     }
 
     public int getValue(int ID) {
+        Integer key = new Integer(ID);
-        Integer key = ID;
         if (settingsMap.containsKey(key)) {
             return settingsMap.get(key).getValue();
         } else {
@@ -65,7 +65,7 @@ public void setValue(int ID, int value, boolean persistValue, boolean persisted)
         if (ID <= 0 || ID > SpdyCodecUtil.SPDY_SETTINGS_MAX_ID) {
             throw new IllegalArgumentException("Setting ID is not valid: " + ID);
         }
+        Integer key = new Integer(ID);
-        Integer key = ID;
         if (settingsMap.containsKey(key)) {
             Setting setting = settingsMap.get(key);
             setting.setValue(value);
@@ -77,7 +77,7 @@ public void setValue(int ID, int value, boolean persistValue, boolean persisted)
     }
 
     public void removeValue(int ID) {
+        Integer key = new Integer(ID);
-        Integer key = ID;
         if (settingsMap.containsKey(key)) {
             settingsMap.remove(key);
         }
@@ -88,7 +88,7 @@ public boolean persistValue(int ID) {
     }
 
     public boolean isPersistValue(int ID) {
+        Integer key = new Integer(ID);
-        Integer key = ID;
         if (settingsMap.containsKey(key)) {
             return settingsMap.get(key).isPersist();
         } else {
@@ -97,14 +97,14 @@ public boolean isPersistValue(int ID) {
     }
 
     public void setPersistValue(int ID, boolean persistValue) {
+        Integer key = new Integer(ID);
-        Integer key = ID;
         if (settingsMap.containsKey(key)) {
             settingsMap.get(key).setPersist(persistValue);
         }
     }
 
     public boolean isPersisted(int ID) {
+        Integer key = new Integer(ID);
-        Integer key = ID;
         if (settingsMap.containsKey(key)) {
             return settingsMap.get(key).isPersisted();
         } else {
@@ -113,7 +113,7 @@ public boolean isPersisted(int ID) {
     }
 
     public void setPersisted(int ID, boolean persisted) {
+        Integer key = new Integer(ID);
-        Integer key = ID;
         if (settingsMap.containsKey(key)) {
             settingsMap.get(key).setPersisted(persisted);
         }
diff --git a/src/main/java/org/jboss/netty/handler/codec/spdy/SpdyFrameEncoder.java b/src/main/java/org/jboss/netty/handler/codec/spdy/SpdyFrameEncoder.java
index 2c8ca87ecb39..d8bdd9b62c0b 100644
--- a/src/main/java/org/jboss/netty/handler/codec/spdy/SpdyFrameEncoder.java
+++ b/src/main/java/org/jboss/netty/handler/codec/spdy/SpdyFrameEncoder.java
@@ -246,7 +246,7 @@ public void run() {
                     // Chromium Issue 79156
                     // SPDY setting ids are not written in network byte order
                     // Write id assuming the architecture is little endian
+                    frame.writeByte(id >>  0 & 0xFF);
-                    frame.writeByte(id & 0xFF);
                     frame.writeByte(id >>  8 & 0xFF);
                     frame.writeByte(id >> 16 & 0xFF);
                     frame.writeByte(ID_flags);
diff --git a/src/main/java/org/jboss/netty/handler/codec/spdy/SpdyHttpDecoder.java b/src/main/java/org/jboss/netty/handler/codec/spdy/SpdyHttpDecoder.java
index cf50bb3bef7d..24ea5bc59394 100644
--- a/src/main/java/org/jboss/netty/handler/codec/spdy/SpdyHttpDecoder.java
+++ b/src/main/java/org/jboss/netty/handler/codec/spdy/SpdyHttpDecoder.java
@@ -127,7 +127,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
                         return httpResponse;
                     } else {
                         // Response body will follow in a series of Data Frames
+                        messageMap.put(new Integer(streamID), httpResponse);
-                        messageMap.put(streamID, httpResponse);
                     }
                 } catch (Exception e) {
                     SpdyRstStreamFrame spdyRstStreamFrame =
@@ -147,7 +147,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
                         return httpRequest;
                     } else {
                         // Request body will follow in a series of Data Frames
+                        messageMap.put(new Integer(streamID), httpRequest);
-                        messageMap.put(streamID, httpRequest);
                     }
                 } catch (Exception e) {
                     // If a client sends a SYN_STREAM without all of the method, url (host and path),
@@ -177,7 +177,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
                     return httpResponse;
                 } else {
                     // Response body will follow in a series of Data Frames
+                    messageMap.put(new Integer(streamID), httpResponse);
-                    messageMap.put(streamID, httpResponse);
                 }
             } catch (Exception e) {
                 // If a client receives a SYN_REPLY without valid status and version headers
@@ -190,7 +190,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
         } else if (msg instanceof SpdyHeadersFrame) {
 
             SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
+            Integer streamID = new Integer(spdyHeadersFrame.getStreamId());
-            Integer streamID = spdyHeadersFrame.getStreamId();
             HttpMessage httpMessage = messageMap.get(streamID);
 
             // If message is not in map discard HEADERS frame.
@@ -206,7 +206,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
         } else if (msg instanceof SpdyDataFrame) {
 
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
+            Integer streamID = new Integer(spdyDataFrame.getStreamId());
-            Integer streamID = spdyDataFrame.getStreamId();
             HttpMessage httpMessage = messageMap.get(streamID);
 
             // If message is not in map discard Data Frame.
@@ -239,7 +239,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, Object msg)
         } else if (msg instanceof SpdyRstStreamFrame) {
 
             SpdyRstStreamFrame spdyRstStreamFrame = (SpdyRstStreamFrame) msg;
+            Integer streamID = new Integer(spdyRstStreamFrame.getStreamId());
-            Integer streamID = spdyRstStreamFrame.getStreamId();
             messageMap.remove(streamID);
         }
 
diff --git a/src/main/java/org/jboss/netty/handler/codec/spdy/SpdySession.java b/src/main/java/org/jboss/netty/handler/codec/spdy/SpdySession.java
index d588b2f3af89..11de8d63912d 100644
--- a/src/main/java/org/jboss/netty/handler/codec/spdy/SpdySession.java
+++ b/src/main/java/org/jboss/netty/handler/codec/spdy/SpdySession.java
@@ -44,7 +44,7 @@ boolean noActiveStreams() {
     }
 
     boolean isActiveStream(int streamID) {
+        return activeStreams.containsKey(new Integer(streamID));
-        return activeStreams.containsKey(streamID);
     }
 
     // Stream-IDs should be iterated in priority order
@@ -59,13 +59,13 @@ void acceptStream(
             int sendWindowSize, int receiveWindowSize) {
         if (!remoteSideClosed || !localSideClosed) {
             activeStreams.put(
+                    new Integer(streamID),
-                    streamID,
                     new StreamState(priority, remoteSideClosed, localSideClosed, sendWindowSize, receiveWindowSize));
         }
     }
 
     void removeStream(int streamID) {
+        Integer StreamID = new Integer(streamID);
-        Integer StreamID = streamID;
         StreamState state = activeStreams.get(StreamID);
         activeStreams.remove(StreamID);
         if (state != null) {
@@ -78,12 +78,12 @@ void removeStream(int streamID) {
     }
 
     boolean isRemoteSideClosed(int streamID) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state == null || state.isRemoteSideClosed();
     }
 
     void closeRemoteSide(int streamID) {
+        Integer StreamID = new Integer(streamID);
-        Integer StreamID = streamID;
         StreamState state = activeStreams.get(StreamID);
         if (state != null) {
             state.closeRemoteSide();
@@ -94,12 +94,12 @@ void closeRemoteSide(int streamID) {
     }
 
     boolean isLocalSideClosed(int streamID) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state == null || state.isLocalSideClosed();
     }
 
     void closeLocalSide(int streamID) {
+        Integer StreamID = new Integer(streamID);
-        Integer StreamID = streamID;
         StreamState state = activeStreams.get(StreamID);
         if (state != null) {
             state.closeLocalSide();
@@ -115,29 +115,29 @@ void closeLocalSide(int streamID) {
      */
 
     boolean hasReceivedReply(int streamID) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state != null && state.hasReceivedReply();
     }
 
     void receivedReply(int streamID) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         if (state != null) {
             state.receivedReply();
         }
     }
 
     int getSendWindowSize(int streamID) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state != null ? state.getSendWindowSize() : -1;
     }
 
     int updateSendWindowSize(int streamID, int deltaWindowSize) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state != null ? state.updateSendWindowSize(deltaWindowSize) : -1;
     }
 
     int updateReceiveWindowSize(int streamID, int deltaWindowSize) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         if (deltaWindowSize > 0) {
             state.setReceiveWindowSizeLowerBound(0);
         }
@@ -145,7 +145,7 @@ int updateReceiveWindowSize(int streamID, int deltaWindowSize) {
     }
 
     int getReceiveWindowSizeLowerBound(int streamID) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state != null ? state.getReceiveWindowSizeLowerBound() : 0;
     }
 
@@ -159,17 +159,17 @@ void updateAllReceiveWindowSizes(int deltaWindowSize) {
     }
 
     boolean putPendingWrite(int streamID, MessageEvent evt) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state != null && state.putPendingWrite(evt);
     }
 
     MessageEvent getPendingWrite(int streamID) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state != null ? state.getPendingWrite() : null;
     }
 
     MessageEvent removePendingWrite(int streamID) {
+        StreamState state = activeStreams.get(new Integer(streamID));
-        StreamState state = activeStreams.get(streamID);
         return state != null ? state.removePendingWrite() : null;
     }
 
diff --git a/src/main/java/org/jboss/netty/handler/ipfilter/CIDR.java b/src/main/java/org/jboss/netty/handler/ipfilter/CIDR.java
index 2f15b2e29548..7e1d21479969 100644
--- a/src/main/java/org/jboss/netty/handler/ipfilter/CIDR.java
+++ b/src/main/java/org/jboss/netty/handler/ipfilter/CIDR.java
@@ -195,7 +195,7 @@ private static int parseInt(String intstr, int def) {
         try {
             res = Integer.decode(intstr);
         } catch (Exception e) {
+            res = new Integer(def);
-            res = def;
         }
         return res.intValue();
     }
diff --git a/src/main/java/org/jboss/netty/handler/ssl/SslHandler.java b/src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
index c4e1755b6e2b..3a313758489a 100644
--- a/src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
+++ b/src/main/java/org/jboss/netty/handler/ssl/SslHandler.java
@@ -206,6 +206,8 @@ public static synchronized SslBufferPool getDefaultBufferPool() {
 
     private final SSLEngineInboundCloseFuture sslEngineCloseFuture = new SSLEngineInboundCloseFuture();
 
-    private boolean closeOnSSLException;
+
     /**
      * Creates a new instance.
      *
@@ -372,9 +374,15 @@ public ChannelFuture handshake() {
                 handshakeFuture.setFailure(e);
 
                 fireExceptionCaught(ctx, e);
-                if (closeOnSSLException) {
-                    Channels.close(ctx, future(channel));
-                }
             }
         } else { // Failed to initiate handshake.
             fireExceptionCaught(ctx, exception);
-            if (closeOnSSLException) {
-                Channels.close(ctx, future(channel));
-            }
         }
 
         return handshakeFuture;
@@ -400,6 +408,9 @@ public ChannelFuture close() {
             return wrapNonAppData(ctx, channel);
         } catch (SSLException e) {
             fireExceptionCaught(ctx, e);
-            if (closeOnSSLException) {
-                Channels.close(ctx, future(channel));
-            }
             return failedFuture(channel, e);
         }
     }
@@ -455,6 +466,25 @@ public ChannelFuture getSSLEngineInboundCloseFuture() {
 
     }
 
-    /**
-     * If set to <code>true</code>, the {@link Channel} will automatically get closed
-     * one a {@link SSLException} was caught. This is most times what you want, as after this
-     * its almost impossible to recover.
-     *
-     * Anyway the default is <code>false</code> to not break compatibility with older releases. This
-     * will be changed to <code>true</code> in the next major release.
-     *
-     */
-    public void setCloseOnSSLException(boolean closeOnSslException) {
-        if (ctx != null) {
-            throw new IllegalStateException("Can only get changed before attached to ChannelPipeline");
-        }
-        this.closeOnSSLException = closeOnSslException;
-    }
+
-    public boolean getCloseOnSSLException() {
-        return closeOnSSLException;
-    }
 
     public void handleDownstream(
             final ChannelHandlerContext context, final ChannelEvent evt) throws Exception {
@@ -696,7 +726,17 @@ protected Object decode(
                 NotSslRecordException e = new NotSslRecordException(
                         "not an SSL/TLS record: " + ChannelBuffers.hexDump(buffer));
                 buffer.skipBytes(buffer.readableBytes());
+                throw e;
-                if (closeOnSSLException) {
-                    // first trigger the exception and then close the channel
-                    fireExceptionCaught(ctx, e);
-                    Channels.close(ctx, future(channel));
+
-                    // just return null as we closed the channel before, that
-                    // will take care of cleanup etc
-                    return null;
-                } else {
-                    throw e;
-                }
             }
         }
 
@@ -1208,6 +1248,9 @@ private void setHandshakeFailure(Channel channel, SSLException cause) {
         }
 
         handshakeFuture.setFailure(cause);
-        if (closeOnSSLException) {
-            Channels.close(ctx, future(channel));
-        }
     }
 
     private void closeOutboundAndChannel(
diff --git a/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java b/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java
index ff591b77dc0d..22574807b637 100644
--- a/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java
+++ b/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java
@@ -309,8 +309,13 @@ private void initialize(ChannelHandlerContext ctx) {
 
         // Avoid the case where destroy() is called before scheduling timeouts.
         // See: https://github.com/netty/netty/issues/143
+        if (state.destroyed) {
+            return;
-        synchronized (state) {
-            switch (state.state) {
-            case 1:
-            case 2:
-                return;
-            }
-            state.state = 1;
         }
 
         state.lastReadTime = state.lastWriteTime = System.currentTimeMillis();
@@ -332,11 +337,12 @@ private void initialize(ChannelHandlerContext ctx) {
     }
 
     private static void destroy(ChannelHandlerContext ctx) {
+        State state;
-
+        synchronized (ctx) {
+            state = state(ctx);
+            state.destroyed = true;
-        State state = state(ctx);
-        synchronized (state) {
-            if (state.state != 1) {
-                return;
-            }
-            state.state = 2;
         }
 
         if (state.readerIdleTimeout != null) {
@@ -478,9 +484,8 @@ public void run(Timeout timeout) throws Exception {
     }
 
     private static final class State {
+        State() {
+            super();
+        }
-        // 0 - none, 1 - initialized, 2 - destroyed
-        int state;
 
         volatile Timeout readerIdleTimeout;
         volatile long lastReadTime;
@@ -490,6 +495,8 @@ private static final class State {
 
         volatile Timeout allIdleTimeout;
 
+        volatile boolean destroyed;
-        State() {
-            super();
-        }
     }
 }
diff --git a/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java b/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java
index 64d56794b13b..1b5be683a599 100644
--- a/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java
+++ b/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java
@@ -189,8 +189,13 @@ private void initialize(ChannelHandlerContext ctx) {
 
         // Avoid the case where destroy() is called before scheduling timeouts.
         // See: https://github.com/netty/netty/issues/143
+        if (state.destroyed) {
+            return;
-        synchronized (state) {
-            switch (state.state) {
-            case 1:
-            case 2:
-                return;
-            }
-            state.state = 1;
         }
 
         if (timeoutMillis > 0) {
@@ -199,10 +204,12 @@ private void initialize(ChannelHandlerContext ctx) {
     }
 
     private static void destroy(ChannelHandlerContext ctx) {
+        State state;
+        synchronized (ctx) {
+            state = state(ctx);
+            state.destroyed = true;
-        State state = state(ctx);
-        synchronized (state) {
-            if (state.state != 1) {
-                return;
-            }
-            state.state = 2;
         }
 
         if (state.timeout != null) {
@@ -269,9 +276,10 @@ public void run(Timeout timeout) throws Exception {
     }
 
     private static final class State {
-        // 0 - none, 1 - initialized, 2 - destroyed
-        int state;
         volatile Timeout timeout;
         volatile long lastReadTime = System.currentTimeMillis();
+        volatile boolean destroyed;
 
         State() {
             super();
diff --git a/src/test/java/org/jboss/netty/handler/codec/http/CookieDecoderTest.java b/src/test/java/org/jboss/netty/handler/codec/http/CookieDecoderTest.java
index 694b5b208368..9ca9b727bedf 100644
--- a/src/test/java/org/jboss/netty/handler/codec/http/CookieDecoderTest.java
+++ b/src/test/java/org/jboss/netty/handler/codec/http/CookieDecoderTest.java
@@ -207,7 +207,7 @@ public void testDecodingClientSideCookies() {
         assertNull(c.getCommentUrl());
         assertNull(c.getDomain());
         assertTrue(c.getPorts().isEmpty());
+        assertEquals(-1, c.getMaxAge());
-        assertEquals(Integer.MIN_VALUE, c.getMaxAge());
 
         c = it.next();
         assertEquals(1, c.getVersion());
@@ -218,7 +218,7 @@ public void testDecodingClientSideCookies() {
         assertNull(c.getCommentUrl());
         assertNull(c.getDomain());
         assertTrue(c.getPorts().isEmpty());
+        assertEquals(-1, c.getMaxAge());
-        assertEquals(Integer.MIN_VALUE, c.getMaxAge());
 
         assertFalse(it.hasNext());
     }
@@ -243,7 +243,7 @@ public void testDecodingCommaSeparatedClientSideCookies() {
         assertNull(c.getCommentUrl());
         assertNull(c.getDomain());
         assertTrue(c.getPorts().isEmpty());
+        assertEquals(-1, c.getMaxAge());
-        assertEquals(Integer.MIN_VALUE, c.getMaxAge());
 
         assertTrue(it.hasNext());
         c = it.next();
@@ -255,7 +255,7 @@ public void testDecodingCommaSeparatedClientSideCookies() {
         assertNull(c.getComment());
         assertNull(c.getCommentUrl());
         assertTrue(c.getPorts().isEmpty());
+        assertEquals(-1, c.getMaxAge());
-        assertEquals(Integer.MIN_VALUE, c.getMaxAge());
 
         assertFalse(it.hasNext());
     }