diff --git a/pom.xml b/pom.xml
index dffda1a9..99097aba 100644
--- a/pom.xml
+++ b/pom.xml
@@ -8,7 +8,8 @@
   <modelVersion>4.0.0</modelVersion>
   <artifactId>plexus-utils</artifactId>
   <name>Plexus Common Utilities</name>
-  <version>1.4.2-SNAPSHOT</version>
+  <version>1.4.3</version>
+  <url>http://plexus.codehaus.org/plexus-utils</url>
   <build>
     <plugins>
       <plugin>
@@ -28,14 +29,24 @@
             <exclude>org/codehaus/plexus/util/FileBasedTestCase.java</exclude>
             <exclude>**/Test*.java</exclude>
           </excludes>
+          <systemProperties>
+            <property>
+              <name>JAVA_HOME</name>
+              <value>${JAVA_HOME}</value>    
+            </property>
+            <property>
+              <name>M2_HOME</name>
+              <value>${M2_HOME}</value>    
+            </property>                      
+          </systemProperties>          
         </configuration>
       </plugin>
     </plugins>
   </build>
   <scm> 
-    <connection>scm:svn:http://svn.codehaus.org/plexus/plexus-utils/trunk/</connection>
-    <developerConnection>scm:svn:https://svn.codehaus.org/plexus/plexus-utils/trunk</developerConnection> 
-    <url>http://fisheye.codehaus.org/browse/plexus/plexus-utils/trunk/</url>
+    <connection>scm:svn:http://svn.codehaus.org/plexus/plexus-utils/tags/plexus-utils-1.4.3</connection>
+    <developerConnection>scm:svn:https://svn.codehaus.org/plexus/plexus-utils/tags/plexus-utils-1.4.3</developerConnection> 
+    <url>http://fisheye.codehaus.org/browse/plexus/plexus-utils/tags/plexus-utils-1.4.3</url>
   </scm>
   <reporting>
     <plugins>
diff --git a/src/main/java/org/codehaus/plexus/util/FileUtils.java b/src/main/java/org/codehaus/plexus/util/FileUtils.java
index b8478433..62a9e2d0 100644
--- a/src/main/java/org/codehaus/plexus/util/FileUtils.java
+++ b/src/main/java/org/codehaus/plexus/util/FileUtils.java
@@ -388,7 +388,7 @@ public static void fileWrite( String fileName, String encoding, String data )
             else
             {
                 out.write( data.getBytes() );
-            }                    
+            }
         }
         finally
         {
@@ -1205,7 +1205,7 @@ public static void forceDelete( final String file )
     public static void forceDelete( final File file )
         throws IOException
     {
-        if ( !file.exists() )
+        if ( !( file.exists() || file.getAbsoluteFile().exists() || file.getCanonicalFile().exists() ) )
         {
             return;
         }
@@ -1241,6 +1241,7 @@ private static boolean deleteFile( File file )
         {
             if ( System.getProperty( "os.name" ).toLowerCase().indexOf( "windows" ) > -1 )
             {
+                file = file.getCanonicalFile();
                 System.gc();
             }
 
@@ -1948,31 +1949,32 @@ public static abstract class FilterWrapper
     {
         public abstract Reader getReader( Reader fileReader );
     }
-    
-    public static List loadFile( File file ) throws IOException
+
+    public static List loadFile( File file )
+        throws IOException
     {
-                List lines = new ArrayList();
-            
-                if ( file.exists() )
+        List lines = new ArrayList();
+
+        if ( file.exists() )
         {
-                        BufferedReader reader = new BufferedReader( new FileReader( file ) );
-               
-                        String line = reader.readLine();
-               
-                        while ( line != null )
+            BufferedReader reader = new BufferedReader( new FileReader( file ) );
+
+            String line = reader.readLine();
+
+            while ( line != null )
             {
-                                line = line.trim();
-                   
-                                if ( !line.startsWith( "#" ) && line.length() != 0 )
+                line = line.trim();
+
+                if ( !line.startsWith( "#" ) && line.length() != 0 )
                 {
-                                        lines.add ( line );
+                    lines.add( line );
                 }
-                                line = reader.readLine();
+                line = reader.readLine();
             }
-               
-                        reader.close();
+
+            reader.close();
         }
-            
-                return lines;
+
+        return lines;
     }
 }
diff --git a/src/main/java/org/codehaus/plexus/util/Os.java b/src/main/java/org/codehaus/plexus/util/Os.java
index c68eee33..1eb5b80c 100644
--- a/src/main/java/org/codehaus/plexus/util/Os.java
+++ b/src/main/java/org/codehaus/plexus/util/Os.java
@@ -54,34 +54,70 @@
 
 package org.codehaus.plexus.util;
 
+import java.util.HashSet;
+import java.util.Iterator;
 import java.util.Locale;
+import java.util.Set;
 
 /**
  * Condition that tests the OS type.
  *
  * @author Stefan Bodewig
  * @author Magesh Umasankar
- * @since Ant 1.4
+ * @author Brian Fox
+ * @since 1.0
  * @version $Revision$
  */
 public class Os
 {
-    private static final String OS_NAME = System.getProperty( "os.name" ).toLowerCase( Locale.US );
+    // define the families for easier reference
+    public static final String FAMILY_DOS = "dos";
 
-    private static final String OS_ARCH = System.getProperty( "os.arch" ).toLowerCase( Locale.US );
+    public static final String FAMILY_MAC = "mac";
 
-    private static final String OS_VERSION = System.getProperty( "os.version" ).toLowerCase( Locale.US );
+    public static final String FAMILY_NETWARE = "netware";
 
+    public static final String FAMILY_OS2 = "os/2";
+
+    public static final String FAMILY_TANDEM = "tandem";
+
+    public static final String FAMILY_UNIX = "unix";
+
+    public static final String FAMILY_WINDOWS = "windows";
+
+    public static final String FAMILY_WIN9X = "win9x";
+
+    public static final String FAMILY_ZOS = "z/os";
+
+    public static final String FAMILY_OS400 = "os/400";
+
+    public static final String FAMILY_OPENVMS = "openvms";
+
+    // store the valid families
+    private static final Set validFamilies = setValidFamilies();
+
+    // get the current info
     private static final String PATH_SEP = System.getProperty( "path.separator" );
 
+    public static final String OS_NAME = System.getProperty( "os.name" ).toLowerCase( Locale.US );
+
+    public static final String OS_ARCH = System.getProperty( "os.arch" ).toLowerCase( Locale.US );
+
+    public static final String OS_VERSION = System.getProperty( "os.version" ).toLowerCase( Locale.US );
+
+    // Make sure this method is called after static fields it depends on have been set!
+    public static final String OS_FAMILY = getOsFamily();
+
     private String family;
+
     private String name;
+
     private String version;
+
     private String arch;
 
     /**
      * Default constructor
-     *
      */
     public Os()
     {
@@ -89,7 +125,7 @@ public Os()
 
     /**
      * Constructor that sets the family attribute
-     *
+     * 
      * @param family a String value
      */
     public Os( String family )
@@ -97,23 +133,45 @@ public Os( String family )
         setFamily( family );
     }
 
+    /**
+     * Initializes the set of valid families.
+     */
+    private static Set setValidFamilies()
+    {
+        Set valid = new HashSet();
+        valid.add( FAMILY_DOS );
+        valid.add( FAMILY_MAC );
+        valid.add( FAMILY_NETWARE );
+        valid.add( FAMILY_OS2 );
+        valid.add( FAMILY_TANDEM );
+        valid.add( FAMILY_UNIX );
+        valid.add( FAMILY_WINDOWS );
+        valid.add( FAMILY_WIN9X );
+        valid.add( FAMILY_ZOS );
+        valid.add( FAMILY_OS400 );
+        valid.add( FAMILY_OPENVMS );
+
+        return valid;
+    }
+
     /**
      * Sets the desired OS family type
-     *
-     * @param f      The OS family type desired<br />
-     *               Possible values:<br />
-     *               <ul>
-     *               <li>dos</li>
-     *               <li>mac</li>
-     *               <li>netware</li>
-     *               <li>os/2</li>
-     *               <li>tandem</li>
-     *               <li>unix</li>
-     *               <li>windows</li>
-     *               <li>win9x</li>
-     *               <li>z/os</li>
-     *               <li>os/400</li>
-     *               </ul>
+     * 
+     * @param f The OS family type desired<br />
+     *            Possible values:<br />
+     *            <ul>
+     *            <li>dos</li>
+     *            <li>mac</li>
+     *            <li>netware</li>
+     *            <li>os/2</li>
+     *            <li>tandem</li>
+     *            <li>unix</li>
+     *            <li>windows</li>
+     *            <li>win9x</li>
+     *            <li>z/os</li>
+     *            <li>os/400</li>
+     *            <li>openvms</li>
+     *            </ul>
      */
     public void setFamily( String f )
     {
@@ -122,8 +180,8 @@ public void setFamily( String f )
 
     /**
      * Sets the desired OS name
-     *
-     * @param name   The OS name
+     * 
+     * @param name The OS name
      */
     public void setName( String name )
     {
@@ -132,8 +190,8 @@ public void setName( String name )
 
     /**
      * Sets the desired OS architecture
-     *
-     * @param arch   The OS architecture
+     * 
+     * @param arch The OS architecture
      */
     public void setArch( String arch )
     {
@@ -142,8 +200,8 @@ public void setArch( String arch )
 
     /**
      * Sets the desired OS version
-     *
-     * @param version   The OS version
+     * 
+     * @param version The OS version
      */
     public void setVersion( String version )
     {
@@ -151,21 +209,24 @@ public void setVersion( String version )
     }
 
     /**
-     * Determines if the OS on which Ant is executing matches the type of
-     * that set in setFamily.
+     * Determines if the current OS matches the type of that
+     * set in setFamily.
+     * 
      * @see Os#setFamily(String)
      */
-    public boolean eval() throws Exception
+    public boolean eval()
+        throws Exception
     {
         return isOs( family, name, arch, version );
     }
 
     /**
-     * Determines if the OS on which Ant is executing matches the
-     * given OS family.
+     * Determines if the current OS matches the given OS
+     * family.
+     * 
      * @param family the family to check for
      * @return true if the OS matches
-     * @since 1.5
+     * @since 1.0
      */
     public static boolean isFamily( String family )
     {
@@ -173,12 +234,12 @@ public static boolean isFamily( String family )
     }
 
     /**
-     * Determines if the OS on which Ant is executing matches the
-     * given OS name.
-     *
+     * Determines if the current OS matches the given OS
+     * name.
+     * 
      * @param name the OS name to check for
      * @return true if the OS matches
-     * @since 1.7
+     * @since 1.0
      */
     public static boolean isName( String name )
     {
@@ -186,12 +247,12 @@ public static boolean isName( String name )
     }
 
     /**
-     * Determines if the OS on which Ant is executing matches the
-     * given OS architecture.
-     *
+     * Determines if the current OS matches the given OS
+     * architecture.
+     * 
      * @param arch the OS architecture to check for
      * @return true if the OS matches
-     * @since 1.7
+     * @since 1.0
      */
     public static boolean isArch( String arch )
     {
@@ -199,12 +260,12 @@ public static boolean isArch( String arch )
     }
 
     /**
-     * Determines if the OS on which Ant is executing matches the
-     * given OS version.
-     *
+     * Determines if the current OS matches the given OS
+     * version.
+     * 
      * @param version the OS version to check for
      * @return true if the OS matches
-     * @since 1.7
+     * @since 1.0
      */
     public static boolean isVersion( String version )
     {
@@ -212,26 +273,25 @@ public static boolean isVersion( String version )
     }
 
     /**
-     * Determines if the OS on which Ant is executing matches the
-     * given OS family, name, architecture and version.
-     *
-     * The name, archictecture and version are compared to the System
-     * properties os.name, os.version and os.arch in a case-independent way.
-     *
-     * @param family   The OS family
-     * @param name   The OS name
-     * @param arch   The OS architecture
-     * @param version   The OS version
+     * Determines if the current OS matches the given OS
+     * family, name, architecture and version.
+     * 
+     * The name, archictecture and version are compared to
+     * the System properties os.name, os.version and os.arch
+     * in a case-independent way.
+     * 
+     * @param family The OS family
+     * @param name The OS name
+     * @param arch The OS architecture
+     * @param version The OS version
      * @return true if the OS matches
-     * @since 1.7
+     * @since 1.0
      */
-    public static boolean isOs( String family, String name, String arch,
-                                String version )
+    public static boolean isOs( String family, String name, String arch, String version )
     {
         boolean retValue = false;
 
-        if ( family != null || name != null || arch != null
-            || version != null )
+        if ( family != null || name != null || arch != null || version != null )
         {
 
             boolean isFamily = true;
@@ -241,60 +301,56 @@ public static boolean isOs( String family, String name, String arch,
 
             if ( family != null )
             {
-                if ( family.equalsIgnoreCase( "windows" ) )
+                if ( family.equalsIgnoreCase( FAMILY_WINDOWS ) )
                 {
-                    isFamily = OS_NAME.indexOf( "windows" ) > -1;
+                    isFamily = OS_NAME.indexOf( FAMILY_WINDOWS ) > -1;
                 }
-                else if ( family.equalsIgnoreCase( "os/2" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_OS2 ) )
                 {
-                    isFamily = OS_NAME.indexOf( "os/2" ) > -1;
+                    isFamily = OS_NAME.indexOf( FAMILY_OS2 ) > -1;
                 }
-                else if ( family.equalsIgnoreCase( "netware" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_NETWARE ) )
                 {
-                    isFamily = OS_NAME.indexOf( "netware" ) > -1;
+                    isFamily = OS_NAME.indexOf( FAMILY_NETWARE ) > -1;
                 }
-                else if ( family.equalsIgnoreCase( "dos" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_DOS ) )
                 {
-                    isFamily = PATH_SEP.equals( ";" ) && !isFamily( "netware" );
+                    isFamily = PATH_SEP.equals( ";" ) && !isFamily( FAMILY_NETWARE );
                 }
-                else if ( family.equalsIgnoreCase( "mac" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_MAC ) )
                 {
-                    isFamily = OS_NAME.indexOf( "mac" ) > -1;
+                    isFamily = OS_NAME.indexOf( FAMILY_MAC ) > -1;
                 }
-                else if ( family.equalsIgnoreCase( "tandem" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_TANDEM ) )
                 {
                     isFamily = OS_NAME.indexOf( "nonstop_kernel" ) > -1;
                 }
-                else if ( family.equalsIgnoreCase( "unix" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_UNIX ) )
                 {
-                    isFamily = PATH_SEP.equals( ":" )
-                        && !isFamily( "openvms" )
-                        && ( !isFamily( "mac" ) || OS_NAME.endsWith( "x" ) );
+                    isFamily = PATH_SEP.equals( ":" ) && !isFamily( FAMILY_OPENVMS )
+                        && ( !isFamily( FAMILY_MAC ) || OS_NAME.endsWith( "x" ) );
                 }
-                else if ( family.equalsIgnoreCase( "win9x" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_WIN9X ) )
                 {
-                    isFamily = isFamily( "windows" )
-                        && ( OS_NAME.indexOf( "95" ) >= 0
-                        || OS_NAME.indexOf( "98" ) >= 0
-                        || OS_NAME.indexOf( "me" ) >= 0
-                        || OS_NAME.indexOf( "ce" ) >= 0 );
+                    isFamily = isFamily( FAMILY_WINDOWS )
+                        && ( OS_NAME.indexOf( "95" ) >= 0 || OS_NAME.indexOf( "98" ) >= 0
+                            || OS_NAME.indexOf( "me" ) >= 0 || OS_NAME.indexOf( "ce" ) >= 0 );
                 }
-                else if ( family.equalsIgnoreCase( "z/os" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_ZOS ) )
                 {
-                    isFamily = OS_NAME.indexOf( "z/os" ) > -1
-                        || OS_NAME.indexOf( "os/390" ) > -1;
+                    isFamily = OS_NAME.indexOf( FAMILY_ZOS ) > -1 || OS_NAME.indexOf( "os/390" ) > -1;
                 }
-                else if ( family.equalsIgnoreCase( "os/400" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_OS400 ) )
                 {
-                    isFamily = OS_NAME.indexOf( "os/400" ) > -1;
+                    isFamily = OS_NAME.indexOf( FAMILY_OS400 ) > -1;
                 }
-                else if ( family.equalsIgnoreCase( "openvms" ) )
+                else if ( family.equalsIgnoreCase( FAMILY_OPENVMS ) )
                 {
-                    isFamily = OS_NAME.indexOf( "openvms" ) > -1;
+                    isFamily = OS_NAME.indexOf( FAMILY_OPENVMS ) > -1;
                 }
                 else
                 {
-                    isFamily = false;
+                    isFamily = OS_NAME.indexOf( family.toLowerCase() ) > -1;
                 }
             }
             if ( name != null )
@@ -313,4 +369,71 @@ else if ( family.equalsIgnoreCase( "openvms" ) )
         }
         return retValue;
     }
+
+    /**
+     * Helper method to determine the current OS family.
+     * 
+     * @return name of current OS family.
+     * @since 1.4.2
+     */
+    private static String getOsFamily()
+    {
+        // in case the order of static initialization is
+        // wrong, get the list
+        // safely.
+        Set families = null;
+        if ( !validFamilies.isEmpty() )
+        {
+            families = validFamilies;
+        }
+        else
+        {
+            families = setValidFamilies();
+        }
+        Iterator iter = families.iterator();
+        while ( iter.hasNext() )
+        {
+            String fam = (String) iter.next();
+            if ( Os.isFamily( fam ) )
+            {
+                return fam;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Helper method to check if the given family is in the
+     * following list:
+     * <ul>
+     * <li>dos</li>
+     * <li>mac</li>
+     * <li>netware</li>
+     * <li>os/2</li>
+     * <li>tandem</li>
+     * <li>unix</li>
+     * <li>windows</li>
+     * <li>win9x</li>
+     * <li>z/os</li>
+     * <li>os/400</li>
+     * <li>openvms</li>
+     * </ul>
+     * 
+     * @param theFamily the family to check.
+     * @return true if one of the valid families.
+     * @since 1.4.2
+     */
+    public static boolean isValidFamily( String theFamily )
+    {
+        return ( validFamilies.contains( theFamily ) );
+    }
+
+    /**
+     * @return a copy of the valid families
+     * @since 1.4.2
+     */
+    public static Set getValidFamilies()
+    {
+        return new HashSet( validFamilies );
+    }
 }
diff --git a/src/main/java/org/codehaus/plexus/util/ReaderFactory.java b/src/main/java/org/codehaus/plexus/util/ReaderFactory.java
new file mode 100644
index 00000000..d707a91e
--- /dev/null
+++ b/src/main/java/org/codehaus/plexus/util/ReaderFactory.java
@@ -0,0 +1,180 @@
+package org.codehaus.plexus.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.io.UnsupportedEncodingException;
+import java.net.URL;
+import java.nio.charset.Charset;
+
+import org.codehaus.plexus.util.xml.XmlReader;
+
+/**
+ * Utility to create Readers from streams, with explicit encoding choice: platform default,
+ * XML, or specified.
+ * 
+ * @author <a href="mailto:hboutemy@codehaus.org">Herve Boutemy</a>
+ * @see Charset
+ * @see <a href="http://java.sun.com/j2se/1.4.2/docs/guide/intl/encoding.doc.html">Supported encodings</a>
+ * @version $Id: $
+ */
+public class ReaderFactory
+{
+    /**
+     * ISO Latin Alphabet #1, also known as ISO-LATIN-1.
+     * Every implementation of the Java platform is required to support this character encoding.
+     * @see Charset
+     */
+    public static final String ISO_8859_1 = "ISO-8859-1";
+
+    /**
+     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.
+     * Every implementation of the Java platform is required to support this character encoding.
+     * @see Charset
+     */
+    public static final String US_ASCII = "US-ASCII";
+
+    /**
+     * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either
+     * order accepted on input, big-endian used on output).
+     * Every implementation of the Java platform is required to support this character encoding.
+     * @see Charset
+     */
+    public static final String UTF_16 = "UTF-16";
+
+    /**
+     * Sixteen-bit Unicode Transformation Format, big-endian byte order.
+     * Every implementation of the Java platform is required to support this character encoding.
+     * @see Charset
+     */
+    public static final String UTF_16BE = "UTF-16BE";
+
+    /**
+     * Sixteen-bit Unicode Transformation Format, little-endian byte order.
+     * Every implementation of the Java platform is required to support this character encoding.
+     * @see Charset
+     */
+    public static final String UTF_16LE = "UTF-16LE";
+
+    /**
+     * Eight-bit Unicode Transformation Format.
+     * Every implementation of the Java platform is required to support this character encoding.
+     * @see Charset
+     */
+    public static final String UTF_8 = "UTF-8";
+
+    /**
+     * The <code>file.encoding</code> System Property.
+     */
+    public static final String FILE_ENCODING = System.getProperty( "file.encoding" );
+    
+    /**
+     * Create a new Reader with XML encoding detection rules.
+     * @see XmlReader
+     */
+    public static Reader newXmlReader( InputStream in )
+    throws IOException
+    {
+        return new XmlReader( in );
+    }
+
+    /**
+     * Create a new Reader with XML encoding detection rules.
+     * @see XmlReader
+     */
+    public static Reader newXmlReader( File file )
+    throws IOException
+    {
+        return new XmlReader( file );
+    }
+
+    /**
+     * Create a new Reader with XML encoding detection rules.
+     * @see XmlReader
+     */
+    public static Reader newXmlReader( URL url )
+    throws IOException
+    {
+        return new XmlReader( url );
+    }
+
+    /**
+     * Create a new Reader with default plaform encoding.
+     */
+    public static Reader newPlatformReader( InputStream in )
+    {
+        return new InputStreamReader( in );
+    }
+
+    /**
+     * Create a new Reader with default plaform encoding.
+     */
+    public static Reader newPlatformReader( File file )
+    throws FileNotFoundException
+    {
+        return new FileReader( file );
+    }
+
+    /**
+     * Create a new Reader with default plaform encoding.
+     */
+    public static Reader newPlatformReader( URL url )
+    throws IOException
+    {
+        return new InputStreamReader( url.openStream() );
+    }
+
+    /**
+     * Create a new Reader with specified encoding.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/guide/intl/encoding.doc.html">Supported encodings</a>
+     */
+    public static Reader newReader( InputStream in, String encoding )
+    throws UnsupportedEncodingException
+    {
+        return new InputStreamReader( in, encoding );
+    }
+
+    /**
+     * Create a new Reader with specified encoding.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/guide/intl/encoding.doc.html">Supported encodings</a>
+     */
+    public static Reader newReader( File file, String encoding )
+    throws FileNotFoundException, UnsupportedEncodingException
+    {
+        return new InputStreamReader( new FileInputStream(file), encoding );
+    }
+
+    /**
+     * Create a new Reader with specified encoding.
+     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/guide/intl/encoding.doc.html">Supported encodings</a>
+     */
+    public static Reader newReader( URL url, String encoding )
+    throws IOException
+    {
+        return new InputStreamReader( url.openStream(), encoding );
+    }
+}
diff --git a/src/main/java/org/codehaus/plexus/util/cli/CommandLineUtils.java b/src/main/java/org/codehaus/plexus/util/cli/CommandLineUtils.java
index cd745a52..1d9c2eb8 100644
--- a/src/main/java/org/codehaus/plexus/util/cli/CommandLineUtils.java
+++ b/src/main/java/org/codehaus/plexus/util/cli/CommandLineUtils.java
@@ -229,7 +229,7 @@ public static Properties getSystemEnvVars( boolean caseSensitive )
         {
             int idx = line.indexOf( '=' );
 
-            if ( idx > 1 )
+            if ( idx > 0 )
             {
                 lastKey = line.substring( 0, idx );
 
diff --git a/src/main/java/org/codehaus/plexus/util/cli/Commandline.java b/src/main/java/org/codehaus/plexus/util/cli/Commandline.java
index f5cd163d..33f3eddd 100644
--- a/src/main/java/org/codehaus/plexus/util/cli/Commandline.java
+++ b/src/main/java/org/codehaus/plexus/util/cli/Commandline.java
@@ -2,93 +2,77 @@
 
 /*
  * The MIT License
- *
+ * 
  * Copyright (c) 2004, The Codehaus
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is furnished to do
- * so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+ * associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+ * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-/********************************************************************************
- * CruiseControl, a Continuous Integration Toolkit
- * Copyright (c) 2001-2003, ThoughtWorks, Inc.
- * 651 W Washington Ave. Suite 500
- * Chicago, IL 60661 USA
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *     + Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *
- *     + Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *     + Neither the name of ThoughtWorks, Inc., CruiseControl, nor the
- *       names of its contributors may be used to endorse or promote
- *       products derived from this software without specific prior
- *       written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ********************************************************************************/
-
-/* ====================================================================
- * Copyright 2003-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * ====================================================================
- */
+/***************************************************************************************************
+ * CruiseControl, a Continuous Integration Toolkit Copyright (c) 2001-2003, ThoughtWorks, Inc. 651 W
+ * Washington Ave. Suite 500 Chicago, IL 60661 USA All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met: + Redistributions of source code must retain the
+ * above copyright notice, this list of conditions and the following disclaimer. + Redistributions
+ * in binary form must reproduce the above copyright notice, this list of conditions and the
+ * following disclaimer in the documentation and/or other materials provided with the distribution. +
+ * Neither the name of ThoughtWorks, Inc., CruiseControl, nor the names of its contributors may be
+ * used to endorse or promote products derived from this software without specific prior written
+ * permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ **************************************************************************************************/
 
-import org.codehaus.plexus.util.cli.shell.BourneShell;
-import org.codehaus.plexus.util.cli.shell.CmdShell;
-import org.codehaus.plexus.util.cli.shell.CommandShell;
-import org.codehaus.plexus.util.cli.shell.Shell;
+/*
+ * ==================================================================== Copyright 2003-2004 The
+ * Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License. ====================================================================
+ */
 
 import java.io.File;
 import java.io.IOException;
+import java.util.Collections;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
 import java.util.Properties;
 import java.util.Vector;
 
+import org.codehaus.plexus.util.cli.shell.BourneShell;
+import org.codehaus.plexus.util.cli.shell.CmdShell;
+import org.codehaus.plexus.util.cli.shell.CommandShell;
+import org.codehaus.plexus.util.cli.shell.Shell;
+
 /**
  * <p/>
  * Commandline objects help handling command lines specifying processes to
@@ -126,17 +110,19 @@ public class Commandline
 
     protected Vector arguments = new Vector();
 
-    protected Vector envVars = new Vector();
+    //protected Vector envVars = new Vector();
+    // synchronized added to preserve synchronize of Vector class 
+    protected Map envVars = Collections.synchronizedMap( new LinkedHashMap() );
 
     private long pid = -1;
 
     private Shell shell;
-    
+
     /**
      * @deprecated Use {@link Commandline#setExecutable(String)} instead.
      */
     protected String executable;
-    
+
     /**
      * @deprecated Use {@link Commandline#setWorkingDirectory(File)} or 
      * {@link Commandline#setWorkingDirectory(String)} instead.
@@ -152,7 +138,7 @@ public class Commandline
     public Commandline( String toProcess, Shell shell )
     {
         this.shell = shell;
-        
+
         String[] tmp = new String[0];
         try
         {
@@ -233,7 +219,6 @@ public void setPid( long pid )
         this.pid = pid;
     }
 
-
     /**
      * Class to keep track of the position of an Argument.
      */
@@ -273,7 +258,6 @@ public int getPosition()
         }
     }
 
-
     /**
      * <p>Sets the shell or command-line interpretor for the detected operating system,
      * and the shell arguments.</p>
@@ -419,12 +403,12 @@ public void setExecutable( String executable )
     public String getExecutable()
     {
         String exec = shell.getExecutable();
-        
+
         if ( exec == null )
         {
             exec = executable;
         }
-        
+
         return exec;
     }
 
@@ -439,10 +423,10 @@ public void addArguments( String[] line )
     /**
      * Add an environment variable
      */
-    public void addEnvironment( String name,
-                                String value )
+    public void addEnvironment( String name, String value )
     {
-        envVars.add( name + "=" + value );
+        //envVars.add( name + "=" + value );
+        envVars.put( name, value );
     }
 
     /**
@@ -451,13 +435,15 @@ public void addEnvironment( String name,
     public void addSystemEnvironment()
         throws Exception
     {
-        Properties envVars = CommandLineUtils.getSystemEnvVars();
+        Properties systemEnvVars = CommandLineUtils.getSystemEnvVars();
 
-        for ( Iterator i = envVars.keySet().iterator(); i.hasNext(); )
+        for ( Iterator i = systemEnvVars.keySet().iterator(); i.hasNext(); )
         {
             String key = (String) i.next();
-
-            addEnvironment( key, envVars.getProperty( key ) );
+            if ( !envVars.containsKey( key ) )
+            {
+                addEnvironment( key, systemEnvVars.getProperty( key ) );
+            }
         }
     }
 
@@ -475,8 +461,16 @@ public String[] getEnvironmentVariables()
         {
             throw new CommandLineException( "Error setting up environmental variables", e );
         }
-
-        return (String[]) envVars.toArray( new String[envVars.size()] );
+        String[] environmentVars = new String[envVars.size()];
+        int i = 0;
+        for ( Iterator iterator = envVars.keySet().iterator(); iterator.hasNext(); )
+        {
+            String name = (String) iterator.next();
+            String value = (String) envVars.get( name );
+            environmentVars[i] = name + "=" + value;
+            i++;
+        }
+        return environmentVars;
     }
 
     /**
@@ -486,7 +480,7 @@ public String[] getCommandline()
     {
         final String[] args = getArguments();
         String executable = getExecutable();
-        
+
         if ( executable == null )
         {
             return args;
@@ -504,7 +498,7 @@ public String[] getShellCommandline()
     {
         // TODO: Provided only for backward compat. with <= 1.4
         verifyShellState();
-        
+
         return (String[]) getShell().getShellCommandLine( getArguments() ).toArray( new String[0] );
     }
 
@@ -605,12 +599,12 @@ public void setWorkingDirectory( File workingDirectory )
     public File getWorkingDirectory()
     {
         File workDir = shell.getWorkingDirectory();
-        
+
         if ( workDir == null )
         {
             workDir = workingDir;
         }
-        
+
         return workDir;
     }
 
@@ -622,7 +616,7 @@ public Process execute()
     {
         // TODO: Provided only for backward compat. with <= 1.4
         verifyShellState();
-        
+
         Process process;
 
         //addEnvironment( "MAVEN_TEST_ENVAR", "MAVEN_TEST_ENVAR_VALUE" );
@@ -630,7 +624,7 @@ public Process execute()
         String[] environment = getEnvironmentVariables();
 
         File workingDir = shell.getWorkingDirectory();
-        
+
         try
         {
             if ( workingDir == null )
@@ -641,13 +635,13 @@ public Process execute()
             {
                 if ( !workingDir.exists() )
                 {
-                    throw new CommandLineException(
-                        "Working directory \"" + workingDir.getPath() + "\" does not exist!" );
+                    throw new CommandLineException( "Working directory \"" + workingDir.getPath()
+                        + "\" does not exist!" );
                 }
                 else if ( !workingDir.isDirectory() )
                 {
-                    throw new CommandLineException(
-                        "Path \"" + workingDir.getPath() + "\" does not specify a directory." );
+                    throw new CommandLineException( "Path \"" + workingDir.getPath()
+                        + "\" does not specify a directory." );
                 }
 
                 process = Runtime.getRuntime().exec( getShellCommandline(), environment, workingDir );
@@ -670,7 +664,7 @@ private void verifyShellState()
         {
             shell.setWorkingDirectory( workingDir );
         }
-        
+
         if ( shell.getExecutable() == null )
         {
             shell.setExecutable( executable );
@@ -712,7 +706,7 @@ public static String[] translateCommandline( String toProcess )
     {
         return CommandLineUtils.translateCommandline( toProcess );
     }
-    
+
     /**
      * @deprecated Use {@link CommandLineUtils#quote(String)} instead.
      */
@@ -729,7 +723,7 @@ public static String toString( String[] line )
     {
         return CommandLineUtils.toString( line );
     }
-    
+
     public static class Argument
         implements Arg
     {
diff --git a/src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java b/src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java
index 0475e5ed..58611a9a 100644
--- a/src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java
+++ b/src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java
@@ -19,6 +19,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.codehaus.plexus.util.StringUtils;
+
 /**
  * @author Jason van Zyl
  *  @version $Id$
@@ -30,35 +32,35 @@ public BourneShell()
     {
         this( false );
     }
-    
+
     public BourneShell( boolean isLoginShell )
     {
         setShellCommand( "/bin/bash" );
         setSingleQuotedArgumentEscaped( true );
         setSingleQuotedExecutableEscaped( true );
         setQuotedExecutableEnabled( false );
-        
+
         if ( isLoginShell )
         {
             addShellArg( "-l" );
         }
     }
-    
+
     public List getShellArgsList()
     {
         List shellArgs = new ArrayList();
         List existingShellArgs = super.getShellArgsList();
-        
+
         if ( existingShellArgs != null && !existingShellArgs.isEmpty() )
         {
             shellArgs.addAll( existingShellArgs );
         }
-        
+
         shellArgs.add( "-c" );
-        
+
         return shellArgs;
     }
-    
+
     public String[] getShellArgs()
     {
         String[] shellArgs = super.getShellArgs();
@@ -66,32 +68,58 @@ public String[] getShellArgs()
         {
            shellArgs = new String[0];
         }
-        
+
         if ( shellArgs.length > 0 && !shellArgs[shellArgs.length-1].equals( "-c" ) )
         {
             String[] newArgs = new String[shellArgs.length + 1];
-            
+
             System.arraycopy( shellArgs, 0, newArgs, 0, shellArgs.length );
             newArgs[shellArgs.length] = "-c";
-            
+
             shellArgs = newArgs;
         }
-        
+
         return shellArgs;
     }
-    
+
     public String getExecutable()
     {
         File wd = getWorkingDirectory();
-        
+
         if ( wd != null )
         {
-            return "cd " + getWorkingDirectory().getAbsolutePath() + " && " + super.getExecutable();
+            String path = getWorkingDirectory().getAbsolutePath();
+            String exe = super.getExecutable();
+            return "cd " + handleQuote( path ) + " && " + handleQuote( exe );
         }
         else
         {
             return super.getExecutable();
         }
     }
-    
+
+    /**
+     * Convenience method to handle single or double quote in a path
+     *
+     * @param path
+     * @return corrected path
+     */
+    private static String handleQuote( String path )
+    {
+        if ( path.indexOf( "\'" ) > -1 )
+        {
+            return StringUtils.replace( path, "\'", "\\'" );
+        }
+        if ( path.indexOf( "'" ) > -1 )
+        {
+            return StringUtils.replace( path, "'", "\\'" );
+        }
+        if ( path.indexOf( "\"" ) > -1 )
+        {
+            return StringUtils.replace( path, "\"", "\\\"" );
+        }
+
+
+        return path;
+    }
 }
diff --git a/src/main/java/org/codehaus/plexus/util/interpolation/PropertiesBasedValueSource.java b/src/main/java/org/codehaus/plexus/util/interpolation/PropertiesBasedValueSource.java
new file mode 100644
index 00000000..22c438c7
--- /dev/null
+++ b/src/main/java/org/codehaus/plexus/util/interpolation/PropertiesBasedValueSource.java
@@ -0,0 +1,21 @@
+package org.codehaus.plexus.util.interpolation;
+
+import java.util.Properties;
+
+public class PropertiesBasedValueSource
+    implements ValueSource
+{
+
+    private final Properties properties;
+
+    public PropertiesBasedValueSource( Properties properties )
+    {
+        this.properties = properties;
+    }
+
+    public Object getValue( String expression )
+    {
+        return properties.getProperty( expression );
+    }
+
+}
diff --git a/src/main/java/org/codehaus/plexus/util/introspection/ReflectionValueExtractor.java b/src/main/java/org/codehaus/plexus/util/introspection/ReflectionValueExtractor.java
index a235629e..061b80f5 100644
--- a/src/main/java/org/codehaus/plexus/util/introspection/ReflectionValueExtractor.java
+++ b/src/main/java/org/codehaus/plexus/util/introspection/ReflectionValueExtractor.java
@@ -17,7 +17,7 @@
  */
 
 import java.lang.reflect.Method;
-import java.util.HashMap;
+import java.util.WeakHashMap;
 import java.util.Map;
 import java.util.StringTokenizer;
 
@@ -33,13 +33,16 @@
  */
 public class ReflectionValueExtractor
 {
-    private static Class[] args = new Class[ 0 ];
+    private static final Class[] CLASS_ARGS = new Class[ 0 ];
 
-    private static Object[] params = new Object[ 0 ];
+    private static final Object[] OBJECT_ARGS = new Object[ 0 ];
 
-    private static ClassMap classMap;
-
-    private static Map classMaps = new HashMap();
+    /**
+     * Use a WeakHashMap here, so the keys (Class objects) can be garbage collected.
+     * This approach prevents permgen space overflows due to retention of discarded
+     * classloaders.
+     */
+    private static final Map classMaps = new WeakHashMap();
 
     private ReflectionValueExtractor()
     {
@@ -79,20 +82,20 @@ public static Object evaluate( String expression, Object root, boolean trimRootT
                 return null;
             }
 
-            classMap = getClassMap( value.getClass() );
+            ClassMap classMap = getClassMap( value.getClass() );
 
             String methodBase = StringUtils.capitalizeFirstLetter( token );
             
             String methodName = "get" + methodBase;
 
-            Method method = classMap.findMethod( methodName, args );
+            Method method = classMap.findMethod( methodName, CLASS_ARGS );
             
             if ( method == null )
             {
                 // perhaps this is a boolean property??
                 methodName = "is" + methodBase;
                 
-                method = classMap.findMethod( methodName, args );
+                method = classMap.findMethod( methodName, CLASS_ARGS );
             }
 
             if ( method == null )
@@ -100,7 +103,7 @@ public static Object evaluate( String expression, Object root, boolean trimRootT
                 return null;
             }
 
-            value = method.invoke( value, params );
+            value = method.invoke( value, OBJECT_ARGS );
         }
 
         return value;
@@ -108,7 +111,7 @@ public static Object evaluate( String expression, Object root, boolean trimRootT
 
     private static ClassMap getClassMap( Class clazz )
     {
-        classMap = (ClassMap) classMaps.get( clazz );
+        ClassMap classMap = (ClassMap) classMaps.get( clazz );
 
         if ( classMap == null )
         {
diff --git a/src/main/java/org/codehaus/plexus/util/xml/XmlReader.java b/src/main/java/org/codehaus/plexus/util/xml/XmlReader.java
new file mode 100644
index 00000000..51d672ea
--- /dev/null
+++ b/src/main/java/org/codehaus/plexus/util/xml/XmlReader.java
@@ -0,0 +1,783 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package org.codehaus.plexus.util.xml;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.io.StringReader;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.HttpURLConnection;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+import java.text.MessageFormat;
+
+/**
+ * Character stream that handles (or at least attemtps to) all the necessary Voodo to figure out the charset encoding of
+ * the XML document within the stream.
+ * <p>
+ * IMPORTANT: This class is not related in any way to the org.xml.sax.XMLReader. This one IS a character stream.
+ * <p>
+ * All this has to be done without consuming characters from the stream, if not the XML parser will not recognized the
+ * document as a valid XML. This is not 100% true, but it's close enough (UTF-8 BOM is not handled by all parsers right
+ * now, XmlReader handles it and things work in all parsers).
+ * <p>
+ * The XmlReader class handles the charset encoding of XML documents in Files, raw streams and HTTP streams by offering
+ * a wide set of constructors.
+ * <P>
+ * By default the charset encoding detection is lenient, the constructor with the lenient flag can be used for an script
+ * (following HTTP MIME and XML specifications). All this is nicely explained by Mark Pilgrim in his blog, <a
+ * href="http://diveintomark.org/archives/2004/02/13/xml-media-types"> Determining the character encoding of a feed</a>.
+ * <p>
+ * 
+ * @author Alejandro Abdelnur
+ * @version revision 1.17 taken on 26/06/2007 from Rome (see https://rome.dev.java.net/source/browse/rome/src/java/com/sun/syndication/io/XmlReader.java)
+ */
+public class XmlReader extends Reader
+{
+    private static final int BUFFER_SIZE = 4096;
+
+    private static final String UTF_8 = "UTF-8";
+
+    private static final String US_ASCII = "US-ASCII";
+
+    private static final String UTF_16BE = "UTF-16BE";
+
+    private static final String UTF_16LE = "UTF-16LE";
+
+    private static final String UTF_16 = "UTF-16";
+
+    private static final String EBCDIC = "CP1047";
+
+    private static String _staticDefaultEncoding = null;
+
+    private Reader _reader;
+
+    private String _encoding;
+
+    private String _defaultEncoding;
+
+    /**
+     * Sets the default encoding to use if none is set in HTTP content-type, XML prolog and the rules based on
+     * content-type are not adequate. <p/> If it is set to NULL the content-type based rules are used. <p/> By default
+     * it is NULL. <p/>
+     * 
+     * @param encoding
+     *            charset encoding to default to.
+     */
+    public static void setDefaultEncoding( String encoding )
+    {
+        _staticDefaultEncoding = encoding;
+    }
+
+    /**
+     * Returns the default encoding to use if none is set in HTTP content-type, XML prolog and the rules based on
+     * content-type are not adequate. <p/> If it is NULL the content-type based rules are used. <p/>
+     * 
+     * @return the default encoding to use.
+     */
+    public static String getDefaultEncoding()
+    {
+        return _staticDefaultEncoding;
+    }
+
+    /**
+     * Creates a Reader for a File.
+     * <p>
+     * It looks for the UTF-8 BOM first, if none sniffs the XML prolog charset, if this is also missing defaults to
+     * UTF-8.
+     * <p>
+     * It does a lenient charset encoding detection, check the constructor with the lenient parameter for details.
+     * <p>
+     * 
+     * @param file
+     *            File to create a Reader from.
+     * @throws IOException
+     *             thrown if there is a problem reading the file.
+     * 
+     */
+    public XmlReader( File file ) throws IOException
+    {
+        this( new FileInputStream( file ) );
+    }
+
+    /**
+     * Creates a Reader for a raw InputStream.
+     * <p>
+     * It follows the same logic used for files.
+     * <p>
+     * It does a lenient charset encoding detection, check the constructor with the lenient parameter for details.
+     * <p>
+     * 
+     * @param is
+     *            InputStream to create a Reader from.
+     * @throws IOException
+     *             thrown if there is a problem reading the stream.
+     * 
+     */
+    public XmlReader( InputStream is ) throws IOException
+    {
+        this( is, true );
+    }
+
+    /**
+     * Creates a Reader for a raw InputStream.
+     * <p>
+     * It follows the same logic used for files.
+     * <p>
+     * If lenient detection is indicated and the detection above fails as per specifications it then attempts the
+     * following:
+     * <p>
+     * If the content type was 'text/html' it replaces it with 'text/xml' and tries the detection again.
+     * <p>
+     * Else if the XML prolog had a charset encoding that encoding is used.
+     * <p>
+     * Else if the content type had a charset encoding that encoding is used.
+     * <p>
+     * Else 'UTF-8' is used.
+     * <p>
+     * If lenient detection is indicated an XmlReaderException is never thrown.
+     * <p>
+     * 
+     * @param is
+     *            InputStream to create a Reader from.
+     * @param lenient
+     *            indicates if the charset encoding detection should be relaxed.
+     * @throws IOException
+     *             thrown if there is a problem reading the stream.
+     * @throws XmlReaderException
+     *             thrown if the charset encoding could not be determined according to the specs.
+     * 
+     */
+    public XmlReader( InputStream is, boolean lenient ) throws IOException, XmlReaderException
+    {
+        _defaultEncoding = _staticDefaultEncoding;
+        try
+        {
+            doRawStream( is, lenient );
+        }
+        catch ( XmlReaderException ex )
+        {
+            if ( !lenient )
+            {
+                throw ex;
+            }
+            else
+            {
+                doLenientDetection( null, ex );
+            }
+        }
+    }
+
+    /**
+     * Creates a Reader using the InputStream of a URL.
+     * <p>
+     * If the URL is not of type HTTP and there is not 'content-type' header in the fetched data it uses the same logic
+     * used for Files.
+     * <p>
+     * If the URL is a HTTP Url or there is a 'content-type' header in the fetched data it uses the same logic used for
+     * an InputStream with content-type.
+     * <p>
+     * It does a lenient charset encoding detection, check the constructor with the lenient parameter for details.
+     * <p>
+     * 
+     * @param url
+     *            URL to create a Reader from.
+     * @throws IOException
+     *             thrown if there is a problem reading the stream of the URL.
+     * 
+     */
+    public XmlReader( URL url ) throws IOException
+    {
+        this( url.openConnection() );
+    }
+
+    /**
+     * Creates a Reader using the InputStream of a URLConnection.
+     * <p>
+     * If the URLConnection is not of type HttpURLConnection and there is not 'content-type' header in the fetched data
+     * it uses the same logic used for files.
+     * <p>
+     * If the URLConnection is a HTTP Url or there is a 'content-type' header in the fetched data it uses the same logic
+     * used for an InputStream with content-type.
+     * <p>
+     * It does a lenient charset encoding detection, check the constructor with the lenient parameter for details.
+     * <p>
+     * 
+     * @param conn
+     *            URLConnection to create a Reader from.
+     * @throws IOException
+     *             thrown if there is a problem reading the stream of the URLConnection.
+     * 
+     */
+    public XmlReader( URLConnection conn ) throws IOException
+    {
+        _defaultEncoding = _staticDefaultEncoding;
+        boolean lenient = true;
+        if ( conn instanceof HttpURLConnection )
+        {
+            try
+            {
+                doHttpStream( conn.getInputStream(), conn.getContentType(), lenient );
+            }
+            catch ( XmlReaderException ex )
+            {
+                doLenientDetection( conn.getContentType(), ex );
+            }
+        }
+        else if ( conn.getContentType() != null )
+        {
+            try
+            {
+                doHttpStream( conn.getInputStream(), conn.getContentType(), lenient );
+            }
+            catch ( XmlReaderException ex )
+            {
+                doLenientDetection( conn.getContentType(), ex );
+            }
+        }
+        else
+        {
+            try
+            {
+                doRawStream( conn.getInputStream(), lenient );
+            }
+            catch ( XmlReaderException ex )
+            {
+                doLenientDetection( null, ex );
+            }
+        }
+    }
+
+    /**
+     * Creates a Reader using an InputStream an the associated content-type header.
+     * <p>
+     * First it checks if the stream has BOM. If there is not BOM checks the content-type encoding. If there is not
+     * content-type encoding checks the XML prolog encoding. If there is not XML prolog encoding uses the default
+     * encoding mandated by the content-type MIME type.
+     * <p>
+     * It does a lenient charset encoding detection, check the constructor with the lenient parameter for details.
+     * <p>
+     * 
+     * @param is
+     *            InputStream to create the reader from.
+     * @param httpContentType
+     *            content-type header to use for the resolution of the charset encoding.
+     * @throws IOException
+     *             thrown if there is a problem reading the file.
+     * 
+     */
+    public XmlReader( InputStream is, String httpContentType ) throws IOException
+    {
+        this( is, httpContentType, true );
+    }
+
+    /**
+     * Creates a Reader using an InputStream an the associated content-type header. This constructor is lenient
+     * regarding the encoding detection.
+     * <p>
+     * First it checks if the stream has BOM. If there is not BOM checks the content-type encoding. If there is not
+     * content-type encoding checks the XML prolog encoding. If there is not XML prolog encoding uses the default
+     * encoding mandated by the content-type MIME type.
+     * <p>
+     * If lenient detection is indicated and the detection above fails as per specifications it then attempts the
+     * following:
+     * <p>
+     * If the content type was 'text/html' it replaces it with 'text/xml' and tries the detection again.
+     * <p>
+     * Else if the XML prolog had a charset encoding that encoding is used.
+     * <p>
+     * Else if the content type had a charset encoding that encoding is used.
+     * <p>
+     * Else 'UTF-8' is used.
+     * <p>
+     * If lenient detection is indicated an XmlReaderException is never thrown.
+     * <p>
+     * 
+     * @param is
+     *            InputStream to create the reader from.
+     * @param httpContentType
+     *            content-type header to use for the resolution of the charset encoding.
+     * @param lenient
+     *            indicates if the charset encoding detection should be relaxed.
+     * @throws IOException
+     *             thrown if there is a problem reading the file.
+     * @throws XmlReaderException
+     *             thrown if the charset encoding could not be determined according to the specs.
+     * 
+     */
+    public XmlReader( InputStream is, String httpContentType, boolean lenient, String defaultEncoding )
+        throws IOException, XmlReaderException
+    {
+        _defaultEncoding = ( defaultEncoding == null ) ? _staticDefaultEncoding : defaultEncoding;
+        try
+        {
+            doHttpStream( is, httpContentType, lenient );
+        }
+        catch ( XmlReaderException ex )
+        {
+            if ( !lenient )
+            {
+                throw ex;
+            }
+            else
+            {
+                doLenientDetection( httpContentType, ex );
+            }
+        }
+    }
+
+    /**
+     * Creates a Reader using an InputStream an the associated content-type header. This constructor is lenient
+     * regarding the encoding detection.
+     * <p>
+     * First it checks if the stream has BOM. If there is not BOM checks the content-type encoding. If there is not
+     * content-type encoding checks the XML prolog encoding. If there is not XML prolog encoding uses the default
+     * encoding mandated by the content-type MIME type.
+     * <p>
+     * If lenient detection is indicated and the detection above fails as per specifications it then attempts the
+     * following:
+     * <p>
+     * If the content type was 'text/html' it replaces it with 'text/xml' and tries the detection again.
+     * <p>
+     * Else if the XML prolog had a charset encoding that encoding is used.
+     * <p>
+     * Else if the content type had a charset encoding that encoding is used.
+     * <p>
+     * Else 'UTF-8' is used.
+     * <p>
+     * If lenient detection is indicated an XmlReaderException is never thrown.
+     * <p>
+     * 
+     * @param is
+     *            InputStream to create the reader from.
+     * @param httpContentType
+     *            content-type header to use for the resolution of the charset encoding.
+     * @param lenient
+     *            indicates if the charset encoding detection should be relaxed.
+     * @throws IOException
+     *             thrown if there is a problem reading the file.
+     * @throws XmlReaderException
+     *             thrown if the charset encoding could not be determined according to the specs.
+     * 
+     */
+    public XmlReader( InputStream is, String httpContentType, boolean lenient ) throws IOException, XmlReaderException
+    {
+        this( is, httpContentType, lenient, null );
+    }
+
+    private void doLenientDetection( String httpContentType, XmlReaderException ex ) throws IOException
+    {
+        if ( httpContentType != null )
+        {
+            if ( httpContentType.startsWith( "text/html" ) )
+            {
+                httpContentType = httpContentType.substring( "text/html".length() );
+                httpContentType = "text/xml" + httpContentType;
+                try
+                {
+                    doHttpStream( ex.getInputStream(), httpContentType, true );
+                    ex = null;
+                }
+                catch ( XmlReaderException ex2 )
+                {
+                    ex = ex2;
+                }
+            }
+        }
+        if ( ex != null )
+        {
+            String encoding = ex.getXmlEncoding();
+            if ( encoding == null )
+            {
+                encoding = ex.getContentTypeEncoding();
+            }
+            if ( encoding == null )
+            {
+                encoding = ( _defaultEncoding == null ) ? UTF_8 : _defaultEncoding;
+            }
+            prepareReader( ex.getInputStream(), encoding );
+        }
+    }
+
+    /**
+     * Returns the charset encoding of the XmlReader.
+     * <p>
+     * 
+     * @return charset encoding.
+     * 
+     */
+    public String getEncoding()
+    {
+        return _encoding;
+    }
+
+    public int read( char[] buf, int offset, int len ) throws IOException
+    {
+        return _reader.read( buf, offset, len );
+    }
+
+    /**
+     * Closes the XmlReader stream.
+     * <p>
+     * 
+     * @throws IOException
+     *             thrown if there was a problem closing the stream.
+     * 
+     */
+    public void close() throws IOException
+    {
+        _reader.close();
+    }
+
+    private void doRawStream( InputStream is, boolean lenient ) throws IOException
+    {
+        BufferedInputStream pis = new BufferedInputStream( is, BUFFER_SIZE );
+        String bomEnc = getBOMEncoding( pis );
+        String xmlGuessEnc = getXMLGuessEncoding( pis );
+        String xmlEnc = getXmlProlog( pis, xmlGuessEnc );
+        String encoding = calculateRawEncoding( bomEnc, xmlGuessEnc, xmlEnc, pis );
+        prepareReader( pis, encoding );
+    }
+
+    private void doHttpStream( InputStream is, String httpContentType, boolean lenient ) throws IOException
+    {
+        BufferedInputStream pis = new BufferedInputStream( is, BUFFER_SIZE );
+        String cTMime = getContentTypeMime( httpContentType );
+        String cTEnc = getContentTypeEncoding( httpContentType );
+        String bomEnc = getBOMEncoding( pis );
+        String xmlGuessEnc = getXMLGuessEncoding( pis );
+        String xmlEnc = getXmlProlog( pis, xmlGuessEnc );
+        String encoding = calculateHttpEncoding( cTMime, cTEnc, bomEnc, xmlGuessEnc, xmlEnc, pis, lenient );
+        prepareReader( pis, encoding );
+    }
+
+    private void prepareReader( InputStream is, String encoding ) throws IOException
+    {
+        _reader = new InputStreamReader( is, encoding );
+        _encoding = encoding;
+    }
+
+    // InputStream is passed for XmlReaderException creation only
+    private String calculateRawEncoding( String bomEnc, String xmlGuessEnc, String xmlEnc, InputStream is )
+        throws IOException
+    {
+        String encoding;
+        if ( bomEnc == null )
+        {
+            if ( xmlGuessEnc == null || xmlEnc == null )
+            {
+                encoding = ( _defaultEncoding == null ) ? UTF_8 : _defaultEncoding;
+            }
+            else if ( xmlEnc.equals( UTF_16 ) && ( xmlGuessEnc.equals( UTF_16BE ) || xmlGuessEnc.equals( UTF_16LE ) ) )
+            {
+                encoding = xmlGuessEnc;
+            }
+            else
+            {
+                encoding = xmlEnc;
+            }
+        }
+        else if ( bomEnc.equals( UTF_8 ) )
+        {
+            if ( xmlGuessEnc != null && !xmlGuessEnc.equals( UTF_8 ) )
+            {
+                throw new XmlReaderException( RAW_EX_1.format( new Object[] { bomEnc, xmlGuessEnc, xmlEnc } ), bomEnc,
+                                              xmlGuessEnc, xmlEnc, is );
+            }
+            if ( xmlEnc != null && !xmlEnc.equals( UTF_8 ) )
+            {
+                throw new XmlReaderException( RAW_EX_1.format( new Object[] { bomEnc, xmlGuessEnc, xmlEnc } ), bomEnc,
+                                              xmlGuessEnc, xmlEnc, is );
+            }
+            encoding = UTF_8;
+        }
+        else if ( bomEnc.equals( UTF_16BE ) || bomEnc.equals( UTF_16LE ) )
+        {
+            if ( xmlGuessEnc != null && !xmlGuessEnc.equals( bomEnc ) )
+            {
+                throw new IOException( RAW_EX_1.format( new Object[] { bomEnc, xmlGuessEnc, xmlEnc } ) );
+            }
+            if ( xmlEnc != null && !xmlEnc.equals( UTF_16 ) && !xmlEnc.equals( bomEnc ) )
+            {
+                throw new XmlReaderException( RAW_EX_1.format( new Object[] { bomEnc, xmlGuessEnc, xmlEnc } ), bomEnc,
+                                              xmlGuessEnc, xmlEnc, is );
+            }
+            encoding = bomEnc;
+        }
+        else
+        {
+            throw new XmlReaderException( RAW_EX_2.format( new Object[] { bomEnc, xmlGuessEnc, xmlEnc } ), bomEnc,
+                                          xmlGuessEnc, xmlEnc, is );
+        }
+        return encoding;
+    }
+
+    // InputStream is passed for XmlReaderException creation only
+    private String calculateHttpEncoding( String cTMime, String cTEnc, String bomEnc, String xmlGuessEnc,
+                                          String xmlEnc, InputStream is, boolean lenient ) throws IOException
+    {
+        String encoding;
+        if ( lenient & xmlEnc != null )
+        {
+            encoding = xmlEnc;
+        }
+        else
+        {
+            boolean appXml = isAppXml( cTMime );
+            boolean textXml = isTextXml( cTMime );
+            if ( appXml || textXml )
+            {
+                if ( cTEnc == null )
+                {
+                    if ( appXml )
+                    {
+                        encoding = calculateRawEncoding( bomEnc, xmlGuessEnc, xmlEnc, is );
+                    }
+                    else
+                    {
+                        encoding = ( _defaultEncoding == null ) ? US_ASCII : _defaultEncoding;
+                    }
+                }
+                else if ( bomEnc != null && ( cTEnc.equals( UTF_16BE ) || cTEnc.equals( UTF_16LE ) ) )
+                {
+                    throw new XmlReaderException( HTTP_EX_1.format( new Object[] { cTMime, cTEnc, bomEnc, xmlGuessEnc,
+                        xmlEnc } ), cTMime, cTEnc, bomEnc, xmlGuessEnc, xmlEnc, is );
+                }
+                else if ( cTEnc.equals( UTF_16 ) )
+                {
+                    if ( bomEnc != null && bomEnc.startsWith( UTF_16 ) )
+                    {
+                        encoding = bomEnc;
+                    }
+                    else
+                    {
+                        throw new XmlReaderException( HTTP_EX_2.format( new Object[] { cTMime, cTEnc, bomEnc,
+                            xmlGuessEnc, xmlEnc } ), cTMime, cTEnc, bomEnc, xmlGuessEnc, xmlEnc, is );
+                    }
+                }
+                else
+                {
+                    encoding = cTEnc;
+                }
+            }
+            else
+            {
+                throw new XmlReaderException( HTTP_EX_3.format( new Object[] { cTMime, cTEnc, bomEnc, xmlGuessEnc,
+                    xmlEnc } ), cTMime, cTEnc, bomEnc, xmlGuessEnc, xmlEnc, is );
+            }
+        }
+        return encoding;
+    }
+
+    // returns MIME type or NULL if httpContentType is NULL
+    private static String getContentTypeMime( String httpContentType )
+    {
+        String mime = null;
+        if ( httpContentType != null )
+        {
+            int i = httpContentType.indexOf( ";" );
+            mime = ( ( i == -1 ) ? httpContentType : httpContentType.substring( 0, i ) ).trim();
+        }
+        return mime;
+    }
+
+    private static final Pattern CHARSET_PATTERN = Pattern.compile( "charset=([.[^; ]]*)" );
+
+    // returns charset parameter value, NULL if not present, NULL if httpContentType is NULL
+    private static String getContentTypeEncoding( String httpContentType )
+    {
+        String encoding = null;
+        if ( httpContentType != null )
+        {
+            int i = httpContentType.indexOf( ";" );
+            if ( i > -1 )
+            {
+                String postMime = httpContentType.substring( i + 1 );
+                Matcher m = CHARSET_PATTERN.matcher( postMime );
+                encoding = ( m.find() ) ? m.group( 1 ) : null;
+                encoding = ( encoding != null ) ? encoding.toUpperCase() : null;
+            }
+        }
+        return encoding;
+    }
+
+    // returns the BOM in the stream, NULL if not present,
+    // if there was BOM the in the stream it is consumed
+    private static String getBOMEncoding( BufferedInputStream is ) throws IOException
+    {
+        String encoding = null;
+        int[] bytes = new int[3];
+        is.mark( 3 );
+        bytes[0] = is.read();
+        bytes[1] = is.read();
+        bytes[2] = is.read();
+
+        if ( bytes[0] == 0xFE && bytes[1] == 0xFF )
+        {
+            encoding = UTF_16BE;
+            is.reset();
+            is.read();
+            is.read();
+        }
+        else if ( bytes[0] == 0xFF && bytes[1] == 0xFE )
+        {
+            encoding = UTF_16LE;
+            is.reset();
+            is.read();
+            is.read();
+        }
+        else if ( bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF )
+        {
+            encoding = UTF_8;
+        }
+        else
+        {
+            is.reset();
+        }
+        return encoding;
+    }
+
+    // returns the best guess for the encoding by looking the first bytes of the stream, '<?'
+    private static String getXMLGuessEncoding( BufferedInputStream is ) throws IOException
+    {
+        String encoding = null;
+        int[] bytes = new int[4];
+        is.mark( 4 );
+        bytes[0] = is.read();
+        bytes[1] = is.read();
+        bytes[2] = is.read();
+        bytes[3] = is.read();
+        is.reset();
+
+        if ( bytes[0] == 0x00 && bytes[1] == 0x3C && bytes[2] == 0x00 && bytes[3] == 0x3F )
+        {
+            encoding = UTF_16BE;
+        }
+        else if ( bytes[0] == 0x3C && bytes[1] == 0x00 && bytes[2] == 0x3F && bytes[3] == 0x00 )
+        {
+            encoding = UTF_16LE;
+        }
+        else if ( bytes[0] == 0x3C && bytes[1] == 0x3F && bytes[2] == 0x78 && bytes[3] == 0x6D )
+        {
+            encoding = UTF_8;
+        }
+        else if ( bytes[0] == 0x4C && bytes[1] == 0x6F && bytes[2] == 0xA7 && bytes[3] == 0x94 )
+        {
+            encoding = EBCDIC;
+        }
+        return encoding;
+    }
+
+    private static final Pattern ENCODING_PATTERN =
+        Pattern.compile( "<\\?xml.*encoding[\\s]*=[\\s]*((?:\".[^\"]*\")|(?:'.[^']*'))", Pattern.MULTILINE );
+
+    // returns the encoding declared in the <?xml encoding=...?>, NULL if none
+    private static String getXmlProlog( BufferedInputStream is, String guessedEnc ) throws IOException
+    {
+        String encoding = null;
+        if ( guessedEnc != null )
+        {
+            byte[] bytes = new byte[BUFFER_SIZE];
+            is.mark( BUFFER_SIZE );
+            int offset = 0;
+            int max = BUFFER_SIZE;
+            int c = is.read( bytes, offset, max );
+            int firstGT = -1;
+            String xmlProlog = null;
+            while ( c != -1 && firstGT == -1 && offset < BUFFER_SIZE )
+            {
+                offset += c;
+                max -= c;
+                c = is.read( bytes, offset, max );
+                xmlProlog = new String( bytes, 0, offset, guessedEnc );
+                firstGT = xmlProlog.indexOf( '>' );
+            }
+            if ( firstGT == -1 )
+            {
+                if ( c == -1 )
+                {
+                    throw new IOException( "Unexpected end of XML stream" );
+                }
+                else
+                {
+                    throw new IOException( "XML prolog or ROOT element not found on first " + offset + " bytes" );
+                }
+            }
+            int bytesRead = offset;
+            if ( bytesRead > 0 )
+            {
+                is.reset();
+                BufferedReader bReader = new BufferedReader( new StringReader( xmlProlog ) );
+                StringBuffer prolog = new StringBuffer();
+                String line = bReader.readLine();
+                while ( line != null )
+                {
+                    prolog.append( line );
+                    line = bReader.readLine();
+                }
+                Matcher m = ENCODING_PATTERN.matcher( prolog );
+                if ( m.find() )
+                {
+                    encoding = m.group( 1 ).toUpperCase();
+                    encoding = encoding.substring( 1, encoding.length() - 1 );
+                }
+            }
+        }
+        return encoding;
+    }
+
+    // indicates if the MIME type belongs to the APPLICATION XML family
+    private static boolean isAppXml( String mime )
+    {
+        return mime != null
+                        && ( mime.equals( "application/xml" ) || mime.equals( "application/xml-dtd" )
+                                        || mime.equals( "application/xml-external-parsed-entity" ) || ( mime.startsWith( "application/" ) && mime.endsWith( "+xml" ) ) );
+    }
+
+    // indicates if the MIME type belongs to the TEXT XML family
+    private static boolean isTextXml( String mime )
+    {
+        return mime != null
+                        && ( mime.equals( "text/xml" ) || mime.equals( "text/xml-external-parsed-entity" ) || ( mime.startsWith( "text/" ) && mime.endsWith( "+xml" ) ) );
+    }
+
+    private static final MessageFormat RAW_EX_1 =
+        new MessageFormat( "Invalid encoding, BOM [{0}] XML guess [{1}] XML prolog [{2}] encoding mismatch" );
+
+    private static final MessageFormat RAW_EX_2 =
+        new MessageFormat( "Invalid encoding, BOM [{0}] XML guess [{1}] XML prolog [{2}] unknown BOM" );
+
+    private static final MessageFormat HTTP_EX_1 =
+        new MessageFormat(
+                           "Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], BOM must be NULL" );
+
+    private static final MessageFormat HTTP_EX_2 =
+        new MessageFormat(
+                           "Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], encoding mismatch" );
+
+    private static final MessageFormat HTTP_EX_3 =
+        new MessageFormat(
+                           "Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], Invalid MIME" );
+
+}
diff --git a/src/main/java/org/codehaus/plexus/util/xml/XmlReaderException.java b/src/main/java/org/codehaus/plexus/util/xml/XmlReaderException.java
new file mode 100644
index 00000000..23cf7e67
--- /dev/null
+++ b/src/main/java/org/codehaus/plexus/util/xml/XmlReaderException.java
@@ -0,0 +1,162 @@
+package org.codehaus.plexus.util.xml;
+
+import java.io.InputStream;
+import java.io.IOException;
+
+/**
+ * The XmlReaderException is thrown by the XmlReader constructors if the charset encoding can not be determined
+ * according to the XML 1.0 specification and RFC 3023.
+ * <p>
+ * The exception returns the unconsumed InputStream to allow the application to do an alternate processing with the
+ * stream. Note that the original InputStream given to the XmlReader cannot be used as that one has been already read.
+ * <p>
+ * 
+ * @author Alejandro Abdelnur
+ * @version revision 1.1 taken on 26/06/2007 from Rome (see https://rome.dev.java.net/source/browse/rome/src/java/com/sun/syndication/io/XmlReaderException.java)
+ */
+public class XmlReaderException extends IOException
+{
+    private String _bomEncoding;
+
+    private String _xmlGuessEncoding;
+
+    private String _xmlEncoding;
+
+    private String _contentTypeMime;
+
+    private String _contentTypeEncoding;
+
+    private InputStream _is;
+
+    /**
+     * Creates an exception instance if the charset encoding could not be determined.
+     * <p>
+     * Instances of this exception are thrown by the XmlReader.
+     * <p>
+     * 
+     * @param msg
+     *            message describing the reason for the exception.
+     * @param bomEnc
+     *            BOM encoding.
+     * @param xmlGuessEnc
+     *            XML guess encoding.
+     * @param xmlEnc
+     *            XML prolog encoding.
+     * @param is
+     *            the unconsumed InputStream.
+     * 
+     */
+    public XmlReaderException( String msg, String bomEnc, String xmlGuessEnc, String xmlEnc, InputStream is )
+    {
+        this( msg, null, null, bomEnc, xmlGuessEnc, xmlEnc, is );
+    }
+
+    /**
+     * Creates an exception instance if the charset encoding could not be determined.
+     * <p>
+     * Instances of this exception are thrown by the XmlReader.
+     * <p>
+     * 
+     * @param msg
+     *            message describing the reason for the exception.
+     * @param ctMime
+     *            MIME type in the content-type.
+     * @param ctEnc
+     *            encoding in the content-type.
+     * @param bomEnc
+     *            BOM encoding.
+     * @param xmlGuessEnc
+     *            XML guess encoding.
+     * @param xmlEnc
+     *            XML prolog encoding.
+     * @param is
+     *            the unconsumed InputStream.
+     * 
+     */
+    public XmlReaderException( String msg, String ctMime, String ctEnc, String bomEnc, String xmlGuessEnc,
+                               String xmlEnc, InputStream is )
+    {
+        super( msg );
+        _contentTypeMime = ctMime;
+        _contentTypeEncoding = ctEnc;
+        _bomEncoding = bomEnc;
+        _xmlGuessEncoding = xmlGuessEnc;
+        _xmlEncoding = xmlEnc;
+        _is = is;
+    }
+
+    /**
+     * Returns the BOM encoding found in the InputStream.
+     * <p>
+     * 
+     * @return the BOM encoding, null if none.
+     * 
+     */
+    public String getBomEncoding()
+    {
+        return _bomEncoding;
+    }
+
+    /**
+     * Returns the encoding guess based on the first bytes of the InputStream.
+     * <p>
+     * 
+     * @return the encoding guess, null if it couldn't be guessed.
+     * 
+     */
+    public String getXmlGuessEncoding()
+    {
+        return _xmlGuessEncoding;
+    }
+
+    /**
+     * Returns the encoding found in the XML prolog of the InputStream.
+     * <p>
+     * 
+     * @return the encoding of the XML prolog, null if none.
+     * 
+     */
+    public String getXmlEncoding()
+    {
+        return _xmlEncoding;
+    }
+
+    /**
+     * Returns the MIME type in the content-type used to attempt determining the encoding.
+     * <p>
+     * 
+     * @return the MIME type in the content-type, null if there was not content-type or the encoding detection did not
+     *         involve HTTP.
+     * 
+     */
+    public String getContentTypeMime()
+    {
+        return _contentTypeMime;
+    }
+
+    /**
+     * Returns the encoding in the content-type used to attempt determining the encoding.
+     * <p>
+     * 
+     * @return the encoding in the content-type, null if there was not content-type, no encoding in it or the encoding
+     *         detection did not involve HTTP.
+     * 
+     */
+    public String getContentTypeEncoding()
+    {
+        return _contentTypeEncoding;
+    }
+
+    /**
+     * Returns the unconsumed InputStream to allow the application to do an alternate encoding detection on the
+     * InputStream.
+     * <p>
+     * 
+     * @return the unconsumed InputStream.
+     * 
+     */
+    public InputStream getInputStream()
+    {
+        return _is;
+    }
+}
diff --git a/src/main/java/org/codehaus/plexus/util/xml/Xpp3Dom.java b/src/main/java/org/codehaus/plexus/util/xml/Xpp3Dom.java
index 090d7c65..d2ef7103 100644
--- a/src/main/java/org/codehaus/plexus/util/xml/Xpp3Dom.java
+++ b/src/main/java/org/codehaus/plexus/util/xml/Xpp3Dom.java
@@ -21,41 +21,41 @@ public class Xpp3Dom
 
     protected Map attributes;
 
-    protected List childList;
+    protected final List childList;
 
-    protected Map childMap;
+    protected final Map childMap;
 
     protected Xpp3Dom parent;
 
     private static final Xpp3Dom[] EMPTY_DOM_ARRAY = new Xpp3Dom[0];
 
     public static final String CHILDREN_COMBINATION_MODE_ATTRIBUTE = "combine.children";
-    
+
     public static final String CHILDREN_COMBINATION_MERGE = "merge";
-    
+
     public static final String CHILDREN_COMBINATION_APPEND = "append";
-    
-    /** 
+
+    /**
      * This default mode for combining children DOMs during merge means that where element names
      * match, the process will try to merge the element data, rather than putting the dominant
      * and recessive elements (which share the same element name) as siblings in the resulting
      * DOM.
-     */ 
+     */
     public static final String DEFAULT_CHILDREN_COMBINATION_MODE = CHILDREN_COMBINATION_MERGE;
 
     public static final String SELF_COMBINATION_MODE_ATTRIBUTE = "combine.self";
-    
+
     public static final String SELF_COMBINATION_OVERRIDE = "override";
-    
+
     public static final String SELF_COMBINATION_MERGE = "merge";
-    
-    /** 
+
+    /**
      * This default mode for combining a DOM node during merge means that where element names
-     * match, the process will try to merge the element attributes and values, rather than 
+     * match, the process will try to merge the element attributes and values, rather than
      * overriding the recessive element completely with the dominant one. This means that
      * wherever the dominant element doesn't provide the value or a particular attribute, that
      * value or attribute will be set from the recessive DOM node.
-     */ 
+     */
     public static final String DEFAULT_SELF_COMBINATION_MODE = SELF_COMBINATION_MERGE;
 
     public Xpp3Dom( String name )
@@ -65,6 +65,9 @@ public Xpp3Dom( String name )
         childMap = new HashMap();
     }
 
+    /**
+     * Copy constructor.
+     */
     public Xpp3Dom( Xpp3Dom src )
     {
         this( src.getName() );
@@ -191,11 +194,11 @@ public Xpp3Dom[] getChildren( String name )
         else
         {
             ArrayList children = new ArrayList();
-            int size = this.childList.size();
+            int size = childList.size();
 
             for ( int i = 0; i < size; i++ )
             {
-                Xpp3Dom configuration = (Xpp3Dom) this.childList.get( i );
+                Xpp3Dom configuration = (Xpp3Dom) childList.get( i );
                 if ( name.equals( configuration.getName() ) )
                 {
                     children.add( configuration );
@@ -258,41 +261,41 @@ public void writeToSerializer( String namespace, XmlSerializer serializer )
     /**
      * Merges one DOM into another, given a specific algorithm and possible override points for that algorithm.
      * The algorithm is as follows:
-     * 
+     *
      * 1. if the recessive DOM is null, there is nothing to do...return.
-     * 
+     *
      * 2. Determine whether the dominant node will suppress the recessive one (flag=mergeSelf).
-     * 
+     *
      *    A. retrieve the 'combine.self' attribute on the dominant node, and try to match against 'override'...
      *       if it matches 'override', then set mergeSelf == false...the dominant node suppresses the recessive
      *       one completely.
-     *       
+     *
      *    B. otherwise, use the default value for mergeSelf, which is true...this is the same as specifying
      *       'combine.self' == 'merge' as an attribute of the dominant root node.
-     *       
+     *
      * 3. If mergeSelf == true
-     * 
+     *
      *    A. if the dominant root node's value is empty, set it to the recessive root node's value
-     *    
+     *
      *    B. For each attribute in the recessive root node which is not set in the dominant root node, set it.
-     *    
-     *    C. Determine whether children from the recessive DOM will be merged or appended to the dominant 
+     *
+     *    C. Determine whether children from the recessive DOM will be merged or appended to the dominant
      *       DOM as siblings (flag=mergeChildren).
-     *       
+     *
      *       i.   if childMergeOverride is set (non-null), use that value (true/false)
-     *       
+     *
      *       ii.  retrieve the 'combine.children' attribute on the dominant node, and try to match against
      *            'append'...if it matches 'append', then set mergeChildren == false...the recessive children
      *            will be appended as siblings of the dominant children.
-     *           
+     *
      *       iii. otherwise, use the default value for mergeChildren, which is true...this is the same as
      *            specifying 'combine.children' == 'merge' as an attribute on the dominant root node.
-     *    
+     *
      *    D. Iterate through the recessive children, and:
-     *    
+     *
      *       i.   if mergeChildren == true and there is a corresponding dominant child (matched by element name),
      *            merge the two.
-     *            
+     *
      *       ii.  otherwise, add the recessive child as a new child on the dominant root node.
      */
     private static void mergeIntoXpp3Dom( Xpp3Dom dominant, Xpp3Dom recessive, Boolean childMergeOverride )
@@ -302,36 +305,36 @@ private static void mergeIntoXpp3Dom( Xpp3Dom dominant, Xpp3Dom recessive, Boole
         {
             return;
         }
-        
+
         boolean mergeSelf = true;
-        
+
         String selfMergeMode = dominant.getAttribute( SELF_COMBINATION_MODE_ATTRIBUTE );
-        
+
         if ( isNotEmpty( selfMergeMode ) && SELF_COMBINATION_OVERRIDE.equals( selfMergeMode ) )
         {
             mergeSelf = false;
         }
-        
+
         if ( mergeSelf )
         {
             if ( isEmpty( dominant.getValue() ) )
             {
                 dominant.setValue( recessive.getValue() );
             }
-            
+
             String[] recessiveAttrs = recessive.getAttributeNames();
             for ( int i = 0; i < recessiveAttrs.length; i++ )
             {
                 String attr = recessiveAttrs[i];
-                
+
                 if ( isEmpty( dominant.getAttribute( attr ) ) )
                 {
-                    dominant.setAttribute( attr, recessive.getAttribute( attr ) ); 
+                    dominant.setAttribute( attr, recessive.getAttribute( attr ) );
                 }
             }
-            
+
             boolean mergeChildren = true;
-            
+
             if ( childMergeOverride != null )
             {
                 mergeChildren = childMergeOverride.booleanValue();
@@ -339,19 +342,26 @@ private static void mergeIntoXpp3Dom( Xpp3Dom dominant, Xpp3Dom recessive, Boole
             else
             {
                 String childMergeMode = dominant.getAttribute( CHILDREN_COMBINATION_MODE_ATTRIBUTE );
-                
+
                 if ( isNotEmpty( childMergeMode ) && CHILDREN_COMBINATION_APPEND.equals( childMergeMode ) )
                 {
                     mergeChildren = false;
                 }
             }
-            
+
+            Xpp3Dom[] dominantChildren = dominant.getChildren();
+            if ( !mergeChildren )
+            {
+                // remove these now, so we can append them to the recessive list later.
+                dominant.childList.clear();
+            }
+
             Xpp3Dom[] children = recessive.getChildren();
             for ( int i = 0; i < children.length; i++ )
             {
                 Xpp3Dom child = children[i];
                 Xpp3Dom childDom = dominant.getChild( child.getName() );
-                if ( mergeChildren && childDom != null )
+                if ( mergeChildren && ( childDom != null ) )
                 {
                     mergeIntoXpp3Dom( childDom, child, childMergeOverride );
                 }
@@ -360,15 +370,24 @@ private static void mergeIntoXpp3Dom( Xpp3Dom dominant, Xpp3Dom recessive, Boole
                     dominant.addChild( new Xpp3Dom( child ) );
                 }
             }
+
+            if ( !mergeChildren )
+            {
+                // now, re-add these children so they'll be appended to the recessive list.
+                for ( int i = 0; i < dominantChildren.length; i++ )
+                {
+                    dominant.addChild( dominantChildren[i] );
+                }
+            }
         }
     }
-    
+
     /**
      * Merge two DOMs, with one having dominance in the case of collision.
-     * 
+     *
      * @see #CHILDREN_COMBINATION_MODE_ATTRIBUTE
      * @see #SELF_COMBINATION_MODE_ATTRIBUTE
-     * 
+     *
      * @param dominant The dominant DOM into which the recessive value/attributes/children will be merged
      * @param recessive The recessive DOM, which will be merged into the dominant DOM
      * @param childMergeOverride Overrides attribute flags to force merging or appending of child elements
@@ -388,10 +407,10 @@ public static Xpp3Dom mergeXpp3Dom( Xpp3Dom dominant, Xpp3Dom recessive, Boolean
      * Merge two DOMs, with one having dominance in the case of collision.
      * Merge mechanisms (vs. override for nodes, or vs. append for children) is determined by
      * attributes of the dominant root node.
-     * 
+     *
      * @see #CHILDREN_COMBINATION_MODE_ATTRIBUTE
      * @see #SELF_COMBINATION_MODE_ATTRIBUTE
-     * 
+     *
      * @param dominant The dominant DOM into which the recessive value/attributes/children will be merged
      * @param recessive The recessive DOM, which will be merged into the dominant DOM
      */
@@ -475,12 +494,12 @@ public String toUnescapedString()
 
     public static boolean isNotEmpty( String str )
     {
-        return ( str != null && str.length() > 0 );
+        return ( ( str != null ) && ( str.length() > 0 ) );
     }
 
     public static boolean isEmpty( String str )
     {
-        return ( str == null || str.trim().length() == 0 );
+        return ( ( str == null ) || ( str.trim().length() == 0 ) );
     }
 
 }
diff --git a/src/main/java/org/codehaus/plexus/util/xml/pull/MXParser.java b/src/main/java/org/codehaus/plexus/util/xml/pull/MXParser.java
index f511f770..95753f91 100644
--- a/src/main/java/org/codehaus/plexus/util/xml/pull/MXParser.java
+++ b/src/main/java/org/codehaus/plexus/util/xml/pull/MXParser.java
@@ -12,9 +12,10 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.Reader;
-import java.io.InputStreamReader;
 import java.io.UnsupportedEncodingException;
 
+import org.codehaus.plexus.util.ReaderFactory;
+
 //import java.util.Hashtable;
 
 //TODO best handling of interning issues
@@ -25,8 +26,9 @@
 //TODO review code for use of bufAbsoluteStart when keeping pos between next()/fillBuf()
 
 /**
- * Absolutely minimal implementaion of XMLPULL V1 API
+ * Absolutely minimal implementation of XMLPULL V1 API. Encoding handling done with XmlReader
  *
+ * @see org.codehaus.plexus.util.xml.XmlReader
  * @author <a href="http://www.extreme.indiana.edu/~aslom/">Aleksander Slominski</a>
  */
 
@@ -530,22 +532,23 @@ public void setInput(java.io.InputStream inputStream, String inputEncoding)
             throw new IllegalArgumentException("input stream can not be null");
         }
         Reader reader;
-        if(inputEncoding != null) {
-            try {
-                if(inputEncoding != null) {
-                    reader = new InputStreamReader(inputStream, inputEncoding);
-                } else {
-                    reader = new InputStreamReader(inputStream);
-                }
-            } catch (UnsupportedEncodingException une) {
-                throw new XmlPullParserException(
-                    "could not create reader for encoding "+inputEncoding+" : "+une, this, une);
+        try {
+            if(inputEncoding != null) {
+                reader = ReaderFactory.newReader(inputStream, inputEncoding);
+            } else {
+                reader = ReaderFactory.newXmlReader(inputStream);
             }
-        } else {
-            reader = new InputStreamReader(inputStream);
+        } catch (UnsupportedEncodingException une) {
+            throw new XmlPullParserException(
+                "could not create reader for encoding "+inputEncoding+" : "+une, this, une);
+        }
+        catch ( IOException e )
+        {
+            throw new XmlPullParserException(
+                "could not create reader : "+e, this, e);
         }
         setInput(reader);
-        //must be  here as reest() was called in setInput() and has set this.inputEncoding to null ...
+        //must be  here as reset() was called in setInput() and has set this.inputEncoding to null ...
         this.inputEncoding = inputEncoding;
     }
     
diff --git a/src/main/javadoc/org/codehaus/plexus/util/cli/package.html b/src/main/javadoc/org/codehaus/plexus/util/cli/package.html
new file mode 100644
index 00000000..6da4e2c3
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/cli/package.html
@@ -0,0 +1,3 @@
+<body>
+Command-line utilities.
+</body>
\ No newline at end of file
diff --git a/src/main/javadoc/org/codehaus/plexus/util/cli/shell/package.html b/src/main/javadoc/org/codehaus/plexus/util/cli/shell/package.html
new file mode 100644
index 00000000..9e00e89d
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/cli/shell/package.html
@@ -0,0 +1,3 @@
+<body>
+Shell utilities.
+</body>
\ No newline at end of file
diff --git a/src/main/javadoc/org/codehaus/plexus/util/dag/package.html b/src/main/javadoc/org/codehaus/plexus/util/dag/package.html
new file mode 100644
index 00000000..4f4c77f9
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/dag/package.html
@@ -0,0 +1,3 @@
+<body>
+Directed Acyclic Graph utilities.
+</body>
\ No newline at end of file
diff --git a/src/main/javadoc/org/codehaus/plexus/util/interpolation/package.html b/src/main/javadoc/org/codehaus/plexus/util/interpolation/package.html
new file mode 100644
index 00000000..648b0c85
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/interpolation/package.html
@@ -0,0 +1,3 @@
+<body>
+Interpolation utilities.
+</body>
\ No newline at end of file
diff --git a/src/main/javadoc/org/codehaus/plexus/util/introspection/package.html b/src/main/javadoc/org/codehaus/plexus/util/introspection/package.html
new file mode 100644
index 00000000..1d4c4fd6
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/introspection/package.html
@@ -0,0 +1,3 @@
+<body>
+Introspection utilities.
+</body>
\ No newline at end of file
diff --git a/src/main/javadoc/org/codehaus/plexus/util/package.html b/src/main/javadoc/org/codehaus/plexus/util/package.html
new file mode 100644
index 00000000..79bf2c28
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/package.html
@@ -0,0 +1,3 @@
+<body>
+Misc. utilities.
+</body>
\ No newline at end of file
diff --git a/src/main/javadoc/org/codehaus/plexus/util/reflection/package.html b/src/main/javadoc/org/codehaus/plexus/util/reflection/package.html
new file mode 100644
index 00000000..7ced7f31
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/reflection/package.html
@@ -0,0 +1,3 @@
+<body>
+Reflection utilities.
+</body>
\ No newline at end of file
diff --git a/src/main/javadoc/org/codehaus/plexus/util/xml/package.html b/src/main/javadoc/org/codehaus/plexus/util/xml/package.html
new file mode 100644
index 00000000..58e530ba
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/xml/package.html
@@ -0,0 +1,3 @@
+<body>
+XML utilities.
+</body>
\ No newline at end of file
diff --git a/src/main/javadoc/org/codehaus/plexus/util/xml/pull/package.html b/src/main/javadoc/org/codehaus/plexus/util/xml/pull/package.html
new file mode 100644
index 00000000..8cf73f2b
--- /dev/null
+++ b/src/main/javadoc/org/codehaus/plexus/util/xml/pull/package.html
@@ -0,0 +1,7 @@
+<body>
+<a href="http://www.xmlpull.org/">XML Pull Parser</a> interface and implementation.
+
+XML Pull Parser is an interface that defines parsing functionlity provided
+in <a href="http://www.xmlpull.org/">XMLPULL V1 API</a> (visit this website to
+learn more about API and its implementations).
+</body>
\ No newline at end of file
diff --git a/src/test/java/org/codehaus/plexus/util/FileUtilsTest.java b/src/test/java/org/codehaus/plexus/util/FileUtilsTest.java
index 992043c6..08a546ed 100644
--- a/src/test/java/org/codehaus/plexus/util/FileUtilsTest.java
+++ b/src/test/java/org/codehaus/plexus/util/FileUtilsTest.java
@@ -28,6 +28,7 @@
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Reader;
@@ -985,4 +986,49 @@ public void testFileWriteWithEncoding() throws IOException
         assertEqualContent( testString.getBytes( encoding ), testFile );
         testFile.delete();
     }
+
+    /**
+     * Workaround for the following Sun bugs. They are fixed in JDK 6u1 and JDK 5u11.
+     *
+     * @see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4403166">Sun bug id=4403166</a>
+     * @see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6182812">Sun bug id=6182812</a>
+     * @see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6481955">Sun bug id=6481955</a>
+     *
+     * @throws Exception
+     */
+    public void testDeleteLongPathOnWindows()
+        throws Exception
+    {
+        if ( System.getProperty( "os.name" ).toLowerCase().indexOf( "windows" ) == -1 )
+        {
+            return;
+        }
+
+        File a = new File( getTestDirectory(), "longpath" );
+        a.mkdir();
+        File a1 = new File( a, "a" );
+        a1.mkdir();
+
+        StringBuffer path = new StringBuffer( "" );
+        for ( int i = 0; i < 100; i++ )
+        {
+            path.append( "../a/" );
+        }
+
+        File f = new File( a1, path.toString() + "test.txt" );
+
+        InputStream is = new StringInputStream( "Blabla" );
+        OutputStream os = new FileOutputStream( f.getCanonicalFile() );
+        IOUtil.copy( is, os );
+        IOUtil.close( is );
+        IOUtil.close( os );
+
+        FileUtils.forceDelete( f );
+
+        File f1 = new File( a1, "test.txt" );
+        if ( f1.exists() )
+        {
+            throw new Exception( "Unable to delete the file :" + f1.getAbsolutePath() );
+        }
+    }
 }
diff --git a/src/test/java/org/codehaus/plexus/util/OsTest.java b/src/test/java/org/codehaus/plexus/util/OsTest.java
index 74235837..4b1467b8 100644
--- a/src/test/java/org/codehaus/plexus/util/OsTest.java
+++ b/src/test/java/org/codehaus/plexus/util/OsTest.java
@@ -3,15 +3,70 @@
  */
 package org.codehaus.plexus.util;
 
+import java.util.Iterator;
+
 import junit.framework.TestCase;
 
 /**
  * Test Case for Os
  */
-public class OsTest extends TestCase
+public class OsTest
+    extends TestCase
 {
     public void testUndefinedFamily()
     {
         assertFalse( Os.isFamily( "bogus family" ) );
     }
+
+    public void testOs()
+    {
+        Iterator iter = Os.getValidFamilies().iterator();
+        String currentFamily = null;
+        String notCurrentFamily = null;
+        while ( iter.hasNext() && ( currentFamily == null || notCurrentFamily == null ) )
+        {
+            String fam = (String) iter.next();
+            if ( Os.isFamily( fam ) )
+            {
+                currentFamily = fam;
+            }
+            else
+            {
+                notCurrentFamily = fam;
+            }
+        }
+
+        //make sure the OS_FAMILY is set right.
+        assertEquals( currentFamily, Os.OS_FAMILY );
+        
+        // check the current family and one of the others
+        assertTrue( Os.isOs( currentFamily, null, null, null ) );
+        assertFalse( Os.isOs( notCurrentFamily, null, null, null ) );
+
+        // check for junk
+        assertFalse( Os.isOs( "junk", null, null, null ) );
+
+        // check the current name
+        assertTrue( Os.isOs( currentFamily, Os.OS_NAME, null, null ) );
+
+        // check some other name
+        assertFalse( Os.isOs( currentFamily, "myos", null, null ) );
+
+        // check the arch
+        assertTrue( Os.isOs( currentFamily, Os.OS_NAME, Os.OS_ARCH, null ) );
+        assertFalse( Os.isOs( currentFamily, Os.OS_NAME, "myarch", null ) );
+
+        // check the version
+        assertTrue( Os.isOs( currentFamily, Os.OS_NAME, Os.OS_ARCH, Os.OS_VERSION ) );
+        assertFalse( Os.isOs( currentFamily, Os.OS_NAME, Os.OS_ARCH, "myversion"  ) );
+    }
+    
+    public void testValidList()
+    {
+        assertTrue(Os.isValidFamily( "dos" ) );
+        
+        assertFalse( Os.isValidFamily( "" ) );
+        assertFalse( Os.isValidFamily( null ) );
+        assertFalse( Os.isValidFamily( "something" ) );
+    }
 }
diff --git a/src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java b/src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java
index 954bf0cc..75f61464 100644
--- a/src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java
+++ b/src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java
@@ -5,32 +5,32 @@
  *
  * Copyright (c) 2004, The Codehaus
  *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of
- * this software and associated documentation files (the "Software"), to deal in
- * the Software without restriction, including without limitation the rights to
- * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is furnished to do
- * so, subject to the following conditions:
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+ * associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
  *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
  *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+ * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
 import java.io.File;
+import java.io.FileWriter;
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.io.StringWriter;
+import java.io.Writer;
 
 import junit.framework.TestCase;
 
+import org.codehaus.plexus.util.IOUtil;
 import org.codehaus.plexus.util.Os;
 import org.codehaus.plexus.util.cli.shell.BourneShell;
 import org.codehaus.plexus.util.cli.shell.CmdShell;
@@ -247,7 +247,7 @@ public void testGetShellCommandLineBash()
         assertEquals( "/bin/bash", shellCommandline[0] );
         assertEquals( "-c", shellCommandline[1] );
         String expectedShellCmd = "/bin/echo \"hello world\"";
-        if (Os.isFamily( "windows" ))
+        if ( Os.isFamily( "windows" ) )
         {
             expectedShellCmd = "\\bin\\echo \"hello world\"";
         }
@@ -272,7 +272,7 @@ public void testGetShellCommandLineBash_WithSingleQuotedArg()
         assertEquals( "/bin/bash", shellCommandline[0] );
         assertEquals( "-c", shellCommandline[1] );
         String expectedShellCmd = "/bin/echo \'hello world\'";
-        if (Os.isFamily( "windows" ))
+        if ( Os.isFamily( "windows" ) )
         {
             expectedShellCmd = "\\bin\\echo \'hello world\'";
         }
@@ -291,9 +291,7 @@ public void testGetShellCommandLineNonWindows()
 
         assertEquals( "/bin/bash", shellCommandline[0] );
         assertEquals( "-c", shellCommandline[1] );
-        
-        
-        
+
         if ( Os.isFamily( "windows" ) )
         {
             assertEquals( "\\usr\\bin a b", shellCommandline[2] );
@@ -311,4 +309,104 @@ public void testEnvironment()
         cmd.addEnvironment( "name", "value" );
         assertEquals( "name=value", cmd.getEnvironmentVariables()[0] );
     }
+
+    public void testEnvironmentWitOverrideSystemEnvironment()
+        throws Exception
+    {
+
+        Commandline cmd = new Commandline();
+        cmd.addSystemEnvironment();
+        cmd.addEnvironment( "JAVA_HOME", "/usr/jdk1.5" );
+        String[] environmentVariables = cmd.getEnvironmentVariables();
+
+        for ( int i = 0, size = environmentVariables.length; i < size; i++ )
+        {
+            if ( "JAVA_HOME=/usr/jdk1.5".equals( environmentVariables[i] ) )
+            {
+                return;
+            }
+        }
+
+        fail( "can't find JAVA_HOME=/usr/jdk1.5" );
+    }
+
+    public void testEnvironmentWitSystemEnvironment()
+        throws Exception
+    {
+        String javaHome = System.getProperty( "JAVA_HOME" );
+        Commandline cmd = new Commandline();
+        cmd.addSystemEnvironment();
+        String[] environmentVariables = cmd.getEnvironmentVariables();
+
+        for ( int i = 0, size = environmentVariables.length; i < size; i++ )
+        {
+            if ( ( "JAVA_HOME=" + javaHome ).equals( environmentVariables[i] ) )
+            {
+                return;
+            }
+        }
+
+        fail( "can't find JAVA_HOME=" + javaHome );
+    }
+
+    /**
+     * Test an executable with a quote in its path
+     *
+     * @throws Exception
+     */
+    public void testQuotedPath()
+        throws Exception
+    {
+        File dir = new File( "target/quotedpath'test" );
+        dir.mkdirs();
+
+        // Create a script file
+        File bat;
+        if ( Os.isFamily( "windows" ) )
+        {
+            bat = new File( dir, "echo.bat" );
+        }
+        else
+        {
+            bat = new File( dir, "echo" );
+        }
+
+        Writer w = new FileWriter( bat );
+        try{
+            IOUtil.copy( "echo Quoted", w );
+        }
+        finally
+        {
+            IOUtil.close( w );
+        }
+
+        // Change permission
+        if ( !Os.isFamily( "windows" ) )
+        {
+            Runtime.getRuntime().exec( new String[] { "chmod", "a+x", bat.getAbsolutePath() } );
+        }
+
+        Commandline cmd = new Commandline();
+        cmd.setExecutable( bat.getAbsolutePath() );
+        cmd.setWorkingDirectory( dir );
+
+        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();
+
+        try
+        {
+            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );
+
+            if ( exitCode != 0 )
+            {
+                StringBuffer msg = new StringBuffer( "Exit code: " + exitCode + " - " + err.getOutput() );
+                msg.append( '\n' );
+                msg.append( "Command line was:" + Commandline.toString( cmd.getCommandline() ) );
+                throw new Exception( msg.toString() );
+            }
+        }
+        catch ( CommandLineException e )
+        {
+            throw new Exception( "Unable to execute command: " + e.getMessage(), e );
+        }
+    }
 }
diff --git a/src/test/java/org/codehaus/plexus/util/xml/XmlReaderTest.java b/src/test/java/org/codehaus/plexus/util/xml/XmlReaderTest.java
new file mode 100644
index 00000000..9531bf5f
--- /dev/null
+++ b/src/test/java/org/codehaus/plexus/util/xml/XmlReaderTest.java
@@ -0,0 +1,133 @@
+package org.codehaus.plexus.util.xml;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+import org.codehaus.plexus.util.IOUtil;
+
+import junit.framework.ComparisonFailure;
+import junit.framework.TestCase;
+
+public class XmlReaderTest
+    extends TestCase
+{
+    /** french */
+    private static final String TEXT_LATIN1 = "eacute: \u00E9";
+    /** greek */
+    private static final String TEXT_LATIN7 = "alpha: \u03B1";
+    /** euro support */
+    private static final String TEXT_LATIN15 = "euro: \u20AC";
+    /** japanese */
+    private static final String TEXT_EUC_JP = "hiragana A: \u3042";
+    /** Unicode: support everything */
+    private static final String TEXT_UNICODE =
+        TEXT_LATIN1 + ", " +
+        TEXT_LATIN7 + ", " +
+        TEXT_LATIN15 + ", " +
+        TEXT_EUC_JP;
+
+    private static String createXmlContent( String text, String encoding )
+    {
+        String xmlDecl = "<?xml version=\"1.0\"?>";
+        if ( encoding != null )
+        {
+            xmlDecl = "<?xml version=\"1.0\" encoding=\"" + encoding + "\"?>";
+        }
+        String xml = xmlDecl + "\n<text>" + text + "</text>";
+        return xml;
+    }
+    
+    private static void checkXmlReader( String text, String encoding )
+    throws IOException
+    {
+        String xml = createXmlContent( text, encoding );
+        byte[] xmlContent = xml.getBytes( ( encoding == null ) ? "UTF-8" : encoding );
+        XmlReader reader = new XmlReader( new ByteArrayInputStream( xmlContent ) );
+        String result = IOUtil.toString( reader );
+        assertEquals( xml, result );
+    }
+
+    public void testNoXmlHeader()
+    throws IOException
+    {
+        String xml = "<text>text with no XML header</text>";
+        byte[] xmlContent = xml.getBytes( "UTF-8" );
+        XmlReader reader = new XmlReader( new ByteArrayInputStream( xmlContent ) );
+        String result = IOUtil.toString( reader );
+        assertEquals( xml, result );
+    }
+
+    public void testDefaultEncoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_UNICODE, null );
+    }
+
+    public void testUTF8Encoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_UNICODE, "UTF-8" );
+    }
+
+    public void testUTF16Encoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_UNICODE, "UTF-16" );
+    }
+
+    public void testUTF16BEEncoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_UNICODE, "UTF-16BE" );
+    }
+
+    public void testUTF16LEEncoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_UNICODE, "UTF-16LE" );
+    }
+
+    public void testLatin1Encoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_LATIN1, "ISO-8859-1" );
+    }
+
+    public void testLatin7Encoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_LATIN7, "ISO-8859-7" );
+    }
+
+    public void testLatin15Encoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_LATIN15, "ISO-8859-15" );
+    }
+
+    public void testEUC_JPEncoding()
+    throws IOException
+    {
+        checkXmlReader( TEXT_EUC_JP, "EUC-JP" );
+    }
+
+    public void testEBCDICEncoding()
+    throws IOException
+    {
+        checkXmlReader( "simple text in EBCDIC", "CP1047" );
+    }
+
+    public void testInappropriateEncoding()
+    throws IOException
+    {
+        try
+        {
+            checkXmlReader( TEXT_UNICODE, "ISO-8859-2" );
+            fail( "Check should have failed, since some characters are not available in the specified encoding" );
+        }
+        catch ( ComparisonFailure cf )
+        {
+            // expected failure, since the encoding does not contain some characters
+        }
+    }
+}
diff --git a/src/test/java/org/codehaus/plexus/util/xml/Xpp3DomTest.java b/src/test/java/org/codehaus/plexus/util/xml/Xpp3DomTest.java
index 64bd57cb..f0f5e45b 100644
--- a/src/test/java/org/codehaus/plexus/util/xml/Xpp3DomTest.java
+++ b/src/test/java/org/codehaus/plexus/util/xml/Xpp3DomTest.java
@@ -1,5 +1,10 @@
 package org.codehaus.plexus.util.xml;
 
+import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
+
+import java.io.IOException;
+import java.io.StringReader;
+
 import junit.framework.TestCase;
 
 public class Xpp3DomTest
@@ -92,7 +97,7 @@ public void testShouldMergeValuesAtTopLevelByDefault()
 
         // this is still 2, since we're not using the merge-control attribute.
         assertEquals( 2, result.getAttributeNames().length );
-        
+
         assertEquals( result.getValue(), t2.getValue() );
     }
 
@@ -147,4 +152,43 @@ public void testEquals()
         assertFalse( dom.equals( null ) );
         assertFalse( dom.equals( new Xpp3Dom( (String) null ) ) );
     }
+
+    public void testShouldOverwritePluginConfigurationSubItemsByDefault()
+        throws XmlPullParserException, IOException
+    {
+        String parentConfigStr = "<configuration><items><item>one</item><item>two</item></items></configuration>";
+        Xpp3Dom parentConfig = Xpp3DomBuilder.build( new StringReader( parentConfigStr ) );
+
+        String childConfigStr = "<configuration><items><item>three</item></items></configuration>";
+        Xpp3Dom childConfig = Xpp3DomBuilder.build( new StringReader( childConfigStr ) );
+
+        Xpp3Dom result = Xpp3Dom.mergeXpp3Dom( childConfig, parentConfig );
+        Xpp3Dom items = result.getChild( "items" );
+
+        assertEquals( 1, items.getChildCount() );
+
+        Xpp3Dom item = items.getChild( 0 );
+        assertEquals( "three", item.getValue() );
+    }
+
+    public void testShouldMergePluginConfigurationSubItemsWithMergeAttributeSet()
+        throws XmlPullParserException, IOException
+    {
+        String parentConfigStr = "<configuration><items><item>one</item><item>two</item></items></configuration>";
+        Xpp3Dom parentConfig = Xpp3DomBuilder.build( new StringReader( parentConfigStr ) );
+
+        String childConfigStr = "<configuration><items combine.children=\"append\"><item>three</item></items></configuration>";
+        Xpp3Dom childConfig = Xpp3DomBuilder.build( new StringReader( childConfigStr ) );
+
+        Xpp3Dom result = Xpp3Dom.mergeXpp3Dom( childConfig, parentConfig );
+        Xpp3Dom items = result.getChild( "items" );
+
+        assertEquals( 3, items.getChildCount() );
+
+        Xpp3Dom[] item = items.getChildren();
+
+        assertEquals( "one", item[0].getValue() );
+        assertEquals( "two", item[1].getValue() );
+        assertEquals( "three", item[2].getValue() );
+    }
 }