diff --git a/.gitignore b/.gitignore
index b9e7986b1abb..8a80d67d0d91 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,28 +1,32 @@
-#Eclipse project files
+# Eclipse project files
 .project
 .classpath
 .settings
 
-#IntelliJ IDEA project files and directories
+# IntelliJ IDEA project files and directories
 *.iml
 *.ipr
 *.iws
 .idea/
 
-#Geany project file
+# Geany project file
 .geany
 
-#KDevelop project file and directory
+# KDevelop project file and directory
 .kdev4/
 *.kdev4
 
-#Build targets
+# Build targets
 /target
 */target
 
-#Report directories
+# Report directories
 /reports
 */reports
 
-#Mac-specific directory that no other operating system needs.
-.DS_Store
\ No newline at end of file
+# Mac-specific directory that no other operating system needs.
+.DS_Store
+
+# JVM crash logs
+hs_err_pid*.log
+
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 000000000000..1a8b4d84cd5c
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,46 @@
+## How to submit a bug report
+
+Please ensure to specify the following:
+
+* Netty version (e.g. 4.0.17.Final)
+* Contextual information (e.g. what you were trying to achieve with Netty)
+* Simplest possible steps to reproduce
+  * More complex the steps are, lower the priority will be.
+  * A pull request with failing JUnit test case is most preferred, although it's OK to paste the test case into the issue description.
+* Anything that might be relevant in your opinion, such as:
+  * JDK/JRE version or the output of `java -version`
+  * Operating system and the output of `uname -a`
+  * Network configuration
+
+
+### Example
+
+```
+Netty version: 4.0.17.Final
+
+Context:
+I encountered an exception which looks suspicious while load-testing my Netty-based Thrift server implementation.
+
+Steps to reproduce:
+1. ...
+2. ...
+3. ...
+4. ...
+
+$ java -version
+java version "1.7.0_51"
+Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
+Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)
+
+Operating system: Ubuntu Linux 13.04 64-bit
+
+$ uname -a
+Linux infinity 3.10.32-1-lts #1 SMP Sun Feb 23 09:44:24 CET 2014 x86_64 GNU/Linux
+
+My system has IPv6 disabled.
+```
+
+## How to contribute your work
+
+Before submitting a pull request or push a commit, please read [our developer guide](http://netty.io/wiki/developer-guide.html).
+
diff --git a/NOTICE.txt b/NOTICE.txt
index ef811d15d037..f30b1f531d72 100644
--- a/NOTICE.txt
+++ b/NOTICE.txt
@@ -6,7 +6,7 @@ Please visit the Netty web site for more information:
 
   * http://netty.io/
 
-Copyright 2011 The Netty Project
+Copyright 2014 The Netty Project
 
 The Netty Project licenses this file to you under the Apache License,
 version 2.0 (the "License"); you may not use this file except in compliance
@@ -50,14 +50,6 @@ WebSocket and HTTP server, which can be obtained at:
   * HOMEPAGE:
     * https://github.com/joewalnes/webbit
 
-This product contains a modified portion of 'Caliper', Google's micro-
-benchmarking framework, which can be obtained at:
-
-  * LICENSE:
-    * license/LICENSE.caliper.txt (Apache License 2.0)
-  * HOMEPAGE:
-    * http://code.google.com/p/caliper/
-
 This product contains a modified portion of 'SLF4J', a simple logging
 facade for Java, which can be obtained at:
 
@@ -72,6 +64,31 @@ Bloch of Google, Inc:
   * LICENSE:
     * license/LICENSE.deque.txt (Public Domain)
 
+This product contains a modified portion of 'Apache Harmony', an open source
+Java SE, which can be obtained at:
+
+  * LICENSE:
+    * license/LICENSE.harmony.txt (Apache License 2.0)
+  * HOMEPAGE:
+    * http://archive.apache.org/dist/harmony/
+
+This product contains a modified version of Roland Kuhn's ASL2
+AbstractNodeQueue, which is based on Dmitriy Vyukov's non-intrusive MPSC queue.
+It can be obtained at:
+
+  * LICENSE:
+    * license/LICENSE.abstractnodequeue.txt (Public Domain)
+  * HOMEPAGE:
+    * https://github.com/akka/akka/blob/wip-2.2.3-for-scala-2.11/akka-actor/src/main/java/akka/dispatch/AbstractNodeQueue.java
+
+This product contains a modified portion of 'jbzip2', a Java bzip2 compression
+and decompression library written by Matthew J. Francis. It can be obtained at:
+
+  * LICENSE:
+    * license/LICENSE.jbzip2.txt (MIT License)
+  * HOMEPAGE:
+    * https://code.google.com/p/jbzip2/
+
 This product optionally depends on 'JZlib', a re-implementation of zlib in
 pure Java, which can be obtained at:
 
@@ -88,6 +105,23 @@ interchange format, which can be obtained at:
   * HOMEPAGE:
     * http://code.google.com/p/protobuf/
 
+This product optionally depends on 'Bouncy Castle Crypto APIs' to generate
+a temporary self-signed X.509 certificate when the JVM does not provide the
+equivalent functionality.  It can be obtained at:
+
+  * LICENSE:
+    * license/LICENSE.bouncycastle.txt (MIT License)
+  * HOMEPAGE:
+    * http://www.bouncycastle.org/
+
+This product optionally depends on 'Snappy', a compression library produced
+by Google Inc, which can be obtained at:
+
+  * LICENSE:
+    * license/LICENSE.snappy.txt (New BSD License)
+  * HOMEPAGE:
+    * http://code.google.com/p/snappy/
+
 This product optionally depends on 'JBoss Marshalling', an alternative Java
 serialization API, which can be obtained at:
 
@@ -96,6 +130,14 @@ serialization API, which can be obtained at:
   * HOMEPAGE:
     * http://www.jboss.org/jbossmarshalling
 
+This product optionally depends on 'Caliper', Google's micro-
+benchmarking framework, which can be obtained at:
+
+  * LICENSE:
+    * license/LICENSE.caliper.txt (Apache License 2.0)
+  * HOMEPAGE:
+    * http://code.google.com/p/caliper/
+
 This product optionally depends on 'Apache Commons Logging', a logging
 framework, which can be obtained at:
 
@@ -112,10 +154,3 @@ can be obtained at:
   * HOMEPAGE:
     * http://logging.apache.org/log4j/
 
-This product optionally depends on 'Snappy', a compression library produced
-by Google Inc, which can be obtained at:
-
-  * LICENSE:
-    * license/LICENSE.snappy.txt (New BSD License)
-  * HOMEPAGE:
-    * http://code.google.com/p/snappy/
diff --git a/README.md b/README.md
index bf154aa3884a..6feeddc0fcdc 100644
--- a/README.md
+++ b/README.md
@@ -22,4 +22,5 @@ Note that this is build-time requirement.  JDK 5 (for 3.x) or 6 (for 4.0+) is en
 
 ## Branches to look
 
-[The 'master' branch](https://github.com/netty/netty/tree/master) is where the development of the latest major version lives on.  The development of all other major versions takes place in each branch whose name is identical to its major version number.  For example, the development of 3.x and 4.x resides in [the branch '3'](https://github.com/netty/netty/tree/3) and [the branch '4'](https://github.com/netty/netty/tree/4) respectively.
+[The 'master' branch](https://github.com/netty/netty/tree/master) is where the development of the latest major version lives on.  The development of all other versions takes place in each branch whose name is identical to `<majorVersion>.<minorVersion>`.  For example, the development of 3.9 and 4.0 resides in [the branch '3.9'](https://github.com/netty/netty/tree/3.9) and [the branch '4.0'](https://github.com/netty/netty/tree/4.0) respectively.
+
diff --git a/all/pom.xml b/all/pom.xml
index f09fd9dad043..41c133296ca2 100644
--- a/all/pom.xml
+++ b/all/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-all</artifactId>
@@ -31,7 +31,7 @@
   <properties>
     <quickbuild>true</quickbuild>
     <generatedSourceDir>${project.build.directory}/src</generatedSourceDir>
-    <dependencyVersionDir>${project.build.directory}/versions</dependencyVersionDir>
+    <dependencyVersionsDir>${project.build.directory}/versions</dependencyVersionsDir>
   </properties>
 
   <profiles>
@@ -41,18 +41,6 @@
         <quickbuild>false</quickbuild>
       </properties>
     </profile>
-    <profile>
-      <id>sonatype-oss-release</id>
-      <properties>
-        <quickbuild>false</quickbuild>
-      </properties>
-    </profile>
-    <profile>
-      <id>release</id>
-      <properties>
-        <quickbuild>false</quickbuild>
-      </properties>
-    </profile>
     <profile>
       <id>coverage</id>
       <build>
@@ -93,10 +81,29 @@
         </plugins>
       </build>
     </profile>
+    <profile>
+      <id>linux</id>
+      <activation>
+        <os>
+          <family>linux</family>
+        </os>
+      </activation>
+      <dependencies>
+        <!-- All release modules -->
+        <dependency>
+          <groupId>${project.groupId}</groupId>
+          <artifactId>netty-transport-native-epoll</artifactId>
+          <version>${project.version}</version>
+          <classifier>${os.detected.classifier}</classifier>
+          <scope>compile</scope>
+          <optional>true</optional>
+        </dependency>
+      </dependencies>
+    </profile>
   </profiles>
 
   <dependencies>
-  
+
     <!-- All release modules -->
     <dependency>
       <groupId>${project.groupId}</groupId>
@@ -112,6 +119,20 @@
       <scope>compile</scope>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec-dns</artifactId>
+      <version>${project.version}</version>
+      <scope>compile</scope>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec-haproxy</artifactId>
+      <version>${project.version}</version>
+      <scope>compile</scope>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>netty-codec-http</artifactId>
@@ -119,6 +140,20 @@
       <scope>compile</scope>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec-memcache</artifactId>
+      <version>${project.version}</version>
+      <scope>compile</scope>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec-mqtt</artifactId>
+      <version>${project.version}</version>
+      <scope>compile</scope>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>netty-codec-socks</artifactId>
@@ -126,6 +161,13 @@
       <scope>compile</scope>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec-stomp</artifactId>
+      <version>${project.version}</version>
+      <scope>compile</scope>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>netty-common</artifactId>
@@ -256,8 +298,9 @@
               <goal>unpack-dependencies</goal>
             </goals>
             <configuration>
-              <includes>io/netty/**</includes>
-              <excludes>io/netty/example/**</excludes>
+              <excludes>io/netty/example/**,META-INF/native/libnetty-tcnative*</excludes>
+              <includes>io/netty/**,META-INF/native/**</includes>
+              <includeGroupIds>${project.groupId}</includeGroupIds>
               <outputDirectory>${project.build.outputDirectory}</outputDirectory>
             </configuration>
           </execution>
@@ -309,7 +352,7 @@
             <configuration>
               <target>
                 <delete dir="${generatedSourceDir}" quiet="true" />
-                <delete dir="${dependencyVersionDir}" quiet="true" />
+                <delete dir="${dependencyVersionsDir}" quiet="true" />
                 <delete dir="${project.build.outputDirectory}" quiet="true" />
               </target>
             </configuration>
diff --git a/buffer/pom.xml b/buffer/pom.xml
index d6f7ba0a379f..0505c1dc47d2 100644
--- a/buffer/pom.xml
+++ b/buffer/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-buffer</artifactId>
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
index 1ec4afa71fad..1f80a39e4c7d 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
@@ -38,7 +38,7 @@ public abstract class AbstractByteBuf extends ByteBuf {
     static final ResourceLeakDetector<ByteBuf> leakDetector = new ResourceLeakDetector<ByteBuf>(ByteBuf.class);
 
     int readerIndex;
-    private int writerIndex;
+    int writerIndex;
     private int markedReaderIndex;
     private int markedWriterIndex;
 
@@ -229,6 +229,7 @@ protected final void adjustMarkers(int decrement) {
 
     @Override
     public ByteBuf ensureWritable(int minWritableBytes) {
+        ensureAccessible();
         if (minWritableBytes < 0) {
             throw new IllegalArgumentException(String.format(
                     "minWritableBytes: %d (expected: >= 0)", minWritableBytes));
@@ -245,7 +246,7 @@ public ByteBuf ensureWritable(int minWritableBytes) {
         }
 
         // Normalize the current capacity to the power of 2.
-        int newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);
+        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);
 
         // Adjust to the new capacity.
         capacity(newCapacity);
@@ -275,41 +276,13 @@ public int ensureWritable(int minWritableBytes, boolean force) {
         }
 
         // Normalize the current capacity to the power of 2.
-        int newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);
+        int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);
 
         // Adjust to the new capacity.
         capacity(newCapacity);
         return 2;
     }
 
-    private int calculateNewCapacity(int minNewCapacity) {
-        final int maxCapacity = this.maxCapacity;
-        final int threshold = 1048576 * 4; // 4 MiB page
-
-        if (minNewCapacity == threshold) {
-            return threshold;
-        }
-
-        // If over threshold, do not double but just increase by threshold.
-        if (minNewCapacity > threshold) {
-            int newCapacity = minNewCapacity / threshold * threshold;
-            if (newCapacity > maxCapacity - threshold) {
-                newCapacity = maxCapacity;
-            } else {
-                newCapacity += threshold;
-            }
-            return newCapacity;
-        }
-
-        // Not over threshold. Double up to 4 MiB, starting from 64.
-        int newCapacity = 64;
-        while (newCapacity < minNewCapacity) {
-            newCapacity <<= 1;
-        }
-
-        return Math.min(newCapacity, maxCapacity);
-    }
-
     @Override
     public ByteBuf order(ByteOrder endianness) {
         if (endianness == null) {
@@ -321,11 +294,18 @@ public ByteBuf order(ByteOrder endianness) {
 
         SwappedByteBuf swappedBuf = this.swappedBuf;
         if (swappedBuf == null) {
-            this.swappedBuf = swappedBuf = new SwappedByteBuf(this);
+            this.swappedBuf = swappedBuf = newSwappedByteBuf();
         }
         return swappedBuf;
     }
 
+    /**
+     * Creates a new {@link SwappedByteBuf} for this {@link ByteBuf} instance.
+     */
+    protected SwappedByteBuf newSwappedByteBuf() {
+        return new SwappedByteBuf(this);
+    }
+
     @Override
     public byte getByte(int index) {
         checkIndex(index);
@@ -995,11 +975,12 @@ public int forEachByte(ByteBufProcessor processor) {
 
     @Override
     public int forEachByte(int index, int length, ByteBufProcessor processor) {
-        checkIndex(index, length);
         return forEachByteAsc0(index, length, processor);
     }
 
     private int forEachByteAsc0(int index, int length, ByteBufProcessor processor) {
+        checkIndex(index, length);
+
         if (processor == null) {
             throw new NullPointerException("processor");
         }
@@ -1034,11 +1015,12 @@ public int forEachByteDesc(ByteBufProcessor processor) {
 
     @Override
     public int forEachByteDesc(int index, int length, ByteBufProcessor processor) {
-        checkIndex(index, length);
         return forEachByteDesc0(index, length, processor);
     }
 
     private int forEachByteDesc0(int index, int length, ByteBufProcessor processor) {
+        checkIndex(index, length);
+
         if (processor == null) {
             throw new NullPointerException("processor");
         }
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java
index 4d39bc29eedf..7eda9d97bb9f 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java
@@ -96,9 +96,9 @@ public ByteBuf buffer(int initialCapacity, int maxCapacity) {
     @Override
     public ByteBuf ioBuffer() {
         if (PlatformDependent.hasUnsafe()) {
-            return directBuffer(0);
+            return directBuffer(DEFAULT_INITIAL_CAPACITY);
         }
-        return heapBuffer(0);
+        return heapBuffer(DEFAULT_INITIAL_CAPACITY);
     }
 
     @Override
@@ -216,4 +216,40 @@ private static void validate(int initialCapacity, int maxCapacity) {
     public String toString() {
         return StringUtil.simpleClassName(this) + "(directByDefault: " + directByDefault + ')';
     }
+
+    @Override
+    public int calculateNewCapacity(int minNewCapacity, int maxCapacity) {
+        if (minNewCapacity < 0) {
+            throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expectd: 0+)");
+        }
+        if (minNewCapacity > maxCapacity) {
+            throw new IllegalArgumentException(String.format(
+                    "minNewCapacity: %d (expected: not greater than maxCapacity(%d)",
+                    minNewCapacity, maxCapacity));
+        }
+        final int threshold = 1048576 * 4; // 4 MiB page
+
+        if (minNewCapacity == threshold) {
+            return threshold;
+        }
+
+        // If over threshold, do not double but just increase by threshold.
+        if (minNewCapacity > threshold) {
+            int newCapacity = minNewCapacity / threshold * threshold;
+            if (newCapacity > maxCapacity - threshold) {
+                newCapacity = maxCapacity;
+            } else {
+                newCapacity += threshold;
+            }
+            return newCapacity;
+        }
+
+        // Not over threshold. Double up to 4 MiB, starting from 64.
+        int newCapacity = 64;
+        while (newCapacity < minNewCapacity) {
+            newCapacity <<= 1;
+        }
+
+        return Math.min(newCapacity, maxCapacity);
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
index d4d24f11b744..e385fa2c3165 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
@@ -45,6 +45,18 @@ public final ByteBuf retain(int increment) {
         return this;
     }
 
+    @Override
+    public final ByteBuf touch() {
+        unwrap().touch();
+        return this;
+    }
+
+    @Override
+    public final ByteBuf touch(Object hint) {
+        unwrap().touch(hint);
+        return this;
+    }
+
     @Override
     public final boolean release() {
         return unwrap().release();
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index 08c498178d9b..c3e1f5a08b28 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -37,7 +37,6 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
         refCntUpdater = updater;
     }
 
-    @SuppressWarnings("FieldMayBeFinal")
     private volatile int refCnt = 1;
 
     protected AbstractReferenceCountedByteBuf(int maxCapacity) {
@@ -94,6 +93,16 @@ public ByteBuf retain(int increment) {
         return this;
     }
 
+    @Override
+    public ByteBuf touch() {
+        return this;
+    }
+
+    @Override
+    public ByteBuf touch(Object hint) {
+        return this;
+    }
+
     @Override
     public final boolean release() {
         for (;;) {
diff --git a/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
index 443ee5bb5909..3866baf967d3 100644
--- a/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
@@ -36,28 +36,6 @@ final class AdvancedLeakAwareByteBuf extends WrappedByteBuf {
         this.leak = leak;
     }
 
-    @Override
-    public boolean release() {
-        boolean deallocated =  super.release();
-        if (deallocated) {
-            leak.close();
-        } else {
-            leak.record();
-        }
-        return deallocated;
-    }
-
-    @Override
-    public boolean release(int decrement) {
-        boolean deallocated = super.release(decrement);
-        if (deallocated) {
-            leak.close();
-        } else {
-            leak.record();
-        }
-        return deallocated;
-    }
-
     @Override
     public ByteBuf order(ByteOrder endianness) {
         leak.record();
@@ -704,6 +682,12 @@ public String toString(int index, int length, Charset charset) {
         return super.toString(index, length, charset);
     }
 
+    @Override
+    public ByteBuf capacity(int newCapacity) {
+        leak.record();
+        return super.capacity(newCapacity);
+    }
+
     @Override
     public ByteBuf retain() {
         leak.record();
@@ -717,8 +701,36 @@ public ByteBuf retain(int increment) {
     }
 
     @Override
-    public ByteBuf capacity(int newCapacity) {
+    public ByteBuf touch() {
         leak.record();
-        return super.capacity(newCapacity);
+        return this;
+    }
+
+    @Override
+    public ByteBuf touch(Object hint) {
+        leak.record(hint);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        boolean deallocated = super.release();
+        if (deallocated) {
+            leak.close();
+        } else {
+            leak.record();
+        }
+        return deallocated;
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        boolean deallocated = super.release(decrement);
+        if (deallocated) {
+            leak.close();
+        } else {
+            leak.record();
+        }
+        return deallocated;
     }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBuf.java b/buffer/src/main/java/io/netty/buffer/ByteBuf.java
index be93120efc01..4d399c683e6b 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java
@@ -1877,4 +1877,10 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
 
     @Override
     public abstract ByteBuf retain();
+
+    @Override
+    public abstract ByteBuf touch();
+
+    @Override
+    public abstract ByteBuf touch(Object hint);
 }
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java
index 9ced16c18570..c30d96204625 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java
@@ -21,6 +21,8 @@
  */
 public interface ByteBufAllocator {
 
+    ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR;
+
     /**
      * Allocate a {@link ByteBuf}. If it is a direct or heap buffer
      * depends on the actual implementation.
@@ -41,7 +43,7 @@ public interface ByteBufAllocator {
     ByteBuf buffer(int initialCapacity, int maxCapacity);
 
     /**
-     * Allocate a {@link ByteBuf} whose initial capacity is 0, preferably a direct buffer which is suitable for I/O.
+     * Allocate a {@link ByteBuf}, preferably a direct buffer which is suitable for I/O.
      */
     ByteBuf ioBuffer();
 
@@ -123,4 +125,10 @@ public interface ByteBufAllocator {
      * Returns {@code true} if direct {@link ByteBuf}'s are pooled
      */
     boolean isDirectBufferPooled();
-}
+
+    /**
+     * Calculate the new capacity of a {@link ByteBuf} that is used when a {@link ByteBuf} needs to expand by the
+     * {@code minNewCapacity} with {@code maxCapacity} as upper-bound.
+     */
+    int calculateNewCapacity(int minNewCapacity, int maxCapacity);
+ }
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
index 7dea904baa75..c78cb6a45975 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
@@ -42,4 +42,10 @@ public interface ByteBufHolder extends ReferenceCounted {
 
     @Override
     ByteBufHolder retain(int increment);
+
+    @Override
+    ByteBufHolder touch();
+
+    @Override
+    ByteBufHolder touch(Object hint);
 }
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java
index 46b11b090c45..56496fadf456 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java
@@ -189,7 +189,7 @@ public String readLine() throws IOException {
 
         loop: while (true) {
             if (!buffer.isReadable()) {
-                return (lineBuf.length() > 0) ? lineBuf.toString() : null;
+                return lineBuf.length() > 0 ? lineBuf.toString() : null;
             }
 
             int c = buffer.readUnsignedByte();
@@ -198,7 +198,7 @@ public String readLine() throws IOException {
                     break loop;
 
                 case '\r':
-                    if (buffer.isReadable() && buffer.getUnsignedByte(buffer.readerIndex()) == '\n') {
+                    if (buffer.isReadable() && (char) buffer.getUnsignedByte(buffer.readerIndex()) == '\n') {
                         buffer.skipBytes(1);
                     }
                     break loop;
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
index 00d6640f506e..0aa9807f1bc6 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
@@ -16,6 +16,10 @@
 package io.netty.buffer;
 
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -25,20 +29,43 @@
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CoderResult;
+import java.util.Locale;
 
 /**
  * A collection of utility methods that is related with handling {@link ByteBuf}.
  */
 public final class ByteBufUtil {
 
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(ByteBufUtil.class);
+
     private static final char[] HEXDUMP_TABLE = new char[256 * 4];
 
+    static final ByteBufAllocator DEFAULT_ALLOCATOR;
+
     static {
         final char[] DIGITS = "0123456789abcdef".toCharArray();
         for (int i = 0; i < 256; i ++) {
             HEXDUMP_TABLE[ i << 1     ] = DIGITS[i >>> 4 & 0x0F];
             HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i       & 0x0F];
         }
+
+        String allocType = SystemPropertyUtil.get(
+                "io.netty.allocator.type", PlatformDependent.isAndroid() ? "unpooled" : "pooled");
+        allocType = allocType.toLowerCase(Locale.US).trim();
+
+        ByteBufAllocator alloc;
+        if ("unpooled".equals(allocType)) {
+            alloc = UnpooledByteBufAllocator.DEFAULT;
+            logger.debug("-Dio.netty.allocator.type: {}", allocType);
+        } else if ("pooled".equals(allocType)) {
+            alloc = PooledByteBufAllocator.DEFAULT;
+            logger.debug("-Dio.netty.allocator.type: {}", allocType);
+        } else {
+            alloc = PooledByteBufAllocator.DEFAULT;
+            logger.debug("-Dio.netty.allocator.type: pooled (unknown: {})", allocType);
+        }
+
+        DEFAULT_ALLOCATOR = alloc;
     }
 
     /**
@@ -75,6 +102,38 @@ public static String hexDump(ByteBuf buffer, int fromIndex, int length) {
         return new String(buf);
     }
 
+    /**
+     * Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>
+     * of the specified byte array.
+     */
+    public static String hexDump(byte[] array) {
+        return hexDump(array, 0, array.length);
+    }
+
+    /**
+     * Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>
+     * of the specified byte array's sub-region.
+     */
+    public static String hexDump(byte[] array, int fromIndex, int length) {
+        if (length < 0) {
+            throw new IllegalArgumentException("length: " + length);
+        }
+        if (length == 0) {
+            return "";
+        }
+
+        int endIndex = fromIndex + length;
+        char[] buf = new char[length << 1];
+
+        int srcIdx = fromIndex;
+        int dstIdx = 0;
+        for (; srcIdx < endIndex; srcIdx ++, dstIdx += 2) {
+            System.arraycopy(HEXDUMP_TABLE, (array[srcIdx] & 0xFF) << 1, buf, dstIdx, 2);
+        }
+
+        return new String(buf);
+    }
+
     /**
      * Calculates the hash code of the specified buffer.  This method is
      * useful when implementing a new buffer type.
@@ -324,7 +383,7 @@ public static ByteBuf encodeString(ByteBufAllocator alloc, CharBuffer src, Chars
             if (!cr.isUnderflow()) {
                 cr.throwException();
             }
-            dst.writerIndex(dst.writerIndex() + (dstBuf.position() - pos));
+            dst.writerIndex(dst.writerIndex() + dstBuf.position() - pos);
             release = false;
             return dst;
         } catch (CharacterCodingException x) {
diff --git a/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
index a67cb3914f25..818c97569f41 100644
--- a/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
@@ -289,7 +289,6 @@ private void consolidateIfNeeded() {
             ByteBuf consolidated = allocBuffer(capacity);
 
             // We're not using foreach to avoid creating an iterator.
-            // noinspection ForLoopReplaceableByForEach
             for (int i = 0; i < numComponents; i ++) {
                 Component c = components.get(i);
                 ByteBuf b = c.buf;
@@ -304,7 +303,7 @@ private void consolidateIfNeeded() {
     }
 
     private void checkComponentIndex(int cIndex) {
-        assert !freed;
+        ensureAccessible();
         if (cIndex < 0 || cIndex > components.size()) {
             throw new IndexOutOfBoundsException(String.format(
                     "cIndex: %d (expected: >= 0 && <= numComponents(%d))",
@@ -313,7 +312,7 @@ private void checkComponentIndex(int cIndex) {
     }
 
     private void checkComponentIndex(int cIndex, int numComponents) {
-        assert !freed;
+        ensureAccessible();
         if (cIndex < 0 || cIndex + numComponents > components.size()) {
             throw new IndexOutOfBoundsException(String.format(
                     "cIndex: %d, numComponents: %d " +
@@ -375,7 +374,7 @@ public CompositeByteBuf removeComponents(int cIndex, int numComponents) {
     }
 
     public Iterator<ByteBuf> iterator() {
-        assert !freed;
+        ensureAccessible();
         List<ByteBuf> list = new ArrayList<ByteBuf>(components.size());
         for (Component c: components) {
             list.add(c.buf);
@@ -492,7 +491,7 @@ public int capacity() {
 
     @Override
     public CompositeByteBuf capacity(int newCapacity) {
-        assert !freed;
+        ensureAccessible();
         if (newCapacity < 0 || newCapacity > maxCapacity()) {
             throw new IllegalArgumentException("newCapacity: " + newCapacity);
         }
@@ -569,7 +568,6 @@ public int maxNumComponents() {
      * Return the index for the given offset
      */
     public int toComponentIndex(int offset) {
-        assert !freed;
         checkIndex(offset);
 
         for (int low = 0, high = components.size(); low <= high;) {
@@ -1075,7 +1073,6 @@ public ByteBuf internalComponentAtOffset(int offset) {
     }
 
     private Component findComponent(int offset) {
-        assert !freed;
         checkIndex(offset);
 
         for (int low = 0, high = components.size(); low <= high;) {
@@ -1100,7 +1097,6 @@ public int nioBufferCount() {
         } else {
             int count = 0;
             int componentsCount = components.size();
-            //noinspection ForLoopReplaceableByForEach
             for (int i = 0; i < componentsCount; i++) {
                 Component c = components.get(i);
                 count += c.buf.nioBufferCount();
@@ -1173,7 +1169,7 @@ public ByteBuffer[] nioBuffers(int index, int length) {
      * Consolidate the composed {@link ByteBuf}s
      */
     public CompositeByteBuf consolidate() {
-        assert !freed;
+        ensureAccessible();
         final int numComponents = numComponents();
         if (numComponents <= 1) {
             return this;
@@ -1230,7 +1226,7 @@ public CompositeByteBuf consolidate(int cIndex, int numComponents) {
      * Discard all {@link ByteBuf}s which are read.
      */
     public CompositeByteBuf discardReadComponents() {
-        assert !freed;
+        ensureAccessible();
         final int readerIndex = readerIndex();
         if (readerIndex == 0) {
             return this;
@@ -1266,7 +1262,7 @@ public CompositeByteBuf discardReadComponents() {
 
     @Override
     public CompositeByteBuf discardReadBytes() {
-        assert !freed;
+        ensureAccessible();
         final int readerIndex = readerIndex();
         if (readerIndex == 0) {
             return this;
@@ -1570,6 +1566,22 @@ public CompositeByteBuf retain() {
         return (CompositeByteBuf) super.retain();
     }
 
+    @Override
+    public CompositeByteBuf touch() {
+        if (leak != null) {
+            leak.record();
+        }
+        return this;
+    }
+
+    @Override
+    public CompositeByteBuf touch(Object hint) {
+        if (leak != null) {
+            leak.record(hint);
+        }
+        return this;
+    }
+
     @Override
     public ByteBuffer[] nioBuffers() {
         return nioBuffers(readerIndex(), readableBytes());
diff --git a/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
index 974138a9ae90..c029accedf68 100644
--- a/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
+++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
@@ -68,6 +68,18 @@ public ByteBufHolder retain(int increment) {
         return this;
     }
 
+    @Override
+    public ByteBufHolder touch() {
+        data.touch();
+        return this;
+    }
+
+    @Override
+    public ByteBufHolder touch(Object hint) {
+        data.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         return data.release();
diff --git a/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
index 4364a5256149..9f8db897417d 100644
--- a/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
@@ -831,6 +831,16 @@ public ByteBuf retain(int increment) {
         return this;
     }
 
+    @Override
+    public ByteBuf touch() {
+        return this;
+    }
+
+    @Override
+    public ByteBuf touch(Object hint) {
+        return this;
+    }
+
     @Override
     public boolean release() {
         return false;
diff --git a/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
new file mode 100644
index 000000000000..816c0b41de9f
--- /dev/null
+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
@@ -0,0 +1,572 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.buffer;
+
+import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.RecyclableArrayList;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.ReadOnlyBufferException;
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.ScatteringByteChannel;
+import java.util.Collections;
+
+/**
+ * {@link ByteBuf} implementation which allows to wrap an array of {@link ByteBuf} in a read-only mode.
+ * This is useful to write an array of {@link ByteBuf}s.
+ */
+final class FixedCompositeByteBuf extends AbstractReferenceCountedByteBuf {
+    private static final ByteBuf[] EMPTY = { Unpooled.EMPTY_BUFFER };
+    private final int nioBufferCount;
+    private final int capacity;
+    private final ByteBufAllocator allocator;
+    private final ByteOrder order;
+    private final Object[] buffers;
+    private final boolean direct;
+
+    FixedCompositeByteBuf(ByteBufAllocator allocator, ByteBuf... buffers) {
+        super(Integer.MAX_VALUE);
+        if (buffers.length == 0) {
+            this.buffers = EMPTY;
+            order = ByteOrder.BIG_ENDIAN;
+            nioBufferCount = 1;
+            capacity = 0;
+            direct = buffers[0].isDirect();
+        } else {
+            ByteBuf b = buffers[0];
+            this.buffers = new Object[buffers.length];
+            this.buffers[0] = b;
+            boolean direct = true;
+            int nioBufferCount = b.nioBufferCount();
+            int capacity = b.readableBytes();
+            order = b.order();
+            for (int i = 1; i < buffers.length; i++) {
+                b = buffers[i];
+                if (buffers[i].order() != order) {
+                    throw new IllegalArgumentException("All ByteBufs need to have same ByteOrder");
+                }
+                nioBufferCount += b.nioBufferCount();
+                capacity += b.readableBytes();
+                if (!b.isDirect()) {
+                    direct = false;
+                }
+                this.buffers[i] = b;
+            }
+            this.nioBufferCount = nioBufferCount;
+            this.capacity = capacity;
+            this.direct = direct;
+        }
+        setIndex(0, capacity());
+        this.allocator = allocator;
+    }
+
+    @Override
+    public boolean isWritable() {
+        return false;
+    }
+
+    @Override
+    public boolean isWritable(int size) {
+        return false;
+    }
+
+    @Override
+    public ByteBuf discardReadBytes() {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, ByteBuffer src) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBuf setByte(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    protected void _setByte(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBuf setShort(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    protected void _setShort(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBuf setMedium(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    protected void _setMedium(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBuf setInt(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    protected void _setInt(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBuf setLong(int index, long value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    protected void _setLong(int index, long value) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public int setBytes(int index, InputStream in, int length) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public int setBytes(int index, ScatteringByteChannel in, int length) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public int capacity() {
+        return capacity;
+    }
+
+    @Override
+    public int maxCapacity() {
+        return capacity;
+    }
+
+    @Override
+    public ByteBuf capacity(int newCapacity) {
+        throw new ReadOnlyBufferException();
+    }
+
+    @Override
+    public ByteBufAllocator alloc() {
+        return allocator;
+    }
+
+    @Override
+    public ByteOrder order() {
+        return order;
+    }
+
+    @Override
+    public ByteBuf unwrap() {
+        return null;
+    }
+
+    @Override
+    public boolean isDirect() {
+        return direct;
+    }
+
+    private Component findComponent(int index) {
+        int readable = 0;
+        for (int i = 0 ; i < buffers.length; i++) {
+            Component comp = null;
+            ByteBuf b;
+            Object obj = buffers[i];
+            boolean isBuffer;
+            if (obj instanceof ByteBuf) {
+                b = (ByteBuf) obj;
+                isBuffer = true;
+            } else {
+                comp = (Component) obj;
+                b = comp.buf;
+                isBuffer = false;
+            }
+            readable += b.readableBytes();
+            if (index < readable) {
+                if (isBuffer) {
+                    // Create a new component ad store ti in the array so it not create a new object
+                    // on the next access.
+                    comp = new Component(i, readable - b.readableBytes(), b);
+                    buffers[i] = comp;
+                }
+                return comp;
+            }
+        }
+        throw new IllegalStateException();
+    }
+
+    /**
+     * Return the {@link ByteBuf} stored at the given index of the array.
+     */
+    private ByteBuf buffer(int i) {
+        Object obj = buffers[i];
+        if (obj instanceof ByteBuf) {
+            return (ByteBuf) obj;
+        }
+        return ((Component) obj).buf;
+    }
+
+    @Override
+    public byte getByte(int index) {
+        return _getByte(index);
+    }
+
+    @Override
+    protected byte _getByte(int index) {
+        Component c = findComponent(index);
+        return c.buf.getByte(index - c.offset);
+    }
+
+    @Override
+    protected short _getShort(int index) {
+        Component c = findComponent(index);
+        if (index + 2 <= c.endOffset) {
+            return c.buf.getShort(index - c.offset);
+        } else if (order() == ByteOrder.BIG_ENDIAN) {
+            return (short) ((_getByte(index) & 0xff) << 8 | _getByte(index + 1) & 0xff);
+        } else {
+            return (short) (_getByte(index) & 0xff | (_getByte(index + 1) & 0xff) << 8);
+        }
+    }
+
+    @Override
+    protected int _getUnsignedMedium(int index) {
+        Component c = findComponent(index);
+        if (index + 3 <= c.endOffset) {
+            return c.buf.getUnsignedMedium(index - c.offset);
+        } else if (order() == ByteOrder.BIG_ENDIAN) {
+            return (_getShort(index) & 0xffff) << 8 | _getByte(index + 2) & 0xff;
+        } else {
+            return _getShort(index) & 0xFFFF | (_getByte(index + 2) & 0xFF) << 16;
+        }
+    }
+
+    @Override
+    protected int _getInt(int index) {
+        Component c = findComponent(index);
+        if (index + 4 <= c.endOffset) {
+            return c.buf.getInt(index - c.offset);
+        } else if (order() == ByteOrder.BIG_ENDIAN) {
+            return (_getShort(index) & 0xffff) << 16 | _getShort(index + 2) & 0xffff;
+        } else {
+            return _getShort(index) & 0xFFFF | (_getShort(index + 2) & 0xFFFF) << 16;
+        }
+    }
+
+    @Override
+    protected long _getLong(int index) {
+        Component c = findComponent(index);
+        if (index + 8 <= c.endOffset) {
+            return c.buf.getLong(index - c.offset);
+        } else if (order() == ByteOrder.BIG_ENDIAN) {
+            return (_getInt(index) & 0xffffffffL) << 32 | _getInt(index + 4) & 0xffffffffL;
+        } else {
+            return _getInt(index) & 0xFFFFFFFFL | (_getInt(index + 4) & 0xFFFFFFFFL) << 32;
+        }
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
+        checkDstIndex(index, length, dstIndex, dst.length);
+        if (length == 0) {
+            return this;
+        }
+
+        Component c = findComponent(index);
+        int i = c.index;
+        int adjustment = c.offset;
+        ByteBuf s = c.buf;
+        for (;;) {
+            int localLength = Math.min(length, s.readableBytes() - (index - adjustment));
+            s.getBytes(index - adjustment, dst, dstIndex, localLength);
+            index += localLength;
+            dstIndex += localLength;
+            length -= localLength;
+            adjustment += s.readableBytes();
+            if (length <= 0) {
+                break;
+            }
+            s = buffer(++i);
+        }
+        return this;
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, ByteBuffer dst) {
+        int limit = dst.limit();
+        int length = dst.remaining();
+
+        checkIndex(index, length);
+        if (length == 0) {
+            return this;
+        }
+
+        try {
+            Component c = findComponent(index);
+            int i = c.index;
+            int adjustment = c.offset;
+            ByteBuf s = c.buf;
+            for (;;) {
+                int localLength = Math.min(length, s.capacity() - (index - adjustment));
+                dst.limit(dst.position() + localLength);
+                s.getBytes(index - adjustment, dst);
+                index += localLength;
+                length -= localLength;
+                adjustment += s.readableBytes();
+                if (length <= 0) {
+                    break;
+                }
+                s = buffer(++i);
+            }
+        } finally {
+            dst.limit(limit);
+        }
+        return this;
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
+        checkDstIndex(index, length, dstIndex, dst.capacity());
+        if (length == 0) {
+            return this;
+        }
+
+        Component c = findComponent(index);
+        int i = c.index;
+        int adjustment = c.offset;
+        ByteBuf s = c.buf;
+        for (;;) {
+            int localLength = Math.min(length, s.capacity() - (index - adjustment));
+            s.getBytes(index - adjustment, dst, dstIndex, localLength);
+            index += localLength;
+            dstIndex += localLength;
+            length -= localLength;
+            adjustment += s.readableBytes();
+            if (length <= 0) {
+                break;
+            }
+            s = buffer(++i);
+        }
+        return this;
+    }
+
+    @Override
+    public int getBytes(int index, GatheringByteChannel out, int length)
+            throws IOException {
+        int count = nioBufferCount();
+        if (count == 1) {
+            return out.write(internalNioBuffer(index, length));
+        } else {
+            long writtenBytes = out.write(nioBuffers(index, length));
+            if (writtenBytes > Integer.MAX_VALUE) {
+                return Integer.MAX_VALUE;
+            } else {
+                return (int) writtenBytes;
+            }
+        }
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, OutputStream out, int length) throws IOException {
+        checkIndex(index, length);
+        if (length == 0) {
+            return this;
+        }
+
+        Component c = findComponent(index);
+        int i = c.index;
+        int adjustment = c.offset;
+        ByteBuf s = c.buf;
+        for (;;) {
+            int localLength = Math.min(length, s.capacity() - (index - adjustment));
+            s.getBytes(index - adjustment, out, localLength);
+            index += localLength;
+            length -= localLength;
+            adjustment += s.readableBytes();
+            if (length <= 0) {
+                break;
+            }
+            s = buffer(++i);
+        }
+        return this;
+    }
+
+    @Override
+    public ByteBuf copy(int index, int length) {
+        checkIndex(index, length);
+        boolean release = true;
+        ByteBuf buf = alloc().buffer(length);
+        try {
+            buf.writeBytes(this, index, length);
+            release = false;
+            return buf;
+        } finally {
+            if (release) {
+                buf.release();
+            }
+        }
+    }
+
+    @Override
+    public int nioBufferCount() {
+        return nioBufferCount;
+    }
+
+    @Override
+    public ByteBuffer nioBuffer(int index, int length) {
+        checkIndex(index, length);
+        if (buffers.length == 1) {
+            ByteBuf buf = buffer(0);
+            if (buf.nioBufferCount() == 1) {
+                return buf.nioBuffer(index, length);
+            }
+        }
+        ByteBuffer merged = ByteBuffer.allocate(length).order(order());
+        ByteBuffer[] buffers = nioBuffers(index, length);
+
+        //noinspection ForLoopReplaceableByForEach
+        for (int i = 0; i < buffers.length; i++) {
+            merged.put(buffers[i]);
+        }
+
+        merged.flip();
+        return merged;
+    }
+
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        if (buffers.length == 1) {
+            return buffer(0).internalNioBuffer(index, length);
+        }
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        checkIndex(index, length);
+        if (length == 0) {
+            return EmptyArrays.EMPTY_BYTE_BUFFERS;
+        }
+
+        RecyclableArrayList array = RecyclableArrayList.newInstance(buffers.length);
+        try {
+            Component c = findComponent(index);
+            int i = c.index;
+            int adjustment = c.offset;
+            ByteBuf s = c.buf;
+            for (;;) {
+                int localLength = Math.min(length, s.capacity() - (index - adjustment));
+                switch (s.nioBufferCount()) {
+                    case 0:
+                        throw new UnsupportedOperationException();
+                    case 1:
+                        array.add(s.nioBuffer(index - adjustment, localLength));
+                        break;
+                    default:
+                        Collections.addAll(array, s.nioBuffers(index - adjustment, localLength));
+                }
+
+                index += localLength;
+                length -= localLength;
+                adjustment += s.readableBytes();
+                if (length <= 0) {
+                    break;
+                }
+                s = buffer(++i);
+            }
+
+            return array.toArray(new ByteBuffer[array.size()]);
+        } finally {
+            array.recycle();
+        }
+    }
+
+    @Override
+    public boolean hasArray() {
+        return false;
+    }
+
+    @Override
+    public byte[] array() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int arrayOffset() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean hasMemoryAddress() {
+        return false;
+    }
+
+    @Override
+    public long memoryAddress() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected void deallocate() {
+        for (int i = 0; i < buffers.length; i++) {
+             buffer(i).release();
+        }
+    }
+
+    @Override
+    public String toString() {
+        String result = super.toString();
+        result = result.substring(0, result.length() - 1);
+        return result + ", components=" + buffers.length + ')';
+    }
+
+    private static final class Component {
+        private final int index;
+        private final int offset;
+        private final ByteBuf buf;
+        private final int endOffset;
+
+        Component(int index, int offset, ByteBuf buf) {
+            this.index = index;
+            this.offset = offset;
+            endOffset = offset + buf.readableBytes();
+            this.buf = buf;
+        }
+    }
+}
diff --git a/buffer/src/main/java/io/netty/buffer/PoolArena.java b/buffer/src/main/java/io/netty/buffer/PoolArena.java
index 2beff46a898c..5f7998e66255 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolArena.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java
@@ -23,14 +23,16 @@
 
 abstract class PoolArena<T> {
 
+    static final int numTinySubpagePools = 512 >>> 4;
+
     final PooledByteBufAllocator parent;
 
-    private final int pageSize;
     private final int maxOrder;
-    private final int pageShifts;
-    private final int chunkSize;
-    private final int subpageOverflowMask;
-
+    final int pageSize;
+    final int pageShifts;
+    final int chunkSize;
+    final int subpageOverflowMask;
+    final int numSmallSubpagePools;
     private final PoolSubpage<T>[] tinySubpagePools;
     private final PoolSubpage<T>[] smallSubpagePools;
 
@@ -51,13 +53,13 @@ protected PoolArena(PooledByteBufAllocator parent, int pageSize, int maxOrder, i
         this.pageShifts = pageShifts;
         this.chunkSize = chunkSize;
         subpageOverflowMask = ~(pageSize - 1);
-
-        tinySubpagePools = newSubpagePoolArray(512 >>> 4);
+        tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);
         for (int i = 0; i < tinySubpagePools.length; i ++) {
             tinySubpagePools[i] = newSubpagePoolHead(pageSize);
         }
 
-        smallSubpagePools = newSubpagePoolArray(pageShifts - 9);
+        numSmallSubpagePools = pageShifts - 9;
+        smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);
         for (int i = 0; i < smallSubpagePools.length; i ++) {
             smallSubpagePools[i] = newSubpagePoolHead(pageSize);
         }
@@ -89,27 +91,56 @@ private PoolSubpage<T>[] newSubpagePoolArray(int size) {
         return new PoolSubpage[size];
     }
 
+    abstract boolean isDirect();
+
     PooledByteBuf<T> allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) {
         PooledByteBuf<T> buf = newByteBuf(maxCapacity);
         allocate(cache, buf, reqCapacity);
         return buf;
     }
 
+    static int tinyIdx(int normCapacity) {
+        return normCapacity >>> 4;
+    }
+
+    static int smallIdx(int normCapacity) {
+        int tableIdx = 0;
+        int i = normCapacity >>> 10;
+        while (i != 0) {
+            i >>>= 1;
+            tableIdx ++;
+        }
+        return tableIdx;
+    }
+
+    // capacity < pageSize
+    boolean isTinyOrSmall(int normCapacity) {
+        return (normCapacity & subpageOverflowMask) == 0;
+    }
+
+    // normCapacity < 512
+    static boolean isTiny(int normCapacity) {
+        return (normCapacity & 0xFFFFFE00) == 0;
+    }
+
     private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {
         final int normCapacity = normalizeCapacity(reqCapacity);
-        if ((normCapacity & subpageOverflowMask) == 0) { // capacity < pageSize
+        if (isTinyOrSmall(normCapacity)) { // capacity < pageSize
             int tableIdx;
             PoolSubpage<T>[] table;
-            if ((normCapacity & 0xFFFFFE00) == 0) { // < 512
-                tableIdx = normCapacity >>> 4;
+            if (isTiny(normCapacity)) { // < 512
+                if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) {
+                    // was able to allocate out of the cache so move on
+                    return;
+                }
+                tableIdx = tinyIdx(normCapacity);
                 table = tinySubpagePools;
             } else {
-                tableIdx = 0;
-                int i = normCapacity >>> 10;
-                while (i != 0) {
-                    i >>>= 1;
-                    tableIdx ++;
+                if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) {
+                    // was able to allocate out of the cache so move on
+                    return;
                 }
+                tableIdx = smallIdx(normCapacity);
                 table = smallSubpagePools;
             }
 
@@ -124,11 +155,16 @@ private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int req
                     return;
                 }
             }
-        } else if (normCapacity > chunkSize) {
+        } else if (normCapacity <= chunkSize) {
+            if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) {
+                // was able to allocate out of the cache so move on
+                return;
+            }
+        } else {
+            // Huge allocations are never served via the cache so just call allocateHuge
             allocateHuge(buf, reqCapacity);
             return;
         }
-
         allocateNormal(buf, reqCapacity, normCapacity);
     }
 
@@ -151,10 +187,15 @@ private void allocateHuge(PooledByteBuf<T> buf, int reqCapacity) {
         buf.initUnpooled(newUnpooledChunk(reqCapacity), reqCapacity);
     }
 
-     void free(PoolChunk<T> chunk, long handle) {
+    void free(PoolChunk<T> chunk, long handle, int normCapacity) {
         if (chunk.unpooled) {
             destroyChunk(chunk);
         } else {
+            PoolThreadCache cache = parent.threadCache.get();
+            if (cache.add(this, chunk, handle, normCapacity)) {
+                // cached so not free it.
+                return;
+            }
             synchronized (this) {
                 chunk.parent.free(chunk, handle);
             }
@@ -164,7 +205,7 @@ void free(PoolChunk<T> chunk, long handle) {
     PoolSubpage<T> findSubpagePoolHead(int elemSize) {
         int tableIdx;
         PoolSubpage<T>[] table;
-        if ((elemSize & 0xFFFFFE00) == 0) { // < 512
+        if (isTiny(elemSize)) { // < 512
             tableIdx = elemSize >>> 4;
             table = tinySubpagePools;
         } else {
@@ -180,7 +221,7 @@ PoolSubpage<T> findSubpagePoolHead(int elemSize) {
         return table[tableIdx];
     }
 
-    private int normalizeCapacity(int reqCapacity) {
+    int normalizeCapacity(int reqCapacity) {
         if (reqCapacity < 0) {
             throw new IllegalArgumentException("capacity: " + reqCapacity + " (expected: 0+)");
         }
@@ -188,10 +229,11 @@ private int normalizeCapacity(int reqCapacity) {
             return reqCapacity;
         }
 
-        if ((reqCapacity & 0xFFFFFE00) != 0) { // >= 512
+        if (!isTiny(reqCapacity)) { // >= 512
             // Doubled
 
             int normalizedCapacity = reqCapacity;
+            normalizedCapacity --;
             normalizedCapacity |= normalizedCapacity >>>  1;
             normalizedCapacity |= normalizedCapacity >>>  2;
             normalizedCapacity |= normalizedCapacity >>>  4;
@@ -228,7 +270,7 @@ void reallocate(PooledByteBuf<T> buf, int newCapacity, boolean freeOldMemory) {
         long oldHandle = buf.handle;
         T oldMemory = buf.memory;
         int oldOffset = buf.offset;
-
+        int oldMaxLength = buf.maxLength;
         int readerIndex = buf.readerIndex();
         int writerIndex = buf.writerIndex();
 
@@ -253,7 +295,7 @@ void reallocate(PooledByteBuf<T> buf, int newCapacity, boolean freeOldMemory) {
         buf.setIndex(readerIndex, writerIndex);
 
         if (freeOldMemory) {
-            free(oldChunk, oldHandle);
+            free(oldChunk, oldHandle, oldMaxLength);
         }
     }
 
@@ -339,6 +381,11 @@ static final class HeapArena extends PoolArena<byte[]> {
             super(parent, pageSize, maxOrder, pageShifts, chunkSize);
         }
 
+        @Override
+        boolean isDirect() {
+            return false;
+        }
+
         @Override
         protected PoolChunk<byte[]> newChunk(int pageSize, int maxOrder, int pageShifts, int chunkSize) {
             return new PoolChunk<byte[]>(this, new byte[chunkSize], pageSize, maxOrder, pageShifts, chunkSize);
@@ -377,6 +424,11 @@ static final class DirectArena extends PoolArena<ByteBuffer> {
             super(parent, pageSize, maxOrder, pageShifts, chunkSize);
         }
 
+        @Override
+        boolean isDirect() {
+            return true;
+        }
+
         @Override
         protected PoolChunk<ByteBuffer> newChunk(int pageSize, int maxOrder, int pageShifts, int chunkSize) {
             return new PoolChunk<ByteBuffer>(
diff --git a/buffer/src/main/java/io/netty/buffer/PoolChunk.java b/buffer/src/main/java/io/netty/buffer/PoolChunk.java
index 9b6dd41f5201..0eb8ce11c28a 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolChunk.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java
@@ -16,31 +16,110 @@
 
 package io.netty.buffer;
 
-final class PoolChunk<T> {
-    private static final int ST_UNUSED = 0;
-    private static final int ST_BRANCH = 1;
-    private static final int ST_ALLOCATED = 2;
-    private static final int ST_ALLOCATED_SUBPAGE = ST_ALLOCATED | 1;
+/**
+ * Description of algorithm for PageRun/PoolSubpage allocation from PoolChunk
+ *
+ * Notation: The following terms are important to understand the code
+ * > page  - a page is the smallest unit of memory chunk that can be allocated
+ * > chunk - a chunk is a collection of pages
+ * > in this code chunkSize = 2^{maxOrder} * pageSize
+ *
+ * To begin we allocate a byte array of size = chunkSize
+ * Whenever a ByteBuf of given size needs to be created we search for the first position
+ * in the byte array that has enough empty space to accommodate the requested size and
+ * return a (long) handle that encodes this offset information, (this memory segment is then
+ * marked as reserved so it is always used by exactly one ByteBuf and no more)
+ *
+ * For simplicity all sizes are normalized according to PoolArena#normalizeCapacity method
+ * This ensures that when we request for memory segments of size >= pageSize the normalizedCapacity
+ * equals the next nearest power of 2
+ *
+ * To search for the first offset in chunk that has at least requested size available we construct a
+ * complete balanced binary tree and store it in an array (just like heaps) - memoryMap
+ *
+ * The tree looks like this (the size of each node being mentioned in the parenthesis)
+ *
+ * depth=0        1 node (chunkSize)
+ * depth=1        2 nodes (chunkSize/2)
+ * ..
+ * ..
+ * depth=d        2^d nodes (chunkSize/2^d)
+ * ..
+ * depth=maxOrder 2^maxOrder nodes (chunkSize/2^{maxOrder} = pageSize)
+ *
+ * depth=maxOrder is the last level and the leafs consist of pages
+ *
+ * With this tree available searching in chunkArray translates like this:
+ * To allocate a memory segment of size chunkSize/2^k we search for the first node (from left) at height k
+ * which is unused
+ *
+ * Algorithm:
+ * ----------
+ * Encode the tree in memoryMap with the notation
+ *   memoryMap[id] = x => in the subtree rooted at id, the first node that is free to be allocated
+ *   is at depth x (counted from depth=0) i.e., at depths [depth_of_id, x), there is no node that is free
+ *
+ *  As we allocate & free nodes, we update values stored in memoryMap so that the property is maintained
+ *
+ * Initialization -
+ *   In the beginning we construct the memoryMap array by storing the depth of a node at each node
+ *     i.e., memoryMap[id] = depth_of_id
+ *
+ * Observations:
+ * -------------
+ * 1) memoryMap[id] = depth_of_id  => it is free / unallocated
+ * 2) memoryMap[id] > depth_of_id  => at least one of its child nodes is allocated, so we cannot allocate it, but
+ *                                    some of its children can still be allocated based on their availability
+ * 3) memoryMap[id] = maxOrder + 1 => the node is fully allocated & thus none of its children can be allocated, it
+ *                                    is thus marked as unusable
+ *
+ * Algorithm: [allocateNode(d) => we want to find the first node (from left) at height h that can be allocated]
+ * ----------
+ * 1) start at root (i.e., depth = 0 or id = 1)
+ * 2) if memoryMap[1] > d => cannot be allocated from this chunk
+ * 3) if left node value <= h; we can allocate from left subtree so move to left and repeat until found
+ * 4) else try in right subtree
+ *
+ * Algorithm: [allocateRun(size)]
+ * ----------
+ * 1) Compute d = log_2(chunkSize/size)
+ * 2) Return allocateNode(d)
+ *
+ * Algorithm: [allocateSubpage(size)]
+ * ----------
+ * 1) use allocateNode(maxOrder) to find an empty (i.e., unused) leaf (i.e., page)
+ * 2) use this handle to construct the PoolSubpage object or if it already exists just call init(normCapacity)
+ *    note that this PoolSubpage object is added to subpagesPool in the PoolArena when we init() it
+ *
+ * Note:
+ * -----
+ * In the implementation for improving cache coherence,
+ * we store 2 pieces of information (i.e, 2 byte vals) as a short value in memoryMap
+ *
+ * memoryMap[id]= (depth_of_id, x)
+ * where as per convention defined above
+ * the second value (i.e, x) indicates that the first node which is free to be allocated is at depth x (from root)
+ */
 
-    private static final long multiplier = 0x5DEECE66DL;
-    private static final long addend = 0xBL;
-    private static final long mask = (1L << 48) - 1;
+final class PoolChunk<T> {
 
     final PoolArena<T> arena;
     final T memory;
     final boolean unpooled;
 
-    private final int[] memoryMap;
+    private final byte[] memoryMap;
+    private final byte[] depthMap;
     private final PoolSubpage<T>[] subpages;
     /** Used to determine if the requested capacity is equal to or greater than pageSize. */
     private final int subpageOverflowMask;
     private final int pageSize;
     private final int pageShifts;
-
+    private final int maxOrder;
     private final int chunkSize;
+    private final int log2ChunkSize;
     private final int maxSubpageAllocs;
-
-    private long random = (System.nanoTime() ^ multiplier) & mask;
+    /** Used to mark memory as unusable */
+    private final byte unusable;
 
     private int freeBytes;
 
@@ -57,21 +136,27 @@ final class PoolChunk<T> {
         this.memory = memory;
         this.pageSize = pageSize;
         this.pageShifts = pageShifts;
+        this.maxOrder = maxOrder;
         this.chunkSize = chunkSize;
+        unusable = (byte) (maxOrder + 1);
+        log2ChunkSize = log2(chunkSize);
         subpageOverflowMask = ~(pageSize - 1);
         freeBytes = chunkSize;
 
-        int chunkSizeInPages = chunkSize >>> pageShifts;
+        assert maxOrder < 30 : "maxOrder should be < 30, but is: " + maxOrder;
         maxSubpageAllocs = 1 << maxOrder;
 
         // Generate the memory map.
-        memoryMap = new int[maxSubpageAllocs << 1];
+        memoryMap = new byte[maxSubpageAllocs << 1];
+        depthMap = new byte[memoryMap.length];
         int memoryMapIndex = 1;
-        for (int i = 0; i <= maxOrder; i ++) {
-            int runSizeInPages = chunkSizeInPages >>> i;
-            for (int j = 0; j < chunkSizeInPages; j += runSizeInPages) {
-                //noinspection PointlessBitwiseExpression
-                memoryMap[memoryMapIndex ++] = j << 17 | runSizeInPages << 2 | ST_UNUSED;
+        for (int d = 0; d <= maxOrder; ++ d) { // move down the tree one level at a time
+            int depth = 1 << d;
+            for (int p = 0; p < depth; ++ p) {
+                // in each level traverse left to right and set value to the depth of subtree
+                memoryMap[memoryMapIndex] = (byte) d;
+                depthMap[memoryMapIndex] = (byte) d;
+                memoryMapIndex ++;
             }
         }
 
@@ -84,11 +169,15 @@ final class PoolChunk<T> {
         this.arena = arena;
         this.memory = memory;
         memoryMap = null;
+        depthMap = null;
         subpages = null;
         subpageOverflowMask = 0;
         pageSize = 0;
         pageShifts = 0;
+        maxOrder = 0;
+        unusable = (byte) (maxOrder + 1);
         chunkSize = size;
+        log2ChunkSize = log2(chunkSize);
         maxSubpageAllocs = 0;
     }
 
@@ -98,6 +187,7 @@ private PoolSubpage<T>[] newSubpageArray(int size) {
     }
 
     int usage() {
+        final int freeBytes = this.freeBytes;
         if (freeBytes == 0) {
             return 100;
         }
@@ -110,228 +200,221 @@ int usage() {
     }
 
     long allocate(int normCapacity) {
-        int firstVal = memoryMap[1];
         if ((normCapacity & subpageOverflowMask) != 0) { // >= pageSize
-            return allocateRun(normCapacity, 1, firstVal);
+            return allocateRun(normCapacity);
         } else {
-            return allocateSubpage(normCapacity, 1, firstVal);
+            return allocateSubpage(normCapacity);
         }
     }
 
-    private long allocateRun(int normCapacity, int curIdx, int val) {
-        for (;;) {
-            if ((val & ST_ALLOCATED) != 0) { // state == ST_ALLOCATED || state == ST_ALLOCATED_SUBPAGE
-                return -1;
-            }
-
-            if ((val & ST_BRANCH) != 0) { // state == ST_BRANCH
-                int nextIdx = curIdx << 1 ^ nextRandom();
-                long res = allocateRun(normCapacity, nextIdx, memoryMap[nextIdx]);
-                if (res > 0) {
-                    return res;
-                }
+    /**
+     * Update method used by allocate
+     * This is triggered only when a successor is allocated and all its predecessors
+     * need to update their state
+     * The minimal depth at which subtree rooted at id has some free space
+     *
+     * @param id id
+     */
+    private void updateParentsAlloc(int id) {
+        while (id > 1) {
+            int parentId = id >>> 1;
+            byte val1 = value(id);
+            byte val2 = value(id ^ 1);
+            byte val = val1 < val2 ? val1 : val2;
+            setValue(parentId, val);
+            id = parentId;
+        }
+    }
 
-                curIdx = nextIdx ^ 1;
-                val = memoryMap[curIdx];
-                continue;
+    /**
+     * Update method used by free
+     * This needs to handle the special case when both children are completely free
+     * in which case parent be directly allocated on request of size = child-size * 2
+     *
+     * @param id id
+     */
+    private void updateParentsFree(int id) {
+        int logChild = depth(id) + 1;
+        while (id > 1) {
+            int parentId = id >>> 1;
+            byte val1 = value(id);
+            byte val2 = value(id ^ 1);
+            logChild -= 1; // in first iteration equals log, subsequently reduce 1 from logChild as we traverse up
+
+            if (val1 == logChild && val2 == logChild) {
+                setValue(parentId, (byte) (logChild - 1));
+            } else {
+                byte val = val1 < val2 ? val1 : val2;
+                setValue(parentId, val);
             }
 
-            // state == ST_UNUSED
-            return allocateRunSimple(normCapacity, curIdx, val);
+            id = parentId;
         }
     }
 
-    private long allocateRunSimple(int normCapacity, int curIdx, int val) {
-        int runLength = runLength(val);
-        if (normCapacity > runLength) {
+    /**
+     * Algorithm to allocate an index in memoryMap when we query for a free node
+     * at depth d
+     *
+     * @param d depth
+     * @return index in memoryMap
+     */
+    private int allocateNode(int d) {
+        int id = 1;
+        int initial = - (1 << d); // has last d bits = 0 and rest all = 1
+        byte val = value(id);
+        if (val > d) { // unusable
             return -1;
         }
-
-        for (;;) {
-            if (normCapacity == runLength) {
-                // Found the run that fits.
-                // Note that capacity has been normalized already, so we don't need to deal with
-                // the values that are not power of 2.
-                memoryMap[curIdx] = val & ~3 | ST_ALLOCATED;
-                freeBytes -= runLength;
-                return curIdx;
+        while (val < d || (id & initial) == 0) { // id & initial == 1 << d for all ids at depth d, for < d it is 0
+            id <<= 1;
+            val = value(id);
+            if (val > d) {
+                id ^= 1;
+                val = value(id);
             }
-
-            int nextIdx = curIdx << 1 ^ nextRandom();
-            int unusedIdx = nextIdx ^ 1;
-
-            memoryMap[curIdx] = val & ~3 | ST_BRANCH;
-            //noinspection PointlessBitwiseExpression
-            memoryMap[unusedIdx] = memoryMap[unusedIdx] & ~3 | ST_UNUSED;
-
-            runLength >>>= 1;
-            curIdx = nextIdx;
-            val = memoryMap[curIdx];
         }
+        byte value = value(id);
+        assert value == d && (id & initial) == 1 << d : String.format("val = %d, id & initial = %d, d = %d",
+                value, id & initial, d);
+        setValue(id, unusable); // mark as unusable
+        updateParentsAlloc(id);
+        return id;
     }
 
-    private long allocateSubpage(int normCapacity, int curIdx, int val) {
-        int state = val & 3;
-        if (state == ST_BRANCH) {
-            int nextIdx = curIdx << 1 ^ nextRandom();
-            long res = branchSubpage(normCapacity, nextIdx);
-            if (res > 0) {
-                return res;
-            }
-
-            return branchSubpage(normCapacity, nextIdx ^ 1);
-        }
-
-        if (state == ST_UNUSED) {
-            return allocateSubpageSimple(normCapacity, curIdx, val);
+    /**
+     * Allocate a run of pages (>=1)
+     *
+     * @param normCapacity normalized capacity
+     * @return index in memoryMap
+     */
+    private long allocateRun(int normCapacity) {
+        int d = maxOrder - (log2(normCapacity) - pageShifts);
+        int id = allocateNode(d);
+        if (id < 0) {
+            return id;
         }
-
-        if (state == ST_ALLOCATED_SUBPAGE) {
-            PoolSubpage<T> subpage = subpages[subpageIdx(curIdx)];
-            int elemSize = subpage.elemSize;
-            if (normCapacity != elemSize) {
-                return -1;
-            }
-
-            return subpage.allocate();
-        }
-
-        return -1;
+        freeBytes -= runLength(id);
+        return id;
     }
 
-    private long allocateSubpageSimple(int normCapacity, int curIdx, int val) {
-        int runLength = runLength(val);
-        for (;;) {
-            if (runLength == pageSize) {
-                memoryMap[curIdx] = val & ~3 | ST_ALLOCATED_SUBPAGE;
-                freeBytes -= runLength;
-
-                int subpageIdx = subpageIdx(curIdx);
-                PoolSubpage<T> subpage = subpages[subpageIdx];
-                if (subpage == null) {
-                    subpage = new PoolSubpage<T>(this, curIdx, runOffset(val), pageSize, normCapacity);
-                    subpages[subpageIdx] = subpage;
-                } else {
-                    subpage.init(normCapacity);
-                }
-                return subpage.allocate();
-            }
-
-            int nextIdx = curIdx << 1 ^ nextRandom();
-            int unusedIdx = nextIdx ^ 1;
+    /**
+     * Create/ initialize a new PoolSubpage of normCapacity
+     * Any PoolSubpage created/ initialized here is added to subpage pool in the PoolArena that owns this PoolChunk
+     *
+     * @param normCapacity normalized capacity
+     * @return index in memoryMap
+     */
+    private long allocateSubpage(int normCapacity) {
+        int d = maxOrder; // subpages are only be allocated from pages i.e., leaves
+        int id = allocateNode(d);
+        if (id < 0) {
+            return id;
+        }
 
-            memoryMap[curIdx] = val & ~3 | ST_BRANCH;
-            //noinspection PointlessBitwiseExpression
-            memoryMap[unusedIdx] = memoryMap[unusedIdx] & ~3 | ST_UNUSED;
+        final PoolSubpage<T>[] subpages = this.subpages;
+        final int pageSize = this.pageSize;
 
-            runLength >>>= 1;
-            curIdx = nextIdx;
-            val = memoryMap[curIdx];
-        }
-    }
+        freeBytes -= pageSize;
 
-    private long branchSubpage(int normCapacity, int nextIdx) {
-        int nextVal = memoryMap[nextIdx];
-        if ((nextVal & 3) != ST_ALLOCATED) {
-            return allocateSubpage(normCapacity, nextIdx, nextVal);
+        int subpageIdx = subpageIdx(id);
+        PoolSubpage<T> subpage = subpages[subpageIdx];
+        if (subpage == null) {
+            subpage = new PoolSubpage<T>(this, id, runOffset(id), pageSize, normCapacity);
+            subpages[subpageIdx] = subpage;
+        } else {
+            subpage.init(normCapacity);
         }
-        return -1;
+        return subpage.allocate();
     }
 
+    /**
+     * Free a subpage or a run of pages
+     * When a subpage is freed from PoolSubpage, it might be added back to subpage pool of the owning PoolArena
+     * If the subpage pool in PoolArena has at least one other PoolSubpage of given elemSize, we can
+     * completely free the owning Page so it is available for subsequent allocations
+     *
+     * @param handle handle to free
+     */
     void free(long handle) {
         int memoryMapIdx = (int) handle;
-        int bitmapIdx = (int) (handle >>> 32);
+        int bitmapIdx = (int) (handle >>> Integer.SIZE);
 
-        int val = memoryMap[memoryMapIdx];
-        int state = val & 3;
-        if (state == ST_ALLOCATED_SUBPAGE) {
-            assert bitmapIdx != 0;
+        if (bitmapIdx != 0) { // free a subpage
             PoolSubpage<T> subpage = subpages[subpageIdx(memoryMapIdx)];
             assert subpage != null && subpage.doNotDestroy;
             if (subpage.free(bitmapIdx & 0x3FFFFFFF)) {
                 return;
             }
-        } else {
-            assert state == ST_ALLOCATED : "state: " + state;
-            assert bitmapIdx == 0;
-        }
-
-        freeBytes += runLength(val);
-
-        for (;;) {
-            //noinspection PointlessBitwiseExpression
-            memoryMap[memoryMapIdx] = val & ~3 | ST_UNUSED;
-            if (memoryMapIdx == 1) {
-                assert freeBytes == chunkSize;
-                return;
-            }
-
-            if ((memoryMap[siblingIdx(memoryMapIdx)] & 3) != ST_UNUSED) {
-                break;
-            }
-
-            memoryMapIdx = parentIdx(memoryMapIdx);
-            val = memoryMap[memoryMapIdx];
         }
+        freeBytes += runLength(memoryMapIdx);
+        setValue(memoryMapIdx, depth(memoryMapIdx));
+        updateParentsFree(memoryMapIdx);
     }
 
     void initBuf(PooledByteBuf<T> buf, long handle, int reqCapacity) {
         int memoryMapIdx = (int) handle;
-        int bitmapIdx = (int) (handle >>> 32);
+        int bitmapIdx = (int) (handle >>> Integer.SIZE);
         if (bitmapIdx == 0) {
-            int val = memoryMap[memoryMapIdx];
-            assert (val & 3) == ST_ALLOCATED : String.valueOf(val & 3);
-            buf.init(this, handle, runOffset(val), reqCapacity, runLength(val));
+            byte val = value(memoryMapIdx);
+            assert val == unusable : String.valueOf(val);
+            buf.init(this, handle, runOffset(memoryMapIdx), reqCapacity, runLength(memoryMapIdx));
         } else {
             initBufWithSubpage(buf, handle, bitmapIdx, reqCapacity);
         }
     }
 
     void initBufWithSubpage(PooledByteBuf<T> buf, long handle, int reqCapacity) {
-        initBufWithSubpage(buf, handle, (int) (handle >>> 32), reqCapacity);
+        initBufWithSubpage(buf, handle, (int) (handle >>> Integer.SIZE), reqCapacity);
     }
 
     private void initBufWithSubpage(PooledByteBuf<T> buf, long handle, int bitmapIdx, int reqCapacity) {
         assert bitmapIdx != 0;
 
         int memoryMapIdx = (int) handle;
-        int val = memoryMap[memoryMapIdx];
-        assert (val & 3) == ST_ALLOCATED_SUBPAGE;
 
         PoolSubpage<T> subpage = subpages[subpageIdx(memoryMapIdx)];
         assert subpage.doNotDestroy;
         assert reqCapacity <= subpage.elemSize;
 
         buf.init(
-                this, handle,
-                runOffset(val) + (bitmapIdx & 0x3FFFFFFF) * subpage.elemSize, reqCapacity, subpage.elemSize);
+            this, handle,
+            runOffset(memoryMapIdx) + (bitmapIdx & 0x3FFFFFFF) * subpage.elemSize, reqCapacity, subpage.elemSize);
     }
 
-    private static int parentIdx(int memoryMapIdx) {
-        return memoryMapIdx >>> 1;
+    private byte value(int id) {
+        return memoryMap[id];
     }
 
-    private static int siblingIdx(int memoryMapIdx) {
-        return memoryMapIdx ^ 1;
+    private void setValue(int id, byte val) {
+        memoryMap[id] = val;
     }
 
-    private int runLength(int val) {
-        return (val >>> 2 & 0x7FFF) << pageShifts;
+    private byte depth(int id) {
+        return depthMap[id];
     }
 
-    private int runOffset(int val) {
-        return val >>> 17 << pageShifts;
+    private static int log2(int val) {
+        // compute the (0-based, with lsb = 0) position of highest set bit i.e, log2
+        return Integer.SIZE - 1 - Integer.numberOfLeadingZeros(val);
     }
 
-    private int subpageIdx(int memoryMapIdx) {
-        return memoryMapIdx - maxSubpageAllocs;
+    private int runLength(int id) {
+        // represents the size in #bytes supported by node 'id' in the tree
+        return 1 << log2ChunkSize - depth(id);
     }
 
-    private int nextRandom() {
-        random = random * multiplier + addend & mask;
-        return (int) (random >>> 47) & 1;
+    private int runOffset(int id) {
+        // represents the 0-based offset in #bytes from start of the byte-array chunk
+        int shift = id ^ 1 << depth(id);
+        return shift * runLength(id);
+    }
+
+    private int subpageIdx(int memoryMapIdx) {
+        return memoryMapIdx ^ maxSubpageAllocs; // remove highest set bit, to get offset
     }
 
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append("Chunk(");
diff --git a/buffer/src/main/java/io/netty/buffer/PoolSubpage.java b/buffer/src/main/java/io/netty/buffer/PoolSubpage.java
index e915ab7f9811..89cb680f6b4e 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolSubpage.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolSubpage.java
@@ -19,20 +19,20 @@
 final class PoolSubpage<T> {
 
     final PoolChunk<T> chunk;
-    final int memoryMapIdx;
-    final int runOffset;
-    final int pageSize;
-    final long[] bitmap;
+    private final int memoryMapIdx;
+    private final int runOffset;
+    private final int pageSize;
+    private final long[] bitmap;
 
     PoolSubpage<T> prev;
     PoolSubpage<T> next;
 
     boolean doNotDestroy;
     int elemSize;
-    int maxNumElems;
-    int nextAvail;
-    int bitmapLength;
-    int numAvail;
+    private int maxNumElems;
+    private int bitmapLength;
+    private int nextAvail;
+    private int numAvail;
 
     // TODO: Test if adding padding helps under contention
     //private long pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;
@@ -87,7 +87,7 @@ long allocate() {
             return -1;
         }
 
-        final int bitmapIdx = nextAvail;
+        final int bitmapIdx = getNextAvail();
         int q = bitmapIdx >>> 6;
         int r = bitmapIdx & 63;
         assert (bitmap[q] >>> r & 1) == 0;
@@ -95,9 +95,6 @@ long allocate() {
 
         if (-- numAvail == 0) {
             removeFromPool();
-            nextAvail = -1;
-        } else {
-            nextAvail = findNextAvailable();
         }
 
         return toHandle(bitmapIdx);
@@ -118,8 +115,9 @@ boolean free(int bitmapIdx) {
         assert (bitmap[q] >>> r & 1) != 0;
         bitmap[q] ^= 1L << r;
 
+        setNextAvail(bitmapIdx);
+
         if (numAvail ++ == 0) {
-            nextAvail = bitmapIdx;
             addToPool();
             return true;
         }
@@ -157,27 +155,47 @@ private void removeFromPool() {
         prev = null;
     }
 
-    private int findNextAvailable() {
-        int newNextAvail = -1;
-        loop:
+    private void setNextAvail(int bitmapIdx) {
+        nextAvail = bitmapIdx;
+    }
+
+    private int getNextAvail() {
+        int nextAvail = this.nextAvail;
+        if (nextAvail >= 0) {
+            this.nextAvail = -1;
+            return nextAvail;
+        }
+        return findNextAvail();
+    }
+
+    private int findNextAvail() {
+        final long[] bitmap = this.bitmap;
+        final int bitmapLength = this.bitmapLength;
         for (int i = 0; i < bitmapLength; i ++) {
             long bits = bitmap[i];
             if (~bits != 0) {
-                for (int j = 0; j < 64; j ++) {
-                    if ((bits & 1) == 0) {
-                        newNextAvail = i << 6 | j;
-                        break loop;
-                    }
-                    bits >>>= 1;
-                }
+                return findNextAvail0(i, bits);
             }
         }
+        return -1;
+    }
 
-        if (newNextAvail < maxNumElems) {
-            return newNextAvail;
-        } else {
-            return -1;
+    private int findNextAvail0(int i, long bits) {
+        final int maxNumElems = this.maxNumElems;
+        final int baseVal = i << 6;
+
+        for (int j = 0; j < 64; j ++) {
+            if ((bits & 1) == 0) {
+                int val = baseVal | j;
+                if (val < maxNumElems) {
+                    return val;
+                } else {
+                    break;
+                }
+            }
+            bits >>>= 1;
         }
+        return -1;
     }
 
     private long toHandle(int bitmapIdx) {
diff --git a/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
index 09ac499b04f0..37eea127c264 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
@@ -16,18 +16,470 @@
 
 package io.netty.buffer;
 
+
+import io.netty.util.ThreadDeathWatcher;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
 import java.nio.ByteBuffer;
 
+/**
+ * Acts a Thread cache for allocations. This implementation is moduled after
+ * <a href="http://people.freebsd.org/~jasone/jemalloc/bsdcan2006/jemalloc.pdf">jemalloc</a> and the descripted
+ * technics of <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/
+ * 480222803919">Scalable memory allocation using jemalloc</a>.
+ */
 final class PoolThreadCache {
 
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PoolThreadCache.class);
+
     final PoolArena<byte[]> heapArena;
     final PoolArena<ByteBuffer> directArena;
 
+    // Hold the caches for the different size classes, which are tiny, small and normal.
+    private final MemoryRegionCache<byte[]>[] tinySubPageHeapCaches;
+    private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;
+    private final MemoryRegionCache<ByteBuffer>[] tinySubPageDirectCaches;
+    private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;
+    private final MemoryRegionCache<byte[]>[] normalHeapCaches;
+    private final MemoryRegionCache<ByteBuffer>[] normalDirectCaches;
+
+    // Used for bitshifting when calculate the index of normal caches later
+    private final int numShiftsNormalDirect;
+    private final int numShiftsNormalHeap;
+    private final int freeSweepAllocationThreshold;
+
+    private int allocations;
+
+    private final Thread thread = Thread.currentThread();
+    private final Runnable freeTask = new Runnable() {
+        @Override
+        public void run() {
+            free0();
+        }
+    };
+
     // TODO: Test if adding padding helps under contention
     //private long pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;
 
-    PoolThreadCache(PoolArena<byte[]> heapArena, PoolArena<ByteBuffer> directArena) {
+    PoolThreadCache(PoolArena<byte[]> heapArena, PoolArena<ByteBuffer> directArena,
+                    int tinyCacheSize, int smallCacheSize, int normalCacheSize,
+                    int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {
+        if (maxCachedBufferCapacity < 0) {
+            throw new IllegalArgumentException("maxCachedBufferCapacity: "
+                    + maxCachedBufferCapacity + " (expected: >= 0)");
+        }
+        if (freeSweepAllocationThreshold < 1) {
+            throw new IllegalArgumentException("freeSweepAllocationThreshold: "
+                    + maxCachedBufferCapacity + " (expected: > 0)");
+        }
+        this.freeSweepAllocationThreshold = freeSweepAllocationThreshold;
         this.heapArena = heapArena;
         this.directArena = directArena;
+        if (directArena != null) {
+            tinySubPageDirectCaches = createSubPageCaches(tinyCacheSize, PoolArena.numTinySubpagePools);
+            smallSubPageDirectCaches = createSubPageCaches(smallCacheSize, directArena.numSmallSubpagePools);
+
+            numShiftsNormalDirect = log2(directArena.pageSize);
+            normalDirectCaches = createNormalCaches(
+                    normalCacheSize, maxCachedBufferCapacity, directArena);
+        } else {
+            // No directArea is configured so just null out all caches
+            tinySubPageDirectCaches = null;
+            smallSubPageDirectCaches = null;
+            normalDirectCaches = null;
+            numShiftsNormalDirect = -1;
+        }
+        if (heapArena != null) {
+            // Create the caches for the heap allocations
+            tinySubPageHeapCaches = createSubPageCaches(tinyCacheSize, PoolArena.numTinySubpagePools);
+            smallSubPageHeapCaches = createSubPageCaches(smallCacheSize, heapArena.numSmallSubpagePools);
+
+            numShiftsNormalHeap = log2(heapArena.pageSize);
+            normalHeapCaches = createNormalCaches(
+                    normalCacheSize, maxCachedBufferCapacity, heapArena);
+        } else {
+            // No heapArea is configured so just null out all caches
+            tinySubPageHeapCaches = null;
+            smallSubPageHeapCaches = null;
+            normalHeapCaches = null;
+            numShiftsNormalHeap = -1;
+        }
+
+        // The thread-local cache will keep a list of pooled buffers which must be returned to
+        // the pool when the thread is not alive anymore.
+        ThreadDeathWatcher.watch(thread, freeTask);
+    }
+
+    private static <T> SubPageMemoryRegionCache<T>[] createSubPageCaches(int cacheSize, int numCaches) {
+        if (cacheSize > 0) {
+            @SuppressWarnings("unchecked")
+            SubPageMemoryRegionCache<T>[] cache = new SubPageMemoryRegionCache[numCaches];
+            for (int i = 0; i < cache.length; i++) {
+                // TODO: maybe use cacheSize / cache.length
+                cache[i] = new SubPageMemoryRegionCache<T>(cacheSize);
+            }
+            return cache;
+        } else {
+            return null;
+        }
+    }
+
+    private static <T> NormalMemoryRegionCache<T>[] createNormalCaches(
+            int cacheSize, int maxCachedBufferCapacity, PoolArena<T> area) {
+        if (cacheSize > 0) {
+            int max = Math.min(area.chunkSize, maxCachedBufferCapacity);
+            int arraySize = Math.max(1, max / area.pageSize);
+
+            @SuppressWarnings("unchecked")
+            NormalMemoryRegionCache<T>[] cache = new NormalMemoryRegionCache[arraySize];
+            for (int i = 0; i < cache.length; i++) {
+                cache[i] = new NormalMemoryRegionCache<T>(cacheSize);
+            }
+            return cache;
+        } else {
+            return null;
+        }
+    }
+
+    private static int log2(int val) {
+        int res = 0;
+        while (val > 1) {
+            val >>= 1;
+            res++;
+        }
+        return res;
+    }
+
+    /**
+     * Try to allocate a tiny buffer out of the cache. Returns {@code true} if successful {@code false} otherwise
+     */
+    boolean allocateTiny(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int normCapacity) {
+        return allocate(cacheForTiny(area, normCapacity), buf, reqCapacity);
+    }
+
+    /**
+     * Try to allocate a small buffer out of the cache. Returns {@code true} if successful {@code false} otherwise
+     */
+    boolean allocateSmall(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int normCapacity) {
+        return allocate(cacheForSmall(area, normCapacity), buf, reqCapacity);
+    }
+
+    /**
+     * Try to allocate a small buffer out of the cache. Returns {@code true} if successful {@code false} otherwise
+     */
+    boolean allocateNormal(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int normCapacity) {
+        return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    private boolean allocate(MemoryRegionCache<?> cache, PooledByteBuf buf, int reqCapacity) {
+        if (cache == null) {
+            // no cache found so just return false here
+            return false;
+        }
+        boolean allocated = cache.allocate(buf, reqCapacity);
+        if (++ allocations >= freeSweepAllocationThreshold) {
+            allocations = 0;
+            trim();
+        }
+        return allocated;
+    }
+
+    /**
+     * Add {@link PoolChunk} and {@code handle} to the cache if there is enough room.
+     * Returns {@code true} if it fit into the cache {@code false} otherwise.
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    boolean add(PoolArena<?> area, PoolChunk chunk, long handle, int normCapacity) {
+        MemoryRegionCache<?> cache;
+        if (area.isTinyOrSmall(normCapacity)) {
+            if (PoolArena.isTiny(normCapacity)) {
+                cache = cacheForTiny(area, normCapacity);
+            } else {
+                cache = cacheForSmall(area, normCapacity);
+            }
+        } else {
+            cache = cacheForNormal(area, normCapacity);
+        }
+        if (cache == null) {
+            return false;
+        }
+        return cache.add(chunk, handle);
+    }
+
+    /**
+     *  Should be called if the Thread that uses this cache is about to exist to release resources out of the cache
+     */
+    void free() {
+        ThreadDeathWatcher.unwatch(thread, freeTask);
+        free0();
+    }
+
+    private void free0() {
+        int numFreed = free(tinySubPageDirectCaches) +
+                free(smallSubPageDirectCaches) +
+                free(normalDirectCaches) +
+                free(tinySubPageHeapCaches) +
+                free(smallSubPageHeapCaches) +
+                free(normalHeapCaches);
+
+        if (numFreed > 0 && logger.isDebugEnabled()) {
+            logger.debug("Freed {} thread-local buffer(s) from thread: {}", numFreed, thread.getName());
+        }
+    }
+
+    private static int free(MemoryRegionCache<?>[] caches) {
+        if (caches == null) {
+            return 0;
+        }
+
+        int numFreed = 0;
+        for (MemoryRegionCache<?> c: caches) {
+            numFreed += free(c);
+        }
+        return numFreed;
+    }
+
+    private static int free(MemoryRegionCache<?> cache) {
+        if (cache == null) {
+            return 0;
+        }
+        return cache.free();
+    }
+
+    void trim() {
+        trim(tinySubPageDirectCaches);
+        trim(smallSubPageDirectCaches);
+        trim(normalDirectCaches);
+        trim(tinySubPageHeapCaches);
+        trim(smallSubPageHeapCaches);
+        trim(normalHeapCaches);
+    }
+
+    private static void trim(MemoryRegionCache<?>[] caches) {
+        if (caches == null) {
+            return;
+        }
+        for (MemoryRegionCache<?> c: caches) {
+            trim(c);
+        }
+    }
+
+    private static void trim(MemoryRegionCache<?> cache) {
+        if (cache == null) {
+            return;
+        }
+        cache.trim();
+    }
+
+    private MemoryRegionCache<?> cacheForTiny(PoolArena<?> area, int normCapacity) {
+        int idx = PoolArena.tinyIdx(normCapacity);
+        if (area.isDirect()) {
+            return cache(tinySubPageDirectCaches, idx);
+        }
+        return cache(tinySubPageHeapCaches, idx);
+    }
+
+    private MemoryRegionCache<?> cacheForSmall(PoolArena<?> area, int normCapacity) {
+        int idx = PoolArena.smallIdx(normCapacity);
+        if (area.isDirect()) {
+            return cache(smallSubPageDirectCaches, idx);
+        }
+        return cache(smallSubPageHeapCaches, idx);
+    }
+
+    private MemoryRegionCache<?> cacheForNormal(PoolArena<?> area, int normCapacity) {
+        if (area.isDirect()) {
+            int idx = log2(normCapacity >> numShiftsNormalDirect);
+            return cache(normalDirectCaches, idx);
+        }
+        int idx = log2(normCapacity >> numShiftsNormalHeap);
+        return cache(normalHeapCaches, idx);
+    }
+
+    private static <T> MemoryRegionCache<T> cache(MemoryRegionCache<T>[] cache, int idx) {
+        if (cache == null || idx > cache.length - 1) {
+            return null;
+        }
+        return cache[idx];
+    }
+
+    /**
+     * Cache used for buffers which are backed by TINY or SMALL size.
+     */
+    private static final class SubPageMemoryRegionCache<T> extends MemoryRegionCache<T> {
+        SubPageMemoryRegionCache(int size) {
+            super(size);
+        }
+
+        @Override
+        protected void initBuf(
+                PoolChunk<T> chunk, long handle, PooledByteBuf<T> buf, int reqCapacity) {
+            chunk.initBufWithSubpage(buf, handle, reqCapacity);
+        }
+    }
+
+    /**
+     * Cache used for buffers which are backed by NORMAL size.
+     */
+    private static final class NormalMemoryRegionCache<T> extends MemoryRegionCache<T> {
+        NormalMemoryRegionCache(int size) {
+            super(size);
+        }
+
+        @Override
+        protected void initBuf(
+                PoolChunk<T> chunk, long handle, PooledByteBuf<T> buf, int reqCapacity) {
+            chunk.initBuf(buf, handle, reqCapacity);
+        }
+    }
+
+    /**
+     * Cache of {@link PoolChunk} and handles which can be used to allocate a buffer without locking at all.
+     */
+    private abstract static class MemoryRegionCache<T> {
+        private final Entry<T>[] entries;
+        private final int maxUnusedCached;
+        private int head;
+        private int tail;
+        private int maxEntriesInUse;
+        private int entriesInUse;
+
+        @SuppressWarnings("unchecked")
+        MemoryRegionCache(int size) {
+            entries = new Entry[powerOfTwo(size)];
+            for (int i = 0; i < entries.length; i++) {
+                entries[i] = new Entry<T>();
+            }
+            maxUnusedCached = size / 2;
+        }
+
+        private static int powerOfTwo(int res) {
+            if (res <= 2) {
+                return 2;
+            }
+            res--;
+            res |= res >> 1;
+            res |= res >> 2;
+            res |= res >> 4;
+            res |= res >> 8;
+            res |= res >> 16;
+            res++;
+            return res;
+        }
+
+        /**
+         * Init the {@link PooledByteBuf} using the provided chunk and handle with the capacity restrictions.
+         */
+        protected abstract void initBuf(PoolChunk<T> chunk, long handle,
+                                        PooledByteBuf<T> buf, int reqCapacity);
+
+        /**
+         * Add to cache if not already full.
+         */
+        public boolean add(PoolChunk<T> chunk, long handle) {
+            Entry<T> entry = entries[tail];
+            if (entry.chunk != null) {
+                // cache is full
+                return false;
+            }
+            entriesInUse --;
+
+            entry.chunk = chunk;
+            entry.handle = handle;
+            tail = nextIdx(tail);
+            return true;
+        }
+
+        /**
+         * Allocate something out of the cache if possible and remove the entry from the cache.
+         */
+        public boolean allocate(PooledByteBuf<T> buf, int reqCapacity) {
+            Entry<T> entry = entries[head];
+            if (entry.chunk == null) {
+                return false;
+            }
+
+            entriesInUse ++;
+            if (maxEntriesInUse < entriesInUse) {
+                maxEntriesInUse = entriesInUse;
+            }
+            initBuf(entry.chunk, entry.handle, buf, reqCapacity);
+            // only null out the chunk as we only use the chunk to check if the buffer is full or not.
+            entry.chunk = null;
+            head = nextIdx(head);
+            return true;
+        }
+
+        /**
+         * Clear out this cache and free up all previous cached {@link PoolChunk}s and {@code handle}s.
+         */
+        public int free() {
+            int numFreed = 0;
+            entriesInUse = 0;
+            maxEntriesInUse = 0;
+            for (int i = head;; i = nextIdx(i)) {
+                if (freeEntry(entries[i])) {
+                    numFreed++;
+                } else {
+                    // all cleared
+                    return numFreed;
+                }
+            }
+        }
+
+        /**
+         * Free up cached {@link PoolChunk}s if not allocated frequently enough.
+         */
+        private void trim() {
+            int free = size() - maxEntriesInUse;
+            entriesInUse = 0;
+            maxEntriesInUse = 0;
+
+            if (free <= maxUnusedCached) {
+                return;
+            }
+
+            int i = head;
+            for (; free > 0; free--) {
+                if (!freeEntry(entries[i])) {
+                    // all freed
+                    return;
+                }
+                i = nextIdx(i);
+            }
+        }
+
+        @SuppressWarnings({ "unchecked", "rawtypes" })
+        private static boolean freeEntry(Entry entry) {
+            PoolChunk chunk = entry.chunk;
+            if (chunk == null) {
+                return false;
+            }
+            // need to synchronize on the area from which it was allocated before.
+            synchronized (chunk.arena) {
+                chunk.parent.free(chunk, entry.handle);
+            }
+            entry.chunk = null;
+            return true;
+        }
+
+        /**
+         * Return the number of cached entries.
+         */
+        private int size()  {
+            return tail - head & entries.length - 1;
+        }
+
+        private int nextIdx(int index) {
+            // use bitwise operation as this is faster as using modulo.
+            return index + 1 & entries.length - 1;
+        }
+
+        private static final class Entry<T> {
+            PoolChunk<T> chunk;
+            long handle;
+        }
     }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
index 3f88a6971334..af36ef7eafca 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
@@ -17,26 +17,28 @@
 package io.netty.buffer;
 
 import io.netty.util.Recycler;
+import io.netty.util.Recycler.Handle;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
 abstract class PooledByteBuf<T> extends AbstractReferenceCountedByteBuf {
 
-    private final Recycler.Handle recyclerHandle;
+    private final Recycler.Handle<PooledByteBuf<T>> recyclerHandle;
 
     protected PoolChunk<T> chunk;
     protected long handle;
     protected T memory;
     protected int offset;
     protected int length;
-    private int maxLength;
+    int maxLength;
 
     private ByteBuffer tmpNioBuf;
 
-    protected PooledByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {
+    @SuppressWarnings("unchecked")
+    protected PooledByteBuf(Recycler.Handle<? extends PooledByteBuf<T>> recyclerHandle, int maxCapacity) {
         super(maxCapacity);
-        this.recyclerHandle = recyclerHandle;
+        this.recyclerHandle = (Handle<PooledByteBuf<T>>) recyclerHandle;
     }
 
     void init(PoolChunk<T> chunk, long handle, int offset, int length, int maxLength) {
@@ -140,21 +142,15 @@ protected final void deallocate() {
             final long handle = this.handle;
             this.handle = -1;
             memory = null;
-            chunk.arena.free(chunk, handle);
+            chunk.arena.free(chunk, handle, maxLength);
             recycle();
         }
     }
 
-    @SuppressWarnings("unchecked")
     private void recycle() {
-        Recycler.Handle recyclerHandle = this.recyclerHandle;
-        if (recyclerHandle != null) {
-            ((Recycler<Object>) recycler()).recycle(this, recyclerHandle);
-        }
+        recyclerHandle.recycle(this);
     }
 
-    protected abstract Recycler<?> recycler();
-
     protected final int idx(int index) {
         return offset + index;
     }
diff --git a/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
index cbe4252102ac..1d765c553e8a 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
@@ -16,6 +16,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.logging.InternalLogger;
@@ -27,12 +28,16 @@
 public class PooledByteBufAllocator extends AbstractByteBufAllocator {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(PooledByteBufAllocator.class);
-
     private static final int DEFAULT_NUM_HEAP_ARENA;
     private static final int DEFAULT_NUM_DIRECT_ARENA;
 
     private static final int DEFAULT_PAGE_SIZE;
     private static final int DEFAULT_MAX_ORDER; // 8192 << 11 = 16 MiB per chunk
+    private static final int DEFAULT_TINY_CACHE_SIZE;
+    private static final int DEFAULT_SMALL_CACHE_SIZE;
+    private static final int DEFAULT_NORMAL_CACHE_SIZE;
+    private static final int DEFAULT_MAX_CACHED_BUFFER_CAPACITY;
+    private static final int DEFAULT_CACHE_TRIM_INTERVAL;
 
     private static final int MIN_PAGE_SIZE = 4096;
     private static final int MAX_CHUNK_SIZE = (int) (((long) Integer.MAX_VALUE + 1) / 2);
@@ -75,6 +80,20 @@ public class PooledByteBufAllocator extends AbstractByteBufAllocator {
                                 runtime.availableProcessors(),
                                 PlatformDependent.maxDirectMemory() / defaultChunkSize / 2 / 3)));
 
+        // cache sizes
+        DEFAULT_TINY_CACHE_SIZE = SystemPropertyUtil.getInt("io.netty.allocator.tinyCacheSize", 512);
+        DEFAULT_SMALL_CACHE_SIZE = SystemPropertyUtil.getInt("io.netty.allocator.smallCacheSize", 256);
+        DEFAULT_NORMAL_CACHE_SIZE = SystemPropertyUtil.getInt("io.netty.allocator.normalCacheSize", 64);
+
+        // 32 kb is the default maximum capacity of the cached buffer. Similar to what is explained in
+        // 'Scalable memory allocation using jemalloc'
+        DEFAULT_MAX_CACHED_BUFFER_CAPACITY = SystemPropertyUtil.getInt(
+                "io.netty.allocator.maxCachedBufferCapacity", 32 * 1024);
+
+        // the number of threshold of allocations when cached entries will be freed up if not frequently used
+        DEFAULT_CACHE_TRIM_INTERVAL = SystemPropertyUtil.getInt(
+                "io.netty.allocator.cacheTrimInterval", 8192);
+
         if (logger.isDebugEnabled()) {
             logger.debug("-Dio.netty.allocator.numHeapArenas: {}", DEFAULT_NUM_HEAP_ARENA);
             logger.debug("-Dio.netty.allocator.numDirectArenas: {}", DEFAULT_NUM_DIRECT_ARENA);
@@ -89,6 +108,11 @@ public class PooledByteBufAllocator extends AbstractByteBufAllocator {
                 logger.debug("-Dio.netty.allocator.maxOrder: {}", DEFAULT_MAX_ORDER, maxOrderFallbackCause);
             }
             logger.debug("-Dio.netty.allocator.chunkSize: {}", DEFAULT_PAGE_SIZE << DEFAULT_MAX_ORDER);
+            logger.debug("-Dio.netty.allocator.tinyCacheSize: {}", DEFAULT_TINY_CACHE_SIZE);
+            logger.debug("-Dio.netty.allocator.smallCacheSize: {}", DEFAULT_SMALL_CACHE_SIZE);
+            logger.debug("-Dio.netty.allocator.normalCacheSize: {}", DEFAULT_NORMAL_CACHE_SIZE);
+            logger.debug("-Dio.netty.allocator.maxCachedBufferCapacity: {}", DEFAULT_MAX_CACHED_BUFFER_CAPACITY);
+            logger.debug("-Dio.netty.allocator.cacheTrimInterval: {}", DEFAULT_CACHE_TRIM_INTERVAL);
         }
     }
 
@@ -97,30 +121,11 @@ public class PooledByteBufAllocator extends AbstractByteBufAllocator {
 
     private final PoolArena<byte[]>[] heapArenas;
     private final PoolArena<ByteBuffer>[] directArenas;
+    private final int tinyCacheSize;
+    private final int smallCacheSize;
+    private final int normalCacheSize;
 
-    final ThreadLocal<PoolThreadCache> threadCache = new ThreadLocal<PoolThreadCache>() {
-        private final AtomicInteger index = new AtomicInteger();
-        @Override
-        protected PoolThreadCache initialValue() {
-            final int idx = index.getAndIncrement();
-            final PoolArena<byte[]> heapArena;
-            final PoolArena<ByteBuffer> directArena;
-
-            if (heapArenas != null) {
-                heapArena = heapArenas[Math.abs(idx % heapArenas.length)];
-            } else {
-                heapArena = null;
-            }
-
-            if (directArenas != null) {
-                directArena = directArenas[Math.abs(idx % directArenas.length)];
-            } else {
-                directArena = null;
-            }
-
-            return new PoolThreadCache(heapArena, directArena);
-        }
-    };
+    final PoolThreadLocalCache threadCache;
 
     public PooledByteBufAllocator() {
         this(false);
@@ -135,8 +140,17 @@ public PooledByteBufAllocator(int nHeapArena, int nDirectArena, int pageSize, in
     }
 
     public PooledByteBufAllocator(boolean preferDirect, int nHeapArena, int nDirectArena, int pageSize, int maxOrder) {
-        super(preferDirect);
+        this(preferDirect, nHeapArena, nDirectArena, pageSize, maxOrder,
+                DEFAULT_TINY_CACHE_SIZE, DEFAULT_SMALL_CACHE_SIZE, DEFAULT_NORMAL_CACHE_SIZE);
+    }
 
+    public PooledByteBufAllocator(boolean preferDirect, int nHeapArena, int nDirectArena, int pageSize, int maxOrder,
+                                  int tinyCacheSize, int smallCacheSize, int normalCacheSize) {
+        super(preferDirect);
+        threadCache = new PoolThreadLocalCache();
+        this.tinyCacheSize = tinyCacheSize;
+        this.smallCacheSize = smallCacheSize;
+        this.normalCacheSize = normalCacheSize;
         final int chunkSize = validateAndCalculateChunkSize(pageSize, maxOrder);
 
         if (nHeapArena < 0) {
@@ -174,26 +188,15 @@ private static <T> PoolArena<T>[] newArenaArray(int size) {
 
     private static int validateAndCalculatePageShifts(int pageSize) {
         if (pageSize < MIN_PAGE_SIZE) {
-            throw new IllegalArgumentException("pageSize: " + pageSize + " (expected: 4096+)");
+            throw new IllegalArgumentException("pageSize: " + pageSize + " (expected: " + MIN_PAGE_SIZE + "+)");
         }
 
-        // Ensure pageSize is power of 2.
-        boolean found1 = false;
-        int pageShifts = 0;
-        for (int i = pageSize; i != 0 ; i >>= 1) {
-            if ((i & 1) != 0) {
-                if (!found1) {
-                    found1 = true;
-                } else {
-                    throw new IllegalArgumentException("pageSize: " + pageSize + " (expected: power of 2");
-                }
-            } else {
-                if (!found1) {
-                    pageShifts ++;
-                }
-            }
+        if ((pageSize & pageSize - 1) != 0) {
+            throw new IllegalArgumentException("pageSize: " + pageSize + " (expected: power of 2)");
         }
-        return pageShifts;
+
+        // Logarithm base 2. At this point we know that pageSize is a power of two.
+        return Integer.SIZE - 1 - Integer.numberOfLeadingZeros(pageSize);
     }
 
     private static int validateAndCalculateChunkSize(int pageSize, int maxOrder) {
@@ -252,6 +255,55 @@ public boolean isDirectBufferPooled() {
         return directArenas != null;
     }
 
+    /**
+     * Returns {@code true} if the calling {@link Thread} has a {@link ThreadLocal} cache for the allocated
+     * buffers.
+     */
+    @Deprecated
+    public boolean hasThreadLocalCache() {
+        return threadCache.isSet();
+    }
+
+    /**
+     * Free all cached buffers for the calling {@link Thread}.
+     */
+    @Deprecated
+    public void freeThreadLocalCache() {
+        threadCache.remove();
+    }
+
+    final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {
+        private final AtomicInteger index = new AtomicInteger();
+
+        @Override
+        protected PoolThreadCache initialValue() {
+            final int idx = index.getAndIncrement();
+            final PoolArena<byte[]> heapArena;
+            final PoolArena<ByteBuffer> directArena;
+
+            if (heapArenas != null) {
+                heapArena = heapArenas[Math.abs(idx % heapArenas.length)];
+            } else {
+                heapArena = null;
+            }
+
+            if (directArenas != null) {
+                directArena = directArenas[Math.abs(idx % directArenas.length)];
+            } else {
+                directArena = null;
+            }
+
+            return new PoolThreadCache(
+                    heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,
+                    DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);
+        }
+
+        @Override
+        protected void onRemoval(PoolThreadCache value) {
+            value.free();
+        }
+    }
+
 //    Too noisy at the moment.
 //
 //    public String toString() {
diff --git a/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
index b50f72063724..bd07ddd48965 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
@@ -30,7 +30,7 @@ final class PooledDirectByteBuf extends PooledByteBuf<ByteBuffer> {
 
     private static final Recycler<PooledDirectByteBuf> RECYCLER = new Recycler<PooledDirectByteBuf>() {
         @Override
-        protected PooledDirectByteBuf newObject(Handle handle) {
+        protected PooledDirectByteBuf newObject(Handle<PooledDirectByteBuf> handle) {
             return new PooledDirectByteBuf(handle, 0);
         }
     };
@@ -42,7 +42,7 @@ static PooledDirectByteBuf newInstance(int maxCapacity) {
         return buf;
     }
 
-    private PooledDirectByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {
+    private PooledDirectByteBuf(Recycler.Handle<PooledDirectByteBuf> recyclerHandle, int maxCapacity) {
         super(recyclerHandle, maxCapacity);
     }
 
@@ -274,7 +274,7 @@ public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
 
     @Override
     public ByteBuf setBytes(int index, ByteBuffer src) {
-        checkIndex(index);
+        checkIndex(index, src.remaining());
         ByteBuffer tmpBuf = internalNioBuffer();
         if (src == tmpBuf) {
             src = src.duplicate();
@@ -308,7 +308,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         tmpBuf.clear().position(index).limit(index + length);
         try {
             return in.read(tmpBuf);
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }
@@ -369,9 +369,4 @@ public boolean hasMemoryAddress() {
     public long memoryAddress() {
         throw new UnsupportedOperationException();
     }
-
-    @Override
-    protected Recycler<?> recycler() {
-        return RECYCLER;
-    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
index 1eb445b04e48..cd1e595b60d8 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
@@ -29,7 +29,7 @@ final class PooledHeapByteBuf extends PooledByteBuf<byte[]> {
 
     private static final Recycler<PooledHeapByteBuf> RECYCLER = new Recycler<PooledHeapByteBuf>() {
         @Override
-        protected PooledHeapByteBuf newObject(Handle handle) {
+        protected PooledHeapByteBuf newObject(Handle<PooledHeapByteBuf> handle) {
             return new PooledHeapByteBuf(handle, 0);
         }
     };
@@ -41,7 +41,7 @@ static PooledHeapByteBuf newInstance(int maxCapacity) {
         return buf;
     }
 
-    private PooledHeapByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {
+    private PooledHeapByteBuf(Recycler.Handle<PooledHeapByteBuf> recyclerHandle, int maxCapacity) {
         super(recyclerHandle, maxCapacity);
     }
 
@@ -232,7 +232,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         index = idx(index);
         try {
             return in.read((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length));
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }
@@ -299,9 +299,4 @@ public long memoryAddress() {
     protected ByteBuffer newInternalNioBuffer(byte[] memory) {
         return ByteBuffer.wrap(memory);
     }
-
-    @Override
-    protected Recycler<?> recycler() {
-        return RECYCLER;
-    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
index 92bd6ef42329..a22777a05a17 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
@@ -34,7 +34,7 @@ final class PooledUnsafeDirectByteBuf extends PooledByteBuf<ByteBuffer> {
 
     private static final Recycler<PooledUnsafeDirectByteBuf> RECYCLER = new Recycler<PooledUnsafeDirectByteBuf>() {
         @Override
-        protected PooledUnsafeDirectByteBuf newObject(Handle handle) {
+        protected PooledUnsafeDirectByteBuf newObject(Handle<PooledUnsafeDirectByteBuf> handle) {
             return new PooledUnsafeDirectByteBuf(handle, 0);
         }
     };
@@ -48,7 +48,7 @@ static PooledUnsafeDirectByteBuf newInstance(int maxCapacity) {
 
     private long memoryAddress;
 
-    private PooledUnsafeDirectByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {
+    private PooledUnsafeDirectByteBuf(Recycler.Handle<PooledUnsafeDirectByteBuf> recyclerHandle, int maxCapacity) {
         super(recyclerHandle, maxCapacity);
     }
 
@@ -278,7 +278,7 @@ public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
 
     @Override
     public ByteBuf setBytes(int index, ByteBuffer src) {
-        checkIndex(index);
+        checkIndex(index, src.remaining());
         ByteBuffer tmpBuf = internalNioBuffer();
         if (src == tmpBuf) {
             src = src.duplicate();
@@ -309,7 +309,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         tmpBuf.clear().position(index).limit(index + length);
         try {
             return in.read(tmpBuf);
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }
@@ -383,7 +383,7 @@ private long addr(int index) {
     }
 
     @Override
-    protected Recycler<?> recycler() {
-        return RECYCLER;
+    protected SwappedByteBuf newSwappedByteBuf() {
+        return new UnsafeDirectSwappedByteBuf(this);
     }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
index 47e4eb7473fe..a4643f62484c 100644
--- a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
@@ -36,7 +36,7 @@ class ReadOnlyByteBufferBuf extends AbstractReferenceCountedByteBuf {
     private final ByteBufAllocator allocator;
     private ByteBuffer tmpNioBuf;
 
-    public ReadOnlyByteBufferBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
+    ReadOnlyByteBufferBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
         super(buffer.remaining());
         if (!buffer.isReadOnly()) {
             throw new IllegalArgumentException("must be a readonly buffer: " + StringUtil.simpleClassName(buffer));
@@ -276,7 +276,7 @@ public ByteBuf copy(int index, int length) {
         ByteBuffer src;
         try {
             src = (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
-        } catch (IllegalArgumentException e) {
+        } catch (IllegalArgumentException ignored) {
             throw new IndexOutOfBoundsException("Too many bytes to read - Need " + (index + length));
         }
 
@@ -299,7 +299,7 @@ public ByteBuffer[] nioBuffers(int index, int length) {
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
-        return (ByteBuffer) buffer.duplicate().position(index).limit(length);
+        return (ByteBuffer) buffer.duplicate().position(index).limit(index + length);
     }
 
     @Override
diff --git a/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java
index 7093b4f28bdd..f93b7dc2e431 100644
--- a/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java
@@ -30,7 +30,7 @@ final class ReadOnlyUnsafeDirectByteBuf extends ReadOnlyByteBufferBuf {
     private static final boolean NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
     private final long memoryAddress;
 
-    public ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
+    ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer buffer) {
         super(allocator, buffer);
         memoryAddress = PlatformDependent.directBufferAddress(buffer);
     }
diff --git a/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
index aa61a5c79079..0a9fe3f20b78 100644
--- a/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
@@ -29,6 +29,16 @@ final class SimpleLeakAwareByteBuf extends WrappedByteBuf {
         this.leak = leak;
     }
 
+    @Override
+    public ByteBuf touch() {
+        return this;
+    }
+
+    @Override
+    public ByteBuf touch(Object hint) {
+        return this;
+    }
+
     @Override
     public boolean release() {
         boolean deallocated =  super.release();
diff --git a/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
index bdcf6798f3bc..4c109fe62e2a 100644
--- a/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
@@ -39,7 +39,7 @@ public class SlicedByteBuf extends AbstractDerivedByteBuf {
     public SlicedByteBuf(ByteBuf buffer, int index, int length) {
         super(length);
         if (index < 0 || index > buffer.capacity() - length) {
-            throw new IndexOutOfBoundsException(buffer.toString() + ".slice(" + index + ", " + length + ')');
+            throw new IndexOutOfBoundsException(buffer + ".slice(" + index + ", " + length + ')');
         }
 
         if (buffer instanceof SlicedByteBuf) {
diff --git a/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
index b199e3103788..3c917c4f8492 100644
--- a/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
@@ -27,7 +27,7 @@
 /**
  * Wrapper which swap the {@link ByteOrder} of a {@link ByteBuf}.
  */
-public final class SwappedByteBuf extends ByteBuf {
+public class SwappedByteBuf extends ByteBuf {
 
     private final ByteBuf buf;
     private final ByteOrder order;
@@ -814,6 +814,18 @@ public ByteBuf retain(int increment) {
         return this;
     }
 
+    @Override
+    public ByteBuf touch() {
+        buf.touch();
+        return this;
+    }
+
+    @Override
+    public ByteBuf touch(Object hint) {
+        buf.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         return buf.release();
@@ -847,6 +859,6 @@ public int compareTo(ByteBuf buffer) {
 
     @Override
     public String toString() {
-        return "Swapped(" + buf.toString() + ')';
+        return "Swapped(" + buf + ')';
     }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/Unpooled.java b/buffer/src/main/java/io/netty/buffer/Unpooled.java
index f9edbb38d980..5a6aa3f2437d 100644
--- a/buffer/src/main/java/io/netty/buffer/Unpooled.java
+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java
@@ -857,6 +857,14 @@ public static ByteBuf unreleasableBuffer(ByteBuf buf) {
         return new UnreleasableByteBuf(buf);
     }
 
+    /**
+     * Wrap the given {@link ByteBuf}s in an unmodifiable {@link ByteBuf}. Be aware the returned {@link ByteBuf} will
+     * not try to slice the given {@link ByteBuf}s to reduce GC-Pressure.
+     */
+    public static ByteBuf unmodifiableBuffer(ByteBuf... buffers) {
+        return new FixedCompositeByteBuf(ALLOC, buffers);
+    }
+
     private Unpooled() {
         // Unused
     }
diff --git a/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
index 844479e4dd36..1414c8ee8ee0 100644
--- a/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
@@ -411,9 +411,7 @@ protected void _setLong(int index, long value) {
     @Override
     public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
         checkSrcIndex(index, length, srcIndex, src.capacity());
-        if (buffer.hasArray()) {
-            src.getBytes(srcIndex, buffer.array(), index + buffer.arrayOffset(), length);
-        } else if (src.nioBufferCount() > 0) {
+        if (src.nioBufferCount() > 0) {
             for (ByteBuffer bb: src.nioBuffers(srcIndex, length)) {
                 int bbLen = bb.remaining();
                 setBytes(index, bb);
@@ -537,7 +535,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         tmpBuf.clear().position(index).limit(index + length);
         try {
             return in.read(tmpNioBuf);
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }
@@ -558,7 +556,7 @@ public ByteBuf copy(int index, int length) {
         ByteBuffer src;
         try {
             src = (ByteBuffer) buffer.duplicate().clear().position(index).limit(index + length);
-        } catch (IllegalArgumentException e) {
+        } catch (IllegalArgumentException ignored) {
             throw new IndexOutOfBoundsException("Too many bytes to read - Need " + (index + length));
         }
 
@@ -567,6 +565,7 @@ public ByteBuf copy(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
         return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
@@ -580,6 +579,7 @@ private ByteBuffer internalNioBuffer() {
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
+        checkIndex(index, length);
         return ((ByteBuffer) buffer.duplicate().position(index).limit(index + length)).slice();
     }
 
diff --git a/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
index 668b79449319..a85431973126 100644
--- a/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
@@ -254,7 +254,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         ensureAccessible();
         try {
             return in.read((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length));
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }
@@ -277,6 +277,7 @@ public ByteBuffer[] nioBuffers(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
         return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
diff --git a/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
index 89df31acde71..954c320bd522 100644
--- a/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
@@ -355,7 +355,7 @@ public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
         if (length != 0) {
             if (src.hasMemoryAddress()) {
                 PlatformDependent.copyMemory(src.memoryAddress() + srcIndex, addr(index), length);
-            } else if (buffer.hasArray()) {
+            } else if (src.hasArray()) {
                 PlatformDependent.copyMemory(src.array(), src.arrayOffset() + srcIndex, addr(index), length);
             } else {
                 src.getBytes(srcIndex, this, index, length);
@@ -444,7 +444,7 @@ public int setBytes(int index, ScatteringByteChannel in, int length) throws IOEx
         tmpBuf.clear().position(index).limit(index + length);
         try {
             return in.read(tmpBuf);
-        } catch (ClosedChannelException e) {
+        } catch (ClosedChannelException ignored) {
             return -1;
         }
     }
@@ -476,6 +476,7 @@ public ByteBuf copy(int index, int length) {
 
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
         return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
@@ -489,6 +490,7 @@ private ByteBuffer internalNioBuffer() {
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
+        checkIndex(index, length);
         return ((ByteBuffer) buffer.duplicate().position(index).limit(index + length)).slice();
     }
 
@@ -514,4 +516,9 @@ public ByteBuf unwrap() {
     long addr(int index) {
         return memoryAddress + index;
     }
+
+    @Override
+    protected SwappedByteBuf newSwappedByteBuf() {
+        return new UnsafeDirectSwappedByteBuf(this);
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
index 8310ea03c22b..2b26f29137cf 100644
--- a/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
@@ -75,6 +75,16 @@ public ByteBuf retain() {
         return this;
     }
 
+    @Override
+    public ByteBuf touch() {
+        return this;
+    }
+
+    @Override
+    public ByteBuf touch(Object hint) {
+        return this;
+    }
+
     @Override
     public boolean release() {
         return false;
diff --git a/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java
new file mode 100644
index 000000000000..e777c80578dd
--- /dev/null
+++ b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java
@@ -0,0 +1,183 @@
+/*
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+
+package io.netty.buffer;
+
+import io.netty.util.internal.PlatformDependent;
+
+import java.nio.ByteOrder;
+
+/**
+ * Special {@link SwappedByteBuf} for {@link ByteBuf}s that are backed by a {@code memoryAddress}.
+ */
+final class UnsafeDirectSwappedByteBuf extends SwappedByteBuf {
+    private static final boolean NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
+    private final boolean nativeByteOrder;
+    private final AbstractByteBuf wrapped;
+
+    UnsafeDirectSwappedByteBuf(AbstractByteBuf buf) {
+        super(buf);
+        wrapped = buf;
+        nativeByteOrder = NATIVE_ORDER == (order() == ByteOrder.BIG_ENDIAN);
+    }
+
+    private long addr(int index) {
+        // We need to call wrapped.memoryAddress() everytime and NOT cache it as it may change if the buffer expand.
+        // See:
+        // - https://github.com/netty/netty/issues/2587
+        // - https://github.com/netty/netty/issues/2580
+        return wrapped.memoryAddress() + index;
+    }
+
+    @Override
+    public long getLong(int index) {
+        wrapped.checkIndex(index, 8);
+        long v = PlatformDependent.getLong(addr(index));
+        return nativeByteOrder? v : Long.reverseBytes(v);
+    }
+
+    @Override
+    public float getFloat(int index) {
+        return Float.intBitsToFloat(getInt(index));
+    }
+
+    @Override
+    public double getDouble(int index) {
+        return Double.longBitsToDouble(getLong(index));
+    }
+
+    @Override
+    public char getChar(int index) {
+        return (char) getShort(index);
+    }
+
+    @Override
+    public long getUnsignedInt(int index) {
+        return getInt(index) & 0xFFFFFFFFL;
+    }
+
+    @Override
+    public int getInt(int index) {
+        wrapped.checkIndex(index, 4);
+        int v = PlatformDependent.getInt(addr(index));
+        return nativeByteOrder? v : Integer.reverseBytes(v);
+    }
+
+    @Override
+    public int getUnsignedShort(int index) {
+        return getShort(index) & 0xFFFF;
+    }
+
+    @Override
+    public short getShort(int index) {
+        wrapped.checkIndex(index, 2);
+        short v = PlatformDependent.getShort(addr(index));
+        return nativeByteOrder? v : Short.reverseBytes(v);
+    }
+
+    @Override
+    public ByteBuf setShort(int index, int value) {
+        wrapped.checkIndex(index, 2);
+        _setShort(index, value);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setInt(int index, int value) {
+        wrapped.checkIndex(index, 4);
+        _setInt(index, value);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setLong(int index, long value) {
+        wrapped.checkIndex(index, 8);
+        _setLong(index, value);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setChar(int index, int value) {
+        setShort(index, value);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setFloat(int index, float value) {
+        setInt(index, Float.floatToRawIntBits(value));
+        return this;
+    }
+
+    @Override
+    public ByteBuf setDouble(int index, double value) {
+        setLong(index, Double.doubleToRawLongBits(value));
+        return this;
+    }
+
+    @Override
+    public ByteBuf writeShort(int value) {
+        wrapped.ensureWritable(2);
+        _setShort(wrapped.writerIndex, value);
+        wrapped.writerIndex += 2;
+        return this;
+    }
+
+    @Override
+    public ByteBuf writeInt(int value) {
+        wrapped.ensureWritable(4);
+        _setInt(wrapped.writerIndex, value);
+        wrapped.writerIndex += 4;
+        return this;
+    }
+
+    @Override
+    public ByteBuf writeLong(long value) {
+        wrapped.ensureWritable(8);
+        _setLong(wrapped.writerIndex, value);
+        wrapped.writerIndex += 8;
+        return this;
+    }
+
+    @Override
+    public ByteBuf writeChar(int value) {
+        writeShort(value);
+        return this;
+    }
+
+    @Override
+    public ByteBuf writeFloat(float value) {
+        writeInt(Float.floatToRawIntBits(value));
+        return this;
+    }
+
+    @Override
+    public ByteBuf writeDouble(double value) {
+        writeLong(Double.doubleToRawLongBits(value));
+        return this;
+    }
+
+    private void _setShort(int index, int value) {
+        PlatformDependent.putShort(addr(index), nativeByteOrder ? (short) value : Short.reverseBytes((short) value));
+    }
+
+    private void _setInt(int index, int value) {
+        PlatformDependent.putInt(addr(index), nativeByteOrder ? value : Integer.reverseBytes(value));
+    }
+
+    private void _setLong(int index, long value) {
+        PlatformDependent.putLong(addr(index), nativeByteOrder ? value : Long.reverseBytes(value));
+    }
+}
diff --git a/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java b/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java
index 75df016c9838..eae17e0e7478 100644
--- a/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java
@@ -27,7 +27,7 @@
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
 
-class WrappedByteBuf extends ByteBuf {
+public class WrappedByteBuf extends ByteBuf {
 
     protected final ByteBuf buf;
 
@@ -773,6 +773,7 @@ public int hashCode() {
     }
 
     @Override
+    @SuppressWarnings("EqualsWhichDoesntCheckParameterClass")
     public boolean equals(Object obj) {
         return buf.equals(obj);
     }
@@ -799,6 +800,18 @@ public ByteBuf retain() {
         return this;
     }
 
+    @Override
+    public ByteBuf touch() {
+        buf.touch();
+        return this;
+    }
+
+    @Override
+    public ByteBuf touch(Object hint) {
+        buf.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean isReadable(int size) {
         return buf.isReadable(size);
diff --git a/buffer/src/main/java/io/netty/buffer/package-info.java b/buffer/src/main/java/io/netty/buffer/package-info.java
index 60005c27818b..cc0d28851a76 100644
--- a/buffer/src/main/java/io/netty/buffer/package-info.java
+++ b/buffer/src/main/java/io/netty/buffer/package-info.java
@@ -75,13 +75,13 @@
  * type.
  * <pre>
  * // The composite type is compatible with the component type.
- * {@link ByteBuf} message = {@link Unpooled}.wrappedBuffer(header, body);
+ * {@link io.netty.buffer.ByteBuf} message = {@link io.netty.buffer.Unpooled}.wrappedBuffer(header, body);
  *
  * // Therefore, you can even create a composite by mixing a composite and an
  * // ordinary buffer.
- * {@link ByteBuf} messageWithFooter = {@link Unpooled}.wrappedBuffer(message, footer);
+ * {@link io.netty.buffer.ByteBuf} messageWithFooter = {@link io.netty.buffer.Unpooled}.wrappedBuffer(message, footer);
  *
- * // Because the composite is still a {@link ByteBuf}, you can access its content
+ * // Because the composite is still a {@link io.netty.buffer.ByteBuf}, you can access its content
  * // easily, and the accessor method will behave just like it's a single buffer
  * // even if the region you want to access spans over multiple components.  The
  * // unsigned integer being read here is located across body and footer.
@@ -100,7 +100,7 @@
  * <pre>
  * // A new dynamic buffer is created.  Internally, the actual buffer is created
  * // lazily to avoid potentially wasted memory space.
- * {@link ByteBuf} b = {@link Unpooled}.buffer(4);
+ * {@link io.netty.buffer.ByteBuf} b = {@link io.netty.buffer.Unpooled}.buffer(4);
  *
  * // When the first write attempt is made, the internal buffer is created with
  * // the specified initial capacity (4).
diff --git a/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
index 60c31c748e21..a72ebefae527 100644
--- a/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java
@@ -16,11 +16,11 @@
 package io.netty.buffer;
 
 import io.netty.util.CharsetUtil;
+import io.netty.util.IllegalReferenceCountException;
+import io.netty.util.internal.ThreadLocalRandom;
 import org.junit.After;
-import org.junit.Assert;
 import org.junit.Assume;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
@@ -29,6 +29,7 @@
 import java.nio.ByteBuffer;
 import java.nio.channels.Channels;
 import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.ScatteringByteChannel;
 import java.nio.channels.WritableByteChannel;
 import java.util.Arrays;
 import java.util.HashSet;
@@ -163,6 +164,8 @@ public void writerIndexBoundaryCheck4() {
         buffer.writerIndex(0);
         buffer.readerIndex(0);
         buffer.writerIndex(CAPACITY);
+
+        buffer.writeBytes(ByteBuffer.wrap(EMPTY_BYTES));
     }
 
     @Test(expected = IndexOutOfBoundsException.class)
@@ -1473,6 +1476,7 @@ public void testSliceIndex() throws Exception {
     }
 
     @Test
+    @SuppressWarnings("ObjectEqualsNull")
     public void testEquals() {
         assertFalse(buffer.equals(null));
         assertFalse(buffer.equals(new Object()));
@@ -1724,7 +1728,6 @@ public boolean process(byte value) throws Exception {
         assertThat(lastIndex.get(), is(CAPACITY / 4));
     }
 
-    @Ignore
     @Test
     public void testInternalNioBuffer() {
         testInternalNioBuffer(128);
@@ -1740,15 +1743,15 @@ private void testInternalNioBuffer(int a) {
         ByteBuffer buf = buffer.internalNioBuffer(0, 1);
         assertEquals(1, buf.remaining());
 
-        for (int i = 0; i < a; i++) {
-            buffer.writeByte(i);
-        }
+        byte[] data = new byte[a];
+        ThreadLocalRandom.current().nextBytes(data);
+        buffer.writeBytes(data);
 
         buf = buffer.internalNioBuffer(0, a);
         assertEquals(a, buf.remaining());
 
         for (int i = 0; i < a; i++) {
-            assertEquals((byte) i, buf.get());
+            assertEquals(data[i], buf.get());
         }
         assertFalse(buf.hasRemaining());
     }
@@ -1792,7 +1795,7 @@ public void run() {
                                 return;
                             }
                         }
-                        Assert.assertArrayEquals(bytes, channel.writtenBytes());
+                        assertArrayEquals(bytes, channel.writtenBytes());
                         latch.countDown();
                     }
                     try {
@@ -1846,7 +1849,7 @@ public void run() {
                                 return;
                             }
                         }
-                        Assert.assertArrayEquals(bytes, out.toByteArray());
+                        assertArrayEquals(bytes, out.toByteArray());
                         latch.countDown();
                     }
                     try {
@@ -1895,11 +1898,11 @@ public void run() {
                         byte[] array = new byte[8];
                         buf.readBytes(array);
 
-                        Assert.assertArrayEquals(bytes, array);
+                        assertArrayEquals(bytes, array);
 
                         Arrays.fill(array, (byte) 0);
                         buf.getBytes(0, array);
-                        Assert.assertArrayEquals(bytes, array);
+                        assertArrayEquals(bytes, array);
 
                         latch.countDown();
                     }
@@ -1925,6 +1928,7 @@ public void readByteThrowsIndexOutOfBoundsException() {
     }
 
     @Test
+    @SuppressWarnings("ForLoopThatDoesntUseLoopVariable")
     public void testNioBufferExposeOnlyRegion() {
         final ByteBuf buffer = releaseLater(newBuffer(8));
         byte[] data = new byte[8];
@@ -1940,6 +1944,492 @@ public void testNioBufferExposeOnlyRegion() {
         }
     }
 
+    // See:
+    // - https://github.com/netty/netty/issues/2587
+    // - https://github.com/netty/netty/issues/2580
+    @Test
+    public void testLittleEndianWithExpand() {
+        ByteBuf buffer = releaseLater(newBuffer(0)).order(LITTLE_ENDIAN);
+        buffer.writeInt(0x12345678);
+        assertEquals("78563412", ByteBufUtil.hexDump(buffer));
+    }
+
+    private ByteBuf releasedBuffer() {
+        ByteBuf buffer = newBuffer(8);
+        assertTrue(buffer.release());
+        return buffer;
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testDiscardReadBytesAfterRelease() {
+        releasedBuffer().discardReadBytes();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testDiscardSomeReadBytesAfterRelease() {
+        releasedBuffer().discardSomeReadBytes();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testEnsureWritableAfterRelease() {
+        releasedBuffer().ensureWritable(16);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBooleanAfterRelease() {
+        releasedBuffer().getBoolean(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetByteAfterRelease() {
+        releasedBuffer().getByte(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetUnsignedByteAfterRelease() {
+        releasedBuffer().getUnsignedByte(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetShortAfterRelease() {
+        releasedBuffer().getShort(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetUnsignedShortAfterRelease() {
+        releasedBuffer().getUnsignedShort(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetMediumAfterRelease() {
+        releasedBuffer().getMedium(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetUnsignedMediumAfterRelease() {
+        releasedBuffer().getUnsignedMedium(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetIntAfterRelease() {
+        releasedBuffer().getInt(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetUnsignedIntAfterRelease() {
+        releasedBuffer().getUnsignedInt(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetLongAfterRelease() {
+        releasedBuffer().getLong(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetCharAfterRelease() {
+        releasedBuffer().getChar(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetFloatAfterRelease() {
+        releasedBuffer().getFloat(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetDoubleAfterRelease() {
+        releasedBuffer().getDouble(0);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBytesAfterRelease() {
+        releasedBuffer().getBytes(0, releaseLater(buffer()));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBytesAfterRelease2() {
+        releasedBuffer().getBytes(0, releaseLater(buffer()), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBytesAfterRelease3() {
+        releasedBuffer().getBytes(0, releaseLater(buffer()), 0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBytesAfterRelease4() {
+        releasedBuffer().getBytes(0, new byte[8]);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBytesAfterRelease5() {
+        releasedBuffer().getBytes(0, new byte[8], 0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBytesAfterRelease6() {
+        releasedBuffer().getBytes(0, ByteBuffer.allocate(8));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBytesAfterRelease7() throws IOException {
+        releasedBuffer().getBytes(0, new ByteArrayOutputStream(), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testGetBytesAfterRelease8() throws IOException {
+        releasedBuffer().getBytes(0, new DevNullGatheringByteChannel(), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBooleanAfterRelease() {
+        releasedBuffer().setBoolean(0, true);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetByteAfterRelease() {
+        releasedBuffer().setByte(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetShortAfterRelease() {
+        releasedBuffer().setShort(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetMediumAfterRelease() {
+        releasedBuffer().setMedium(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetIntAfterRelease() {
+        releasedBuffer().setInt(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetLongAfterRelease() {
+        releasedBuffer().setLong(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetCharAfterRelease() {
+        releasedBuffer().setChar(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetFloatAfterRelease() {
+        releasedBuffer().setFloat(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetDoubleAfterRelease() {
+        releasedBuffer().setDouble(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBytesAfterRelease() {
+        releasedBuffer().setBytes(0, releaseLater(buffer()));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBytesAfterRelease2() {
+        releasedBuffer().setBytes(0, releaseLater(buffer()), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBytesAfterRelease3() {
+        releasedBuffer().setBytes(0, releaseLater(buffer()), 0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBytesAfterRelease4() {
+        releasedBuffer().setBytes(0, new byte[8]);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBytesAfterRelease5() {
+        releasedBuffer().setBytes(0, new byte[8], 0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBytesAfterRelease6() {
+        releasedBuffer().setBytes(0, ByteBuffer.allocate(8));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBytesAfterRelease7() throws IOException {
+        releasedBuffer().setBytes(0, new ByteArrayInputStream(new byte[8]), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetBytesAfterRelease8() throws IOException {
+        releasedBuffer().setBytes(0, new TestScatteringByteChannel(), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testSetZeroAfterRelease() {
+        releasedBuffer().setZero(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBooleanAfterRelease() {
+        releasedBuffer().readBoolean();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadByteAfterRelease() {
+        releasedBuffer().readByte();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadUnsignedByteAfterRelease() {
+        releasedBuffer().readUnsignedByte();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadShortAfterRelease() {
+        releasedBuffer().readShort();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadUnsignedShortAfterRelease() {
+        releasedBuffer().readUnsignedShort();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadMediumAfterRelease() {
+        releasedBuffer().readMedium();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadUnsignedMediumAfterRelease() {
+        releasedBuffer().readUnsignedMedium();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadIntAfterRelease() {
+        releasedBuffer().readInt();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadUnsignedIntAfterRelease() {
+        releasedBuffer().readUnsignedInt();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadLongAfterRelease() {
+        releasedBuffer().readLong();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadCharAfterRelease() {
+        releasedBuffer().readChar();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadFloatAfterRelease() {
+        releasedBuffer().readFloat();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadDoubleAfterRelease() {
+        releasedBuffer().readDouble();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease() {
+        releasedBuffer().readBytes(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease2() {
+        releasedBuffer().readBytes(releaseLater(buffer(8)));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease3() {
+        releasedBuffer().readBytes(releaseLater(buffer(8), 1));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease4() {
+        releasedBuffer().readBytes(releaseLater(buffer(8)), 0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease5() {
+        releasedBuffer().readBytes(new byte[8]);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease6() {
+        releasedBuffer().readBytes(new byte[8], 0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease7() {
+        releasedBuffer().readBytes(ByteBuffer.allocate(8));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease8() throws IOException {
+        releasedBuffer().readBytes(new ByteArrayOutputStream(), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease9() throws IOException {
+        releasedBuffer().readBytes(new ByteArrayOutputStream(), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testReadBytesAfterRelease10() throws IOException {
+        releasedBuffer().readBytes(new DevNullGatheringByteChannel(), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBooleanAfterRelease() {
+        releasedBuffer().writeBoolean(true);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteByteAfterRelease() {
+        releasedBuffer().writeByte(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteShortAfterRelease() {
+        releasedBuffer().writeShort(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteMediumAfterRelease() {
+        releasedBuffer().writeMedium(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteIntAfterRelease() {
+        releasedBuffer().writeInt(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteLongAfterRelease() {
+        releasedBuffer().writeLong(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteCharAfterRelease() {
+        releasedBuffer().writeChar(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteFloatAfterRelease() {
+        releasedBuffer().writeFloat(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteDoubleAfterRelease() {
+        releasedBuffer().writeDouble(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBytesAfterRelease() {
+        releasedBuffer().writeBytes(releaseLater(buffer(8)));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBytesAfterRelease2() {
+        releasedBuffer().writeBytes(releaseLater(copiedBuffer(new byte[8])), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBytesAfterRelease3() {
+        releasedBuffer().writeBytes(releaseLater(buffer(8)), 0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBytesAfterRelease4() {
+        releasedBuffer().writeBytes(new byte[8]);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBytesAfterRelease5() {
+        releasedBuffer().writeBytes(new byte[8], 0 , 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBytesAfterRelease6() {
+        releasedBuffer().writeBytes(ByteBuffer.allocate(8));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBytesAfterRelease7() throws IOException {
+        releasedBuffer().writeBytes(new ByteArrayInputStream(new byte[8]), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteBytesAfterRelease8() throws IOException {
+        releasedBuffer().writeBytes(new TestScatteringByteChannel(), 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testWriteZeroAfterRelease() throws IOException {
+        releasedBuffer().writeZero(1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testForEachByteAfterRelease() {
+        releasedBuffer().forEachByte(new TestByteBufProcessor());
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testForEachByteAfterRelease1() {
+        releasedBuffer().forEachByte(0, 1, new TestByteBufProcessor());
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testForEachByteDescAfterRelease() {
+        releasedBuffer().forEachByteDesc(new TestByteBufProcessor());
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testForEachByteDescAfterRelease1() {
+        releasedBuffer().forEachByteDesc(0, 1, new TestByteBufProcessor());
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testCopyAfterRelease() {
+        releasedBuffer().copy();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testCopyAfterRelease1() {
+        releasedBuffer().copy();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testNioBufferAfterRelease() {
+        releasedBuffer().nioBuffer();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testNioBufferAfterRelease1() {
+        releasedBuffer().nioBuffer(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testInternalNioBufferAfterRelease() {
+        releasedBuffer().internalNioBuffer(0, 1);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testNioBuffersAfterRelease() {
+        releasedBuffer().nioBuffers();
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void testNioBuffersAfterRelease2() {
+        releasedBuffer().nioBuffers(0, 1);
+    }
+
     static final class TestGatheringByteChannel implements GatheringByteChannel {
         private final ByteArrayOutputStream out = new ByteArrayOutputStream();
         private final WritableByteChannel channel = Channels.newChannel(out);
@@ -1994,4 +2484,65 @@ public byte[] writtenBytes() {
             return out.toByteArray();
         }
     }
+
+    private static final class DevNullGatheringByteChannel implements GatheringByteChannel {
+        @Override
+        public long write(ByteBuffer[] srcs, int offset, int length) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public long write(ByteBuffer[] srcs) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int write(ByteBuffer src) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isOpen() {
+            return false;
+        }
+
+        @Override
+        public void close() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    private static final class TestScatteringByteChannel implements ScatteringByteChannel {
+        @Override
+        public long read(ByteBuffer[] dsts, int offset, int length) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public long read(ByteBuffer[] dsts) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public int read(ByteBuffer dst) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean isOpen() {
+            return false;
+        }
+
+        @Override
+        public void close() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    private static final class TestByteBufProcessor implements ByteBufProcessor {
+        @Override
+        public boolean process(byte value) throws Exception {
+            return true;
+        }
+    }
 }
diff --git a/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
index a943f1f05d66..72432ab0af32 100644
--- a/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
@@ -71,8 +71,7 @@ protected ByteBuf newBuffer(int length) {
             buffers.add(EMPTY_BUFFER);
         }
 
-        buffer = Unpooled.wrappedBuffer(
-                Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);
+        buffer = wrappedBuffer(Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);
 
         // Truncate to the requested capacity.
         buffer.capacity(length);
@@ -802,7 +801,7 @@ public void testDiscardSomeReadBytes() {
         CompositeByteBuf cbuf = releaseLater(compositeBuffer());
         int len = 8 * 4;
         for (int i = 0; i < len; i += 4) {
-            ByteBuf buf = Unpooled.buffer().writeInt(i);
+            ByteBuf buf = buffer().writeInt(i);
             cbuf.capacity(cbuf.writerIndex()).addComponent(buf).writerIndex(i + 4);
         }
         cbuf.writeByte(1);
diff --git a/buffer/src/test/java/io/netty/buffer/BigEndianCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/BigEndianCompositeByteBufTest.java
index 3b506d9669b4..2ae0aaa6ab54 100644
--- a/buffer/src/test/java/io/netty/buffer/BigEndianCompositeByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/BigEndianCompositeByteBufTest.java
@@ -16,6 +16,8 @@
 package io.netty.buffer;
 
 
+import org.junit.Test;
+
 /**
  * Tests big-endian composite channel buffers
  */
@@ -23,4 +25,11 @@ public class BigEndianCompositeByteBufTest extends AbstractCompositeByteBufTest
     public BigEndianCompositeByteBufTest() {
         super(Unpooled.BIG_ENDIAN);
     }
+
+    @Override
+    @Test(expected = UnsupportedOperationException.class)
+    public void testInternalNioBufferAfterRelease() {
+        super.testInternalNioBufferAfterRelease();
+    }
+
 }
diff --git a/buffer/src/test/java/io/netty/buffer/DuplicateByteBufTest.java b/buffer/src/test/java/io/netty/buffer/DuplicateByteBufTest.java
index ba957489bedc..5dad9f13cb6a 100644
--- a/buffer/src/test/java/io/netty/buffer/DuplicateByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/DuplicateByteBufTest.java
@@ -15,7 +15,6 @@
  */
 package io.netty.buffer;
 
-import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -44,14 +43,6 @@ public void shouldNotAllowNullInConstructor() {
         new DuplicatedByteBuf(null);
     }
 
-    @Ignore
-    @Test
-    // Test which shows bug
-    // https://github.com/netty/netty/issues/1802
-    public void testInternalNioBuffer() {
-        super.testInternalNioBuffer();
-    }
-
     // See https://github.com/netty/netty/issues/1800
     @Test
     public void testIncreaseCapacityWrapped() {
diff --git a/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java
new file mode 100644
index 000000000000..7dea5ebf5672
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java
@@ -0,0 +1,255 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.buffer;
+
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ReadOnlyBufferException;
+import java.nio.channels.ScatteringByteChannel;
+
+import static io.netty.buffer.Unpooled.*;
+import static io.netty.util.ReferenceCountUtil.*;
+import static org.junit.Assert.*;
+
+public class FixedCompositeByteBufTest {
+
+    private static ByteBuf newBuffer(ByteBuf... buffers) {
+        return releaseLater(new FixedCompositeByteBuf(UnpooledByteBufAllocator.DEFAULT, buffers));
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetBoolean() {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setBoolean(0, true);
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetByte() {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setByte(0, 1);
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetBytesWithByteBuf() {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setBytes(0, wrappedBuffer(new byte[4]));
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetBytesWithByteBuffer() {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setBytes(0, ByteBuffer.wrap(new byte[4]));
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetBytesWithInputStream() throws IOException {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setBytes(0, new ByteArrayInputStream(new byte[4]), 4);
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetBytesWithChannel() throws IOException {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setBytes(0, new ScatteringByteChannel() {
+            @Override
+            public long read(ByteBuffer[] dsts, int offset, int length) {
+                return 0;
+            }
+
+            @Override
+            public long read(ByteBuffer[] dsts) {
+                return 0;
+            }
+
+            @Override
+            public int read(ByteBuffer dst) {
+                return 0;
+            }
+
+            @Override
+            public boolean isOpen() {
+                return true;
+            }
+
+            @Override
+            public void close() {
+            }
+        }, 4);
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetChar() throws IOException {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setChar(0, 'b');
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetDouble() throws IOException {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setDouble(0, 1);
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetFloat() throws IOException {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setFloat(0, 1);
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetInt() throws IOException {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setInt(0, 1);
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetLong() {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setLong(0, 1);
+    }
+
+    @Test(expected = ReadOnlyBufferException.class)
+    public void testSetMedium() throws IOException {
+        ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));
+        buf.setMedium(0, 1);
+    }
+
+    @Test
+    public void testGatheringWritesHeap() throws Exception {
+        testGatheringWrites(buffer(), buffer());
+    }
+
+    @Test
+    public void testGatheringWritesDirect() throws Exception {
+        testGatheringWrites(directBuffer(), directBuffer());
+    }
+
+    @Test
+    public void testGatheringWritesMixes() throws Exception {
+        testGatheringWrites(buffer(), directBuffer());
+    }
+
+    @Test
+    public void testGatheringWritesHeapPooled() throws Exception {
+        testGatheringWrites(PooledByteBufAllocator.DEFAULT.heapBuffer(),
+                PooledByteBufAllocator.DEFAULT.heapBuffer());
+    }
+
+    @Test
+    public void testGatheringWritesDirectPooled() throws Exception {
+        testGatheringWrites(PooledByteBufAllocator.DEFAULT.directBuffer(),
+                PooledByteBufAllocator.DEFAULT.directBuffer());
+    }
+
+    @Test
+    public void testGatheringWritesMixesPooled() throws Exception {
+        testGatheringWrites(PooledByteBufAllocator.DEFAULT.heapBuffer(),
+                PooledByteBufAllocator.DEFAULT.directBuffer());
+    }
+
+    private static void testGatheringWrites(ByteBuf buf1, ByteBuf buf2) throws Exception {
+        CompositeByteBuf buf = compositeBuffer();
+        buf.addComponent(buf1.writeBytes(new byte[]{1, 2}));
+        buf.addComponent(buf2.writeBytes(new byte[]{1, 2}));
+        buf.writerIndex(3);
+        buf.readerIndex(1);
+
+        AbstractByteBufTest.TestGatheringByteChannel channel = new AbstractByteBufTest.TestGatheringByteChannel();
+        buf.readBytes(channel, 2);
+
+        byte[] data = new byte[2];
+        buf.getBytes(1, data);
+        buf.release();
+
+        assertArrayEquals(data, channel.writtenBytes());
+    }
+
+    @Test
+    public void testGatheringWritesPartialHeap() throws Exception {
+        testGatheringWritesPartial(buffer(), buffer());
+    }
+
+    @Test
+    public void testGatheringWritesPartialDirect() throws Exception {
+        testGatheringWritesPartial(directBuffer(), directBuffer());
+    }
+
+    @Test
+    public void testGatheringWritesPartialMixes() throws Exception {
+        testGatheringWritesPartial(buffer(), directBuffer());
+    }
+
+    @Test
+    public void testGatheringWritesPartialHeapPooled() throws Exception {
+        testGatheringWritesPartial(PooledByteBufAllocator.DEFAULT.heapBuffer(),
+                PooledByteBufAllocator.DEFAULT.heapBuffer());
+    }
+
+    @Test
+    public void testGatheringWritesPartialDirectPooled() throws Exception {
+        testGatheringWritesPartial(PooledByteBufAllocator.DEFAULT.directBuffer(),
+                PooledByteBufAllocator.DEFAULT.directBuffer());
+    }
+
+    @Test
+    public void testGatheringWritesPartialMixesPooled() throws Exception {
+        testGatheringWritesPartial(PooledByteBufAllocator.DEFAULT.heapBuffer(),
+                PooledByteBufAllocator.DEFAULT.directBuffer());
+    }
+
+    private static void testGatheringWritesPartial(ByteBuf buf1, ByteBuf buf2) throws Exception {
+        buf1.writeBytes(new byte[]{1, 2, 3, 4});
+        buf2.writeBytes(new byte[]{1, 2, 3, 4});
+        ByteBuf buf = newBuffer(buf1, buf2);
+        AbstractByteBufTest.TestGatheringByteChannel channel = new AbstractByteBufTest.TestGatheringByteChannel(1);
+
+        while (buf.isReadable()) {
+            buf.readBytes(channel, buf.readableBytes());
+        }
+
+        byte[] data = new byte[8];
+        buf.getBytes(0, data);
+        assertArrayEquals(data, channel.writtenBytes());
+        buf.release();
+    }
+
+    @Test
+    public void testGatheringWritesSingleHeap() throws Exception {
+        testGatheringWritesSingleBuf(buffer());
+    }
+
+    @Test
+    public void testGatheringWritesSingleDirect() throws Exception {
+        testGatheringWritesSingleBuf(directBuffer());
+    }
+
+    private static void testGatheringWritesSingleBuf(ByteBuf buf1) throws Exception {
+        ByteBuf buf = newBuffer(buf1.writeBytes(new byte[]{1, 2, 3, 4}));
+        buf.readerIndex(1);
+
+        AbstractByteBufTest.TestGatheringByteChannel channel = new AbstractByteBufTest.TestGatheringByteChannel();
+        buf.readBytes(channel, 2);
+
+        byte[] data = new byte[2];
+        buf.getBytes(1, data);
+        assertArrayEquals(data, channel.writtenBytes());
+
+        buf.release();
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/PoolArenaTest.java b/buffer/src/test/java/io/netty/buffer/PoolArenaTest.java
new file mode 100644
index 000000000000..f5acd2b4f220
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/PoolArenaTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.buffer;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.nio.ByteBuffer;
+
+public class PoolArenaTest {
+
+    @Test
+    public void testNormalizeCapacity() throws Exception {
+        PoolArena<ByteBuffer> arena = new PoolArena.DirectArena(null, 0, 0, 9, 999999);
+        int[] reqCapacities = {0, 15, 510, 1024, 1023, 1025};
+        int[] expectedResult = {0, 16, 512, 1024, 1024, 2048};
+        for (int i = 0; i < reqCapacities.length; i ++) {
+            Assert.assertEquals(expectedResult[i], arena.normalizeCapacity(reqCapacities[i]));
+        }
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java
index c944cdd1340e..5023821a54ba 100644
--- a/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java
@@ -46,15 +46,15 @@ public void testUnmodifiableBuffer() {
     @Test
     public void testUnwrap() {
         ByteBuf buf = buffer(1);
-        assertSame(buf, Unpooled.unmodifiableBuffer(buf).unwrap());
+        assertSame(buf, unmodifiableBuffer(buf).unwrap());
     }
 
     @Test
     public void shouldHaveSameByteOrder() {
         ByteBuf buf = buffer(1);
-        assertSame(BIG_ENDIAN, Unpooled.unmodifiableBuffer(buf).order());
+        assertSame(BIG_ENDIAN, unmodifiableBuffer(buf).order());
         buf = buf.order(LITTLE_ENDIAN);
-        assertSame(LITTLE_ENDIAN, Unpooled.unmodifiableBuffer(buf).order());
+        assertSame(LITTLE_ENDIAN, unmodifiableBuffer(buf).order());
     }
 
     @Test
diff --git a/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java
index 06ae54eca458..9c9373ed2a25 100644
--- a/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java
@@ -194,4 +194,17 @@ public void testWrapBufferWithNonZeroPosition() {
         ByteBuf slice = buf.slice();
         Assert.assertEquals(buf, slice);
     }
+
+    @Test
+    public void testWrapBufferRoundTrip() {
+        ByteBuf buf = buffer(((ByteBuffer) allocate(16).putInt(1).putInt(2).flip()).asReadOnlyBuffer());
+        buffers.add(buf);
+
+        Assert.assertEquals(1, buf.readInt());
+
+        ByteBuffer nioBuffer = buf.nioBuffer();
+
+        // Ensure this can be accessed without throwing a BufferUnderflowException
+        Assert.assertEquals(2, nioBuffer.getInt());
+    }
 }
diff --git a/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java
index 505de88d70a6..ab5fa344fb0c 100644
--- a/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java
@@ -15,11 +15,11 @@
  */
 package io.netty.buffer;
 
-import static org.junit.Assert.*;
+import org.junit.Test;
 
 import java.util.Random;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 /**
  * Tests sliced channel buffers
@@ -94,4 +94,10 @@ public void testSliceBytesInArrayMultipleThreads() throws Exception {
     public void testNioBufferExposeOnlyRegion() {
         super.testNioBufferExposeOnlyRegion();
     }
+
+    @Test
+    @Override
+    public void testLittleEndianWithExpand() {
+       // ignore for SlicedByteBuf
+    }
 }
diff --git a/buffer/src/test/java/io/netty/buffer/UnpooledTest.java b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java
index 4b993891d0ba..0b2e5dc816ad 100644
--- a/buffer/src/test/java/io/netty/buffer/UnpooledTest.java
+++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java
@@ -445,8 +445,8 @@ public void testWrapInt() {
         assertEquals(4, buffer.readInt());
         assertFalse(buffer.isReadable());
 
-        assertEquals(0, Unpooled.copyInt(null).capacity());
-        assertEquals(0, Unpooled.copyInt(EMPTY_INTS).capacity());
+        assertEquals(0, copyInt(null).capacity());
+        assertEquals(0, copyInt(EMPTY_INTS).capacity());
     }
 
     @Test
@@ -465,8 +465,8 @@ public void testWrapShortFromShortArray() {
         assertEquals(4, buffer.readShort());
         assertFalse(buffer.isReadable());
 
-        assertEquals(0, Unpooled.copyShort((short[]) null).capacity());
-        assertEquals(0, Unpooled.copyShort(EMPTY_SHORTS).capacity());
+        assertEquals(0, copyShort((short[]) null).capacity());
+        assertEquals(0, copyShort(EMPTY_SHORTS).capacity());
     }
 
     @Test
@@ -477,8 +477,8 @@ public void testWrapShortFromIntArray() {
         assertEquals(4, buffer.readShort());
         assertFalse(buffer.isReadable());
 
-        assertEquals(0, Unpooled.copyShort((int[]) null).capacity());
-        assertEquals(0, Unpooled.copyShort(EMPTY_INTS).capacity());
+        assertEquals(0, copyShort((int[]) null).capacity());
+        assertEquals(0, copyShort(EMPTY_INTS).capacity());
     }
 
     @Test
@@ -497,8 +497,8 @@ public void testWrapMedium() {
         assertEquals(4, buffer.readMedium());
         assertFalse(buffer.isReadable());
 
-        assertEquals(0, Unpooled.copyMedium(null).capacity());
-        assertEquals(0, Unpooled.copyMedium(EMPTY_INTS).capacity());
+        assertEquals(0, copyMedium(null).capacity());
+        assertEquals(0, copyMedium(EMPTY_INTS).capacity());
     }
 
     @Test
@@ -517,8 +517,8 @@ public void testWrapLong() {
         assertEquals(4, buffer.readLong());
         assertFalse(buffer.isReadable());
 
-        assertEquals(0, Unpooled.copyLong(null).capacity());
-        assertEquals(0, Unpooled.copyLong(EMPTY_LONGS).capacity());
+        assertEquals(0, copyLong(null).capacity());
+        assertEquals(0, copyLong(EMPTY_LONGS).capacity());
     }
 
     @Test
@@ -537,8 +537,8 @@ public void testWrapFloat() {
         assertEquals(4, buffer.readFloat(), 0.01);
         assertFalse(buffer.isReadable());
 
-        assertEquals(0, Unpooled.copyFloat(null).capacity());
-        assertEquals(0, Unpooled.copyFloat(EMPTY_FLOATS).capacity());
+        assertEquals(0, copyFloat(null).capacity());
+        assertEquals(0, copyFloat(EMPTY_FLOATS).capacity());
     }
 
     @Test
@@ -557,8 +557,8 @@ public void testWrapDouble() {
         assertEquals(4, buffer.readDouble(), 0.01);
         assertFalse(buffer.isReadable());
 
-        assertEquals(0, Unpooled.copyDouble(null).capacity());
-        assertEquals(0, Unpooled.copyDouble(EMPTY_DOUBLES).capacity());
+        assertEquals(0, copyDouble(null).capacity());
+        assertEquals(0, copyDouble(EMPTY_DOUBLES).capacity());
     }
 
     @Test
@@ -569,8 +569,8 @@ public void testWrapBoolean() {
         assertFalse(buffer.readBoolean());
         assertFalse(buffer.isReadable());
 
-        assertEquals(0, Unpooled.copyBoolean(null).capacity());
-        assertEquals(0, Unpooled.copyBoolean(EMPTY_BOOLEANS).capacity());
+        assertEquals(0, copyBoolean(null).capacity());
+        assertEquals(0, copyBoolean(EMPTY_BOOLEANS).capacity());
     }
 
     @Test
diff --git a/codec-dns/pom.xml b/codec-dns/pom.xml
new file mode 100644
index 000000000000..b17753b81170
--- /dev/null
+++ b/codec-dns/pom.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2014 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>io.netty</groupId>
+    <artifactId>netty-parent</artifactId>
+    <version>4.1.0.Beta1</version>
+  </parent>
+
+  <artifactId>netty-codec-dns</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Netty/Codec/DNS</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.directory.server</groupId>
+      <artifactId>apacheds-protocol-dns</artifactId>
+      <version>1.5.7</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
+
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsEntry.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsEntry.java
new file mode 100644
index 000000000000..104d777cf32c
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsEntry.java
@@ -0,0 +1,377 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * A class representing entries in a DNS packet (questions, and all resource
+ * records). Contains data shared by entries such as name, type, and class.
+ */
+public class DnsEntry {
+
+    /**
+     * Address record RFC 1035 Returns a 32-bit IPv4 address, most commonly used
+     * to map hostnames to an IP address of the host, but also used for DNSBLs,
+     * storing subnet masks in RFC 1101, etc.
+     */
+    public static final int TYPE_A = 0x0001;
+
+    /**
+     * Name server record RFC 1035 Delegates a DNS zone to use the given
+     * authoritative name servers
+     */
+    public static final int TYPE_NS = 0x0002;
+
+    /**
+     * Canonical name record RFC 1035 Alias of one name to another: the DNS
+     * lookup will continue by retrying the lookup with the new name.
+     */
+    public static final int TYPE_CNAME = 0x0005;
+
+    /**
+     * Start of [a zone of] authority record RFC 1035 and RFC 2308 Specifies
+     * authoritative information about a DNS zone, including the primary name
+     * server, the email of the domain administrator, the domain serial number,
+     * and several timers relating to refreshing the zone.
+     */
+    public static final int TYPE_SOA = 0x0006;
+
+    /**
+     * Pointer record RFC 1035 Pointer to a canonical name. Unlike a CNAME, DNS
+     * processing does NOT proceed, just the name is returned. The most common
+     * use is for implementing reverse DNS lookups, but other uses include such
+     * things as DNS-SD.
+     */
+    public static final int TYPE_PTR = 0x000c;
+
+    /**
+     * Mail exchange record RFC 1035 Maps a domain name to a list of message
+     * transfer agents for that domain.
+     */
+    public static final int TYPE_MX = 0x000f;
+
+    /**
+     * Text record RFC 1035 Originally for arbitrary human-readable text in a
+     * DNS record. Since the early 1990s, however, this record more often
+     * carries machine-readable data, such as specified by RFC 1464,
+     * opportunistic encryption, Sender Policy Framework, DKIM, DMARC DNS-SD,
+     * etc.
+     */
+    public static final int TYPE_TXT = 0x0010;
+
+    /**
+     * Responsible person record RFC 1183 Information about the responsible
+     * person(s) for the domain. Usually an email address with the @ replaced by
+     * a .
+     */
+    public static final int TYPE_RP = 0x0011;
+
+    /**
+     * AFS database record RFC 1183 Location of database servers of an AFS cell.
+     * This record is commonly used by AFS clients to contact AFS cells outside
+     * their local domain. A subtype of this record is used by the obsolete
+     * DCE/DFS file system.
+     */
+    public static final int TYPE_AFSDB = 0x0012;
+
+    /**
+     * Signature record RFC 2535 Signature record used in SIG(0) (RFC 2931) and
+     * TKEY (RFC 2930). RFC 3755 designated RRSIG as the replacement for SIG for
+     * use within DNSSEC.
+     */
+    public static final int TYPE_SIG = 0x0018;
+
+    /**
+     * key record RFC 2535 and RFC 2930 Used only for SIG(0) (RFC 2931) and TKEY
+     * (RFC 2930). RFC 3445 eliminated their use for application keys and
+     * limited their use to DNSSEC. RFC 3755 designates DNSKEY as the
+     * replacement within DNSSEC. RFC 4025 designates IPSECKEY as the
+     * replacement for use with IPsec.
+     */
+    public static final int TYPE_KEY = 0x0019;
+
+    /**
+     * IPv6 address record RFC 3596 Returns a 128-bit IPv6 address, most
+     * commonly used to map hostnames to an IP address of the host.
+     */
+    public static final int TYPE_AAAA = 0x001c;
+
+    /**
+     * Location record RFC 1876 Specifies a geographical location associated
+     * with a domain name.
+     */
+    public static final int TYPE_LOC = 0x001d;
+
+    /**
+     * Service locator RFC 2782 Generalized service location record, used for
+     * newer protocols instead of creating protocol-specific records such as MX.
+     */
+    public static final int TYPE_SRV = 0x0021;
+
+    /**
+     * Naming Authority Pointer record RFC 3403 Allows regular expression based
+     * rewriting of domain names which can then be used as URIs, further domain
+     * names to lookups, etc.
+     */
+    public static final int TYPE_NAPTR = 0x0023;
+
+    /**
+     * Key eXchanger record RFC 2230 Used with some cryptographic systems (not
+     * including DNSSEC) to identify a key management agent for the associated
+     * domain-name. Note that this has nothing to do with DNS Security. It is
+     * Informational status, rather than being on the IETF standards-track. It
+     * has always had limited deployment, but is still in use.
+     */
+    public static final int TYPE_KX = 0x0024;
+
+    /**
+     * Certificate record RFC 4398 Stores PKIX, SPKI, PGP, etc.
+     */
+    public static final int TYPE_CERT = 0x0025;
+
+    /**
+     * Delegation name record RFC 2672 DNAME creates an alias for a name and all
+     * its subnames, unlike CNAME, which aliases only the exact name in its
+     * label. Like the CNAME record, the DNS lookup will continue by retrying
+     * the lookup with the new name.
+     */
+    public static final int TYPE_DNAME = 0x0027;
+
+    /**
+     * Option record RFC 2671 This is a pseudo DNS record type needed to support
+     * EDNS.
+     */
+    public static final int TYPE_OPT = 0x0029;
+
+    /**
+     * Address Prefix List record RFC 3123 Specify lists of address ranges, e.g.
+     * in CIDR format, for various address families. Experimental.
+     */
+    public static final int TYPE_APL = 0x002a;
+
+    /**
+     * Delegation signer record RFC 4034 The record used to identify the DNSSEC
+     * signing key of a delegated zone.
+     */
+    public static final int TYPE_DS = 0x002b;
+
+    /**
+     * SSH Public Key Fingerprint record RFC 4255 Resource record for publishing
+     * SSH public host key fingerprints in the DNS System, in order to aid in
+     * verifying the authenticity of the host. RFC 6594 defines ECC SSH keys and
+     * SHA-256 hashes. See the IANA SSHFP RR parameters registry for details.
+     */
+    public static final int TYPE_SSHFP = 0x002c;
+
+    /**
+     * IPsec Key record RFC 4025 Key record that can be used with IPsec.
+     */
+    public static final int TYPE_IPSECKEY = 0x002d;
+
+    /**
+     * DNSSEC signature record RFC 4034 Signature for a DNSSEC-secured record
+     * set. Uses the same format as the SIG record.
+     */
+    public static final int TYPE_RRSIG = 0x002e;
+
+    /**
+     * Next-Secure record RFC 4034 Part of DNSSEC, used to prove a name does not
+     * exist. Uses the same format as the (obsolete) NXT record.
+     */
+    public static final int TYPE_NSEC = 0x002f;
+
+    /**
+     * DNS Key record RFC 4034 The key record used in DNSSEC. Uses the same
+     * format as the KEY record.
+     */
+    public static final int TYPE_DNSKEY = 0x0030;
+
+    /**
+     * DHCP identifier record RFC 4701 Used in conjunction with the FQDN option
+     * to DHCP.
+     */
+    public static final int TYPE_DHCID = 0x0031;
+
+    /**
+     * NSEC record version 3 RFC 5155 An extension to DNSSEC that allows proof
+     * of nonexistence for a name without permitting zonewalking.
+     */
+    public static final int TYPE_NSEC3 = 0x0032;
+
+    /**
+     * NSEC3 parameters record RFC 5155 Parameter record for use with NSEC3.
+     */
+    public static final int TYPE_NSEC3PARAM = 0x0033;
+
+    /**
+     * TLSA certificate association record RFC 6698 A record for DNS-based
+     * Authentication of Named Entities (DANE). RFC 6698 defines The TLSA DNS
+     * resource record is used to associate a TLS server certificate or public
+     * key with the domain name where the record is found, thus forming a 'TLSA
+     * certificate association'.
+     */
+    public static final int TYPE_TLSA = 0x0034;
+
+    /**
+     * Host Identity Protocol record RFC 5205 Method of separating the end-point
+     * identifier and locator roles of IP addresses.
+     */
+    public static final int TYPE_HIP = 0x0037;
+
+    /**
+     * Sender Policy Framework record RFC 4408 Specified as part of the SPF
+     * protocol as an alternative to of storing SPF data in TXT records. Uses
+     * the same format as the earlier TXT record.
+     */
+    public static final int TYPE_SPF = 0x0063;
+
+    /**
+     * Secret key record RFC 2930 A method of providing keying material to be
+     * used with TSIG that is encrypted under the public key in an accompanying
+     * KEY RR..
+     */
+    public static final int TYPE_TKEY = 0x00f9;
+
+    /**
+     * Transaction Signature record RFC 2845 Can be used to authenticate dynamic
+     * updates as coming from an approved client, or to authenticate responses
+     * as coming from an approved recursive name server similar to DNSSEC.
+     */
+    public static final int TYPE_TSIG = 0x00fa;
+
+    /**
+     * Incremental Zone Transfer record RFC 1996 Requests a zone transfer of the
+     * given zone but only differences from a previous serial number. This
+     * request may be ignored and a full (AXFR) sent in response if the
+     * authoritative server is unable to fulfill the request due to
+     * configuration or lack of required deltas.
+     */
+    public static final int TYPE_IXFR = 0x00fb;
+
+    /**
+     * Authoritative Zone Transfer record RFC 1035 Transfer entire zone file
+     * from the master name server to secondary name servers.
+     */
+    public static final int TYPE_AXFR = 0x00fc;
+
+    /**
+     * All cached records RFC 1035 Returns all records of all types known to the
+     * name server. If the name server does not have any information on the
+     * name, the request will be forwarded on. The records returned may not be
+     * complete. For example, if there is both an A and an MX for a name, but
+     * the name server has only the A record cached, only the A record will be
+     * returned. Sometimes referred to as ANY, for example in Windows nslookup
+     * and Wireshark.
+     */
+    public static final int TYPE_ANY = 0x00ff;
+
+    /**
+     * Certification Authority Authorization record RFC 6844 CA pinning,
+     * constraining acceptable CAs for a host/domain.
+     */
+    public static final int TYPE_CAA = 0x0101;
+
+    /**
+     * DNSSEC Trust Authorities record N/A Part of a deployment proposal for
+     * DNSSEC without a signed DNS root. See the IANA database and Weiler Spec
+     * for details. Uses the same format as the DS record.
+     */
+    public static final int TYPE_TA = 0x8000;
+
+    /**
+     * DNSSEC Lookaside Validation record RFC 4431 For publishing DNSSEC trust
+     * anchors outside of the DNS delegation chain. Uses the same format as the
+     * DS record. RFC 5074 describes a way of using these records.
+     */
+    public static final int TYPE_DLV = 0x8001;
+
+    /**
+     * Default class for DNS entries.
+     */
+    public static final int CLASS_IN = 0x0001;
+
+    public static final int CLASS_CSNET = 0x0002;
+    public static final int CLASS_CHAOS = 0x0003;
+    public static final int CLASS_HESIOD = 0x0004;
+    public static final int CLASS_NONE = 0x00fe;
+    public static final int CLASS_ANY = 0x00ff;
+
+    private final String name;
+    private final int type;
+    private final int dnsClass;
+
+    // only allow to extend from same package
+    DnsEntry(String name, int type, int dnsClass) {
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+        if (name.isEmpty()) {
+            throw new IllegalArgumentException("name must not be left blank.");
+        }
+        if ((type & 0xffff) != type) {
+            throw new IllegalArgumentException("type must be an unsigned short.");
+        }
+        if (dnsClass < 1 || dnsClass > 4 && dnsClass != CLASS_NONE && dnsClass != CLASS_ANY) {
+            throw new IllegalArgumentException("an invalid class has been supplied.");
+        }
+        this.name = name;
+        this.type = type;
+        this.dnsClass = dnsClass;
+    }
+
+    /**
+     * Returns the name of this entry (the domain).
+     */
+    public String name() {
+        return name;
+    }
+
+    /**
+     * Returns the type of resource record to be received.
+     */
+    public int type() {
+        return type;
+    }
+
+    /**
+     * Returns the class for this entry. Default is IN (Internet).
+     */
+    public int dnsClass() {
+        return dnsClass;
+    }
+
+    @Override
+    public int hashCode() {
+        return (name.hashCode() * 31 + type) * 31 + dnsClass;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder(32).append(getClass().getSimpleName()).append("(domain name: ").append(name)
+                .append(", type: ").append(type).append(", class: ").append(dnsClass).append(')').toString();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o instanceof DnsEntry) {
+            DnsEntry other = (DnsEntry) o;
+            return other.type() == type && other.dnsClass() == dnsClass && other.name().equals(name);
+        }
+        return false;
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsHeader.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsHeader.java
new file mode 100644
index 000000000000..b824e79f5296
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsHeader.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * The header super-class which includes information shared by DNS query and
+ * response packet headers such as the ID, opcode, and type. The only flag
+ * shared by both classes is the flag for desiring recursion.
+ */
+public class DnsHeader {
+
+    /**
+     * Message type is query.
+     */
+    public static final int TYPE_QUERY = 0;
+
+    /**
+     * Message type is response.
+     */
+    public static final int TYPE_RESPONSE = 1;
+
+    /**
+     * Message is for a standard query.
+     */
+    public static final int OPCODE_QUERY = 0;
+
+    /**
+     * Message is for an inverse query. <strong>Note: inverse queries have been
+     * obsoleted since RFC 3425, and are not necessarily supported.</strong>
+     */
+    @Deprecated
+    public static final int OPCODE_IQUERY = 1;
+
+    private final DnsMessage parent;
+
+    private boolean recursionDesired;
+    private int opcode;
+    private int id;
+    private int type;
+    private int z;
+
+    // only allow to extend from within the same package
+    DnsHeader(DnsMessage parent) {
+        if (parent == null) {
+            throw new NullPointerException("parent");
+        }
+        this.parent = parent;
+    }
+
+    /**
+     * Returns the number of questions in the {@link DnsMessage}.
+     */
+    public int questionCount() {
+        return parent.questions().size();
+    }
+
+    /**
+     * Returns the number of answer resource records in the {@link DnsMessage}.
+     */
+    public int answerCount() {
+        return parent.answers().size();
+    }
+
+    /**
+     * Returns the number of authority resource records in the
+     * {@link DnsMessage}.
+     */
+    public int authorityResourceCount() {
+        return parent.authorityResources().size();
+    }
+
+    /**
+     * Returns the number of additional resource records in the
+     * {@link DnsMessage}.
+     */
+    public int additionalResourceCount() {
+        return parent.additionalResources().size();
+    }
+
+    /**
+     * Returns {@code true} if a query is to be pursued recursively.
+     */
+    public boolean isRecursionDesired() {
+        return recursionDesired;
+    }
+
+    /**
+     * Returns the 4 bit opcode used for the {@link DnsMessage}.
+     *
+     * @see #OPCODE_QUERY
+     * @see #OPCODE_IQUERY
+     */
+    public int opcode() {
+        return opcode;
+    }
+
+    /**
+     * Returns the type of {@link DnsMessage}.
+     *
+     * @see #TYPE_QUERY
+     */
+    public int type() {
+        return type;
+    }
+
+    /**
+     * Returns the 2 byte unsigned identifier number used for the
+     * {@link DnsMessage}.
+     */
+    public int id() {
+        return id;
+    }
+
+    /**
+     * Sets the opcode for this {@link DnsMessage}.
+     *
+     * @param opcode
+     *            opcode to set
+     * @return the header to allow method chaining
+     */
+    public DnsHeader setOpcode(int opcode) {
+        this.opcode = opcode;
+        return this;
+    }
+
+    /**
+     * Sets whether a name server is directed to pursue a query recursively or
+     * not.
+     *
+     * @param recursionDesired
+     *            if set to {@code true}, pursues query recursively
+     * @return the header to allow method chaining
+     */
+    public DnsHeader setRecursionDesired(boolean recursionDesired) {
+        this.recursionDesired = recursionDesired;
+        return this;
+    }
+
+    /**
+     * Sets the {@link DnsMessage} type.
+     *
+     * @param type
+     *            message type
+     * @return the header to allow method chaining
+     */
+    public DnsHeader setType(int type) {
+        this.type = type;
+        return this;
+    }
+
+    /**
+     * Sets the id for this {@link DnsMessage}.
+     *
+     * @param id
+     *            a unique 2 byte unsigned identifier
+     * @return the header to allow method chaining
+     */
+    public DnsHeader setId(int id) {
+        this.id = id;
+        return this;
+    }
+
+    /**
+     * Returns the 3 bit reserved field 'Z'.
+     */
+    public int z() {
+        return z;
+    }
+
+    /**
+     * Sets the field Z. This field is reserved and should remain as 0 if the
+     * DNS server does not make usage of this field.
+     *
+     * @param z
+     *            the value for the reserved field Z
+     */
+    public DnsHeader setZ(int z) {
+        this.z = z;
+        return this;
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java
new file mode 100644
index 000000000000..c30722230b4c
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.util.AbstractReferenceCounted;
+import io.netty.util.ReferenceCountUtil;
+
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * The message super-class which contains core information concerning DNS
+ * packets, both outgoing and incoming.
+ */
+public abstract class DnsMessage extends AbstractReferenceCounted {
+
+    private List<DnsQuestion> questions;
+    private List<DnsResource> answers;
+    private List<DnsResource> authority;
+    private List<DnsResource> additional;
+
+    private final DnsHeader header;
+
+    // Only allow to extend from same package
+    DnsMessage(int id) {
+        header = newHeader(id);
+    }
+
+    /**
+     * Returns the header belonging to this message.
+     */
+    public DnsHeader header() {
+        return header;
+    }
+
+    /**
+     * Returns a list of all the questions in this message.
+     */
+    public List<DnsQuestion> questions() {
+        if (questions == null) {
+            return Collections.emptyList();
+        }
+        return Collections.unmodifiableList(questions);
+    }
+
+    /**
+     * Returns a list of all the answer resource records in this message.
+     */
+    public List<DnsResource> answers() {
+        if (answers == null) {
+            return Collections.emptyList();
+        }
+        return Collections.unmodifiableList(answers);
+    }
+
+    /**
+     * Returns a list of all the authority resource records in this message.
+     */
+    public List<DnsResource> authorityResources() {
+        if (authority == null) {
+            return Collections.emptyList();
+        }
+        return Collections.unmodifiableList(authority);
+    }
+
+    /**
+     * Returns a list of all the additional resource records in this message.
+     */
+    public List<DnsResource> additionalResources() {
+        if (additional == null) {
+            return Collections.emptyList();
+        }
+        return Collections.unmodifiableList(additional);
+    }
+
+    /**
+     * Adds an answer resource record to this message.
+     *
+     * @param answer
+     *            the answer resource record to be added
+     * @return the message to allow method chaining
+     */
+    public DnsMessage addAnswer(DnsResource answer) {
+        if (answers == null) {
+            answers = new LinkedList<DnsResource>();
+        }
+        answers.add(answer);
+        return this;
+    }
+
+    /**
+     * Adds a question to this message.
+     *
+     * @param question
+     *            the question to be added
+     * @return the message to allow method chaining
+     */
+    public DnsMessage addQuestion(DnsQuestion question) {
+        if (questions == null) {
+            questions = new LinkedList<DnsQuestion>();
+        }
+        questions.add(question);
+        return this;
+    }
+
+    /**
+     * Adds an authority resource record to this message.
+     *
+     * @param resource
+     *            the authority resource record to be added
+     * @return the message to allow method chaining
+     */
+    public DnsMessage addAuthorityResource(DnsResource resource) {
+        if (authority == null) {
+            authority = new LinkedList<DnsResource>();
+        }
+        authority.add(resource);
+        return this;
+    }
+
+    /**
+     * Adds an additional resource record to this message.
+     *
+     * @param resource
+     *            the additional resource record to be added
+     * @return the message to allow method chaining
+     */
+    public DnsMessage addAdditionalResource(DnsResource resource) {
+        if (additional == null) {
+            additional = new LinkedList<DnsResource>();
+        }
+        additional.add(resource);
+        return this;
+    }
+
+    @Override
+    protected void deallocate() {
+        // NOOP
+    }
+
+    @Override
+    public boolean release() {
+        release(questions());
+        release(answers());
+        release(additionalResources());
+        release(authorityResources());
+        return super.release();
+    }
+
+    private static void release(List<?> resources) {
+        for (Object resource: resources) {
+            ReferenceCountUtil.release(resource);
+        }
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        release(questions(), decrement);
+        release(answers(), decrement);
+        release(additionalResources(), decrement);
+        release(authorityResources(), decrement);
+        return super.release(decrement);
+    }
+
+    private static void release(List<?> resources, int decrement) {
+        for (Object resource: resources) {
+            ReferenceCountUtil.release(resource, decrement);
+        }
+    }
+
+    @Override
+    public DnsMessage touch(Object hint) {
+        touch(questions(), hint);
+        touch(answers(), hint);
+        touch(additionalResources(), hint);
+        touch(authorityResources(), hint);
+        return this;
+    }
+
+    private static void touch(List<?> resources, Object hint) {
+        for (Object resource: resources) {
+            ReferenceCountUtil.touch(resource, hint);
+        }
+    }
+
+    @Override
+    public DnsMessage retain() {
+        retain(questions());
+        retain(answers());
+        retain(additionalResources());
+        retain(authorityResources());
+        super.retain();
+        return this;
+    }
+
+    private static void retain(List<?> resources) {
+        for (Object resource: resources) {
+            ReferenceCountUtil.retain(resource);
+        }
+    }
+
+    @Override
+    public DnsMessage retain(int increment) {
+        retain(questions(), increment);
+        retain(answers(), increment);
+        retain(additionalResources(), increment);
+        retain(authorityResources(), increment);
+        super.retain(increment);
+        return this;
+    }
+
+    private static void retain(List<?> resources, int increment) {
+        for (Object resource: resources) {
+            ReferenceCountUtil.retain(resource, increment);
+        }
+    }
+
+    @Override
+    public DnsMessage touch() {
+        super.touch();
+        return this;
+    }
+
+    protected abstract DnsHeader newHeader(int id);
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java
new file mode 100644
index 000000000000..c212c0394e2d
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import java.net.InetSocketAddress;
+
+/**
+ * A DNS query packet which is sent to a server to receive a DNS response packet
+ * with information answering a DnsQuery's questions.
+ */
+public class DnsQuery extends DnsMessage {
+
+    private final InetSocketAddress recipient;
+
+    /**
+     * Constructs a DNS query. By default recursion will be toggled on.
+     */
+    public DnsQuery(int id, InetSocketAddress recipient) {
+        super(id);
+        if (recipient == null) {
+            throw new NullPointerException("recipient");
+        }
+        this.recipient = recipient;
+    }
+
+    /**
+     * Return the {@link InetSocketAddress} of the recipient of the {@link DnsQuery}
+     */
+    public InetSocketAddress recipient() {
+        return recipient;
+    }
+
+    @Override
+    public DnsQuery addAnswer(DnsResource answer) {
+        super.addAnswer(answer);
+        return this;
+    }
+
+    @Override
+    public DnsQuery addQuestion(DnsQuestion question) {
+        super.addQuestion(question);
+        return this;
+    }
+
+    @Override
+    public DnsQuery addAuthorityResource(DnsResource resource) {
+        super.addAuthorityResource(resource);
+        return this;
+    }
+
+    @Override
+    public DnsQuery addAdditionalResource(DnsResource resource) {
+        super.addAdditionalResource(resource);
+        return this;
+    }
+
+    @Override
+    public DnsQuery touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+
+    @Override
+    public DnsQuery retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public DnsQuery retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public DnsQuery touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public DnsQueryHeader header() {
+        return (DnsQueryHeader) super.header();
+    }
+
+    @Override
+    protected DnsQueryHeader newHeader(int id) {
+        return new DnsQueryHeader(this, id);
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQueryEncoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQueryEncoder.java
new file mode 100644
index 000000000000..fed619dd9bea
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQueryEncoder.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.util.CharsetUtil;
+import io.netty.util.internal.StringUtil;
+
+import java.nio.charset.Charset;
+import java.util.List;
+
+/**
+ * DnsQueryEncoder accepts {@link DnsQuery} and encodes to {@link ByteBuf}. This
+ * class also contains methods for encoding parts of DnsQuery's such as the
+ * header and questions.
+ */
+@ChannelHandler.Sharable
+public class DnsQueryEncoder extends MessageToMessageEncoder<DnsQuery> {
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, DnsQuery query, List<Object> out) throws Exception {
+        ByteBuf buf = ctx.alloc().buffer();
+        encodeHeader(query.header(), buf);
+        List<DnsQuestion> questions = query.questions();
+        for (DnsQuestion question : questions) {
+            encodeQuestion(question, CharsetUtil.UTF_8, buf);
+        }
+        out.add(new DatagramPacket(buf, query.recipient(), null));
+    }
+
+    /**
+     * Encodes the information in a {@link DnsHeader} and writes it to the
+     * specified {@link ByteBuf}. The header is always 12 bytes long.
+     *
+     * @param header
+     *            the query header being encoded
+     * @param buf
+     *            the buffer the encoded data should be written to
+     */
+    private static void encodeHeader(DnsHeader header, ByteBuf buf) {
+        buf.writeShort(header.id());
+        int flags = 0;
+        flags |= header.type() << 15;
+        flags |= header.opcode() << 14;
+        flags |= header.isRecursionDesired() ? 1 << 8 : 0;
+        buf.writeShort(flags);
+        buf.writeShort(header.questionCount());
+        buf.writeShort(header.answerCount()); // Must be 0
+        buf.writeShort(header.authorityResourceCount()); // Must be 0
+        buf.writeShort(header.additionalResourceCount()); // Must be 0
+    }
+
+    /**
+     * Encodes the information in a {@link DnsQuestion} and writes it to the
+     * specified {@link ByteBuf}.
+     *
+     * @param question
+     *            the question being encoded
+     * @param charset
+     *            charset names are encoded in
+     * @param buf
+     *            the buffer the encoded data should be written to
+     */
+    private static void encodeQuestion(DnsQuestion question, Charset charset, ByteBuf buf) {
+        String[] parts = StringUtil.split(question.name(), '.');
+        for (String part: parts) {
+            buf.writeByte(part.length());
+            buf.writeBytes(part.getBytes(charset));
+        }
+        buf.writeByte(0); // marks end of name field
+        buf.writeShort(question.type());
+        buf.writeShort(question.dnsClass());
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQueryHeader.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQueryHeader.java
new file mode 100644
index 000000000000..65d60e94c109
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQueryHeader.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * The DNS query header class which is used to represent the 12 byte header in a
+ * {@link DnsQuery}.
+ */
+public final class DnsQueryHeader extends DnsHeader {
+
+    /**
+     * Constructor for a DNS packet query header. The id is user generated and
+     * will be replicated in the response packet by the server.
+     *
+     * @param parent the {@link DnsMessage} this header belongs to
+     * @param id     a 2 bit unsigned identification number for this query
+     */
+    public DnsQueryHeader(DnsMessage parent, int id) {
+        super(parent);
+        setId(id);
+        setRecursionDesired(true);
+    }
+
+    /**
+     * Returns the {@link DnsMessage} type. This will always return
+     * {@code TYPE_QUERY}.
+     */
+    @Override
+    public int type() {
+        return TYPE_QUERY;
+    }
+
+    /**
+     * Sets the {@link DnsHeader} type. Must be {@code TYPE_RESPONSE}.
+     *
+     * @param type message type
+     * @return the header to allow method chaining
+     */
+    @Override
+    public DnsQueryHeader setType(int type) {
+        if (type != TYPE_QUERY) {
+            throw new IllegalArgumentException("type cannot be anything but TYPE_QUERY (0) for a query header.");
+        }
+        super.setType(type);
+        return this;
+    }
+
+    @Override
+    public DnsQueryHeader setId(int id) {
+        super.setId(id);
+        return this;
+    }
+
+    @Override
+    public DnsQueryHeader setRecursionDesired(boolean recursionDesired) {
+        super.setRecursionDesired(recursionDesired);
+        return this;
+    }
+
+    @Override
+    public DnsQueryHeader setOpcode(int opcode) {
+        super.setOpcode(opcode);
+        return this;
+    }
+
+    @Override
+    public DnsQueryHeader setZ(int z) {
+        super.setZ(z);
+        return this;
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java
new file mode 100644
index 000000000000..61721c87afc1
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * The DNS question class which represents a question being sent to a server via
+ * a query, or the question being duplicated and sent back in a response.
+ * Usually a message contains a single question, and DNS servers often don't
+ * support multiple questions in a single query.
+ */
+public final class DnsQuestion extends DnsEntry {
+
+    /**
+     * Constructs a question with the default class IN (Internet).
+     *
+     * @param name
+     *            the domain name being queried i.e. "www.example.com"
+     * @param type
+     *            the question type, which represents the type of
+     *            {@link DnsResource} record that should be returned
+     */
+    public DnsQuestion(String name, int type) {
+        this(name, type, CLASS_IN);
+    }
+
+    /**
+     * Constructs a question with the given class.
+     *
+     * @param name
+     *            the domain name being queried i.e. "www.example.com"
+     * @param type
+     *            the question type, which represents the type of
+     *            {@link DnsResource} record that should be returned
+     * @param qClass
+     *            the class of a DNS record
+     */
+    public DnsQuestion(String name, int type, int qClass) {
+        super(name, type, qClass);
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (!(other instanceof DnsQuestion)) {
+            return false;
+        }
+        return super.equals(other);
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode();
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResource.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResource.java
new file mode 100644
index 000000000000..30064269e25a
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResource.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufHolder;
+
+/**
+ * Represents any resource record (answer, authority, or additional resource
+ * records).
+ */
+public final class DnsResource extends DnsEntry implements ByteBufHolder {
+
+    private final long ttl;
+    private final ByteBuf content;
+
+    /**
+     * Constructs a resource record.
+     *
+     * @param name
+     *            the domain name
+     * @param type
+     *            the type of record being returned
+     * @param aClass
+     *            the class for this resource record
+     * @param ttl
+     *            the time to live after reading
+     * @param content
+     *            the data contained in this record
+     */
+    public DnsResource(String name, int type, int aClass, long ttl, ByteBuf content) {
+        super(name, type, aClass);
+        this.ttl = ttl;
+        this.content = content;
+    }
+
+    /**
+     * Returns the time to live after reading for this resource record.
+     */
+    public long timeToLive() {
+        return ttl;
+    }
+
+    /**
+     * Returns the data contained in this resource record.
+     */
+    @Override
+    public ByteBuf content() {
+        return content;
+    }
+
+    /**
+     * Returns a deep copy of this resource record.
+     */
+    @Override
+    public DnsResource copy() {
+        return new DnsResource(name(), type(), dnsClass(), ttl, content.copy());
+    }
+
+    /**
+     * Returns a duplicate of this resource record.
+     */
+    @Override
+    public ByteBufHolder duplicate() {
+        return new DnsResource(name(), type(), dnsClass(), ttl, content.duplicate());
+    }
+
+    @Override
+    public int refCnt() {
+        return content.refCnt();
+    }
+
+    @Override
+    public DnsResource retain() {
+        content.retain();
+        return this;
+    }
+
+    @Override
+    public DnsResource retain(int increment) {
+        content.retain(increment);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        return content.release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        return content.release(decrement);
+    }
+
+    @Override
+    public DnsResource touch() {
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public DnsResource touch(Object hint) {
+        content.touch(hint);
+        return this;
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java
new file mode 100644
index 000000000000..b733614d8fa4
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import java.net.InetSocketAddress;
+
+/**
+ * A DNS response packet which is sent to a client after a server receives a
+ * query.
+ */
+public final class DnsResponse extends DnsMessage {
+
+    private final InetSocketAddress sender;
+
+    public DnsResponse(int id, InetSocketAddress sender) {
+        super(id);
+        if (sender == null) {
+            throw new NullPointerException("sender");
+        }
+        this.sender = sender;
+    }
+
+    /**
+     * The {@link InetSocketAddress} of the sender of this {@link DnsResponse}
+     */
+    public InetSocketAddress sender() {
+        return sender;
+    }
+
+    @Override
+    public DnsResponse addAnswer(DnsResource answer) {
+        super.addAnswer(answer);
+        return this;
+    }
+
+    @Override
+    public DnsResponse addQuestion(DnsQuestion question) {
+        super.addQuestion(question);
+        return this;
+    }
+
+    @Override
+    public DnsResponse addAuthorityResource(DnsResource resource) {
+        super.addAuthorityResource(resource);
+        return this;
+    }
+
+    @Override
+    public DnsResponse addAdditionalResource(DnsResource resource) {
+        super.addAdditionalResource(resource);
+        return this;
+    }
+
+    @Override
+    public DnsResponse touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+
+    @Override
+    public DnsResponse retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public DnsResponse retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public DnsResponse touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public DnsResponseHeader header() {
+        return (DnsResponseHeader) super.header();
+    }
+
+    @Override
+    protected DnsResponseHeader newHeader(int id) {
+        return new DnsResponseHeader(this, id);
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java
new file mode 100644
index 000000000000..c2a7b4b986d2
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * Represents the possible response codes a server may send after receiving a
+ * query. A response code of 0 indicates no error.
+ */
+public final class DnsResponseCode implements Comparable<DnsResponseCode> {
+
+    /**
+     * ID 0, no error
+     */
+    public static final DnsResponseCode NOERROR = new DnsResponseCode(0, "no error");
+
+    /**
+     * ID 1, format error
+     */
+    public static final DnsResponseCode FORMERROR = new DnsResponseCode(1, "format error");
+
+    /**
+     * ID 2, server failure
+     */
+    public static final DnsResponseCode SERVFAIL = new DnsResponseCode(2, "server failure");
+
+    /**
+     * ID 3, name error
+     */
+    public static final DnsResponseCode NXDOMAIN = new DnsResponseCode(3, "name error");
+
+    /**
+     * ID 4, not implemented
+     */
+    public static final DnsResponseCode NOTIMPL = new DnsResponseCode(4, "not implemented");
+
+    /**
+     * ID 5, operation refused
+     */
+    public static final DnsResponseCode REFUSED = new DnsResponseCode(5, "operation refused");
+
+    /**
+     * ID 6, domain name should not exist
+     */
+    public static final DnsResponseCode YXDOMAIN = new DnsResponseCode(6, "domain name should not exist");
+
+    /**
+     * ID 7, resource record set should not exist
+     */
+    public static final DnsResponseCode YXRRSET = new DnsResponseCode(7, "resource record set should not exist");
+
+    /**
+     * ID 8, rrset does not exist
+     */
+    public static final DnsResponseCode NXRRSET = new DnsResponseCode(8, "rrset does not exist");
+
+    /**
+     * ID 9, not authoritative for zone
+     */
+    public static final DnsResponseCode NOTAUTH = new DnsResponseCode(9, "not authoritative for zone");
+
+    /**
+     * ID 10, name not in zone
+     */
+    public static final DnsResponseCode NOTZONE = new DnsResponseCode(10, "name not in zone");
+
+    /**
+     * ID 11, bad extension mechanism for version
+     */
+    public static final DnsResponseCode BADVERS = new DnsResponseCode(11, "bad extension mechanism for version");
+
+    /**
+     * ID 12, bad signature
+     */
+    public static final DnsResponseCode BADSIG = new DnsResponseCode(12, "bad signature");
+
+    /**
+     * ID 13, bad key
+     */
+    public static final DnsResponseCode BADKEY = new DnsResponseCode(13, "bad key");
+
+    /**
+     * ID 14, bad timestamp
+     */
+    public static final DnsResponseCode BADTIME = new DnsResponseCode(14, "bad timestamp");
+
+    private final int errorCode;
+    private final String message;
+
+    /**
+     * Returns the {@link DnsResponseCode} that corresponds with the given
+     * {@code responseCode}.
+     *
+     * @param responseCode
+     *            the error code's id
+     * @return corresponding {@link DnsResponseCode} or {@code null} if none can be found.
+     */
+    public static DnsResponseCode valueOf(int responseCode) {
+        switch (responseCode) {
+            case 0:
+                return NOERROR;
+            case 1:
+                return FORMERROR;
+            case 2:
+                return SERVFAIL;
+            case 3:
+                return NXDOMAIN;
+            case 4:
+                return NOTIMPL;
+            case 5:
+                return REFUSED;
+            case 6:
+                return YXDOMAIN;
+            case 7:
+                return YXRRSET;
+            case 8:
+                return NXRRSET;
+            case 9:
+                return NOTAUTH;
+            case 10:
+                return NOTZONE;
+            case 11:
+                return BADVERS;
+            case 12:
+                return BADSIG;
+            case 13:
+                return BADKEY;
+            case 14:
+                return BADTIME;
+            default:
+                return new DnsResponseCode(responseCode, null);
+        }
+    }
+
+    public DnsResponseCode(int errorCode, String message) {
+        this.errorCode = errorCode;
+        this.message = message;
+    }
+
+    /**
+     * Returns the error code for this {@link DnsResponseCode}.
+     */
+    public int code() {
+        return errorCode;
+    }
+
+    @Override
+    public int compareTo(DnsResponseCode o) {
+        return code() - o.code();
+    }
+
+    @Override
+    public int hashCode() {
+        return code();
+    }
+
+    /**
+     * Equality of {@link DnsResponseCode} only depends on {@link #code()}.
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (!(o instanceof DnsResponseCode)) {
+            return false;
+        }
+
+        return code() == ((DnsResponseCode) o).code();
+    }
+
+    /**
+     * Returns a formatted error message for this {@link DnsResponseCode}.
+     */
+    @Override
+    public String toString() {
+        if (message == null) {
+            return "DnsResponseCode(" + errorCode + ')';
+        }
+        return "DnsResponseCode(" + errorCode + ", " + message + ')';
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java
new file mode 100644
index 000000000000..b8f613b52dd8
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.util.CharsetUtil;
+
+import java.util.List;
+
+/**
+ * DnsResponseDecoder accepts {@link io.netty.channel.socket.DatagramPacket} and encodes to
+ * {@link DnsResponse}. This class also contains methods for decoding parts of
+ * DnsResponses such as questions and resource records.
+ */
+@ChannelHandler.Sharable
+public class DnsResponseDecoder extends MessageToMessageDecoder<DatagramPacket> {
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, DatagramPacket packet, List<Object> out) throws Exception {
+        ByteBuf buf = packet.content();
+
+        int id = buf.readUnsignedShort();
+
+        DnsResponse response = new DnsResponse(id, packet.sender());
+        DnsResponseHeader header = response.header();
+        int flags = buf.readUnsignedShort();
+        header.setType(flags >> 15);
+        header.setOpcode(flags >> 11 & 0xf);
+        header.setRecursionDesired((flags >> 8 & 1) == 1);
+        header.setAuthoritativeAnswer((flags >> 10 & 1) == 1);
+        header.setTruncated((flags >> 9 & 1) == 1);
+        header.setRecursionAvailable((flags >> 7 & 1) == 1);
+        header.setZ(flags >> 4 & 0x7);
+        header.setResponseCode(DnsResponseCode.valueOf(flags & 0xf));
+
+        int questions = buf.readUnsignedShort();
+        int answers = buf.readUnsignedShort();
+        int authorities = buf.readUnsignedShort();
+        int additionals = buf.readUnsignedShort();
+
+        for (int i = 0; i < questions; i++) {
+            response.addQuestion(decodeQuestion(buf));
+        }
+        if (header.responseCode() != DnsResponseCode.NOERROR) {
+            // response code for error
+            out.add(response);
+            return;
+        }
+        for (int i = 0; i < answers; i++) {
+            response.addAnswer(decodeResource(buf));
+        }
+        for (int i = 0; i < authorities; i++) {
+            response.addAuthorityResource(decodeResource(buf));
+        }
+        for (int i = 0; i < additionals; i++) {
+            response.addAdditionalResource(decodeResource(buf));
+        }
+        out.add(response);
+    }
+
+    /**
+     * Retrieves a domain name given a buffer containing a DNS packet. If the
+     * name contains a pointer, the position of the buffer will be set to
+     * directly after the pointer's index after the name has been read.
+     *
+     * @param buf
+     *            the byte buffer containing the DNS packet
+     * @return the domain name for an entry
+     */
+    private static String readName(ByteBuf buf) {
+        int position = -1;
+        StringBuilder name = new StringBuilder();
+        for (int len = buf.readUnsignedByte(); buf.isReadable() && len != 0; len = buf.readUnsignedByte()) {
+            boolean pointer = (len & 0xc0) == 0xc0;
+            if (pointer) {
+                if (position == -1) {
+                    position = buf.readerIndex() + 1;
+                }
+                buf.readerIndex((len & 0x3f) << 8 | buf.readUnsignedByte());
+            } else {
+                name.append(buf.toString(buf.readerIndex(), len, CharsetUtil.UTF_8)).append('.');
+                buf.skipBytes(len);
+            }
+        }
+        if (position != -1) {
+            buf.readerIndex(position);
+        }
+        if (name.length() == 0) {
+            return null;
+        }
+        return name.substring(0, name.length() - 1);
+    }
+
+    /**
+     * Decodes a question, given a DNS packet in a byte buffer.
+     *
+     * @param buf
+     *            the byte buffer containing the DNS packet
+     * @return a decoded {@link DnsQuestion}
+     */
+    private static DnsQuestion decodeQuestion(ByteBuf buf) {
+        String name = readName(buf);
+        int type = buf.readUnsignedShort();
+        int qClass = buf.readUnsignedShort();
+        return new DnsQuestion(name, type, qClass);
+    }
+
+    /**
+     * Decodes a resource record, given a DNS packet in a byte buffer.
+     *
+     * @param buf
+     *            the byte buffer containing the DNS packet
+     * @return a {@link DnsResource} record containing response data
+     */
+    private static DnsResource decodeResource(ByteBuf buf) {
+        String name = readName(buf);
+        int type = buf.readUnsignedShort();
+        int aClass = buf.readUnsignedShort();
+        long ttl = buf.readUnsignedInt();
+        int len = buf.readUnsignedShort();
+
+        int readerIndex = buf.readerIndex();
+        ByteBuf payload = buf.duplicate().setIndex(readerIndex, readerIndex + len).retain();
+        buf.readerIndex(readerIndex + len);
+        return new DnsResource(name, type, aClass, ttl, payload);
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseException.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseException.java
new file mode 100644
index 000000000000..4497463fe5ac
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseException.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+
+import io.netty.handler.codec.DecoderException;
+
+public final class DnsResponseException extends DecoderException {
+
+    private static final long serialVersionUID = -8519053051363525286L;
+
+    private final DnsResponseCode code;
+
+    public DnsResponseException(DnsResponseCode code) {
+        if (code == null) {
+            throw new NullPointerException("code");
+        }
+        this.code = code;
+    }
+
+    /**
+     * The {@link DnsResponseCode} which caused this {@link DnsResponseException} to be created.
+     */
+    public DnsResponseCode responseCode() {
+        return code;
+    }
+}
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseHeader.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseHeader.java
new file mode 100644
index 000000000000..7d828ef9afae
--- /dev/null
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseHeader.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+/**
+ * The DNS response header class which is used when receiving data from a DNS
+ * server. Contains information contained in a DNS response header, such as
+ * recursion availability, and response codes.
+ */
+public final class DnsResponseHeader extends DnsHeader {
+
+    private boolean authoritativeAnswer;
+    private boolean truncated;
+    private boolean recursionAvailable;
+
+    private DnsResponseCode responseCode;
+
+    /**
+     * Constructor for a DNS packet response header. The id is received by
+     * reading a {@link DnsQuery} and is sent back to the client.
+     *
+     * @param parent
+     *            the {@link DnsMessage} this header belongs to
+     * @param id
+     *            a 2 bit unsigned identification number received from client
+     */
+    public DnsResponseHeader(DnsMessage parent, int id) {
+        super(parent);
+        setId(id);
+    }
+
+    /**
+     * Returns {@code true} if responding server is authoritative for the domain
+     * name in the query message.
+     */
+    public boolean isAuthoritativeAnswer() {
+        return authoritativeAnswer;
+    }
+
+    /**
+     * Returns {@code true} if response has been truncated, usually if it is
+     * over 512 bytes.
+     */
+    public boolean isTruncated() {
+        return truncated;
+    }
+
+    /**
+     * Returns {@code true} if DNS server can handle recursive queries.
+     */
+    public boolean isRecursionAvailable() {
+        return recursionAvailable;
+    }
+
+    /**
+     * Returns the 4 bit return code.
+     */
+    public DnsResponseCode responseCode() {
+        return responseCode;
+    }
+
+    /**
+     * Returns the {@link DnsMessage} type. This will always return
+     * {@code TYPE_RESPONSE}.
+     */
+    @Override
+    public int type() {
+        return TYPE_RESPONSE;
+    }
+
+    /**
+     * Set to {@code true} if responding server is authoritative for the domain
+     * name in the query message.
+     *
+     * @param authoritativeAnswer
+     *            flag for authoritative answer
+     */
+    public DnsResponseHeader setAuthoritativeAnswer(boolean authoritativeAnswer) {
+        this.authoritativeAnswer = authoritativeAnswer;
+        return this;
+    }
+
+    /**
+     * Set to {@code true} if response has been truncated (usually happens for
+     * responses over 512 bytes).
+     *
+     * @param truncated
+     *            flag for truncation
+     */
+    public DnsResponseHeader setTruncated(boolean truncated) {
+        this.truncated = truncated;
+        return this;
+    }
+
+    /**
+     * Set to {@code true} if DNS server can handle recursive queries.
+     *
+     * @param recursionAvailable
+     *            flag for recursion availability
+     */
+    public DnsResponseHeader setRecursionAvailable(boolean recursionAvailable) {
+        this.recursionAvailable = recursionAvailable;
+        return this;
+    }
+
+    /**
+     * Sets the response code for this message.
+     *
+     * @param responseCode
+     *            the response code
+     */
+    public DnsResponseHeader setResponseCode(DnsResponseCode responseCode) {
+        this.responseCode = responseCode;
+        return this;
+    }
+
+    /**
+     * Sets the {@link DnsHeader} type. Must be {@code TYPE_RESPONSE}.
+     *
+     * @param type
+     *            message type
+     * @return the header to allow method chaining
+     */
+    @Override
+    public DnsResponseHeader setType(int type) {
+        if (type != TYPE_RESPONSE) {
+            throw new IllegalArgumentException("type cannot be anything but TYPE_RESPONSE (1) for a response header.");
+        }
+        super.setType(type);
+        return this;
+    }
+
+    @Override
+    public DnsResponseHeader setId(int id) {
+        super.setId(id);
+        return this;
+    }
+
+    @Override
+    public DnsHeader setRecursionDesired(boolean recursionDesired) {
+        return super.setRecursionDesired(recursionDesired);
+    }
+
+    @Override
+    public DnsResponseHeader setOpcode(int opcode) {
+        super.setOpcode(opcode);
+        return this;
+    }
+
+    @Override
+    public DnsResponseHeader setZ(int z) {
+        super.setZ(z);
+        return this;
+    }
+}
diff --git a/example/src/main/java/io/netty/example/http/websocketx/client/package-info.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
similarity index 69%
rename from example/src/main/java/io/netty/example/http/websocketx/client/package-info.java
rename to codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
index f009016a0d10..7dab11b7dde8 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/client/package-info.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
@@ -15,9 +15,7 @@
  */
 
 /**
- * <p>This is an example web service client.
- * <p>To run this example, you must first start
- * {@link io.netty.example.http.websocketx.server.WebSocketServer} and
- * then {@link io.netty.example.http.websocketx.client.WebSocketClient}.
+ * DNS codec information for writing to and reading from a DNS server.
+ * Includes decoders and classes for representing messages and resources.
  */
-package io.netty.example.http.websocketx.client;
+package io.netty.handler.codec.dns;
diff --git a/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java
new file mode 100644
index 000000000000..18e999b58d06
--- /dev/null
+++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.channel.embedded.EmbeddedChannel;
+
+import io.netty.channel.socket.DatagramPacket;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.List;
+
+public class DnsQueryTest {
+
+    @Test
+    public void writeQueryTest() throws Exception {
+        InetSocketAddress addr = new InetSocketAddress(0);
+        EmbeddedChannel embedder = new EmbeddedChannel(new DnsQueryEncoder());
+        List<DnsQuery> queries = new ArrayList<DnsQuery>(5);
+        queries.add(new DnsQuery(1, addr).addQuestion(new DnsQuestion("1.0.0.127.in-addr.arpa", DnsEntry.TYPE_PTR)));
+        queries.add(new DnsQuery(1, addr).addQuestion(new DnsQuestion("www.example.com", DnsEntry.TYPE_A)));
+        queries.add(new DnsQuery(1, addr).addQuestion(new DnsQuestion("example.com", DnsEntry.TYPE_AAAA)));
+        queries.add(new DnsQuery(1, addr).addQuestion(new DnsQuestion("example.com", DnsEntry.TYPE_MX)));
+        queries.add(new DnsQuery(1, addr).addQuestion(new DnsQuestion("example.com", DnsEntry.TYPE_CNAME)));
+
+        for (DnsQuery query: queries) {
+            Assert.assertEquals("Invalid question count, expected 1.", 1, query.header().questionCount());
+            Assert.assertEquals("Invalid answer count, expected 0.", 0, query.header().answerCount());
+            Assert.assertEquals("Invalid authority resource record count, expected 0.", 0, query.header()
+                    .authorityResourceCount());
+            Assert.assertEquals("Invalid additional resource record count, expected 0.", 0, query.header()
+                    .additionalResourceCount());
+            Assert.assertEquals("Invalid type, should be TYPE_QUERY (0)", DnsHeader.TYPE_QUERY, query.header()
+                    .type());
+            embedder.writeOutbound(query);
+            DatagramPacket packet = embedder.readOutbound();
+            Assert.assertTrue(packet.content().isReadable());
+            packet.release();
+            Assert.assertNull(embedder.readOutbound());
+        }
+    }
+}
diff --git a/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java
new file mode 100644
index 000000000000..28efbe5063d7
--- /dev/null
+++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.dns;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.channel.socket.DatagramPacket;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+
+public class DnsResponseTest {
+
+    private static final byte[][] packets = {
+            { 0, 1, -127, -128, 0, 1, 0, 1, 0, 0, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3, 99,
+                    111, 109, 0, 0, 1, 0, 1, -64, 12, 0, 1, 0, 1, 0, 0, 16, -113, 0, 4, -64, 0, 43, 10 },
+            { 0, 1, -127, -128, 0, 1, 0, 1, 0, 0, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3, 99,
+                    111, 109, 0, 0, 28, 0, 1, -64, 12, 0, 28, 0, 1, 0, 0, 69, -8, 0, 16, 32, 1, 5, 0, 0, -120, 2, 0, 0,
+                    0, 0, 0, 0, 0, 0, 16 },
+            { 0, 2, -127, -128, 0, 1, 0, 0, 0, 1, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3, 99,
+                    111, 109, 0, 0, 15, 0, 1, -64, 16, 0, 6, 0, 1, 0, 0, 3, -43, 0, 45, 3, 115, 110, 115, 3, 100, 110,
+                    115, 5, 105, 99, 97, 110, 110, 3, 111, 114, 103, 0, 3, 110, 111, 99, -64, 49, 119, -4, 39, 112, 0,
+                    0, 28, 32, 0, 0, 14, 16, 0, 18, 117, 0, 0, 0, 14, 16 },
+            { 0, 3, -127, -128, 0, 1, 0, 1, 0, 0, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97, 109, 112, 108, 101, 3, 99,
+                    111, 109, 0, 0, 16, 0, 1, -64, 12, 0, 16, 0, 1, 0, 0, 84, 75, 0, 12, 11, 118, 61, 115, 112, 102,
+                    49, 32, 45, 97, 108, 108 } };
+
+    @Test
+    public void readResponseTest() throws Exception {
+        EmbeddedChannel embedder = new EmbeddedChannel(new DnsResponseDecoder());
+        for (byte[] p: packets) {
+            ByteBuf packet = embedder.alloc().buffer(512).writeBytes(p);
+            embedder.writeInbound(new DatagramPacket(packet, null, new InetSocketAddress(0)));
+            DnsResponse decoded = embedder.readInbound();
+            packet.retain().readerIndex(0);
+            ByteBuf raw = Unpooled.wrappedBuffer(p);
+            Assert.assertEquals("Invalid id, expected: " + raw.getUnsignedShort(0) + ", actual: "
+                    + decoded.header().id(), raw.getUnsignedShort(0), decoded.header().id());
+            Assert.assertEquals("Invalid resource count,  expected: " + raw.getUnsignedShort(4) + ", actual: "
+                    + decoded.questions().size(), raw.getUnsignedShort(4), decoded.questions().size());
+            Assert.assertEquals("Invalid resource count,  expected: " + raw.getUnsignedShort(6) + ", actual: "
+                    + decoded.answers().size(), raw.getUnsignedShort(6), decoded.answers().size());
+            Assert.assertEquals("Invalid resource count,  expected: " + raw.getUnsignedShort(8) + ", actual: "
+                    + decoded.authorityResources().size(), raw.getUnsignedShort(8), decoded.authorityResources()
+                    .size());
+            Assert.assertEquals("Invalid resource count,  expected: " + raw.getUnsignedShort(10) + ", actual: "
+                    + decoded.additionalResources().size(), raw.getUnsignedShort(10),
+                    decoded.additionalResources().size());
+            decoded.release();
+        }
+    }
+}
diff --git a/codec-dns/src/test/java/io/netty/handler/codec/dns/package-info.java b/codec-dns/src/test/java/io/netty/handler/codec/dns/package-info.java
new file mode 100644
index 000000000000..35930c2162e9
--- /dev/null
+++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/package-info.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * A DNS client that queries a server and checks if query information and
+ * responses are valid to ensure codec is correct.
+ */
+package io.netty.handler.codec.dns;
diff --git a/codec-haproxy/pom.xml b/codec-haproxy/pom.xml
new file mode 100644
index 000000000000..6a5eb688eec9
--- /dev/null
+++ b/codec-haproxy/pom.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2012 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>io.netty</groupId>
+    <artifactId>netty-parent</artifactId>
+    <version>4.1.0.Beta1</version>
+  </parent>
+
+  <artifactId>netty-codec-haproxy</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Netty/Codec/HAProxy</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+</project>
+
diff --git a/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyCommand.java b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyCommand.java
new file mode 100644
index 000000000000..4fb9d334d64d
--- /dev/null
+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyCommand.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.haproxy;
+
+/**
+ * The command of an HAProxy proxy protocol header
+ */
+public enum HAProxyCommand {
+    /**
+     * The LOCAL command represents a connection that was established on purpose by the proxy
+     * without being relayed.
+     */
+    LOCAL(HAProxyConstants.COMMAND_LOCAL_BYTE),
+    /**
+     * The PROXY command represents a connection that was established on behalf of another node,
+     * and reflects the original connection endpoints.
+     */
+    PROXY(HAProxyConstants.COMMAND_PROXY_BYTE);
+
+    /**
+     * The command is specified in the lowest 4 bits of the protocol version and command byte
+     */
+    private static final byte COMMAND_MASK = 0x0f;
+
+    private final byte byteValue;
+
+    /**
+     * Creates a new instance
+     */
+    HAProxyCommand(byte byteValue) {
+        this.byteValue = byteValue;
+    }
+
+    /**
+     * Returns the {@link HAProxyCommand} represented by the lowest 4 bits of the specified byte.
+     *
+     * @param verCmdByte protocol version and command byte
+     */
+    public static HAProxyCommand valueOf(byte verCmdByte) {
+        int cmd = verCmdByte & COMMAND_MASK;
+        switch ((byte) cmd) {
+            case HAProxyConstants.COMMAND_PROXY_BYTE:
+                return PROXY;
+            case HAProxyConstants.COMMAND_LOCAL_BYTE:
+                return LOCAL;
+            default:
+                throw new IllegalArgumentException("unknown command: " + cmd);
+        }
+    }
+
+    /**
+     * Returns the byte value of this command.
+     */
+    public byte byteValue() {
+        return byteValue;
+    }
+}
diff --git a/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyConstants.java b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyConstants.java
new file mode 100644
index 000000000000..c2a4e22c7234
--- /dev/null
+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyConstants.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.haproxy;
+
+final class HAProxyConstants {
+
+    /**
+     * Command byte constants
+     */
+    static final byte COMMAND_LOCAL_BYTE = 0x00;
+    static final byte COMMAND_PROXY_BYTE = 0x01;
+
+    /**
+     * Version byte constants
+     */
+    static final byte VERSION_ONE_BYTE = 0x10;
+    static final byte VERSION_TWO_BYTE = 0x20;
+
+    /**
+     * Transport protocol byte constants
+     */
+    static final byte TRANSPORT_UNSPEC_BYTE = 0x00;
+    static final byte TRANSPORT_STREAM_BYTE = 0x01;
+    static final byte TRANSPORT_DGRAM_BYTE = 0x02;
+
+    /**
+     * Address family byte constants
+     */
+    static final byte AF_UNSPEC_BYTE = 0x00;
+    static final byte AF_IPV4_BYTE = 0x10;
+    static final byte AF_IPV6_BYTE = 0x20;
+    static final byte AF_UNIX_BYTE = 0x30;
+
+    /**
+     * Transport protocol and address family byte constants
+     */
+    static final byte TPAF_UNKNOWN_BYTE = 0x00;
+    static final byte TPAF_TCP4_BYTE = 0x11;
+    static final byte TPAF_TCP6_BYTE = 0x21;
+    static final byte TPAF_UDP4_BYTE = 0x12;
+    static final byte TPAF_UDP6_BYTE = 0x22;
+    static final byte TPAF_UNIX_STREAM_BYTE = 0x31;
+    static final byte TPAF_UNIX_DGRAM_BYTE = 0x32;
+
+    private HAProxyConstants() { }
+}
diff --git a/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java
new file mode 100644
index 000000000000..5589d0d24ef7
--- /dev/null
+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java
@@ -0,0 +1,431 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.haproxy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufProcessor;
+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;
+import io.netty.util.CharsetUtil;
+import io.netty.util.NetUtil;
+import io.netty.util.internal.StringUtil;
+
+/**
+ * Message container for decoded HAProxy proxy protocol parameters
+ */
+public final class HAProxyMessage {
+
+    /**
+     * Version 1 proxy protocol message for 'UNKNOWN' proxied protocols. Per spec, when the proxied protocol is
+     * 'UNKNOWN' we must discard all other header values.
+     */
+    private static final HAProxyMessage V1_UNKNOWN_MSG = new HAProxyMessage(
+            HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNKNOWN, null, null, 0, 0);
+
+    /**
+     * Version 2 proxy protocol message for 'UNKNOWN' proxied protocols. Per spec, when the proxied protocol is
+     * 'UNKNOWN' we must discard all other header values.
+     */
+    private static final HAProxyMessage V2_UNKNOWN_MSG = new HAProxyMessage(
+            HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNKNOWN, null, null, 0, 0);
+
+    /**
+     * Version 2 proxy protocol message for local requests. Per spec, we should use an unspecified protocol and family
+     * for 'LOCAL' commands. Per spec, when the proxied protocol is 'UNKNOWN' we must discard all other header values.
+     */
+    private static final HAProxyMessage V2_LOCAL_MSG = new HAProxyMessage(
+            HAProxyProtocolVersion.V2, HAProxyCommand.LOCAL, HAProxyProxiedProtocol.UNKNOWN, null, null, 0, 0);
+
+    private final HAProxyProtocolVersion protocolVersion;
+    private final HAProxyCommand command;
+    private final HAProxyProxiedProtocol proxiedProtocol;
+    private final String sourceAddress;
+    private final String destinationAddress;
+    private final int sourcePort;
+    private final int destinationPort;
+
+    /**
+     * Creates a new instance
+     */
+    private HAProxyMessage(
+            HAProxyProtocolVersion protocolVersion, HAProxyCommand command, HAProxyProxiedProtocol proxiedProtocol,
+            String sourceAddress, String destinationAddress, String sourcePort, String destinationPort) {
+        this(
+                protocolVersion, command, proxiedProtocol,
+                sourceAddress, destinationAddress, portStringToInt(sourcePort), portStringToInt(destinationPort));
+    }
+
+    /**
+     * Creates a new instance
+     */
+    private HAProxyMessage(
+            HAProxyProtocolVersion protocolVersion, HAProxyCommand command, HAProxyProxiedProtocol proxiedProtocol,
+            String sourceAddress, String destinationAddress, int sourcePort, int destinationPort) {
+
+        AddressFamily addrFamily;
+        if (proxiedProtocol != null) {
+            addrFamily = proxiedProtocol.addressFamily();
+        } else {
+            addrFamily = null;
+        }
+
+        checkAddress(sourceAddress, addrFamily);
+        checkAddress(destinationAddress, addrFamily);
+        checkPort(sourcePort);
+        checkPort(destinationPort);
+
+        this.protocolVersion = protocolVersion;
+        this.command = command;
+        this.proxiedProtocol = proxiedProtocol;
+        this.sourceAddress = sourceAddress;
+        this.destinationAddress = destinationAddress;
+        this.sourcePort = sourcePort;
+        this.destinationPort = destinationPort;
+    }
+
+    /**
+     * Decodes a version 2, binary proxy protocol header.
+     *
+     * @param header                     a version 2 proxy protocol header
+     * @return                           {@link HAProxyMessage} instance
+     * @throws HAProxyProtocolException  if any portion of the header is invalid
+     */
+    static HAProxyMessage decodeHeader(ByteBuf header) {
+        if (header == null) {
+            throw new NullPointerException("header");
+        }
+
+        if (header.readableBytes() < 16) {
+            throw new HAProxyProtocolException(
+                    "incomplete header: " + header.readableBytes() + " bytes (expected: 16+ bytes)");
+        }
+
+        // Per spec, the 13th byte is the protocol version and command byte
+        header.skipBytes(12);
+        final byte verCmdByte = header.readByte();
+
+        HAProxyProtocolVersion ver;
+        try {
+            ver = HAProxyProtocolVersion.valueOf(verCmdByte);
+        } catch (IllegalArgumentException e) {
+            throw new HAProxyProtocolException(e);
+        }
+
+        if (ver != HAProxyProtocolVersion.V2) {
+            throw new HAProxyProtocolException("version 1 unsupported: 0x" + Integer.toHexString(verCmdByte));
+        }
+
+        HAProxyCommand cmd;
+        try {
+            cmd = HAProxyCommand.valueOf(verCmdByte);
+        } catch (IllegalArgumentException e) {
+            throw new HAProxyProtocolException(e);
+        }
+
+        if (cmd == HAProxyCommand.LOCAL) {
+            return V2_LOCAL_MSG;
+        }
+
+        // Per spec, the 14th byte is the protocol and address family byte
+        HAProxyProxiedProtocol protAndFam;
+        try {
+            protAndFam = HAProxyProxiedProtocol.valueOf(header.readByte());
+        } catch (IllegalArgumentException e) {
+            throw new HAProxyProtocolException(e);
+        }
+
+        if (protAndFam == HAProxyProxiedProtocol.UNKNOWN) {
+            return V2_UNKNOWN_MSG;
+        }
+
+        int addressInfoLen = header.readUnsignedShort();
+
+        String srcAddress;
+        String dstAddress;
+        int addressLen;
+        int srcPort = 0;
+        int dstPort = 0;
+
+        AddressFamily addressFamily = protAndFam.addressFamily();
+
+        if (addressFamily == AddressFamily.AF_UNIX) {
+            // unix sockets require 216 bytes for address information
+            if (addressInfoLen < 216 || header.readableBytes() < 216) {
+                throw new HAProxyProtocolException(
+                    "incomplete UNIX socket address information: " +
+                            Math.min(addressInfoLen, header.readableBytes()) + " bytes (expected: 216+ bytes)");
+            }
+            int startIdx = header.readerIndex();
+            int addressEnd = header.forEachByte(startIdx, 108, ByteBufProcessor.FIND_NUL);
+            if (addressEnd == -1) {
+                addressLen = 108;
+            } else {
+                addressLen = addressEnd - startIdx;
+            }
+            srcAddress = header.toString(startIdx, addressLen, CharsetUtil.US_ASCII);
+
+            startIdx += 108;
+
+            addressEnd = header.forEachByte(startIdx, 108, ByteBufProcessor.FIND_NUL);
+            if (addressEnd == -1) {
+                addressLen = 108;
+            } else {
+                addressLen = addressEnd - startIdx;
+            }
+            dstAddress = header.toString(startIdx, addressLen, CharsetUtil.US_ASCII);
+        } else {
+            if (addressFamily == AddressFamily.AF_IPv4) {
+                // IPv4 requires 12 bytes for address information
+                if (addressInfoLen < 12 || header.readableBytes() < 12) {
+                    throw new HAProxyProtocolException(
+                        "incomplete IPv4 address information: " +
+                                Math.min(addressInfoLen, header.readableBytes()) + " bytes (expected: 12+ bytes)");
+                }
+                addressLen = 4;
+            } else if (addressFamily == AddressFamily.AF_IPv6) {
+                // IPv6 requires 36 bytes for address information
+                if (addressInfoLen < 36 || header.readableBytes() < 36) {
+                    throw new HAProxyProtocolException(
+                        "incomplete IPv6 address information: " +
+                                Math.min(addressInfoLen, header.readableBytes()) + " bytes (expected: 36+ bytes)");
+                }
+                addressLen = 16;
+            } else {
+                throw new HAProxyProtocolException(
+                    "unable to parse address information (unkown address family: " + addressFamily + ')');
+            }
+
+            // Per spec, the src address begins at the 17th byte
+            srcAddress = ipBytestoString(header, addressLen);
+            dstAddress = ipBytestoString(header, addressLen);
+            srcPort = header.readUnsignedShort();
+            dstPort = header.readUnsignedShort();
+        }
+
+        return new HAProxyMessage(ver, cmd, protAndFam, srcAddress, dstAddress, srcPort, dstPort);
+    }
+
+    /**
+     * Decodes a version 1, human-readable proxy protocol header.
+     *
+     * @param header                     a version 1 proxy protocol header
+     * @return                           {@link HAProxyMessage} instance
+     * @throws HAProxyProtocolException  if any portion of the header is invalid
+     */
+    static HAProxyMessage decodeHeader(String header) {
+        if (header == null) {
+            throw new HAProxyProtocolException("header");
+        }
+
+        String[] parts = StringUtil.split(header, ' ');
+        int numParts = parts.length;
+
+        if (numParts < 2) {
+            throw new HAProxyProtocolException(
+                    "invalid header: " + header + " (expected: 'PROXY' and proxied protocol values)");
+        }
+
+        if (!"PROXY".equals(parts[0])) {
+            throw new HAProxyProtocolException("unknown identifier: " + parts[0]);
+        }
+
+        HAProxyProxiedProtocol protAndFam;
+        try {
+            protAndFam = HAProxyProxiedProtocol.valueOf(parts[1]);
+        } catch (IllegalArgumentException e) {
+            throw new HAProxyProtocolException(e);
+        }
+
+        if (protAndFam != HAProxyProxiedProtocol.TCP4 &&
+                protAndFam != HAProxyProxiedProtocol.TCP6 &&
+                protAndFam != HAProxyProxiedProtocol.UNKNOWN) {
+            throw new HAProxyProtocolException("unsupported v1 proxied protocol: " + parts[1]);
+        }
+
+        if (protAndFam == HAProxyProxiedProtocol.UNKNOWN) {
+            return V1_UNKNOWN_MSG;
+        }
+
+        if (numParts != 6) {
+            throw new HAProxyProtocolException("invalid TCP4/6 header: " + header + " (expected: 6 parts)");
+        }
+
+        return new HAProxyMessage(
+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY,
+                protAndFam, parts[2], parts[3], parts[4], parts[5]);
+    }
+
+    /**
+     * Convert ip address bytes to string representation
+     *
+     * @param header     buffer containing ip address bytes
+     * @param addressLen number of bytes to read (4 bytes for IPv4, 16 bytes for IPv6)
+     * @return           string representation of the ip address
+     */
+    private static String ipBytestoString(ByteBuf header, int addressLen) {
+        StringBuilder sb = new StringBuilder();
+        if (addressLen == 4) {
+            sb.append(header.readByte() & 0xff);
+            sb.append('.');
+            sb.append(header.readByte() & 0xff);
+            sb.append('.');
+            sb.append(header.readByte() & 0xff);
+            sb.append('.');
+            sb.append(header.readByte() & 0xff);
+        } else {
+            sb.append(Integer.toHexString(header.readUnsignedShort()));
+            sb.append(':');
+            sb.append(Integer.toHexString(header.readUnsignedShort()));
+            sb.append(':');
+            sb.append(Integer.toHexString(header.readUnsignedShort()));
+            sb.append(':');
+            sb.append(Integer.toHexString(header.readUnsignedShort()));
+            sb.append(':');
+            sb.append(Integer.toHexString(header.readUnsignedShort()));
+            sb.append(':');
+            sb.append(Integer.toHexString(header.readUnsignedShort()));
+            sb.append(':');
+            sb.append(Integer.toHexString(header.readUnsignedShort()));
+            sb.append(':');
+            sb.append(Integer.toHexString(header.readUnsignedShort()));
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Convert port to integer
+     *
+     * @param value                      the port
+     * @return                           port as an integer
+     * @throws HAProxyProtocolException  if port is not a valid integer
+     */
+    private static int portStringToInt(String value) {
+        int port;
+        try {
+            port = Integer.parseInt(value);
+        } catch (NumberFormatException e) {
+            throw new HAProxyProtocolException("invalid port: " + value, e);
+        }
+
+        if (port <= 0 || port > 65535) {
+            throw new HAProxyProtocolException("invalid port: " + value + " (expected: 1 ~ 65535)");
+        }
+
+        return port;
+    }
+
+    /**
+     * Validate an address (IPv4, IPv6, Unix Socket)
+     *
+     * @param address                    human-readable address
+     * @param addrFamily                 the {@link AddressFamily} to check the address against
+     * @throws HAProxyProtocolException  if the address is invalid
+     */
+    private static void checkAddress(String address, AddressFamily addrFamily) {
+        if (addrFamily == null) {
+            throw new NullPointerException("addrFamily");
+        }
+
+        switch (addrFamily) {
+            case AF_UNSPEC:
+                if (address != null) {
+                    throw new HAProxyProtocolException("unable to validate an AF_UNSPEC address: " + address);
+                }
+                return;
+            case AF_UNIX:
+                return;
+        }
+
+        if (address == null) {
+            throw new NullPointerException("address");
+        }
+
+        switch (addrFamily) {
+            case AF_IPv4:
+                if (!NetUtil.isValidIpV4Address(address)) {
+                    throw new HAProxyProtocolException("invalid IPv4 address: " + address);
+                }
+                break;
+            case AF_IPv6:
+                if (!NetUtil.isValidIpV6Address(address)) {
+                    throw new HAProxyProtocolException("invalid IPv6 address: " + address);
+                }
+                break;
+            default:
+                throw new Error();
+        }
+    }
+
+    /**
+     * Validate a UDP/TCP port
+     *
+     * @param port                       the UDP/TCP port
+     * @throws HAProxyProtocolException  if the port is out of range (0-65535 inclusive)
+     */
+    private static void checkPort(int port) {
+        if (port < 0 || port > 65535) {
+            throw new HAProxyProtocolException("invalid port: " + port + " (expected: 1 ~ 65535)");
+        }
+    }
+
+    /**
+     * Returns the {@link HAProxyProtocolVersion} of this {@link HAProxyMessage}.
+     */
+    public HAProxyProtocolVersion protocolVersion() {
+        return protocolVersion;
+    }
+
+    /**
+     * Returns the {@link HAProxyCommand} of this {@link HAProxyMessage}.
+     */
+    public HAProxyCommand command() {
+        return command;
+    }
+
+    /**
+     * Returns the {@link HAProxyProxiedProtocol} of this {@link HAProxyMessage}.
+     */
+    public HAProxyProxiedProtocol proxiedProtocol() {
+        return proxiedProtocol;
+    }
+
+    /**
+     * Returns the human-readable source address of this {@link HAProxyMessage}.
+     */
+    public String sourceAddress() {
+        return sourceAddress;
+    }
+
+    /**
+     * Returns the human-readable destination address of this {@link HAProxyMessage}.
+     */
+    public String destinationAddress() {
+        return destinationAddress;
+    }
+
+    /**
+     * Returns the UDP/TCP source port of this {@link HAProxyMessage}.
+     */
+    public int sourcePort() {
+        return sourcePort;
+    }
+
+    /**
+     * Returns the UDP/TCP destination port of this {@link HAProxyMessage}.
+     */
+    public int destinationPort() {
+        return destinationPort;
+    }
+}
diff --git a/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoder.java b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoder.java
new file mode 100644
index 000000000000..3487c159ef97
--- /dev/null
+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoder.java
@@ -0,0 +1,360 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.haproxy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.handler.codec.LineBasedFrameDecoder;
+import io.netty.util.CharsetUtil;
+
+import java.util.List;
+
+/**
+ * Decodes an HAProxy proxy protocol header
+ *
+ * @see <a href="http://haproxy.1wt.eu/download/1.5/doc/proxy-protocol.txt">Proxy Protocol Specification</a>
+ */
+public class HAProxyMessageDecoder extends ByteToMessageDecoder {
+    /**
+     * Maximum possible length of a v1 proxy protocol header per spec
+     */
+    private static final int V1_MAX_LENGTH = 108;
+
+    /**
+     * Maximum possible length of a v2 proxy protocol header (fixed 16 bytes + max unsigned short)
+     */
+    private static final int V2_MAX_LENGTH = 16 + 65535;
+
+    /**
+     * Minimum possible length of a fully functioning v2 proxy protocol header (fixed 16 bytes + v2 address info space)
+     */
+    private static final int V2_MIN_LENGTH = 16 + 216;
+
+    /**
+     * Maximum possible length for v2 additional TLV data (max unsigned short - max v2 address info space)
+     */
+    private static final int V2_MAX_TLV = 65535 - 216;
+
+    /**
+     * Version 1 header delimiter is always '\r\n' per spec
+     */
+    private static final int DELIMITER_LENGTH = 2;
+
+    /**
+     * Binary header prefix
+     */
+    private static final byte[] BINARY_PREFIX = {
+            (byte) 0x0D,
+            (byte) 0x0A,
+            (byte) 0x0D,
+            (byte) 0x0A,
+            (byte) 0x00,
+            (byte) 0x0D,
+            (byte) 0x0A,
+            (byte) 0x51,
+            (byte) 0x55,
+            (byte) 0x49,
+            (byte) 0x54,
+            (byte) 0x0A
+    };
+
+    /**
+     * Binary header prefix length
+     */
+    private static final int BINARY_PREFIX_LENGTH = BINARY_PREFIX.length;
+
+    /**
+     * {@code true} if we're discarding input because we're already over maxLength
+     */
+    private boolean discarding;
+
+    /**
+     * Number of discarded bytes
+     */
+    private int discardedBytes;
+
+    /**
+     * {@code true} if we're finished decoding the proxy protocol header
+     */
+    private boolean finished;
+
+    /**
+     * Protocol specification version
+     */
+    private int version = -1;
+
+    /**
+     * The latest v2 spec (2014/05/18) allows for additional data to be sent in the proxy protocol header beyond the
+     * address information block so now we need a configurable max header size
+     */
+    private final int v2MaxHeaderSize;
+
+    /**
+     * Creates a new decoder with no additional data (TLV) restrictions
+     */
+    public HAProxyMessageDecoder() {
+        v2MaxHeaderSize = V2_MAX_LENGTH;
+    }
+
+    /**
+     * Creates a new decoder with restricted additional data (TLV) size
+     * <p>
+     * <b>Note:</b> limiting TLV size only affects processing of v2, binary headers. Also, as allowed by the 1.5 spec
+     * TLV data is currently ignored. For maximum performance it would be best to configure your upstream proxy host to
+     * <b>NOT</b> send TLV data and instantiate with a max TLV size of {@code 0}.
+     * </p>
+     *
+     * @param maxTlvSize maximum number of bytes allowed for additional data (Type-Length-Value vectors) in a v2 header
+     */
+    public HAProxyMessageDecoder(int maxTlvSize) {
+        if (maxTlvSize < 1) {
+            v2MaxHeaderSize = V2_MIN_LENGTH;
+        } else if (maxTlvSize > V2_MAX_TLV) {
+            v2MaxHeaderSize = V2_MAX_LENGTH;
+        } else {
+            int calcMax = maxTlvSize + V2_MIN_LENGTH;
+            if (calcMax > V2_MAX_LENGTH) {
+                v2MaxHeaderSize = V2_MAX_LENGTH;
+            } else {
+                v2MaxHeaderSize = calcMax;
+            }
+        }
+    }
+
+    /**
+     * Returns the proxy protocol specification version in the buffer if the version is found.
+     * Returns -1 if no version was found in the buffer.
+     */
+    private static int findVersion(final ByteBuf buffer) {
+        final int n = buffer.readableBytes();
+        // per spec, the version number is found in the 13th byte
+        if (n < 13) {
+            return -1;
+        }
+
+        int idx = buffer.readerIndex();
+
+        for (int i = 0; i < BINARY_PREFIX_LENGTH; i++) {
+            final byte b = buffer.getByte(idx + i);
+            if (b != BINARY_PREFIX[i]) {
+                return 1;
+            }
+        }
+
+        return buffer.getByte(idx + BINARY_PREFIX_LENGTH);
+    }
+
+    /**
+     * Returns the index in the buffer of the end of header if found.
+     * Returns -1 if no end of header was found in the buffer.
+     */
+    private static int findEndOfHeader(final ByteBuf buffer) {
+        final int n = buffer.readableBytes();
+
+        // per spec, the 15th and 16th bytes contain the address length in bytes
+        if (n < 16) {
+            return -1;
+        }
+
+        int offset = buffer.readerIndex() + 14;
+
+        // the total header length will be a fixed 16 byte sequence + the dynamic address information block
+        int totalHeaderBytes = 16 + buffer.getUnsignedShort(offset);
+
+        // ensure we actually have the full header available
+        if (n >= totalHeaderBytes) {
+            return totalHeaderBytes;
+        } else {
+            return -1;
+        }
+    }
+
+    /**
+     * Returns the index in the buffer of the end of line found.
+     * Returns -1 if no end of line was found in the buffer.
+     */
+    private static int findEndOfLine(final ByteBuf buffer) {
+        final int n = buffer.writerIndex();
+        for (int i = buffer.readerIndex(); i < n; i++) {
+            final byte b = buffer.getByte(i);
+            if (b == '\r' && i < n - 1 && buffer.getByte(i + 1) == '\n') {
+                return i;  // \r\n
+            }
+        }
+        return -1;  // Not found.
+    }
+
+    @Override
+    public boolean isSingleDecode() {
+        // ByteToMessageDecoder uses this method to optionally break out of the decoding loop after each unit of work.
+        // Since we only ever want to decode a single header we always return true to save a bit of work here.
+        return true;
+    }
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+        super.channelRead(ctx, msg);
+        if (finished) {
+            ctx.pipeline().remove(this);
+        }
+    }
+
+    @Override
+    protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        // determine the specification version
+        if (version == -1) {
+            if ((version = findVersion(in)) == -1) {
+                return;
+            }
+        }
+
+        ByteBuf decoded;
+
+        if (version == 1) {
+            decoded = decodeLine(ctx, in);
+        } else {
+            decoded = decodeStruct(ctx, in);
+        }
+
+        if (decoded != null) {
+            finished = true;
+            try {
+                if (version == 1) {
+                    out.add(HAProxyMessage.decodeHeader(decoded.toString(CharsetUtil.US_ASCII)));
+                } else {
+                    out.add(HAProxyMessage.decodeHeader(decoded));
+                }
+            } catch (HAProxyProtocolException e) {
+                fail(ctx, null, e);
+            }
+        }
+    }
+
+    /**
+     * Create a frame out of the {@link ByteBuf} and return it.
+     * Based on code from {@link LineBasedFrameDecoder#decode(ChannelHandlerContext, ByteBuf)}.
+     *
+     * @param ctx     the {@link ChannelHandlerContext} which this {@link HAProxyMessageDecoder} belongs to
+     * @param buffer  the {@link ByteBuf} from which to read data
+     * @return frame  the {@link ByteBuf} which represent the frame or {@code null} if no frame could
+     *                be created
+     */
+    private ByteBuf decodeStruct(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {
+        final int eoh = findEndOfHeader(buffer);
+        if (!discarding) {
+            if (eoh >= 0) {
+                final int length = eoh - buffer.readerIndex();
+                if (length > v2MaxHeaderSize) {
+                    buffer.readerIndex(eoh);
+                    failOverLimit(ctx, length);
+                    return null;
+                }
+                return buffer.readSlice(length);
+            } else {
+                final int length = buffer.readableBytes();
+                if (length > v2MaxHeaderSize) {
+                    discardedBytes = length;
+                    buffer.skipBytes(length);
+                    discarding = true;
+                    failOverLimit(ctx, "over " + discardedBytes);
+                }
+                return null;
+            }
+        } else {
+            if (eoh >= 0) {
+                buffer.readerIndex(eoh);
+                discardedBytes = 0;
+                discarding = false;
+            } else {
+                discardedBytes = buffer.readableBytes();
+                buffer.skipBytes(discardedBytes);
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Create a frame out of the {@link ByteBuf} and return it.
+     * Based on code from {@link LineBasedFrameDecoder#decode(ChannelHandlerContext, ByteBuf)}.
+     *
+     * @param ctx     the {@link ChannelHandlerContext} which this {@link HAProxyMessageDecoder} belongs to
+     * @param buffer  the {@link ByteBuf} from which to read data
+     * @return frame  the {@link ByteBuf} which represent the frame or {@code null} if no frame could
+     *                be created
+     */
+    private ByteBuf decodeLine(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {
+        final int eol = findEndOfLine(buffer);
+        if (!discarding) {
+            if (eol >= 0) {
+                final int length = eol - buffer.readerIndex();
+                if (length > V1_MAX_LENGTH) {
+                    buffer.readerIndex(eol + DELIMITER_LENGTH);
+                    failOverLimit(ctx, length);
+                    return null;
+                }
+                ByteBuf frame = buffer.readSlice(length);
+                buffer.skipBytes(DELIMITER_LENGTH);
+                return frame;
+            } else {
+                final int length = buffer.readableBytes();
+                if (length > V1_MAX_LENGTH) {
+                    discardedBytes = length;
+                    buffer.skipBytes(length);
+                    discarding = true;
+                    failOverLimit(ctx, "over " + discardedBytes);
+                }
+                return null;
+            }
+        } else {
+            if (eol >= 0) {
+                final int delimLength = buffer.getByte(eol) == '\r' ? 2 : 1;
+                buffer.readerIndex(eol + delimLength);
+                discardedBytes = 0;
+                discarding = false;
+            } else {
+                discardedBytes = buffer.readableBytes();
+                buffer.skipBytes(discardedBytes);
+            }
+            return null;
+        }
+    }
+
+    private void failOverLimit(final ChannelHandlerContext ctx, int length) {
+        failOverLimit(ctx, String.valueOf(length));
+    }
+
+    private void failOverLimit(final ChannelHandlerContext ctx, String length) {
+        int maxLength = version == 1 ? V1_MAX_LENGTH : v2MaxHeaderSize;
+        fail(ctx, "header length (" + length + ") exceeds the allowed maximum (" + maxLength + ')', null);
+    }
+
+    private void fail(final ChannelHandlerContext ctx, String errMsg, Throwable t) {
+        finished = true;
+        ctx.close(); // drop connection immediately per spec
+        HAProxyProtocolException ppex;
+        if (errMsg != null && t != null) {
+            ppex = new HAProxyProtocolException(errMsg, t);
+        } else if (errMsg != null) {
+            ppex = new HAProxyProtocolException(errMsg);
+        } else if (t != null) {
+            ppex = new HAProxyProtocolException(t);
+        } else {
+            ppex = new HAProxyProtocolException();
+        }
+        throw ppex;
+    }
+}
diff --git a/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProtocolException.java b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProtocolException.java
new file mode 100644
index 000000000000..20748370b172
--- /dev/null
+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProtocolException.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.haproxy;
+
+import io.netty.handler.codec.DecoderException;
+
+/**
+ * A {@link DecoderException} which is thrown when an invalid HAProxy proxy protocol header is encountered
+ */
+public class HAProxyProtocolException extends DecoderException {
+
+    private static final long serialVersionUID = 713710864325167351L;
+
+    /**
+     * Creates a new instance
+     */
+    public HAProxyProtocolException() { }
+
+    /**
+     * Creates a new instance
+     */
+    public HAProxyProtocolException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    /**
+     * Creates a new instance
+     */
+    public HAProxyProtocolException(String message) {
+        super(message);
+    }
+
+    /**
+     * Creates a new instance
+     */
+    public HAProxyProtocolException(Throwable cause) {
+        super(cause);
+    }
+}
diff --git a/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProtocolVersion.java b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProtocolVersion.java
new file mode 100644
index 000000000000..d3cfc604c30c
--- /dev/null
+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProtocolVersion.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.haproxy;
+
+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;
+
+/**
+ * The HAProxy proxy protocol specification version.
+ */
+public enum HAProxyProtocolVersion {
+    /**
+     * The ONE proxy protocol version represents a version 1 (human-readable) header.
+     */
+    V1(VERSION_ONE_BYTE),
+    /**
+     * The TWO proxy protocol version represents a version 2 (binary) header.
+     */
+    V2(VERSION_TWO_BYTE);
+
+    /**
+     * The highest 4 bits of the protocol version and command byte contain the version
+     */
+    private static final byte VERSION_MASK = (byte) 0xf0;
+
+    private final byte byteValue;
+
+    /**
+     * Creates a new instance
+     */
+    HAProxyProtocolVersion(byte byteValue) {
+        this.byteValue = byteValue;
+    }
+
+    /**
+     * Returns the {@link HAProxyProtocolVersion} represented by the higest 4 bits of the specified byte.
+     *
+     * @param verCmdByte protocol version and command byte
+     */
+    public static HAProxyProtocolVersion valueOf(byte verCmdByte) {
+        int version = verCmdByte & VERSION_MASK;
+        switch ((byte) version) {
+            case VERSION_TWO_BYTE:
+                return V2;
+            case VERSION_ONE_BYTE:
+                return V1;
+            default:
+                throw new IllegalArgumentException("unknown version: " + version);
+        }
+    }
+
+    /**
+     * Returns the byte value of this version.
+     */
+    public byte byteValue() {
+        return byteValue;
+    }
+}
diff --git a/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProxiedProtocol.java b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProxiedProtocol.java
new file mode 100644
index 000000000000..a299e4795816
--- /dev/null
+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyProxiedProtocol.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.haproxy;
+
+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;
+
+/**
+ * A protocol proxied by HAProxy which is represented by its transport protocol and address family.
+ */
+public enum HAProxyProxiedProtocol {
+    /**
+     * The UNKNOWN represents a connection which was forwarded for an unknown protocol and an unknown address family.
+     */
+    UNKNOWN(TPAF_UNKNOWN_BYTE, AddressFamily.AF_UNSPEC, TransportProtocol.UNSPEC),
+    /**
+     * The TCP4 represents a connection which was forwarded for an IPv4 client over TCP.
+     */
+    TCP4(TPAF_TCP4_BYTE, AddressFamily.AF_IPv4, TransportProtocol.STREAM),
+    /**
+     * The TCP6 represents a connection which was forwarded for an IPv6 client over TCP.
+     */
+    TCP6(TPAF_TCP6_BYTE, AddressFamily.AF_IPv6, TransportProtocol.STREAM),
+    /**
+     * The UDP4 represents a connection which was forwarded for an IPv4 client over UDP.
+     */
+    UDP4(TPAF_UDP4_BYTE, AddressFamily.AF_IPv4, TransportProtocol.DGRAM),
+    /**
+     * The UDP6 represents a connection which was forwarded for an IPv6 client over UDP.
+     */
+    UDP6(TPAF_UDP6_BYTE, AddressFamily.AF_IPv6, TransportProtocol.DGRAM),
+    /**
+     * The UNIX_STREAM represents a connection which was forwarded for a UNIX stream socket.
+     */
+    UNIX_STREAM(TPAF_UNIX_STREAM_BYTE, AddressFamily.AF_UNIX, TransportProtocol.STREAM),
+    /**
+     * The UNIX_DGRAM represents a connection which was forwarded for a UNIX datagram socket.
+     */
+    UNIX_DGRAM(TPAF_UNIX_DGRAM_BYTE, AddressFamily.AF_UNIX, TransportProtocol.DGRAM);
+
+    private final byte byteValue;
+    private final AddressFamily addressFamily;
+    private final TransportProtocol transportProtocol;
+
+    /**
+     * Creates a new instance.
+     */
+    HAProxyProxiedProtocol(
+            byte byteValue,
+            AddressFamily addressFamily,
+            TransportProtocol transportProtocol) {
+
+        this.byteValue = byteValue;
+        this.addressFamily = addressFamily;
+        this.transportProtocol = transportProtocol;
+    }
+
+    /**
+     * Returns the {@link HAProxyProxiedProtocol} represented by the specified byte.
+     *
+     * @param tpafByte transport protocol and address family byte
+     */
+    public static HAProxyProxiedProtocol valueOf(byte tpafByte) {
+        switch (tpafByte) {
+            case TPAF_TCP4_BYTE:
+                return TCP4;
+            case TPAF_TCP6_BYTE:
+                return TCP6;
+            case TPAF_UNKNOWN_BYTE:
+                return UNKNOWN;
+            case TPAF_UDP4_BYTE:
+                return UDP4;
+            case TPAF_UDP6_BYTE:
+                return UDP6;
+            case TPAF_UNIX_STREAM_BYTE:
+                return UNIX_STREAM;
+            case TPAF_UNIX_DGRAM_BYTE:
+                return UNIX_DGRAM;
+            default:
+                throw new IllegalArgumentException(
+                        "unknown transport protocol + address family: " + (tpafByte & 0xFF));
+        }
+    }
+
+    /**
+     * Returns the byte value of this protocol and address family.
+     */
+    public byte byteValue() {
+        return byteValue;
+    }
+
+    /**
+     * Returns the {@link AddressFamily} of this protocol and address family.
+     */
+    public AddressFamily addressFamily() {
+        return addressFamily;
+    }
+
+    /**
+     * Returns the {@link TransportProtocol} of this protocol and address family.
+     */
+    public TransportProtocol transportProtocol() {
+        return transportProtocol;
+    }
+
+    /**
+     * The address family of an HAProxy proxy protocol header.
+     */
+    public enum AddressFamily {
+        /**
+         * The UNSPECIFIED address family represents a connection which was forwarded for an unkown protocol.
+         */
+        AF_UNSPEC(AF_UNSPEC_BYTE),
+        /**
+         * The IPV4 address family represents a connection which was forwarded for an IPV4 client.
+         */
+        AF_IPv4(AF_IPV4_BYTE),
+        /**
+         * The IPV6 address family represents a connection which was forwarded for an IPV6 client.
+         */
+        AF_IPv6(AF_IPV6_BYTE),
+        /**
+         * The UNIX address family represents a connection which was forwarded for a unix socket.
+         */
+        AF_UNIX(AF_UNIX_BYTE);
+
+        /**
+         * The highest 4 bits of the transport protocol and address family byte contain the address family
+         */
+        private static final byte FAMILY_MASK = (byte) 0xf0;
+
+        private final byte byteValue;
+
+        /**
+         * Creates a new instance
+         */
+        AddressFamily(byte byteValue) {
+            this.byteValue = byteValue;
+        }
+
+        /**
+         * Returns the {@link AddressFamily} represented by the highest 4 bits of the specified byte.
+         *
+         * @param tpafByte transport protocol and address family byte
+         */
+        public static AddressFamily valueOf(byte tpafByte) {
+            int addressFamily = tpafByte & FAMILY_MASK;
+            switch((byte) addressFamily) {
+                case AF_IPV4_BYTE:
+                    return AF_IPv4;
+                case AF_IPV6_BYTE:
+                    return AF_IPv6;
+                case AF_UNSPEC_BYTE:
+                    return AF_UNSPEC;
+                case AF_UNIX_BYTE:
+                    return AF_UNIX;
+                default:
+                    throw new IllegalArgumentException("unknown address family: " + addressFamily);
+            }
+        }
+
+        /**
+         * Returns the byte value of this address family.
+         */
+        public byte byteValue() {
+            return byteValue;
+        }
+    }
+
+    /**
+     * The transport protocol of an HAProxy proxy protocol header
+     */
+    public enum TransportProtocol {
+        /**
+         * The UNSPEC transport protocol represents a connection which was forwarded for an unkown protocol.
+         */
+        UNSPEC(TRANSPORT_UNSPEC_BYTE),
+        /**
+         * The STREAM transport protocol represents a connection which was forwarded for a TCP connection.
+         */
+        STREAM(TRANSPORT_STREAM_BYTE),
+        /**
+         * The DGRAM transport protocol represents a connection which was forwarded for a UDP connection.
+         */
+        DGRAM(TRANSPORT_DGRAM_BYTE);
+
+        /**
+         * The transport protocol is specified in the lowest 4 bits of the transport protocol and address family byte
+         */
+        private static final byte TRANSPORT_MASK = 0x0f;
+
+        private final byte transportByte;
+
+        /**
+         * Creates a new instance.
+         */
+        TransportProtocol(byte transportByte) {
+            this.transportByte = transportByte;
+        }
+
+        /**
+         * Returns the {@link TransportProtocol} represented by the lowest 4 bits of the specified byte.
+         *
+         * @param tpafByte transport protocol and address family byte
+         */
+        public static TransportProtocol valueOf(byte tpafByte) {
+            int transportProtocol = tpafByte & TRANSPORT_MASK;
+            switch ((byte) transportProtocol) {
+                case TRANSPORT_STREAM_BYTE:
+                    return STREAM;
+                case TRANSPORT_UNSPEC_BYTE:
+                    return UNSPEC;
+                case TRANSPORT_DGRAM_BYTE:
+                    return DGRAM;
+                default:
+                    throw new IllegalArgumentException("unknown transport protocol: " + transportProtocol);
+            }
+        }
+
+        /**
+         * Returns the byte value of this transport protocol.
+         */
+        public byte byteValue() {
+            return transportByte;
+        }
+    }
+}
diff --git a/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/package-info.java b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/package-info.java
new file mode 100644
index 000000000000..6fdd68eed59d
--- /dev/null
+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/package-info.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Decodes an HAProxy proxy protocol header
+ *
+ * @see <a href="http://haproxy.1wt.eu/download/1.5/doc/proxy-protocol.txt">Proxy Protocol Specification</a>
+ */
+package io.netty.handler.codec.haproxy;
diff --git a/codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoderTest.java b/codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoderTest.java
new file mode 100644
index 000000000000..beb7311b2cfd
--- /dev/null
+++ b/codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoderTest.java
@@ -0,0 +1,899 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.haproxy;
+
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;
+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.TransportProtocol;
+import io.netty.util.CharsetUtil;
+import org.junit.Before;
+import org.junit.Test;
+
+import static io.netty.buffer.Unpooled.*;
+import static org.junit.Assert.*;
+
+public class HAProxyMessageDecoderTest {
+
+    private EmbeddedChannel ch;
+
+    @Before
+    public void setUp() {
+        ch = new EmbeddedChannel(new HAProxyMessageDecoder());
+    }
+
+    @Test
+    public void testIPV4Decode() {
+        int startChannels = ch.pipeline().names().size();
+        String header = "PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V1, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.TCP4, msg.proxiedProtocol());
+        assertEquals("192.168.0.1", msg.sourceAddress());
+        assertEquals("192.168.0.11", msg.destinationAddress());
+        assertEquals(56324, msg.sourcePort());
+        assertEquals(443, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testIPV6Decode() {
+        int startChannels = ch.pipeline().names().size();
+        String header = "PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V1, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.TCP6, msg.proxiedProtocol());
+        assertEquals("2001:0db8:85a3:0000:0000:8a2e:0370:7334", msg.sourceAddress());
+        assertEquals("1050:0:0:0:5:600:300c:326b", msg.destinationAddress());
+        assertEquals(56324, msg.sourcePort());
+        assertEquals(443, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUnknownProtocolDecode() {
+        int startChannels = ch.pipeline().names().size();
+        String header = "PROXY UNKNOWN 192.168.0.1 192.168.0.11 56324 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V1, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.UNKNOWN, msg.proxiedProtocol());
+        assertNull(msg.sourceAddress());
+        assertNull(msg.destinationAddress());
+        assertEquals(0, msg.sourcePort());
+        assertEquals(0, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testV1NoUDP() {
+        String header = "PROXY UDP4 192.168.0.1 192.168.0.11 56324 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testInvalidPort() {
+        String header = "PROXY TCP4 192.168.0.1 192.168.0.11 80000 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testInvalidIPV4Address() {
+        String header = "PROXY TCP4 299.168.0.1 192.168.0.11 56324 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testInvalidIPV6Address() {
+        String header = "PROXY TCP6 r001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testInvalidProtocol() {
+        String header = "PROXY TCP7 192.168.0.1 192.168.0.11 56324 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testMissingParams() {
+        String header = "PROXY TCP4 192.168.0.1 192.168.0.11 56324\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testTooManyParams() {
+        String header = "PROXY TCP4 192.168.0.1 192.168.0.11 56324 443 123\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testInvalidCommand() {
+        String header = "PING TCP4 192.168.0.1 192.168.0.11 56324 443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testInvalidEOL() {
+        String header = "PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\nGET / HTTP/1.1\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testHeaderTooLong() {
+        String header = "PROXY TCP4 192.168.0.1 192.168.0.11 56324 " +
+                "00000000000000000000000000000000000000000000000000000000000000000443\r\n";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+    }
+
+    @Test
+    public void testIncompleteHeader() {
+        String header = "PROXY TCP4 192.168.0.1 192.168.0.11 56324";
+        ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testCloseOnInvalid() {
+        ChannelFuture closeFuture = ch.closeFuture();
+        String header = "GET / HTTP/1.1\r\n";
+        try {
+            ch.writeInbound(copiedBuffer(header, CharsetUtil.US_ASCII));
+        } catch (HAProxyProtocolException ppex) {
+            // swallow this exception since we're just testing to be sure the channel was closed
+        }
+        boolean isComplete = closeFuture.awaitUninterruptibly(5000);
+        if (!isComplete || !closeFuture.isDone() || !closeFuture.isSuccess()) {
+            fail("Expected channel close");
+        }
+    }
+
+    @Test
+    public void testTransportProtocolAndAddressFamily() {
+        final byte unkown = HAProxyProxiedProtocol.UNKNOWN.byteValue();
+        final byte tcp4 = HAProxyProxiedProtocol.TCP4.byteValue();
+        final byte tcp6 = HAProxyProxiedProtocol.TCP6.byteValue();
+        final byte udp4 = HAProxyProxiedProtocol.UDP4.byteValue();
+        final byte udp6 = HAProxyProxiedProtocol.UDP6.byteValue();
+        final byte unix_stream = HAProxyProxiedProtocol.UNIX_STREAM.byteValue();
+        final byte unix_dgram = HAProxyProxiedProtocol.UNIX_DGRAM.byteValue();
+
+        assertEquals(TransportProtocol.UNSPEC, TransportProtocol.valueOf(unkown));
+        assertEquals(TransportProtocol.STREAM, TransportProtocol.valueOf(tcp4));
+        assertEquals(TransportProtocol.STREAM, TransportProtocol.valueOf(tcp6));
+        assertEquals(TransportProtocol.STREAM, TransportProtocol.valueOf(unix_stream));
+        assertEquals(TransportProtocol.DGRAM, TransportProtocol.valueOf(udp4));
+        assertEquals(TransportProtocol.DGRAM, TransportProtocol.valueOf(udp6));
+        assertEquals(TransportProtocol.DGRAM, TransportProtocol.valueOf(unix_dgram));
+
+        assertEquals(AddressFamily.AF_UNSPEC, AddressFamily.valueOf(unkown));
+        assertEquals(AddressFamily.AF_IPv4, AddressFamily.valueOf(tcp4));
+        assertEquals(AddressFamily.AF_IPv4, AddressFamily.valueOf(udp4));
+        assertEquals(AddressFamily.AF_IPv6, AddressFamily.valueOf(tcp6));
+        assertEquals(AddressFamily.AF_IPv6, AddressFamily.valueOf(udp6));
+        assertEquals(AddressFamily.AF_UNIX, AddressFamily.valueOf(unix_stream));
+        assertEquals(AddressFamily.AF_UNIX, AddressFamily.valueOf(unix_dgram));
+    }
+
+    @Test
+    public void testV2IPV4Decode() {
+        byte[] header = new byte[28];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x11; // TCP over IPv4
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x0c; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        header[26] = 0x01; // Destination Port
+        header[27] = (byte) 0xbb; // -----
+
+        int startChannels = ch.pipeline().names().size();
+        ch.writeInbound(copiedBuffer(header));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V2, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.TCP4, msg.proxiedProtocol());
+        assertEquals("192.168.0.1", msg.sourceAddress());
+        assertEquals("192.168.0.11", msg.destinationAddress());
+        assertEquals(56324, msg.sourcePort());
+        assertEquals(443, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testV2UDPDecode() {
+        byte[] header = new byte[28];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x12; // UDP over IPv4
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x0c; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        header[26] = 0x01; // Destination Port
+        header[27] = (byte) 0xbb; // -----
+
+        int startChannels = ch.pipeline().names().size();
+        ch.writeInbound(copiedBuffer(header));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V2, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.UDP4, msg.proxiedProtocol());
+        assertEquals("192.168.0.1", msg.sourceAddress());
+        assertEquals("192.168.0.11", msg.destinationAddress());
+        assertEquals(56324, msg.sourcePort());
+        assertEquals(443, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testv2IPV6Decode() {
+        byte[] header = new byte[52];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x21; // TCP over IPv6
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x24; // -----
+
+        header[16] = 0x20; // Source Address
+        header[17] = 0x01; // -----
+        header[18] = 0x0d; // -----
+        header[19] = (byte) 0xb8; // -----
+        header[20] = (byte) 0x85; // -----
+        header[21] = (byte) 0xa3; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x00; // -----
+        header[24] = 0x00; // -----
+        header[25] = 0x00; // -----
+        header[26] = (byte) 0x8a; // -----
+        header[27] = 0x2e; // -----
+        header[28] = 0x03; // -----
+        header[29] = 0x70; // -----
+        header[30] = 0x73; // -----
+        header[31] = 0x34; // -----
+
+        header[32] = 0x10; // Destination Address
+        header[33] = 0x50; // -----
+        header[34] = 0x00; // -----
+        header[35] = 0x00; // -----
+        header[36] = 0x00; // -----
+        header[37] = 0x00; // -----
+        header[38] = 0x00; // -----
+        header[39] = 0x00; // -----
+        header[40] = 0x00; // -----
+        header[41] = 0x05; // -----
+        header[42] = 0x06; // -----
+        header[43] = 0x00; // -----
+        header[44] = 0x30; // -----
+        header[45] = 0x0c; // -----
+        header[46] = 0x32; // -----
+        header[47] = 0x6b; // -----
+
+        header[48] = (byte) 0xdc; // Source Port
+        header[49] = 0x04; // -----
+
+        header[50] = 0x01; // Destination Port
+        header[51] = (byte) 0xbb; // -----
+
+        int startChannels = ch.pipeline().names().size();
+        ch.writeInbound(copiedBuffer(header));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V2, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.TCP6, msg.proxiedProtocol());
+        assertEquals("2001:db8:85a3:0:0:8a2e:370:7334", msg.sourceAddress());
+        assertEquals("1050:0:0:0:5:600:300c:326b", msg.destinationAddress());
+        assertEquals(56324, msg.sourcePort());
+        assertEquals(443, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testv2UnixDecode() {
+        byte[] header = new byte[232];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x31; // UNIX_STREAM
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = (byte) 0xd8; // -----
+
+        header[16] = 0x2f; // Source Address
+        header[17] = 0x76; // -----
+        header[18] = 0x61; // -----
+        header[19] = 0x72; // -----
+        header[20] = 0x2f; // -----
+        header[21] = 0x72; // -----
+        header[22] = 0x75; // -----
+        header[23] = 0x6e; // -----
+        header[24] = 0x2f; // -----
+        header[25] = 0x73; // -----
+        header[26] = 0x72; // -----
+        header[27] = 0x63; // -----
+        header[28] = 0x2e; // -----
+        header[29] = 0x73; // -----
+        header[30] = 0x6f; // -----
+        header[31] = 0x63; // -----
+        header[32] = 0x6b; // -----
+        header[33] = 0x00; // -----
+
+        header[124] = 0x2f; // Destination Address
+        header[125] = 0x76; // -----
+        header[126] = 0x61; // -----
+        header[127] = 0x72; // -----
+        header[128] = 0x2f; // -----
+        header[129] = 0x72; // -----
+        header[130] = 0x75; // -----
+        header[131] = 0x6e; // -----
+        header[132] = 0x2f; // -----
+        header[133] = 0x64; // -----
+        header[134] = 0x65; // -----
+        header[135] = 0x73; // -----
+        header[136] = 0x74; // -----
+        header[137] = 0x2e; // -----
+        header[138] = 0x73; // -----
+        header[139] = 0x6f; // -----
+        header[140] = 0x63; // -----
+        header[141] = 0x6b; // -----
+        header[142] = 0x00; // -----
+
+        int startChannels = ch.pipeline().names().size();
+        ch.writeInbound(copiedBuffer(header));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V2, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.UNIX_STREAM, msg.proxiedProtocol());
+        assertEquals("/var/run/src.sock", msg.sourceAddress());
+        assertEquals("/var/run/dest.sock", msg.destinationAddress());
+        assertEquals(0, msg.sourcePort());
+        assertEquals(0, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testV2LocalProtocolDecode() {
+        byte[] header = new byte[28];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x20; // v2, cmd=LOCAL
+        header[13] = 0x00; // Unspecified transport protocol and address family
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x0c; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        header[26] = 0x01; // Destination Port
+        header[27] = (byte) 0xbb; // -----
+
+        int startChannels = ch.pipeline().names().size();
+        ch.writeInbound(copiedBuffer(header));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V2, msg.protocolVersion());
+        assertEquals(HAProxyCommand.LOCAL, msg.command());
+        assertEquals(HAProxyProxiedProtocol.UNKNOWN, msg.proxiedProtocol());
+        assertNull(msg.sourceAddress());
+        assertNull(msg.destinationAddress());
+        assertEquals(0, msg.sourcePort());
+        assertEquals(0, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testV2UnknownProtocolDecode() {
+        byte[] header = new byte[28];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x00; // Unspecified transport protocol and address family
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x0c; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        header[26] = 0x01; // Destination Port
+        header[27] = (byte) 0xbb; // -----
+
+        int startChannels = ch.pipeline().names().size();
+        ch.writeInbound(copiedBuffer(header));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V2, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.UNKNOWN, msg.proxiedProtocol());
+        assertNull(msg.sourceAddress());
+        assertNull(msg.destinationAddress());
+        assertEquals(0, msg.sourcePort());
+        assertEquals(0, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testV2WithTLV() {
+        ch = new EmbeddedChannel(new HAProxyMessageDecoder(4));
+
+        byte[] header = new byte[236];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x31; // UNIX_STREAM
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = (byte) 0xdc; // -----
+
+        header[16] = 0x2f; // Source Address
+        header[17] = 0x76; // -----
+        header[18] = 0x61; // -----
+        header[19] = 0x72; // -----
+        header[20] = 0x2f; // -----
+        header[21] = 0x72; // -----
+        header[22] = 0x75; // -----
+        header[23] = 0x6e; // -----
+        header[24] = 0x2f; // -----
+        header[25] = 0x73; // -----
+        header[26] = 0x72; // -----
+        header[27] = 0x63; // -----
+        header[28] = 0x2e; // -----
+        header[29] = 0x73; // -----
+        header[30] = 0x6f; // -----
+        header[31] = 0x63; // -----
+        header[32] = 0x6b; // -----
+        header[33] = 0x00; // -----
+
+        header[124] = 0x2f; // Destination Address
+        header[125] = 0x76; // -----
+        header[126] = 0x61; // -----
+        header[127] = 0x72; // -----
+        header[128] = 0x2f; // -----
+        header[129] = 0x72; // -----
+        header[130] = 0x75; // -----
+        header[131] = 0x6e; // -----
+        header[132] = 0x2f; // -----
+        header[133] = 0x64; // -----
+        header[134] = 0x65; // -----
+        header[135] = 0x73; // -----
+        header[136] = 0x74; // -----
+        header[137] = 0x2e; // -----
+        header[138] = 0x73; // -----
+        header[139] = 0x6f; // -----
+        header[140] = 0x63; // -----
+        header[141] = 0x6b; // -----
+        header[142] = 0x00; // -----
+
+        // ---- Additional data (TLV) ---- \\
+
+        header[232] = 0x01; // Type
+        header[233] = 0x00; // Remaining bytes
+        header[234] = 0x01; // -----
+        header[235] = 0x01; // Payload
+
+        int startChannels = ch.pipeline().names().size();
+        ch.writeInbound(copiedBuffer(header));
+        Object msgObj = ch.readInbound();
+        assertEquals(startChannels - 1, ch.pipeline().names().size());
+        assertTrue(msgObj instanceof HAProxyMessage);
+        HAProxyMessage msg = (HAProxyMessage) msgObj;
+        assertEquals(HAProxyProtocolVersion.V2, msg.protocolVersion());
+        assertEquals(HAProxyCommand.PROXY, msg.command());
+        assertEquals(HAProxyProxiedProtocol.UNIX_STREAM, msg.proxiedProtocol());
+        assertEquals("/var/run/src.sock", msg.sourceAddress());
+        assertEquals("/var/run/dest.sock", msg.destinationAddress());
+        assertEquals(0, msg.sourcePort());
+        assertEquals(0, msg.destinationPort());
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testV2InvalidProtocol() {
+        byte[] header = new byte[28];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x41; // Bogus transport protocol
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x0c; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        header[26] = 0x01; // Destination Port
+        header[27] = (byte) 0xbb; // -----
+
+        ch.writeInbound(copiedBuffer(header));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testV2MissingParams() {
+        byte[] header = new byte[26];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x11; // TCP over IPv4
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x0a; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        ch.writeInbound(copiedBuffer(header));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testV2InvalidCommand() {
+        byte[] header = new byte[28];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x22; // v2, Bogus command
+        header[13] = 0x11; // TCP over IPv4
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x0c; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        header[26] = 0x01; // Destination Port
+        header[27] = (byte) 0xbb; // -----
+
+        ch.writeInbound(copiedBuffer(header));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testV2InvalidVersion() {
+        byte[] header = new byte[28];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x31; // Bogus version, cmd=PROXY
+        header[13] = 0x11; // TCP over IPv4
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = 0x0c; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        header[26] = 0x01; // Destination Port
+        header[27] = (byte) 0xbb; // -----
+
+        ch.writeInbound(copiedBuffer(header));
+    }
+
+    @Test(expected = HAProxyProtocolException.class)
+    public void testV2HeaderTooLong() {
+        ch = new EmbeddedChannel(new HAProxyMessageDecoder(0));
+
+        byte[] header = new byte[248];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+        header[13] = 0x11; // TCP over IPv4
+
+        header[14] = 0x00; // Remaining Bytes
+        header[15] = (byte) 0xe8; // -----
+
+        header[16] = (byte) 0xc0; // Source Address
+        header[17] = (byte) 0xa8; // -----
+        header[18] = 0x00; // -----
+        header[19] = 0x01; // -----
+
+        header[20] = (byte) 0xc0; // Destination Address
+        header[21] = (byte) 0xa8; // -----
+        header[22] = 0x00; // -----
+        header[23] = 0x0b; // -----
+
+        header[24] = (byte) 0xdc; // Source Port
+        header[25] = 0x04; // -----
+
+        header[26] = 0x01; // Destination Port
+        header[27] = (byte) 0xbb; // -----
+
+        ch.writeInbound(copiedBuffer(header));
+    }
+
+    @Test
+    public void testV2IncompleteHeader() {
+        byte[] header = new byte[13];
+        header[0]  = 0x0D; // Binary Prefix
+        header[1]  = 0x0A; // -----
+        header[2]  = 0x0D; // -----
+        header[3]  = 0x0A; // -----
+        header[4]  = 0x00; // -----
+        header[5]  = 0x0D; // -----
+        header[6]  = 0x0A; // -----
+        header[7]  = 0x51; // -----
+        header[8]  = 0x55; // -----
+        header[9]  = 0x49; // -----
+        header[10] = 0x54; // -----
+        header[11] = 0x0A; // -----
+
+        header[12] = 0x21; // v2, cmd=PROXY
+
+        ch.writeInbound(copiedBuffer(header));
+        assertNull(ch.readInbound());
+        assertFalse(ch.finish());
+    }
+}
diff --git a/codec-http/pom.xml b/codec-http/pom.xml
index cac7bfd7eaf5..66a1232790a4 100644
--- a/codec-http/pom.xml
+++ b/codec-http/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-codec-http</artifactId>
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
index 03dc1ad48d27..308e890f1a68 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java
@@ -42,7 +42,7 @@ public static String encode(Cookie cookie) {
             throw new NullPointerException("cookie");
         }
 
-        StringBuilder buf = buffer.get();
+        StringBuilder buf = stringBuilder();
         encode(buf, cookie);
         return stripTrailingSeparator(buf);
     }
@@ -52,7 +52,7 @@ public static String encode(Cookie... cookies) {
             throw new NullPointerException("cookies");
         }
 
-        StringBuilder buf = buffer.get();
+        StringBuilder buf = stringBuilder();
         for (Cookie c: cookies) {
             if (c == null) {
                 break;
@@ -68,7 +68,7 @@ public static String encode(Iterable<Cookie> cookies) {
             throw new NullPointerException("cookies");
         }
 
-        StringBuilder buf = buffer.get();
+        StringBuilder buf = stringBuilder();
         for (Cookie c: cookies) {
             if (c == null) {
                 break;
@@ -80,27 +80,27 @@ public static String encode(Iterable<Cookie> cookies) {
     }
 
     private static void encode(StringBuilder buf, Cookie c) {
-        if (c.getVersion() >= 1) {
+        if (c.version() >= 1) {
             add(buf, '$' + CookieHeaderNames.VERSION, 1);
         }
 
-        add(buf, c.getName(), c.getValue());
+        add(buf, c.name(), c.value());
 
-        if (c.getPath() != null) {
-            add(buf, '$' + CookieHeaderNames.PATH, c.getPath());
+        if (c.path() != null) {
+            add(buf, '$' + CookieHeaderNames.PATH, c.path());
         }
 
-        if (c.getDomain() != null) {
-            add(buf, '$' + CookieHeaderNames.DOMAIN, c.getDomain());
+        if (c.domain() != null) {
+            add(buf, '$' + CookieHeaderNames.DOMAIN, c.domain());
         }
 
-        if (c.getVersion() >= 1) {
-            if (!c.getPorts().isEmpty()) {
+        if (c.version() >= 1) {
+            if (!c.ports().isEmpty()) {
                 buf.append('$');
                 buf.append(CookieHeaderNames.PORT);
                 buf.append((char) HttpConstants.EQUALS);
                 buf.append((char) HttpConstants.DOUBLE_QUOTE);
-                for (int port: c.getPorts()) {
+                for (int port: c.ports()) {
                     buf.append(port);
                     buf.append((char) HttpConstants.COMMA);
                 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java
index be9278bd47b0..7259d218eb07 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java
@@ -50,7 +50,17 @@ public LastHttpContent retain() {
     }
 
     @Override
-    public HttpContent duplicate() {
+    public LastHttpContent touch() {
+        return this;
+    }
+
+    @Override
+    public LastHttpContent touch(Object hint) {
+        return this;
+    }
+
+    @Override
+    public LastHttpContent duplicate() {
         return copy();
     }
 
@@ -60,10 +70,15 @@ public ByteBuf content() {
     }
 
     @Override
-    public DecoderResult getDecoderResult() {
+    public DecoderResult decoderResult() {
         return result;
     }
 
+    @Override
+    public DecoderResult getDecoderResult() {
+        return decoderResult();
+    }
+
     @Override
     public void setDecoderResult(DecoderResult result) {
         this.result = result;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java
index c154d2de26da..45e47d6791ed 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java
@@ -23,19 +23,31 @@
  */
 public interface Cookie extends Comparable<Cookie> {
 
+    /**
+     * @deprecated Use {@link #name()} instead.
+     */
+    @Deprecated
+    String getName();
+
     /**
      * Returns the name of this {@link Cookie}.
      *
      * @return The name of this {@link Cookie}
      */
-    String getName();
+    String name();
+
+    /**
+     * @deprecated Use {@link #value()} instead.
+     */
+    @Deprecated
+    String getValue();
 
     /**
      * Returns the value of this {@link Cookie}.
      *
      * @return The value of this {@link Cookie}
      */
-    String getValue();
+    String value();
 
     /**
      * Sets the value of this {@link Cookie}.
@@ -44,12 +56,18 @@ public interface Cookie extends Comparable<Cookie> {
      */
     void setValue(String value);
 
+    /**
+     * @deprecated Use {@link #domain()} instead.
+     */
+    @Deprecated
+    String getDomain();
+
     /**
      * Returns the domain of this {@link Cookie}.
      *
      * @return The domain of this {@link Cookie}
      */
-    String getDomain();
+    String domain();
 
     /**
      * Sets the domain of this {@link Cookie}.
@@ -58,12 +76,18 @@ public interface Cookie extends Comparable<Cookie> {
      */
     void setDomain(String domain);
 
+    /**
+     * @deprecated Use {@link #path()} instead.
+     */
+    @Deprecated
+    String getPath();
+
     /**
      * Returns the path of this {@link Cookie}.
      *
      * @return The {@link Cookie}'s path
      */
-    String getPath();
+    String path();
 
     /**
      * Sets the path of this {@link Cookie}.
@@ -72,12 +96,18 @@ public interface Cookie extends Comparable<Cookie> {
      */
     void setPath(String path);
 
+    /**
+     * @deprecated Use {@link #comment()} instead.
+     */
+    @Deprecated
+    String getComment();
+
     /**
      * Returns the comment of this {@link Cookie}.
      *
      * @return The comment of this {@link Cookie}
      */
-    String getComment();
+    String comment();
 
     /**
      * Sets the comment of this {@link Cookie}.
@@ -86,12 +116,18 @@ public interface Cookie extends Comparable<Cookie> {
      */
     void setComment(String comment);
 
+    /**
+     * @deprecated Use {@link #maxAge()} instead.
+     */
+    @Deprecated
+    long getMaxAge();
+
     /**
      * Returns the maximum age of this {@link Cookie} in seconds or {@link Long#MIN_VALUE} if unspecified
      *
      * @return The maximum age of this {@link Cookie}
      */
-    long getMaxAge();
+    long maxAge();
 
     /**
      * Sets the maximum age of this {@link Cookie} in seconds.
@@ -104,12 +140,18 @@ public interface Cookie extends Comparable<Cookie> {
      */
     void setMaxAge(long maxAge);
 
+    /**
+     * @deprecated Use {@link #version()} instead.
+     */
+    @Deprecated
+    int getVersion();
+
     /**
      * Returns the version of this {@link Cookie}.
      *
      * @return The version of this {@link Cookie}
      */
-    int getVersion();
+    int version();
 
     /**
      * Sets the version of this {@link Cookie}.
@@ -153,12 +195,18 @@ public interface Cookie extends Comparable<Cookie> {
      */
     void setHttpOnly(boolean httpOnly);
 
+    /**
+     * @deprecated Use {@link #commentUrl()} instead.
+     */
+    @Deprecated
+    String getCommentUrl();
+
     /**
      * Returns the comment URL of this {@link Cookie}.
      *
      * @return The comment URL of this {@link Cookie}
      */
-    String getCommentUrl();
+    String commentUrl();
 
     /**
      * Sets the comment URL of this {@link Cookie}.
@@ -184,12 +232,18 @@ public interface Cookie extends Comparable<Cookie> {
      */
     void setDiscard(boolean discard);
 
+    /**
+     * @deprecated Use {@link #ports()} instead.
+     */
+    @Deprecated
+    Set<Integer> getPorts();
+
     /**
      * Returns the ports that this {@link Cookie} can be accessed on.
      *
      * @return The {@link Set} of ports that this {@link Cookie} can use
      */
-    Set<Integer> getPorts();
+    Set<Integer> ports();
 
     /**
      * Sets the ports that this {@link Cookie} can be accessed on.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java
index 1fba709e38e7..bb45518db2b2 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java
@@ -16,21 +16,13 @@
 package io.netty.handler.codec.http;
 
 
-final class CookieEncoderUtil {
+import io.netty.util.internal.InternalThreadLocalMap;
 
-    static final ThreadLocal<StringBuilder> buffer = new ThreadLocal<StringBuilder>() {
-        @Override
-        public StringBuilder get() {
-            StringBuilder buf = super.get();
-            buf.setLength(0);
-            return buf;
-        }
+final class CookieEncoderUtil {
 
-        @Override
-        protected StringBuilder initialValue() {
-            return new StringBuilder(512);
-        }
-    };
+    static StringBuilder stringBuilder() {
+        return InternalThreadLocalMap.get().stringBuilder();
+    }
 
     static String stripTrailingSeparator(StringBuilder buf) {
         if (buf.length() > 0) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java
index 7e6512196cba..66b421c60784 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java
@@ -78,12 +78,24 @@ public DefaultCookie(String name, String value) {
     }
 
     @Override
+    @Deprecated
     public String getName() {
+        return name();
+    }
+
+    @Override
+    public String name() {
         return name;
     }
 
     @Override
+    @Deprecated
     public String getValue() {
+        return value();
+    }
+
+    @Override
+    public String value() {
         return value;
     }
 
@@ -96,7 +108,13 @@ public void setValue(String value) {
     }
 
     @Override
+    @Deprecated
     public String getDomain() {
+        return domain();
+    }
+
+    @Override
+    public String domain() {
         return domain;
     }
 
@@ -106,7 +124,13 @@ public void setDomain(String domain) {
     }
 
     @Override
+    @Deprecated
     public String getPath() {
+        return path();
+    }
+
+    @Override
+    public String path() {
         return path;
     }
 
@@ -116,7 +140,13 @@ public void setPath(String path) {
     }
 
     @Override
+    @Deprecated
     public String getComment() {
+        return comment();
+    }
+
+    @Override
+    public String comment() {
         return comment;
     }
 
@@ -126,7 +156,13 @@ public void setComment(String comment) {
     }
 
     @Override
+    @Deprecated
     public String getCommentUrl() {
+        return commentUrl();
+    }
+
+    @Override
+    public String commentUrl() {
         return commentUrl;
     }
 
@@ -146,7 +182,13 @@ public void setDiscard(boolean discard) {
     }
 
     @Override
+    @Deprecated
     public Set<Integer> getPorts() {
+        return ports();
+    }
+
+    @Override
+    public Set<Integer> ports() {
         if (unmodifiablePorts == null) {
             unmodifiablePorts = Collections.unmodifiableSet(ports);
         }
@@ -193,7 +235,13 @@ public void setPorts(Iterable<Integer> ports) {
     }
 
     @Override
+    @Deprecated
     public long getMaxAge() {
+        return maxAge();
+    }
+
+    @Override
+    public long maxAge() {
         return maxAge;
     }
 
@@ -203,7 +251,13 @@ public void setMaxAge(long maxAge) {
     }
 
     @Override
+    @Deprecated
     public int getVersion() {
+        return version();
+    }
+
+    @Override
+    public int version() {
         return version;
     }
 
@@ -234,7 +288,7 @@ public void setHttpOnly(boolean httpOnly) {
 
     @Override
     public int hashCode() {
-        return getName().hashCode();
+        return name().hashCode();
     }
 
     @Override
@@ -244,28 +298,28 @@ public boolean equals(Object o) {
         }
 
         Cookie that = (Cookie) o;
-        if (!getName().equalsIgnoreCase(that.getName())) {
+        if (!name().equalsIgnoreCase(that.name())) {
             return false;
         }
 
-        if (getPath() == null) {
-            if (that.getPath() != null) {
+        if (path() == null) {
+            if (that.path() != null) {
                 return false;
             }
-        } else if (that.getPath() == null) {
+        } else if (that.path() == null) {
             return false;
-        } else if (!getPath().equals(that.getPath())) {
+        } else if (!path().equals(that.path())) {
             return false;
         }
 
-        if (getDomain() == null) {
-            if (that.getDomain() != null) {
+        if (domain() == null) {
+            if (that.domain() != null) {
                 return false;
             }
-        } else if (that.getDomain() == null) {
+        } else if (that.domain() == null) {
             return false;
         } else {
-            return getDomain().equalsIgnoreCase(that.getDomain());
+            return domain().equalsIgnoreCase(that.domain());
         }
 
         return true;
@@ -274,32 +328,32 @@ public boolean equals(Object o) {
     @Override
     public int compareTo(Cookie c) {
         int v;
-        v = getName().compareToIgnoreCase(c.getName());
+        v = name().compareToIgnoreCase(c.name());
         if (v != 0) {
             return v;
         }
 
-        if (getPath() == null) {
-            if (c.getPath() != null) {
+        if (path() == null) {
+            if (c.path() != null) {
                 return -1;
             }
-        } else if (c.getPath() == null) {
+        } else if (c.path() == null) {
             return 1;
         } else {
-            v = getPath().compareTo(c.getPath());
+            v = path().compareTo(c.path());
             if (v != 0) {
                 return v;
             }
         }
 
-        if (getDomain() == null) {
-            if (c.getDomain() != null) {
+        if (domain() == null) {
+            if (c.domain() != null) {
                 return -1;
             }
-        } else if (c.getDomain() == null) {
+        } else if (c.domain() == null) {
             return 1;
         } else {
-            v = getDomain().compareToIgnoreCase(c.getDomain());
+            v = domain().compareToIgnoreCase(c.domain());
             return v;
         }
 
@@ -309,24 +363,24 @@ public int compareTo(Cookie c) {
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
-        buf.append(getName());
+        buf.append(name());
         buf.append('=');
-        buf.append(getValue());
-        if (getDomain() != null) {
+        buf.append(value());
+        if (domain() != null) {
             buf.append(", domain=");
-            buf.append(getDomain());
+            buf.append(domain());
         }
-        if (getPath() != null) {
+        if (path() != null) {
             buf.append(", path=");
-            buf.append(getPath());
+            buf.append(path());
         }
-        if (getComment() != null) {
+        if (comment() != null) {
             buf.append(", comment=");
-            buf.append(getComment());
+            buf.append(comment());
         }
-        if (getMaxAge() >= 0) {
+        if (maxAge() >= 0) {
             buf.append(", maxAge=");
-            buf.append(getMaxAge());
+            buf.append(maxAge());
             buf.append('s');
         }
         if (isSecure()) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
index 8ea1983ef330..3087b0c724b7 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
@@ -72,6 +72,18 @@ public FullHttpRequest retain(int increment) {
         return this;
     }
 
+    @Override
+    public FullHttpRequest touch() {
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public FullHttpRequest touch(Object hint) {
+        content.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         return content.release();
@@ -103,7 +115,7 @@ public FullHttpRequest setUri(String uri) {
     @Override
     public FullHttpRequest copy() {
         DefaultFullHttpRequest copy = new DefaultFullHttpRequest(
-                getProtocolVersion(), getMethod(), getUri(), content().copy(), validateHeaders);
+                protocolVersion(), method(), uri(), content().copy(), validateHeaders);
         copy.headers().set(headers());
         copy.trailingHeaders().set(trailingHeaders());
         return copy;
@@ -112,7 +124,7 @@ public FullHttpRequest copy() {
     @Override
     public FullHttpRequest duplicate() {
         DefaultFullHttpRequest duplicate = new DefaultFullHttpRequest(
-                getProtocolVersion(), getMethod(), getUri(), content().duplicate(), validateHeaders);
+                protocolVersion(), method(), uri(), content().duplicate(), validateHeaders);
         duplicate.headers().set(headers());
         duplicate.trailingHeaders().set(trailingHeaders());
         return duplicate;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
index 77d19e594c42..1c23ea73f32b 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
@@ -74,6 +74,18 @@ public FullHttpResponse retain(int increment) {
         return this;
     }
 
+    @Override
+    public FullHttpResponse touch() {
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public FullHttpResponse touch(Object hint) {
+        content.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         return content.release();
@@ -99,7 +111,7 @@ public FullHttpResponse setStatus(HttpResponseStatus status) {
     @Override
     public FullHttpResponse copy() {
         DefaultFullHttpResponse copy = new DefaultFullHttpResponse(
-                getProtocolVersion(), getStatus(), content().copy(), validateHeaders);
+                protocolVersion(), status(), content().copy(), validateHeaders);
         copy.headers().set(headers());
         copy.trailingHeaders().set(trailingHeaders());
         return copy;
@@ -107,7 +119,7 @@ public FullHttpResponse copy() {
 
     @Override
     public FullHttpResponse duplicate() {
-        DefaultFullHttpResponse duplicate = new DefaultFullHttpResponse(getProtocolVersion(), getStatus(),
+        DefaultFullHttpResponse duplicate = new DefaultFullHttpResponse(protocolVersion(), status(),
                 content().duplicate(), validateHeaders);
         duplicate.headers().set(headers());
         duplicate.trailingHeaders().set(trailingHeaders());
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
index b88a0ff8a3b9..18f6a6b79445 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
@@ -67,6 +67,18 @@ public HttpContent retain(int increment) {
         return this;
     }
 
+    @Override
+    public HttpContent touch() {
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public HttpContent touch(Object hint) {
+        content.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         return content.release();
@@ -80,6 +92,6 @@ public boolean release(int decrement) {
     @Override
     public String toString() {
         return StringUtil.simpleClassName(this) +
-               "(data: " + content() + ", getDecoderResult: " + getDecoderResult() + ')';
+               "(data: " + content() + ", decoderResult: " + decoderResult() + ')';
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
index 0711fb391666..a690180d3e89 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
@@ -16,53 +16,37 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.AsciiString;
+import io.netty.handler.codec.DefaultTextHeaders;
+import io.netty.handler.codec.TextHeaders;
 
-import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
-import java.util.NoSuchElementException;
 import java.util.Set;
 
 public class DefaultHttpHeaders extends HttpHeaders {
 
-    private static final int BUCKET_SIZE = 17;
-
-    private static int index(int hash) {
-        return hash % BUCKET_SIZE;
-    }
-
-    private final HeaderEntry[] entries = new HeaderEntry[BUCKET_SIZE];
-    private final HeaderEntry head = new HeaderEntry();
-    protected final boolean validate;
+    private final TextHeaders headers;
 
     public DefaultHttpHeaders() {
         this(true);
     }
 
     public DefaultHttpHeaders(boolean validate) {
-        this.validate = validate;
-        head.before = head.after = head;
+        headers = validate? new ValidatingTextHeaders() : new NonValidatingTextHeaders();
     }
 
-    void validateHeaderName0(CharSequence headerName) {
-        validateHeaderName(headerName);
+    DefaultHttpHeaders(TextHeaders headers) {
+        this.headers = headers;
     }
 
     @Override
     public HttpHeaders add(HttpHeaders headers) {
         if (headers instanceof DefaultHttpHeaders) {
-            DefaultHttpHeaders defaultHttpHeaders = (DefaultHttpHeaders) headers;
-            HeaderEntry e = defaultHttpHeaders.head.after;
-            while (e != defaultHttpHeaders.head) {
-                add(e.key, e.value);
-                e = e.after;
-            }
+            this.headers.add(((DefaultHttpHeaders) headers).headers);
             return this;
         } else {
             return super.add(headers);
@@ -72,13 +56,7 @@ public HttpHeaders add(HttpHeaders headers) {
     @Override
     public HttpHeaders set(HttpHeaders headers) {
         if (headers instanceof DefaultHttpHeaders) {
-            clear();
-            DefaultHttpHeaders defaultHttpHeaders = (DefaultHttpHeaders) headers;
-            HeaderEntry e = defaultHttpHeaders.head.after;
-            while (e != defaultHttpHeaders.head) {
-                add(e.key, e.value);
-                e = e.after;
-            }
+            this.headers.set(((DefaultHttpHeaders) headers).headers);
             return this;
         } else {
             return super.set(headers);
@@ -86,413 +64,329 @@ public HttpHeaders set(HttpHeaders headers) {
     }
 
     @Override
-    public HttpHeaders add(final String name, final Object value) {
-        return add((CharSequence) name, value);
+    public HttpHeaders add(String name, Object value) {
+        headers.add(name, value);
+        return this;
     }
 
     @Override
-    public HttpHeaders add(final CharSequence name, final Object value) {
-        CharSequence strVal;
-        if (validate) {
-            validateHeaderName0(name);
-            strVal = toCharSequence(value);
-            validateHeaderValue(strVal);
-        } else {
-            strVal = toCharSequence(value);
-        }
-        int h = hash(name);
-        int i = index(h);
-        add0(h, i, name, strVal);
+    public HttpHeaders add(CharSequence name, Object value) {
+        headers.add(name, value);
         return this;
     }
 
     @Override
     public HttpHeaders add(String name, Iterable<?> values) {
-        return add((CharSequence) name, values);
+        headers.add(name, values);
+        return this;
     }
 
     @Override
     public HttpHeaders add(CharSequence name, Iterable<?> values) {
-        if (validate) {
-            validateHeaderName0(name);
-        }
-        int h = hash(name);
-        int i = index(h);
-        for (Object v: values) {
-            CharSequence vstr = toCharSequence(v);
-            if (validate) {
-                validateHeaderValue(vstr);
-            }
-            add0(h, i, name, vstr);
-        }
+        headers.add(name, values);
         return this;
     }
 
-    private void add0(int h, int i, final CharSequence name, final CharSequence value) {
-        // Update the hash table.
-        HeaderEntry e = entries[i];
-        HeaderEntry newEntry;
-        entries[i] = newEntry = new HeaderEntry(h, name, value);
-        newEntry.next = e;
-
-        // Update the linked list.
-        newEntry.addBefore(head);
-    }
-
     @Override
-    public HttpHeaders remove(final String name) {
-        return remove((CharSequence) name);
+    public HttpHeaders remove(String name) {
+        headers.remove(name);
+        return this;
     }
 
     @Override
-    public HttpHeaders remove(final CharSequence name) {
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-        int h = hash(name);
-        int i = index(h);
-        remove0(h, i, name);
+    public HttpHeaders remove(CharSequence name) {
+        headers.remove(name);
         return this;
     }
 
-    private void remove0(int h, int i, CharSequence name) {
-        HeaderEntry e = entries[i];
-        if (e == null) {
-            return;
-        }
-
-        for (;;) {
-            if (e.hash == h && equalsIgnoreCase(name, e.key)) {
-                e.remove();
-                HeaderEntry next = e.next;
-                if (next != null) {
-                    entries[i] = next;
-                    e = next;
-                } else {
-                    entries[i] = null;
-                    return;
-                }
-            } else {
-                break;
-            }
-        }
-
-        for (;;) {
-            HeaderEntry next = e.next;
-            if (next == null) {
-                break;
-            }
-            if (next.hash == h && equalsIgnoreCase(name, next.key)) {
-                e.next = next.next;
-                next.remove();
-            } else {
-                e = next;
-            }
-        }
-    }
-
     @Override
-    public HttpHeaders set(final String name, final Object value) {
-        return set((CharSequence) name, value);
+    public HttpHeaders set(String name, Object value) {
+        headers.set(name, value);
+        return this;
     }
 
     @Override
-    public HttpHeaders set(final CharSequence name, final Object value) {
-        CharSequence strVal;
-        if (validate) {
-            validateHeaderName0(name);
-            strVal = toCharSequence(value);
-            validateHeaderValue(strVal);
-        } else {
-            strVal = toCharSequence(value);
-        }
-        int h = hash(name);
-        int i = index(h);
-        remove0(h, i, name);
-        add0(h, i, name, strVal);
+    public HttpHeaders set(CharSequence name, Object value) {
+        headers.set(name, value);
         return this;
     }
 
     @Override
-    public HttpHeaders set(final String name, final Iterable<?> values) {
-        return set((CharSequence) name, values);
+    public HttpHeaders set(String name, Iterable<?> values) {
+        headers.set(name, values);
+        return this;
     }
 
     @Override
-    public HttpHeaders set(final CharSequence name, final Iterable<?> values) {
-        if (values == null) {
-            throw new NullPointerException("values");
-        }
-        if (validate) {
-            validateHeaderName0(name);
-        }
-
-        int h = hash(name);
-        int i = index(h);
-
-        remove0(h, i, name);
-        for (Object v: values) {
-            if (v == null) {
-                break;
-            }
-            CharSequence strVal = toCharSequence(v);
-            if (validate) {
-                validateHeaderValue(strVal);
-            }
-            add0(h, i, name, strVal);
-        }
-
+    public HttpHeaders set(CharSequence name, Iterable<?> values) {
+        headers.set(name, values);
         return this;
     }
 
     @Override
     public HttpHeaders clear() {
-        Arrays.fill(entries, null);
-        head.before = head.after = head;
+        headers.clear();
         return this;
     }
 
     @Override
-    public String get(final String name) {
-        return get((CharSequence) name);
+    public String get(String name) {
+        return headers.get(name);
     }
 
     @Override
-    public String get(final CharSequence name) {
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-
-        int h = hash(name);
-        int i = index(h);
-        HeaderEntry e = entries[i];
-        CharSequence value = null;
-        // loop until the first header was found
-        while (e != null) {
-            if (e.hash == h && equalsIgnoreCase(name, e.key)) {
-                value = e.value;
-            }
-
-            e = e.next;
-        }
-        if (value == null) {
-            return null;
-        }
-        return value.toString();
+    public String get(CharSequence name) {
+        return headers.get(name);
     }
 
     @Override
-    public List<String> getAll(final String name) {
-        return getAll((CharSequence) name);
+    public List<String> getAll(String name) {
+        return headers.getAll(name);
     }
 
     @Override
-    public List<String> getAll(final CharSequence name) {
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-
-        LinkedList<String> values = new LinkedList<String>();
-
-        int h = hash(name);
-        int i = index(h);
-        HeaderEntry e = entries[i];
-        while (e != null) {
-            if (e.hash == h && equalsIgnoreCase(name, e.key)) {
-                values.addFirst(e.getValue());
-            }
-            e = e.next;
-        }
-        return values;
+    public List<String> getAll(CharSequence name) {
+        return headers.getAll(name);
     }
 
     @Override
     public List<Map.Entry<String, String>> entries() {
-        List<Map.Entry<String, String>> all =
-            new LinkedList<Map.Entry<String, String>>();
-
-        HeaderEntry e = head.after;
-        while (e != head) {
-            all.add(e);
-            e = e.after;
-        }
-        return all;
+        return headers.entries();
     }
 
     @Override
     public Iterator<Map.Entry<String, String>> iterator() {
-        return new HeaderIterator();
+        return headers.iterator();
     }
 
     @Override
     public boolean contains(String name) {
-        return get(name) != null;
+        return headers.contains(name);
     }
 
     @Override
     public boolean contains(CharSequence name) {
-        return get(name) != null;
+        return headers.contains(name);
     }
 
     @Override
     public boolean isEmpty() {
-        return head == head.after;
+        return headers.isEmpty();
     }
 
     @Override
-    public boolean contains(String name, String value, boolean ignoreCaseValue) {
-        return contains((CharSequence) name, (CharSequence) value, ignoreCaseValue);
+    public boolean contains(String name, String value, boolean ignoreCase) {
+        return headers.contains(name, value, ignoreCase);
     }
 
     @Override
-    public boolean contains(CharSequence name, CharSequence value, boolean ignoreCaseValue) {
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-
-        int h = hash(name);
-        int i = index(h);
-        HeaderEntry e = entries[i];
-        while (e != null) {
-            if (e.hash == h && equalsIgnoreCase(name, e.key)) {
-                if (ignoreCaseValue) {
-                    if (equalsIgnoreCase(e.value, value)) {
-                        return true;
-                    }
-                } else {
-                    if (e.value.equals(value)) {
-                        return true;
-                    }
-                }
-            }
-            e = e.next;
-        }
-        return false;
+    public boolean contains(CharSequence name, CharSequence value, boolean ignoreCase) {
+        return headers.contains(name, value, ignoreCase);
     }
 
     @Override
     public Set<String> names() {
-        Set<String> names = new LinkedHashSet<String>();
-        HeaderEntry e = head.after;
-        while (e != head) {
-            names.add(e.getKey());
-            e = e.after;
-        }
-        return names;
+        return headers.names();
     }
 
-    private static CharSequence toCharSequence(Object value) {
-        if (value == null) {
-            return null;
-        }
-        if (value instanceof CharSequence) {
-            return (CharSequence) value;
-        }
-        if (value instanceof Number) {
-            return value.toString();
-        }
-        if (value instanceof Date) {
-            return HttpHeaderDateFormat.get().format((Date) value);
-        }
-        if (value instanceof Calendar) {
-            return HttpHeaderDateFormat.get().format(((Calendar) value).getTime());
-        }
-        return value.toString();
+    void encode(ByteBuf buf) {
+        headers.forEachEntry(new HttpHeadersEncoder(buf));
     }
 
-    void encode(ByteBuf buf) {
-        HeaderEntry e = head.after;
-        while (e != head) {
-            e.encode(buf);
-            e = e.after;
+    static class NonValidatingTextHeaders extends DefaultTextHeaders {
+        @Override
+        protected CharSequence convertValue(Object value) {
+            if (value == null) {
+                throw new NullPointerException("value");
+            }
+
+            CharSequence seq;
+            if (value instanceof CharSequence) {
+                seq = (CharSequence) value;
+            } else if (value instanceof Number) {
+                seq = value.toString();
+            } else if (value instanceof Date) {
+                seq = HttpHeaderDateFormat.get().format((Date) value);
+            } else if (value instanceof Calendar) {
+                seq = HttpHeaderDateFormat.get().format(((Calendar) value).getTime());
+            } else {
+                seq = value.toString();
+            }
+
+            return seq;
         }
     }
 
-    private final class HeaderIterator implements Iterator<Map.Entry<String, String>> {
+    static class ValidatingTextHeaders extends NonValidatingTextHeaders {
+        private static final int HIGHEST_INVALID_NAME_CHAR_MASK = ~63;
+        private static final int HIGHEST_INVALID_VALUE_CHAR_MASK = ~15;
 
-        private HeaderEntry current = head;
+        /**
+         * A look-up table used for checking if a character in a header name is prohibited.
+         */
+        private static final byte[] LOOKUP_TABLE = new byte[~HIGHEST_INVALID_NAME_CHAR_MASK + 1];
 
-        @Override
-        public boolean hasNext() {
-            return current.after != head;
+        static {
+            LOOKUP_TABLE['\t'] = -1;
+            LOOKUP_TABLE['\n'] = -1;
+            LOOKUP_TABLE[0x0b] = -1;
+            LOOKUP_TABLE['\f'] = -1;
+            LOOKUP_TABLE[' '] = -1;
+            LOOKUP_TABLE[','] = -1;
+            LOOKUP_TABLE[':'] = -1;
+            LOOKUP_TABLE[';'] = -1;
+            LOOKUP_TABLE['='] = -1;
         }
 
         @Override
-        public Entry<String, String> next() {
-            current = current.after;
-
-            if (current == head) {
-                throw new NoSuchElementException();
+        protected CharSequence convertName(CharSequence name) {
+            name = super.convertName(name);
+            if (name instanceof AsciiString) {
+                validateName((AsciiString) name);
+            } else {
+                validateName(name);
             }
 
-            return current;
+            return name;
         }
 
-        @Override
-        public void remove() {
-            throw new UnsupportedOperationException();
-        }
-    }
+        private static void validateName(AsciiString name) {
+            // Go through each characters in the name
+            final int start = name.arrayOffset();
+            final int end = start + name.length();
+            final byte[] array = name.array();
+            for (int index = start; index < end; index ++) {
+                byte b = array[index];
 
-    private final class HeaderEntry implements Map.Entry<String, String> {
-        final int hash;
-        final CharSequence key;
-        CharSequence value;
-        HeaderEntry next;
-        HeaderEntry before, after;
-
-        HeaderEntry(int hash, CharSequence key, CharSequence value) {
-            this.hash = hash;
-            this.key = key;
-            this.value = value;
-        }
+                // Check to see if the character is not an ASCII character
+                if (b < 0) {
+                    throw new IllegalArgumentException(
+                            "a header name cannot contain non-ASCII characters: " + name);
+                }
 
-        HeaderEntry() {
-            hash = -1;
-            key = null;
-            value = null;
+                // Check for prohibited characters.
+                validateNameChar(name, b);
+            }
         }
 
-        void remove() {
-            before.after = after;
-            after.before = before;
-        }
+        private static void validateName(CharSequence name) {
+            // Go through each characters in the name
+            for (int index = 0; index < name.length(); index ++) {
+                char character = name.charAt(index);
 
-        void addBefore(HeaderEntry e) {
-            after  = e;
-            before = e.before;
-            before.after = this;
-            after.before = this;
+                // Check to see if the character is not an ASCII character
+                if (character > 127) {
+                    throw new IllegalArgumentException(
+                            "a header name cannot contain non-ASCII characters: " + name);
+                }
+
+                // Check for prohibited characters.
+                validateNameChar(name, character);
+            }
         }
 
-        @Override
-        public String getKey() {
-            return key.toString();
+        private static void validateNameChar(CharSequence name, int character) {
+            if ((character & HIGHEST_INVALID_NAME_CHAR_MASK) == 0 && LOOKUP_TABLE[character] != 0) {
+                throw new IllegalArgumentException(
+                        "a header name cannot contain the following prohibited characters: " +
+                                "=,;: \\t\\r\\n\\v\\f: " + name);
+            }
         }
 
         @Override
-        public String getValue() {
-            return value.toString();
+        protected CharSequence convertValue(Object value) {
+            CharSequence seq = super.convertValue(value);
+            if (value instanceof AsciiString) {
+                validateValue((AsciiString) seq);
+            } else {
+                validateValue(seq);
+            }
+
+            return seq;
         }
 
-        @Override
-        public String setValue(String value) {
-            if (value == null) {
-                throw new NullPointerException("value");
+        private static void validateValue(AsciiString seq) {
+            int state = 0;
+            // Start looping through each of the character
+            final int start = seq.arrayOffset();
+            final int end = start + seq.length();
+            final byte[] array = seq.array();
+            for (int index = start; index < end; index ++) {
+                state = validateValueChar(seq, state, (char) (array[index] & 0xFF));
+            }
+
+            if (state != 0) {
+                throw new IllegalArgumentException(
+                        "a header value must not end with '\\r' or '\\n':" + seq);
             }
-            validateHeaderValue(value);
-            CharSequence oldValue = this.value;
-            this.value = value;
-            return oldValue.toString();
         }
 
-        @Override
-        public String toString() {
-            return key.toString() + '=' + value.toString();
+        private static void validateValue(CharSequence seq) {
+            int state = 0;
+            // Start looping through each of the character
+            for (int index = 0; index < seq.length(); index ++) {
+                state = validateValueChar(seq, state, seq.charAt(index));
+            }
+
+            if (state != 0) {
+                throw new IllegalArgumentException(
+                        "a header value must not end with '\\r' or '\\n':" + seq);
+            }
         }
 
-        void encode(ByteBuf buf) {
-            HttpHeaders.encode(key, value, buf);
+        private static int validateValueChar(CharSequence seq, int state, char character) {
+            /*
+             * State:
+             *
+             * 0: Previous character was neither CR nor LF
+             * 1: The previous character was CR
+             * 2: The previous character was LF
+             */
+            if ((character & HIGHEST_INVALID_VALUE_CHAR_MASK) == 0) {
+                // Check the absolutely prohibited characters.
+                switch (character) {
+                    case 0x0b: // Vertical tab
+                        throw new IllegalArgumentException(
+                                "a header value contains a prohibited character '\\v': " + seq);
+                    case '\f':
+                        throw new IllegalArgumentException(
+                                "a header value contains a prohibited character '\\f': " + seq);
+                }
+            }
+
+            // Check the CRLF (HT | SP) pattern
+            switch (state) {
+                case 0:
+                    switch (character) {
+                        case '\r':
+                            state = 1;
+                            break;
+                        case '\n':
+                            state = 2;
+                            break;
+                    }
+                    break;
+                case 1:
+                    switch (character) {
+                        case '\n':
+                            state = 2;
+                            break;
+                        default:
+                            throw new IllegalArgumentException(
+                                    "only '\\n' is allowed after '\\r': " + seq);
+                    }
+                    break;
+                case 2:
+                    switch (character) {
+                        case '\t': case ' ':
+                            state = 0;
+                            break;
+                        default:
+                            throw new IllegalArgumentException(
+                                    "only ' ' and '\\t' are allowed after '\\n': " + seq);
+                    }
+            }
+            return state;
         }
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java
index b6e08894148d..a699ba4acd90 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java
@@ -34,12 +34,15 @@ protected DefaultHttpMessage(final HttpVersion version) {
         this(version, true);
     }
 
-    protected DefaultHttpMessage(final HttpVersion version, boolean validate) {
+    /**
+     * Creates a new instance.
+     */
+    protected DefaultHttpMessage(final HttpVersion version, boolean validateHeaders) {
         if (version == null) {
             throw new NullPointerException("version");
         }
         this.version = version;
-        headers = new DefaultHttpHeaders(validate);
+        headers = new DefaultHttpHeaders(validateHeaders);
     }
 
     @Override
@@ -48,7 +51,13 @@ public HttpHeaders headers() {
     }
 
     @Override
+    @Deprecated
     public HttpVersion getProtocolVersion() {
+        return protocolVersion();
+    }
+
+    @Override
+    public HttpVersion protocolVersion() {
         return version;
     }
 
@@ -57,7 +66,7 @@ public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(StringUtil.simpleClassName(this));
         buf.append("(version: ");
-        buf.append(getProtocolVersion().text());
+        buf.append(protocolVersion().text());
         buf.append(", keepAlive: ");
         buf.append(HttpHeaders.isKeepAlive(this));
         buf.append(')');
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java
index 11f3c23c5533..e6718620e963 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java
@@ -26,10 +26,16 @@ protected DefaultHttpObject() {
     }
 
     @Override
-    public DecoderResult getDecoderResult() {
+    public DecoderResult decoderResult() {
         return decoderResult;
     }
 
+    @Override
+    @Deprecated
+    public DecoderResult getDecoderResult() {
+        return decoderResult();
+    }
+
     @Override
     public void setDecoderResult(DecoderResult decoderResult) {
         if (decoderResult == null) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java
index 21e9fff377c1..66a14910fded 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java
@@ -42,7 +42,7 @@ public DefaultHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri
      * @param httpVersion       the HTTP version of the request
      * @param method            the HTTP getMethod of the request
      * @param uri               the URI or path of the request
-     * @param validateHeaders   validate the headers when adding them
+     * @param validateHeaders   validate the header names and values when adding them to the {@link HttpHeaders}
      */
     public DefaultHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri, boolean validateHeaders) {
         super(httpVersion, validateHeaders);
@@ -57,12 +57,24 @@ public DefaultHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri
     }
 
     @Override
+    @Deprecated
     public HttpMethod getMethod() {
+        return method();
+    }
+
+    @Override
+    public HttpMethod method() {
         return method;
     }
 
     @Override
+    @Deprecated
     public String getUri() {
+        return uri();
+    }
+
+    @Override
+    public String uri() {
         return uri;
     }
 
@@ -95,14 +107,14 @@ public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(StringUtil.simpleClassName(this));
         buf.append("(decodeResult: ");
-        buf.append(getDecoderResult());
+        buf.append(decoderResult());
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
-        buf.append(getMethod().toString());
+        buf.append(method());
         buf.append(' ');
-        buf.append(getUri());
+        buf.append(uri());
         buf.append(' ');
-        buf.append(getProtocolVersion().text());
+        buf.append(protocolVersion().text());
         buf.append(StringUtil.NEWLINE);
         appendHeaders(buf);
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java
index 057839c0dd27..def3c141897a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java
@@ -39,7 +39,7 @@ public DefaultHttpResponse(HttpVersion version, HttpResponseStatus status) {
      *
      * @param version           the HTTP version of this response
      * @param status            the getStatus of this response
-     * @param validateHeaders   validate the headers when adding them
+     * @param validateHeaders   validate the header names and values when adding them to the {@link HttpHeaders}
      */
     public DefaultHttpResponse(HttpVersion version, HttpResponseStatus status, boolean validateHeaders) {
         super(version, validateHeaders);
@@ -50,7 +50,13 @@ public DefaultHttpResponse(HttpVersion version, HttpResponseStatus status, boole
     }
 
     @Override
+    @Deprecated
     public HttpResponseStatus getStatus() {
+        return status();
+    }
+
+    @Override
+    public HttpResponseStatus status() {
         return status;
     }
 
@@ -74,12 +80,12 @@ public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(StringUtil.simpleClassName(this));
         buf.append("(decodeResult: ");
-        buf.append(getDecoderResult());
+        buf.append(decoderResult());
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
-        buf.append(getProtocolVersion().text());
+        buf.append(protocolVersion().text());
         buf.append(' ');
-        buf.append(getStatus().toString());
+        buf.append(status());
         buf.append(StringUtil.NEWLINE);
         appendHeaders(buf);
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java
index 599c543d6462..8583bdfd1fe3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java
@@ -17,6 +17,9 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.AsciiString;
+import io.netty.handler.codec.http.DefaultHttpHeaders.NonValidatingTextHeaders;
+import io.netty.handler.codec.http.DefaultHttpHeaders.ValidatingTextHeaders;
 import io.netty.util.internal.StringUtil;
 
 import java.util.Map;
@@ -39,7 +42,8 @@ public DefaultLastHttpContent(ByteBuf content) {
 
     public DefaultLastHttpContent(ByteBuf content, boolean validateHeaders) {
         super(content);
-        trailingHeaders = new TrailingHeaders(validateHeaders);
+        trailingHeaders = new DefaultHttpHeaders(
+                validateHeaders? new ValidatingTrailingTextHeaders() : new NonValidatingTextHeaders());
         this.validateHeaders = validateHeaders;
     }
 
@@ -69,6 +73,18 @@ public LastHttpContent retain() {
         return this;
     }
 
+    @Override
+    public LastHttpContent touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public LastHttpContent touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+
     @Override
     public HttpHeaders trailingHeaders() {
         return trailingHeaders;
@@ -94,20 +110,17 @@ private void appendHeaders(StringBuilder buf) {
         }
     }
 
-    private static final class TrailingHeaders extends DefaultHttpHeaders {
-        TrailingHeaders(boolean validate) {
-            super(validate);
-        }
-
+    private static final class ValidatingTrailingTextHeaders extends ValidatingTextHeaders {
         @Override
-        void validateHeaderName0(CharSequence name) {
-            super.validateHeaderName0(name);
-            if (HttpHeaders.equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH, name) ||
-                    HttpHeaders.equalsIgnoreCase(HttpHeaders.Names.TRANSFER_ENCODING, name) ||
-                    HttpHeaders.equalsIgnoreCase(HttpHeaders.Names.TRAILER, name)) {
+        protected CharSequence convertName(CharSequence name) {
+            name = super.convertName(name);
+            if (AsciiString.equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH, name) ||
+                    AsciiString.equalsIgnoreCase(HttpHeaders.Names.TRANSFER_ENCODING, name) ||
+                    AsciiString.equalsIgnoreCase(HttpHeaders.Names.TRAILER, name)) {
                 throw new IllegalArgumentException(
                         "prohibited trailing header: " + name);
             }
+            return name;
         }
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
index 7a46d3274a15..c9a59032d8fb 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
@@ -28,4 +28,13 @@ public interface FullHttpMessage extends HttpMessage, LastHttpContent {
 
     @Override
     FullHttpMessage retain();
+
+    @Override
+    FullHttpMessage touch();
+
+    @Override
+    FullHttpMessage touch(Object hint);
+
+    @Override
+    FullHttpMessage duplicate();
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
index 615bdc88eab7..1de15faaee39 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
@@ -29,6 +29,15 @@ public interface FullHttpRequest extends HttpRequest, FullHttpMessage {
     @Override
     FullHttpRequest retain();
 
+    @Override
+    FullHttpRequest touch();
+
+    @Override
+    FullHttpRequest touch(Object hint);
+
+    @Override
+    FullHttpRequest duplicate();
+
     @Override
     FullHttpRequest setProtocolVersion(HttpVersion version);
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java
index 756916c4546d..f3b7496f7320 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java
@@ -29,6 +29,15 @@ public interface FullHttpResponse extends HttpResponse, FullHttpMessage {
     @Override
     FullHttpResponse retain();
 
+    @Override
+    FullHttpResponse touch();
+
+    @Override
+    FullHttpResponse touch(Object hint);
+
+    @Override
+    FullHttpResponse duplicate();
+
     @Override
     FullHttpResponse setProtocolVersion(HttpVersion version);
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
index e7a7610a9dac..6fa72477667b 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
@@ -17,8 +17,8 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerAppender;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.CombinedChannelDuplexHandler;
 import io.netty.handler.codec.PrematureChannelClosureException;
 
 import java.util.ArrayDeque;
@@ -40,8 +40,7 @@
  *
  * @see HttpServerCodec
  */
-public final class HttpClientCodec
-        extends CombinedChannelDuplexHandler<HttpResponseDecoder, HttpRequestEncoder> {
+public final class HttpClientCodec extends ChannelHandlerAppender {
 
     /** A queue that is used for correlating a request and a response. */
     private final Queue<HttpMethod> queue = new ArrayDeque<HttpMethod>();
@@ -61,14 +60,6 @@ public HttpClientCodec() {
         this(4096, 8192, 8192, false);
     }
 
-    public void setSingleDecode(boolean singleDecode) {
-        inboundHandler().setSingleDecode(singleDecode);
-    }
-
-    public boolean isSingleDecode() {
-        return inboundHandler().isSingleDecode();
-    }
-
     /**
      * Creates a new instance with the specified decoder options.
      */
@@ -90,17 +81,30 @@ public HttpClientCodec(
     public HttpClientCodec(
             int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean failOnMissingResponse,
             boolean validateHeaders) {
-        init(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders), new Encoder());
+        add(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders));
+        add(new Encoder());
         this.failOnMissingResponse = failOnMissingResponse;
     }
 
+    private Decoder decoder() {
+        return handlerAt(0);
+    }
+
+    public void setSingleDecode(boolean singleDecode) {
+        decoder().setSingleDecode(singleDecode);
+    }
+
+    public boolean isSingleDecode() {
+        return decoder().isSingleDecode();
+    }
+
     private final class Encoder extends HttpRequestEncoder {
 
         @Override
         protected void encode(
                 ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
             if (msg instanceof HttpRequest && !done) {
-                queue.offer(((HttpRequest) msg).getMethod());
+                queue.offer(((HttpRequest) msg).method());
             }
 
             super.encode(ctx, msg, out);
@@ -156,7 +160,7 @@ private void decrement(Object msg) {
 
         @Override
         protected boolean isContentAlwaysEmpty(HttpMessage msg) {
-            final int statusCode = ((HttpResponse) msg).getStatus().code();
+            final int statusCode = ((HttpResponse) msg).status().code();
             if (statusCode == 100) {
                 // 100-continue response should be excluded from paired comparison.
                 return true;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
index dddb5b1f76fe..de702742a7c5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
@@ -38,4 +38,10 @@ public interface HttpContent extends HttpObject, ByteBufHolder {
 
     @Override
     HttpContent retain(int increment);
+
+    @Override
+    HttpContent touch();
+
+    @Override
+    HttpContent touch(Object hint);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
index 5fcef790d0e9..87367acd187c 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.util.internal.StringUtil;
@@ -96,7 +97,7 @@ public HttpContentCompressor(int compressionLevel, int windowBits, int memLevel)
     protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {
         String contentEncoding = headers.headers().get(HttpHeaders.Names.CONTENT_ENCODING);
         if (contentEncoding != null &&
-            !HttpHeaders.Values.IDENTITY.equalsIgnoreCase(contentEncoding)) {
+            !AsciiString.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {
             return null;
         }
 
@@ -123,6 +124,7 @@ protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws
                         wrapper, compressionLevel, windowBits, memLevel)));
     }
 
+    @SuppressWarnings("FloatingPointEquality")
     protected ZlibWrapper determineWrapper(String acceptEncoding) {
         float starQ = -1.0f;
         float gzipQ = -1.0f;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
index 789e829b0064..d011722115be 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
@@ -51,7 +51,7 @@ public abstract class HttpContentDecoder extends MessageToMessageDecoder<HttpObj
 
     @Override
     protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {
-        if (msg instanceof HttpResponse && ((HttpResponse) msg).getStatus().code() == 100) {
+        if (msg instanceof HttpResponse && ((HttpResponse) msg).status().code() == 100) {
 
             if (!(msg instanceof LastHttpContent)) {
                 continueResponse = true;
@@ -184,8 +184,8 @@ private void decodeContent(HttpContent c, List<Object> out) {
      * @param contentEncoding the value of the {@code "Content-Encoding"} header
      * @return the expected content encoding of the new content
      */
-    @SuppressWarnings("unused")
-    protected String getTargetContentEncoding(String contentEncoding) throws Exception {
+    protected String getTargetContentEncoding(
+            @SuppressWarnings("UnusedParameters") String contentEncoding) throws Exception {
         return HttpHeaders.Values.IDENTITY;
     }
 
@@ -206,7 +206,7 @@ private void cleanup() {
             // Clean-up the previous encoder if not cleaned up correctly.
             if (decoder.finish()) {
                 for (;;) {
-                    ByteBuf buf = (ByteBuf) decoder.readOutbound();
+                    ByteBuf buf = decoder.readOutbound();
                     if (buf == null) {
                         break;
                     }
@@ -234,7 +234,7 @@ private void finishDecode(List<Object> out) {
 
     private void fetchDecoderOutput(List<Object> out) {
         for (;;) {
-            ByteBuf buf = (ByteBuf) decoder.readInbound();
+            ByteBuf buf = decoder.readInbound();
             if (buf == null) {
                 break;
             }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
index 0b54d4d88ff7..b8b296478662 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
@@ -89,7 +89,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
 
                 final HttpResponse res = (HttpResponse) msg;
 
-                if (res.getStatus().code() == 100) {
+                if (res.status().code() == 100) {
                     if (isFull) {
                         out.add(ReferenceCountUtil.retain(res));
                     } else {
@@ -142,7 +142,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
                 // Output the rewritten response.
                 if (isFull) {
                     // Convert full message into unfull one.
-                    HttpResponse newRes = new DefaultHttpResponse(res.getProtocolVersion(), res.getStatus());
+                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());
                     newRes.headers().set(res.headers());
                     out.add(newRes);
                     // Fall through to encode the content of the full response.
@@ -247,7 +247,7 @@ private void cleanup() {
             // Clean-up the previous encoder if not cleaned up correctly.
             if (encoder.finish()) {
                 for (;;) {
-                    ByteBuf buf = (ByteBuf) encoder.readOutbound();
+                    ByteBuf buf = encoder.readOutbound();
                     if (buf == null) {
                         break;
                     }
@@ -275,7 +275,7 @@ private void finishEncode(List<Object> out) {
 
     private void fetchEncoderOutput(List<Object> out) {
         for (;;) {
-            ByteBuf buf = (ByteBuf) encoder.readOutbound();
+            ByteBuf buf = encoder.readOutbound();
             if (buf == null) {
                 break;
             }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
index b94abd8b622a..5c89e7c5f198 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.http;
 
+import io.netty.util.concurrent.FastThreadLocal;
+
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -37,8 +39,8 @@ final class HttpHeaderDateFormat extends SimpleDateFormat {
     private final SimpleDateFormat format1 = new HttpHeaderDateFormatObsolete1();
     private final SimpleDateFormat format2 = new HttpHeaderDateFormatObsolete2();
 
-    private static final ThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal =
-            new ThreadLocal<HttpHeaderDateFormat>() {
+    private static final FastThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal =
+            new FastThreadLocal<HttpHeaderDateFormat>() {
                 @Override
                 protected HttpHeaderDateFormat initialValue() {
                     return new HttpHeaderDateFormat();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderEntity.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderEntity.java
deleted file mode 100644
index c667782bc9f5..000000000000
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderEntity.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec.http;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.util.CharsetUtil;
-
-final class HttpHeaderEntity implements CharSequence {
-
-    private final String name;
-    private final int hash;
-    private final byte[] bytes;
-
-    public HttpHeaderEntity(String name) {
-        this.name = name;
-        hash = HttpHeaders.hash(name);
-        bytes = name.getBytes(CharsetUtil.US_ASCII);
-    }
-
-    int hash() {
-        return hash;
-    }
-
-    @Override
-    public int length() {
-        return bytes.length;
-    }
-
-    @Override
-    public char charAt(int index) {
-        return (char) bytes[index];
-    }
-
-    @Override
-    public CharSequence subSequence(int start, int end) {
-        return new HttpHeaderEntity(name.substring(start, end));
-    }
-
-    @Override
-    public String toString() {
-        return name;
-    }
-
-    void encode(ByteBuf buf) {
-        buf.writeBytes(bytes);
-    }
-}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
index 94bed3a326c0..5dc131365bea 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.AsciiString;
 
 import java.text.ParseException;
 import java.util.Calendar;
@@ -35,7 +36,7 @@
  */
 public abstract class HttpHeaders implements Iterable<Map.Entry<String, String>> {
 
-    private static final byte[] HEADER_SEPERATOR = { HttpConstants.COLON, HttpConstants.SP };
+    private static final byte[] HEADER_SEPERATOR = { COLON, SP };
     private static final byte[] CRLF = { CR, LF };
     private static final CharSequence CONTENT_LENGTH_ENTITY = newEntity(Names.CONTENT_LENGTH);
     private static final CharSequence CONNECTION_ENTITY = newEntity(Names.CONNECTION);
@@ -566,14 +567,14 @@ private Values() {
      */
     public static boolean isKeepAlive(HttpMessage message) {
         String connection = message.headers().get(CONNECTION_ENTITY);
-        if (connection != null && equalsIgnoreCase(CLOSE_ENTITY, connection)) {
+        if (connection != null && AsciiString.equalsIgnoreCase(CLOSE_ENTITY, connection)) {
             return false;
         }
 
-        if (message.getProtocolVersion().isKeepAliveDefault()) {
-            return !equalsIgnoreCase(CLOSE_ENTITY, connection);
+        if (message.protocolVersion().isKeepAliveDefault()) {
+            return !AsciiString.equalsIgnoreCase(CLOSE_ENTITY, connection);
         } else {
-            return equalsIgnoreCase(KEEP_ALIVE_ENTITY, connection);
+            return AsciiString.equalsIgnoreCase(KEEP_ALIVE_ENTITY, connection);
         }
     }
 
@@ -598,7 +599,7 @@ public static boolean isKeepAlive(HttpMessage message) {
      */
     public static void setKeepAlive(HttpMessage message, boolean keepAlive) {
         HttpHeaders h = message.headers();
-        if (message.getProtocolVersion().isKeepAliveDefault()) {
+        if (message.protocolVersion().isKeepAliveDefault()) {
             if (keepAlive) {
                 h.remove(CONNECTION_ENTITY);
             } else {
@@ -785,7 +786,7 @@ public static int getIntHeader(HttpMessage message, CharSequence name, int defau
 
         try {
             return Integer.parseInt(value);
-        } catch (NumberFormatException e) {
+        } catch (NumberFormatException ignored) {
             return defaultValue;
         }
     }
@@ -882,7 +883,7 @@ public static Date getDateHeader(HttpMessage message, CharSequence name, Date de
 
         try {
             return HttpHeaderDateFormat.get().parse(value);
-        } catch (ParseException e) {
+        } catch (ParseException ignored) {
             return defaultValue;
         }
     }
@@ -985,7 +986,7 @@ public static long getContentLength(HttpMessage message, long defaultValue) {
         if (contentLength != null) {
             try {
                 return Long.parseLong(contentLength);
-            } catch (NumberFormatException e) {
+            } catch (NumberFormatException ignored) {
                 return defaultValue;
             }
         }
@@ -1010,14 +1011,14 @@ private static int getWebSocketContentLength(HttpMessage message) {
         HttpHeaders h = message.headers();
         if (message instanceof HttpRequest) {
             HttpRequest req = (HttpRequest) message;
-            if (HttpMethod.GET.equals(req.getMethod()) &&
+            if (HttpMethod.GET.equals(req.method()) &&
                 h.contains(SEC_WEBSOCKET_KEY1_ENTITY) &&
                 h.contains(SEC_WEBSOCKET_KEY2_ENTITY)) {
                 return 8;
             }
         } else if (message instanceof HttpResponse) {
             HttpResponse res = (HttpResponse) message;
-            if (res.getStatus().code() == 101 &&
+            if (res.status().code() == 101 &&
                 h.contains(SEC_WEBSOCKET_ORIGIN_ENTITY) &&
                 h.contains(SEC_WEBSOCKET_LOCATION_ENTITY)) {
                 return 16;
@@ -1105,7 +1106,7 @@ public static boolean is100ContinueExpected(HttpMessage message) {
         }
 
         // It works only on HTTP/1.1 or later.
-        if (message.getProtocolVersion().compareTo(HttpVersion.HTTP_1_1) < 0) {
+        if (message.protocolVersion().compareTo(HttpVersion.HTTP_1_1) < 0) {
             return false;
         }
 
@@ -1114,7 +1115,7 @@ public static boolean is100ContinueExpected(HttpMessage message) {
         if (value == null) {
             return false;
         }
-        if (equalsIgnoreCase(CONTINUE_ENTITY, value)) {
+        if (AsciiString.equalsIgnoreCase(CONTINUE_ENTITY, value)) {
             return true;
         }
 
@@ -1146,115 +1147,6 @@ public static void set100ContinueExpected(HttpMessage message, boolean set) {
         }
     }
 
-    /**
-     * Validates the name of a header
-     *
-     * @param headerName The header name being validated
-     */
-    static void validateHeaderName(CharSequence headerName) {
-        //Check to see if the name is null
-        if (headerName == null) {
-            throw new NullPointerException("Header names cannot be null");
-        }
-        //Go through each of the characters in the name
-        for (int index = 0; index < headerName.length(); index ++) {
-            //Actually get the character
-            char character = headerName.charAt(index);
-
-            //Check to see if the character is not an ASCII character
-            if (character > 127) {
-                throw new IllegalArgumentException(
-                        "Header name cannot contain non-ASCII characters: " + headerName);
-            }
-
-            //Check for prohibited characters.
-            switch (character) {
-                case '\t': case '\n': case 0x0b: case '\f': case '\r':
-                case ' ':  case ',':  case ':':  case ';':  case '=':
-                    throw new IllegalArgumentException(
-                            "Header name cannot contain the following prohibited characters: " +
-                                    "=,;: \\t\\r\\n\\v\\f: " + headerName);
-            }
-        }
-    }
-
-    /**
-     * Validates the specified header value
-     *
-     * @param headerValue The value being validated
-     */
-    static void validateHeaderValue(CharSequence headerValue) {
-        //Check to see if the value is null
-        if (headerValue == null) {
-            throw new NullPointerException("Header values cannot be null");
-        }
-
-        /*
-         * Set up the state of the validation
-         *
-         * States are as follows:
-         *
-         * 0: Previous character was neither CR nor LF
-         * 1: The previous character was CR
-         * 2: The previous character was LF
-         */
-        int state = 0;
-
-        //Start looping through each of the character
-
-        for (int index = 0; index < headerValue.length(); index ++) {
-            char character = headerValue.charAt(index);
-
-            //Check the absolutely prohibited characters.
-            switch (character) {
-                case 0x0b: // Vertical tab
-                    throw new IllegalArgumentException(
-                            "Header value contains a prohibited character '\\v': " + headerValue);
-                case '\f':
-                    throw new IllegalArgumentException(
-                            "Header value contains a prohibited character '\\f': " + headerValue);
-            }
-
-            // Check the CRLF (HT | SP) pattern
-            switch (state) {
-                case 0:
-                    switch (character) {
-                        case '\r':
-                            state = 1;
-                            break;
-                        case '\n':
-                            state = 2;
-                            break;
-                    }
-                    break;
-                case 1:
-                    switch (character) {
-                        case '\n':
-                            state = 2;
-                            break;
-                        default:
-                            throw new IllegalArgumentException(
-                                    "Only '\\n' is allowed after '\\r': " + headerValue);
-                    }
-                    break;
-                case 2:
-                    switch (character) {
-                        case '\t': case ' ':
-                            state = 0;
-                            break;
-                        default:
-                            throw new IllegalArgumentException(
-                                    "Only ' ' and '\\t' are allowed after '\\n': " + headerValue);
-                    }
-            }
-        }
-
-        if (state != 0) {
-            throw new IllegalArgumentException(
-                    "Header value must not end with '\\r' or '\\n':" + headerValue);
-        }
-    }
-
     /**
      * Checks to see if the transfer encoding in a specified {@link HttpMessage} is chunked
      *
@@ -1273,7 +1165,7 @@ public static void removeTransferEncodingChunked(HttpMessage m) {
         Iterator<String> valuesIt = values.iterator();
         while (valuesIt.hasNext()) {
             String value = valuesIt.next();
-            if (equalsIgnoreCase(value, CHUNKED_ENTITY)) {
+            if (AsciiString.equalsIgnoreCase(value, CHUNKED_ENTITY)) {
                 valuesIt.remove();
             }
         }
@@ -1294,61 +1186,11 @@ public static boolean isContentLengthSet(HttpMessage m) {
     }
 
     /**
-     * Returns {@code true} if both {@link CharSequence}'s are equals when ignore the case.
-     * This only supports US_ASCII.
+     * @deprecated Use {@link AsciiString#equalsIgnoreCase(CharSequence, CharSequence)} instead.
      */
+    @Deprecated
     public static boolean equalsIgnoreCase(CharSequence name1, CharSequence name2) {
-        if (name1 == name2) {
-            return true;
-        }
-
-        if (name1 == null || name2 == null) {
-            return false;
-        }
-
-        int nameLen = name1.length();
-        if (nameLen != name2.length()) {
-            return false;
-        }
-
-        for (int i = nameLen - 1; i >= 0; i --) {
-            char c1 = name1.charAt(i);
-            char c2 = name2.charAt(i);
-            if (c1 != c2) {
-                if (c1 >= 'A' && c1 <= 'Z') {
-                    c1 += 32;
-                }
-                if (c2 >= 'A' && c2 <= 'Z') {
-                    c2 += 32;
-                }
-                if (c1 != c2) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    static int hash(CharSequence name) {
-        if (name instanceof HttpHeaderEntity) {
-            return ((HttpHeaderEntity) name).hash();
-        }
-        int h = 0;
-        for (int i = name.length() - 1; i >= 0; i --) {
-            char c = name.charAt(i);
-            if (c >= 'A' && c <= 'Z') {
-                c += 32;
-            }
-            h = 31 * h + c;
-        }
-
-        if (h > 0) {
-            return h;
-        } else if (h == Integer.MIN_VALUE) {
-            return Integer.MAX_VALUE;
-        } else {
-            return -h;
-        }
+        return AsciiString.equalsIgnoreCase(name1, name2);
     }
 
     static void encode(HttpHeaders headers, ByteBuf buf) {
@@ -1361,16 +1203,18 @@ static void encode(HttpHeaders headers, ByteBuf buf) {
         }
     }
 
-    static void encode(CharSequence key, CharSequence value, ByteBuf buf) {
+    @SuppressWarnings("deprecation")
+    private static void encode(CharSequence key, CharSequence value, ByteBuf buf) {
         encodeAscii(key, buf);
         buf.writeBytes(HEADER_SEPERATOR);
         encodeAscii(value, buf);
         buf.writeBytes(CRLF);
     }
 
+    @Deprecated
     public static void encodeAscii(CharSequence seq, ByteBuf buf) {
-        if (seq instanceof HttpHeaderEntity) {
-            ((HttpHeaderEntity) seq).encode(buf);
+        if (seq instanceof AsciiString) {
+            ((AsciiString) seq).copy(0, buf, seq.length());
         } else {
             encodeAscii0(seq, buf);
         }
@@ -1391,7 +1235,7 @@ public static CharSequence newEntity(String name) {
         if (name == null) {
             throw new NullPointerException("name");
         }
-        return new HttpHeaderEntity(name);
+        return new AsciiString(name);
     }
 
     protected HttpHeaders() { }
@@ -1584,7 +1428,12 @@ public HttpHeaders set(HttpHeaders headers) {
         if (headers == null) {
             throw new NullPointerException("headers");
         }
+
         clear();
+        if (headers.isEmpty()) {
+            return this;
+        }
+
         for (Map.Entry<String, String> e: headers) {
             add(e.getKey(), e.getValue());
         }
@@ -1616,15 +1465,15 @@ public HttpHeaders remove(CharSequence name) {
     /**
      * @see {@link #contains(CharSequence, CharSequence, boolean)}
      */
-    public boolean contains(String name, String value, boolean ignoreCaseValue) {
+    public boolean contains(String name, String value, boolean ignoreCase) {
         List<String> values = getAll(name);
         if (values.isEmpty()) {
             return false;
         }
 
         for (String v: values) {
-            if (ignoreCaseValue) {
-                if (equalsIgnoreCase(v, value)) {
+            if (ignoreCase) {
+                if (AsciiString.equalsIgnoreCase(v, value)) {
                     return true;
                 }
             } else {
@@ -1639,12 +1488,12 @@ public boolean contains(String name, String value, boolean ignoreCaseValue) {
     /**
      * Returns {@code true} if a header with the name and value exists.
      *
-     * @param name              the headername
-     * @param value             the value
-     * @param ignoreCaseValue   {@code true} if case should be ignored
-     * @return contains         {@code true} if it contains it {@code false} otherwise
+     * @param name         the headername
+     * @param value        the value
+     * @param ignoreCase   {@code true} if case should be ignored
+     * @return contains    {@code true} if it contains it {@code false} otherwise
      */
-    public boolean contains(CharSequence name, CharSequence value, boolean ignoreCaseValue) {
-        return contains(name.toString(), value.toString(), ignoreCaseValue);
+    public boolean contains(CharSequence name, CharSequence value, boolean ignoreCase) {
+        return contains(name.toString(), value.toString(), ignoreCase);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeadersEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeadersEncoder.java
new file mode 100644
index 000000000000..fccd251509b8
--- /dev/null
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeadersEncoder.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.http;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.AsciiString;
+import io.netty.handler.codec.TextHeaderProcessor;
+
+final class HttpHeadersEncoder implements TextHeaderProcessor {
+
+    private final ByteBuf buf;
+
+    HttpHeadersEncoder(ByteBuf buf) {
+        this.buf = buf;
+    }
+
+    @Override
+    public boolean process(CharSequence name, CharSequence value) throws Exception {
+        final ByteBuf buf = this.buf;
+        final int nameLen = name.length();
+        final int valueLen = value.length();
+        final int entryLen = nameLen + valueLen + 4;
+        int offset = buf.writerIndex();
+        buf.ensureWritable(entryLen);
+        writeAscii(buf, offset, name, nameLen);
+        offset += nameLen;
+        buf.setByte(offset ++, ':');
+        buf.setByte(offset ++, ' ');
+        writeAscii(buf, offset, value, valueLen);
+        offset += valueLen;
+        buf.setByte(offset ++, '\r');
+        buf.setByte(offset ++, '\n');
+        buf.writerIndex(offset);
+        return true;
+    }
+
+    private static void writeAscii(ByteBuf buf, int offset, CharSequence value, int valueLen) {
+        if (value instanceof AsciiString) {
+            writeAsciiString(buf, offset, (AsciiString) value, valueLen);
+        } else {
+            writeCharSequence(buf, offset, value, valueLen);
+        }
+    }
+
+    private static void writeAsciiString(ByteBuf buf, int offset, AsciiString value, int valueLen) {
+        value.copy(0, buf, offset, valueLen);
+    }
+
+    private static void writeCharSequence(ByteBuf buf, int offset, CharSequence value, int valueLen) {
+        for (int i = 0; i < valueLen; i ++) {
+            buf.setByte(offset ++, c2b(value.charAt(i)));
+        }
+    }
+
+    private static int c2b(char ch) {
+        return ch < 256? (byte) ch : '?';
+    }
+}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java
index 7faabd2f6005..357ad99bca3f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java
@@ -27,12 +27,16 @@
 public interface HttpMessage extends HttpObject {
 
     /**
-     * Returns the protocol version of this {@link HttpMessage}
-     *
-     * @return The protocol version
+     * @deprecated Use {@link #protocolVersion()} instead.
      */
+    @Deprecated
     HttpVersion getProtocolVersion();
 
+    /**
+     * Returns the protocol version of this {@link HttpMessage}
+     */
+    HttpVersion protocolVersion();
+
     /**
      * Set the protocol version of this {@link HttpMessage}
      */
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java
index 6abe639fdb1c..7af32564ad6e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java
@@ -149,8 +149,8 @@ private HttpMethod(String name, boolean bytes) {
         }
 
         for (int i = 0; i < name.length(); i ++) {
-            if (Character.isISOControl(name.charAt(i)) ||
-                Character.isWhitespace(name.charAt(i))) {
+            char c = name.charAt(i);
+            if (Character.isISOControl(c) || Character.isWhitespace(c)) {
                 throw new IllegalArgumentException("invalid character in name");
             }
         }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObject.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObject.java
index f28a785cb802..aaa5a503a399 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObject.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObject.java
@@ -16,16 +16,12 @@
 package io.netty.handler.codec.http;
 
 import io.netty.handler.codec.DecoderResult;
+import io.netty.handler.codec.DecoderResultProvider;
 
-public interface HttpObject {
+public interface HttpObject extends DecoderResultProvider {
     /**
-     * Returns the result of decoding this message.
+     * @deprecated Use {@link #decoderResult()} instead.
      */
+    @Deprecated
     DecoderResult getDecoderResult();
-
-    /**
-     * Updates the result of decoding this message. This method is supposed to be invoked by {@link HttpObjectDecoder}.
-     * Do not call this method unless you know what you are doing.
-     */
-    void setDecoderResult(DecoderResult result);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
index 104a4123c745..64153e24b30e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
@@ -15,26 +15,23 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
-import io.netty.handler.codec.DecoderResult;
-import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.handler.codec.MessageAggregator;
 import io.netty.handler.codec.TooLongFrameException;
-import io.netty.util.ReferenceCountUtil;
-
-import java.util.List;
-
-import static io.netty.handler.codec.http.HttpHeaders.*;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
 
 /**
  * A {@link ChannelHandler} that aggregates an {@link HttpMessage}
- * and its following {@link HttpContent}s into a single {@link HttpMessage} with
- * no following {@link HttpContent}s.  It is useful when you don't want to take
+ * and its following {@link HttpContent}s into a single {@link FullHttpRequest}
+ * or {@link FullHttpResponse} (depending on if it used to handle requests or responses)
+ * with no following {@link HttpContent}s.  It is useful when you don't want to take
  * care of HTTP messages whose transfer encoding is 'chunked'.  Insert this
  * handler after {@link HttpObjectDecoder} in the {@link ChannelPipeline}:
  * <pre>
@@ -46,18 +43,22 @@
  * ...
  * p.addLast("handler", new HttpRequestHandler());
  * </pre>
+ * Be aware that you need to have the {@link HttpResponseEncoder} or {@link HttpRequestEncoder}
+ * before the {@link HttpObjectAggregator} in the {@link ChannelPipeline}.
  */
-public class HttpObjectAggregator extends MessageToMessageDecoder<HttpObject> {
-    public static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024;
-    private static final FullHttpResponse CONTINUE =
-            new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE, Unpooled.EMPTY_BUFFER);
+public class HttpObjectAggregator
+        extends MessageAggregator<HttpObject, HttpMessage, HttpContent, FullHttpMessage> {
 
-    private final int maxContentLength;
-    private FullHttpMessage currentMessage;
-    private boolean tooLongFrameFound;
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(HttpObjectAggregator.class);
 
-    private int maxCumulationBufferComponents = DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS;
-    private ChannelHandlerContext ctx;
+    private static final FullHttpResponse CONTINUE = new DefaultFullHttpResponse(
+            HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE, Unpooled.EMPTY_BUFFER);
+    private static final FullHttpResponse TOO_LARGE = new DefaultFullHttpResponse(
+            HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);
+
+    static {
+        TOO_LARGE.headers().set(HttpHeaders.Names.CONTENT_LENGTH, 0);
+    }
 
     /**
      * Creates a new instance.
@@ -65,186 +66,125 @@ public class HttpObjectAggregator extends MessageToMessageDecoder<HttpObject> {
      * @param maxContentLength
      *        the maximum length of the aggregated content.
      *        If the length of the aggregated content exceeds this value,
-     *        a {@link TooLongFrameException} will be raised.
+     *        {@link #handleOversizedMessage(ChannelHandlerContext, HttpMessage)}
+     *        will be called.
      */
     public HttpObjectAggregator(int maxContentLength) {
-        if (maxContentLength <= 0) {
-            throw new IllegalArgumentException(
-                    "maxContentLength must be a positive integer: " +
-                    maxContentLength);
-        }
-        this.maxContentLength = maxContentLength;
+        super(maxContentLength);
     }
 
-    /**
-     * Returns the maximum number of components in the cumulation buffer.  If the number of
-     * the components in the cumulation buffer exceeds this value, the components of the
-     * cumulation buffer are consolidated into a single component, involving memory copies.
-     * The default value of this property is {@link #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}.
-     */
-    public final int getMaxCumulationBufferComponents() {
-        return maxCumulationBufferComponents;
+    @Override
+    protected boolean isStartMessage(HttpObject msg) throws Exception {
+        return msg instanceof HttpMessage;
     }
 
-    /**
-     * Sets the maximum number of components in the cumulation buffer.  If the number of
-     * the components in the cumulation buffer exceeds this value, the components of the
-     * cumulation buffer are consolidated into a single component, involving memory copies.
-     * The default value of this property is {@link #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}
-     * and its minimum allowed value is {@code 2}.
-     */
-    public final void setMaxCumulationBufferComponents(int maxCumulationBufferComponents) {
-        if (maxCumulationBufferComponents < 2) {
-            throw new IllegalArgumentException(
-                    "maxCumulationBufferComponents: " + maxCumulationBufferComponents +
-                    " (expected: >= 2)");
-        }
-
-        if (ctx == null) {
-            this.maxCumulationBufferComponents = maxCumulationBufferComponents;
-        } else {
-            throw new IllegalStateException(
-                    "decoder properties cannot be changed once the decoder is added to a pipeline.");
-        }
+    @Override
+    protected boolean isContentMessage(HttpObject msg) throws Exception {
+        return msg instanceof HttpContent;
     }
 
     @Override
-    protected void decode(final ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {
-        FullHttpMessage currentMessage = this.currentMessage;
-
-        if (msg instanceof HttpMessage) {
-            tooLongFrameFound = false;
-            assert currentMessage == null;
-
-            HttpMessage m = (HttpMessage) msg;
-
-            // Handle the 'Expect: 100-continue' header if necessary.
-            // TODO: Respond with 413 Request Entity Too Large
-            //   and discard the traffic or close the connection.
-            //       No need to notify the upstream handlers - just log.
-            //       If decoding a response, just throw an exception.
-            if (is100ContinueExpected(m)) {
-                ctx.writeAndFlush(CONTINUE).addListener(new ChannelFutureListener() {
-                    @Override
-                    public void operationComplete(ChannelFuture future) throws Exception {
-                        if (!future.isSuccess()) {
-                            ctx.fireExceptionCaught(future.cause());
-                        }
-                    }
-                });
-            }
-
-            if (!m.getDecoderResult().isSuccess()) {
-                removeTransferEncodingChunked(m);
-                this.currentMessage = null;
-                out.add(ReferenceCountUtil.retain(m));
-                return;
-            }
-            if (msg instanceof HttpRequest) {
-                HttpRequest header = (HttpRequest) msg;
-                this.currentMessage = currentMessage = new DefaultFullHttpRequest(header.getProtocolVersion(),
-                        header.getMethod(), header.getUri(), Unpooled.compositeBuffer(maxCumulationBufferComponents));
-            } else if (msg instanceof HttpResponse) {
-                HttpResponse header = (HttpResponse) msg;
-                this.currentMessage = currentMessage = new DefaultFullHttpResponse(
-                        header.getProtocolVersion(), header.getStatus(),
-                        Unpooled.compositeBuffer(maxCumulationBufferComponents));
-            } else {
-                throw new Error();
-            }
-
-            currentMessage.headers().set(m.headers());
-
-            // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.
-            removeTransferEncodingChunked(currentMessage);
-        } else if (msg instanceof HttpContent) {
-            if (tooLongFrameFound) {
-                if (msg instanceof LastHttpContent) {
-                    this.currentMessage = null;
-                }
-                // already detect the too long frame so just discard the content
-                return;
-            }
-            assert currentMessage != null;
-
-            // Merge the received chunk into the content of the current message.
-            HttpContent chunk = (HttpContent) msg;
-            CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();
-
-            if (content.readableBytes() > maxContentLength - chunk.content().readableBytes()) {
-                tooLongFrameFound = true;
-
-                // release current message to prevent leaks
-                currentMessage.release();
-                this.currentMessage = null;
-
-                throw new TooLongFrameException(
-                        "HTTP content length exceeded " + maxContentLength +
-                        " bytes.");
-            }
-
-            // Append the content of the chunk
-            if (chunk.content().isReadable()) {
-                chunk.retain();
-                content.addComponent(chunk.content());
-                content.writerIndex(content.writerIndex() + chunk.content().readableBytes());
-            }
+    protected boolean isLastContentMessage(HttpContent msg) throws Exception {
+        return msg instanceof LastHttpContent;
+    }
 
-            final boolean last;
-            if (!chunk.getDecoderResult().isSuccess()) {
-                currentMessage.setDecoderResult(
-                        DecoderResult.failure(chunk.getDecoderResult().cause()));
-                last = true;
-            } else {
-                last = chunk instanceof LastHttpContent;
-            }
+    @Override
+    protected boolean isAggregated(HttpObject msg) throws Exception {
+        return msg instanceof FullHttpMessage;
+    }
 
-            if (last) {
-                this.currentMessage = null;
+    @Override
+    protected boolean hasContentLength(HttpMessage start) throws Exception {
+        return HttpHeaders.isContentLengthSet(start);
+    }
 
-                // Merge trailing headers into the message.
-                if (chunk instanceof LastHttpContent) {
-                    LastHttpContent trailer = (LastHttpContent) chunk;
-                    currentMessage.headers().add(trailer.trailingHeaders());
-                }
+    @Override
+    protected long contentLength(HttpMessage start) throws Exception {
+        return HttpHeaders.getContentLength(start);
+    }
 
-                // Set the 'Content-Length' header.
-                currentMessage.headers().set(
-                        HttpHeaders.Names.CONTENT_LENGTH,
-                        String.valueOf(content.readableBytes()));
+    @Override
+    protected Object newContinueResponse(HttpMessage start) throws Exception {
+        if (HttpHeaders.is100ContinueExpected(start)) {
+            return CONTINUE;
+        } else {
+            return null;
+        }
+    }
 
-                // All done
-                out.add(currentMessage);
-            }
+    @Override
+    protected FullHttpMessage beginAggregation(HttpMessage start, ByteBuf content) throws Exception {
+        assert !(start instanceof FullHttpMessage);
+
+        HttpHeaders.removeTransferEncodingChunked(start);
+
+        FullHttpMessage ret;
+        if (start instanceof HttpRequest) {
+            HttpRequest req = (HttpRequest) start;
+            ret = new DefaultFullHttpRequest(req.protocolVersion(),
+                    req.method(), req.uri(), content);
+        } else if (start instanceof HttpResponse) {
+            HttpResponse res = (HttpResponse) start;
+            ret = new DefaultFullHttpResponse(
+                    res.protocolVersion(), res.status(), content);
         } else {
             throw new Error();
         }
+
+        ret.headers().set(start.headers());
+        ret.setDecoderResult(start.decoderResult());
+        return ret;
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        super.channelInactive(ctx);
-
-        // release current message if it is not null as it may be a left-over
-        if (currentMessage != null) {
-            currentMessage.release();
-            currentMessage = null;
+    protected void aggregate(FullHttpMessage aggregated, HttpContent content) throws Exception {
+        if (content instanceof LastHttpContent) {
+            // Merge trailing headers into the message.
+            aggregated.headers().add(((LastHttpContent) content).trailingHeaders());
         }
     }
 
     @Override
-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-        this.ctx = ctx;
+    protected void finishAggregation(FullHttpMessage aggregated) throws Exception {
+        // Set the 'Content-Length' header.
+        aggregated.headers().set(
+                HttpHeaders.Names.CONTENT_LENGTH,
+                String.valueOf(aggregated.content().readableBytes()));
     }
 
     @Override
-    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
-        super.handlerRemoved(ctx);
-        // release current message if it is not null as it may be a left-over as there is not much more we can do in
-        // this case
-        if (currentMessage != null) {
-            currentMessage.release();
-            currentMessage = null;
+    protected void handleOversizedMessage(final ChannelHandlerContext ctx, HttpMessage oversized) throws Exception {
+        if (oversized instanceof HttpRequest) {
+            // send back a 413 and close the connection
+            ChannelFuture future = ctx.writeAndFlush(TOO_LARGE).addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    if (!future.isSuccess()) {
+                        logger.debug("Failed to send a 413 Request Entity Too Large.", future.cause());
+                        ctx.close();
+                    }
+                }
+            });
+
+            // If the client started to send data already, close because it's impossible to recover.
+            // If 'Expect: 100-continue' is missing, close becuase it's impossible to recover.
+            // If keep-alive is off, no need to leave the connection open.
+            if (oversized instanceof FullHttpMessage ||
+                    !HttpHeaders.is100ContinueExpected(oversized) || !HttpHeaders.isKeepAlive(oversized)) {
+                future.addListener(ChannelFutureListener.CLOSE);
+            }
+
+            // If an oversized request was handled properly and the connection is still alive
+            // (i.e. rejected 100-continue). the decoder should prepare to handle a new message.
+            HttpObjectDecoder decoder = ctx.pipeline().get(HttpObjectDecoder.class);
+            if (decoder != null) {
+                decoder.reset();
+            }
+        } else if (oversized instanceof HttpResponse) {
+            ctx.close();
+            throw new TooLongFrameException("Response entity too large: " + oversized);
+        } else {
+            throw new IllegalStateException();
         }
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
index 3c467b02543c..c40afa8065ca 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
@@ -20,9 +20,11 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.HttpObjectDecoder.State;
 import io.netty.util.internal.AppendableCharSequence;
 
 import java.util.List;
@@ -100,7 +102,7 @@
  * To implement the decoder of such a derived protocol, extend this class and
  * implement all abstract methods properly.
  */
-public abstract class HttpObjectDecoder extends ReplayingDecoder<HttpObjectDecoder.State> {
+public abstract class HttpObjectDecoder extends ReplayingDecoder<State> {
 
     private final int maxInitialLineLength;
     private final int maxHeaderSize;
@@ -115,6 +117,7 @@ public abstract class HttpObjectDecoder extends ReplayingDecoder<HttpObjectDecod
     private long chunkSize;
     private int headerSize;
     private long contentLength = Long.MIN_VALUE;
+    private volatile boolean resetRequested;
 
     /**
      * The internal state of {@link HttpObjectDecoder}.
@@ -184,6 +187,10 @@ protected HttpObjectDecoder(
 
     @Override
     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {
+        if (resetRequested) {
+            resetNow();
+        }
+
         switch (state()) {
         case SKIP_CONTROL_CHARS: {
             try {
@@ -223,14 +230,14 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
                 // No content is expected.
                 out.add(message);
                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
-                reset();
+                resetNow();
                 return;
             }
             long contentLength = contentLength();
             if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {
                 out.add(message);
                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
-                reset();
+                resetNow();
                 return;
             }
 
@@ -259,12 +266,12 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
                 } else {
                     // End of connection.
                     out.add(new DefaultLastHttpContent(content, validateHeaders));
-                    reset();
+                    resetNow();
                 }
             } else if (!buffer.isReadable()) {
                 // End of connection.
                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
-                reset();
+                resetNow();
             }
             return;
         }
@@ -291,7 +298,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
             if (chunkSize == 0) {
                 // Read all content.
                 out.add(new DefaultLastHttpContent(content, validateHeaders));
-                reset();
+                resetNow();
             } else {
                 out.add(new DefaultHttpContent(content));
             }
@@ -350,7 +357,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
         case READ_CHUNK_FOOTER: try {
             LastHttpContent trailer = readTrailingHeaders(buffer);
             out.add(trailer);
-            reset();
+            resetNow();
             return;
         } catch (Exception e) {
             out.add(invalidChunk(e));
@@ -393,7 +400,7 @@ protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
                 // connection, so it is perfectly fine.
                 prematureClosure = contentLength() > 0;
             }
-            reset();
+            resetNow();
 
             if (!prematureClosure) {
                 out.add(LastHttpContent.EMPTY_LAST_CONTENT);
@@ -404,7 +411,7 @@ protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
     protected boolean isContentAlwaysEmpty(HttpMessage msg) {
         if (msg instanceof HttpResponse) {
             HttpResponse res = (HttpResponse) msg;
-            int code = res.getStatus().code();
+            int code = res.status().code();
 
             // Correctly handle return codes of 1xx.
             //
@@ -424,13 +431,21 @@ protected boolean isContentAlwaysEmpty(HttpMessage msg) {
         return false;
     }
 
-    private void reset() {
+    /**
+     * Resets the state of the decoder so that it is ready to decode a new message.
+     * This method is useful for handling a rejected request with {@code Expect: 100-continue} header.
+     */
+    public void reset() {
+        resetRequested = true;
+    }
+
+    private void resetNow() {
         HttpMessage message = this.message;
         this.message = null;
         contentLength = Long.MIN_VALUE;
         if (!isDecodingRequest()) {
             HttpResponse res = (HttpResponse) message;
-            if (res != null && res.getStatus().code() == 101) {
+            if (res != null && res.status().code() == 101) {
                 checkpoint(State.UPGRADED);
                 return;
             }
@@ -455,8 +470,9 @@ private HttpMessage invalidMessage(Exception cause) {
 
     private HttpContent invalidChunk(Exception cause) {
         checkpoint(State.BAD_MESSAGE);
-        HttpContent chunk = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);
+        HttpContent chunk = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER);
         chunk.setDecoderResult(DecoderResult.failure(cause));
+        message = null;
         return chunk;
     }
 
@@ -545,9 +561,9 @@ private LastHttpContent readTrailingHeaders(ByteBuf buffer) {
                 } else {
                     String[] header = splitHeader(line);
                     String name = header[0];
-                    if (!HttpHeaders.equalsIgnoreCase(name, HttpHeaders.Names.CONTENT_LENGTH) &&
-                        !HttpHeaders.equalsIgnoreCase(name, HttpHeaders.Names.TRANSFER_ENCODING) &&
-                        !HttpHeaders.equalsIgnoreCase(name, HttpHeaders.Names.TRAILER)) {
+                    if (!AsciiString.equalsIgnoreCase(name, HttpHeaders.Names.CONTENT_LENGTH) &&
+                        !AsciiString.equalsIgnoreCase(name, HttpHeaders.Names.TRANSFER_ENCODING) &&
+                        !AsciiString.equalsIgnoreCase(name, HttpHeaders.Names.TRAILER)) {
                         trailer.trailingHeaders().add(name, header[1]);
                     }
                     lastHeader = name;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
old mode 100644
new mode 100755
index 791822f7df74..e08ef0cf24e4
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
@@ -78,7 +78,7 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
                 throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
             }
 
-            int contentLength = contentLength(msg);
+            final long contentLength = contentLength(msg);
             if (state == ST_CONTENT_NON_CHUNK) {
                 if (contentLength > 0) {
                     if (buf != null && buf.writableBytes() >= contentLength && msg instanceof HttpContent) {
@@ -119,9 +119,9 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
         }
     }
 
-    private void encodeChunkedContent(ChannelHandlerContext ctx, Object msg, int contentLength, List<Object> out) {
+    private void encodeChunkedContent(ChannelHandlerContext ctx, Object msg, long contentLength, List<Object> out) {
         if (contentLength > 0) {
-            byte[] length = Integer.toHexString(contentLength).getBytes(CharsetUtil.US_ASCII);
+            byte[] length = Long.toHexString(contentLength).getBytes(CharsetUtil.US_ASCII);
             ByteBuf buf = ctx.alloc().buffer(length.length + 2);
             buf.writeBytes(length);
             buf.writeBytes(CRLF);
@@ -170,7 +170,7 @@ private static Object encodeAndRetain(Object msg) {
         throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
     }
 
-    private static int contentLength(Object msg) {
+    private static long contentLength(Object msg) {
         if (msg instanceof HttpContent) {
             return ((HttpContent) msg).content().readableBytes();
         }
@@ -178,7 +178,7 @@ private static int contentLength(Object msg) {
             return ((ByteBuf) msg).readableBytes();
         }
         if (msg instanceof FileRegion) {
-            return (int) ((FileRegion) msg).count();
+            return ((FileRegion) msg).count();
         }
         throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java
index c17a634b113c..38f9f71c92e1 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java
@@ -33,24 +33,36 @@
  */
 public interface HttpRequest extends HttpMessage {
 
+    /**
+     * @deprecated Use {@link #method()} instead.
+     */
+    @Deprecated
+    HttpMethod getMethod();
+
     /**
      * Returns the {@link HttpMethod} of this {@link HttpRequest}.
      *
      * @return The {@link HttpMethod} of this {@link HttpRequest}
      */
-    HttpMethod getMethod();
+    HttpMethod method();
 
     /**
      * Set the {@link HttpMethod} of this {@link HttpRequest}.
      */
     HttpRequest setMethod(HttpMethod method);
 
+    /**
+     * @deprecated Use {@link #uri()} instead.
+     */
+    @Deprecated
+    String getUri();
+
     /**
      * Returns the requested URI (or alternatively, path)
      *
      * @return The URI being requested
      */
-    String getUri();
+    String uri();
 
     /**
      *  Set the requested URI (or alternatively, path)
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
index 52bb90fa86f7..2346205b3485 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
@@ -35,12 +35,12 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
 
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {
-        request.getMethod().encode(buf);
+        request.method().encode(buf);
         buf.writeByte(SP);
 
         // Add / as absolute path if no is present.
         // See http://tools.ietf.org/html/rfc2616#section-5.1.2
-        String uri = request.getUri();
+        String uri = request.uri();
 
         if (uri.length() == 0) {
             uri += SLASH;
@@ -57,7 +57,7 @@ protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Except
         buf.writeBytes(uri.getBytes(CharsetUtil.UTF_8));
 
         buf.writeByte(SP);
-        request.getProtocolVersion().encode(buf);
+        request.protocolVersion().encode(buf);
         buf.writeBytes(CRLF);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java
index 7c7ebe242705..44cb77e361fa 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java
@@ -31,12 +31,18 @@
  */
 public interface HttpResponse extends HttpMessage {
 
+    /**
+     * @deprecated Use {@link #status()} instead.
+     */
+    @Deprecated
+    HttpResponseStatus getStatus();
+
     /**
      * Returns the status of this {@link HttpResponse}.
      *
      * @return The {@link HttpResponseStatus} of this {@link HttpResponse}
      */
-    HttpResponseStatus getStatus();
+    HttpResponseStatus status();
 
     /**
      * Set the status of this {@link HttpResponse}.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
index 07e2414998af..5a4c7c5cc313 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
@@ -33,9 +33,9 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
 
     @Override
     protected void encodeInitialLine(ByteBuf buf, HttpResponse response) throws Exception {
-        response.getProtocolVersion().encode(buf);
+        response.protocolVersion().encode(buf);
         buf.writeByte(SP);
-        response.getStatus().encode(buf);
+        response.status().encode(buf);
         buf.writeBytes(CRLF);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java
index 985d85291f87..af623201c3c9 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.util.CharsetUtil;
 
-import static io.netty.handler.codec.http.HttpConstants.SP;
+import static io.netty.handler.codec.http.HttpConstants.*;
 
 /**
  * The response code and its description of HTTP or its derived protocols, such as
@@ -213,8 +213,7 @@ public class HttpResponseStatus implements Comparable<HttpResponseStatus> {
     /**
      * 417 Expectation Failed
      */
-    public static final HttpResponseStatus EXPECTATION_FAILED =
-            new HttpResponseStatus(417, "Expectation Failed", true);
+    public static final HttpResponseStatus EXPECTATION_FAILED = new HttpResponseStatus(417, "Expectation Failed", true);
 
     /**
      * 422 Unprocessable Entity (WebDAV, RFC4918)
@@ -225,8 +224,7 @@ public class HttpResponseStatus implements Comparable<HttpResponseStatus> {
     /**
      * 423 Locked (WebDAV, RFC4918)
      */
-    public static final HttpResponseStatus LOCKED =
-            new HttpResponseStatus(423, "Locked", true);
+    public static final HttpResponseStatus LOCKED = new HttpResponseStatus(423, "Locked", true);
 
     /**
      * 424 Failed Dependency (WebDAV, RFC4918)
@@ -455,6 +453,36 @@ public static HttpResponseStatus valueOf(int code) {
         return new HttpResponseStatus(code, reasonPhrase + " (" + code + ')');
     }
 
+    /**
+     * Parses the specified HTTP status line into a {@link HttpResponseStatus}.  The expected formats of the line are:
+     * <ul>
+     * <li>{@code statusCode} (e.g. 200)</li>
+     * <li>{@code statusCode} {@code reasonPhrase} (e.g. 404 Not Found)</li>
+     * </ul>
+     *
+     * @throws IllegalArgumentException if the specified status line is malformed
+     */
+    public static HttpResponseStatus parseLine(CharSequence line) {
+        String status = line.toString();
+        try {
+            int space = status.indexOf(' ');
+            if (space == -1) {
+                return valueOf(Integer.parseInt(status));
+            } else {
+                int code = Integer.parseInt(status.substring(0, space));
+                String reasonPhrase = status.substring(space + 1);
+                HttpResponseStatus responseStatus = valueOf(code);
+                if (responseStatus.reasonPhrase().equals(reasonPhrase)) {
+                    return responseStatus;
+                } else {
+                    return new HttpResponseStatus(code, reasonPhrase);
+                }
+            }
+        } catch (Exception e) {
+            throw new IllegalArgumentException("malformed status line: " + status, e);
+        }
+    }
+
     private final int code;
 
     private final String reasonPhrase;
@@ -499,14 +527,14 @@ private HttpResponseStatus(int code, String reasonPhrase, boolean bytes) {
     }
 
     /**
-     * Returns the code of this getStatus.
+     * Returns the code of this {@link HttpResponseStatus}.
      */
     public int code() {
         return code;
     }
 
     /**
-     * Returns the reason phrase of this getStatus.
+     * Returns the reason phrase of this {@link HttpResponseStatus}.
      */
     public String reasonPhrase() {
         return reasonPhrase;
@@ -517,6 +545,10 @@ public int hashCode() {
         return code();
     }
 
+    /**
+     * Equality of {@link HttpResponseStatus} only depends on {@link #code()}. The
+     * reason phrase is not considered for equality.
+     */
     @Override
     public boolean equals(Object o) {
         if (!(o instanceof HttpResponseStatus)) {
@@ -526,6 +558,10 @@ public boolean equals(Object o) {
         return code() == ((HttpResponseStatus) o).code();
     }
 
+    /**
+     * Equality of {@link HttpResponseStatus} only depends on {@link #code()}. The
+     * reason phrase is not considered for equality.
+     */
     @Override
     public int compareTo(HttpResponseStatus o) {
         return code() - o.code();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
index c10185a51b42..0b14fa26e189 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.channel.CombinedChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerAppender;
 
 
 /**
@@ -24,8 +24,7 @@
  *
  * @see HttpClientCodec
  */
-public final class HttpServerCodec
-        extends CombinedChannelDuplexHandler<HttpRequestDecoder, HttpResponseEncoder> {
+public final class HttpServerCodec extends ChannelHandlerAppender {
 
     /**
      * Creates a new instance with the default decoder options
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java
index 26be9ebe6296..0dbfda8ec09f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java
@@ -71,18 +71,9 @@ public static HttpVersion valueOf(String text) {
         // * http://trac.tools.ietf.org/wg/httpbis/trac/ticket/1
         // * http://trac.tools.ietf.org/wg/httpbis/trac/wiki
         //
-        // TODO: Remove the uppercase conversion in 4.1.0 as the RFC state it must be HTTP (uppercase)
-        //       See https://github.com/netty/netty/issues/1682
-
         HttpVersion version = version0(text);
         if (version == null) {
-            text = text.toUpperCase();
-            // try again after convert to uppercase
-            version = version0(text);
-            if (version == null) {
-                // still no match, construct a new one
-                version = new HttpVersion(text, true);
-            }
+            version = new HttpVersion(text, true);
         }
         return version;
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
index d93d1d1865d0..695397656f0c 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
@@ -50,10 +50,16 @@ public HttpHeaders trailingHeaders() {
         }
 
         @Override
-        public DecoderResult getDecoderResult() {
+        public DecoderResult decoderResult() {
             return DecoderResult.SUCCESS;
         }
 
+        @Override
+        @Deprecated
+        public DecoderResult getDecoderResult() {
+            return decoderResult();
+        }
+
         @Override
         public void setDecoderResult(DecoderResult result) {
             throw new UnsupportedOperationException("read only");
@@ -74,6 +80,16 @@ public LastHttpContent retain(int increment) {
             return this;
         }
 
+        @Override
+        public LastHttpContent touch() {
+            return this;
+        }
+
+        @Override
+        public LastHttpContent touch(Object hint) {
+            return this;
+        }
+
         @Override
         public boolean release() {
             return false;
@@ -100,4 +116,13 @@ public String toString() {
 
     @Override
     LastHttpContent retain();
+
+    @Override
+    LastHttpContent touch();
+
+    @Override
+    LastHttpContent touch(Object hint);
+
+    @Override
+    LastHttpContent duplicate();
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
index 4075efa25b19..eabdcfbf8f40 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
@@ -301,9 +301,7 @@ public static String decodeComponent(final String s) {
      * @throws IllegalArgumentException if the string contains a malformed
      * escape sequence.
      */
-    @SuppressWarnings("fallthrough")
-    public static String decodeComponent(final String s,
-                                         final Charset charset) {
+    public static String decodeComponent(final String s, final Charset charset) {
         if (s == null) {
             return "";
         }
@@ -311,13 +309,9 @@ public static String decodeComponent(final String s,
         boolean modified = false;
         for (int i = 0; i < size; i++) {
             final char c = s.charAt(i);
-            switch (c) {
-                case '%':
-                    i++;  // We can skip at least one char, e.g. `%%'.
-                    // Fall through.
-                case '+':
-                    modified = true;
-                    break;
+            if (c == '%' || c == '+') {
+                modified = true;
+                break;
             }
         }
         if (!modified) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
index eb40646f24f6..86d5ac6c5cf0 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java
@@ -72,9 +72,6 @@ public void addParam(String name, String value) {
         if (name == null) {
             throw new NullPointerException("name");
         }
-        if (value == null) {
-            throw new NullPointerException("value");
-        }
         params.add(new Param(name, value));
     }
 
@@ -101,8 +98,10 @@ public String toString() {
             for (int i = 0; i < params.size(); i++) {
                 Param param = params.get(i);
                 sb.append(encodeComponent(param.name, charset));
-                sb.append('=');
-                sb.append(encodeComponent(param.value, charset));
+                if (param.value != null) {
+                    sb.append('=');
+                    sb.append(encodeComponent(param.value, charset));
+                }
                 if (i != params.size() - 1) {
                     sb.append('&');
                 }
@@ -115,7 +114,7 @@ private static String encodeComponent(String s, Charset charset) {
         // TODO: Optimize me.
         try {
             return URLEncoder.encode(s, charset.name()).replace("+", "%20");
-        } catch (UnsupportedEncodingException e) {
+        } catch (UnsupportedEncodingException ignored) {
             throw new UnsupportedCharsetException(charset.name());
         }
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
index 21c906e7bec7..3c71ddcc6678 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
@@ -47,34 +47,34 @@ public static String encode(Cookie cookie) {
             throw new NullPointerException("cookie");
         }
 
-        StringBuilder buf = buffer.get();
+        StringBuilder buf = stringBuilder();
 
-        add(buf, cookie.getName(), cookie.getValue());
+        add(buf, cookie.name(), cookie.value());
 
-        if (cookie.getMaxAge() != Long.MIN_VALUE) {
-            if (cookie.getVersion() == 0) {
+        if (cookie.maxAge() != Long.MIN_VALUE) {
+            if (cookie.version() == 0) {
                 addUnquoted(buf, CookieHeaderNames.EXPIRES,
                         HttpHeaderDateFormat.get().format(
                                 new Date(System.currentTimeMillis() +
-                                         cookie.getMaxAge() * 1000L)));
+                                         cookie.maxAge() * 1000L)));
             } else {
-                add(buf, CookieHeaderNames.MAX_AGE, cookie.getMaxAge());
+                add(buf, CookieHeaderNames.MAX_AGE, cookie.maxAge());
             }
         }
 
-        if (cookie.getPath() != null) {
-            if (cookie.getVersion() > 0) {
-                add(buf, CookieHeaderNames.PATH, cookie.getPath());
+        if (cookie.path() != null) {
+            if (cookie.version() > 0) {
+                add(buf, CookieHeaderNames.PATH, cookie.path());
             } else {
-                addUnquoted(buf, CookieHeaderNames.PATH, cookie.getPath());
+                addUnquoted(buf, CookieHeaderNames.PATH, cookie.path());
             }
         }
 
-        if (cookie.getDomain() != null) {
-            if (cookie.getVersion() > 0) {
-                add(buf, CookieHeaderNames.DOMAIN, cookie.getDomain());
+        if (cookie.domain() != null) {
+            if (cookie.version() > 0) {
+                add(buf, CookieHeaderNames.DOMAIN, cookie.domain());
             } else {
-                addUnquoted(buf, CookieHeaderNames.DOMAIN, cookie.getDomain());
+                addUnquoted(buf, CookieHeaderNames.DOMAIN, cookie.domain());
             }
         }
         if (cookie.isSecure()) {
@@ -87,22 +87,22 @@ public static String encode(Cookie cookie) {
             buf.append((char) HttpConstants.SEMICOLON);
             buf.append((char) HttpConstants.SP);
         }
-        if (cookie.getVersion() >= 1) {
-            if (cookie.getComment() != null) {
-                add(buf, CookieHeaderNames.COMMENT, cookie.getComment());
+        if (cookie.version() >= 1) {
+            if (cookie.comment() != null) {
+                add(buf, CookieHeaderNames.COMMENT, cookie.comment());
             }
 
             add(buf, CookieHeaderNames.VERSION, 1);
 
-            if (cookie.getCommentUrl() != null) {
-                addQuoted(buf, CookieHeaderNames.COMMENTURL, cookie.getCommentUrl());
+            if (cookie.commentUrl() != null) {
+                addQuoted(buf, CookieHeaderNames.COMMENTURL, cookie.commentUrl());
             }
 
-            if (!cookie.getPorts().isEmpty()) {
+            if (!cookie.ports().isEmpty()) {
                 buf.append(CookieHeaderNames.PORT);
                 buf.append((char) HttpConstants.EQUALS);
                 buf.append((char) HttpConstants.DOUBLE_QUOTE);
-                for (int port: cookie.getPorts()) {
+                for (int port: cookie.ports()) {
                     buf.append(port);
                     buf.append((char) HttpConstants.COMMA);
                 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
index b818453d9411..7ceff7a54f11 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java
@@ -15,20 +15,30 @@
  */
 package io.netty.handler.codec.http.cors;
 
+import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.util.internal.StringUtil;
 
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
+import java.util.concurrent.Callable;
 
 /**
  * Configuration for Cross-Origin Resource Sharing (CORS).
  */
 public final class CorsConfig {
 
-    private final String origin;
+    private final Set<String> origins;
+    private final boolean anyOrigin;
     private final boolean enabled;
     private final Set<String> exposeHeaders;
     private final boolean allowCredentials;
@@ -36,9 +46,12 @@ public final class CorsConfig {
     private final Set<HttpMethod> allowedRequestMethods;
     private final Set<String> allowedRequestHeaders;
     private final boolean allowNullOrigin;
+    private final Map<CharSequence, Callable<?>> preflightHeaders;
+    private final boolean shortCurcuit;
 
     private CorsConfig(final Builder builder) {
-        origin = builder.origin;
+        origins = new LinkedHashSet<String>(builder.origins);
+        anyOrigin = builder.anyOrigin;
         enabled = builder.enabled;
         exposeHeaders = builder.exposeHeaders;
         allowCredentials = builder.allowCredentials;
@@ -46,6 +59,8 @@ private CorsConfig(final Builder builder) {
         allowedRequestMethods = builder.requestMethods;
         allowedRequestHeaders = builder.requestHeaders;
         allowNullOrigin = builder.allowNullOrigin;
+        preflightHeaders = builder.preflightHeaders;
+        shortCurcuit = builder.shortCurcuit;
     }
 
     /**
@@ -57,18 +72,37 @@ public boolean isCorsSupportEnabled() {
         return enabled;
     }
 
+    /**
+     * Determines whether a wildcard origin, '*', is supported.
+     *
+     * @return {@code boolean} true if any origin is allowed.
+     */
+    public boolean isAnyOriginSupported() {
+        return anyOrigin;
+    }
+
     /**
      * Returns the allowed origin. This can either be a wildcard or an origin value.
      *
      * @return the value that will be used for the CORS response header 'Access-Control-Allow-Origin'
      */
     public String origin() {
-        return origin;
+        return origins.isEmpty() ? "*" : origins.iterator().next();
+    }
+
+    /**
+     * Returns the set of allowed origins.
+     *
+     * @return {@code Set} the allowed origins.
+     */
+    public Set<String> origins() {
+        return origins;
     }
 
     /**
      * Web browsers may set the 'Origin' request header to 'null' if a resource is loaded
      * from the local file system.
+     *
      * If isNullOriginAllowed is true then the server will response with the wildcard for the
      * the CORS response header 'Access-Control-Allow-Origin'.
      *
@@ -95,8 +129,8 @@ public boolean isNullOriginAllowed() {
      * <li>Last-Modified</li>
      * <li>Pragma</li>
      * </ul>
-     * To expose other headers they need to be specified which what this method enables by adding the headers
-     * to the CORS 'Access-Control-Expose-Headers' response header.
+     * To expose other headers they need to be specified, which is what this method enables by
+     * adding the headers names to the CORS 'Access-Control-Expose-Headers' response header.
      *
      * @return {@code List<String>} a list of the headers to expose.
      */
@@ -107,9 +141,17 @@ public Set<String> exposedHeaders() {
     /**
      * Determines if cookies are supported for CORS requests.
      *
-     * By default cookies are not included in CORS requests but if isCredentialsAllowed returns true cookies will
-     * be added to CORS requests. Setting this value to true will set the CORS 'Access-Control-Allow-Credentials'
-     * response header to true.
+     * By default cookies are not included in CORS requests but if isCredentialsAllowed returns
+     * true cookies will be added to CORS requests. Setting this value to true will set the
+     * CORS 'Access-Control-Allow-Credentials' response header to true.
+     *
+     * Please note that cookie support needs to be enabled on the client side as well.
+     * The client needs to opt-in to send cookies by calling:
+     * <pre>
+     * xhr.withCredentials = true;
+     * </pre>
+     * The default value for 'withCredentials' is false in which case no cookies are sent.
+     * Settning this to true will included cookies in cross origin requests.
      *
      * @return {@code true} if cookies are supported.
      */
@@ -120,9 +162,10 @@ public boolean isCredentialsAllowed() {
     /**
      * Gets the maxAge setting.
      *
-     * When making a preflight request the client has to perform two request with can be inefficient. This setting
-     * will set the CORS 'Access-Control-Max-Age' response header and enables the caching of the preflight response
-     * for the specified time. During this time no preflight request will be made.
+     * When making a preflight request the client has to perform two request with can be inefficient.
+     * This setting will set the CORS 'Access-Control-Max-Age' response header and enables the
+     * caching of the preflight response for the specified time. During this time no preflight
+     * request will be made.
      *
      * @return {@code long} the time in seconds that a preflight request may be cached.
      */
@@ -132,10 +175,9 @@ public long maxAge() {
 
     /**
      * Returns the allowed set of Request Methods. The Http methods that should be returned in the
-     *
      * CORS 'Access-Control-Request-Method' response header.
      *
-     * @return {@code Set} strings that represent the allowed Request Methods.
+     * @return {@code Set} of {@link HttpMethod}s that represent the allowed Request Methods.
      */
     public Set<HttpMethod> allowedRequestMethods() {
         return Collections.unmodifiableSet(allowedRequestMethods);
@@ -144,36 +186,108 @@ public Set<HttpMethod> allowedRequestMethods() {
     /**
      * Returns the allowed set of Request Headers.
      *
-     * The header names returned from this method will be used to set the CORS 'Access-Control-Allow-Headers'
-     * response header.
+     * The header names returned from this method will be used to set the CORS
+     * 'Access-Control-Allow-Headers' response header.
      *
-     * @return {@code Set} of strings that represent the allowed Request Headers.
+     * @return {@code Set<String>} of strings that represent the allowed Request Headers.
      */
     public Set<String> allowedRequestHeaders() {
         return Collections.unmodifiableSet(allowedRequestHeaders);
     }
 
+    /**
+     * Returns HTTP response headers that should be added to a CORS preflight response.
+     *
+     * @return {@link HttpHeaders} the HTTP response headers to be added.
+     */
+    public HttpHeaders preflightResponseHeaders() {
+        if (preflightHeaders.isEmpty()) {
+            return HttpHeaders.EMPTY_HEADERS;
+        }
+        final HttpHeaders preflightHeaders = new DefaultHttpHeaders();
+        for (Entry<CharSequence, Callable<?>> entry : this.preflightHeaders.entrySet()) {
+            final Object value = getValue(entry.getValue());
+            if (value instanceof Iterable) {
+                preflightHeaders.add(entry.getKey(), (Iterable<?>) value);
+            } else {
+                preflightHeaders.add(entry.getKey(), value);
+            }
+        }
+        return preflightHeaders;
+    }
+
+    /**
+     * Determines whether a CORS request should be rejected if it's invalid before being
+     * further processing.
+     *
+     * CORS headers are set after a request is processed. This may not always be desired
+     * and this setting will check that the Origin is valid and if it is not valid no
+     * further processing will take place, and a error will be returned to the calling client.
+     *
+     * @return {@code true} if a CORS request should short-curcuit upon receiving an invalid Origin header.
+     */
+    public boolean isShortCurcuit() {
+        return shortCurcuit;
+    }
+
+    private static <T> T getValue(final Callable<T> callable) {
+        try {
+            return callable.call();
+        } catch (final Exception e) {
+            throw new IllegalStateException("Could not generate value for callable [" + callable + ']', e);
+        }
+    }
+
+    @Override
     public String toString() {
         return StringUtil.simpleClassName(this) + "[enabled=" + enabled +
-                ", origin=" + origin +
+                ", origins=" + origins +
+                ", anyOrigin=" + anyOrigin +
                 ", exposedHeaders=" + exposeHeaders +
                 ", isCredentialsAllowed=" + allowCredentials +
                 ", maxAge=" + maxAge +
                 ", allowedRequestMethods=" + allowedRequestMethods +
-                ", allowedRequestHeaders=" + allowedRequestHeaders + ']';
+                ", allowedRequestHeaders=" + allowedRequestHeaders +
+                ", preflightHeaders=" + preflightHeaders + ']';
     }
 
-    public static Builder anyOrigin() {
-        return new Builder("*");
+    /**
+     * Creates a Builder instance with it's origin set to '*'.
+     *
+     * @return Builder to support method chaining.
+     */
+    public static Builder withAnyOrigin() {
+        return new Builder();
     }
 
+    /**
+     * Creates a {@link Builder} instance with the specified origin.
+     *
+     * @return {@link Builder} to support method chaining.
+     */
     public static Builder withOrigin(final String origin) {
+        if ("*".equals(origin)) {
+            return new Builder();
+        }
         return new Builder(origin);
     }
 
+    /**
+     * Creates a {@link Builder} instance with the specified origins.
+     *
+     * @return {@link Builder} to support method chaining.
+     */
+    public static Builder withOrigins(final String... origins) {
+        return new Builder(origins);
+    }
+
+    /**
+     * Builder used to configure and build a CorsConfig instance.
+     */
     public static class Builder {
 
-        private final String origin;
+        private final Set<String> origins;
+        private final boolean anyOrigin;
         private boolean allowNullOrigin;
         private boolean enabled = true;
         private boolean allowCredentials;
@@ -181,49 +295,281 @@ public static class Builder {
         private long maxAge;
         private final Set<HttpMethod> requestMethods = new HashSet<HttpMethod>();
         private final Set<String> requestHeaders = new HashSet<String>();
+        private final Map<CharSequence, Callable<?>> preflightHeaders = new HashMap<CharSequence, Callable<?>>();
+        private boolean noPreflightHeaders;
+        private boolean shortCurcuit;
+
+        /**
+         * Creates a new Builder instance with the origin passed in.
+         *
+         * @param origins the origin to be used for this builder.
+         */
+        public Builder(final String... origins) {
+            this.origins = new LinkedHashSet<String>(Arrays.asList(origins));
+            anyOrigin = false;
+        }
 
-        public Builder(final String origin) {
-            this.origin = origin;
+        /**
+         * Creates a new Builder instance allowing any origin, "*" which is the
+         * wildcard origin.
+         *
+         */
+        public Builder() {
+            anyOrigin = true;
+            origins = Collections.emptySet();
         }
 
+        /**
+         * Web browsers may set the 'Origin' request header to 'null' if a resource is loaded
+         * from the local file system. Calling this method will enable a successful CORS response
+         * with a wildcard for the the CORS response header 'Access-Control-Allow-Origin'.
+         *
+         * @return {@link Builder} to support method chaining.
+         */
         public Builder allowNullOrigin() {
             allowNullOrigin = true;
             return this;
         }
 
+        /**
+         * Disables CORS support.
+         *
+         * @return {@link Builder} to support method chaining.
+         */
         public Builder disable() {
             enabled = false;
             return this;
         }
 
+        /**
+         * Specifies the headers to be exposed to calling clients.
+         *
+         * During a simple CORS request, only certain response headers are made available by the
+         * browser, for example using:
+         * <pre>
+         * xhr.getResponseHeader("Content-Type");
+         * </pre>
+         *
+         * The headers that are available by default are:
+         * <ul>
+         * <li>Cache-Control</li>
+         * <li>Content-Language</li>
+         * <li>Content-Type</li>
+         * <li>Expires</li>
+         * <li>Last-Modified</li>
+         * <li>Pragma</li>
+         * </ul>
+         *
+         * To expose other headers they need to be specified which is what this method enables by
+         * adding the headers to the CORS 'Access-Control-Expose-Headers' response header.
+         *
+         * @param headers the values to be added to the 'Access-Control-Expose-Headers' response header
+         * @return {@link Builder} to support method chaining.
+         */
         public Builder exposeHeaders(final String... headers) {
             exposeHeaders.addAll(Arrays.asList(headers));
             return this;
         }
 
+        /**
+         * By default cookies are not included in CORS requests, but this method will enable cookies to
+         * be added to CORS requests. Calling this method will set the CORS 'Access-Control-Allow-Credentials'
+         * response header to true.
+         *
+         * Please note, that cookie support needs to be enabled on the client side as well.
+         * The client needs to opt-in to send cookies by calling:
+         * <pre>
+         * xhr.withCredentials = true;
+         * </pre>
+         * The default value for 'withCredentials' is false in which case no cookies are sent.
+         * Settning this to true will included cookies in cross origin requests.
+         *
+         * @return {@link Builder} to support method chaining.
+         */
         public Builder allowCredentials() {
             allowCredentials = true;
             return this;
         }
 
+        /**
+         * When making a preflight request the client has to perform two request with can be inefficient.
+         * This setting will set the CORS 'Access-Control-Max-Age' response header and enables the
+         * caching of the preflight response for the specified time. During this time no preflight
+         * request will be made.
+         *
+         * @param max the maximum time, in seconds, that the preflight response may be cached.
+         * @return {@link Builder} to support method chaining.
+         */
         public Builder maxAge(final long max) {
             maxAge = max;
             return this;
         }
 
+        /**
+         * Specifies the allowed set of HTTP Request Methods that should be returned in the
+         * CORS 'Access-Control-Request-Method' response header.
+         *
+         * @param methods the {@link HttpMethod}s that should be allowed.
+         * @return {@link Builder} to support method chaining.
+         */
         public Builder allowedRequestMethods(final HttpMethod... methods) {
             requestMethods.addAll(Arrays.asList(methods));
             return this;
         }
 
+        /**
+         * Specifies the if headers that should be returned in the CORS 'Access-Control-Allow-Headers'
+         * response header.
+         *
+         * If a client specifies headers on the request, for example by calling:
+         * <pre>
+         * xhr.setRequestHeader('My-Custom-Header', "SomeValue");
+         * </pre>
+         * the server will recieve the above header name in the 'Access-Control-Request-Headers' of the
+         * preflight request. The server will then decide if it allows this header to be sent for the
+         * real request (remember that a preflight is not the real request but a request asking the server
+         * if it allow a request).
+         *
+         * @param headers the headers to be added to the preflight 'Access-Control-Allow-Headers' response header.
+         * @return {@link Builder} to support method chaining.
+         */
         public Builder allowedRequestHeaders(final String... headers) {
             requestHeaders.addAll(Arrays.asList(headers));
             return this;
         }
 
+        /**
+         * Returns HTTP response headers that should be added to a CORS preflight response.
+         *
+         * An intermediary like a load balancer might require that a CORS preflight request
+         * have certain headers set. This enables such headers to be added.
+         *
+         * @param name the name of the HTTP header.
+         * @param values the values for the HTTP header.
+         * @return {@link Builder} to support method chaining.
+         */
+        public Builder preflightResponseHeader(final CharSequence name, final Object... values) {
+            if (values.length == 1) {
+                preflightHeaders.put(name, new ConstantValueGenerator(values[0]));
+            } else {
+                preflightResponseHeader(name, Arrays.asList(values));
+            }
+            return this;
+        }
+
+        /**
+         * Returns HTTP response headers that should be added to a CORS preflight response.
+         *
+         * An intermediary like a load balancer might require that a CORS preflight request
+         * have certain headers set. This enables such headers to be added.
+         *
+         * @param name the name of the HTTP header.
+         * @param value the values for the HTTP header.
+         * @param <T> the type of values that the Iterable contains.
+         * @return {@link Builder} to support method chaining.
+         */
+        public <T> Builder preflightResponseHeader(final CharSequence name, final Iterable<T> value) {
+            preflightHeaders.put(name, new ConstantValueGenerator(value));
+            return this;
+        }
+
+        /**
+         * Returns HTTP response headers that should be added to a CORS preflight response.
+         *
+         * An intermediary like a load balancer might require that a CORS preflight request
+         * have certain headers set. This enables such headers to be added.
+         *
+         * Some values must be dynamically created when the HTTP response is created, for
+         * example the 'Date' response header. This can be occomplished by using a Callable
+         * which will have its 'call' method invoked when the HTTP response is created.
+         *
+         * @param name the name of the HTTP header.
+         * @param valueGenerator a Callable which will be invoked at HTTP response creation.
+         * @param <T> the type of the value that the Callable can return.
+         * @return {@link Builder} to support method chaining.
+         */
+        public <T> Builder preflightResponseHeader(final String name, final Callable<T> valueGenerator) {
+            preflightHeaders.put(name, valueGenerator);
+            return this;
+        }
+
+        /**
+         * Specifies that no preflight response headers should be added to a preflight response.
+         *
+         * @return {@link Builder} to support method chaining.
+         */
+        public Builder noPreflightResponseHeaders() {
+            noPreflightHeaders = true;
+            return this;
+        }
+
+        /**
+         * Builds a {@link CorsConfig} with settings specified by previous method calls.
+         *
+         * @return {@link CorsConfig} the configured CorsConfig instance.
+         */
         public CorsConfig build() {
+            if (preflightHeaders.isEmpty() && !noPreflightHeaders) {
+                preflightHeaders.put(Names.DATE, new DateValueGenerator());
+                preflightHeaders.put(Names.CONTENT_LENGTH, new ConstantValueGenerator("0"));
+            }
             return new CorsConfig(this);
         }
+
+        /**
+         * Specifies that a CORS request should be rejected if it's invalid before being
+         * further processing.
+         *
+         * CORS headers are set after a request is processed. This may not always be desired
+         * and this setting will check that the Origin is valid and if it is not valid no
+         * further processing will take place, and a error will be returned to the calling client.
+         *
+         * @return {@link Builder} to support method chaining.
+         */
+        public Builder shortCurcuit() {
+            shortCurcuit = true;
+            return this;
+        }
+    }
+
+    /**
+     * This class is used for preflight HTTP response values that do not need to be
+     * generated, but instead the value is "static" in that the same value will be returned
+     * for each call.
+     */
+    private static final class ConstantValueGenerator implements Callable<Object> {
+
+        private final Object value;
+
+        /**
+         * Sole constructor.
+         *
+         * @param value the value that will be returned when the call method is invoked.
+         */
+        private ConstantValueGenerator(final Object value) {
+            if (value == null) {
+                throw new IllegalArgumentException("value must not be null");
+            }
+            this.value = value;
+        }
+
+        @Override
+        public Object call() {
+            return value;
+        }
+    }
+
+    /**
+     * This callable is used for the DATE preflight HTTP response HTTP header.
+     * It's value must be generated when the response is generated, hence will be
+     * different for every call.
+     */
+    public static final class DateValueGenerator implements Callable<Date> {
+
+        @Override
+        public Date call() throws Exception {
+            return new Date();
+        }
     }
 
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
index f08a6a4af67d..dea12c83ce7a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
@@ -15,25 +15,25 @@
  */
 package io.netty.handler.codec.http.cors;
 
-import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpMethod.*;
-import static io.netty.handler.codec.http.HttpResponseStatus.OK;
-
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static io.netty.handler.codec.http.HttpMethod.*;
+import static io.netty.handler.codec.http.HttpResponseStatus.*;
+
 /**
  * Handles <a href="http://www.w3.org/TR/cors/">Cross Origin Resource Sharing</a> (CORS) requests.
  * <p>
- * This handler can be configured using a {@link io.netty.handler.codec.http.cors.CorsConfig}, please
+ * This handler can be configured using a {@link CorsConfig}, please
  * refer to this class for details about the configuration options available.
  */
 public class CorsHandler extends ChannelDuplexHandler {
@@ -55,34 +55,96 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) throw
                 handlePreflight(ctx, request);
                 return;
             }
+            if (config.isShortCurcuit() && !validateOrigin()) {
+                forbidden(ctx, request);
+                return;
+            }
         }
         ctx.fireChannelRead(msg);
     }
 
     private void handlePreflight(final ChannelHandlerContext ctx, final HttpRequest request) {
-        final HttpResponse response = new DefaultHttpResponse(request.getProtocolVersion(), OK);
+        final HttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), OK);
         if (setOrigin(response)) {
             setAllowMethods(response);
             setAllowHeaders(response);
             setAllowCredentials(response);
             setMaxAge(response);
+            setPreflightHeaders(response);
         }
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
 
+    /**
+     * This is a non CORS specification feature which enables the setting of preflight
+     * response headers that might be required by intermediaries.
+     *
+     * @param response the HttpResponse to which the preflight response headers should be added.
+     */
+    private void setPreflightHeaders(final HttpResponse response) {
+        response.headers().add(config.preflightResponseHeaders());
+    }
+
     private boolean setOrigin(final HttpResponse response) {
         final String origin = request.headers().get(ORIGIN);
         if (origin != null) {
             if ("null".equals(origin) && config.isNullOriginAllowed()) {
-                response.headers().set(ACCESS_CONTROL_ALLOW_ORIGIN, "*");
-            } else {
-                response.headers().set(ACCESS_CONTROL_ALLOW_ORIGIN, config.origin());
+                setAnyOrigin(response);
+                return true;
             }
-            return true;
+            if (config.isAnyOriginSupported()) {
+                if (config.isCredentialsAllowed()) {
+                    echoRequestOrigin(response);
+                    setVaryHeader(response);
+                } else {
+                    setAnyOrigin(response);
+                }
+                return true;
+            }
+            if (config.origins().contains(origin)) {
+                setOrigin(response, origin);
+                setVaryHeader(response);
+                return true;
+            }
+            logger.debug("Request origin [" + origin + "] was not among the configured origins " + config.origins());
         }
         return false;
     }
 
+    private boolean validateOrigin() {
+        if (config.isAnyOriginSupported()) {
+            return true;
+        }
+
+        final String origin = request.headers().get(ORIGIN);
+        if (origin == null) {
+            // Not a CORS request so we cannot validate it. It may be a non CORS request.
+            return true;
+        }
+
+        if ("null".equals(origin) && config.isNullOriginAllowed()) {
+            return true;
+        }
+
+        return config.origins().contains(origin);
+    }
+
+    private void echoRequestOrigin(final HttpResponse response) {
+        setOrigin(response, request.headers().get(ORIGIN));
+    }
+
+    private static void setVaryHeader(final HttpResponse response) {
+        response.headers().set(VARY, ORIGIN);
+    }
+
+    private static void setAnyOrigin(final HttpResponse response) {
+        setOrigin(response, "*");
+    }
+
+    private static void setOrigin(final HttpResponse response, final String origin) {
+        response.headers().set(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
+    }
+
     private void setAllowCredentials(final HttpResponse response) {
         if (config.isCredentialsAllowed()) {
             response.headers().set(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
@@ -91,7 +153,7 @@ private void setAllowCredentials(final HttpResponse response) {
 
     private static boolean isPreflightRequest(final HttpRequest request) {
         final HttpHeaders headers = request.headers();
-        return request.getMethod().equals(OPTIONS) &&
+        return request.method().equals(OPTIONS) &&
                 headers.contains(ORIGIN) &&
                 headers.contains(ACCESS_CONTROL_REQUEST_METHOD);
     }
@@ -133,5 +195,10 @@ public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cau
         logger.error("Caught error in CorsHandler", cause);
         ctx.fireExceptionCaught(cause);
     }
+
+    private static void forbidden(final ChannelHandlerContext ctx, final HttpRequest request) {
+        ctx.writeAndFlush(new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN))
+                .addListener(ChannelFutureListener.CLOSE);
+    }
 }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
index 62af2b449ceb..9130d33f4dd6 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java
@@ -39,7 +39,7 @@ public abstract class AbstractDiskHttpData extends AbstractHttpData {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractDiskHttpData.class);
 
-    protected File file;
+    private File file;
     private boolean isRenamed;
     private FileChannel fileChannel;
 
@@ -105,6 +105,7 @@ public void setContent(ByteBuf buffer) throws IOException {
         }
         try {
             size = buffer.readableBytes();
+            checkSize(size);
             if (definedSize > 0 && definedSize < size) {
                 throw new IOException("Out of size: " + size + " > " + definedSize);
             }
@@ -113,7 +114,9 @@ public void setContent(ByteBuf buffer) throws IOException {
             }
             if (buffer.readableBytes() == 0) {
                 // empty file
-                file.createNewFile();
+                if (!file.createNewFile()) {
+                    throw new IOException("file exists already: " + file);
+                }
                 return;
             }
             FileOutputStream outputStream = new FileOutputStream(file);
@@ -127,7 +130,7 @@ public void setContent(ByteBuf buffer) throws IOException {
             localfileChannel.force(false);
             localfileChannel.close();
             outputStream.close();
-            completed = true;
+            setCompleted();
         } finally {
             // Release the buffer as it was retained before and we not need a reference to it at all
             // See https://github.com/netty/netty/issues/1516
@@ -141,6 +144,7 @@ public void addContent(ByteBuf buffer, boolean last)
         if (buffer != null) {
             try {
                 int localsize = buffer.readableBytes();
+                checkSize(size + localsize);
                 if (definedSize > 0 && definedSize < size + localsize) {
                     throw new IOException("Out of size: " + (size + localsize) +
                             " > " + definedSize);
@@ -176,7 +180,7 @@ public void addContent(ByteBuf buffer, boolean last)
             fileChannel.force(false);
             fileChannel.close();
             fileChannel = null;
-            completed = true;
+            setCompleted();
         } else {
             if (buffer == null) {
                 throw new NullPointerException("buffer");
@@ -191,8 +195,9 @@ public void setContent(File file) throws IOException {
         }
         this.file = file;
         size = file.length();
+        checkSize(size);
         isRenamed = true;
-        completed = true;
+        setCompleted();
     }
 
     @Override
@@ -213,18 +218,21 @@ public void setContent(InputStream inputStream) throws IOException {
         while (read > 0) {
             byteBuffer.position(read).flip();
             written += localfileChannel.write(byteBuffer);
+            checkSize(written);
             read = inputStream.read(bytes);
         }
         localfileChannel.force(false);
         localfileChannel.close();
         size = written;
         if (definedSize > 0 && definedSize < size) {
-            file.delete();
+            if (!file.delete()) {
+                logger.warn("Failed to delete: {}", file);
+            }
             file = null;
             throw new IOException("Out of size: " + size + " > " + definedSize);
         }
         isRenamed = true;
-        completed = true;
+        setCompleted();
     }
 
     @Override
@@ -240,7 +248,9 @@ public void delete() {
         }
         if (! isRenamed) {
             if (file != null && file.exists()) {
-                file.delete();
+                if (!file.delete()) {
+                    logger.warn("Failed to delete: {}", file);
+                }
             }
             file = null;
         }
@@ -342,12 +352,16 @@ public boolean renameTo(File dest) throws IOException {
             in.close();
             out.close();
             if (position == size) {
-                file.delete();
+                if (!file.delete()) {
+                    logger.warn("Failed to delete: {}", file);
+                }
                 file = dest;
                 isRenamed = true;
                 return true;
             } else {
-                dest.delete();
+                if (!dest.delete()) {
+                    logger.warn("Failed to delete: {}", dest);
+                }
                 return false;
             }
         }
@@ -382,4 +396,14 @@ private static byte[] readFrom(File src) throws IOException {
     public File getFile() throws IOException {
         return file;
     }
+
+    @Override
+    public HttpData touch() {
+        return this;
+    }
+
+    @Override
+    public HttpData touch(Object hint) {
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
index 5a3af0e6adf2..ae16b2a627f1 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
@@ -32,11 +32,12 @@ public abstract class AbstractHttpData extends AbstractReferenceCounted implemen
     private static final Pattern STRIP_PATTERN = Pattern.compile("(?:^\\s+|\\s+$|\\n)");
     private static final Pattern REPLACE_PATTERN = Pattern.compile("[\\r\\t]");
 
-    protected final String name;
+    private final String name;
     protected long definedSize;
     protected long size;
-    protected Charset charset = HttpConstants.DEFAULT_CHARSET;
-    protected boolean completed;
+    private Charset charset = HttpConstants.DEFAULT_CHARSET;
+    private boolean completed;
+    private long maxSize = DefaultHttpDataFactory.MAXSIZE;
 
     protected AbstractHttpData(String name, Charset charset, long size) {
         if (name == null) {
@@ -57,6 +58,21 @@ protected AbstractHttpData(String name, Charset charset, long size) {
         definedSize = size;
     }
 
+    @Override
+    public long getMaxSize() { return maxSize; }
+
+    @Override
+    public void setMaxSize(long maxSize) {
+        this.maxSize = maxSize;
+    }
+
+    @Override
+    public void checkSize(long newSize) throws IOException {
+        if (maxSize >= 0 && newSize > maxSize) {
+            throw new IOException("Size exceed allowed maximum capacity");
+        }
+    }
+
     @Override
     public String getName() {
         return name;
@@ -67,6 +83,10 @@ public boolean isCompleted() {
         return completed;
     }
 
+    protected void setCompleted() {
+        completed = true;
+    }
+
     @Override
     public Charset getCharset() {
         return charset;
@@ -110,4 +130,10 @@ public HttpData retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public abstract HttpData touch();
+
+    @Override
+    public abstract HttpData touch(Object hint);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
index 929226b8e2a3..e0870e11f628 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
@@ -37,7 +37,6 @@ public abstract class AbstractMemoryHttpData extends AbstractHttpData {
 
     private ByteBuf byteBuf;
     private int chunkPosition;
-    protected boolean isRenamed;
 
     protected AbstractMemoryHttpData(String name, Charset charset, long size) {
         super(name, charset, size);
@@ -49,6 +48,7 @@ public void setContent(ByteBuf buffer) throws IOException {
             throw new NullPointerException("buffer");
         }
         long localsize = buffer.readableBytes();
+        checkSize(localsize);
         if (definedSize > 0 && definedSize < localsize) {
             throw new IOException("Out of size: " + localsize + " > " +
                     definedSize);
@@ -58,7 +58,7 @@ public void setContent(ByteBuf buffer) throws IOException {
         }
         byteBuf = buffer;
         size = localsize;
-        completed = true;
+        setCompleted();
     }
 
     @Override
@@ -73,6 +73,7 @@ public void setContent(InputStream inputStream) throws IOException {
         while (read > 0) {
             buffer.writeBytes(bytes, 0, read);
             written += read;
+            checkSize(written);
             read = inputStream.read(bytes);
         }
         size = written;
@@ -83,7 +84,7 @@ public void setContent(InputStream inputStream) throws IOException {
             byteBuf.release();
         }
         byteBuf = buffer;
-        completed = true;
+        setCompleted();
     }
 
     @Override
@@ -91,6 +92,7 @@ public void addContent(ByteBuf buffer, boolean last)
             throws IOException {
         if (buffer != null) {
             long localsize = buffer.readableBytes();
+            checkSize(size + localsize);
             if (definedSize > 0 && definedSize < size + localsize) {
                 throw new IOException("Out of size: " + (size + localsize) +
                         " > " + definedSize);
@@ -110,7 +112,7 @@ public void addContent(ByteBuf buffer, boolean last)
             }
         }
         if (last) {
-            completed = true;
+            setCompleted();
         } else {
             if (buffer == null) {
                 throw new NullPointerException("buffer");
@@ -128,6 +130,7 @@ public void setContent(File file) throws IOException {
             throw new IllegalArgumentException(
                     "File too big to be loaded in memory");
         }
+        checkSize(newsize);
         FileInputStream inputStream = new FileInputStream(file);
         FileChannel fileChannel = inputStream.getChannel();
         byte[] array = new byte[(int) newsize];
@@ -144,7 +147,7 @@ public void setContent(File file) throws IOException {
         }
         byteBuf = wrappedBuffer(Integer.MAX_VALUE, byteBuffer);
         size = newsize;
-        completed = true;
+        setCompleted();
     }
 
     @Override
@@ -223,8 +226,9 @@ public boolean renameTo(File dest) throws IOException {
         }
         if (byteBuf == null) {
             // empty file
-            dest.createNewFile();
-            isRenamed = true;
+            if (!dest.createNewFile()) {
+                throw new IOException("file exists already: " + dest);
+            }
             return true;
         }
         int length = byteBuf.readableBytes();
@@ -246,7 +250,6 @@ public boolean renameTo(File dest) throws IOException {
         fileChannel.force(false);
         fileChannel.close();
         outputStream.close();
-        isRenamed = true;
         return written == length;
     }
 
@@ -254,4 +257,17 @@ public boolean renameTo(File dest) throws IOException {
     public File getFile() throws IOException {
         throw new IOException("Not represented by a file");
     }
+
+    @Override
+    public HttpData touch() {
+        return touch(null);
+    }
+
+    @Override
+    public HttpData touch(Object hint) {
+        if (byteBuf != null) {
+            byteBuf.touch(hint);
+        }
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
index 365c18f67e78..a2060e732732 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
@@ -42,4 +42,10 @@ public interface Attribute extends HttpData {
 
     @Override
     Attribute retain(int increment);
+
+    @Override
+    Attribute touch();
+
+    @Override
+    Attribute touch(Object hint);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java
index afccf2607923..fb46572e13e6 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java
@@ -18,7 +18,7 @@
 import java.io.Serializable;
 import java.util.Comparator;
 
-final class CaseIgnoringComparator implements Comparator<String>, Serializable {
+final class CaseIgnoringComparator implements Comparator<CharSequence>, Serializable {
 
     private static final long serialVersionUID = 4582133183775373862L;
 
@@ -28,11 +28,28 @@ private CaseIgnoringComparator() {
     }
 
     @Override
-    public int compare(String o1, String o2) {
-        return o1.compareToIgnoreCase(o2);
+    public int compare(CharSequence o1, CharSequence o2) {
+        int o1Length = o1.length();
+        int o2Length = o2.length();
+        int min = Math.min(o1Length, o2Length);
+        for (int i = 0; i < min; i++) {
+            char c1 = o1.charAt(i);
+            char c2 = o2.charAt(i);
+            if (c1 != c2) {
+                c1 = Character.toUpperCase(c1);
+                c2 = Character.toUpperCase(c2);
+                if (c1 != c2) {
+                    c1 = Character.toLowerCase(c1);
+                    c2 = Character.toLowerCase(c2);
+                    if (c1 != c2) {
+                        return c1 - c2;
+                    }
+                }
+            }
+        }
+        return o1Length - o2Length;
     }
 
-    @SuppressWarnings("MethodMayBeStatic")
     private Object readResolve() {
         return INSTANCE;
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java
index af4655385e37..6391f649f57f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java
@@ -15,14 +15,17 @@
  */
 package io.netty.handler.codec.http.multipart;
 
+import io.netty.handler.codec.http.HttpConstants;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 /**
  * Default factory giving Attribute and FileUpload according to constructor
@@ -33,10 +36,15 @@
  * according to the constructor.
  */
 public class DefaultHttpDataFactory implements HttpDataFactory {
+
     /**
      * Proposed default MINSIZE as 16 KB.
      */
     public static final long MINSIZE = 0x4000;
+    /**
+     * Proposed default MAXSIZE = -1 as UNLIMITED
+     */
+    public static final long MAXSIZE = -1;
 
     private final boolean useDisk;
 
@@ -44,8 +52,12 @@ public class DefaultHttpDataFactory implements HttpDataFactory {
 
     private long minSize;
 
+    private long maxSize = MAXSIZE;
+
+    private Charset charset = HttpConstants.DEFAULT_CHARSET;
+
     /**
-     * Keep all HttpDatas until cleanAllHttpDatas() is called.
+     * Keep all HttpDatas until cleanAllHttpData() is called.
      */
     private final Map<HttpRequest, List<HttpData>> requestFileDeleteMap = PlatformDependent.newConcurrentHashMap();
 
@@ -59,6 +71,11 @@ public DefaultHttpDataFactory() {
         minSize = MINSIZE;
     }
 
+    public DefaultHttpDataFactory(Charset charset) {
+        this();
+        this.charset = charset;
+    }
+
     /**
      * HttpData will be always on Disk if useDisk is True, else always in Memory if False
      */
@@ -67,6 +84,10 @@ public DefaultHttpDataFactory(boolean useDisk) {
         checkSize = false;
     }
 
+    public DefaultHttpDataFactory(boolean useDisk, Charset charset) {
+        this(useDisk);
+        this.charset = charset;
+    }
     /**
      * HttpData will be on Disk if the size of the file is greater than minSize, else it
      * will be in memory. The type will be Mixed.
@@ -77,6 +98,16 @@ public DefaultHttpDataFactory(long minSize) {
         this.minSize = minSize;
     }
 
+    public DefaultHttpDataFactory(long minSize, Charset charset) {
+        this(minSize);
+        this.charset = charset;
+    }
+
+    @Override
+    public void setMaxLimit(long maxSize) {
+        this.maxSize = maxSize;
+    }
+
     /**
      * @return the associated list of Files for the request
      */
@@ -92,18 +123,33 @@ private List<HttpData> getList(HttpRequest request) {
     @Override
     public Attribute createAttribute(HttpRequest request, String name) {
         if (useDisk) {
-            Attribute attribute = new DiskAttribute(name);
+            Attribute attribute = new DiskAttribute(name, charset);
+            attribute.setMaxSize(maxSize);
             List<HttpData> fileToDelete = getList(request);
             fileToDelete.add(attribute);
             return attribute;
         }
         if (checkSize) {
-            Attribute attribute = new MixedAttribute(name, minSize);
+            Attribute attribute = new MixedAttribute(name, minSize, charset);
+            attribute.setMaxSize(maxSize);
             List<HttpData> fileToDelete = getList(request);
             fileToDelete.add(attribute);
             return attribute;
         }
-        return new MemoryAttribute(name);
+        MemoryAttribute attribute = new MemoryAttribute(name);
+        attribute.setMaxSize(maxSize);
+        return attribute;
+    }
+
+    /**
+     * Utility method
+     */
+    private static void checkHttpDataSize(HttpData data) {
+        try {
+            data.checkSize(data.length());
+        } catch (IOException ignored) {
+            throw new IllegalArgumentException("Attribute bigger than maxSize allowed");
+        }
     }
 
     @Override
@@ -111,23 +157,31 @@ public Attribute createAttribute(HttpRequest request, String name, String value)
         if (useDisk) {
             Attribute attribute;
             try {
-                attribute = new DiskAttribute(name, value);
+                attribute = new DiskAttribute(name, value, charset);
+                attribute.setMaxSize(maxSize);
             } catch (IOException e) {
                 // revert to Mixed mode
-                attribute = new MixedAttribute(name, value, minSize);
+                attribute = new MixedAttribute(name, value, minSize, charset);
+                attribute.setMaxSize(maxSize);
             }
+            checkHttpDataSize(attribute);
             List<HttpData> fileToDelete = getList(request);
             fileToDelete.add(attribute);
             return attribute;
         }
         if (checkSize) {
-            Attribute attribute = new MixedAttribute(name, value, minSize);
+            Attribute attribute = new MixedAttribute(name, value, minSize, charset);
+            attribute.setMaxSize(maxSize);
+            checkHttpDataSize(attribute);
             List<HttpData> fileToDelete = getList(request);
             fileToDelete.add(attribute);
             return attribute;
         }
         try {
-            return new MemoryAttribute(name, value);
+            MemoryAttribute attribute = new MemoryAttribute(name, value, charset);
+            attribute.setMaxSize(maxSize);
+            checkHttpDataSize(attribute);
+            return attribute;
         } catch (IOException e) {
             throw new IllegalArgumentException(e);
         }
@@ -140,6 +194,8 @@ public FileUpload createFileUpload(HttpRequest request, String name, String file
         if (useDisk) {
             FileUpload fileUpload = new DiskFileUpload(name, filename, contentType,
                     contentTransferEncoding, charset, size);
+            fileUpload.setMaxSize(maxSize);
+            checkHttpDataSize(fileUpload);
             List<HttpData> fileToDelete = getList(request);
             fileToDelete.add(fileUpload);
             return fileUpload;
@@ -147,12 +203,17 @@ public FileUpload createFileUpload(HttpRequest request, String name, String file
         if (checkSize) {
             FileUpload fileUpload = new MixedFileUpload(name, filename, contentType,
                     contentTransferEncoding, charset, size, minSize);
+            fileUpload.setMaxSize(maxSize);
+            checkHttpDataSize(fileUpload);
             List<HttpData> fileToDelete = getList(request);
             fileToDelete.add(fileUpload);
             return fileUpload;
         }
-        return new MemoryFileUpload(name, filename, contentType,
+        MemoryFileUpload fileUpload = new MemoryFileUpload(name, filename, contentType,
                 contentTransferEncoding, charset, size);
+        fileUpload.setMaxSize(maxSize);
+        checkHttpDataSize(fileUpload);
+        return fileUpload;
     }
 
     @Override
@@ -164,7 +225,7 @@ public void removeHttpDataFromClean(HttpRequest request, InterfaceHttpData data)
     }
 
     @Override
-    public void cleanRequestHttpDatas(HttpRequest request) {
+    public void cleanRequestHttpData(HttpRequest request) {
         List<HttpData> fileToDelete = requestFileDeleteMap.remove(request);
         if (fileToDelete != null) {
             for (HttpData data: fileToDelete) {
@@ -175,16 +236,29 @@ public void cleanRequestHttpDatas(HttpRequest request) {
     }
 
     @Override
-    public void cleanAllHttpDatas() {
-        for (HttpRequest request : requestFileDeleteMap.keySet()) {
-            List<HttpData> fileToDelete = requestFileDeleteMap.get(request);
+    public void cleanAllHttpData() {
+        Iterator<Entry<HttpRequest, List<HttpData>>> i = requestFileDeleteMap.entrySet().iterator();
+        while (i.hasNext()) {
+            Entry<HttpRequest, List<HttpData>> e = i.next();
+            i.remove();
+
+            List<HttpData> fileToDelete = e.getValue();
             if (fileToDelete != null) {
-                for (HttpData data: fileToDelete) {
+                for (HttpData data : fileToDelete) {
                     data.delete();
                 }
                 fileToDelete.clear();
             }
-            requestFileDeleteMap.remove(request);
         }
     }
+
+    @Override
+    public void cleanRequestHttpDatas(HttpRequest request) {
+        cleanRequestHttpData(request);
+    }
+
+    @Override
+    public void cleanAllHttpDatas() {
+        cleanAllHttpData();
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java
index 28ac87044bdf..5c800bdd46f9 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.http.HttpConstants;
 
 import java.io.IOException;
+import java.nio.charset.Charset;
 
 import static io.netty.buffer.Unpooled.*;
 
@@ -39,11 +40,19 @@ public class DiskAttribute extends AbstractDiskHttpData implements Attribute {
      * Constructor used for huge Attribute
      */
     public DiskAttribute(String name) {
-        super(name, HttpConstants.DEFAULT_CHARSET, 0);
+        this(name, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    public DiskAttribute(String name, Charset charset) {
+        super(name, charset, 0);
     }
 
     public DiskAttribute(String name, String value) throws IOException {
-        super(name, HttpConstants.DEFAULT_CHARSET, 0); // Attribute have no default size
+        this(name, value, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    public DiskAttribute(String name, String value, Charset charset) throws IOException {
+        super(name, charset, 0); // Attribute have no default size
         setValue(value);
     }
 
@@ -55,7 +64,7 @@ public HttpDataType getHttpDataType() {
     @Override
     public String getValue() throws IOException {
         byte [] bytes = get();
-        return new String(bytes, charset.name());
+        return new String(bytes, getCharset());
     }
 
     @Override
@@ -63,7 +72,8 @@ public void setValue(String value) throws IOException {
         if (value == null) {
             throw new NullPointerException("value");
         }
-        byte [] bytes = value.getBytes(charset.name());
+        byte [] bytes = value.getBytes(getCharset());
+        checkSize(bytes.length);
         ByteBuf buffer = wrappedBuffer(bytes);
         if (definedSize > 0) {
             definedSize = buffer.readableBytes();
@@ -74,6 +84,7 @@ public void setValue(String value) throws IOException {
     @Override
     public void addContent(ByteBuf buffer, boolean last) throws IOException {
         int localsize = buffer.readableBytes();
+        checkSize(size + localsize);
         if (definedSize > 0 && definedSize < size + localsize) {
             definedSize = size + localsize;
         }
@@ -111,7 +122,7 @@ public String toString() {
         try {
             return getName() + '=' + getValue();
         } catch (IOException e) {
-            return getName() + "=IoException";
+            return getName() + '=' + e;
         }
     }
 
@@ -181,4 +192,16 @@ public Attribute retain() {
         super.retain();
         return this;
     }
+
+    @Override
+    public Attribute touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public Attribute touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
index 69cb190deb78..41afd2ca9ddc 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
@@ -125,11 +125,18 @@ public void setContentTransferEncoding(String contentTransferEncoding) {
 
     @Override
     public String toString() {
+        File file = null;
+        try {
+            file = getFile();
+        } catch (IOException e) {
+            // Should not occur.
+        }
+
         return HttpPostBodyUtil.CONTENT_DISPOSITION + ": " +
             HttpPostBodyUtil.FORM_DATA + "; " + HttpPostBodyUtil.NAME + "=\"" + getName() +
                 "\"; " + HttpPostBodyUtil.FILENAME + "=\"" + filename + "\"\r\n" +
                 HttpHeaders.Names.CONTENT_TYPE + ": " + contentType +
-                (charset != null? "; " + HttpHeaders.Values.CHARSET + '=' + charset + "\r\n" : "\r\n") +
+                (getCharset() != null? "; " + HttpHeaders.Values.CHARSET + '=' + getCharset() + "\r\n" : "\r\n") +
                 HttpHeaders.Names.CONTENT_LENGTH + ": " + length() + "\r\n" +
                 "Completed: " + isCompleted() +
                 "\r\nIsInMemory: " + isInMemory() + "\r\nRealFile: " +
@@ -204,4 +211,16 @@ public FileUpload retain() {
         super.retain();
         return this;
     }
+
+    @Override
+    public FileUpload touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public FileUpload touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
index 9abc9bbf2b90..f519cf5c9013 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
@@ -67,4 +67,10 @@ public interface FileUpload extends HttpData {
 
     @Override
     FileUpload retain(int increment);
+
+    @Override
+    FileUpload touch();
+
+    @Override
+    FileUpload touch(Object hint);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
index 3a6c9b49d4c1..85ad3e67128d 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
@@ -27,6 +27,26 @@
  * Extended interface for InterfaceHttpData
  */
 public interface HttpData extends InterfaceHttpData, ByteBufHolder {
+
+    /**
+     * Returns the maxSize for this HttpData.
+     */
+    long getMaxSize();
+
+    /**
+     * Set the maxSize for this HttpData. When limit will be reached, an exception will be raised.
+     * Setting it to (-1) means no limitation.
+     *
+     * By default, to be set from the HttpDataFactory.
+     */
+    void setMaxSize(long maxSize);
+
+    /**
+     * Check if the new size is not reaching the max limit allowed.
+     * The limit is always computed in term of bytes.
+     */
+    void checkSize(long newSize) throws IOException;
+
     /**
      * Set the content from the ChannelBuffer (erase any previous data)
      *
@@ -188,4 +208,10 @@ public interface HttpData extends InterfaceHttpData, ByteBufHolder {
 
     @Override
     HttpData retain(int increment);
+
+    @Override
+    HttpData touch();
+
+    @Override
+    HttpData touch(Object hint);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpDataFactory.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpDataFactory.java
index eceee401d1b7..650e6aa830e7 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpDataFactory.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpDataFactory.java
@@ -23,11 +23,18 @@
  * Interface to enable creation of InterfaceHttpData objects
  */
 public interface HttpDataFactory {
+
+    /**
+     * To set a max size limitation on fields. Exceeding it will generate an ErrorDataDecoderException.
+     * A value of -1 means no limitation (default).
+     */
+    void setMaxLimit(long max);
+
     /**
-    *
-    * @param request associated request
-    * @return a new Attribute with no value
-    */
+     *
+     * @param request associated request
+     * @return a new Attribute with no value
+     */
     Attribute createAttribute(HttpRequest request, String name);
 
     /**
@@ -57,10 +64,22 @@ FileUpload createFileUpload(HttpRequest request, String name, String filename,
      *
      * @param request associated request
      */
-    void cleanRequestHttpDatas(HttpRequest request);
+    void cleanRequestHttpData(HttpRequest request);
 
     /**
      * Remove all InterfaceHttpData from virtual File storage from clean list for all requests
      */
+    void cleanAllHttpData();
+
+    /**
+     * @deprecated Use {@link #cleanRequestHttpData(HttpRequest)} instead.
+     */
+    @Deprecated
+    void cleanRequestHttpDatas(HttpRequest request);
+
+    /**
+     * @deprecated Use {@link #cleanAllHttpData()} instead.
+     */
+    @Deprecated
     void cleanAllHttpDatas();
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
new file mode 100644
index 000000000000..10481919bcd2
--- /dev/null
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java
@@ -0,0 +1,1800 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.http.multipart;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.http.HttpConstants;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.codec.http.multipart.HttpPostBodyUtil.SeekAheadNoBackArrayException;
+import io.netty.handler.codec.http.multipart.HttpPostBodyUtil.SeekAheadOptimize;
+import io.netty.handler.codec.http.multipart.HttpPostBodyUtil.TransferEncodingMechanism;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.MultiPartStatus;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.NotEnoughDataDecoderException;
+import io.netty.util.internal.StringUtil;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static io.netty.buffer.Unpooled.*;
+
+/**
+ * This decoder will decode Body and can handle POST BODY.
+ *
+ * You <strong>MUST</strong> call {@link #destroy()} after completion to release all resources.
+ *
+ */
+public class HttpPostMultipartRequestDecoder implements InterfaceHttpPostRequestDecoder {
+    /**
+     * Factory used to create InterfaceHttpData
+     */
+    private final HttpDataFactory factory;
+
+    /**
+     * Request to decode
+     */
+    private final HttpRequest request;
+
+    /**
+     * Default charset to use
+     */
+    private Charset charset;
+
+    /**
+     * Does the last chunk already received
+     */
+    private boolean isLastChunk;
+
+    /**
+     * HttpDatas from Body
+     */
+    private final List<InterfaceHttpData> bodyListHttpData = new ArrayList<InterfaceHttpData>();
+
+    /**
+     * HttpDatas as Map from Body
+     */
+    private final Map<String, List<InterfaceHttpData>> bodyMapHttpData = new TreeMap<String, List<InterfaceHttpData>>(
+            CaseIgnoringComparator.INSTANCE);
+
+    /**
+     * The current channelBuffer
+     */
+    private ByteBuf undecodedChunk;
+
+    /**
+     * Body HttpDatas current position
+     */
+    private int bodyListHttpDataRank;
+
+    /**
+     * If multipart, this is the boundary for the flobal multipart
+     */
+    private String multipartDataBoundary;
+
+    /**
+     * If multipart, there could be internal multiparts (mixed) to the global
+     * multipart. Only one level is allowed.
+     */
+    private String multipartMixedBoundary;
+
+    /**
+     * Current getStatus
+     */
+    private MultiPartStatus currentStatus = MultiPartStatus.NOTSTARTED;
+
+    /**
+     * Used in Multipart
+     */
+    private Map<CharSequence, Attribute> currentFieldAttributes;
+
+    /**
+     * The current FileUpload that is currently in decode process
+     */
+    private FileUpload currentFileUpload;
+
+    /**
+     * The current Attribute that is currently in decode process
+     */
+    private Attribute currentAttribute;
+
+    private boolean destroyed;
+
+    private int discardThreshold = HttpPostRequestDecoder.DEFAULT_DISCARD_THRESHOLD;
+
+    /**
+     *
+     * @param request
+     *            the request to decode
+     * @throws NullPointerException
+     *             for request
+     * @throws ErrorDataDecoderException
+     *             if the default charset was wrong when decoding or other
+     *             errors
+     */
+    public HttpPostMultipartRequestDecoder(HttpRequest request) {
+        this(new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE), request, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    /**
+     *
+     * @param factory
+     *            the factory used to create InterfaceHttpData
+     * @param request
+     *            the request to decode
+     * @throws NullPointerException
+     *             for request or factory
+     * @throws ErrorDataDecoderException
+     *             if the default charset was wrong when decoding or other
+     *             errors
+     */
+    public HttpPostMultipartRequestDecoder(HttpDataFactory factory, HttpRequest request) {
+        this(factory, request, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    /**
+     *
+     * @param factory
+     *            the factory used to create InterfaceHttpData
+     * @param request
+     *            the request to decode
+     * @param charset
+     *            the charset to use as default
+     * @throws NullPointerException
+     *             for request or charset or factory
+     * @throws ErrorDataDecoderException
+     *             if the default charset was wrong when decoding or other
+     *             errors
+     */
+    public HttpPostMultipartRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset) {
+        if (factory == null) {
+            throw new NullPointerException("factory");
+        }
+        if (request == null) {
+            throw new NullPointerException("request");
+        }
+        if (charset == null) {
+            throw new NullPointerException("charset");
+        }
+        this.request = request;
+        this.charset = charset;
+        this.factory = factory;
+        // Fill default values
+
+        setMultipart(this.request.headers().get(HttpHeaders.Names.CONTENT_TYPE));
+        if (request instanceof HttpContent) {
+            // Offer automatically if the given request is als type of HttpContent
+            // See #1089
+            offer((HttpContent) request);
+        } else {
+            undecodedChunk = buffer();
+            parseBody();
+        }
+    }
+
+    /**
+     * Set from the request ContentType the multipartDataBoundary and the possible charset.
+     */
+    private void setMultipart(String contentType) {
+        String[] dataBoundary = HttpPostRequestDecoder.getMultipartDataBoundary(contentType);
+        if (dataBoundary != null) {
+            multipartDataBoundary = dataBoundary[0];
+            if (dataBoundary.length > 1 && dataBoundary[1] != null) {
+                charset = Charset.forName(dataBoundary[1]);
+            }
+        } else {
+            multipartDataBoundary = null;
+        }
+        currentStatus = MultiPartStatus.HEADERDELIMITER;
+    }
+
+    private void checkDestroyed() {
+        if (destroyed) {
+            throw new IllegalStateException(HttpPostMultipartRequestDecoder.class.getSimpleName()
+                    + " was destroyed already");
+        }
+    }
+
+    /**
+     * True if this request is a Multipart request
+     *
+     * @return True if this request is a Multipart request
+     */
+    @Override
+    public boolean isMultipart() {
+        checkDestroyed();
+        return true;
+    }
+
+    /**
+     * Set the amount of bytes after which read bytes in the buffer should be discarded.
+     * Setting this lower gives lower memory usage but with the overhead of more memory copies.
+     * Use {@code 0} to disable it.
+     */
+    @Override
+    public void setDiscardThreshold(int discardThreshold) {
+        if (discardThreshold < 0) {
+          throw new IllegalArgumentException("discardThreshold must be >= 0");
+        }
+        this.discardThreshold = discardThreshold;
+    }
+
+    /**
+     * Return the threshold in bytes after which read data in the buffer should be discarded.
+     */
+    @Override
+    public int getDiscardThreshold() {
+        return discardThreshold;
+    }
+
+    /**
+     * This getMethod returns a List of all HttpDatas from body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return the list of HttpDatas from Body part for POST getMethod
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks
+     */
+    @Override
+    public List<InterfaceHttpData> getBodyHttpDatas() {
+        checkDestroyed();
+
+        if (!isLastChunk) {
+            throw new NotEnoughDataDecoderException();
+        }
+        return bodyListHttpData;
+    }
+
+    /**
+     * This getMethod returns a List of all HttpDatas with the given name from
+     * body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return All Body HttpDatas with the given name (ignore case)
+     * @throws NotEnoughDataDecoderException
+     *             need more chunks
+     */
+    @Override
+    public List<InterfaceHttpData> getBodyHttpDatas(String name) {
+        checkDestroyed();
+
+        if (!isLastChunk) {
+            throw new NotEnoughDataDecoderException();
+        }
+        return bodyMapHttpData.get(name);
+    }
+
+    /**
+     * This getMethod returns the first InterfaceHttpData with the given name from
+     * body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return The first Body InterfaceHttpData with the given name (ignore
+     *         case)
+     * @throws NotEnoughDataDecoderException
+     *             need more chunks
+     */
+    @Override
+    public InterfaceHttpData getBodyHttpData(String name) {
+        checkDestroyed();
+
+        if (!isLastChunk) {
+            throw new NotEnoughDataDecoderException();
+        }
+        List<InterfaceHttpData> list = bodyMapHttpData.get(name);
+        if (list != null) {
+            return list.get(0);
+        }
+        return null;
+    }
+
+    /**
+     * Initialized the internals from a new chunk
+     *
+     * @param content
+     *            the new received chunk
+     * @throws ErrorDataDecoderException
+     *             if there is a problem with the charset decoding or other
+     *             errors
+     */
+    @Override
+    public HttpPostMultipartRequestDecoder offer(HttpContent content) {
+        checkDestroyed();
+
+        // Maybe we should better not copy here for performance reasons but this will need
+        // more care by the caller to release the content in a correct manner later
+        // So maybe something to optimize on a later stage
+        ByteBuf buf = content.content();
+        if (undecodedChunk == null) {
+            undecodedChunk = buf.copy();
+        } else {
+            undecodedChunk.writeBytes(buf);
+        }
+        if (content instanceof LastHttpContent) {
+            isLastChunk = true;
+        }
+        parseBody();
+        if (undecodedChunk != null && undecodedChunk.writerIndex() > discardThreshold) {
+            undecodedChunk.discardReadBytes();
+        }
+        return this;
+    }
+
+    /**
+     * True if at current getStatus, there is an available decoded
+     * InterfaceHttpData from the Body.
+     *
+     * This getMethod works for chunked and not chunked request.
+     *
+     * @return True if at current getStatus, there is a decoded InterfaceHttpData
+     * @throws EndOfDataDecoderException
+     *             No more data will be available
+     */
+    @Override
+    public boolean hasNext() {
+        checkDestroyed();
+
+        if (currentStatus == MultiPartStatus.EPILOGUE) {
+            // OK except if end of list
+            if (bodyListHttpDataRank >= bodyListHttpData.size()) {
+                throw new EndOfDataDecoderException();
+            }
+        }
+        return !bodyListHttpData.isEmpty() && bodyListHttpDataRank < bodyListHttpData.size();
+    }
+
+    /**
+     * Returns the next available InterfaceHttpData or null if, at the time it
+     * is called, there is no more available InterfaceHttpData. A subsequent
+     * call to offer(httpChunk) could enable more data.
+     *
+     * Be sure to call {@link InterfaceHttpData#release()} after you are done
+     * with processing to make sure to not leak any resources
+     *
+     * @return the next available InterfaceHttpData or null if none
+     * @throws EndOfDataDecoderException
+     *             No more data will be available
+     */
+    @Override
+    public InterfaceHttpData next() {
+        checkDestroyed();
+
+        if (hasNext()) {
+            return bodyListHttpData.get(bodyListHttpDataRank++);
+        }
+        return null;
+    }
+
+    /**
+     * This getMethod will parse as much as possible data and fill the list and map
+     *
+     * @throws ErrorDataDecoderException
+     *             if there is a problem with the charset decoding or other
+     *             errors
+     */
+    private void parseBody() {
+        if (currentStatus == MultiPartStatus.PREEPILOGUE || currentStatus == MultiPartStatus.EPILOGUE) {
+            if (isLastChunk) {
+                currentStatus = MultiPartStatus.EPILOGUE;
+            }
+            return;
+        }
+        parseBodyMultipart();
+    }
+
+    /**
+     * Utility function to add a new decoded data
+     */
+    protected void addHttpData(InterfaceHttpData data) {
+        if (data == null) {
+            return;
+        }
+        List<InterfaceHttpData> datas = bodyMapHttpData.get(data.getName());
+        if (datas == null) {
+            datas = new ArrayList<InterfaceHttpData>(1);
+            bodyMapHttpData.put(data.getName(), datas);
+        }
+        datas.add(data);
+        bodyListHttpData.add(data);
+    }
+
+    /**
+     * Parse the Body for multipart
+     *
+     * @throws ErrorDataDecoderException
+     *             if there is a problem with the charset decoding or other
+     *             errors
+     */
+    private void parseBodyMultipart() {
+        if (undecodedChunk == null || undecodedChunk.readableBytes() == 0) {
+            // nothing to decode
+            return;
+        }
+        InterfaceHttpData data = decodeMultipart(currentStatus);
+        while (data != null) {
+            addHttpData(data);
+            if (currentStatus == MultiPartStatus.PREEPILOGUE || currentStatus == MultiPartStatus.EPILOGUE) {
+                break;
+            }
+            data = decodeMultipart(currentStatus);
+        }
+    }
+
+    /**
+     * Decode a multipart request by pieces<br>
+     * <br>
+     * NOTSTARTED PREAMBLE (<br>
+     * (HEADERDELIMITER DISPOSITION (FIELD | FILEUPLOAD))*<br>
+     * (HEADERDELIMITER DISPOSITION MIXEDPREAMBLE<br>
+     * (MIXEDDELIMITER MIXEDDISPOSITION MIXEDFILEUPLOAD)+<br>
+     * MIXEDCLOSEDELIMITER)*<br>
+     * CLOSEDELIMITER)+ EPILOGUE<br>
+     *
+     * Inspired from HttpMessageDecoder
+     *
+     * @return the next decoded InterfaceHttpData or null if none until now.
+     * @throws ErrorDataDecoderException
+     *             if an error occurs
+     */
+    private InterfaceHttpData decodeMultipart(MultiPartStatus state) {
+        switch (state) {
+        case NOTSTARTED:
+            throw new ErrorDataDecoderException("Should not be called with the current getStatus");
+        case PREAMBLE:
+            // Content-type: multipart/form-data, boundary=AaB03x
+            throw new ErrorDataDecoderException("Should not be called with the current getStatus");
+        case HEADERDELIMITER: {
+            // --AaB03x or --AaB03x--
+            return findMultipartDelimiter(multipartDataBoundary, MultiPartStatus.DISPOSITION,
+                    MultiPartStatus.PREEPILOGUE);
+        }
+        case DISPOSITION: {
+            // content-disposition: form-data; name="field1"
+            // content-disposition: form-data; name="pics"; filename="file1.txt"
+            // and other immediate values like
+            // Content-type: image/gif
+            // Content-Type: text/plain
+            // Content-Type: text/plain; charset=ISO-8859-1
+            // Content-Transfer-Encoding: binary
+            // The following line implies a change of mode (mixed mode)
+            // Content-type: multipart/mixed, boundary=BbC04y
+            return findMultipartDisposition();
+        }
+        case FIELD: {
+            // Now get value according to Content-Type and Charset
+            Charset localCharset = null;
+            Attribute charsetAttribute = currentFieldAttributes.get(HttpHeaders.Values.CHARSET);
+            if (charsetAttribute != null) {
+                try {
+                    localCharset = Charset.forName(charsetAttribute.getValue());
+                } catch (IOException e) {
+                    throw new ErrorDataDecoderException(e);
+                }
+            }
+            Attribute nameAttribute = currentFieldAttributes.get(HttpPostBodyUtil.NAME);
+            if (currentAttribute == null) {
+                try {
+                    currentAttribute = factory.createAttribute(request,
+                            cleanString(nameAttribute.getValue()));
+                } catch (NullPointerException e) {
+                    throw new ErrorDataDecoderException(e);
+                } catch (IllegalArgumentException e) {
+                    throw new ErrorDataDecoderException(e);
+                } catch (IOException e) {
+                    throw new ErrorDataDecoderException(e);
+                }
+                if (localCharset != null) {
+                    currentAttribute.setCharset(localCharset);
+                }
+            }
+            // load data
+            try {
+                loadFieldMultipart(multipartDataBoundary);
+            } catch (NotEnoughDataDecoderException ignored) {
+                return null;
+            }
+            Attribute finalAttribute = currentAttribute;
+            currentAttribute = null;
+            currentFieldAttributes = null;
+            // ready to load the next one
+            currentStatus = MultiPartStatus.HEADERDELIMITER;
+            return finalAttribute;
+        }
+        case FILEUPLOAD: {
+            // eventually restart from existing FileUpload
+            return getFileUpload(multipartDataBoundary);
+        }
+        case MIXEDDELIMITER: {
+            // --AaB03x or --AaB03x--
+            // Note that currentFieldAttributes exists
+            return findMultipartDelimiter(multipartMixedBoundary, MultiPartStatus.MIXEDDISPOSITION,
+                    MultiPartStatus.HEADERDELIMITER);
+        }
+        case MIXEDDISPOSITION: {
+            return findMultipartDisposition();
+        }
+        case MIXEDFILEUPLOAD: {
+            // eventually restart from existing FileUpload
+            return getFileUpload(multipartMixedBoundary);
+        }
+        case PREEPILOGUE:
+            return null;
+        case EPILOGUE:
+            return null;
+        default:
+            throw new ErrorDataDecoderException("Shouldn't reach here.");
+        }
+    }
+
+    /**
+     * Skip control Characters
+     *
+     * @throws NotEnoughDataDecoderException
+     */
+    void skipControlCharacters() {
+        SeekAheadOptimize sao;
+        try {
+            sao = new SeekAheadOptimize(undecodedChunk);
+        } catch (SeekAheadNoBackArrayException ignored) {
+            try {
+                skipControlCharactersStandard();
+            } catch (IndexOutOfBoundsException e1) {
+                throw new NotEnoughDataDecoderException(e1);
+            }
+            return;
+        }
+
+        while (sao.pos < sao.limit) {
+            char c = (char) (sao.bytes[sao.pos++] & 0xFF);
+            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
+                sao.setReadPosition(1);
+                return;
+            }
+        }
+        throw new NotEnoughDataDecoderException("Access out of bounds");
+    }
+
+    void skipControlCharactersStandard() {
+        for (;;) {
+            char c = (char) undecodedChunk.readUnsignedByte();
+            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
+                undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Find the next Multipart Delimiter
+     *
+     * @param delimiter
+     *            delimiter to find
+     * @param dispositionStatus
+     *            the next getStatus if the delimiter is a start
+     * @param closeDelimiterStatus
+     *            the next getStatus if the delimiter is a close delimiter
+     * @return the next InterfaceHttpData if any
+     * @throws ErrorDataDecoderException
+     */
+    private InterfaceHttpData findMultipartDelimiter(String delimiter, MultiPartStatus dispositionStatus,
+            MultiPartStatus closeDelimiterStatus) {
+        // --AaB03x or --AaB03x--
+        int readerIndex = undecodedChunk.readerIndex();
+        try {
+            skipControlCharacters();
+        } catch (NotEnoughDataDecoderException ignored) {
+            undecodedChunk.readerIndex(readerIndex);
+            return null;
+        }
+        skipOneLine();
+        String newline;
+        try {
+            newline = readDelimiter(delimiter);
+        } catch (NotEnoughDataDecoderException ignored) {
+            undecodedChunk.readerIndex(readerIndex);
+            return null;
+        }
+        if (newline.equals(delimiter)) {
+            currentStatus = dispositionStatus;
+            return decodeMultipart(dispositionStatus);
+        }
+        if (newline.equals(delimiter + "--")) {
+            // CLOSEDELIMITER or MIXED CLOSEDELIMITER found
+            currentStatus = closeDelimiterStatus;
+            if (currentStatus == MultiPartStatus.HEADERDELIMITER) {
+                // MIXEDCLOSEDELIMITER
+                // end of the Mixed part
+                currentFieldAttributes = null;
+                return decodeMultipart(MultiPartStatus.HEADERDELIMITER);
+            }
+            return null;
+        }
+        undecodedChunk.readerIndex(readerIndex);
+        throw new ErrorDataDecoderException("No Multipart delimiter found");
+    }
+
+    /**
+     * Find the next Disposition
+     *
+     * @return the next InterfaceHttpData if any
+     * @throws ErrorDataDecoderException
+     */
+    private InterfaceHttpData findMultipartDisposition() {
+        int readerIndex = undecodedChunk.readerIndex();
+        if (currentStatus == MultiPartStatus.DISPOSITION) {
+            currentFieldAttributes = new TreeMap<CharSequence, Attribute>(CaseIgnoringComparator.INSTANCE);
+        }
+        // read many lines until empty line with newline found! Store all data
+        while (!skipOneLine()) {
+            String newline;
+            try {
+                skipControlCharacters();
+                newline = readLine();
+            } catch (NotEnoughDataDecoderException ignored) {
+                undecodedChunk.readerIndex(readerIndex);
+                return null;
+            }
+            String[] contents = splitMultipartHeader(newline);
+            if (contents[0].equalsIgnoreCase(HttpPostBodyUtil.CONTENT_DISPOSITION)) {
+                boolean checkSecondArg;
+                if (currentStatus == MultiPartStatus.DISPOSITION) {
+                    checkSecondArg = contents[1].equalsIgnoreCase(HttpPostBodyUtil.FORM_DATA);
+                } else {
+                    checkSecondArg = contents[1].equalsIgnoreCase(HttpPostBodyUtil.ATTACHMENT)
+                            || contents[1].equalsIgnoreCase(HttpPostBodyUtil.FILE);
+                }
+                if (checkSecondArg) {
+                    // read next values and store them in the map as Attribute
+                    for (int i = 2; i < contents.length; i++) {
+                        String[] values = StringUtil.split(contents[i], '=');
+                        Attribute attribute;
+                        try {
+                            String name = cleanString(values[0]);
+                            String value = values[1];
+
+                            // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html
+                            if (HttpPostBodyUtil.FILENAME.equals(name)) {
+                                // filename value is quoted string so strip them
+                                value = value.substring(1, value.length() - 1);
+                            } else {
+                                // otherwise we need to clean the value
+                                value = cleanString(value);
+                            }
+                            attribute = factory.createAttribute(request, name, value);
+                        } catch (NullPointerException e) {
+                            throw new ErrorDataDecoderException(e);
+                        } catch (IllegalArgumentException e) {
+                            throw new ErrorDataDecoderException(e);
+                        }
+                        currentFieldAttributes.put(attribute.getName(), attribute);
+                    }
+                }
+            } else if (contents[0].equalsIgnoreCase(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING)) {
+                Attribute attribute;
+                try {
+                    attribute = factory.createAttribute(request, HttpHeaders.Names.CONTENT_TRANSFER_ENCODING,
+                            cleanString(contents[1]));
+                } catch (NullPointerException e) {
+                    throw new ErrorDataDecoderException(e);
+                } catch (IllegalArgumentException e) {
+                    throw new ErrorDataDecoderException(e);
+                }
+                currentFieldAttributes.put(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING, attribute);
+            } else if (contents[0].equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH)) {
+                Attribute attribute;
+                try {
+                    attribute = factory.createAttribute(request, HttpHeaders.Names.CONTENT_LENGTH,
+                            cleanString(contents[1]));
+                } catch (NullPointerException e) {
+                    throw new ErrorDataDecoderException(e);
+                } catch (IllegalArgumentException e) {
+                    throw new ErrorDataDecoderException(e);
+                }
+                currentFieldAttributes.put(HttpHeaders.Names.CONTENT_LENGTH, attribute);
+            } else if (contents[0].equalsIgnoreCase(HttpHeaders.Names.CONTENT_TYPE)) {
+                // Take care of possible "multipart/mixed"
+                if (contents[1].equalsIgnoreCase(HttpPostBodyUtil.MULTIPART_MIXED)) {
+                    if (currentStatus == MultiPartStatus.DISPOSITION) {
+                        String[] values = StringUtil.split(contents[2], '=');
+                        multipartMixedBoundary = "--" + values[1];
+                        currentStatus = MultiPartStatus.MIXEDDELIMITER;
+                        return decodeMultipart(MultiPartStatus.MIXEDDELIMITER);
+                    } else {
+                        throw new ErrorDataDecoderException("Mixed Multipart found in a previous Mixed Multipart");
+                    }
+                } else {
+                    for (int i = 1; i < contents.length; i++) {
+                        if (contents[i].toLowerCase().startsWith(HttpHeaders.Values.CHARSET)) {
+                            String[] values = StringUtil.split(contents[i], '=');
+                            Attribute attribute;
+                            try {
+                                attribute = factory.createAttribute(request, HttpHeaders.Values.CHARSET,
+                                        cleanString(values[1]));
+                            } catch (NullPointerException e) {
+                                throw new ErrorDataDecoderException(e);
+                            } catch (IllegalArgumentException e) {
+                                throw new ErrorDataDecoderException(e);
+                            }
+                            currentFieldAttributes.put(HttpHeaders.Values.CHARSET, attribute);
+                        } else {
+                            Attribute attribute;
+                            try {
+                                attribute = factory.createAttribute(request,
+                                        cleanString(contents[0]), contents[i]);
+                            } catch (NullPointerException e) {
+                                throw new ErrorDataDecoderException(e);
+                            } catch (IllegalArgumentException e) {
+                                throw new ErrorDataDecoderException(e);
+                            }
+                            currentFieldAttributes.put(attribute.getName(), attribute);
+                        }
+                    }
+                }
+            } else {
+                throw new ErrorDataDecoderException("Unknown Params: " + newline);
+            }
+        }
+        // Is it a FileUpload
+        Attribute filenameAttribute = currentFieldAttributes.get(HttpPostBodyUtil.FILENAME);
+        if (currentStatus == MultiPartStatus.DISPOSITION) {
+            if (filenameAttribute != null) {
+                // FileUpload
+                currentStatus = MultiPartStatus.FILEUPLOAD;
+                // do not change the buffer position
+                return decodeMultipart(MultiPartStatus.FILEUPLOAD);
+            } else {
+                // Field
+                currentStatus = MultiPartStatus.FIELD;
+                // do not change the buffer position
+                return decodeMultipart(MultiPartStatus.FIELD);
+            }
+        } else {
+            if (filenameAttribute != null) {
+                // FileUpload
+                currentStatus = MultiPartStatus.MIXEDFILEUPLOAD;
+                // do not change the buffer position
+                return decodeMultipart(MultiPartStatus.MIXEDFILEUPLOAD);
+            } else {
+                // Field is not supported in MIXED mode
+                throw new ErrorDataDecoderException("Filename not found");
+            }
+        }
+    }
+
+    /**
+     * Get the FileUpload (new one or current one)
+     *
+     * @param delimiter
+     *            the delimiter to use
+     * @return the InterfaceHttpData if any
+     * @throws ErrorDataDecoderException
+     */
+    protected InterfaceHttpData getFileUpload(String delimiter) {
+        // eventually restart from existing FileUpload
+        // Now get value according to Content-Type and Charset
+        Attribute encoding = currentFieldAttributes.get(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING);
+        Charset localCharset = charset;
+        // Default
+        TransferEncodingMechanism mechanism = TransferEncodingMechanism.BIT7;
+        if (encoding != null) {
+            String code;
+            try {
+                code = encoding.getValue().toLowerCase();
+            } catch (IOException e) {
+                throw new ErrorDataDecoderException(e);
+            }
+            if (code.equals(HttpPostBodyUtil.TransferEncodingMechanism.BIT7.value())) {
+                localCharset = HttpPostBodyUtil.US_ASCII;
+            } else if (code.equals(HttpPostBodyUtil.TransferEncodingMechanism.BIT8.value())) {
+                localCharset = HttpPostBodyUtil.ISO_8859_1;
+                mechanism = TransferEncodingMechanism.BIT8;
+            } else if (code.equals(HttpPostBodyUtil.TransferEncodingMechanism.BINARY.value())) {
+                // no real charset, so let the default
+                mechanism = TransferEncodingMechanism.BINARY;
+            } else {
+                throw new ErrorDataDecoderException("TransferEncoding Unknown: " + code);
+            }
+        }
+        Attribute charsetAttribute = currentFieldAttributes.get(HttpHeaders.Values.CHARSET);
+        if (charsetAttribute != null) {
+            try {
+                localCharset = Charset.forName(charsetAttribute.getValue());
+            } catch (IOException e) {
+                throw new ErrorDataDecoderException(e);
+            }
+        }
+        if (currentFileUpload == null) {
+            Attribute filenameAttribute = currentFieldAttributes.get(HttpPostBodyUtil.FILENAME);
+            Attribute nameAttribute = currentFieldAttributes.get(HttpPostBodyUtil.NAME);
+            Attribute contentTypeAttribute = currentFieldAttributes.get(HttpHeaders.Names.CONTENT_TYPE);
+            if (contentTypeAttribute == null) {
+                throw new ErrorDataDecoderException("Content-Type is absent but required");
+            }
+            Attribute lengthAttribute = currentFieldAttributes.get(HttpHeaders.Names.CONTENT_LENGTH);
+            long size;
+            try {
+                size = lengthAttribute != null ? Long.parseLong(lengthAttribute.getValue()) : 0L;
+            } catch (IOException e) {
+                throw new ErrorDataDecoderException(e);
+            } catch (NumberFormatException ignored) {
+                size = 0;
+            }
+            try {
+                currentFileUpload = factory.createFileUpload(request,
+                        cleanString(nameAttribute.getValue()), cleanString(filenameAttribute.getValue()),
+                        contentTypeAttribute.getValue(), mechanism.value(), localCharset,
+                        size);
+            } catch (NullPointerException e) {
+                throw new ErrorDataDecoderException(e);
+            } catch (IllegalArgumentException e) {
+                throw new ErrorDataDecoderException(e);
+            } catch (IOException e) {
+                throw new ErrorDataDecoderException(e);
+            }
+        }
+        // load data as much as possible
+        try {
+            readFileUploadByteMultipart(delimiter);
+        } catch (NotEnoughDataDecoderException e) {
+            // do not change the buffer position
+            // since some can be already saved into FileUpload
+            // So do not change the currentStatus
+            return null;
+        }
+        if (currentFileUpload.isCompleted()) {
+            // ready to load the next one
+            if (currentStatus == MultiPartStatus.FILEUPLOAD) {
+                currentStatus = MultiPartStatus.HEADERDELIMITER;
+                currentFieldAttributes = null;
+            } else {
+                currentStatus = MultiPartStatus.MIXEDDELIMITER;
+                cleanMixedAttributes();
+            }
+            FileUpload fileUpload = currentFileUpload;
+            currentFileUpload = null;
+            return fileUpload;
+        }
+        // do not change the buffer position
+        // since some can be already saved into FileUpload
+        // So do not change the currentStatus
+        return null;
+    }
+
+    /**
+     * Destroy the {@link HttpPostMultipartRequestDecoder} and release all it resources. After this method
+     * was called it is not possible to operate on it anymore.
+     */
+    @Override
+    public void destroy() {
+        checkDestroyed();
+        cleanFiles();
+        destroyed = true;
+
+        if (undecodedChunk != null && undecodedChunk.refCnt() > 0) {
+            undecodedChunk.release();
+            undecodedChunk = null;
+        }
+
+        // release all data which was not yet pulled
+        for (int i = bodyListHttpDataRank; i < bodyListHttpData.size(); i++) {
+            bodyListHttpData.get(i).release();
+        }
+    }
+
+    /**
+     * Clean all HttpDatas (on Disk) for the current request.
+     */
+    @Override
+    public void cleanFiles() {
+        checkDestroyed();
+
+        factory.cleanRequestHttpData(request);
+    }
+
+    /**
+     * Remove the given FileUpload from the list of FileUploads to clean
+     */
+    @Override
+    public void removeHttpDataFromClean(InterfaceHttpData data) {
+        checkDestroyed();
+
+        factory.removeHttpDataFromClean(request, data);
+    }
+
+    /**
+     * Remove all Attributes that should be cleaned between two FileUpload in
+     * Mixed mode
+     */
+    private void cleanMixedAttributes() {
+        currentFieldAttributes.remove(HttpHeaders.Values.CHARSET);
+        currentFieldAttributes.remove(HttpHeaders.Names.CONTENT_LENGTH);
+        currentFieldAttributes.remove(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING);
+        currentFieldAttributes.remove(HttpHeaders.Names.CONTENT_TYPE);
+        currentFieldAttributes.remove(HttpPostBodyUtil.FILENAME);
+    }
+
+    /**
+     * Read one line up to the CRLF or LF
+     *
+     * @return the String from one line
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks and reset the readerInder to the previous
+     *             value
+     */
+    private String readLineStandard() {
+        int readerIndex = undecodedChunk.readerIndex();
+        try {
+            ByteBuf line = buffer(64);
+
+            while (undecodedChunk.isReadable()) {
+                byte nextByte = undecodedChunk.readByte();
+                if (nextByte == HttpConstants.CR) {
+                    // check but do not changed readerIndex
+                    nextByte = undecodedChunk.getByte(undecodedChunk.readerIndex());
+                    if (nextByte == HttpConstants.LF) {
+                        // force read
+                        undecodedChunk.readByte();
+                        return line.toString(charset);
+                    } else {
+                        // Write CR (not followed by LF)
+                        line.writeByte(HttpConstants.CR);
+                    }
+                } else if (nextByte == HttpConstants.LF) {
+                    return line.toString(charset);
+                } else {
+                    line.writeByte(nextByte);
+                }
+            }
+        } catch (IndexOutOfBoundsException e) {
+            undecodedChunk.readerIndex(readerIndex);
+            throw new NotEnoughDataDecoderException(e);
+        }
+        undecodedChunk.readerIndex(readerIndex);
+        throw new NotEnoughDataDecoderException();
+    }
+
+    /**
+     * Read one line up to the CRLF or LF
+     *
+     * @return the String from one line
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks and reset the readerInder to the previous
+     *             value
+     */
+    private String readLine() {
+        SeekAheadOptimize sao;
+        try {
+            sao = new SeekAheadOptimize(undecodedChunk);
+        } catch (SeekAheadNoBackArrayException ignored) {
+            return readLineStandard();
+        }
+        int readerIndex = undecodedChunk.readerIndex();
+        try {
+            ByteBuf line = buffer(64);
+
+            while (sao.pos < sao.limit) {
+                byte nextByte = sao.bytes[sao.pos++];
+                if (nextByte == HttpConstants.CR) {
+                    if (sao.pos < sao.limit) {
+                        nextByte = sao.bytes[sao.pos++];
+                        if (nextByte == HttpConstants.LF) {
+                            sao.setReadPosition(0);
+                            return line.toString(charset);
+                        } else {
+                            // Write CR (not followed by LF)
+                            sao.pos--;
+                            line.writeByte(HttpConstants.CR);
+                        }
+                    } else {
+                        line.writeByte(nextByte);
+                    }
+                } else if (nextByte == HttpConstants.LF) {
+                    sao.setReadPosition(0);
+                    return line.toString(charset);
+                } else {
+                    line.writeByte(nextByte);
+                }
+            }
+        } catch (IndexOutOfBoundsException e) {
+            undecodedChunk.readerIndex(readerIndex);
+            throw new NotEnoughDataDecoderException(e);
+        }
+        undecodedChunk.readerIndex(readerIndex);
+        throw new NotEnoughDataDecoderException();
+    }
+
+    /**
+     * Read one line up to --delimiter or --delimiter-- and if existing the CRLF
+     * or LF Read one line up to --delimiter or --delimiter-- and if existing
+     * the CRLF or LF. Note that CRLF or LF are mandatory for opening delimiter
+     * (--delimiter) but not for closing delimiter (--delimiter--) since some
+     * clients does not include CRLF in this case.
+     *
+     * @param delimiter
+     *            of the form --string, such that '--' is already included
+     * @return the String from one line as the delimiter searched (opening or
+     *         closing)
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks and reset the readerInder to the previous
+     *             value
+     */
+    private String readDelimiterStandard(String delimiter) {
+        int readerIndex = undecodedChunk.readerIndex();
+        try {
+            StringBuilder sb = new StringBuilder(64);
+            int delimiterPos = 0;
+            int len = delimiter.length();
+            while (undecodedChunk.isReadable() && delimiterPos < len) {
+                byte nextByte = undecodedChunk.readByte();
+                if (nextByte == delimiter.charAt(delimiterPos)) {
+                    delimiterPos++;
+                    sb.append((char) nextByte);
+                } else {
+                    // delimiter not found so break here !
+                    undecodedChunk.readerIndex(readerIndex);
+                    throw new NotEnoughDataDecoderException();
+                }
+            }
+            // Now check if either opening delimiter or closing delimiter
+            if (undecodedChunk.isReadable()) {
+                byte nextByte = undecodedChunk.readByte();
+                // first check for opening delimiter
+                if (nextByte == HttpConstants.CR) {
+                    nextByte = undecodedChunk.readByte();
+                    if (nextByte == HttpConstants.LF) {
+                        return sb.toString();
+                    } else {
+                        // error since CR must be followed by LF
+                        // delimiter not found so break here !
+                        undecodedChunk.readerIndex(readerIndex);
+                        throw new NotEnoughDataDecoderException();
+                    }
+                } else if (nextByte == HttpConstants.LF) {
+                    return sb.toString();
+                } else if (nextByte == '-') {
+                    sb.append('-');
+                    // second check for closing delimiter
+                    nextByte = undecodedChunk.readByte();
+                    if (nextByte == '-') {
+                        sb.append('-');
+                        // now try to find if CRLF or LF there
+                        if (undecodedChunk.isReadable()) {
+                            nextByte = undecodedChunk.readByte();
+                            if (nextByte == HttpConstants.CR) {
+                                nextByte = undecodedChunk.readByte();
+                                if (nextByte == HttpConstants.LF) {
+                                    return sb.toString();
+                                } else {
+                                    // error CR without LF
+                                    // delimiter not found so break here !
+                                    undecodedChunk.readerIndex(readerIndex);
+                                    throw new NotEnoughDataDecoderException();
+                                }
+                            } else if (nextByte == HttpConstants.LF) {
+                                return sb.toString();
+                            } else {
+                                // No CRLF but ok however (Adobe Flash uploader)
+                                // minus 1 since we read one char ahead but
+                                // should not
+                                undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
+                                return sb.toString();
+                            }
+                        }
+                        // FIXME what do we do here?
+                        // either considering it is fine, either waiting for
+                        // more data to come?
+                        // lets try considering it is fine...
+                        return sb.toString();
+                    }
+                    // only one '-' => not enough
+                    // whatever now => error since incomplete
+                }
+            }
+        } catch (IndexOutOfBoundsException e) {
+            undecodedChunk.readerIndex(readerIndex);
+            throw new NotEnoughDataDecoderException(e);
+        }
+        undecodedChunk.readerIndex(readerIndex);
+        throw new NotEnoughDataDecoderException();
+    }
+
+    /**
+     * Read one line up to --delimiter or --delimiter-- and if existing the CRLF
+     * or LF. Note that CRLF or LF are mandatory for opening delimiter
+     * (--delimiter) but not for closing delimiter (--delimiter--) since some
+     * clients does not include CRLF in this case.
+     *
+     * @param delimiter
+     *            of the form --string, such that '--' is already included
+     * @return the String from one line as the delimiter searched (opening or
+     *         closing)
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks and reset the readerInder to the previous
+     *             value
+     */
+    private String readDelimiter(String delimiter) {
+        SeekAheadOptimize sao;
+        try {
+            sao = new SeekAheadOptimize(undecodedChunk);
+        } catch (SeekAheadNoBackArrayException ignored) {
+            return readDelimiterStandard(delimiter);
+        }
+        int readerIndex = undecodedChunk.readerIndex();
+        int delimiterPos = 0;
+        int len = delimiter.length();
+        try {
+            StringBuilder sb = new StringBuilder(64);
+            // check conformity with delimiter
+            while (sao.pos < sao.limit && delimiterPos < len) {
+                byte nextByte = sao.bytes[sao.pos++];
+                if (nextByte == delimiter.charAt(delimiterPos)) {
+                    delimiterPos++;
+                    sb.append((char) nextByte);
+                } else {
+                    // delimiter not found so break here !
+                    undecodedChunk.readerIndex(readerIndex);
+                    throw new NotEnoughDataDecoderException();
+                }
+            }
+            // Now check if either opening delimiter or closing delimiter
+            if (sao.pos < sao.limit) {
+                byte nextByte = sao.bytes[sao.pos++];
+                if (nextByte == HttpConstants.CR) {
+                    // first check for opening delimiter
+                    if (sao.pos < sao.limit) {
+                        nextByte = sao.bytes[sao.pos++];
+                        if (nextByte == HttpConstants.LF) {
+                            sao.setReadPosition(0);
+                            return sb.toString();
+                        } else {
+                            // error CR without LF
+                            // delimiter not found so break here !
+                            undecodedChunk.readerIndex(readerIndex);
+                            throw new NotEnoughDataDecoderException();
+                        }
+                    } else {
+                        // error since CR must be followed by LF
+                        // delimiter not found so break here !
+                        undecodedChunk.readerIndex(readerIndex);
+                        throw new NotEnoughDataDecoderException();
+                    }
+                } else if (nextByte == HttpConstants.LF) {
+                    // same first check for opening delimiter where LF used with
+                    // no CR
+                    sao.setReadPosition(0);
+                    return sb.toString();
+                } else if (nextByte == '-') {
+                    sb.append('-');
+                    // second check for closing delimiter
+                    if (sao.pos < sao.limit) {
+                        nextByte = sao.bytes[sao.pos++];
+                        if (nextByte == '-') {
+                            sb.append('-');
+                            // now try to find if CRLF or LF there
+                            if (sao.pos < sao.limit) {
+                                nextByte = sao.bytes[sao.pos++];
+                                if (nextByte == HttpConstants.CR) {
+                                    if (sao.pos < sao.limit) {
+                                        nextByte = sao.bytes[sao.pos++];
+                                        if (nextByte == HttpConstants.LF) {
+                                            sao.setReadPosition(0);
+                                            return sb.toString();
+                                        } else {
+                                            // error CR without LF
+                                            // delimiter not found so break here !
+                                            undecodedChunk.readerIndex(readerIndex);
+                                            throw new NotEnoughDataDecoderException();
+                                        }
+                                    } else {
+                                        // error CR without LF
+                                        // delimiter not found so break here !
+                                        undecodedChunk.readerIndex(readerIndex);
+                                        throw new NotEnoughDataDecoderException();
+                                    }
+                                } else if (nextByte == HttpConstants.LF) {
+                                    sao.setReadPosition(0);
+                                    return sb.toString();
+                                } else {
+                                    // No CRLF but ok however (Adobe Flash
+                                    // uploader)
+                                    // minus 1 since we read one char ahead but
+                                    // should not
+                                    sao.setReadPosition(1);
+                                    return sb.toString();
+                                }
+                            }
+                            // FIXME what do we do here?
+                            // either considering it is fine, either waiting for
+                            // more data to come?
+                            // lets try considering it is fine...
+                            sao.setReadPosition(0);
+                            return sb.toString();
+                        }
+                        // whatever now => error since incomplete
+                        // only one '-' => not enough or whatever not enough
+                        // element
+                    }
+                }
+            }
+        } catch (IndexOutOfBoundsException e) {
+            undecodedChunk.readerIndex(readerIndex);
+            throw new NotEnoughDataDecoderException(e);
+        }
+        undecodedChunk.readerIndex(readerIndex);
+        throw new NotEnoughDataDecoderException();
+    }
+
+    /**
+     * Read a FileUpload data as Byte (Binary) and add the bytes directly to the
+     * FileUpload. If the delimiter is found, the FileUpload is completed.
+     *
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks but do not reset the readerInder since some
+     *             values will be already added to the FileOutput
+     * @throws ErrorDataDecoderException
+     *             write IO error occurs with the FileUpload
+     */
+    private void readFileUploadByteMultipartStandard(String delimiter) {
+        int readerIndex = undecodedChunk.readerIndex();
+        // found the decoder limit
+        boolean newLine = true;
+        int index = 0;
+        int lastPosition = undecodedChunk.readerIndex();
+        boolean found = false;
+        while (undecodedChunk.isReadable()) {
+            byte nextByte = undecodedChunk.readByte();
+            if (newLine) {
+                // Check the delimiter
+                if (nextByte == delimiter.codePointAt(index)) {
+                    index++;
+                    if (delimiter.length() == index) {
+                        found = true;
+                        break;
+                    }
+                    continue;
+                } else {
+                    newLine = false;
+                    index = 0;
+                    // continue until end of line
+                    if (nextByte == HttpConstants.CR) {
+                        if (undecodedChunk.isReadable()) {
+                            nextByte = undecodedChunk.readByte();
+                            if (nextByte == HttpConstants.LF) {
+                                newLine = true;
+                                index = 0;
+                                lastPosition = undecodedChunk.readerIndex() - 2;
+                            } else {
+                                // save last valid position
+                                lastPosition = undecodedChunk.readerIndex() - 1;
+
+                                // Unread next byte.
+                                undecodedChunk.readerIndex(lastPosition);
+                            }
+                        }
+                    } else if (nextByte == HttpConstants.LF) {
+                        newLine = true;
+                        index = 0;
+                        lastPosition = undecodedChunk.readerIndex() - 1;
+                    } else {
+                        // save last valid position
+                        lastPosition = undecodedChunk.readerIndex();
+                    }
+                }
+            } else {
+                // continue until end of line
+                if (nextByte == HttpConstants.CR) {
+                    if (undecodedChunk.isReadable()) {
+                        nextByte = undecodedChunk.readByte();
+                        if (nextByte == HttpConstants.LF) {
+                            newLine = true;
+                            index = 0;
+                            lastPosition = undecodedChunk.readerIndex() - 2;
+                        } else {
+                            // save last valid position
+                            lastPosition = undecodedChunk.readerIndex() - 1;
+
+                            // Unread next byte.
+                            undecodedChunk.readerIndex(lastPosition);
+                        }
+                    }
+                } else if (nextByte == HttpConstants.LF) {
+                    newLine = true;
+                    index = 0;
+                    lastPosition = undecodedChunk.readerIndex() - 1;
+                } else {
+                    // save last valid position
+                    lastPosition = undecodedChunk.readerIndex();
+                }
+            }
+        }
+        ByteBuf buffer = undecodedChunk.copy(readerIndex, lastPosition - readerIndex);
+        if (found) {
+            // found so lastPosition is correct and final
+            try {
+                currentFileUpload.addContent(buffer, true);
+                // just before the CRLF and delimiter
+                undecodedChunk.readerIndex(lastPosition);
+            } catch (IOException e) {
+                throw new ErrorDataDecoderException(e);
+            }
+        } else {
+            // possibly the delimiter is partially found but still the last
+            // position is OK
+            try {
+                currentFileUpload.addContent(buffer, false);
+                // last valid char (not CR, not LF, not beginning of delimiter)
+                undecodedChunk.readerIndex(lastPosition);
+                throw new NotEnoughDataDecoderException();
+            } catch (IOException e) {
+                throw new ErrorDataDecoderException(e);
+            }
+        }
+    }
+
+    /**
+     * Read a FileUpload data as Byte (Binary) and add the bytes directly to the
+     * FileUpload. If the delimiter is found, the FileUpload is completed.
+     *
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks but do not reset the readerInder since some
+     *             values will be already added to the FileOutput
+     * @throws ErrorDataDecoderException
+     *             write IO error occurs with the FileUpload
+     */
+    private void readFileUploadByteMultipart(String delimiter) {
+        SeekAheadOptimize sao;
+        try {
+            sao = new SeekAheadOptimize(undecodedChunk);
+        } catch (SeekAheadNoBackArrayException ignored) {
+            readFileUploadByteMultipartStandard(delimiter);
+            return;
+        }
+        int readerIndex = undecodedChunk.readerIndex();
+        // found the decoder limit
+        boolean newLine = true;
+        int index = 0;
+        int lastrealpos = sao.pos;
+        int lastPosition;
+        boolean found = false;
+
+        while (sao.pos < sao.limit) {
+            byte nextByte = sao.bytes[sao.pos++];
+            if (newLine) {
+                // Check the delimiter
+                if (nextByte == delimiter.codePointAt(index)) {
+                    index++;
+                    if (delimiter.length() == index) {
+                        found = true;
+                        break;
+                    }
+                    continue;
+                } else {
+                    newLine = false;
+                    index = 0;
+                    // continue until end of line
+                    if (nextByte == HttpConstants.CR) {
+                        if (sao.pos < sao.limit) {
+                            nextByte = sao.bytes[sao.pos++];
+                            if (nextByte == HttpConstants.LF) {
+                                newLine = true;
+                                index = 0;
+                                lastrealpos = sao.pos - 2;
+                            } else {
+                                // unread next byte
+                                sao.pos--;
+
+                                // save last valid position
+                                lastrealpos = sao.pos;
+                            }
+                        }
+                    } else if (nextByte == HttpConstants.LF) {
+                        newLine = true;
+                        index = 0;
+                        lastrealpos = sao.pos - 1;
+                    } else {
+                        // save last valid position
+                        lastrealpos = sao.pos;
+                    }
+                }
+            } else {
+                // continue until end of line
+                if (nextByte == HttpConstants.CR) {
+                    if (sao.pos < sao.limit) {
+                        nextByte = sao.bytes[sao.pos++];
+                        if (nextByte == HttpConstants.LF) {
+                            newLine = true;
+                            index = 0;
+                            lastrealpos = sao.pos - 2;
+                        } else {
+                            // unread next byte
+                            sao.pos--;
+
+                            // save last valid position
+                            lastrealpos = sao.pos;
+                        }
+                    }
+                } else if (nextByte == HttpConstants.LF) {
+                    newLine = true;
+                    index = 0;
+                    lastrealpos = sao.pos - 1;
+                } else {
+                    // save last valid position
+                    lastrealpos = sao.pos;
+                }
+            }
+        }
+        lastPosition = sao.getReadPosition(lastrealpos);
+        ByteBuf buffer = undecodedChunk.copy(readerIndex, lastPosition - readerIndex);
+        if (found) {
+            // found so lastPosition is correct and final
+            try {
+                currentFileUpload.addContent(buffer, true);
+                // just before the CRLF and delimiter
+                undecodedChunk.readerIndex(lastPosition);
+            } catch (IOException e) {
+                throw new ErrorDataDecoderException(e);
+            }
+        } else {
+            // possibly the delimiter is partially found but still the last
+            // position is OK
+            try {
+                currentFileUpload.addContent(buffer, false);
+                // last valid char (not CR, not LF, not beginning of delimiter)
+                undecodedChunk.readerIndex(lastPosition);
+                throw new NotEnoughDataDecoderException();
+            } catch (IOException e) {
+                throw new ErrorDataDecoderException(e);
+            }
+        }
+    }
+
+    /**
+     * Load the field value from a Multipart request
+     *
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks
+     * @throws ErrorDataDecoderException
+     */
+    private void loadFieldMultipartStandard(String delimiter) {
+        int readerIndex = undecodedChunk.readerIndex();
+        try {
+            // found the decoder limit
+            boolean newLine = true;
+            int index = 0;
+            int lastPosition = undecodedChunk.readerIndex();
+            boolean found = false;
+            while (undecodedChunk.isReadable()) {
+                byte nextByte = undecodedChunk.readByte();
+                if (newLine) {
+                    // Check the delimiter
+                    if (nextByte == delimiter.codePointAt(index)) {
+                        index++;
+                        if (delimiter.length() == index) {
+                            found = true;
+                            break;
+                        }
+                        continue;
+                    } else {
+                        newLine = false;
+                        index = 0;
+                        // continue until end of line
+                        if (nextByte == HttpConstants.CR) {
+                            if (undecodedChunk.isReadable()) {
+                                nextByte = undecodedChunk.readByte();
+                                if (nextByte == HttpConstants.LF) {
+                                    newLine = true;
+                                    index = 0;
+                                    lastPosition = undecodedChunk.readerIndex() - 2;
+                                } else {
+                                    // Unread second nextByte
+                                    lastPosition = undecodedChunk.readerIndex() - 1;
+                                    undecodedChunk.readerIndex(lastPosition);
+                                }
+                            } else {
+                                lastPosition = undecodedChunk.readerIndex() - 1;
+                            }
+                        } else if (nextByte == HttpConstants.LF) {
+                            newLine = true;
+                            index = 0;
+                            lastPosition = undecodedChunk.readerIndex() - 1;
+                        } else {
+                            lastPosition = undecodedChunk.readerIndex();
+                        }
+                    }
+                } else {
+                    // continue until end of line
+                    if (nextByte == HttpConstants.CR) {
+                        if (undecodedChunk.isReadable()) {
+                            nextByte = undecodedChunk.readByte();
+                            if (nextByte == HttpConstants.LF) {
+                                newLine = true;
+                                index = 0;
+                                lastPosition = undecodedChunk.readerIndex() - 2;
+                            } else {
+                                // Unread second nextByte
+                                lastPosition = undecodedChunk.readerIndex() - 1;
+                                undecodedChunk.readerIndex(lastPosition);
+                            }
+                        } else {
+                            lastPosition = undecodedChunk.readerIndex() - 1;
+                        }
+                    } else if (nextByte == HttpConstants.LF) {
+                        newLine = true;
+                        index = 0;
+                        lastPosition = undecodedChunk.readerIndex() - 1;
+                    } else {
+                        lastPosition = undecodedChunk.readerIndex();
+                    }
+                }
+            }
+            if (found) {
+                // found so lastPosition is correct
+                // but position is just after the delimiter (either close
+                // delimiter or simple one)
+                // so go back of delimiter size
+                try {
+                    currentAttribute.addContent(
+                            undecodedChunk.copy(readerIndex, lastPosition - readerIndex), true);
+                } catch (IOException e) {
+                    throw new ErrorDataDecoderException(e);
+                }
+                undecodedChunk.readerIndex(lastPosition);
+            } else {
+                try {
+                    currentAttribute.addContent(
+                            undecodedChunk.copy(readerIndex, lastPosition - readerIndex), false);
+                } catch (IOException e) {
+                    throw new ErrorDataDecoderException(e);
+                }
+                undecodedChunk.readerIndex(lastPosition);
+                throw new NotEnoughDataDecoderException();
+            }
+        } catch (IndexOutOfBoundsException e) {
+            undecodedChunk.readerIndex(readerIndex);
+            throw new NotEnoughDataDecoderException(e);
+        }
+    }
+
+    /**
+     * Load the field value from a Multipart request
+     *
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks
+     * @throws ErrorDataDecoderException
+     */
+    private void loadFieldMultipart(String delimiter) {
+        SeekAheadOptimize sao;
+        try {
+            sao = new SeekAheadOptimize(undecodedChunk);
+        } catch (SeekAheadNoBackArrayException ignored) {
+            loadFieldMultipartStandard(delimiter);
+            return;
+        }
+        int readerIndex = undecodedChunk.readerIndex();
+        try {
+            // found the decoder limit
+            boolean newLine = true;
+            int index = 0;
+            int lastPosition;
+            int lastrealpos = sao.pos;
+            boolean found = false;
+
+            while (sao.pos < sao.limit) {
+                byte nextByte = sao.bytes[sao.pos++];
+                if (newLine) {
+                    // Check the delimiter
+                    if (nextByte == delimiter.codePointAt(index)) {
+                        index++;
+                        if (delimiter.length() == index) {
+                            found = true;
+                            break;
+                        }
+                        continue;
+                    } else {
+                        newLine = false;
+                        index = 0;
+                        // continue until end of line
+                        if (nextByte == HttpConstants.CR) {
+                            if (sao.pos < sao.limit) {
+                                nextByte = sao.bytes[sao.pos++];
+                                if (nextByte == HttpConstants.LF) {
+                                    newLine = true;
+                                    index = 0;
+                                    lastrealpos = sao.pos - 2;
+                                } else {
+                                    // Unread last nextByte
+                                    sao.pos--;
+                                    lastrealpos = sao.pos;
+                                }
+                            }
+                        } else if (nextByte == HttpConstants.LF) {
+                            newLine = true;
+                            index = 0;
+                            lastrealpos = sao.pos - 1;
+                        } else {
+                            lastrealpos = sao.pos;
+                        }
+                    }
+                } else {
+                    // continue until end of line
+                    if (nextByte == HttpConstants.CR) {
+                        if (sao.pos < sao.limit) {
+                            nextByte = sao.bytes[sao.pos++];
+                            if (nextByte == HttpConstants.LF) {
+                                newLine = true;
+                                index = 0;
+                                lastrealpos = sao.pos - 2;
+                            } else {
+                                // Unread last nextByte
+                                sao.pos--;
+                                lastrealpos = sao.pos;
+                            }
+                        }
+                    } else if (nextByte == HttpConstants.LF) {
+                        newLine = true;
+                        index = 0;
+                        lastrealpos = sao.pos - 1;
+                    } else {
+                        lastrealpos = sao.pos;
+                    }
+                }
+            }
+            lastPosition = sao.getReadPosition(lastrealpos);
+            if (found) {
+                // found so lastPosition is correct
+                // but position is just after the delimiter (either close
+                // delimiter or simple one)
+                // so go back of delimiter size
+                try {
+                    currentAttribute.addContent(
+                            undecodedChunk.copy(readerIndex, lastPosition - readerIndex), true);
+                } catch (IOException e) {
+                    throw new ErrorDataDecoderException(e);
+                }
+                undecodedChunk.readerIndex(lastPosition);
+            } else {
+                try {
+                    currentAttribute.addContent(
+                            undecodedChunk.copy(readerIndex, lastPosition - readerIndex), false);
+                } catch (IOException e) {
+                    throw new ErrorDataDecoderException(e);
+                }
+                undecodedChunk.readerIndex(lastPosition);
+                throw new NotEnoughDataDecoderException();
+            }
+        } catch (IndexOutOfBoundsException e) {
+            undecodedChunk.readerIndex(readerIndex);
+            throw new NotEnoughDataDecoderException(e);
+        }
+    }
+
+    /**
+     * Clean the String from any unallowed character
+     *
+     * @return the cleaned String
+     */
+    @SuppressWarnings("IfStatementWithIdenticalBranches")
+    private static String cleanString(String field) {
+        StringBuilder sb = new StringBuilder(field.length());
+        for (int i = 0; i < field.length(); i++) {
+            char nextChar = field.charAt(i);
+            if (nextChar == HttpConstants.COLON) {
+                sb.append(HttpConstants.SP);
+            } else if (nextChar == HttpConstants.COMMA) {
+                sb.append(HttpConstants.SP);
+            } else if (nextChar == HttpConstants.EQUALS) {
+                sb.append(HttpConstants.SP);
+            } else if (nextChar == HttpConstants.SEMICOLON) {
+                sb.append(HttpConstants.SP);
+            } else if (nextChar == HttpConstants.HT) {
+                sb.append(HttpConstants.SP);
+            } else if (nextChar == HttpConstants.DOUBLE_QUOTE) {
+                // nothing added, just removes it
+            } else {
+                sb.append(nextChar);
+            }
+        }
+        return sb.toString().trim();
+    }
+
+    /**
+     * Skip one empty line
+     *
+     * @return True if one empty line was skipped
+     */
+    private boolean skipOneLine() {
+        if (!undecodedChunk.isReadable()) {
+            return false;
+        }
+        byte nextByte = undecodedChunk.readByte();
+        if (nextByte == HttpConstants.CR) {
+            if (!undecodedChunk.isReadable()) {
+                undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
+                return false;
+            }
+            nextByte = undecodedChunk.readByte();
+            if (nextByte == HttpConstants.LF) {
+                return true;
+            }
+            undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 2);
+            return false;
+        }
+        if (nextByte == HttpConstants.LF) {
+            return true;
+        }
+        undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
+        return false;
+    }
+
+    /**
+     * Split one header in Multipart
+     *
+     * @return an array of String where rank 0 is the name of the header,
+     *         follows by several values that were separated by ';' or ','
+     */
+    private static String[] splitMultipartHeader(String sb) {
+        ArrayList<String> headers = new ArrayList<String>(1);
+        int nameStart;
+        int nameEnd;
+        int colonEnd;
+        int valueStart;
+        int valueEnd;
+        nameStart = HttpPostBodyUtil.findNonWhitespace(sb, 0);
+        for (nameEnd = nameStart; nameEnd < sb.length(); nameEnd++) {
+            char ch = sb.charAt(nameEnd);
+            if (ch == ':' || Character.isWhitespace(ch)) {
+                break;
+            }
+        }
+        for (colonEnd = nameEnd; colonEnd < sb.length(); colonEnd++) {
+            if (sb.charAt(colonEnd) == ':') {
+                colonEnd++;
+                break;
+            }
+        }
+        valueStart = HttpPostBodyUtil.findNonWhitespace(sb, colonEnd);
+        valueEnd = HttpPostBodyUtil.findEndOfString(sb);
+        headers.add(sb.substring(nameStart, nameEnd));
+        String svalue = sb.substring(valueStart, valueEnd);
+        String[] values;
+        if (svalue.indexOf(';') >= 0) {
+            values = StringUtil.split(svalue, ';');
+        } else {
+            values = StringUtil.split(svalue, ',');
+        }
+        for (String value : values) {
+            headers.add(value.trim());
+        }
+        String[] array = new String[headers.size()];
+        for (int i = 0; i < headers.size(); i++) {
+            array[i] = headers.get(i);
+        }
+        return array;
+    }
+}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
index fe21fb726297..d0e66de839cf 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
@@ -15,29 +15,15 @@
  */
 package io.netty.handler.codec.http.multipart;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.http.HttpConstants;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.LastHttpContent;
-import io.netty.handler.codec.http.multipart.HttpPostBodyUtil.SeekAheadNoBackArrayException;
-import io.netty.handler.codec.http.multipart.HttpPostBodyUtil.SeekAheadOptimize;
-import io.netty.handler.codec.http.multipart.HttpPostBodyUtil.TransferEncodingMechanism;
 import io.netty.util.internal.StringUtil;
 
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
 import java.nio.charset.Charset;
-import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
-import java.util.TreeMap;
-
-import static io.netty.buffer.Unpooled.*;
 
 /**
  * This decoder will decode Body and can handle POST BODY.
@@ -45,94 +31,11 @@
  * You <strong>MUST</strong> call {@link #destroy()} after completion to release all resources.
  *
  */
-public class HttpPostRequestDecoder {
-    private static final int DEFAULT_DISCARD_THRESHOLD = 10 * 1024 * 1024;
-
-    /**
-     * Factory used to create InterfaceHttpData
-     */
-    private final HttpDataFactory factory;
-
-    /**
-     * Request to decode
-     */
-    private final HttpRequest request;
-
-    /**
-     * Default charset to use
-     */
-    private final Charset charset;
-
-    /**
-     * Does request have a body to decode
-     */
-    private boolean bodyToDecode;
-
-    /**
-     * Does the last chunk already received
-     */
-    private boolean isLastChunk;
-
-    /**
-     * HttpDatas from Body
-     */
-    private final List<InterfaceHttpData> bodyListHttpData = new ArrayList<InterfaceHttpData>();
-
-    /**
-     * HttpDatas as Map from Body
-     */
-    private final Map<String, List<InterfaceHttpData>> bodyMapHttpData = new TreeMap<String, List<InterfaceHttpData>>(
-            CaseIgnoringComparator.INSTANCE);
-
-    /**
-     * The current channelBuffer
-     */
-    private ByteBuf undecodedChunk;
-
-    /**
-     * Does this request is a Multipart request
-     */
-    private boolean isMultipart;
+public class HttpPostRequestDecoder implements InterfaceHttpPostRequestDecoder {
 
-    /**
-     * Body HttpDatas current position
-     */
-    private int bodyListHttpDataRank;
-
-    /**
-     * If multipart, this is the boundary for the flobal multipart
-     */
-    private String multipartDataBoundary;
-
-    /**
-     * If multipart, there could be internal multiparts (mixed) to the global
-     * multipart. Only one level is allowed.
-     */
-    private String multipartMixedBoundary;
-
-    /**
-     * Current getStatus
-     */
-    private MultiPartStatus currentStatus = MultiPartStatus.NOTSTARTED;
-
-    /**
-     * Used in Multipart
-     */
-    private Map<String, Attribute> currentFieldAttributes;
+    static final int DEFAULT_DISCARD_THRESHOLD = 10 * 1024 * 1024;
 
-    /**
-     * The current FileUpload that is currently in decode process
-     */
-    private FileUpload currentFileUpload;
-
-    /**
-     * The current Attribute that is currently in decode process
-     */
-    private Attribute currentAttribute;
-
-    private boolean destroyed;
-
-    private int discardThreshold = DEFAULT_DISCARD_THRESHOLD;
+    private final InterfaceHttpPostRequestDecoder decoder;
 
     /**
      *
@@ -140,14 +43,11 @@ public class HttpPostRequestDecoder {
      *            the request to decode
      * @throws NullPointerException
      *             for request
-     * @throws IncompatibleDataDecoderException
-     *             if the request has no body to decode
      * @throws ErrorDataDecoderException
      *             if the default charset was wrong when decoding or other
      *             errors
      */
-    public HttpPostRequestDecoder(HttpRequest request) throws ErrorDataDecoderException,
-            IncompatibleDataDecoderException {
+    public HttpPostRequestDecoder(HttpRequest request) {
         this(new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE), request, HttpConstants.DEFAULT_CHARSET);
     }
 
@@ -159,14 +59,11 @@ public HttpPostRequestDecoder(HttpRequest request) throws ErrorDataDecoderExcept
      *            the request to decode
      * @throws NullPointerException
      *             for request or factory
-     * @throws IncompatibleDataDecoderException
-     *             if the request has no body to decode
      * @throws ErrorDataDecoderException
      *             if the default charset was wrong when decoding or other
      *             errors
      */
-    public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request) throws ErrorDataDecoderException,
-            IncompatibleDataDecoderException {
+    public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request) {
         this(factory, request, HttpConstants.DEFAULT_CHARSET);
     }
 
@@ -180,14 +77,11 @@ public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request) thro
      *            the charset to use as default
      * @throws NullPointerException
      *             for request or charset or factory
-     * @throws IncompatibleDataDecoderException
-     *             if the request has no body to decode
      * @throws ErrorDataDecoderException
      *             if the default charset was wrong when decoding or other
      *             errors
      */
-    public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset)
-            throws ErrorDataDecoderException, IncompatibleDataDecoderException {
+    public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset) {
         if (factory == null) {
             throw new NullPointerException("factory");
         }
@@ -197,31 +91,11 @@ public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request, Char
         if (charset == null) {
             throw new NullPointerException("charset");
         }
-        this.request = request;
-        HttpMethod method = request.getMethod();
-        if (method.equals(HttpMethod.POST) || method.equals(HttpMethod.PUT) || method.equals(HttpMethod.PATCH)) {
-            bodyToDecode = true;
-        }
-        this.charset = charset;
-        this.factory = factory;
         // Fill default values
-
-        String contentType = this.request.headers().get(HttpHeaders.Names.CONTENT_TYPE);
-        if (contentType != null) {
-            checkMultipart(contentType);
+        if (isMultipart(request)) {
+            decoder = new HttpPostMultipartRequestDecoder(factory, request, charset);
         } else {
-            isMultipart = false;
-        }
-        if (!bodyToDecode) {
-            throw new IncompatibleDataDecoderException("No Body to decode");
-        }
-        if (request instanceof HttpContent) {
-            // Offer automatically if the given request is als type of HttpContent
-            // See #1089
-            offer((HttpContent) request);
-        } else {
-            undecodedChunk = buffer();
-            parseBody();
+            decoder = new HttpPostStandardRequestDecoder(factory, request, charset);
         }
     }
 
@@ -255,1866 +129,161 @@ public HttpPostRequestDecoder(HttpDataFactory factory, HttpRequest request, Char
      *
      * Once CLOSEDELIMITER is found, last getStatus is EPILOGUE
      */
-    private enum MultiPartStatus {
+    protected enum MultiPartStatus {
         NOTSTARTED, PREAMBLE, HEADERDELIMITER, DISPOSITION, FIELD, FILEUPLOAD, MIXEDPREAMBLE, MIXEDDELIMITER,
         MIXEDDISPOSITION, MIXEDFILEUPLOAD, MIXEDCLOSEDELIMITER, CLOSEDELIMITER, PREEPILOGUE, EPILOGUE
     }
 
     /**
-     * Check from the request ContentType if this request is a Multipart
-     * request.
+     * Check if the given request is a multipart request
+     * @return True if the request is a Multipart request
      */
-    private void checkMultipart(String contentType) throws ErrorDataDecoderException {
-        // Check if Post using "multipart/form-data; boundary=--89421926422648"
-        String[] headerContentType = splitHeaderContentType(contentType);
-        if (headerContentType[0].toLowerCase().startsWith(HttpHeaders.Values.MULTIPART_FORM_DATA)
-                && headerContentType[1].toLowerCase().startsWith(HttpHeaders.Values.BOUNDARY)) {
-            String[] boundary = StringUtil.split(headerContentType[1], '=');
-            if (boundary.length != 2) {
-                throw new ErrorDataDecoderException("Needs a boundary value");
-            }
-            multipartDataBoundary = "--" + boundary[1];
-            isMultipart = true;
-            currentStatus = MultiPartStatus.HEADERDELIMITER;
+    public static boolean isMultipart(HttpRequest request) {
+        if (request.headers().contains(HttpHeaders.Names.CONTENT_TYPE)) {
+            return getMultipartDataBoundary(request.headers().get(HttpHeaders.Names.CONTENT_TYPE)) != null;
         } else {
-            isMultipart = false;
-        }
-    }
-
-    private void checkDestroyed() {
-        if (destroyed) {
-            throw new IllegalStateException(HttpPostRequestDecoder.class.getSimpleName() + " was destroyed already");
-        }
-    }
-
-    /**
-     * True if this request is a Multipart request
-     *
-     * @return True if this request is a Multipart request
-     */
-    public boolean isMultipart() {
-        checkDestroyed();
-        return isMultipart;
-    }
-
-    /**
-     * Set the amount of bytes after which read bytes in the buffer should be discarded.
-     * Setting this lower gives lower memory usage but with the overhead of more memory copies.
-     * Use {@code 0} to disable it.
-     */
-    public void setDiscardThreshold(int discardThreshold) {
-        if (discardThreshold < 0) {
-          throw new IllegalArgumentException("discardThreshold must be >= 0");
-        }
-        this.discardThreshold = discardThreshold;
-    }
-
-    /**
-     * Return the threshold in bytes after which read data in the buffer should be discarded.
-     */
-    public int getDiscardThreshold() {
-        return discardThreshold;
-    }
-
-    /**
-     * This getMethod returns a List of all HttpDatas from body.<br>
-     *
-     * If chunked, all chunks must have been offered using offer() getMethod. If
-     * not, NotEnoughDataDecoderException will be raised.
-     *
-     * @return the list of HttpDatas from Body part for POST getMethod
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks
-     */
-    public List<InterfaceHttpData> getBodyHttpDatas() throws NotEnoughDataDecoderException {
-        checkDestroyed();
-
-        if (!isLastChunk) {
-            throw new NotEnoughDataDecoderException();
-        }
-        return bodyListHttpData;
-    }
-
-    /**
-     * This getMethod returns a List of all HttpDatas with the given name from
-     * body.<br>
-     *
-     * If chunked, all chunks must have been offered using offer() getMethod. If
-     * not, NotEnoughDataDecoderException will be raised.
-     *
-     * @return All Body HttpDatas with the given name (ignore case)
-     * @throws NotEnoughDataDecoderException
-     *             need more chunks
-     */
-    public List<InterfaceHttpData> getBodyHttpDatas(String name) throws NotEnoughDataDecoderException {
-        checkDestroyed();
-
-        if (!isLastChunk) {
-            throw new NotEnoughDataDecoderException();
-        }
-        return bodyMapHttpData.get(name);
-    }
-
-    /**
-     * This getMethod returns the first InterfaceHttpData with the given name from
-     * body.<br>
-     *
-     * If chunked, all chunks must have been offered using offer() getMethod. If
-     * not, NotEnoughDataDecoderException will be raised.
-     *
-     * @return The first Body InterfaceHttpData with the given name (ignore
-     *         case)
-     * @throws NotEnoughDataDecoderException
-     *             need more chunks
-     */
-    public InterfaceHttpData getBodyHttpData(String name) throws NotEnoughDataDecoderException {
-        checkDestroyed();
-
-        if (!isLastChunk) {
-            throw new NotEnoughDataDecoderException();
-        }
-        List<InterfaceHttpData> list = bodyMapHttpData.get(name);
-        if (list != null) {
-            return list.get(0);
-        }
-        return null;
-    }
-
-    /**
-     * Initialized the internals from a new chunk
-     *
-     * @param content
-     *            the new received chunk
-     * @throws ErrorDataDecoderException
-     *             if there is a problem with the charset decoding or other
-     *             errors
-     */
-    public HttpPostRequestDecoder offer(HttpContent content) throws ErrorDataDecoderException {
-        checkDestroyed();
-
-        // Maybe we should better not copy here for performance reasons but this will need
-        // more care by the caller to release the content in a correct manner later
-        // So maybe something to optimize on a later stage
-        ByteBuf buf = content.content();
-        if (undecodedChunk == null) {
-            undecodedChunk = buf.copy();
-        } else {
-            undecodedChunk.writeBytes(buf);
-        }
-        if (content instanceof LastHttpContent) {
-            isLastChunk = true;
-        }
-        parseBody();
-        if (undecodedChunk != null && undecodedChunk.writerIndex() > discardThreshold) {
-            undecodedChunk.discardReadBytes();
-        }
-        return this;
-    }
-
-    /**
-     * True if at current getStatus, there is an available decoded
-     * InterfaceHttpData from the Body.
-     *
-     * This getMethod works for chunked and not chunked request.
-     *
-     * @return True if at current getStatus, there is a decoded InterfaceHttpData
-     * @throws EndOfDataDecoderException
-     *             No more data will be available
-     */
-    public boolean hasNext() throws EndOfDataDecoderException {
-        checkDestroyed();
-
-        if (currentStatus == MultiPartStatus.EPILOGUE) {
-            // OK except if end of list
-            if (bodyListHttpDataRank >= bodyListHttpData.size()) {
-                throw new EndOfDataDecoderException();
-            }
-        }
-        return !bodyListHttpData.isEmpty() && bodyListHttpDataRank < bodyListHttpData.size();
-    }
-
-    /**
-     * Returns the next available InterfaceHttpData or null if, at the time it
-     * is called, there is no more available InterfaceHttpData. A subsequent
-     * call to offer(httpChunk) could enable more data.
-     *
-     * Be sure to call {@link InterfaceHttpData#release()} after you are done
-     * with processing to make sure to not leak any resources
-     *
-     * @return the next available InterfaceHttpData or null if none
-     * @throws EndOfDataDecoderException
-     *             No more data will be available
-     */
-    public InterfaceHttpData next() throws EndOfDataDecoderException {
-        checkDestroyed();
-
-        if (hasNext()) {
-            return bodyListHttpData.get(bodyListHttpDataRank++);
-        }
-        return null;
-    }
-
-    /**
-     * This getMethod will parse as much as possible data and fill the list and map
-     *
-     * @throws ErrorDataDecoderException
-     *             if there is a problem with the charset decoding or other
-     *             errors
-     */
-    private void parseBody() throws ErrorDataDecoderException {
-        if (currentStatus == MultiPartStatus.PREEPILOGUE || currentStatus == MultiPartStatus.EPILOGUE) {
-            if (isLastChunk) {
-                currentStatus = MultiPartStatus.EPILOGUE;
-            }
-            return;
-        }
-        if (isMultipart) {
-            parseBodyMultipart();
-        } else {
-            parseBodyAttributes();
+            return false;
         }
     }
 
     /**
-     * Utility function to add a new decoded data
+     * Check from the request ContentType if this request is a Multipart request.
+     * @return an array of String if multipartDataBoundary exists with the multipartDataBoundary
+     * as first element, charset if any as second (missing if not set), else null
      */
-    protected void addHttpData(InterfaceHttpData data) {
-        if (data == null) {
-            return;
-        }
-        List<InterfaceHttpData> datas = bodyMapHttpData.get(data.getName());
-        if (datas == null) {
-            datas = new ArrayList<InterfaceHttpData>(1);
-            bodyMapHttpData.put(data.getName(), datas);
-        }
-        datas.add(data);
-        bodyListHttpData.add(data);
-    }
-
-    /**
-     * This getMethod fill the map and list with as much Attribute as possible from
-     * Body in not Multipart mode.
-     *
-     * @throws ErrorDataDecoderException
-     *             if there is a problem with the charset decoding or other
-     *             errors
-     */
-    private void parseBodyAttributesStandard() throws ErrorDataDecoderException {
-        int firstpos = undecodedChunk.readerIndex();
-        int currentpos = firstpos;
-        int equalpos;
-        int ampersandpos;
-        if (currentStatus == MultiPartStatus.NOTSTARTED) {
-            currentStatus = MultiPartStatus.DISPOSITION;
-        }
-        boolean contRead = true;
-        try {
-            while (undecodedChunk.isReadable() && contRead) {
-                char read = (char) undecodedChunk.readUnsignedByte();
-                currentpos++;
-                switch (currentStatus) {
-                case DISPOSITION:// search '='
-                    if (read == '=') {
-                        currentStatus = MultiPartStatus.FIELD;
-                        equalpos = currentpos - 1;
-                        String key = decodeAttribute(undecodedChunk.toString(firstpos, equalpos - firstpos, charset),
-                                charset);
-                        currentAttribute = factory.createAttribute(request, key);
-                        firstpos = currentpos;
-                    } else if (read == '&') { // special empty FIELD
-                        currentStatus = MultiPartStatus.DISPOSITION;
-                        ampersandpos = currentpos - 1;
-                        String key = decodeAttribute(
-                                undecodedChunk.toString(firstpos, ampersandpos - firstpos, charset), charset);
-                        currentAttribute = factory.createAttribute(request, key);
-                        currentAttribute.setValue(""); // empty
-                        addHttpData(currentAttribute);
-                        currentAttribute = null;
-                        firstpos = currentpos;
-                        contRead = true;
-                    }
-                    break;
-                case FIELD:// search '&' or end of line
-                    if (read == '&') {
-                        currentStatus = MultiPartStatus.DISPOSITION;
-                        ampersandpos = currentpos - 1;
-                        setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
-                        firstpos = currentpos;
-                        contRead = true;
-                    } else if (read == HttpConstants.CR) {
-                        if (undecodedChunk.isReadable()) {
-                            read = (char) undecodedChunk.readUnsignedByte();
-                            currentpos++;
-                            if (read == HttpConstants.LF) {
-                                currentStatus = MultiPartStatus.PREEPILOGUE;
-                                ampersandpos = currentpos - 2;
-                                setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
-                                firstpos = currentpos;
-                                contRead = false;
-                            } else {
-                                // Error
-                                throw new ErrorDataDecoderException("Bad end of line");
-                            }
-                        } else {
-                            currentpos--;
-                        }
-                    } else if (read == HttpConstants.LF) {
-                        currentStatus = MultiPartStatus.PREEPILOGUE;
-                        ampersandpos = currentpos - 1;
-                        setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
-                        firstpos = currentpos;
-                        contRead = false;
-                    }
-                    break;
-                default:
-                    // just stop
-                    contRead = false;
-                }
-            }
-            if (isLastChunk && currentAttribute != null) {
-                // special case
-                ampersandpos = currentpos;
-                if (ampersandpos > firstpos) {
-                    setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
-                } else if (!currentAttribute.isCompleted()) {
-                    setFinalBuffer(EMPTY_BUFFER);
-                }
-                firstpos = currentpos;
-                currentStatus = MultiPartStatus.EPILOGUE;
-                return;
-            }
-            if (contRead && currentAttribute != null) {
-                // reset index except if to continue in case of FIELD getStatus
-                if (currentStatus == MultiPartStatus.FIELD) {
-                    currentAttribute.addContent(undecodedChunk.copy(firstpos, currentpos - firstpos),
-                                                false);
-                    firstpos = currentpos;
-                }
-                undecodedChunk.readerIndex(firstpos);
+    protected static String[] getMultipartDataBoundary(String contentType) {
+        // Check if Post using "multipart/form-data; boundary=--89421926422648 [; charset=xxx]"
+        String[] headerContentType = splitHeaderContentType(contentType);
+        if (headerContentType[0].toLowerCase().startsWith(
+                HttpHeaders.Values.MULTIPART_FORM_DATA)) {
+            int mrank;
+            int crank;
+            if (headerContentType[1].toLowerCase().startsWith(
+                    HttpHeaders.Values.BOUNDARY)) {
+                mrank = 1;
+                crank = 2;
+            } else if (headerContentType[2].toLowerCase().startsWith(
+                    HttpHeaders.Values.BOUNDARY)) {
+                mrank = 2;
+                crank = 1;
             } else {
-                // end of line so keep index
+                return null;
             }
-        } catch (ErrorDataDecoderException e) {
-            // error while decoding
-            undecodedChunk.readerIndex(firstpos);
-            throw e;
-        } catch (IOException e) {
-            // error while decoding
-            undecodedChunk.readerIndex(firstpos);
-            throw new ErrorDataDecoderException(e);
-        }
-    }
-
-    /**
-     * This getMethod fill the map and list with as much Attribute as possible from
-     * Body in not Multipart mode.
-     *
-     * @throws ErrorDataDecoderException
-     *             if there is a problem with the charset decoding or other
-     *             errors
-     */
-    private void parseBodyAttributes() throws ErrorDataDecoderException {
-        SeekAheadOptimize sao;
-        try {
-            sao = new SeekAheadOptimize(undecodedChunk);
-        } catch (SeekAheadNoBackArrayException e1) {
-            parseBodyAttributesStandard();
-            return;
-        }
-        int firstpos = undecodedChunk.readerIndex();
-        int currentpos = firstpos;
-        int equalpos;
-        int ampersandpos;
-        if (currentStatus == MultiPartStatus.NOTSTARTED) {
-            currentStatus = MultiPartStatus.DISPOSITION;
-        }
-        boolean contRead = true;
-        try {
-            loop: while (sao.pos < sao.limit) {
-                char read = (char) (sao.bytes[sao.pos++] & 0xFF);
-                currentpos++;
-                switch (currentStatus) {
-                case DISPOSITION:// search '='
-                    if (read == '=') {
-                        currentStatus = MultiPartStatus.FIELD;
-                        equalpos = currentpos - 1;
-                        String key = decodeAttribute(undecodedChunk.toString(firstpos, equalpos - firstpos, charset),
-                                charset);
-                        currentAttribute = factory.createAttribute(request, key);
-                        firstpos = currentpos;
-                    } else if (read == '&') { // special empty FIELD
-                        currentStatus = MultiPartStatus.DISPOSITION;
-                        ampersandpos = currentpos - 1;
-                        String key = decodeAttribute(
-                                undecodedChunk.toString(firstpos, ampersandpos - firstpos, charset), charset);
-                        currentAttribute = factory.createAttribute(request, key);
-                        currentAttribute.setValue(""); // empty
-                        addHttpData(currentAttribute);
-                        currentAttribute = null;
-                        firstpos = currentpos;
-                        contRead = true;
-                    }
-                    break;
-                case FIELD:// search '&' or end of line
-                    if (read == '&') {
-                        currentStatus = MultiPartStatus.DISPOSITION;
-                        ampersandpos = currentpos - 1;
-                        setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
-                        firstpos = currentpos;
-                        contRead = true;
-                    } else if (read == HttpConstants.CR) {
-                        if (sao.pos < sao.limit) {
-                            read = (char) (sao.bytes[sao.pos++] & 0xFF);
-                            currentpos++;
-                            if (read == HttpConstants.LF) {
-                                currentStatus = MultiPartStatus.PREEPILOGUE;
-                                ampersandpos = currentpos - 2;
-                                sao.setReadPosition(0);
-                                setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
-                                firstpos = currentpos;
-                                contRead = false;
-                                break loop;
-                            } else {
-                                // Error
-                                sao.setReadPosition(0);
-                                throw new ErrorDataDecoderException("Bad end of line");
-                            }
-                        } else {
-                            if (sao.limit > 0) {
-                                currentpos--;
-                            }
-                        }
-                    } else if (read == HttpConstants.LF) {
-                        currentStatus = MultiPartStatus.PREEPILOGUE;
-                        ampersandpos = currentpos - 1;
-                        sao.setReadPosition(0);
-                        setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
-                        firstpos = currentpos;
-                        contRead = false;
-                        break loop;
-                    }
-                    break;
-                default:
-                    // just stop
-                    sao.setReadPosition(0);
-                    contRead = false;
-                    break loop;
-                }
+            String[] boundary = StringUtil.split(headerContentType[mrank], '=');
+            if (boundary.length != 2) {
+                throw new ErrorDataDecoderException("Needs a boundary value");
             }
-            if (isLastChunk && currentAttribute != null) {
-                // special case
-                ampersandpos = currentpos;
-                if (ampersandpos > firstpos) {
-                    setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
-                } else if (!currentAttribute.isCompleted()) {
-                    setFinalBuffer(EMPTY_BUFFER);
+            if (boundary[1].charAt(0) == '"') {
+                String bound = boundary[1].trim();
+                int index = bound.length() - 1;
+                if (bound.charAt(index) == '"') {
+                    boundary[1] = bound.substring(1, index);
                 }
-                firstpos = currentpos;
-                currentStatus = MultiPartStatus.EPILOGUE;
-                return;
             }
-            if (contRead && currentAttribute != null) {
-                // reset index except if to continue in case of FIELD getStatus
-                if (currentStatus == MultiPartStatus.FIELD) {
-                    currentAttribute.addContent(undecodedChunk.copy(firstpos, currentpos - firstpos),
-                                                false);
-                    firstpos = currentpos;
+            if (headerContentType[crank].toLowerCase().startsWith(
+                    HttpHeaders.Values.CHARSET)) {
+                String[] charset = StringUtil.split(headerContentType[crank], '=');
+                if (charset.length > 1) {
+                    return new String[] {"--" + boundary[1], charset[1]};
                 }
-                undecodedChunk.readerIndex(firstpos);
-            } else {
-                // end of line so keep index
             }
-        } catch (ErrorDataDecoderException e) {
-            // error while decoding
-            undecodedChunk.readerIndex(firstpos);
-            throw e;
-        } catch (IOException e) {
-            // error while decoding
-            undecodedChunk.readerIndex(firstpos);
-            throw new ErrorDataDecoderException(e);
+            return new String[] {"--" + boundary[1]};
         }
+        return null;
     }
 
-    private void setFinalBuffer(ByteBuf buffer) throws ErrorDataDecoderException, IOException {
-        currentAttribute.addContent(buffer, true);
-        String value = decodeAttribute(currentAttribute.getByteBuf().toString(charset), charset);
-        currentAttribute.setValue(value);
-        addHttpData(currentAttribute);
-        currentAttribute = null;
+    @Override
+    public boolean isMultipart() {
+        return decoder.isMultipart();
     }
 
-    /**
-     * Decode component
-     *
-     * @return the decoded component
-     */
-    private static String decodeAttribute(String s, Charset charset) throws ErrorDataDecoderException {
-        if (s == null) {
-            return "";
-        }
-        try {
-            return URLDecoder.decode(s, charset.name());
-        } catch (UnsupportedEncodingException e) {
-            throw new ErrorDataDecoderException(charset.toString(), e);
-        } catch (IllegalArgumentException e) {
-            throw new ErrorDataDecoderException("Bad string: '" + s + '\'', e);
-        }
+    @Override
+    public void setDiscardThreshold(int discardThreshold) {
+        decoder.setDiscardThreshold(discardThreshold);
     }
 
-    /**
-     * Parse the Body for multipart
-     *
-     * @throws ErrorDataDecoderException
-     *             if there is a problem with the charset decoding or other
-     *             errors
-     */
-    private void parseBodyMultipart() throws ErrorDataDecoderException {
-        if (undecodedChunk == null || undecodedChunk.readableBytes() == 0) {
-            // nothing to decode
-            return;
-        }
-        InterfaceHttpData data = decodeMultipart(currentStatus);
-        while (data != null) {
-            addHttpData(data);
-            if (currentStatus == MultiPartStatus.PREEPILOGUE || currentStatus == MultiPartStatus.EPILOGUE) {
-                break;
-            }
-            data = decodeMultipart(currentStatus);
-        }
+    @Override
+    public int getDiscardThreshold() {
+        return decoder.getDiscardThreshold();
     }
 
-    /**
-     * Decode a multipart request by pieces<br>
-     * <br>
-     * NOTSTARTED PREAMBLE (<br>
-     * (HEADERDELIMITER DISPOSITION (FIELD | FILEUPLOAD))*<br>
-     * (HEADERDELIMITER DISPOSITION MIXEDPREAMBLE<br>
-     * (MIXEDDELIMITER MIXEDDISPOSITION MIXEDFILEUPLOAD)+<br>
-     * MIXEDCLOSEDELIMITER)*<br>
-     * CLOSEDELIMITER)+ EPILOGUE<br>
-     *
-     * Inspired from HttpMessageDecoder
-     *
-     * @return the next decoded InterfaceHttpData or null if none until now.
-     * @throws ErrorDataDecoderException
-     *             if an error occurs
-     */
-    private InterfaceHttpData decodeMultipart(MultiPartStatus state) throws ErrorDataDecoderException {
-        switch (state) {
-        case NOTSTARTED:
-            throw new ErrorDataDecoderException("Should not be called with the current getStatus");
-        case PREAMBLE:
-            // Content-type: multipart/form-data, boundary=AaB03x
-            throw new ErrorDataDecoderException("Should not be called with the current getStatus");
-        case HEADERDELIMITER: {
-            // --AaB03x or --AaB03x--
-            return findMultipartDelimiter(multipartDataBoundary, MultiPartStatus.DISPOSITION,
-                    MultiPartStatus.PREEPILOGUE);
-        }
-        case DISPOSITION: {
-            // content-disposition: form-data; name="field1"
-            // content-disposition: form-data; name="pics"; filename="file1.txt"
-            // and other immediate values like
-            // Content-type: image/gif
-            // Content-Type: text/plain
-            // Content-Type: text/plain; charset=ISO-8859-1
-            // Content-Transfer-Encoding: binary
-            // The following line implies a change of mode (mixed mode)
-            // Content-type: multipart/mixed, boundary=BbC04y
-            return findMultipartDisposition();
-        }
-        case FIELD: {
-            // Now get value according to Content-Type and Charset
-            Charset localCharset = null;
-            Attribute charsetAttribute = currentFieldAttributes.get(HttpHeaders.Values.CHARSET);
-            if (charsetAttribute != null) {
-                try {
-                    localCharset = Charset.forName(charsetAttribute.getValue());
-                } catch (IOException e) {
-                    throw new ErrorDataDecoderException(e);
-                }
-            }
-            Attribute nameAttribute = currentFieldAttributes.get(HttpPostBodyUtil.NAME);
-            if (currentAttribute == null) {
-                try {
-                    currentAttribute = factory.createAttribute(request,
-                            cleanString(nameAttribute.getValue()));
-                } catch (NullPointerException e) {
-                    throw new ErrorDataDecoderException(e);
-                } catch (IllegalArgumentException e) {
-                    throw new ErrorDataDecoderException(e);
-                } catch (IOException e) {
-                    throw new ErrorDataDecoderException(e);
-                }
-                if (localCharset != null) {
-                    currentAttribute.setCharset(localCharset);
-                }
-            }
-            // load data
-            try {
-                loadFieldMultipart(multipartDataBoundary);
-            } catch (NotEnoughDataDecoderException e) {
-                return null;
-            }
-            Attribute finalAttribute = currentAttribute;
-            currentAttribute = null;
-            currentFieldAttributes = null;
-            // ready to load the next one
-            currentStatus = MultiPartStatus.HEADERDELIMITER;
-            return finalAttribute;
-        }
-        case FILEUPLOAD: {
-            // eventually restart from existing FileUpload
-            return getFileUpload(multipartDataBoundary);
-        }
-        case MIXEDDELIMITER: {
-            // --AaB03x or --AaB03x--
-            // Note that currentFieldAttributes exists
-            return findMultipartDelimiter(multipartMixedBoundary, MultiPartStatus.MIXEDDISPOSITION,
-                    MultiPartStatus.HEADERDELIMITER);
-        }
-        case MIXEDDISPOSITION: {
-            return findMultipartDisposition();
-        }
-        case MIXEDFILEUPLOAD: {
-            // eventually restart from existing FileUpload
-            return getFileUpload(multipartMixedBoundary);
-        }
-        case PREEPILOGUE:
-            return null;
-        case EPILOGUE:
-            return null;
-        default:
-            throw new ErrorDataDecoderException("Shouldn't reach here.");
-        }
+    @Override
+    public List<InterfaceHttpData> getBodyHttpDatas() {
+        return decoder.getBodyHttpDatas();
     }
 
-    /**
-     * Skip control Characters
-     *
-     * @throws NotEnoughDataDecoderException
-     */
-    void skipControlCharacters() throws NotEnoughDataDecoderException {
-        SeekAheadOptimize sao;
-        try {
-            sao = new SeekAheadOptimize(undecodedChunk);
-        } catch (SeekAheadNoBackArrayException e) {
-            try {
-                skipControlCharactersStandard();
-            } catch (IndexOutOfBoundsException e1) {
-                throw new NotEnoughDataDecoderException(e1);
-            }
-            return;
-        }
-
-        while (sao.pos < sao.limit) {
-            char c = (char) (sao.bytes[sao.pos++] & 0xFF);
-            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
-                sao.setReadPosition(1);
-                return;
-            }
-        }
-        throw new NotEnoughDataDecoderException("Access out of bounds");
+    @Override
+    public List<InterfaceHttpData> getBodyHttpDatas(String name) {
+        return decoder.getBodyHttpDatas(name);
     }
 
-    void skipControlCharactersStandard() {
-        for (;;) {
-            char c = (char) undecodedChunk.readUnsignedByte();
-            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
-                undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
-                break;
-            }
-        }
+    @Override
+    public InterfaceHttpData getBodyHttpData(String name) {
+        return decoder.getBodyHttpData(name);
     }
 
-    /**
-     * Find the next Multipart Delimiter
-     *
-     * @param delimiter
-     *            delimiter to find
-     * @param dispositionStatus
-     *            the next getStatus if the delimiter is a start
-     * @param closeDelimiterStatus
-     *            the next getStatus if the delimiter is a close delimiter
-     * @return the next InterfaceHttpData if any
-     * @throws ErrorDataDecoderException
-     */
-    private InterfaceHttpData findMultipartDelimiter(String delimiter, MultiPartStatus dispositionStatus,
-            MultiPartStatus closeDelimiterStatus) throws ErrorDataDecoderException {
-        // --AaB03x or --AaB03x--
-        int readerIndex = undecodedChunk.readerIndex();
-        try {
-            skipControlCharacters();
-        } catch (NotEnoughDataDecoderException e1) {
-            undecodedChunk.readerIndex(readerIndex);
-            return null;
-        }
-        skipOneLine();
-        String newline;
-        try {
-            newline = readDelimiter(delimiter);
-        } catch (NotEnoughDataDecoderException e) {
-            undecodedChunk.readerIndex(readerIndex);
-            return null;
-        }
-        if (newline.equals(delimiter)) {
-            currentStatus = dispositionStatus;
-            return decodeMultipart(dispositionStatus);
-        }
-        if (newline.equals(delimiter + "--")) {
-            // CLOSEDELIMITER or MIXED CLOSEDELIMITER found
-            currentStatus = closeDelimiterStatus;
-            if (currentStatus == MultiPartStatus.HEADERDELIMITER) {
-                // MIXEDCLOSEDELIMITER
-                // end of the Mixed part
-                currentFieldAttributes = null;
-                return decodeMultipart(MultiPartStatus.HEADERDELIMITER);
-            }
-            return null;
-        }
-        undecodedChunk.readerIndex(readerIndex);
-        throw new ErrorDataDecoderException("No Multipart delimiter found");
+    @Override
+    public InterfaceHttpPostRequestDecoder offer(HttpContent content) {
+        return decoder.offer(content);
     }
 
-    /**
-     * Find the next Disposition
-     *
-     * @return the next InterfaceHttpData if any
-     * @throws ErrorDataDecoderException
-     */
-    private InterfaceHttpData findMultipartDisposition() throws ErrorDataDecoderException {
-        int readerIndex = undecodedChunk.readerIndex();
-        if (currentStatus == MultiPartStatus.DISPOSITION) {
-            currentFieldAttributes = new TreeMap<String, Attribute>(CaseIgnoringComparator.INSTANCE);
-        }
-        // read many lines until empty line with newline found! Store all data
-        while (!skipOneLine()) {
-            String newline;
-            try {
-                skipControlCharacters();
-                newline = readLine();
-            } catch (NotEnoughDataDecoderException e) {
-                undecodedChunk.readerIndex(readerIndex);
-                return null;
-            }
-            String[] contents = splitMultipartHeader(newline);
-            if (contents[0].equalsIgnoreCase(HttpPostBodyUtil.CONTENT_DISPOSITION)) {
-                boolean checkSecondArg;
-                if (currentStatus == MultiPartStatus.DISPOSITION) {
-                    checkSecondArg = contents[1].equalsIgnoreCase(HttpPostBodyUtil.FORM_DATA);
-                } else {
-                    checkSecondArg = contents[1].equalsIgnoreCase(HttpPostBodyUtil.ATTACHMENT)
-                            || contents[1].equalsIgnoreCase(HttpPostBodyUtil.FILE);
-                }
-                if (checkSecondArg) {
-                    // read next values and store them in the map as Attribute
-                    for (int i = 2; i < contents.length; i++) {
-                        String[] values = StringUtil.split(contents[i], '=');
-                        Attribute attribute;
-                        try {
-                            String name = cleanString(values[0]);
-                            String value = values[1];
-
-                            // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html
-                            if (HttpPostBodyUtil.FILENAME.equals(name)) {
-                                // filename value is quoted string so strip them
-                                value = value.substring(1, value.length() - 1);
-                            } else {
-                                // otherwise we need to clean the value
-                                value = cleanString(value);
-                            }
-                            attribute = factory.createAttribute(request, name, value);
-                        } catch (NullPointerException e) {
-                            throw new ErrorDataDecoderException(e);
-                        } catch (IllegalArgumentException e) {
-                            throw new ErrorDataDecoderException(e);
-                        }
-                        currentFieldAttributes.put(attribute.getName(), attribute);
-                    }
-                }
-            } else if (contents[0].equalsIgnoreCase(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING)) {
-                Attribute attribute;
-                try {
-                    attribute = factory.createAttribute(request, HttpHeaders.Names.CONTENT_TRANSFER_ENCODING,
-                            cleanString(contents[1]));
-                } catch (NullPointerException e) {
-                    throw new ErrorDataDecoderException(e);
-                } catch (IllegalArgumentException e) {
-                    throw new ErrorDataDecoderException(e);
-                }
-                currentFieldAttributes.put(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING, attribute);
-            } else if (contents[0].equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH)) {
-                Attribute attribute;
-                try {
-                    attribute = factory.createAttribute(request, HttpHeaders.Names.CONTENT_LENGTH,
-                            cleanString(contents[1]));
-                } catch (NullPointerException e) {
-                    throw new ErrorDataDecoderException(e);
-                } catch (IllegalArgumentException e) {
-                    throw new ErrorDataDecoderException(e);
-                }
-                currentFieldAttributes.put(HttpHeaders.Names.CONTENT_LENGTH, attribute);
-            } else if (contents[0].equalsIgnoreCase(HttpHeaders.Names.CONTENT_TYPE)) {
-                // Take care of possible "multipart/mixed"
-                if (contents[1].equalsIgnoreCase(HttpPostBodyUtil.MULTIPART_MIXED)) {
-                    if (currentStatus == MultiPartStatus.DISPOSITION) {
-                        String[] values = StringUtil.split(contents[2], '=');
-                        multipartMixedBoundary = "--" + values[1];
-                        currentStatus = MultiPartStatus.MIXEDDELIMITER;
-                        return decodeMultipart(MultiPartStatus.MIXEDDELIMITER);
-                    } else {
-                        throw new ErrorDataDecoderException("Mixed Multipart found in a previous Mixed Multipart");
-                    }
-                } else {
-                    for (int i = 1; i < contents.length; i++) {
-                        if (contents[i].toLowerCase().startsWith(HttpHeaders.Values.CHARSET)) {
-                            String[] values = StringUtil.split(contents[i], '=');
-                            Attribute attribute;
-                            try {
-                                attribute = factory.createAttribute(request, HttpHeaders.Values.CHARSET,
-                                        cleanString(values[1]));
-                            } catch (NullPointerException e) {
-                                throw new ErrorDataDecoderException(e);
-                            } catch (IllegalArgumentException e) {
-                                throw new ErrorDataDecoderException(e);
-                            }
-                            currentFieldAttributes.put(HttpHeaders.Values.CHARSET, attribute);
-                        } else {
-                            Attribute attribute;
-                            try {
-                                attribute = factory.createAttribute(request,
-                                        cleanString(contents[0]), contents[i]);
-                            } catch (NullPointerException e) {
-                                throw new ErrorDataDecoderException(e);
-                            } catch (IllegalArgumentException e) {
-                                throw new ErrorDataDecoderException(e);
-                            }
-                            currentFieldAttributes.put(attribute.getName(), attribute);
-                        }
-                    }
-                }
-            } else {
-                throw new ErrorDataDecoderException("Unknown Params: " + newline);
-            }
-        }
-        // Is it a FileUpload
-        Attribute filenameAttribute = currentFieldAttributes.get(HttpPostBodyUtil.FILENAME);
-        if (currentStatus == MultiPartStatus.DISPOSITION) {
-            if (filenameAttribute != null) {
-                // FileUpload
-                currentStatus = MultiPartStatus.FILEUPLOAD;
-                // do not change the buffer position
-                return decodeMultipart(MultiPartStatus.FILEUPLOAD);
-            } else {
-                // Field
-                currentStatus = MultiPartStatus.FIELD;
-                // do not change the buffer position
-                return decodeMultipart(MultiPartStatus.FIELD);
-            }
-        } else {
-            if (filenameAttribute != null) {
-                // FileUpload
-                currentStatus = MultiPartStatus.MIXEDFILEUPLOAD;
-                // do not change the buffer position
-                return decodeMultipart(MultiPartStatus.MIXEDFILEUPLOAD);
-            } else {
-                // Field is not supported in MIXED mode
-                throw new ErrorDataDecoderException("Filename not found");
-            }
-        }
+    @Override
+    public boolean hasNext() {
+        return decoder.hasNext();
     }
 
-    /**
-     * Get the FileUpload (new one or current one)
-     *
-     * @param delimiter
-     *            the delimiter to use
-     * @return the InterfaceHttpData if any
-     * @throws ErrorDataDecoderException
-     */
-    protected InterfaceHttpData getFileUpload(String delimiter) throws ErrorDataDecoderException {
-        // eventually restart from existing FileUpload
-        // Now get value according to Content-Type and Charset
-        Attribute encoding = currentFieldAttributes.get(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING);
-        Charset localCharset = charset;
-        // Default
-        TransferEncodingMechanism mechanism = TransferEncodingMechanism.BIT7;
-        if (encoding != null) {
-            String code;
-            try {
-                code = encoding.getValue().toLowerCase();
-            } catch (IOException e) {
-                throw new ErrorDataDecoderException(e);
-            }
-            if (code.equals(HttpPostBodyUtil.TransferEncodingMechanism.BIT7.value())) {
-                localCharset = HttpPostBodyUtil.US_ASCII;
-            } else if (code.equals(HttpPostBodyUtil.TransferEncodingMechanism.BIT8.value())) {
-                localCharset = HttpPostBodyUtil.ISO_8859_1;
-                mechanism = TransferEncodingMechanism.BIT8;
-            } else if (code.equals(HttpPostBodyUtil.TransferEncodingMechanism.BINARY.value())) {
-                // no real charset, so let the default
-                mechanism = TransferEncodingMechanism.BINARY;
-            } else {
-                throw new ErrorDataDecoderException("TransferEncoding Unknown: " + code);
-            }
-        }
-        Attribute charsetAttribute = currentFieldAttributes.get(HttpHeaders.Values.CHARSET);
-        if (charsetAttribute != null) {
-            try {
-                localCharset = Charset.forName(charsetAttribute.getValue());
-            } catch (IOException e) {
-                throw new ErrorDataDecoderException(e);
-            }
-        }
-        if (currentFileUpload == null) {
-            Attribute filenameAttribute = currentFieldAttributes.get(HttpPostBodyUtil.FILENAME);
-            Attribute nameAttribute = currentFieldAttributes.get(HttpPostBodyUtil.NAME);
-            Attribute contentTypeAttribute = currentFieldAttributes.get(HttpHeaders.Names.CONTENT_TYPE);
-            if (contentTypeAttribute == null) {
-                throw new ErrorDataDecoderException("Content-Type is absent but required");
-            }
-            Attribute lengthAttribute = currentFieldAttributes.get(HttpHeaders.Names.CONTENT_LENGTH);
-            long size;
-            try {
-                size = lengthAttribute != null ? Long.parseLong(lengthAttribute.getValue()) : 0L;
-            } catch (IOException e) {
-                throw new ErrorDataDecoderException(e);
-            } catch (NumberFormatException e) {
-                size = 0;
-            }
-            try {
-                currentFileUpload = factory.createFileUpload(request,
-                        cleanString(nameAttribute.getValue()), cleanString(filenameAttribute.getValue()),
-                        contentTypeAttribute.getValue(), mechanism.value(), localCharset,
-                        size);
-            } catch (NullPointerException e) {
-                throw new ErrorDataDecoderException(e);
-            } catch (IllegalArgumentException e) {
-                throw new ErrorDataDecoderException(e);
-            } catch (IOException e) {
-                throw new ErrorDataDecoderException(e);
-            }
-        }
-        // load data as much as possible
-        try {
-            readFileUploadByteMultipart(delimiter);
-        } catch (NotEnoughDataDecoderException e) {
-            // do not change the buffer position
-            // since some can be already saved into FileUpload
-            // So do not change the currentStatus
-            return null;
-        }
-        if (currentFileUpload.isCompleted()) {
-            // ready to load the next one
-            if (currentStatus == MultiPartStatus.FILEUPLOAD) {
-                currentStatus = MultiPartStatus.HEADERDELIMITER;
-                currentFieldAttributes = null;
-            } else {
-                currentStatus = MultiPartStatus.MIXEDDELIMITER;
-                cleanMixedAttributes();
-            }
-            FileUpload fileUpload = currentFileUpload;
-            currentFileUpload = null;
-            return fileUpload;
-        }
-        // do not change the buffer position
-        // since some can be already saved into FileUpload
-        // So do not change the currentStatus
-        return null;
+    @Override
+    public InterfaceHttpData next() {
+        return decoder.next();
     }
 
-    /**
-     * Destroy the {@link HttpPostRequestDecoder} and release all it resources. After this method
-     * was called it is not possible to operate on it anymore.
-     */
+    @Override
     public void destroy() {
-        checkDestroyed();
-        cleanFiles();
-        destroyed = true;
-
-        if (undecodedChunk != null && undecodedChunk.refCnt() > 0) {
-            undecodedChunk.release();
-            undecodedChunk = null;
-        }
-
-        // release all data which was not yet pulled
-        for (int i = bodyListHttpDataRank; i < bodyListHttpData.size(); i++) {
-            bodyListHttpData.get(i).release();
-        }
+        decoder.destroy();
     }
 
-    /**
-     * Clean all HttpDatas (on Disk) for the current request.
-     */
+    @Override
     public void cleanFiles() {
-        checkDestroyed();
-
-        factory.cleanRequestHttpDatas(request);
+        decoder.cleanFiles();
     }
 
-    /**
-     * Remove the given FileUpload from the list of FileUploads to clean
-     */
+    @Override
     public void removeHttpDataFromClean(InterfaceHttpData data) {
-        checkDestroyed();
-
-        factory.removeHttpDataFromClean(request, data);
-    }
-
-    /**
-     * Remove all Attributes that should be cleaned between two FileUpload in
-     * Mixed mode
-     */
-    private void cleanMixedAttributes() {
-        currentFieldAttributes.remove(HttpHeaders.Values.CHARSET);
-        currentFieldAttributes.remove(HttpHeaders.Names.CONTENT_LENGTH);
-        currentFieldAttributes.remove(HttpHeaders.Names.CONTENT_TRANSFER_ENCODING);
-        currentFieldAttributes.remove(HttpHeaders.Names.CONTENT_TYPE);
-        currentFieldAttributes.remove(HttpPostBodyUtil.FILENAME);
-    }
-
-    /**
-     * Read one line up to the CRLF or LF
-     *
-     * @return the String from one line
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks and reset the readerInder to the previous
-     *             value
-     */
-    private String readLineStandard() throws NotEnoughDataDecoderException {
-        int readerIndex = undecodedChunk.readerIndex();
-        try {
-            ByteBuf line = buffer(64);
-
-            while (undecodedChunk.isReadable()) {
-                byte nextByte = undecodedChunk.readByte();
-                if (nextByte == HttpConstants.CR) {
-                    nextByte = undecodedChunk.readByte();
-                    if (nextByte == HttpConstants.LF) {
-                        return line.toString(charset);
-                    }
-                } else if (nextByte == HttpConstants.LF) {
-                    return line.toString(charset);
-                } else {
-                    line.writeByte(nextByte);
-                }
-            }
-        } catch (IndexOutOfBoundsException e) {
-            undecodedChunk.readerIndex(readerIndex);
-            throw new NotEnoughDataDecoderException(e);
-        }
-        undecodedChunk.readerIndex(readerIndex);
-        throw new NotEnoughDataDecoderException();
+        decoder.removeHttpDataFromClean(data);
     }
 
     /**
-     * Read one line up to the CRLF or LF
+     * Split the very first line (Content-Type value) in 3 Strings
      *
-     * @return the String from one line
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks and reset the readerInder to the previous
-     *             value
-     */
-    private String readLine() throws NotEnoughDataDecoderException {
-        SeekAheadOptimize sao;
-        try {
-            sao = new SeekAheadOptimize(undecodedChunk);
-        } catch (SeekAheadNoBackArrayException e1) {
-            return readLineStandard();
-        }
-        int readerIndex = undecodedChunk.readerIndex();
-        try {
-            ByteBuf line = buffer(64);
-
-            while (sao.pos < sao.limit) {
-                byte nextByte = sao.bytes[sao.pos++];
-                if (nextByte == HttpConstants.CR) {
-                    if (sao.pos < sao.limit) {
-                        nextByte = sao.bytes[sao.pos++];
-                        if (nextByte == HttpConstants.LF) {
-                            sao.setReadPosition(0);
-                            return line.toString(charset);
-                        }
-                    } else {
-                        line.writeByte(nextByte);
-                    }
-                } else if (nextByte == HttpConstants.LF) {
-                    sao.setReadPosition(0);
-                    return line.toString(charset);
-                } else {
-                    line.writeByte(nextByte);
-                }
-            }
-        } catch (IndexOutOfBoundsException e) {
-            undecodedChunk.readerIndex(readerIndex);
-            throw new NotEnoughDataDecoderException(e);
-        }
-        undecodedChunk.readerIndex(readerIndex);
-        throw new NotEnoughDataDecoderException();
-    }
-
-    /**
-     * Read one line up to --delimiter or --delimiter-- and if existing the CRLF
-     * or LF Read one line up to --delimiter or --delimiter-- and if existing
-     * the CRLF or LF. Note that CRLF or LF are mandatory for opening delimiter
-     * (--delimiter) but not for closing delimiter (--delimiter--) since some
-     * clients does not include CRLF in this case.
-     *
-     * @param delimiter
-     *            of the form --string, such that '--' is already included
-     * @return the String from one line as the delimiter searched (opening or
-     *         closing)
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks and reset the readerInder to the previous
-     *             value
-     */
-    private String readDelimiterStandard(String delimiter) throws NotEnoughDataDecoderException {
-        int readerIndex = undecodedChunk.readerIndex();
-        try {
-            StringBuilder sb = new StringBuilder(64);
-            int delimiterPos = 0;
-            int len = delimiter.length();
-            while (undecodedChunk.isReadable() && delimiterPos < len) {
-                byte nextByte = undecodedChunk.readByte();
-                if (nextByte == delimiter.charAt(delimiterPos)) {
-                    delimiterPos++;
-                    sb.append((char) nextByte);
-                } else {
-                    // delimiter not found so break here !
-                    undecodedChunk.readerIndex(readerIndex);
-                    throw new NotEnoughDataDecoderException();
-                }
-            }
-            // Now check if either opening delimiter or closing delimiter
-            if (undecodedChunk.isReadable()) {
-                byte nextByte = undecodedChunk.readByte();
-                // first check for opening delimiter
-                if (nextByte == HttpConstants.CR) {
-                    nextByte = undecodedChunk.readByte();
-                    if (nextByte == HttpConstants.LF) {
-                        return sb.toString();
-                    } else {
-                        // error since CR must be followed by LF
-                        // delimiter not found so break here !
-                        undecodedChunk.readerIndex(readerIndex);
-                        throw new NotEnoughDataDecoderException();
-                    }
-                } else if (nextByte == HttpConstants.LF) {
-                    return sb.toString();
-                } else if (nextByte == '-') {
-                    sb.append('-');
-                    // second check for closing delimiter
-                    nextByte = undecodedChunk.readByte();
-                    if (nextByte == '-') {
-                        sb.append('-');
-                        // now try to find if CRLF or LF there
-                        if (undecodedChunk.isReadable()) {
-                            nextByte = undecodedChunk.readByte();
-                            if (nextByte == HttpConstants.CR) {
-                                nextByte = undecodedChunk.readByte();
-                                if (nextByte == HttpConstants.LF) {
-                                    return sb.toString();
-                                } else {
-                                    // error CR without LF
-                                    // delimiter not found so break here !
-                                    undecodedChunk.readerIndex(readerIndex);
-                                    throw new NotEnoughDataDecoderException();
-                                }
-                            } else if (nextByte == HttpConstants.LF) {
-                                return sb.toString();
-                            } else {
-                                // No CRLF but ok however (Adobe Flash uploader)
-                                // minus 1 since we read one char ahead but
-                                // should not
-                                undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
-                                return sb.toString();
-                            }
-                        }
-                        // FIXME what do we do here?
-                        // either considering it is fine, either waiting for
-                        // more data to come?
-                        // lets try considering it is fine...
-                        return sb.toString();
-                    }
-                    // only one '-' => not enough
-                    // whatever now => error since incomplete
-                }
-            }
-        } catch (IndexOutOfBoundsException e) {
-            undecodedChunk.readerIndex(readerIndex);
-            throw new NotEnoughDataDecoderException(e);
-        }
-        undecodedChunk.readerIndex(readerIndex);
-        throw new NotEnoughDataDecoderException();
-    }
-
-    /**
-     * Read one line up to --delimiter or --delimiter-- and if existing the CRLF
-     * or LF. Note that CRLF or LF are mandatory for opening delimiter
-     * (--delimiter) but not for closing delimiter (--delimiter--) since some
-     * clients does not include CRLF in this case.
-     *
-     * @param delimiter
-     *            of the form --string, such that '--' is already included
-     * @return the String from one line as the delimiter searched (opening or
-     *         closing)
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks and reset the readerInder to the previous
-     *             value
-     */
-    private String readDelimiter(String delimiter) throws NotEnoughDataDecoderException {
-        SeekAheadOptimize sao;
-        try {
-            sao = new SeekAheadOptimize(undecodedChunk);
-        } catch (SeekAheadNoBackArrayException e1) {
-            return readDelimiterStandard(delimiter);
-        }
-        int readerIndex = undecodedChunk.readerIndex();
-        int delimiterPos = 0;
-        int len = delimiter.length();
-        try {
-            StringBuilder sb = new StringBuilder(64);
-            // check conformity with delimiter
-            while (sao.pos < sao.limit && delimiterPos < len) {
-                byte nextByte = sao.bytes[sao.pos++];
-                if (nextByte == delimiter.charAt(delimiterPos)) {
-                    delimiterPos++;
-                    sb.append((char) nextByte);
-                } else {
-                    // delimiter not found so break here !
-                    undecodedChunk.readerIndex(readerIndex);
-                    throw new NotEnoughDataDecoderException();
-                }
-            }
-            // Now check if either opening delimiter or closing delimiter
-            if (sao.pos < sao.limit) {
-                byte nextByte = sao.bytes[sao.pos++];
-                if (nextByte == HttpConstants.CR) {
-                    // first check for opening delimiter
-                    if (sao.pos < sao.limit) {
-                        nextByte = sao.bytes[sao.pos++];
-                        if (nextByte == HttpConstants.LF) {
-                            sao.setReadPosition(0);
-                            return sb.toString();
-                        }
-                    } else {
-                        // error since CR must be followed by LF
-                        // delimiter not found so break here !
-                        undecodedChunk.readerIndex(readerIndex);
-                        throw new NotEnoughDataDecoderException();
-                    }
-                } else if (nextByte == HttpConstants.LF) {
-                    // same first check for opening delimiter where LF used with
-                    // no CR
-                    sao.setReadPosition(0);
-                    return sb.toString();
-                } else if (nextByte == '-') {
-                    sb.append('-');
-                    // second check for closing delimiter
-                    if (sao.pos < sao.limit) {
-                        nextByte = sao.bytes[sao.pos++];
-                        if (nextByte == '-') {
-                            sb.append('-');
-                            // now try to find if CRLF or LF there
-                            if (sao.pos < sao.limit) {
-                                nextByte = sao.bytes[sao.pos++];
-                                if (nextByte == HttpConstants.CR) {
-                                    if (sao.pos < sao.limit) {
-                                        nextByte = sao.bytes[sao.pos++];
-                                        if (nextByte == HttpConstants.LF) {
-                                            sao.setReadPosition(0);
-                                            return sb.toString();
-                                        }
-                                    } else {
-                                        // error CR without LF
-                                        // delimiter not found so break here !
-                                        undecodedChunk.readerIndex(readerIndex);
-                                        throw new NotEnoughDataDecoderException();
-                                    }
-                                } else if (nextByte == HttpConstants.LF) {
-                                    sao.setReadPosition(0);
-                                    return sb.toString();
-                                } else {
-                                    // No CRLF but ok however (Adobe Flash
-                                    // uploader)
-                                    // minus 1 since we read one char ahead but
-                                    // should not
-                                    sao.setReadPosition(1);
-                                    return sb.toString();
-                                }
-                            }
-                            // FIXME what do we do here?
-                            // either considering it is fine, either waiting for
-                            // more data to come?
-                            // lets try considering it is fine...
-                            sao.setReadPosition(0);
-                            return sb.toString();
-                        }
-                        // whatever now => error since incomplete
-                        // only one '-' => not enough or whatever not enough
-                        // element
-                    }
-                }
-            }
-        } catch (IndexOutOfBoundsException e) {
-            undecodedChunk.readerIndex(readerIndex);
-            throw new NotEnoughDataDecoderException(e);
-        }
-        undecodedChunk.readerIndex(readerIndex);
-        throw new NotEnoughDataDecoderException();
-    }
-
-    /**
-     * Read a FileUpload data as Byte (Binary) and add the bytes directly to the
-     * FileUpload. If the delimiter is found, the FileUpload is completed.
-     *
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks but do not reset the readerInder since some
-     *             values will be already added to the FileOutput
-     * @throws ErrorDataDecoderException
-     *             write IO error occurs with the FileUpload
-     */
-    private void readFileUploadByteMultipartStandard(String delimiter) throws NotEnoughDataDecoderException,
-            ErrorDataDecoderException {
-        int readerIndex = undecodedChunk.readerIndex();
-        // found the decoder limit
-        boolean newLine = true;
-        int index = 0;
-        int lastPosition = undecodedChunk.readerIndex();
-        boolean found = false;
-        while (undecodedChunk.isReadable()) {
-            byte nextByte = undecodedChunk.readByte();
-            if (newLine) {
-                // Check the delimiter
-                if (nextByte == delimiter.codePointAt(index)) {
-                    index++;
-                    if (delimiter.length() == index) {
-                        found = true;
-                        break;
-                    }
-                    continue;
-                } else {
-                    newLine = false;
-                    index = 0;
-                    // continue until end of line
-                    if (nextByte == HttpConstants.CR) {
-                        if (undecodedChunk.isReadable()) {
-                            nextByte = undecodedChunk.readByte();
-                            if (nextByte == HttpConstants.LF) {
-                                newLine = true;
-                                index = 0;
-                                lastPosition = undecodedChunk.readerIndex() - 2;
-                            } else {
-                                // save last valid position
-                                lastPosition = undecodedChunk.readerIndex() - 1;
-
-                                // Unread next byte.
-                                undecodedChunk.readerIndex(lastPosition);
-                            }
-                        }
-                    } else if (nextByte == HttpConstants.LF) {
-                        newLine = true;
-                        index = 0;
-                        lastPosition = undecodedChunk.readerIndex() - 1;
-                    } else {
-                        // save last valid position
-                        lastPosition = undecodedChunk.readerIndex();
-                    }
-                }
-            } else {
-                // continue until end of line
-                if (nextByte == HttpConstants.CR) {
-                    if (undecodedChunk.isReadable()) {
-                        nextByte = undecodedChunk.readByte();
-                        if (nextByte == HttpConstants.LF) {
-                            newLine = true;
-                            index = 0;
-                            lastPosition = undecodedChunk.readerIndex() - 2;
-                        } else {
-                            // save last valid position
-                            lastPosition = undecodedChunk.readerIndex() - 1;
-
-                            // Unread next byte.
-                            undecodedChunk.readerIndex(lastPosition);
-                        }
-                    }
-                } else if (nextByte == HttpConstants.LF) {
-                    newLine = true;
-                    index = 0;
-                    lastPosition = undecodedChunk.readerIndex() - 1;
-                } else {
-                    // save last valid position
-                    lastPosition = undecodedChunk.readerIndex();
-                }
-            }
-        }
-        ByteBuf buffer = undecodedChunk.copy(readerIndex, lastPosition - readerIndex);
-        if (found) {
-            // found so lastPosition is correct and final
-            try {
-                currentFileUpload.addContent(buffer, true);
-                // just before the CRLF and delimiter
-                undecodedChunk.readerIndex(lastPosition);
-            } catch (IOException e) {
-                throw new ErrorDataDecoderException(e);
-            }
-        } else {
-            // possibly the delimiter is partially found but still the last
-            // position is OK
-            try {
-                currentFileUpload.addContent(buffer, false);
-                // last valid char (not CR, not LF, not beginning of delimiter)
-                undecodedChunk.readerIndex(lastPosition);
-                throw new NotEnoughDataDecoderException();
-            } catch (IOException e) {
-                throw new ErrorDataDecoderException(e);
-            }
-        }
-    }
-
-    /**
-     * Read a FileUpload data as Byte (Binary) and add the bytes directly to the
-     * FileUpload. If the delimiter is found, the FileUpload is completed.
-     *
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks but do not reset the readerInder since some
-     *             values will be already added to the FileOutput
-     * @throws ErrorDataDecoderException
-     *             write IO error occurs with the FileUpload
-     */
-    private void readFileUploadByteMultipart(String delimiter) throws NotEnoughDataDecoderException,
-            ErrorDataDecoderException {
-        SeekAheadOptimize sao;
-        try {
-            sao = new SeekAheadOptimize(undecodedChunk);
-        } catch (SeekAheadNoBackArrayException e1) {
-            readFileUploadByteMultipartStandard(delimiter);
-            return;
-        }
-        int readerIndex = undecodedChunk.readerIndex();
-        // found the decoder limit
-        boolean newLine = true;
-        int index = 0;
-        int lastrealpos = sao.pos;
-        int lastPosition;
-        boolean found = false;
-
-        while (sao.pos < sao.limit) {
-            byte nextByte = sao.bytes[sao.pos++];
-            if (newLine) {
-                // Check the delimiter
-                if (nextByte == delimiter.codePointAt(index)) {
-                    index++;
-                    if (delimiter.length() == index) {
-                        found = true;
-                        break;
-                    }
-                    continue;
-                } else {
-                    newLine = false;
-                    index = 0;
-                    // continue until end of line
-                    if (nextByte == HttpConstants.CR) {
-                        if (sao.pos < sao.limit) {
-                            nextByte = sao.bytes[sao.pos++];
-                            if (nextByte == HttpConstants.LF) {
-                                newLine = true;
-                                index = 0;
-                                lastrealpos = sao.pos - 2;
-                            } else {
-                                // unread next byte
-                                sao.pos--;
-
-                                // save last valid position
-                                lastrealpos = sao.pos;
-                            }
-                        }
-                    } else if (nextByte == HttpConstants.LF) {
-                        newLine = true;
-                        index = 0;
-                        lastrealpos = sao.pos - 1;
-                    } else {
-                        // save last valid position
-                        lastrealpos = sao.pos;
-                    }
-                }
-            } else {
-                // continue until end of line
-                if (nextByte == HttpConstants.CR) {
-                    if (sao.pos < sao.limit) {
-                        nextByte = sao.bytes[sao.pos++];
-                        if (nextByte == HttpConstants.LF) {
-                            newLine = true;
-                            index = 0;
-                            lastrealpos = sao.pos - 2;
-                        } else {
-                            // unread next byte
-                            sao.pos--;
-
-                            // save last valid position
-                            lastrealpos = sao.pos;
-                        }
-                    }
-                } else if (nextByte == HttpConstants.LF) {
-                    newLine = true;
-                    index = 0;
-                    lastrealpos = sao.pos - 1;
-                } else {
-                    // save last valid position
-                    lastrealpos = sao.pos;
-                }
-            }
-        }
-        lastPosition = sao.getReadPosition(lastrealpos);
-        ByteBuf buffer = undecodedChunk.copy(readerIndex, lastPosition - readerIndex);
-        if (found) {
-            // found so lastPosition is correct and final
-            try {
-                currentFileUpload.addContent(buffer, true);
-                // just before the CRLF and delimiter
-                undecodedChunk.readerIndex(lastPosition);
-            } catch (IOException e) {
-                throw new ErrorDataDecoderException(e);
-            }
-        } else {
-            // possibly the delimiter is partially found but still the last
-            // position is OK
-            try {
-                currentFileUpload.addContent(buffer, false);
-                // last valid char (not CR, not LF, not beginning of delimiter)
-                undecodedChunk.readerIndex(lastPosition);
-                throw new NotEnoughDataDecoderException();
-            } catch (IOException e) {
-                throw new ErrorDataDecoderException(e);
-            }
-        }
-    }
-
-    /**
-     * Load the field value from a Multipart request
-     *
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks
-     * @throws ErrorDataDecoderException
-     */
-    private void loadFieldMultipartStandard(String delimiter) throws NotEnoughDataDecoderException,
-            ErrorDataDecoderException {
-        int readerIndex = undecodedChunk.readerIndex();
-        try {
-            // found the decoder limit
-            boolean newLine = true;
-            int index = 0;
-            int lastPosition = undecodedChunk.readerIndex();
-            boolean found = false;
-            while (undecodedChunk.isReadable()) {
-                byte nextByte = undecodedChunk.readByte();
-                if (newLine) {
-                    // Check the delimiter
-                    if (nextByte == delimiter.codePointAt(index)) {
-                        index++;
-                        if (delimiter.length() == index) {
-                            found = true;
-                            break;
-                        }
-                        continue;
-                    } else {
-                        newLine = false;
-                        index = 0;
-                        // continue until end of line
-                        if (nextByte == HttpConstants.CR) {
-                            if (undecodedChunk.isReadable()) {
-                                nextByte = undecodedChunk.readByte();
-                                if (nextByte == HttpConstants.LF) {
-                                    newLine = true;
-                                    index = 0;
-                                    lastPosition = undecodedChunk.readerIndex() - 2;
-                                }
-                            }
-                        } else if (nextByte == HttpConstants.LF) {
-                            newLine = true;
-                            index = 0;
-                            lastPosition = undecodedChunk.readerIndex() - 1;
-                        } else {
-                            lastPosition = undecodedChunk.readerIndex();
-                        }
-                    }
-                } else {
-                    // continue until end of line
-                    if (nextByte == HttpConstants.CR) {
-                        if (undecodedChunk.isReadable()) {
-                            nextByte = undecodedChunk.readByte();
-                            if (nextByte == HttpConstants.LF) {
-                                newLine = true;
-                                index = 0;
-                                lastPosition = undecodedChunk.readerIndex() - 2;
-                            }
-                        }
-                    } else if (nextByte == HttpConstants.LF) {
-                        newLine = true;
-                        index = 0;
-                        lastPosition = undecodedChunk.readerIndex() - 1;
-                    } else {
-                        lastPosition = undecodedChunk.readerIndex();
-                    }
-                }
-            }
-            if (found) {
-                // found so lastPosition is correct
-                // but position is just after the delimiter (either close
-                // delimiter or simple one)
-                // so go back of delimiter size
-                try {
-                    currentAttribute.addContent(
-                            undecodedChunk.copy(readerIndex, lastPosition - readerIndex), true);
-                } catch (IOException e) {
-                    throw new ErrorDataDecoderException(e);
-                }
-                undecodedChunk.readerIndex(lastPosition);
-            } else {
-                try {
-                    currentAttribute.addContent(
-                            undecodedChunk.copy(readerIndex, lastPosition - readerIndex), false);
-                } catch (IOException e) {
-                    throw new ErrorDataDecoderException(e);
-                }
-                undecodedChunk.readerIndex(lastPosition);
-                throw new NotEnoughDataDecoderException();
-            }
-        } catch (IndexOutOfBoundsException e) {
-            undecodedChunk.readerIndex(readerIndex);
-            throw new NotEnoughDataDecoderException(e);
-        }
-    }
-
-    /**
-     * Load the field value from a Multipart request
-     *
-     * @throws NotEnoughDataDecoderException
-     *             Need more chunks
-     * @throws ErrorDataDecoderException
-     */
-    private void loadFieldMultipart(String delimiter) throws NotEnoughDataDecoderException, ErrorDataDecoderException {
-        SeekAheadOptimize sao;
-        try {
-            sao = new SeekAheadOptimize(undecodedChunk);
-        } catch (SeekAheadNoBackArrayException e1) {
-            loadFieldMultipartStandard(delimiter);
-            return;
-        }
-        int readerIndex = undecodedChunk.readerIndex();
-        try {
-            // found the decoder limit
-            boolean newLine = true;
-            int index = 0;
-            int lastPosition;
-            int lastrealpos = sao.pos;
-            boolean found = false;
-
-            while (sao.pos < sao.limit) {
-                byte nextByte = sao.bytes[sao.pos++];
-                if (newLine) {
-                    // Check the delimiter
-                    if (nextByte == delimiter.codePointAt(index)) {
-                        index++;
-                        if (delimiter.length() == index) {
-                            found = true;
-                            break;
-                        }
-                        continue;
-                    } else {
-                        newLine = false;
-                        index = 0;
-                        // continue until end of line
-                        if (nextByte == HttpConstants.CR) {
-                            if (sao.pos < sao.limit) {
-                                nextByte = sao.bytes[sao.pos++];
-                                if (nextByte == HttpConstants.LF) {
-                                    newLine = true;
-                                    index = 0;
-                                    lastrealpos = sao.pos - 2;
-                                }
-                            }
-                        } else if (nextByte == HttpConstants.LF) {
-                            newLine = true;
-                            index = 0;
-                            lastrealpos = sao.pos - 1;
-                        } else {
-                            lastrealpos = sao.pos;
-                        }
-                    }
-                } else {
-                    // continue until end of line
-                    if (nextByte == HttpConstants.CR) {
-                        if (sao.pos < sao.limit) {
-                            nextByte = sao.bytes[sao.pos++];
-                            if (nextByte == HttpConstants.LF) {
-                                newLine = true;
-                                index = 0;
-                                lastrealpos = sao.pos - 2;
-                            }
-                        }
-                    } else if (nextByte == HttpConstants.LF) {
-                        newLine = true;
-                        index = 0;
-                        lastrealpos = sao.pos - 1;
-                    } else {
-                        lastrealpos = sao.pos;
-                    }
-                }
-            }
-            lastPosition = sao.getReadPosition(lastrealpos);
-            if (found) {
-                // found so lastPosition is correct
-                // but position is just after the delimiter (either close
-                // delimiter or simple one)
-                // so go back of delimiter size
-                try {
-                    currentAttribute.addContent(
-                            undecodedChunk.copy(readerIndex, lastPosition - readerIndex), true);
-                } catch (IOException e) {
-                    throw new ErrorDataDecoderException(e);
-                }
-                undecodedChunk.readerIndex(lastPosition);
-            } else {
-                try {
-                    currentAttribute.addContent(
-                            undecodedChunk.copy(readerIndex, lastPosition - readerIndex), false);
-                } catch (IOException e) {
-                    throw new ErrorDataDecoderException(e);
-                }
-                undecodedChunk.readerIndex(lastPosition);
-                throw new NotEnoughDataDecoderException();
-            }
-        } catch (IndexOutOfBoundsException e) {
-            undecodedChunk.readerIndex(readerIndex);
-            throw new NotEnoughDataDecoderException(e);
-        }
-    }
-
-    /**
-     * Clean the String from any unallowed character
-     *
-     * @return the cleaned String
-     */
-    private static String cleanString(String field) {
-        StringBuilder sb = new StringBuilder(field.length());
-        for (int i = 0; i < field.length(); i++) {
-            char nextChar = field.charAt(i);
-            if (nextChar == HttpConstants.COLON) {
-                sb.append(HttpConstants.SP);
-            } else if (nextChar == HttpConstants.COMMA) {
-                sb.append(HttpConstants.SP);
-            } else if (nextChar == HttpConstants.EQUALS) {
-                sb.append(HttpConstants.SP);
-            } else if (nextChar == HttpConstants.SEMICOLON) {
-                sb.append(HttpConstants.SP);
-            } else if (nextChar == HttpConstants.HT) {
-                sb.append(HttpConstants.SP);
-            } else if (nextChar == HttpConstants.DOUBLE_QUOTE) {
-                // nothing added, just removes it
-            } else {
-                sb.append(nextChar);
-            }
-        }
-        return sb.toString().trim();
-    }
-
-    /**
-     * Skip one empty line
-     *
-     * @return True if one empty line was skipped
-     */
-    private boolean skipOneLine() {
-        if (!undecodedChunk.isReadable()) {
-            return false;
-        }
-        byte nextByte = undecodedChunk.readByte();
-        if (nextByte == HttpConstants.CR) {
-            if (!undecodedChunk.isReadable()) {
-                undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
-                return false;
-            }
-            nextByte = undecodedChunk.readByte();
-            if (nextByte == HttpConstants.LF) {
-                return true;
-            }
-            undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 2);
-            return false;
-        }
-        if (nextByte == HttpConstants.LF) {
-            return true;
-        }
-        undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
-        return false;
-    }
-
-    /**
-     * Split the very first line (Content-Type value) in 2 Strings
-     *
-     * @return the array of 2 Strings
+     * @return the array of 3 Strings
      */
     private static String[] splitHeaderContentType(String sb) {
         int aStart;
         int aEnd;
         int bStart;
         int bEnd;
+        int cStart;
+        int cEnd;
         aStart = HttpPostBodyUtil.findNonWhitespace(sb, 0);
         aEnd =  sb.indexOf(';');
         if (aEnd == -1) {
-            return new String[] { sb, "" };
+            return new String[] { sb, "", "" };
         }
+        bStart = HttpPostBodyUtil.findNonWhitespace(sb, aEnd + 1);
         if (sb.charAt(aEnd - 1) == ' ') {
             aEnd--;
         }
-        bStart = HttpPostBodyUtil.findNonWhitespace(sb, aEnd + 1);
-        bEnd = HttpPostBodyUtil.findEndOfString(sb);
-        return new String[] { sb.substring(aStart, aEnd), sb.substring(bStart, bEnd) };
-    }
-
-    /**
-     * Split one header in Multipart
-     *
-     * @return an array of String where rank 0 is the name of the header,
-     *         follows by several values that were separated by ';' or ','
-     */
-    private static String[] splitMultipartHeader(String sb) {
-        ArrayList<String> headers = new ArrayList<String>(1);
-        int nameStart;
-        int nameEnd;
-        int colonEnd;
-        int valueStart;
-        int valueEnd;
-        nameStart = HttpPostBodyUtil.findNonWhitespace(sb, 0);
-        for (nameEnd = nameStart; nameEnd < sb.length(); nameEnd++) {
-            char ch = sb.charAt(nameEnd);
-            if (ch == ':' || Character.isWhitespace(ch)) {
-                break;
-            }
+        bEnd =  sb.indexOf(';', bStart);
+        if (bEnd == -1) {
+            bEnd = HttpPostBodyUtil.findEndOfString(sb);
+            return new String[] { sb.substring(aStart, aEnd), sb.substring(bStart, bEnd), "" };
         }
-        for (colonEnd = nameEnd; colonEnd < sb.length(); colonEnd++) {
-            if (sb.charAt(colonEnd) == ':') {
-                colonEnd++;
-                break;
-            }
-        }
-        valueStart = HttpPostBodyUtil.findNonWhitespace(sb, colonEnd);
-        valueEnd = HttpPostBodyUtil.findEndOfString(sb);
-        headers.add(sb.substring(nameStart, nameEnd));
-        String svalue = sb.substring(valueStart, valueEnd);
-        String[] values;
-        if (svalue.indexOf(';') >= 0) {
-            values = StringUtil.split(svalue, ';');
-        } else {
-            values = StringUtil.split(svalue, ',');
-        }
-        for (String value : values) {
-            headers.add(value.trim());
+        cStart = HttpPostBodyUtil.findNonWhitespace(sb, bEnd + 1);
+        if (sb.charAt(bEnd - 1) == ' ') {
+            bEnd--;
         }
-        String[] array = new String[headers.size()];
-        for (int i = 0; i < headers.size(); i++) {
-            array[i] = headers.get(i);
-        }
-        return array;
+        cEnd = HttpPostBodyUtil.findEndOfString(sb);
+        return new String[] { sb.substring(aStart, aEnd), sb.substring(bStart, bEnd), sb.substring(cStart, cEnd) };
     }
 
     /**
@@ -2168,26 +337,4 @@ public ErrorDataDecoderException(String msg, Throwable cause) {
             super(msg, cause);
         }
     }
-
-    /**
-     * Exception when an unappropriated getMethod was called on a request
-     */
-    public static class IncompatibleDataDecoderException extends DecoderException {
-        private static final long serialVersionUID = -953268047926250267L;
-
-        public IncompatibleDataDecoderException() {
-        }
-
-        public IncompatibleDataDecoderException(String msg) {
-            super(msg);
-        }
-
-        public IncompatibleDataDecoderException(Throwable cause) {
-            super(cause);
-        }
-
-        public IncompatibleDataDecoderException(String msg, Throwable cause) {
-            super(msg, cause);
-        }
-    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
index 476548534835..e984b5f5979a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpContent;
@@ -55,15 +56,26 @@ public class HttpPostRequestEncoder implements ChunkedInput<HttpContent> {
      */
     public enum EncoderMode {
         /**
-         *  Legacy mode which should work for most. It is known to not work with OAUTH. For OAUTH use
-         *  {@link EncoderMode#RFC3986}. The W3C form recommentations this for submitting post form data.
+         * Legacy mode which should work for most. It is known to not work with OAUTH. For OAUTH use
+         * {@link EncoderMode#RFC3986}. The W3C form recommentations this for submitting post form data.
          */
         RFC1738,
 
         /**
          * Mode which is more new and is used for OAUTH
          */
-        RFC3986
+        RFC3986,
+
+        /**
+         * The HTML5 spec disallows mixed mode in multipart/form-data
+         * requests. More concretely this means that more files submitted
+         * under the same name will not be encoded using mixed mode, but
+         * will be treated as distinct fields.
+         *
+         * Reference:
+         *   http://www.w3.org/TR/html5/forms.html#multipart-form-data
+         */
+        HTML5
     }
 
     private static final Map<Pattern, String> percentEncodings = new HashMap<Pattern, String>();
@@ -188,7 +200,9 @@ public HttpPostRequestEncoder(
         if (charset == null) {
             throw new NullPointerException("charset");
         }
-        if (request.getMethod() != HttpMethod.POST) {
+        HttpMethod method = request.method();
+        if (!(method.equals(HttpMethod.POST) || method.equals(HttpMethod.PUT)
+                || method.equals(HttpMethod.PATCH) || method.equals(HttpMethod.OPTIONS))) {
             throw new ErrorDataEncoderException("Cannot create a Encoder if not a POST");
         }
         this.request = request;
@@ -211,7 +225,7 @@ public HttpPostRequestEncoder(
      * Clean all HttpDatas (on Disk) for the current request.
      */
     public void cleanFiles() {
-        factory.cleanRequestHttpDatas(request);
+        factory.cleanRequestHttpData(request);
     }
 
     /**
@@ -370,7 +384,7 @@ public void addBodyFileUpload(String name, File file, String contentType, boolea
     }
 
     /**
-     * Add a series of Files associated with one File parameter (implied Mixed mode in Multipart)
+     * Add a series of Files associated with one File parameter
      *
      * @param name
      *            the name of the parameter
@@ -532,7 +546,8 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
                     duringMixedMode = false;
                 }
             } else {
-                if (currentFileUpload != null && currentFileUpload.getName().equals(fileUpload.getName())) {
+                if (encoderMode != EncoderMode.HTML5 && currentFileUpload != null
+                        && currentFileUpload.getName().equals(fileUpload.getName())) {
                     // create a new mixed mode (from previous file)
 
                     // change multipart body header of previous file into
@@ -551,7 +566,7 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
                     // * Content-Type: multipart/mixed; boundary=BbC04y
                     // *
                     // * --BbC04y
-                    // * Content-Disposition: file; filename="file1.txt"
+                    // * Content-Disposition: attachment; filename="file1.txt"
                     // Content-Type: text/plain
                     initMixedMultipart();
                     InternalAttribute pastAttribute = (InternalAttribute) multipartHttpDatas.get(multipartHttpDatas
@@ -623,7 +638,7 @@ public void addBodyHttpData(InterfaceHttpData data) throws ErrorDataEncoderExcep
                 // add mixedmultipart delimiter, mixedmultipart body header and
                 // Data to multipart list
                 internal.addValue("--" + multipartMixedBoundary + "\r\n");
-                // Content-Disposition: file; filename="file1.txt"
+                // Content-Disposition: attachment; filename="file1.txt"
                 internal.addValue(HttpPostBodyUtil.CONTENT_DISPOSITION + ": " + HttpPostBodyUtil.ATTACHMENT + "; "
                         + HttpPostBodyUtil.FILENAME + "=\"" + fileUpload.getFilename() + "\"\r\n");
             } else {
@@ -698,7 +713,7 @@ public HttpRequest finalizeRequest() throws ErrorDataEncoderException {
                 // "multipart/form-data; boundary=--89421926422648"
                 String lowercased = contentType.toLowerCase();
                 if (lowercased.startsWith(HttpHeaders.Values.MULTIPART_FORM_DATA) ||
-                    lowercased.startsWith(HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED)) {
+                        lowercased.startsWith(HttpHeaders.Values.APPLICATION_X_WWW_FORM_URLENCODED)) {
                     // ignore
                 } else {
                     headers.add(HttpHeaders.Names.CONTENT_TYPE, contentType);
@@ -727,7 +742,7 @@ public HttpRequest finalizeRequest() throws ErrorDataEncoderException {
             if (transferEncoding != null) {
                 headers.remove(HttpHeaders.Names.TRANSFER_ENCODING);
                 for (String v : transferEncoding) {
-                    if (v.equalsIgnoreCase(HttpHeaders.Values.CHUNKED)) {
+                    if (AsciiString.equalsIgnoreCase(v, HttpHeaders.Values.CHUNKED)) {
                         // ignore
                     } else {
                         headers.add(HttpHeaders.Names.TRANSFER_ENCODING, v);
@@ -1116,17 +1131,32 @@ public HttpRequest setUri(String uri) {
 
         @Override
         public HttpMethod getMethod() {
-            return request.getMethod();
+            return request.method();
+        }
+
+        @Override
+        public HttpMethod method() {
+            return request.method();
         }
 
         @Override
         public String getUri() {
-            return request.getUri();
+            return request.uri();
+        }
+
+        @Override
+        public String uri() {
+            return request.uri();
         }
 
         @Override
         public HttpVersion getProtocolVersion() {
-            return request.getProtocolVersion();
+            return request.protocolVersion();
+        }
+
+        @Override
+        public HttpVersion protocolVersion() {
+            return request.protocolVersion();
         }
 
         @Override
@@ -1135,6 +1165,12 @@ public HttpHeaders headers() {
         }
 
         @Override
+        public DecoderResult decoderResult() {
+            return request.decoderResult();
+        }
+
+        @Override
+        @Deprecated
         public DecoderResult getDecoderResult() {
             return request.getDecoderResult();
         }
@@ -1147,6 +1183,7 @@ public void setDecoderResult(DecoderResult result) {
 
     private static final class WrappedFullHttpRequest extends WrappedHttpRequest implements FullHttpRequest {
         private final HttpContent content;
+
         private WrappedFullHttpRequest(HttpRequest request, HttpContent content) {
             super(request);
             this.content = content;
@@ -1200,6 +1237,18 @@ public FullHttpRequest retain() {
             return this;
         }
 
+        @Override
+        public FullHttpRequest touch() {
+            content.touch();
+            return this;
+        }
+
+        @Override
+        public FullHttpRequest touch(Object hint) {
+            content.touch(hint);
+            return this;
+        }
+
         @Override
         public ByteBuf content() {
             return content.content();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java
new file mode 100644
index 000000000000..d63f0575fdd4
--- /dev/null
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java
@@ -0,0 +1,731 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.http.multipart;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.http.HttpConstants;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.codec.http.QueryStringDecoder;
+import io.netty.handler.codec.http.multipart.HttpPostBodyUtil.SeekAheadNoBackArrayException;
+import io.netty.handler.codec.http.multipart.HttpPostBodyUtil.SeekAheadOptimize;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.MultiPartStatus;
+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.NotEnoughDataDecoderException;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+import static io.netty.buffer.Unpooled.*;
+
+/**
+ * This decoder will decode Body and can handle POST BODY.
+ *
+ * You <strong>MUST</strong> call {@link #destroy()} after completion to release all resources.
+ *
+ */
+public class HttpPostStandardRequestDecoder implements InterfaceHttpPostRequestDecoder {
+
+    /**
+     * Factory used to create InterfaceHttpData
+     */
+    private final HttpDataFactory factory;
+
+    /**
+     * Request to decode
+     */
+    private final HttpRequest request;
+
+    /**
+     * Default charset to use
+     */
+    private final Charset charset;
+
+    /**
+     * Does the last chunk already received
+     */
+    private boolean isLastChunk;
+
+    /**
+     * HttpDatas from Body
+     */
+    private final List<InterfaceHttpData> bodyListHttpData = new ArrayList<InterfaceHttpData>();
+
+    /**
+     * HttpDatas as Map from Body
+     */
+    private final Map<String, List<InterfaceHttpData>> bodyMapHttpData = new TreeMap<String, List<InterfaceHttpData>>(
+            CaseIgnoringComparator.INSTANCE);
+
+    /**
+     * The current channelBuffer
+     */
+    private ByteBuf undecodedChunk;
+
+    /**
+     * Body HttpDatas current position
+     */
+    private int bodyListHttpDataRank;
+
+    /**
+     * Current getStatus
+     */
+    private MultiPartStatus currentStatus = MultiPartStatus.NOTSTARTED;
+
+    /**
+     * The current Attribute that is currently in decode process
+     */
+    private Attribute currentAttribute;
+
+    private boolean destroyed;
+
+    private int discardThreshold = HttpPostRequestDecoder.DEFAULT_DISCARD_THRESHOLD;
+
+    /**
+     *
+     * @param request
+     *            the request to decode
+     * @throws NullPointerException
+     *             for request
+     * @throws ErrorDataDecoderException
+     *             if the default charset was wrong when decoding or other
+     *             errors
+     */
+    public HttpPostStandardRequestDecoder(HttpRequest request) {
+        this(new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE), request, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    /**
+     *
+     * @param factory
+     *            the factory used to create InterfaceHttpData
+     * @param request
+     *            the request to decode
+     * @throws NullPointerException
+     *             for request or factory
+     * @throws ErrorDataDecoderException
+     *             if the default charset was wrong when decoding or other
+     *             errors
+     */
+    public HttpPostStandardRequestDecoder(HttpDataFactory factory, HttpRequest request) {
+        this(factory, request, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    /**
+     *
+     * @param factory
+     *            the factory used to create InterfaceHttpData
+     * @param request
+     *            the request to decode
+     * @param charset
+     *            the charset to use as default
+     * @throws NullPointerException
+     *             for request or charset or factory
+     * @throws ErrorDataDecoderException
+     *             if the default charset was wrong when decoding or other
+     *             errors
+     */
+    public HttpPostStandardRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset) {
+        if (factory == null) {
+            throw new NullPointerException("factory");
+        }
+        if (request == null) {
+            throw new NullPointerException("request");
+        }
+        if (charset == null) {
+            throw new NullPointerException("charset");
+        }
+        this.request = request;
+        this.charset = charset;
+        this.factory = factory;
+        if (request instanceof HttpContent) {
+            // Offer automatically if the given request is als type of HttpContent
+            // See #1089
+            offer((HttpContent) request);
+        } else {
+            undecodedChunk = buffer();
+            parseBody();
+        }
+    }
+
+    private void checkDestroyed() {
+        if (destroyed) {
+            throw new IllegalStateException(HttpPostStandardRequestDecoder.class.getSimpleName()
+                    + " was destroyed already");
+        }
+    }
+
+    /**
+     * True if this request is a Multipart request
+     *
+     * @return True if this request is a Multipart request
+     */
+    @Override
+    public boolean isMultipart() {
+        checkDestroyed();
+        return false;
+    }
+
+    /**
+     * Set the amount of bytes after which read bytes in the buffer should be discarded.
+     * Setting this lower gives lower memory usage but with the overhead of more memory copies.
+     * Use {@code 0} to disable it.
+     */
+    @Override
+    public void setDiscardThreshold(int discardThreshold) {
+        if (discardThreshold < 0) {
+          throw new IllegalArgumentException("discardThreshold must be >= 0");
+        }
+        this.discardThreshold = discardThreshold;
+    }
+
+    /**
+     * Return the threshold in bytes after which read data in the buffer should be discarded.
+     */
+    @Override
+    public int getDiscardThreshold() {
+        return discardThreshold;
+    }
+
+    /**
+     * This getMethod returns a List of all HttpDatas from body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return the list of HttpDatas from Body part for POST getMethod
+     * @throws NotEnoughDataDecoderException
+     *             Need more chunks
+     */
+    @Override
+    public List<InterfaceHttpData> getBodyHttpDatas() {
+        checkDestroyed();
+
+        if (!isLastChunk) {
+            throw new NotEnoughDataDecoderException();
+        }
+        return bodyListHttpData;
+    }
+
+    /**
+     * This getMethod returns a List of all HttpDatas with the given name from
+     * body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return All Body HttpDatas with the given name (ignore case)
+     * @throws NotEnoughDataDecoderException
+     *             need more chunks
+     */
+    @Override
+    public List<InterfaceHttpData> getBodyHttpDatas(String name) {
+        checkDestroyed();
+
+        if (!isLastChunk) {
+            throw new NotEnoughDataDecoderException();
+        }
+        return bodyMapHttpData.get(name);
+    }
+
+    /**
+     * This getMethod returns the first InterfaceHttpData with the given name from
+     * body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return The first Body InterfaceHttpData with the given name (ignore
+     *         case)
+     * @throws NotEnoughDataDecoderException
+     *             need more chunks
+     */
+    @Override
+    public InterfaceHttpData getBodyHttpData(String name) {
+        checkDestroyed();
+
+        if (!isLastChunk) {
+            throw new NotEnoughDataDecoderException();
+        }
+        List<InterfaceHttpData> list = bodyMapHttpData.get(name);
+        if (list != null) {
+            return list.get(0);
+        }
+        return null;
+    }
+
+    /**
+     * Initialized the internals from a new chunk
+     *
+     * @param content
+     *            the new received chunk
+     * @throws ErrorDataDecoderException
+     *             if there is a problem with the charset decoding or other
+     *             errors
+     */
+    @Override
+    public HttpPostStandardRequestDecoder offer(HttpContent content) {
+        checkDestroyed();
+
+        // Maybe we should better not copy here for performance reasons but this will need
+        // more care by the caller to release the content in a correct manner later
+        // So maybe something to optimize on a later stage
+        ByteBuf buf = content.content();
+        if (undecodedChunk == null) {
+            undecodedChunk = buf.copy();
+        } else {
+            undecodedChunk.writeBytes(buf);
+        }
+        if (content instanceof LastHttpContent) {
+            isLastChunk = true;
+        }
+        parseBody();
+        if (undecodedChunk != null && undecodedChunk.writerIndex() > discardThreshold) {
+            undecodedChunk.discardReadBytes();
+        }
+        return this;
+    }
+
+    /**
+     * True if at current getStatus, there is an available decoded
+     * InterfaceHttpData from the Body.
+     *
+     * This getMethod works for chunked and not chunked request.
+     *
+     * @return True if at current getStatus, there is a decoded InterfaceHttpData
+     * @throws EndOfDataDecoderException
+     *             No more data will be available
+     */
+    @Override
+    public boolean hasNext() {
+        checkDestroyed();
+
+        if (currentStatus == MultiPartStatus.EPILOGUE) {
+            // OK except if end of list
+            if (bodyListHttpDataRank >= bodyListHttpData.size()) {
+                throw new EndOfDataDecoderException();
+            }
+        }
+        return !bodyListHttpData.isEmpty() && bodyListHttpDataRank < bodyListHttpData.size();
+    }
+
+    /**
+     * Returns the next available InterfaceHttpData or null if, at the time it
+     * is called, there is no more available InterfaceHttpData. A subsequent
+     * call to offer(httpChunk) could enable more data.
+     *
+     * Be sure to call {@link InterfaceHttpData#release()} after you are done
+     * with processing to make sure to not leak any resources
+     *
+     * @return the next available InterfaceHttpData or null if none
+     * @throws EndOfDataDecoderException
+     *             No more data will be available
+     */
+    @Override
+    public InterfaceHttpData next() {
+        checkDestroyed();
+
+        if (hasNext()) {
+            return bodyListHttpData.get(bodyListHttpDataRank++);
+        }
+        return null;
+    }
+
+    /**
+     * This getMethod will parse as much as possible data and fill the list and map
+     *
+     * @throws ErrorDataDecoderException
+     *             if there is a problem with the charset decoding or other
+     *             errors
+     */
+    private void parseBody() {
+        if (currentStatus == MultiPartStatus.PREEPILOGUE || currentStatus == MultiPartStatus.EPILOGUE) {
+            if (isLastChunk) {
+                currentStatus = MultiPartStatus.EPILOGUE;
+            }
+            return;
+        }
+        parseBodyAttributes();
+    }
+
+    /**
+     * Utility function to add a new decoded data
+     */
+    protected void addHttpData(InterfaceHttpData data) {
+        if (data == null) {
+            return;
+        }
+        List<InterfaceHttpData> datas = bodyMapHttpData.get(data.getName());
+        if (datas == null) {
+            datas = new ArrayList<InterfaceHttpData>(1);
+            bodyMapHttpData.put(data.getName(), datas);
+        }
+        datas.add(data);
+        bodyListHttpData.add(data);
+    }
+
+    /**
+     * This getMethod fill the map and list with as much Attribute as possible from
+     * Body in not Multipart mode.
+     *
+     * @throws ErrorDataDecoderException
+     *             if there is a problem with the charset decoding or other
+     *             errors
+     */
+    private void parseBodyAttributesStandard() {
+        int firstpos = undecodedChunk.readerIndex();
+        int currentpos = firstpos;
+        int equalpos;
+        int ampersandpos;
+        if (currentStatus == MultiPartStatus.NOTSTARTED) {
+            currentStatus = MultiPartStatus.DISPOSITION;
+        }
+        boolean contRead = true;
+        try {
+            while (undecodedChunk.isReadable() && contRead) {
+                char read = (char) undecodedChunk.readUnsignedByte();
+                currentpos++;
+                switch (currentStatus) {
+                case DISPOSITION:// search '='
+                    if (read == '=') {
+                        currentStatus = MultiPartStatus.FIELD;
+                        equalpos = currentpos - 1;
+                        String key = decodeAttribute(undecodedChunk.toString(firstpos, equalpos - firstpos, charset),
+                                charset);
+                        currentAttribute = factory.createAttribute(request, key);
+                        firstpos = currentpos;
+                    } else if (read == '&') { // special empty FIELD
+                        currentStatus = MultiPartStatus.DISPOSITION;
+                        ampersandpos = currentpos - 1;
+                        String key = decodeAttribute(
+                                undecodedChunk.toString(firstpos, ampersandpos - firstpos, charset), charset);
+                        currentAttribute = factory.createAttribute(request, key);
+                        currentAttribute.setValue(""); // empty
+                        addHttpData(currentAttribute);
+                        currentAttribute = null;
+                        firstpos = currentpos;
+                        contRead = true;
+                    }
+                    break;
+                case FIELD:// search '&' or end of line
+                    if (read == '&') {
+                        currentStatus = MultiPartStatus.DISPOSITION;
+                        ampersandpos = currentpos - 1;
+                        setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
+                        firstpos = currentpos;
+                        contRead = true;
+                    } else if (read == HttpConstants.CR) {
+                        if (undecodedChunk.isReadable()) {
+                            read = (char) undecodedChunk.readUnsignedByte();
+                            currentpos++;
+                            if (read == HttpConstants.LF) {
+                                currentStatus = MultiPartStatus.PREEPILOGUE;
+                                ampersandpos = currentpos - 2;
+                                setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
+                                firstpos = currentpos;
+                                contRead = false;
+                            } else {
+                                // Error
+                                throw new ErrorDataDecoderException("Bad end of line");
+                            }
+                        } else {
+                            currentpos--;
+                        }
+                    } else if (read == HttpConstants.LF) {
+                        currentStatus = MultiPartStatus.PREEPILOGUE;
+                        ampersandpos = currentpos - 1;
+                        setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
+                        firstpos = currentpos;
+                        contRead = false;
+                    }
+                    break;
+                default:
+                    // just stop
+                    contRead = false;
+                }
+            }
+            if (isLastChunk && currentAttribute != null) {
+                // special case
+                ampersandpos = currentpos;
+                if (ampersandpos > firstpos) {
+                    setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
+                } else if (!currentAttribute.isCompleted()) {
+                    setFinalBuffer(EMPTY_BUFFER);
+                }
+                firstpos = currentpos;
+                currentStatus = MultiPartStatus.EPILOGUE;
+                undecodedChunk.readerIndex(firstpos);
+                return;
+            }
+            if (contRead && currentAttribute != null) {
+                // reset index except if to continue in case of FIELD getStatus
+                if (currentStatus == MultiPartStatus.FIELD) {
+                    currentAttribute.addContent(undecodedChunk.copy(firstpos, currentpos - firstpos),
+                                                false);
+                    firstpos = currentpos;
+                }
+                undecodedChunk.readerIndex(firstpos);
+            } else {
+                // end of line or end of block so keep index to last valid position
+                undecodedChunk.readerIndex(firstpos);
+            }
+        } catch (ErrorDataDecoderException e) {
+            // error while decoding
+            undecodedChunk.readerIndex(firstpos);
+            throw e;
+        } catch (IOException e) {
+            // error while decoding
+            undecodedChunk.readerIndex(firstpos);
+            throw new ErrorDataDecoderException(e);
+        }
+    }
+
+    /**
+     * This getMethod fill the map and list with as much Attribute as possible from
+     * Body in not Multipart mode.
+     *
+     * @throws ErrorDataDecoderException
+     *             if there is a problem with the charset decoding or other
+     *             errors
+     */
+    private void parseBodyAttributes() {
+        SeekAheadOptimize sao;
+        try {
+            sao = new SeekAheadOptimize(undecodedChunk);
+        } catch (SeekAheadNoBackArrayException ignored) {
+            parseBodyAttributesStandard();
+            return;
+        }
+        int firstpos = undecodedChunk.readerIndex();
+        int currentpos = firstpos;
+        int equalpos;
+        int ampersandpos;
+        if (currentStatus == MultiPartStatus.NOTSTARTED) {
+            currentStatus = MultiPartStatus.DISPOSITION;
+        }
+        boolean contRead = true;
+        try {
+            loop: while (sao.pos < sao.limit) {
+                char read = (char) (sao.bytes[sao.pos++] & 0xFF);
+                currentpos++;
+                switch (currentStatus) {
+                case DISPOSITION:// search '='
+                    if (read == '=') {
+                        currentStatus = MultiPartStatus.FIELD;
+                        equalpos = currentpos - 1;
+                        String key = decodeAttribute(undecodedChunk.toString(firstpos, equalpos - firstpos, charset),
+                                charset);
+                        currentAttribute = factory.createAttribute(request, key);
+                        firstpos = currentpos;
+                    } else if (read == '&') { // special empty FIELD
+                        currentStatus = MultiPartStatus.DISPOSITION;
+                        ampersandpos = currentpos - 1;
+                        String key = decodeAttribute(
+                                undecodedChunk.toString(firstpos, ampersandpos - firstpos, charset), charset);
+                        currentAttribute = factory.createAttribute(request, key);
+                        currentAttribute.setValue(""); // empty
+                        addHttpData(currentAttribute);
+                        currentAttribute = null;
+                        firstpos = currentpos;
+                        contRead = true;
+                    }
+                    break;
+                case FIELD:// search '&' or end of line
+                    if (read == '&') {
+                        currentStatus = MultiPartStatus.DISPOSITION;
+                        ampersandpos = currentpos - 1;
+                        setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
+                        firstpos = currentpos;
+                        contRead = true;
+                    } else if (read == HttpConstants.CR) {
+                        if (sao.pos < sao.limit) {
+                            read = (char) (sao.bytes[sao.pos++] & 0xFF);
+                            currentpos++;
+                            if (read == HttpConstants.LF) {
+                                currentStatus = MultiPartStatus.PREEPILOGUE;
+                                ampersandpos = currentpos - 2;
+                                sao.setReadPosition(0);
+                                setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
+                                firstpos = currentpos;
+                                contRead = false;
+                                break loop;
+                            } else {
+                                // Error
+                                sao.setReadPosition(0);
+                                throw new ErrorDataDecoderException("Bad end of line");
+                            }
+                        } else {
+                            if (sao.limit > 0) {
+                                currentpos--;
+                            }
+                        }
+                    } else if (read == HttpConstants.LF) {
+                        currentStatus = MultiPartStatus.PREEPILOGUE;
+                        ampersandpos = currentpos - 1;
+                        sao.setReadPosition(0);
+                        setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
+                        firstpos = currentpos;
+                        contRead = false;
+                        break loop;
+                    }
+                    break;
+                default:
+                    // just stop
+                    sao.setReadPosition(0);
+                    contRead = false;
+                    break loop;
+                }
+            }
+            if (isLastChunk && currentAttribute != null) {
+                // special case
+                ampersandpos = currentpos;
+                if (ampersandpos > firstpos) {
+                    setFinalBuffer(undecodedChunk.copy(firstpos, ampersandpos - firstpos));
+                } else if (!currentAttribute.isCompleted()) {
+                    setFinalBuffer(EMPTY_BUFFER);
+                }
+                firstpos = currentpos;
+                currentStatus = MultiPartStatus.EPILOGUE;
+                undecodedChunk.readerIndex(firstpos);
+                return;
+            }
+            if (contRead && currentAttribute != null) {
+                // reset index except if to continue in case of FIELD getStatus
+                if (currentStatus == MultiPartStatus.FIELD) {
+                    currentAttribute.addContent(undecodedChunk.copy(firstpos, currentpos - firstpos),
+                                                false);
+                    firstpos = currentpos;
+                }
+                undecodedChunk.readerIndex(firstpos);
+            } else {
+                // end of line or end of block so keep index to last valid position
+                undecodedChunk.readerIndex(firstpos);
+            }
+        } catch (ErrorDataDecoderException e) {
+            // error while decoding
+            undecodedChunk.readerIndex(firstpos);
+            throw e;
+        } catch (IOException e) {
+            // error while decoding
+            undecodedChunk.readerIndex(firstpos);
+            throw new ErrorDataDecoderException(e);
+        }
+    }
+
+    private void setFinalBuffer(ByteBuf buffer) throws IOException {
+        currentAttribute.addContent(buffer, true);
+        String value = decodeAttribute(currentAttribute.getByteBuf().toString(charset), charset);
+        currentAttribute.setValue(value);
+        addHttpData(currentAttribute);
+        currentAttribute = null;
+    }
+
+    /**
+     * Decode component
+     *
+     * @return the decoded component
+     */
+    private static String decodeAttribute(String s, Charset charset) {
+        try {
+            return QueryStringDecoder.decodeComponent(s, charset);
+        } catch (IllegalArgumentException e) {
+            throw new ErrorDataDecoderException("Bad string: '" + s + '\'', e);
+        }
+    }
+
+    /**
+     * Skip control Characters
+     */
+    void skipControlCharacters() {
+        SeekAheadOptimize sao;
+        try {
+            sao = new SeekAheadOptimize(undecodedChunk);
+        } catch (SeekAheadNoBackArrayException ignored) {
+            try {
+                skipControlCharactersStandard();
+            } catch (IndexOutOfBoundsException e) {
+                throw new NotEnoughDataDecoderException(e);
+            }
+            return;
+        }
+
+        while (sao.pos < sao.limit) {
+            char c = (char) (sao.bytes[sao.pos++] & 0xFF);
+            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
+                sao.setReadPosition(1);
+                return;
+            }
+        }
+        throw new NotEnoughDataDecoderException("Access out of bounds");
+    }
+
+    void skipControlCharactersStandard() {
+        for (;;) {
+            char c = (char) undecodedChunk.readUnsignedByte();
+            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {
+                undecodedChunk.readerIndex(undecodedChunk.readerIndex() - 1);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Destroy the {@link HttpPostStandardRequestDecoder} and release all it resources. After this method
+     * was called it is not possible to operate on it anymore.
+     */
+    @Override
+    public void destroy() {
+        checkDestroyed();
+        cleanFiles();
+        destroyed = true;
+
+        if (undecodedChunk != null && undecodedChunk.refCnt() > 0) {
+            undecodedChunk.release();
+            undecodedChunk = null;
+        }
+
+        // release all data which was not yet pulled
+        for (int i = bodyListHttpDataRank; i < bodyListHttpData.size(); i++) {
+            bodyListHttpData.get(i).release();
+        }
+    }
+
+    /**
+     * Clean all HttpDatas (on Disk) for the current request.
+     */
+    @Override
+    public void cleanFiles() {
+        checkDestroyed();
+
+        factory.cleanRequestHttpData(request);
+    }
+
+    /**
+     * Remove the given FileUpload from the list of FileUploads to clean
+     */
+    @Override
+    public void removeHttpDataFromClean(InterfaceHttpData data) {
+        checkDestroyed();
+
+        factory.removeHttpDataFromClean(request, data);
+    }
+}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpData.java
index b0b9daf3ed7e..2b9cb61e965a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpData.java
@@ -35,4 +35,16 @@ enum HttpDataType {
      * @return The HttpDataType
      */
     HttpDataType getHttpDataType();
+
+    @Override
+    InterfaceHttpData retain();
+
+    @Override
+    InterfaceHttpData retain(int increment);
+
+    @Override
+    InterfaceHttpData touch();
+
+    @Override
+    InterfaceHttpData touch(Object hint);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpPostRequestDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpPostRequestDecoder.java
new file mode 100644
index 000000000000..a832c883b176
--- /dev/null
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InterfaceHttpPostRequestDecoder.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.http.multipart;
+
+import io.netty.handler.codec.http.HttpContent;
+
+import java.util.List;
+
+/**
+ * This decoder will decode Body and can handle POST BODY (or for PUT, PATCH or OPTIONS).
+ *
+ * You <strong>MUST</strong> call {@link #destroy()} after completion to release all resources.
+ *
+ */
+public interface InterfaceHttpPostRequestDecoder {
+    /**
+     * True if this request is a Multipart request
+     *
+     * @return True if this request is a Multipart request
+     */
+    boolean isMultipart();
+
+    /**
+     * Set the amount of bytes after which read bytes in the buffer should be discarded.
+     * Setting this lower gives lower memory usage but with the overhead of more memory copies.
+     * Use {@code 0} to disable it.
+     */
+    void setDiscardThreshold(int discardThreshold);
+
+    /**
+     * Return the threshold in bytes after which read data in the buffer should be discarded.
+     */
+    int getDiscardThreshold();
+
+    /**
+     * This getMethod returns a List of all HttpDatas from body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return the list of HttpDatas from Body part for POST getMethod
+     * @throws HttpPostRequestDecoder.NotEnoughDataDecoderException
+     *             Need more chunks
+     */
+    List<InterfaceHttpData> getBodyHttpDatas();
+
+    /**
+     * This getMethod returns a List of all HttpDatas with the given name from
+     * body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return All Body HttpDatas with the given name (ignore case)
+     * @throws HttpPostRequestDecoder.NotEnoughDataDecoderException
+     *             need more chunks
+     */
+    List<InterfaceHttpData> getBodyHttpDatas(String name);
+
+    /**
+     * This getMethod returns the first InterfaceHttpData with the given name from
+     * body.<br>
+     *
+     * If chunked, all chunks must have been offered using offer() getMethod. If
+     * not, NotEnoughDataDecoderException will be raised.
+     *
+     * @return The first Body InterfaceHttpData with the given name (ignore
+     *         case)
+     * @throws HttpPostRequestDecoder.NotEnoughDataDecoderException
+     *             need more chunks
+     */
+    InterfaceHttpData getBodyHttpData(String name);
+
+    /**
+     * Initialized the internals from a new chunk
+     *
+     * @param content
+     *            the new received chunk
+     * @throws HttpPostRequestDecoder.ErrorDataDecoderException
+     *             if there is a problem with the charset decoding or other
+     *             errors
+     */
+    InterfaceHttpPostRequestDecoder offer(HttpContent content);
+
+    /**
+     * True if at current getStatus, there is an available decoded
+     * InterfaceHttpData from the Body.
+     *
+     * This getMethod works for chunked and not chunked request.
+     *
+     * @return True if at current getStatus, there is a decoded InterfaceHttpData
+     * @throws HttpPostRequestDecoder.EndOfDataDecoderException
+     *             No more data will be available
+     */
+    boolean hasNext();
+
+    /**
+     * Returns the next available InterfaceHttpData or null if, at the time it
+     * is called, there is no more available InterfaceHttpData. A subsequent
+     * call to offer(httpChunk) could enable more data.
+     *
+     * Be sure to call {@link InterfaceHttpData#release()} after you are done
+     * with processing to make sure to not leak any resources
+     *
+     * @return the next available InterfaceHttpData or null if none
+     * @throws HttpPostRequestDecoder.EndOfDataDecoderException
+     *             No more data will be available
+     */
+    InterfaceHttpData next();
+
+    /**
+     * Destroy the {@link InterfaceHttpPostRequestDecoder} and release all it resources. After this method
+     * was called it is not possible to operate on it anymore.
+     */
+    void destroy();
+
+    /**
+     * Clean all HttpDatas (on Disk) for the current request.
+     */
+    void cleanFiles();
+
+    /**
+     * Remove the given FileUpload from the list of FileUploads to clean
+     */
+    void removeHttpDataFromClean(InterfaceHttpData data);
+}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java
index 275b46aeea75..b0b034f779db 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java
@@ -125,4 +125,36 @@ public String getName() {
     protected void deallocate() {
         // Do nothing
     }
+
+    @Override
+    public InterfaceHttpData retain() {
+        for (ByteBuf buf: value) {
+            buf.retain();
+        }
+        return this;
+    }
+
+    @Override
+    public InterfaceHttpData retain(int increment) {
+        for (ByteBuf buf: value) {
+            buf.retain(increment);
+        }
+        return this;
+    }
+
+    @Override
+    public InterfaceHttpData touch() {
+        for (ByteBuf buf: value) {
+            buf.touch();
+        }
+        return this;
+    }
+
+    @Override
+    public InterfaceHttpData touch(Object hint) {
+        for (ByteBuf buf: value) {
+            buf.touch(hint);
+        }
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java
index e174ac91f405..23d5730d1672 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.http.HttpConstants;
 
 import java.io.IOException;
+import java.nio.charset.Charset;
 
 import static io.netty.buffer.Unpooled.*;
 
@@ -29,11 +30,19 @@
 public class MemoryAttribute extends AbstractMemoryHttpData implements Attribute {
 
     public MemoryAttribute(String name) {
-        super(name, HttpConstants.DEFAULT_CHARSET, 0);
+        this(name, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    public MemoryAttribute(String name, Charset charset) {
+        super(name, charset, 0);
     }
 
     public MemoryAttribute(String name, String value) throws IOException {
-        super(name, HttpConstants.DEFAULT_CHARSET, 0); // Attribute have no default size
+        this(name, value, HttpConstants.DEFAULT_CHARSET); // Attribute have no default size
+    }
+
+    public MemoryAttribute(String name, String value, Charset charset) throws IOException {
+        super(name, charset, 0); // Attribute have no default size
         setValue(value);
     }
 
@@ -44,7 +53,7 @@ public HttpDataType getHttpDataType() {
 
     @Override
     public String getValue() {
-        return getByteBuf().toString(charset);
+        return getByteBuf().toString(getCharset());
     }
 
     @Override
@@ -52,7 +61,8 @@ public void setValue(String value) throws IOException {
         if (value == null) {
             throw new NullPointerException("value");
         }
-        byte [] bytes = value.getBytes(charset.name());
+        byte [] bytes = value.getBytes(getCharset());
+        checkSize(bytes.length);
         ByteBuf buffer = wrappedBuffer(bytes);
         if (definedSize > 0) {
             definedSize = buffer.readableBytes();
@@ -63,6 +73,7 @@ public void setValue(String value) throws IOException {
     @Override
     public void addContent(ByteBuf buffer, boolean last) throws IOException {
         int localsize = buffer.readableBytes();
+        checkSize(size + localsize);
         if (definedSize > 0 && definedSize < size + localsize) {
             definedSize = size + localsize;
         }
@@ -142,4 +153,16 @@ public Attribute retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public Attribute touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public Attribute touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
index a9ad28b1f450..6100629b3b22 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
@@ -123,7 +123,7 @@ public String toString() {
             HttpPostBodyUtil.FORM_DATA + "; " + HttpPostBodyUtil.NAME + "=\"" + getName() +
             "\"; " + HttpPostBodyUtil.FILENAME + "=\"" + filename + "\"\r\n" +
             HttpHeaders.Names.CONTENT_TYPE + ": " + contentType +
-            (charset != null? "; " + HttpHeaders.Values.CHARSET + '=' + charset + "\r\n" : "\r\n") +
+            (getCharset() != null? "; " + HttpHeaders.Values.CHARSET + '=' + getCharset() + "\r\n" : "\r\n") +
             HttpHeaders.Names.CONTENT_LENGTH + ": " + length() + "\r\n" +
             "Completed: " + isCompleted() +
             "\r\nIsInMemory: " + isInMemory();
@@ -171,4 +171,16 @@ public FileUpload retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public FileUpload touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public FileUpload touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java
index e47e5486939a..63299018ac50 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.http.multipart;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.http.HttpConstants;
 
 import java.io.File;
 import java.io.IOException;
@@ -29,40 +30,69 @@ public class MixedAttribute implements Attribute {
     private Attribute attribute;
 
     private final long limitSize;
+    private long maxSize = DefaultHttpDataFactory.MAXSIZE;
 
     public MixedAttribute(String name, long limitSize) {
+        this(name, limitSize, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    public MixedAttribute(String name, long limitSize, Charset charset) {
         this.limitSize = limitSize;
-        attribute = new MemoryAttribute(name);
+        attribute = new MemoryAttribute(name, charset);
     }
 
     public MixedAttribute(String name, String value, long limitSize) {
+        this(name, value, limitSize, HttpConstants.DEFAULT_CHARSET);
+    }
+
+    public MixedAttribute(String name, String value, long limitSize, Charset charset) {
         this.limitSize = limitSize;
         if (value.length() > this.limitSize) {
             try {
-                attribute = new DiskAttribute(name, value);
+                attribute = new DiskAttribute(name, value, charset);
             } catch (IOException e) {
                 // revert to Memory mode
                 try {
-                    attribute = new MemoryAttribute(name, value);
-                } catch (IOException e1) {
+                    attribute = new MemoryAttribute(name, value, charset);
+                } catch (IOException ignore) {
                     throw new IllegalArgumentException(e);
                 }
             }
         } else {
             try {
-                attribute = new MemoryAttribute(name, value);
+                attribute = new MemoryAttribute(name, value, charset);
             } catch (IOException e) {
                 throw new IllegalArgumentException(e);
             }
         }
     }
 
+    @Override
+    public long getMaxSize() {
+        return maxSize;
+    }
+
+    @Override
+    public void setMaxSize(long maxSize) {
+        this.maxSize = maxSize;
+        attribute.setMaxSize(maxSize);
+    }
+
+    @Override
+    public void checkSize(long newSize) throws IOException {
+        if (maxSize >= 0 && newSize > maxSize) {
+            throw new IOException("Size exceed allowed maximum capacity");
+        }
+    }
+
     @Override
     public void addContent(ByteBuf buffer, boolean last) throws IOException {
         if (attribute instanceof MemoryAttribute) {
+            checkSize(attribute.length() + buffer.readableBytes());
             if (attribute.length() + buffer.readableBytes() > limitSize) {
                 DiskAttribute diskAttribute = new DiskAttribute(attribute
                         .getName());
+                diskAttribute.setMaxSize(maxSize);
                 if (((MemoryAttribute) attribute).getByteBuf() != null) {
                     diskAttribute.addContent(((MemoryAttribute) attribute)
                         .getByteBuf(), false);
@@ -130,10 +160,12 @@ public void setCharset(Charset charset) {
 
     @Override
     public void setContent(ByteBuf buffer) throws IOException {
+        checkSize(buffer.readableBytes());
         if (buffer.readableBytes() > limitSize) {
             if (attribute instanceof MemoryAttribute) {
                 // change to Disk
                 attribute = new DiskAttribute(attribute.getName());
+                attribute.setMaxSize(maxSize);
             }
         }
         attribute.setContent(buffer);
@@ -141,10 +173,12 @@ public void setContent(ByteBuf buffer) throws IOException {
 
     @Override
     public void setContent(File file) throws IOException {
+        checkSize(file.length());
         if (file.length() > limitSize) {
             if (attribute instanceof MemoryAttribute) {
                 // change to Disk
                 attribute = new DiskAttribute(attribute.getName());
+                attribute.setMaxSize(maxSize);
             }
         }
         attribute.setContent(file);
@@ -155,6 +189,7 @@ public void setContent(InputStream inputStream) throws IOException {
         if (attribute instanceof MemoryAttribute) {
             // change to Disk even if we don't know the size
             attribute = new DiskAttribute(attribute.getName());
+            attribute.setMaxSize(maxSize);
         }
         attribute.setContent(inputStream);
     }
@@ -169,6 +204,16 @@ public String getName() {
         return attribute.getName();
     }
 
+    @Override
+    public int hashCode() {
+        return attribute.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return attribute.equals(obj);
+    }
+
     @Override
     public int compareTo(InterfaceHttpData o) {
         return attribute.compareTo(o);
@@ -176,7 +221,7 @@ public int compareTo(InterfaceHttpData o) {
 
     @Override
     public String toString() {
-        return "Mixed: " + attribute.toString();
+        return "Mixed: " + attribute;
     }
 
     @Override
@@ -186,6 +231,9 @@ public String getValue() throws IOException {
 
     @Override
     public void setValue(String value) throws IOException {
+        if (value != null) {
+            checkSize(value.getBytes().length);
+        }
         attribute.setValue(value);
     }
 
@@ -231,6 +279,18 @@ public Attribute retain(int increment) {
         return this;
     }
 
+    @Override
+    public Attribute touch() {
+        attribute.touch();
+        return this;
+    }
+
+    @Override
+    public Attribute touch(Object hint) {
+        attribute.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         return attribute.release();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java
index e216810edbba..1d462ce96fe8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java
@@ -32,6 +32,7 @@ public class MixedFileUpload implements FileUpload {
     private final long limitSize;
 
     private final long definedSize;
+    private long maxSize = DefaultHttpDataFactory.MAXSIZE;
 
     public MixedFileUpload(String name, String filename, String contentType,
             String contentTransferEncoding, Charset charset, long size,
@@ -47,17 +48,36 @@ public MixedFileUpload(String name, String filename, String contentType,
         definedSize = size;
     }
 
+    @Override
+    public long getMaxSize() {
+        return maxSize;
+    }
+
+    @Override
+    public void setMaxSize(long maxSize) {
+        this.maxSize = maxSize;
+        fileUpload.setMaxSize(maxSize);
+    }
+
+    @Override
+    public void checkSize(long newSize) throws IOException {
+        if (maxSize >= 0 && newSize > maxSize) {
+            throw new IOException("Size exceed allowed maximum capacity");
+        }
+    }
+
     @Override
     public void addContent(ByteBuf buffer, boolean last)
             throws IOException {
         if (fileUpload instanceof MemoryFileUpload) {
+            checkSize(fileUpload.length() + buffer.readableBytes());
             if (fileUpload.length() + buffer.readableBytes() > limitSize) {
                 DiskFileUpload diskFileUpload = new DiskFileUpload(fileUpload
                         .getName(), fileUpload.getFilename(), fileUpload
                         .getContentType(), fileUpload
                         .getContentTransferEncoding(), fileUpload.getCharset(),
                         definedSize);
-
+                diskFileUpload.setMaxSize(maxSize);
                 ByteBuf data = fileUpload.getByteBuf();
                 if (data != null && data.isReadable()) {
                     diskFileUpload.addContent(data.retain(), false);
@@ -143,6 +163,7 @@ public void setCharset(Charset charset) {
 
     @Override
     public void setContent(ByteBuf buffer) throws IOException {
+        checkSize(buffer.readableBytes());
         if (buffer.readableBytes() > limitSize) {
             if (fileUpload instanceof MemoryFileUpload) {
                 FileUpload memoryUpload = fileUpload;
@@ -152,6 +173,7 @@ public void setContent(ByteBuf buffer) throws IOException {
                         .getContentType(), memoryUpload
                         .getContentTransferEncoding(), memoryUpload.getCharset(),
                         definedSize);
+                fileUpload.setMaxSize(maxSize);
 
                 // release old upload
                 memoryUpload.release();
@@ -162,6 +184,7 @@ public void setContent(ByteBuf buffer) throws IOException {
 
     @Override
     public void setContent(File file) throws IOException {
+        checkSize(file.length());
         if (file.length() > limitSize) {
             if (fileUpload instanceof MemoryFileUpload) {
                 FileUpload memoryUpload = fileUpload;
@@ -172,6 +195,7 @@ public void setContent(File file) throws IOException {
                         .getContentType(), memoryUpload
                         .getContentTransferEncoding(), memoryUpload.getCharset(),
                         definedSize);
+                fileUpload.setMaxSize(maxSize);
 
                 // release old upload
                 memoryUpload.release();
@@ -191,6 +215,7 @@ public void setContent(InputStream inputStream) throws IOException {
                     .getContentType(), fileUpload
                     .getContentTransferEncoding(), fileUpload.getCharset(),
                     definedSize);
+            fileUpload.setMaxSize(maxSize);
 
             // release old upload
             memoryUpload.release();
@@ -223,6 +248,16 @@ public String getName() {
         return fileUpload.getName();
     }
 
+    @Override
+    public int hashCode() {
+        return fileUpload.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return fileUpload.equals(obj);
+    }
+
     @Override
     public int compareTo(InterfaceHttpData o) {
         return fileUpload.compareTo(o);
@@ -230,7 +265,7 @@ public int compareTo(InterfaceHttpData o) {
 
     @Override
     public String toString() {
-        return "Mixed: " + fileUpload.toString();
+        return "Mixed: " + fileUpload;
     }
 
     @Override
@@ -275,6 +310,18 @@ public FileUpload retain(int increment) {
         return this;
     }
 
+    @Override
+    public FileUpload touch() {
+        fileUpload.touch();
+        return this;
+    }
+
+    @Override
+    public FileUpload touch(Object hint) {
+        fileUpload.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         return fileUpload.release();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java
index da7392a38e38..f3ce587d6bda 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java
@@ -75,4 +75,16 @@ public BinaryWebSocketFrame retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public BinaryWebSocketFrame touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public BinaryWebSocketFrame touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
index 8d6c56b2cd4d..8b060f668142 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
@@ -159,4 +159,16 @@ public CloseWebSocketFrame retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public CloseWebSocketFrame touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public CloseWebSocketFrame touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java
index 9d590a5d02cf..8560f410f17d 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java
@@ -25,13 +25,11 @@
  */
 public class ContinuationWebSocketFrame extends WebSocketFrame {
 
-    private String aggregatedText;
-
     /**
      * Creates a new empty continuation frame.
      */
     public ContinuationWebSocketFrame() {
-        super(Unpooled.buffer(0));
+        this(Unpooled.buffer(0));
     }
 
     /**
@@ -58,25 +56,6 @@ public ContinuationWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binary
         super(finalFragment, rsv, binaryData);
     }
 
-    /**
-     * Creates a new continuation frame with the specified binary data
-     *
-     * @param finalFragment
-     *            flag indicating if this frame is the final fragment
-     * @param rsv
-     *            reserved bits used for protocol extensions
-     * @param binaryData
-     *            the content of the frame.
-     * @param aggregatedText
-     *            Aggregated text set by decoder on the final continuation frame of a fragmented
-     *            text message
-     */
-    public ContinuationWebSocketFrame(
-            boolean finalFragment, int rsv, ByteBuf binaryData, String aggregatedText) {
-        super(finalFragment, rsv, binaryData);
-        this.aggregatedText = aggregatedText;
-    }
-
     /**
      * Creates a new continuation frame with the specified text data
      *
@@ -88,7 +67,7 @@ public ContinuationWebSocketFrame(
      *            text content of the frame.
      */
     public ContinuationWebSocketFrame(boolean finalFragment, int rsv, String text) {
-        this(finalFragment, rsv, fromText(text), null);
+        this(finalFragment, rsv, fromText(text));
     }
 
     /**
@@ -112,21 +91,14 @@ private static ByteBuf fromText(String text) {
         }
     }
 
-    /**
-     * Aggregated text returned by decoder on the final continuation frame of a fragmented text message
-     */
-    public String aggregatedText() {
-        return aggregatedText;
-    }
-
     @Override
     public ContinuationWebSocketFrame copy() {
-        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().copy(), aggregatedText());
+        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().copy());
     }
 
     @Override
     public ContinuationWebSocketFrame duplicate() {
-        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().duplicate(), aggregatedText());
+        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());
     }
 
     @Override
@@ -140,4 +112,16 @@ public ContinuationWebSocketFrame retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public ContinuationWebSocketFrame touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public ContinuationWebSocketFrame touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java
index bc4e6b8d4d03..49a10ac644e7 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java
@@ -75,4 +75,16 @@ public PingWebSocketFrame retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public PingWebSocketFrame touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public PingWebSocketFrame touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java
index 0324a3c098ae..b96c815d9898 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java
@@ -75,4 +75,16 @@ public PongWebSocketFrame retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public PongWebSocketFrame touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public PongWebSocketFrame touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java
index dfa311f17c8c..7dca7ba87fc6 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java
@@ -115,4 +115,16 @@ public TextWebSocketFrame retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public TextWebSocketFrame touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public TextWebSocketFrame touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/UTF8Exception.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/UTF8Exception.java
deleted file mode 100644
index 9580b720735f..000000000000
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/UTF8Exception.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-/*
- * Adaptation of http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
- *
- * Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
- * and associated documentation files (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge, publish, distribute,
- * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all copies or
- * substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
- * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-package io.netty.handler.codec.http.websocketx;
-
-/**
- * Invalid UTF8 bytes encountered
- */
-final class UTF8Exception extends RuntimeException {
-    private static final long serialVersionUID = 1L;
-
-    UTF8Exception(String reason) {
-        super(reason);
-    }
-}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/UTF8Output.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8Validator.java
similarity index 81%
rename from codec-http/src/main/java/io/netty/handler/codec/http/websocketx/UTF8Output.java
rename to codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8Validator.java
index fa9564b3eaa6..d4a612fcbf54 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/UTF8Output.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8Validator.java
@@ -36,11 +36,13 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufProcessor;
+import io.netty.handler.codec.CorruptedFrameException;
 
 /**
- * Checks UTF8 bytes for validity before converting it into a string
+ * Checks UTF8 bytes for validity
  */
-final class UTF8Output {
+final class Utf8Validator implements ByteBufProcessor {
     private static final int UTF8_ACCEPT = 0;
     private static final int UTF8_REJECT = 12;
 
@@ -65,45 +67,38 @@ final class UTF8Output {
     @SuppressWarnings("RedundantFieldInitialization")
     private int state = UTF8_ACCEPT;
     private int codep;
+    private boolean checking;
 
-    private final StringBuilder stringBuilder;
-
-    UTF8Output(ByteBuf buffer) {
-        stringBuilder = new StringBuilder(buffer.readableBytes());
-        write(buffer);
+    public void check(ByteBuf buffer) {
+        checking = true;
+        buffer.forEachByte(this);
     }
 
-    public void write(ByteBuf buffer) {
-        for (int i = buffer.readerIndex(); i < buffer.writerIndex(); i++) {
-            write(buffer.getByte(i));
-        }
-    }
-
-    public void write(byte[] bytes) {
-        for (byte b : bytes) {
-            write(b);
+    public void finish() {
+        checking = false;
+        codep = 0;
+        if (state != UTF8_ACCEPT) {
+            state = UTF8_ACCEPT;
+            throw new CorruptedFrameException("bytes are not UTF-8");
         }
     }
 
-    public void write(int b) {
+    @Override
+    public boolean process(byte b) throws Exception {
         byte type = TYPES[b & 0xFF];
 
         codep = state != UTF8_ACCEPT ? b & 0x3f | codep << 6 : 0xff >> type & b;
 
         state = STATES[state + type];
 
-        if (state == UTF8_ACCEPT) {
-            stringBuilder.append((char) codep);
-        } else if (state == UTF8_REJECT) {
-            throw new UTF8Exception("bytes are not UTF-8");
+        if (state == UTF8_REJECT) {
+            checking = false;
+            throw new CorruptedFrameException("bytes are not UTF-8");
         }
+        return true;
     }
 
-    @Override
-    public String toString() {
-        if (state != UTF8_ACCEPT) {
-            throw new UTF8Exception("bytes are not UTF-8");
-        }
-        return stringBuilder.toString();
+    public boolean isChecking() {
+        return checking;
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
index f88229fcdf07..11263531a42d 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
@@ -22,6 +22,8 @@
 
 import java.util.List;
 
+import static io.netty.buffer.ByteBufUtil.readBytes;
+
 /**
  * Decodes {@link ByteBuf}s into {@link WebSocketFrame}s.
  * <p>
@@ -91,8 +93,7 @@ private WebSocketFrame decodeBinaryFrame(ChannelHandlerContext ctx, byte type, B
             receivedClosingHandshake = true;
             return new CloseWebSocketFrame();
         }
-        ByteBuf payload = ctx.alloc().buffer((int) frameSize);
-        buffer.readBytes(payload);
+        ByteBuf payload = readBytes(ctx.alloc(), buffer, (int) frameSize);
         return new BinaryWebSocketFrame(payload);
     }
 
@@ -116,12 +117,12 @@ private WebSocketFrame decodeTextFrame(ChannelHandlerContext ctx, ByteBuf buffer
             throw new TooLongFrameException();
         }
 
-        ByteBuf binaryData = ctx.alloc().buffer(frameSize);
-        buffer.readBytes(binaryData);
+        ByteBuf binaryData = readBytes(ctx.alloc(), buffer, frameSize);
         buffer.skipBytes(1);
 
         int ffDelimPos = binaryData.indexOf(binaryData.readerIndex(), binaryData.writerIndex(), (byte) 0xFF);
         if (ffDelimPos >= 0) {
+            binaryData.release();
             throw new IllegalArgumentException("a text frame should not contain 0xFF.");
         }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
index e34a3a2dc4ee..1339f2dd5d94 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
@@ -57,21 +57,32 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.CorruptedFrameException;
-import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.util.List;
 
+import static io.netty.buffer.ByteBufUtil.readBytes;
+
 /**
  * Decodes a web socket frame from wire protocol version 8 format. This code was forked from <a
  * href="https://github.com/joewalnes/webbit">webbit</a> and modified.
  */
-public class WebSocket08FrameDecoder extends ReplayingDecoder<WebSocket08FrameDecoder.State>
+public class WebSocket08FrameDecoder extends ByteToMessageDecoder
         implements WebSocketFrameDecoder {
 
+    enum State {
+        READING_FIRST,
+        READING_SECOND,
+        READING_SIZE,
+        MASKING_KEY,
+        PAYLOAD,
+        CORRUPT
+    }
+
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocket08FrameDecoder.class);
 
     private static final byte OPCODE_CONT = 0x0;
@@ -81,26 +92,20 @@ public class WebSocket08FrameDecoder extends ReplayingDecoder<WebSocket08FrameDe
     private static final byte OPCODE_PING = 0x9;
     private static final byte OPCODE_PONG = 0xA;
 
-    private UTF8Output fragmentedFramesText;
-    private int fragmentedFramesCount;
-
     private final long maxFramePayloadLength;
+    private final boolean allowExtensions;
+    private final boolean maskedPayload;
+
+    private int fragmentedFramesCount;
     private boolean frameFinalFlag;
     private int frameRsv;
     private int frameOpcode;
     private long framePayloadLength;
-    private ByteBuf framePayload;
-    private int framePayloadBytesRead;
     private byte[] maskingKey;
-    private ByteBuf payloadBuffer;
-
-    private final boolean allowExtensions;
-    private final boolean maskedPayload;
+    private int framePayloadLen1;
     private boolean receivedClosingHandshake;
-
-    enum State {
-        FRAME_START, MASKING_KEY, PAYLOAD, CORRUPT
-    }
+    private Utf8Validator utf8Validator;
+    private State state = State.READING_FIRST;
 
     /**
      * Constructor
@@ -115,7 +120,6 @@ enum State {
      *            helps check for denial of services attacks.
      */
     public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions, int maxFramePayloadLength) {
-        super(State.FRAME_START);
         this.maskedPayload = maskedPayload;
         this.allowExtensions = allowExtensions;
         this.maxFramePayloadLength = maxFramePayloadLength;
@@ -129,14 +133,13 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             in.skipBytes(actualReadableBytes());
             return;
         }
+            switch (state) {
+                case READING_FIRST:
+                    if (!in.isReadable()) {
+                        return;
+                    }
 
-        try {
-            switch (state()) {
-                case FRAME_START:
-                    framePayloadBytesRead = 0;
-                    framePayloadLength = -1;
-                    framePayload = null;
-                    payloadBuffer = null;
+                    framePayloadLength = 0;
 
                     // FIN, RSV, OPCODE
                     byte b = in.readByte();
@@ -148,10 +151,15 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         logger.debug("Decoding WebSocket Frame opCode={}", frameOpcode);
                     }
 
+                    state = State.READING_SECOND;
+                case READING_SECOND:
+                    if (!in.isReadable()) {
+                        return;
+                    }
                     // MASK, PAYLOAD LEN 1
                     b = in.readByte();
                     boolean frameMasked = (b & 0x80) != 0;
-                    int framePayloadLen1 = b & 0x7F;
+                    framePayloadLen1 = b & 0x7F;
 
                     if (frameRsv != 0 && !allowExtensions) {
                         protocolViolation(ctx, "RSV != 0 and no extension negotiated, RSV:" + frameRsv);
@@ -212,14 +220,23 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         }
                     }
 
+                    state = State.READING_SIZE;
+                 case READING_SIZE:
+
                     // Read frame payload length
                     if (framePayloadLen1 == 126) {
+                        if (in.readableBytes() < 2) {
+                            return;
+                        }
                         framePayloadLength = in.readUnsignedShort();
                         if (framePayloadLength < 126) {
                             protocolViolation(ctx, "invalid data frame length (not using minimal length encoding)");
                             return;
                         }
                     } else if (framePayloadLen1 == 127) {
+                        if (in.readableBytes() < 8) {
+                            return;
+                        }
                         framePayloadLength = in.readLong();
                         // TODO: check if it's bigger than 0x7FFFFFFFFFFFFFFF, Maybe
                         // just check if it's negative?
@@ -241,169 +258,127 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         logger.debug("Decoding WebSocket Frame length={}", framePayloadLength);
                     }
 
-                    checkpoint(State.MASKING_KEY);
+                    state = State.MASKING_KEY;
                 case MASKING_KEY:
                     if (maskedPayload) {
+                        if (in.readableBytes() < 4) {
+                            return;
+                        }
                         if (maskingKey == null) {
                             maskingKey = new byte[4];
                         }
                         in.readBytes(maskingKey);
                     }
-                    checkpoint(State.PAYLOAD);
+                    state = State.PAYLOAD;
                 case PAYLOAD:
-                    // Sometimes, the payload may not be delivered in 1 nice packet
-                    // We need to accumulate the data until we have it all
-                    int rbytes = actualReadableBytes();
-
-                    long willHaveReadByteCount = framePayloadBytesRead + rbytes;
-                    // logger.debug("Frame rbytes=" + rbytes + " willHaveReadByteCount="
-                    // + willHaveReadByteCount + " framePayloadLength=" +
-                    // framePayloadLength);
-                    if (willHaveReadByteCount == framePayloadLength) {
-                        // We have all our content so proceed to process
-                        payloadBuffer = ctx.alloc().buffer(rbytes);
-                        payloadBuffer.writeBytes(in, rbytes);
-                    } else if (willHaveReadByteCount < framePayloadLength) {
-
-                        // We don't have all our content so accumulate payload.
-                        // Returning null means we will get called back
-                        if (framePayload == null) {
-                            framePayload = ctx.alloc().buffer(toFrameLength(framePayloadLength));
-                        }
-                        framePayload.writeBytes(in, rbytes);
-                        framePayloadBytesRead += rbytes;
-
-                        // Return null to wait for more bytes to arrive
+                    if (in.readableBytes() < framePayloadLength) {
                         return;
-                    } else if (willHaveReadByteCount > framePayloadLength) {
-                        // We have more than what we need so read up to the end of frame
-                        // Leave the remainder in the buffer for next frame
-                        if (framePayload == null) {
-                            framePayload = ctx.alloc().buffer(toFrameLength(framePayloadLength));
-                        }
-                        framePayload.writeBytes(in, toFrameLength(framePayloadLength - framePayloadBytesRead));
                     }
 
-                    // Now we have all the data, the next checkpoint must be the next
-                    // frame
-                    checkpoint(State.FRAME_START);
-
-                    // Take the data that we have in this packet
-                    if (framePayload == null) {
-                        framePayload = payloadBuffer;
-                        payloadBuffer = null;
-                    } else if (payloadBuffer != null) {
-                        framePayload.writeBytes(payloadBuffer);
-                        payloadBuffer.release();
-                        payloadBuffer = null;
-                    }
+                    ByteBuf payloadBuffer = null;
+                    try {
+                        payloadBuffer = readBytes(ctx.alloc(), in, toFrameLength(framePayloadLength));
 
-                    // Unmask data if needed
-                    if (maskedPayload) {
-                        unmask(framePayload);
-                    }
+                        // Now we have all the data, the next checkpoint must be the next
+                        // frame
+                        state = State.READING_FIRST;
 
-                    // Processing ping/pong/close frames because they cannot be
-                    // fragmented
-                    if (frameOpcode == OPCODE_PING) {
-                        out.add(new PingWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                        framePayload = null;
-                        return;
-                    }
-                    if (frameOpcode == OPCODE_PONG) {
-                        out.add(new PongWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                        framePayload = null;
-                        return;
-                    }
-                    if (frameOpcode == OPCODE_CLOSE) {
-                        checkCloseFrameBody(ctx, framePayload);
-                        receivedClosingHandshake = true;
-                        out.add(new CloseWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                        framePayload = null;
-                        return;
-                    }
+                        // Unmask data if needed
+                        if (maskedPayload) {
+                            unmask(payloadBuffer);
+                        }
 
-                    // Processing for possible fragmented messages for text and binary
-                    // frames
-                    String aggregatedText = null;
-                    if (frameFinalFlag) {
-                        // Final frame of the sequence. Apparently ping frames are
-                        // allowed in the middle of a fragmented message
-                        if (frameOpcode != OPCODE_PING) {
-                            fragmentedFramesCount = 0;
-
-                            // Check text for UTF8 correctness
-                            if (frameOpcode == OPCODE_TEXT || fragmentedFramesText != null) {
-                                // Check UTF-8 correctness for this payload
-                                checkUTF8String(ctx, framePayload);
-
-                                // This does a second check to make sure UTF-8
-                                // correctness for entire text message
-                                aggregatedText = fragmentedFramesText.toString();
-
-                                fragmentedFramesText = null;
-                            }
+                        // Processing ping/pong/close frames because they cannot be
+                        // fragmented
+                        if (frameOpcode == OPCODE_PING) {
+                            out.add(new PingWebSocketFrame(frameFinalFlag, frameRsv, payloadBuffer));
+                            payloadBuffer = null;
+                            return;
                         }
-                    } else {
-                        // Not final frame so we can expect more frames in the
-                        // fragmented sequence
-                        if (fragmentedFramesCount == 0) {
-                            // First text or binary frame for a fragmented set
-                            fragmentedFramesText = null;
-                            if (frameOpcode == OPCODE_TEXT) {
-                                checkUTF8String(ctx, framePayload);
+                        if (frameOpcode == OPCODE_PONG) {
+                            out.add(new PongWebSocketFrame(frameFinalFlag, frameRsv, payloadBuffer));
+                            payloadBuffer = null;
+                            return;
+                        }
+                        if (frameOpcode == OPCODE_CLOSE) {
+                            checkCloseFrameBody(ctx, payloadBuffer);
+                            receivedClosingHandshake = true;
+                            out.add(new CloseWebSocketFrame(frameFinalFlag, frameRsv, payloadBuffer));
+                            payloadBuffer = null;
+                            return;
+                        }
+
+                        // Processing for possible fragmented messages for text and binary
+                        // frames
+                        if (frameFinalFlag) {
+                            // Final frame of the sequence. Apparently ping frames are
+                            // allowed in the middle of a fragmented message
+                            if (frameOpcode != OPCODE_PING) {
+                                fragmentedFramesCount = 0;
+
+                                // Check text for UTF8 correctness
+                                if (frameOpcode == OPCODE_TEXT ||
+                                        utf8Validator != null && utf8Validator.isChecking()) {
+                                    // Check UTF-8 correctness for this payload
+                                    checkUTF8String(ctx, payloadBuffer);
+
+                                    // This does a second check to make sure UTF-8
+                                    // correctness for entire text message
+                                    utf8Validator.finish();
+                                }
                             }
                         } else {
-                            // Subsequent frames - only check if init frame is text
-                            if (fragmentedFramesText != null) {
-                                checkUTF8String(ctx, framePayload);
+                            // Not final frame so we can expect more frames in the
+                            // fragmented sequence
+                            if (fragmentedFramesCount == 0) {
+                                // First text or binary frame for a fragmented set
+                                if (frameOpcode == OPCODE_TEXT) {
+                                    checkUTF8String(ctx, payloadBuffer);
+                                }
+                            } else {
+                                // Subsequent frames - only check if init frame is text
+                                if (utf8Validator != null && utf8Validator.isChecking()) {
+                                    checkUTF8String(ctx, payloadBuffer);
+                                }
                             }
-                        }
 
-                        // Increment counter
-                        fragmentedFramesCount++;
-                    }
+                            // Increment counter
+                            fragmentedFramesCount++;
+                        }
 
-                    // Return the frame
-                    if (frameOpcode == OPCODE_TEXT) {
-                        out.add(new TextWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                        framePayload = null;
-                        return;
-                    } else if (frameOpcode == OPCODE_BINARY) {
-                        out.add(new BinaryWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                        framePayload = null;
-                        return;
-                    } else if (frameOpcode == OPCODE_CONT) {
-                        out.add(new ContinuationWebSocketFrame(frameFinalFlag, frameRsv, framePayload, aggregatedText));
-                        framePayload = null;
-                        return;
-                    } else {
-                        throw new UnsupportedOperationException("Cannot decode web socket frame with opcode: "
-                                + frameOpcode);
+                        // Return the frame
+                        if (frameOpcode == OPCODE_TEXT) {
+                            out.add(new TextWebSocketFrame(frameFinalFlag, frameRsv, payloadBuffer));
+                            payloadBuffer = null;
+                            return;
+                        } else if (frameOpcode == OPCODE_BINARY) {
+                            out.add(new BinaryWebSocketFrame(frameFinalFlag, frameRsv, payloadBuffer));
+                            payloadBuffer = null;
+                            return;
+                        } else if (frameOpcode == OPCODE_CONT) {
+                            out.add(new ContinuationWebSocketFrame(frameFinalFlag, frameRsv,
+                                    payloadBuffer));
+                            payloadBuffer = null;
+                            return;
+                        } else {
+                            throw new UnsupportedOperationException("Cannot decode web socket frame with opcode: "
+                                    + frameOpcode);
+                        }
+                    } finally {
+                        if (payloadBuffer != null) {
+                            payloadBuffer.release();
+                        }
                     }
                 case CORRUPT:
-                    // If we don't keep reading Netty will throw an exception saying
-                    // we can't return null if no bytes read and state not changed.
-                    in.readByte();
+                    if (in.isReadable()) {
+                        // If we don't keep reading Netty will throw an exception saying
+                        // we can't return null if no bytes read and state not changed.
+                        in.readByte();
+                    }
                     return;
                 default:
                     throw new Error("Shouldn't reach here.");
             }
-        } catch (Exception e) {
-            if (payloadBuffer != null) {
-                if (payloadBuffer.refCnt() > 0) {
-                    payloadBuffer.release();
-                }
-                payloadBuffer = null;
-            }
-            if (framePayload != null) {
-                if (framePayload.refCnt() > 0) {
-                    framePayload.release();
-                }
-                framePayload = null;
-            }
-            throw e;
-        }
     }
 
     private void unmask(ByteBuf frame) {
@@ -413,11 +388,15 @@ private void unmask(ByteBuf frame) {
     }
 
     private void protocolViolation(ChannelHandlerContext ctx, String reason) {
-        checkpoint(State.CORRUPT);
+        protocolViolation(ctx, new CorruptedFrameException(reason));
+    }
+
+    private void protocolViolation(ChannelHandlerContext ctx, CorruptedFrameException ex) {
+        state = State.CORRUPT;
         if (ctx.channel().isActive()) {
             ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
         }
-        throw new CorruptedFrameException(reason);
+        throw ex;
     }
 
     private static int toFrameLength(long l) {
@@ -430,13 +409,12 @@ private static int toFrameLength(long l) {
 
     private void checkUTF8String(ChannelHandlerContext ctx, ByteBuf buffer) {
         try {
-            if (fragmentedFramesText == null) {
-                fragmentedFramesText = new UTF8Output(buffer);
-            } else {
-                fragmentedFramesText.write(buffer);
+            if (utf8Validator == null) {
+                utf8Validator = new Utf8Validator();
             }
-        } catch (UTF8Exception ex) {
-            protocolViolation(ctx, "invalid UTF-8 bytes");
+            utf8Validator.check(buffer);
+        } catch (CorruptedFrameException ex) {
+            protocolViolation(ctx, ex);
         }
     }
 
@@ -464,27 +442,13 @@ protected void checkCloseFrameBody(
         // May have UTF-8 message
         if (buffer.isReadable()) {
             try {
-                new UTF8Output(buffer);
-            } catch (UTF8Exception ex) {
-                protocolViolation(ctx, "Invalid close frame reason text. Invalid UTF-8 bytes");
+                new Utf8Validator().check(buffer);
+            } catch (CorruptedFrameException ex) {
+                protocolViolation(ctx, ex);
             }
         }
 
         // Restore reader index
         buffer.readerIndex(idx);
     }
-
-    @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        super.channelInactive(ctx);
-
-        // release all not complete frames data to prevent leaks.
-        // https://github.com/netty/netty/issues/1874
-        if (framePayload != null) {
-            framePayload.release();
-        }
-        if (payloadBuffer != null) {
-            payloadBuffer.release();
-        }
-    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
index 4ec7833e6662..2bd4f4234c2f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -191,20 +192,20 @@ protected FullHttpRequest newHandshakeRequest() {
     protected void verify(FullHttpResponse response) {
         final HttpResponseStatus status = new HttpResponseStatus(101, "WebSocket Protocol Handshake");
 
-        if (!response.getStatus().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
+        if (!response.status().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.status());
         }
 
         HttpHeaders headers = response.headers();
 
         String upgrade = headers.get(Names.UPGRADE);
-        if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!AsciiString.equalsIgnoreCase(Values.WEBSOCKET, upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: "
                     + upgrade);
         }
 
         String connection = headers.get(Names.CONNECTION);
-        if (!Values.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!AsciiString.equalsIgnoreCase(Values.UPGRADE, connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: "
                     + connection);
         }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
index a0120554698c..b9a87cf2be43 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -40,7 +41,7 @@
 public class WebSocketClientHandshaker07 extends WebSocketClientHandshaker {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocketClientHandshaker07.class);
-
+    private static final CharSequence WEBSOCKET = HttpHeaders.newEntity(Values.WEBSOCKET.toLowerCase());
     public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
     private String expectedChallengeResponseString;
@@ -110,15 +111,16 @@ protected FullHttpRequest newHandshakeRequest() {
         expectedChallengeResponseString = WebSocketUtil.base64(sha1);
 
         if (logger.isDebugEnabled()) {
-            logger.debug(String.format("WS Version 07 Client Handshake key: %s. Expected response: %s.", key,
-                    expectedChallengeResponseString));
+            logger.debug(
+                    "WebSocket version 07 client handshake key: {}, expected response: {}",
+                    key, expectedChallengeResponseString);
         }
 
         // Format request
         FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);
         HttpHeaders headers = request.headers();
 
-        headers.add(Names.UPGRADE, Values.WEBSOCKET.toLowerCase())
+        headers.add(Names.UPGRADE, WEBSOCKET)
                .add(Names.CONNECTION, Values.UPGRADE)
                .add(Names.SEC_WEBSOCKET_KEY, key)
                .add(Names.HOST, wsURL.getHost());
@@ -167,17 +169,17 @@ protected void verify(FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.getStatus().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
+        if (!response.status().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.status());
         }
 
         String upgrade = headers.get(Names.UPGRADE);
-        if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!AsciiString.equalsIgnoreCase(Values.WEBSOCKET, upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: " + upgrade);
         }
 
         String connection = headers.get(Names.CONNECTION);
-        if (!Values.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!AsciiString.equalsIgnoreCase(Values.UPGRADE, connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: " + connection);
         }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
index d376721ac5c3..a32ba37d7672 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -40,6 +41,7 @@
 public class WebSocketClientHandshaker08 extends WebSocketClientHandshaker {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocketClientHandshaker08.class);
+    private static final CharSequence WEBSOCKET = HttpHeaders.newEntity(Values.WEBSOCKET.toLowerCase());
 
     public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
@@ -110,15 +112,16 @@ protected FullHttpRequest newHandshakeRequest() {
         expectedChallengeResponseString = WebSocketUtil.base64(sha1);
 
         if (logger.isDebugEnabled()) {
-            logger.debug(String.format("WS Version 08 Client Handshake key: %s. Expected response: %s.", key,
-                    expectedChallengeResponseString));
+            logger.debug(
+                    "WebSocket version 08 client handshake key: {}, expected response: {}",
+                    key, expectedChallengeResponseString);
         }
 
         // Format request
         FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);
         HttpHeaders headers = request.headers();
 
-        headers.add(Names.UPGRADE, Values.WEBSOCKET.toLowerCase())
+        headers.add(Names.UPGRADE, WEBSOCKET)
                .add(Names.CONNECTION, Values.UPGRADE)
                .add(Names.SEC_WEBSOCKET_KEY, key)
                .add(Names.HOST, wsURL.getHost());
@@ -167,17 +170,17 @@ protected void verify(FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.getStatus().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
+        if (!response.status().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.status());
         }
 
         String upgrade = headers.get(Names.UPGRADE);
-        if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!AsciiString.equalsIgnoreCase(Values.WEBSOCKET, upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: " + upgrade);
         }
 
         String connection = headers.get(Names.CONNECTION);
-        if (!Values.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!AsciiString.equalsIgnoreCase(Values.UPGRADE, connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: " + connection);
         }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
index ef18fca2133f..0aeae3ba4809 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -40,6 +41,7 @@
 public class WebSocketClientHandshaker13 extends WebSocketClientHandshaker {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocketClientHandshaker13.class);
+    private static final CharSequence WEBSOCKET = HttpHeaders.newEntity(Values.WEBSOCKET.toLowerCase());
 
     public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
@@ -110,8 +112,9 @@ protected FullHttpRequest newHandshakeRequest() {
         expectedChallengeResponseString = WebSocketUtil.base64(sha1);
 
         if (logger.isDebugEnabled()) {
-            logger.debug(String.format("WS Version 13 Client Handshake key: %s. Expected response: %s.", key,
-                    expectedChallengeResponseString));
+            logger.debug(
+                    "WebSocket version 13 client handshake key: {}, expected response: {}",
+                    key, expectedChallengeResponseString);
         }
 
         // Format request
@@ -129,7 +132,7 @@ protected FullHttpRequest newHandshakeRequest() {
         FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, path);
         HttpHeaders headers = request.headers();
 
-        headers.add(Names.UPGRADE, Values.WEBSOCKET.toLowerCase())
+        headers.add(Names.UPGRADE, WEBSOCKET)
                .add(Names.CONNECTION, Values.UPGRADE)
                .add(Names.SEC_WEBSOCKET_KEY, key)
                .add(Names.HOST, wsURL.getHost() + ':' + wsPort);
@@ -177,17 +180,17 @@ protected void verify(FullHttpResponse response) {
         final HttpResponseStatus status = HttpResponseStatus.SWITCHING_PROTOCOLS;
         final HttpHeaders headers = response.headers();
 
-        if (!response.getStatus().equals(status)) {
-            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.getStatus());
+        if (!response.status().equals(status)) {
+            throw new WebSocketHandshakeException("Invalid handshake response getStatus: " + response.status());
         }
 
         String upgrade = headers.get(Names.UPGRADE);
-        if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {
+        if (!AsciiString.equalsIgnoreCase(Values.WEBSOCKET, upgrade)) {
             throw new WebSocketHandshakeException("Invalid handshake response upgrade: " + upgrade);
         }
 
         String connection = headers.get(Names.CONNECTION);
-        if (!Values.UPGRADE.equalsIgnoreCase(connection)) {
+        if (!AsciiString.equalsIgnoreCase(Values.UPGRADE, connection)) {
             throw new WebSocketHandshakeException("Invalid handshake response connection: " + connection);
         }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java
index 231f1cbdc27c..6e616bf1f826 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java
@@ -91,6 +91,6 @@ public static WebSocketClientHandshaker newHandshaker(
                     webSocketURL, V00, subprotocol, customHeaders, maxFramePayloadLength);
         }
 
-        throw new WebSocketHandshakeException("Protocol version " + version.toString() + " not supported.");
+        throw new WebSocketHandshakeException("Protocol version " + version + " not supported.");
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
index 1ea168c54367..c43060a67700 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
@@ -24,7 +24,7 @@
 class WebSocketClientProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {
     private final WebSocketClientHandshaker handshaker;
 
-    public WebSocketClientProtocolHandshakeHandler(WebSocketClientHandshaker handshaker) {
+    WebSocketClientProtocolHandshakeHandler(WebSocketClientHandshaker handshaker) {
         this.handshaker = handshaker;
     }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
index 054bda4cdafa..c46eec82bddc 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
@@ -68,7 +68,7 @@ public int rsv() {
 
     @Override
     public String toString() {
-        return StringUtil.simpleClassName(this) + "(data: " + content().toString() + ')';
+        return StringUtil.simpleClassName(this) + "(data: " + content() + ')';
     }
 
     @Override
@@ -82,4 +82,16 @@ public WebSocketFrame retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public WebSocketFrame touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public WebSocketFrame touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java
index c8cb395b61e9..5df7ea855722 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java
@@ -16,110 +16,78 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.CompositeByteBuf;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.handler.codec.MessageAggregator;
 import io.netty.handler.codec.TooLongFrameException;
 
-import java.util.List;
-
 /**
  * Handler that aggregate fragmented WebSocketFrame's.
  *
  * Be aware if PING/PONG/CLOSE frames are send in the middle of a fragmented {@link WebSocketFrame} they will
  * just get forwarded to the next handler in the pipeline.
  */
-public class WebSocketFrameAggregator extends MessageToMessageDecoder<WebSocketFrame> {
-    private final int maxFrameSize;
-    private WebSocketFrame currentFrame;
-    private boolean tooLongFrameFound;
+public class WebSocketFrameAggregator
+        extends MessageAggregator<WebSocketFrame, WebSocketFrame, ContinuationWebSocketFrame, WebSocketFrame> {
 
     /**
-     * Construct a new instance
+     * Creates a new instance
      *
-     * @param maxFrameSize      If the size of the aggregated frame exceeds this value,
-     *                          a {@link TooLongFrameException} is thrown.
+     * @param maxContentLength If the size of the aggregated frame exceeds this value,
+     *                         a {@link TooLongFrameException} is thrown.
      */
-    public WebSocketFrameAggregator(int maxFrameSize) {
-        if (maxFrameSize < 1) {
-            throw new IllegalArgumentException("maxFrameSize must be > 0");
-        }
-        this.maxFrameSize = maxFrameSize;
+    public WebSocketFrameAggregator(int maxContentLength) {
+        super(maxContentLength);
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object> out) throws Exception {
-        if (currentFrame == null) {
-            tooLongFrameFound = false;
-            if (msg.isFinalFragment()) {
-                out.add(msg.retain());
-                return;
-            }
-            ByteBuf buf = ctx.alloc().compositeBuffer().addComponent(msg.content().retain());
-            buf.writerIndex(buf.writerIndex() + msg.content().readableBytes());
+    protected boolean isStartMessage(WebSocketFrame msg) throws Exception {
+        return msg instanceof TextWebSocketFrame || msg instanceof BinaryWebSocketFrame;
+    }
 
-            if (msg instanceof TextWebSocketFrame) {
-                currentFrame = new TextWebSocketFrame(true, msg.rsv(), buf);
-            } else if (msg instanceof BinaryWebSocketFrame) {
-                currentFrame = new BinaryWebSocketFrame(true, msg.rsv(), buf);
-            } else {
-                buf.release();
-                throw new IllegalStateException(
-                        "WebSocket frame was not of type TextWebSocketFrame or BinaryWebSocketFrame");
-            }
-            return;
-        }
-        if (msg instanceof ContinuationWebSocketFrame) {
-            if (tooLongFrameFound) {
-                if (msg.isFinalFragment()) {
-                    currentFrame = null;
-                }
-                return;
-            }
-            CompositeByteBuf content = (CompositeByteBuf) currentFrame.content();
-            if (content.readableBytes() > maxFrameSize - msg.content().readableBytes()) {
-                // release the current frame
-                currentFrame.release();
-                tooLongFrameFound = true;
-                throw new TooLongFrameException(
-                        "WebSocketFrame length exceeded " + content +
-                                " bytes.");
-            }
-            content.addComponent(msg.content().retain());
-            content.writerIndex(content.writerIndex() + msg.content().readableBytes());
+    @Override
+    protected boolean isContentMessage(WebSocketFrame msg) throws Exception {
+        return msg instanceof ContinuationWebSocketFrame;
+    }
 
-            if (msg.isFinalFragment()) {
-                WebSocketFrame currentFrame = this.currentFrame;
-                this.currentFrame = null;
-                out.add(currentFrame);
-                return;
-            } else {
-                return;
-            }
-        }
-        // It is possible to receive CLOSE/PING/PONG frames during fragmented frames so just pass them to the next
-        // handler in the chain
-        out.add(msg.retain());
+    @Override
+    protected boolean isLastContentMessage(ContinuationWebSocketFrame msg) throws Exception {
+        return isContentMessage(msg) && msg.isFinalFragment();
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        super.channelInactive(ctx);
-        // release current frame if it is not null as it may be a left-over
-        if (currentFrame != null) {
-            currentFrame.release();
-            currentFrame = null;
+    protected boolean isAggregated(WebSocketFrame msg) throws Exception {
+        if (msg.isFinalFragment()) {
+            return !isContentMessage(msg);
         }
+
+        return !isStartMessage(msg) && !isContentMessage(msg);
     }
 
     @Override
-    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
-        super.handlerRemoved(ctx);
-        // release current frame if it is not null as it may be a left-over as there is not much more we can do in
-        // this case
-        if (currentFrame != null) {
-            currentFrame.release();
-            currentFrame = null;
+    protected boolean hasContentLength(WebSocketFrame start) throws Exception {
+        return false;
+    }
+
+    @Override
+    protected long contentLength(WebSocketFrame start) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected Object newContinueResponse(WebSocketFrame start) throws Exception {
+        return null;
+    }
+
+    @Override
+    protected WebSocketFrame beginAggregation(WebSocketFrame start, ByteBuf content) throws Exception {
+        if (start instanceof TextWebSocketFrame) {
+            return new TextWebSocketFrame(true, start.rsv(), content);
         }
+
+        if (start instanceof BinaryWebSocketFrame) {
+            return new BinaryWebSocketFrame(true, start.rsv(), content);
+        }
+
+        // Should not reach here.
+        throw new Error();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
index 22c8198d8e82..c2ca118d3511 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
@@ -156,7 +156,7 @@ public final ChannelFuture handshake(Channel channel, FullHttpRequest req,
                                             HttpHeaders responseHeaders, final ChannelPromise promise) {
 
         if (logger.isDebugEnabled()) {
-            logger.debug(String.format("%s WS Version %s server handshake", channel, version()));
+            logger.debug("{} WebSocket version {} server handshake", channel, version());
         }
         FullHttpResponse response = newHandshakeResponse(req, responseHeaders);
         ChannelPipeline p = channel.pipeline();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
index c55f3c6012e4..6f30d248f366 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
@@ -20,6 +20,7 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -109,8 +110,8 @@ public WebSocketServerHandshaker00(String webSocketURL, String subprotocols, int
     protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders headers) {
 
         // Serve the WebSocket handshake request.
-        if (!Values.UPGRADE.equalsIgnoreCase(req.headers().get(CONNECTION))
-                || !WEBSOCKET.equalsIgnoreCase(req.headers().get(Names.UPGRADE))) {
+        if (!AsciiString.equalsIgnoreCase(Values.UPGRADE, req.headers().get(CONNECTION))
+                || !AsciiString.equalsIgnoreCase(WEBSOCKET, req.headers().get(Names.UPGRADE))) {
             throw new WebSocketHandshakeException("not a WebSocket handshake request: missing upgrade");
         }
 
@@ -137,7 +138,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
                 String selectedSubprotocol = selectSubprotocol(subprotocols);
                 if (selectedSubprotocol == null) {
                     if (logger.isDebugEnabled()) {
-                        logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));
+                        logger.debug("Requested subprotocol(s) not supported: {}", subprotocols);
                     }
                 } else {
                     res.headers().add(SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
index e9cf0f6c7eea..cd1f39506ae5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
@@ -20,10 +20,10 @@
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.util.CharsetUtil;
 
-import static io.netty.handler.codec.http.HttpHeaders.Values.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 
 /**
@@ -35,6 +35,8 @@
  */
 public class WebSocketServerHandshaker07 extends WebSocketServerHandshaker {
 
+    private static final CharSequence WEBSOCKET = HttpHeaders.newEntity(Values.WEBSOCKET.toLowerCase());
+
     public static final String WEBSOCKET_07_ACCEPT_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
     private final boolean allowExtensions;
@@ -111,10 +113,10 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         String accept = WebSocketUtil.base64(sha1);
 
         if (logger.isDebugEnabled()) {
-            logger.debug(String.format("WS Version 7 Server Handshake key: %s. Response: %s.", key, accept));
+            logger.debug("WebSocket version 07 server handshake key: {}, response: {}.", key, accept);
         }
 
-        res.headers().add(Names.UPGRADE, WEBSOCKET.toLowerCase());
+        res.headers().add(Names.UPGRADE, WEBSOCKET);
         res.headers().add(Names.CONNECTION, Names.UPGRADE);
         res.headers().add(Names.SEC_WEBSOCKET_ACCEPT, accept);
         String subprotocols = req.headers().get(Names.SEC_WEBSOCKET_PROTOCOL);
@@ -122,7 +124,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             String selectedSubprotocol = selectSubprotocol(subprotocols);
             if (selectedSubprotocol == null) {
                 if (logger.isDebugEnabled()) {
-                    logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));
+                    logger.debug("Requested subprotocol(s) not supported: {}", subprotocols);
                 }
             } else {
                 res.headers().add(Names.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
index 6eaa91bc327a..a038909c656b 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
@@ -20,10 +20,10 @@
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.util.CharsetUtil;
 
-import static io.netty.handler.codec.http.HttpHeaders.Values.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 
 /**
@@ -35,6 +35,8 @@
  */
 public class WebSocketServerHandshaker08 extends WebSocketServerHandshaker {
 
+    private static final CharSequence WEBSOCKET = HttpHeaders.newEntity(Values.WEBSOCKET.toLowerCase());
+
     public static final String WEBSOCKET_08_ACCEPT_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
     private final boolean allowExtensions;
@@ -110,10 +112,10 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         String accept = WebSocketUtil.base64(sha1);
 
         if (logger.isDebugEnabled()) {
-            logger.debug(String.format("WS Version 8 Server Handshake key: %s. Response: %s.", key, accept));
+            logger.debug("WebSocket version 08 server handshake key: {}, response: {}", key, accept);
         }
 
-        res.headers().add(Names.UPGRADE, WEBSOCKET.toLowerCase());
+        res.headers().add(Names.UPGRADE, WEBSOCKET);
         res.headers().add(Names.CONNECTION, Names.UPGRADE);
         res.headers().add(Names.SEC_WEBSOCKET_ACCEPT, accept);
         String subprotocols = req.headers().get(Names.SEC_WEBSOCKET_PROTOCOL);
@@ -121,7 +123,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             String selectedSubprotocol = selectSubprotocol(subprotocols);
             if (selectedSubprotocol == null) {
                 if (logger.isDebugEnabled()) {
-                    logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));
+                    logger.debug("Requested subprotocol(s) not supported: {}", subprotocols);
                 }
             } else {
                 res.headers().add(Names.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
index bea52550ae4c..367c2ff1a632 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
@@ -20,10 +20,10 @@
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpHeaders.Values;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.util.CharsetUtil;
 
-import static io.netty.handler.codec.http.HttpHeaders.Values.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 
 /**
@@ -34,6 +34,8 @@
  */
 public class WebSocketServerHandshaker13 extends WebSocketServerHandshaker {
 
+    private static final CharSequence WEBSOCKET = HttpHeaders.newEntity(Values.WEBSOCKET.toLowerCase());
+
     public static final String WEBSOCKET_13_ACCEPT_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
 
     private final boolean allowExtensions;
@@ -108,10 +110,10 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
         String accept = WebSocketUtil.base64(sha1);
 
         if (logger.isDebugEnabled()) {
-            logger.debug(String.format("WS Version 13 Server Handshake key: %s. Response: %s.", key, accept));
+            logger.debug("WebSocket version 13 server handshake key: {}, response: {}", key, accept);
         }
 
-        res.headers().add(Names.UPGRADE, WEBSOCKET.toLowerCase());
+        res.headers().add(Names.UPGRADE, WEBSOCKET);
         res.headers().add(Names.CONNECTION, Names.UPGRADE);
         res.headers().add(Names.SEC_WEBSOCKET_ACCEPT, accept);
         String subprotocols = req.headers().get(Names.SEC_WEBSOCKET_PROTOCOL);
@@ -119,7 +121,7 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
             String selectedSubprotocol = selectSubprotocol(subprotocols);
             if (selectedSubprotocol == null) {
                 if (logger.isDebugEnabled()) {
-                    logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));
+                    logger.debug("Requested subprotocol(s) not supported: {}", subprotocols);
                 }
             } else {
                 res.headers().add(Names.SEC_WEBSOCKET_PROTOCOL, selectedSubprotocol);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
index c04c950f765f..550e1766ce05 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
@@ -61,11 +61,12 @@ public enum ServerHandshakeStateEvent {
     }
 
     private static final AttributeKey<WebSocketServerHandshaker> HANDSHAKER_ATTR_KEY =
-            AttributeKey.valueOf(WebSocketServerHandshaker.class.getName() + ".HANDSHAKER");
+            AttributeKey.valueOf(WebSocketServerHandshaker.class, "HANDSHAKER");
 
     private final String websocketPath;
     private final String subprotocols;
     private final boolean allowExtensions;
+    private final int maxFramePayloadLength;
 
     public WebSocketServerProtocolHandler(String websocketPath) {
         this(websocketPath, null, false);
@@ -76,9 +77,15 @@ public WebSocketServerProtocolHandler(String websocketPath, String subprotocols)
     }
 
     public WebSocketServerProtocolHandler(String websocketPath, String subprotocols, boolean allowExtensions) {
+        this(websocketPath, subprotocols, allowExtensions, 65536);
+    }
+
+    public WebSocketServerProtocolHandler(String websocketPath, String subprotocols,
+            boolean allowExtensions, int maxFrameSize) {
         this.websocketPath = websocketPath;
         this.subprotocols = subprotocols;
         this.allowExtensions = allowExtensions;
+        maxFramePayloadLength = maxFrameSize;
     }
 
     @Override
@@ -87,7 +94,8 @@ public void handlerAdded(ChannelHandlerContext ctx) {
         if (cp.get(WebSocketServerProtocolHandshakeHandler.class) == null) {
             // Add the WebSocketHandshakeHandler before this one.
             ctx.pipeline().addBefore(ctx.name(), WebSocketServerProtocolHandshakeHandler.class.getName(),
-                    new WebSocketServerProtocolHandshakeHandler(websocketPath, subprotocols, allowExtensions));
+                    new WebSocketServerProtocolHandshakeHandler(websocketPath, subprotocols,
+                            allowExtensions, maxFramePayloadLength));
         }
     }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
index a1f0d3e20765..57704ec7d68a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
@@ -22,7 +22,6 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.ssl.SslHandler;
@@ -35,31 +34,33 @@
 /**
  * Handles the HTTP handshake (the HTTP Upgrade request) for {@link WebSocketServerProtocolHandler}.
  */
-class WebSocketServerProtocolHandshakeHandler
-        extends ChannelInboundHandlerAdapter {
+class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {
 
     private final String websocketPath;
     private final String subprotocols;
     private final boolean allowExtensions;
+    private final int maxFramePayloadSize;
 
     WebSocketServerProtocolHandshakeHandler(String websocketPath, String subprotocols,
-            boolean allowExtensions) {
+            boolean allowExtensions, int maxFrameSize) {
         this.websocketPath = websocketPath;
         this.subprotocols = subprotocols;
         this.allowExtensions = allowExtensions;
+        maxFramePayloadSize = maxFrameSize;
     }
 
     @Override
     public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
         FullHttpRequest req = (FullHttpRequest) msg;
         try {
-            if (req.getMethod() != GET) {
+            if (req.method() != GET) {
                 sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
                 return;
             }
 
             final WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(
-                    getWebSocketLocation(ctx.pipeline(), req, websocketPath), subprotocols, allowExtensions);
+                    getWebSocketLocation(ctx.pipeline(), req, websocketPath), subprotocols,
+                            allowExtensions, maxFramePayloadSize);
             final WebSocketServerHandshaker handshaker = wsFactory.newHandshaker(req);
             if (handshaker == null) {
                 WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());
@@ -87,7 +88,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
 
     private static void sendHttpResponse(ChannelHandlerContext ctx, HttpRequest req, HttpResponse res) {
         ChannelFuture f = ctx.channel().writeAndFlush(res);
-        if (!isKeepAlive(req) || res.getStatus().code() != 200) {
+        if (!isKeepAlive(req) || res.status().code() != 200) {
             f.addListener(ChannelFutureListener.CLOSE);
         }
     }
@@ -98,7 +99,7 @@ private static String getWebSocketLocation(ChannelPipeline cp, HttpRequest req,
             // SSL in use so use Secure WebSockets
             protocol = "wss";
         }
-        return protocol + "://" + req.headers().get(HttpHeaders.Names.HOST) + path;
+        return protocol + "://" + req.headers().get(Names.HOST) + path;
     }
 
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java
index c1ae1c206d3a..da13aa89d9a3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.util.CharsetUtil;
 
@@ -36,13 +37,13 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     }
 
     @Override
-    protected void encodeInitialLine(ByteBuf buf, HttpRequest request)
-            throws Exception {
-        encodeAscii(request.getMethod().toString(), buf);
+    @SuppressWarnings("deprecation")
+    protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {
+        HttpHeaders.encodeAscii(request.method().toString(), buf);
         buf.writeByte(SP);
-        buf.writeBytes(request.getUri().getBytes(CharsetUtil.UTF_8));
+        buf.writeBytes(request.uri().getBytes(CharsetUtil.UTF_8));
         buf.writeByte(SP);
-        encodeAscii(request.getProtocolVersion().toString(), buf);
+        HttpHeaders.encodeAscii(request.protocolVersion().toString(), buf);
         buf.writeBytes(CRLF);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java
index 347490126776..53968e405c3e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.util.CharsetUtil;
 
@@ -25,7 +26,6 @@
 /**
  * Encodes an RTSP response represented in {@link FullHttpResponse} into
  * a {@link ByteBuf}.
-
  */
 public class RtspResponseEncoder extends RtspObjectEncoder<HttpResponse> {
     private static final byte[] CRLF = { CR, LF };
@@ -36,13 +36,13 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     }
 
     @Override
-    protected void encodeInitialLine(ByteBuf buf, HttpResponse response)
-            throws Exception {
-        encodeAscii(response.getProtocolVersion().toString(), buf);
+    @SuppressWarnings("deprecation")
+    protected void encodeInitialLine(ByteBuf buf, HttpResponse response) throws Exception {
+        HttpHeaders.encodeAscii(response.protocolVersion().toString(), buf);
         buf.writeByte(SP);
-        buf.writeBytes(String.valueOf(response.getStatus().code()).getBytes(CharsetUtil.US_ASCII));
+        buf.writeBytes(String.valueOf(response.status().code()).getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(SP);
-        encodeAscii(String.valueOf(response.getStatus().reasonPhrase()), buf);
+        HttpHeaders.encodeAscii(String.valueOf(response.status().reasonPhrase()), buf);
         buf.writeBytes(CRLF);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
index cfdb1d07cb01..46b2553cb500 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
@@ -80,14 +80,14 @@ public ByteBuf content() {
 
     @Override
     public SpdyDataFrame copy() {
-        SpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), content().copy());
+        SpdyDataFrame frame = new DefaultSpdyDataFrame(streamId(), content().copy());
         frame.setLast(isLast());
         return frame;
     }
 
     @Override
     public SpdyDataFrame duplicate() {
-        SpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), content().duplicate());
+        SpdyDataFrame frame = new DefaultSpdyDataFrame(streamId(), content().duplicate());
         frame.setLast(isLast());
         return frame;
     }
@@ -109,6 +109,18 @@ public SpdyDataFrame retain(int increment) {
         return this;
     }
 
+    @Override
+    public SpdyDataFrame touch() {
+        data.touch();
+        return this;
+    }
+
+    @Override
+    public SpdyDataFrame touch(Object hint) {
+        data.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         return data.release();
@@ -128,7 +140,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Size = ");
         if (refCnt() == 0) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java
index c4515f51ac24..86f4ecc1cc00 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java
@@ -56,7 +56,7 @@ public DefaultSpdyGoAwayFrame(int lastGoodStreamId, SpdySessionStatus status) {
     }
 
     @Override
-    public int getLastGoodStreamId() {
+    public int lastGoodStreamId() {
         return lastGoodStreamId;
     }
 
@@ -71,7 +71,7 @@ public SpdyGoAwayFrame setLastGoodStreamId(int lastGoodStreamId) {
     }
 
     @Override
-    public SpdySessionStatus getStatus() {
+    public SpdySessionStatus status() {
         return status;
     }
 
@@ -87,10 +87,10 @@ public String toString() {
         buf.append(StringUtil.simpleClassName(this));
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Last-good-stream-ID = ");
-        buf.append(getLastGoodStreamId());
+        buf.append(lastGoodStreamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Status: ");
-        buf.append(getStatus().toString());
+        buf.append(status());
         return buf.toString();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java
index 6367041163a2..a00aab55799c 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java
@@ -15,365 +15,101 @@
  */
 package io.netty.handler.codec.spdy;
 
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.NoSuchElementException;
-import java.util.Set;
-import java.util.TreeSet;
+import io.netty.handler.codec.AsciiString;
+import io.netty.handler.codec.DefaultTextHeaders;
+import io.netty.handler.codec.TextHeaderProcessor;
+import io.netty.handler.codec.TextHeaders;
 
+import java.util.Locale;
 
-public class DefaultSpdyHeaders extends SpdyHeaders {
 
-    private static final int BUCKET_SIZE = 17;
-
-    private static int hash(String name) {
-        int h = 0;
-        for (int i = name.length() - 1; i >= 0; i --) {
-            char c = name.charAt(i);
-            if (c >= 'A' && c <= 'Z') {
-                c += 32;
-            }
-            h = 31 * h + c;
-        }
-
-        if (h > 0) {
-            return h;
-        } else if (h == Integer.MIN_VALUE) {
-            return Integer.MAX_VALUE;
+public class DefaultSpdyHeaders extends DefaultTextHeaders implements SpdyHeaders {
+    @Override
+    protected CharSequence convertName(CharSequence name) {
+        name = super.convertName(name);
+        if (name instanceof AsciiString) {
+            name = ((AsciiString) name).toLowerCase();
         } else {
-            return -h;
+            name = name.toString().toLowerCase(Locale.US);
         }
+        SpdyCodecUtil.validateHeaderName(name);
+        return name;
     }
 
-    private static boolean eq(String name1, String name2) {
-        int nameLen = name1.length();
-        if (nameLen != name2.length()) {
-            return false;
+    @Override
+    protected CharSequence convertValue(Object value) {
+        if (value == null) {
+            throw new NullPointerException("value");
         }
 
-        for (int i = nameLen - 1; i >= 0; i --) {
-            char c1 = name1.charAt(i);
-            char c2 = name2.charAt(i);
-            if (c1 != c2) {
-                if (c1 >= 'A' && c1 <= 'Z') {
-                    c1 += 32;
-                }
-                if (c2 >= 'A' && c2 <= 'Z') {
-                    c2 += 32;
-                }
-                if (c1 != c2) {
-                    return false;
-                }
-            }
+        CharSequence seq;
+        if (value instanceof CharSequence) {
+            seq = (CharSequence) value;
+        } else {
+            seq = value.toString();
         }
-        return true;
-    }
-
-    private static int index(int hash) {
-        return hash % BUCKET_SIZE;
-    }
-
-    private final HeaderEntry[] entries = new HeaderEntry[BUCKET_SIZE];
-    private final HeaderEntry head = new HeaderEntry(-1, null, null);
 
-    DefaultSpdyHeaders() {
-        head.before = head.after = head;
+        SpdyCodecUtil.validateHeaderValue(seq);
+        return seq;
     }
 
     @Override
-    public SpdyHeaders add(final String name, final Object value) {
-        String lowerCaseName = name.toLowerCase();
-        SpdyCodecUtil.validateHeaderName(lowerCaseName);
-        String strVal = toString(value);
-        SpdyCodecUtil.validateHeaderValue(strVal);
-        int h = hash(lowerCaseName);
-        int i = index(h);
-        add0(h, i, lowerCaseName, strVal);
+    public SpdyHeaders add(CharSequence name, Object value) {
+        super.add(name, value);
         return this;
     }
 
-    private void add0(int h, int i, final String name, final String value) {
-        // Update the hash table.
-        HeaderEntry e = entries[i];
-        HeaderEntry newEntry;
-        entries[i] = newEntry = new HeaderEntry(h, name, value);
-        newEntry.next = e;
-
-        // Update the linked list.
-        newEntry.addBefore(head);
-    }
-
     @Override
-    public SpdyHeaders remove(final String name) {
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-        String lowerCaseName = name.toLowerCase();
-        int h = hash(lowerCaseName);
-        int i = index(h);
-        remove0(h, i, lowerCaseName);
+    public SpdyHeaders add(CharSequence name, Iterable<?> values) {
+        super.add(name, values);
         return this;
     }
 
-    private void remove0(int h, int i, String name) {
-        HeaderEntry e = entries[i];
-        if (e == null) {
-            return;
-        }
-
-        for (;;) {
-            if (e.hash == h && eq(name, e.key)) {
-                e.remove();
-                HeaderEntry next = e.next;
-                if (next != null) {
-                    entries[i] = next;
-                    e = next;
-                } else {
-                    entries[i] = null;
-                    return;
-                }
-            } else {
-                break;
-            }
-        }
-
-        for (;;) {
-            HeaderEntry next = e.next;
-            if (next == null) {
-                break;
-            }
-            if (next.hash == h && eq(name, next.key)) {
-                e.next = next.next;
-                next.remove();
-            } else {
-                e = next;
-            }
-        }
-    }
-
     @Override
-    public SpdyHeaders set(final String name, final Object value) {
-        String lowerCaseName = name.toLowerCase();
-        SpdyCodecUtil.validateHeaderName(lowerCaseName);
-        String strVal = toString(value);
-        SpdyCodecUtil.validateHeaderValue(strVal);
-        int h = hash(lowerCaseName);
-        int i = index(h);
-        remove0(h, i, lowerCaseName);
-        add0(h, i, lowerCaseName, strVal);
+    public SpdyHeaders add(CharSequence name, Object... values) {
+        super.add(name, values);
         return this;
     }
 
     @Override
-    public SpdyHeaders set(final String name, final Iterable<?> values) {
-        if (values == null) {
-            throw new NullPointerException("values");
-        }
-
-        String lowerCaseName = name.toLowerCase();
-        SpdyCodecUtil.validateHeaderName(lowerCaseName);
-
-        int h = hash(lowerCaseName);
-        int i = index(h);
-
-        remove0(h, i, lowerCaseName);
-        for (Object v: values) {
-            if (v == null) {
-                break;
-            }
-            String strVal = toString(v);
-            SpdyCodecUtil.validateHeaderValue(strVal);
-            add0(h, i, lowerCaseName, strVal);
-        }
+    public SpdyHeaders add(TextHeaders headers) {
+        super.add(headers);
         return this;
     }
 
     @Override
-    public SpdyHeaders clear() {
-        for (int i = 0; i < entries.length; i ++) {
-            entries[i] = null;
-        }
-        head.before = head.after = head;
+    public SpdyHeaders set(CharSequence name, Object value) {
+        super.set(name, value);
         return this;
     }
 
     @Override
-    public String get(final String name) {
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-
-        int h = hash(name);
-        int i = index(h);
-        HeaderEntry e = entries[i];
-        while (e != null) {
-            if (e.hash == h && eq(name, e.key)) {
-                return e.value;
-            }
-
-            e = e.next;
-        }
-        return null;
-    }
-
-    @Override
-    public List<String> getAll(final String name) {
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-
-        LinkedList<String> values = new LinkedList<String>();
-
-        int h = hash(name);
-        int i = index(h);
-        HeaderEntry e = entries[i];
-        while (e != null) {
-            if (e.hash == h && eq(name, e.key)) {
-                values.addFirst(e.value);
-            }
-            e = e.next;
-        }
-        return values;
-    }
-
-    @Override
-    public List<Map.Entry<String, String>> entries() {
-        List<Map.Entry<String, String>> all =
-                new LinkedList<Map.Entry<String, String>>();
-
-        HeaderEntry e = head.after;
-        while (e != head) {
-            all.add(e);
-            e = e.after;
-        }
-        return all;
-    }
-
-    @Override
-    public Iterator<Map.Entry<String, String>> iterator() {
-        return new HeaderIterator();
+    public SpdyHeaders set(CharSequence name, Object... values) {
+        super.set(name, values);
+        return this;
     }
 
     @Override
-    public boolean contains(String name) {
-        return get(name) != null;
+    public SpdyHeaders set(CharSequence name, Iterable<?> values) {
+        super.set(name, values);
+        return this;
     }
 
     @Override
-    public Set<String> names() {
-        Set<String> names = new TreeSet<String>();
-
-        HeaderEntry e = head.after;
-        while (e != head) {
-            names.add(e.key);
-            e = e.after;
-        }
-        return names;
+    public SpdyHeaders set(TextHeaders headers) {
+        super.set(headers);
+        return this;
     }
 
     @Override
-    public SpdyHeaders add(String name, Iterable<?> values) {
-        SpdyCodecUtil.validateHeaderValue(name);
-        int h = hash(name);
-        int i = index(h);
-        for (Object v: values) {
-            String vstr = toString(v);
-            SpdyCodecUtil.validateHeaderValue(vstr);
-            add0(h, i, name, vstr);
-        }
+    public SpdyHeaders clear() {
+        super.clear();
         return this;
     }
 
     @Override
-    public boolean isEmpty() {
-        return head == head.after;
-    }
-
-    private static String toString(Object value) {
-        if (value == null) {
-            return null;
-        }
-        return value.toString();
-    }
-
-    private final class HeaderIterator implements Iterator<Map.Entry<String, String>> {
-
-        private HeaderEntry current = head;
-
-        @Override
-        public boolean hasNext() {
-            return current.after != head;
-        }
-
-        @Override
-        public Entry<String, String> next() {
-            current = current.after;
-
-            if (current == head) {
-                throw new NoSuchElementException();
-            }
-
-            return current;
-        }
-
-        @Override
-        public void remove() {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    private static final class HeaderEntry implements Map.Entry<String, String> {
-        final int hash;
-        final String key;
-        String value;
-        HeaderEntry next;
-        HeaderEntry before, after;
-
-        HeaderEntry(int hash, String key, String value) {
-            this.hash = hash;
-            this.key = key;
-            this.value = value;
-        }
-
-        void remove() {
-            before.after = after;
-            after.before = before;
-        }
-
-        void addBefore(HeaderEntry e) {
-            after  = e;
-            before = e.before;
-            before.after = this;
-            after.before = this;
-        }
-
-        @Override
-        public String getKey() {
-            return key;
-        }
-
-        @Override
-        public String getValue() {
-            return value;
-        }
-
-        @Override
-        public String setValue(String value) {
-            if (value == null) {
-                throw new NullPointerException("value");
-            }
-            SpdyCodecUtil.validateHeaderValue(value);
-            String oldValue = this.value;
-            this.value = value;
-            return oldValue;
-        }
-
-        @Override
-        public String toString() {
-            return key + '=' + value;
-        }
+    public SpdyHeaders forEachEntry(TextHeaderProcessor processor) {
+        super.forEachEntry(processor);
+        return this;
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java
index e614c1807522..65c05ebdadb6 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java
@@ -86,7 +86,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Headers:");
         buf.append(StringUtil.NEWLINE);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java
index 667fa0ecccf5..2af2b72bdb91 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java
@@ -34,7 +34,7 @@ public DefaultSpdyPingFrame(int id) {
     }
 
     @Override
-    public int getId() {
+    public int id() {
         return id;
     }
 
@@ -50,7 +50,7 @@ public String toString() {
         buf.append(StringUtil.simpleClassName(this));
         buf.append(StringUtil.NEWLINE);
         buf.append("--> ID = ");
-        buf.append(getId());
+        buf.append(id());
         return buf.toString();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java
index ee58491743bd..a63f7db9daf5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java
@@ -59,7 +59,7 @@ public SpdyRstStreamFrame setLast(boolean last) {
     }
 
     @Override
-    public SpdyStreamStatus getStatus() {
+    public SpdyStreamStatus status() {
         return status;
     }
 
@@ -75,10 +75,10 @@ public String toString() {
         buf.append(StringUtil.simpleClassName(this));
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Status: ");
-        buf.append(getStatus().toString());
+        buf.append(status());
         return buf.toString();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
index 7a9b2072a5d0..c37e41cece75 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
@@ -30,7 +30,7 @@ public class DefaultSpdySettingsFrame implements SpdySettingsFrame {
     private final Map<Integer, Setting> settingsMap = new TreeMap<Integer, Setting>();
 
     @Override
-    public Set<Integer> getIds() {
+    public Set<Integer> ids() {
         return settingsMap.keySet();
     }
 
@@ -138,7 +138,7 @@ private void appendSettings(StringBuilder buf) {
         for (Map.Entry<Integer, Setting> e: getSettings()) {
             Setting setting = e.getValue();
             buf.append("--> ");
-            buf.append(e.getKey().toString());
+            buf.append(e.getKey());
             buf.append(':');
             buf.append(setting.getValue());
             buf.append(" (persist value: ");
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java
index 4d7608a5d117..4618d4d4a95c 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java
@@ -33,7 +33,7 @@ protected DefaultSpdyStreamFrame(int streamId) {
     }
 
     @Override
-    public int getStreamId() {
+    public int streamId() {
         return streamId;
     }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java
index 331c3e818ef5..b9fafab00819 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java
@@ -59,7 +59,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Headers:");
         buf.append(StringUtil.NEWLINE);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java
index ea97dc11e34c..5f012903d167 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java
@@ -23,21 +23,20 @@
 public class DefaultSpdySynStreamFrame extends DefaultSpdyHeadersFrame
         implements SpdySynStreamFrame {
 
-    private int associatedToStreamId;
+    private int associatedStreamId;
     private byte priority;
     private boolean unidirectional;
 
     /**
      * Creates a new instance.
      *
-     * @param streamId             the Stream-ID of this frame
-     * @param associatedToStreamId the Associated-To-Stream-ID of this frame
-     * @param priority             the priority of the stream
+     * @param streamId           the Stream-ID of this frame
+     * @param associatedStreamId the Associated-To-Stream-ID of this frame
+     * @param priority           the priority of the stream
      */
-    public DefaultSpdySynStreamFrame(
-            int streamId, int associatedToStreamId, byte priority) {
+    public DefaultSpdySynStreamFrame(int streamId, int associatedStreamId, byte priority) {
         super(streamId);
-        setAssociatedToStreamId(associatedToStreamId);
+        setAssociatedStreamId(associatedStreamId);
         setPriority(priority);
     }
 
@@ -60,23 +59,23 @@ public SpdySynStreamFrame setInvalid() {
     }
 
     @Override
-    public int getAssociatedToStreamId() {
-        return associatedToStreamId;
+    public int associatedStreamId() {
+        return associatedStreamId;
     }
 
     @Override
-    public SpdySynStreamFrame setAssociatedToStreamId(int associatedToStreamId) {
-        if (associatedToStreamId < 0) {
+    public SpdySynStreamFrame setAssociatedStreamId(int associatedStreamId) {
+        if (associatedStreamId < 0) {
             throw new IllegalArgumentException(
                     "Associated-To-Stream-ID cannot be negative: " +
-                    associatedToStreamId);
+                    associatedStreamId);
         }
-        this.associatedToStreamId = associatedToStreamId;
+        this.associatedStreamId = associatedStreamId;
         return this;
     }
 
     @Override
-    public byte getPriority() {
+    public byte priority() {
         return priority;
     }
 
@@ -112,15 +111,15 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
-        if (associatedToStreamId != 0) {
+        if (associatedStreamId != 0) {
             buf.append("--> Associated-To-Stream-ID = ");
-            buf.append(getAssociatedToStreamId());
+            buf.append(associatedStreamId());
             buf.append(StringUtil.NEWLINE);
         }
         buf.append("--> Priority = ");
-        buf.append(getPriority());
+        buf.append(priority());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Headers:");
         buf.append(StringUtil.NEWLINE);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java
index 08833a5f63d8..1f30aa4e0569 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java
@@ -37,7 +37,7 @@ public DefaultSpdyWindowUpdateFrame(int streamId, int deltaWindowSize) {
     }
 
     @Override
-    public int getStreamId() {
+    public int streamId() {
         return streamId;
     }
 
@@ -52,7 +52,7 @@ public SpdyWindowUpdateFrame setStreamId(int streamId) {
     }
 
     @Override
-    public int getDeltaWindowSize() {
+    public int deltaWindowSize() {
         return deltaWindowSize;
     }
 
@@ -73,10 +73,10 @@ public String toString() {
         buf.append(StringUtil.simpleClassName(this));
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(getStreamId());
+        buf.append(streamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Delta-Window-Size = ");
-        buf.append(getDeltaWindowSize());
+        buf.append(deltaWindowSize());
         return buf.toString();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java
index 41c64d2a8d9b..612ebdbcb26a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.util.CharsetUtil;
 
 final class SpdyCodecUtil {
 
@@ -286,11 +285,11 @@ static boolean isServerId(int id) {
     /**
      * Validate a SPDY header name.
      */
-    static void validateHeaderName(String name) {
+    static void validateHeaderName(CharSequence name) {
         if (name == null) {
             throw new NullPointerException("name");
         }
-        if (name.isEmpty()) {
+        if (name.length() == 0) {
             throw new IllegalArgumentException(
                     "name cannot be length zero");
         }
@@ -316,7 +315,7 @@ static void validateHeaderName(String name) {
     /**
      * Validate a SPDY header value. Does not validate max length.
      */
-    static void validateHeaderValue(String value) {
+    static void validateHeaderValue(CharSequence value) {
         if (value == null) {
             throw new NullPointerException("value");
         }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
index bb561589f73f..e37d655a0dc8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
@@ -50,4 +50,10 @@ public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame {
 
     @Override
     SpdyDataFrame retain(int increment);
+
+    @Override
+    SpdyDataFrame touch();
+
+    @Override
+    SpdyDataFrame touch(Object hint);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
index e0b40bd9a4aa..936432e1cf4c 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -15,12 +15,38 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.channel.CombinedChannelDuplexHandler;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOutboundHandler;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.handler.codec.UnsupportedMessageTypeException;
+
+import java.net.SocketAddress;
+import java.util.List;
 
 /**
- * A combination of {@link SpdyFrameDecoder} and {@link SpdyFrameEncoder}.
+ * A {@link ChannelHandler} that encodes and decodes SPDY Frames.
  */
-public final class SpdyFrameCodec extends CombinedChannelDuplexHandler<SpdyFrameDecoder, SpdyFrameEncoder> {
+public class SpdyFrameCodec extends ByteToMessageDecoder
+        implements SpdyFrameDecoderDelegate, ChannelOutboundHandler {
+
+    private static final SpdyProtocolException INVALID_FRAME =
+            new SpdyProtocolException("Received invalid frame");
+
+    private final SpdyFrameDecoder spdyFrameDecoder;
+    private final SpdyFrameEncoder spdyFrameEncoder;
+    private final SpdyHeaderBlockDecoder spdyHeaderBlockDecoder;
+    private final SpdyHeaderBlockEncoder spdyHeaderBlockEncoder;
+
+    private SpdyHeadersFrame spdyHeadersFrame;
+    private SpdySettingsFrame spdySettingsFrame;
+
+    private ChannelHandlerContext ctx;
+
     /**
      * Creates a new instance with the specified {@code version} and
      * the default decoder and encoder options
@@ -38,8 +64,291 @@ public SpdyFrameCodec(SpdyVersion version) {
     public SpdyFrameCodec(
             SpdyVersion version, int maxChunkSize, int maxHeaderSize,
             int compressionLevel, int windowBits, int memLevel) {
-        super(
-                new SpdyFrameDecoder(version, maxChunkSize, maxHeaderSize),
-                new SpdyFrameEncoder(version, compressionLevel, windowBits, memLevel));
+        this(version, maxChunkSize,
+                SpdyHeaderBlockDecoder.newInstance(version, maxHeaderSize),
+                SpdyHeaderBlockEncoder.newInstance(version, compressionLevel, windowBits, memLevel));
+    }
+
+    protected SpdyFrameCodec(SpdyVersion version, int maxChunkSize,
+            SpdyHeaderBlockDecoder spdyHeaderBlockDecoder, SpdyHeaderBlockEncoder spdyHeaderBlockEncoder) {
+        spdyFrameDecoder = new SpdyFrameDecoder(version, this, maxChunkSize);
+        spdyFrameEncoder = new SpdyFrameEncoder(version);
+        this.spdyHeaderBlockDecoder = spdyHeaderBlockDecoder;
+        this.spdyHeaderBlockEncoder = spdyHeaderBlockEncoder;
+    }
+
+    @Override
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+        super.handlerAdded(ctx);
+        this.ctx = ctx;
+        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {
+            @Override
+            public void operationComplete(ChannelFuture future) throws Exception {
+                spdyHeaderBlockDecoder.end();
+                spdyHeaderBlockEncoder.end();
+            }
+        });
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        spdyFrameDecoder.decode(in);
+    }
+
+    @Override
+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {
+        ctx.bind(localAddress, promise);
+    }
+
+    @Override
+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress,
+                        ChannelPromise promise) throws Exception {
+        ctx.connect(remoteAddress, localAddress, promise);
+    }
+
+    @Override
+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+        ctx.disconnect(promise);
+    }
+
+    @Override
+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+        ctx.close(promise);
+    }
+
+    @Override
+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+        ctx.deregister(promise);
+    }
+
+    @Override
+    public void read(ChannelHandlerContext ctx) throws Exception {
+        ctx.read();
+    }
+
+    @Override
+    public void flush(ChannelHandlerContext ctx) throws Exception {
+        ctx.flush();
+    }
+
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+        ByteBuf frame;
+
+        if (msg instanceof SpdyDataFrame) {
+
+            SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
+            frame = spdyFrameEncoder.encodeDataFrame(
+                    ctx.alloc(),
+                    spdyDataFrame.streamId(),
+                    spdyDataFrame.isLast(),
+                    spdyDataFrame.content()
+            );
+            spdyDataFrame.release();
+            ctx.write(frame, promise);
+
+        } else if (msg instanceof SpdySynStreamFrame) {
+
+            SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
+            ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(spdySynStreamFrame);
+            try {
+                frame = spdyFrameEncoder.encodeSynStreamFrame(
+                        ctx.alloc(),
+                        spdySynStreamFrame.streamId(),
+                        spdySynStreamFrame.associatedStreamId(),
+                        spdySynStreamFrame.priority(),
+                        spdySynStreamFrame.isLast(),
+                        spdySynStreamFrame.isUnidirectional(),
+                        headerBlock
+                );
+            } finally {
+                headerBlock.release();
+            }
+            ctx.write(frame, promise);
+
+        } else if (msg instanceof SpdySynReplyFrame) {
+
+            SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
+            ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(spdySynReplyFrame);
+            try {
+                frame = spdyFrameEncoder.encodeSynReplyFrame(
+                        ctx.alloc(),
+                        spdySynReplyFrame.streamId(),
+                        spdySynReplyFrame.isLast(),
+                        headerBlock
+                );
+            } finally {
+                headerBlock.release();
+            }
+            ctx.write(frame, promise);
+
+        } else if (msg instanceof SpdyRstStreamFrame) {
+
+            SpdyRstStreamFrame spdyRstStreamFrame = (SpdyRstStreamFrame) msg;
+            frame = spdyFrameEncoder.encodeRstStreamFrame(
+                    ctx.alloc(),
+                    spdyRstStreamFrame.streamId(),
+                    spdyRstStreamFrame.status().code()
+            );
+            ctx.write(frame, promise);
+
+        } else if (msg instanceof SpdySettingsFrame) {
+
+            SpdySettingsFrame spdySettingsFrame = (SpdySettingsFrame) msg;
+            frame = spdyFrameEncoder.encodeSettingsFrame(
+                    ctx.alloc(),
+                    spdySettingsFrame
+            );
+            ctx.write(frame, promise);
+
+        } else if (msg instanceof SpdyPingFrame) {
+
+            SpdyPingFrame spdyPingFrame = (SpdyPingFrame) msg;
+            frame = spdyFrameEncoder.encodePingFrame(
+                    ctx.alloc(),
+                    spdyPingFrame.id()
+            );
+            ctx.write(frame, promise);
+
+        } else if (msg instanceof SpdyGoAwayFrame) {
+
+            SpdyGoAwayFrame spdyGoAwayFrame = (SpdyGoAwayFrame) msg;
+            frame = spdyFrameEncoder.encodeGoAwayFrame(
+                    ctx.alloc(),
+                    spdyGoAwayFrame.lastGoodStreamId(),
+                    spdyGoAwayFrame.status().code()
+            );
+            ctx.write(frame, promise);
+
+        } else if (msg instanceof SpdyHeadersFrame) {
+
+            SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
+            ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(spdyHeadersFrame);
+            try {
+                frame = spdyFrameEncoder.encodeHeadersFrame(
+                        ctx.alloc(),
+                        spdyHeadersFrame.streamId(),
+                        spdyHeadersFrame.isLast(),
+                        headerBlock
+                );
+            } finally {
+                headerBlock.release();
+            }
+            ctx.write(frame, promise);
+
+        } else if (msg instanceof SpdyWindowUpdateFrame) {
+
+            SpdyWindowUpdateFrame spdyWindowUpdateFrame = (SpdyWindowUpdateFrame) msg;
+            frame = spdyFrameEncoder.encodeWindowUpdateFrame(
+                    ctx.alloc(),
+                    spdyWindowUpdateFrame.streamId(),
+                    spdyWindowUpdateFrame.deltaWindowSize()
+            );
+            ctx.write(frame, promise);
+        } else {
+            throw new UnsupportedMessageTypeException(msg);
+        }
+    }
+
+    @Override
+    public void readDataFrame(int streamId, boolean last, ByteBuf data) {
+        SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(streamId, data);
+        spdyDataFrame.setLast(last);
+        ctx.fireChannelRead(spdyDataFrame);
+    }
+
+    @Override
+    public void readSynStreamFrame(
+            int streamId, int associatedToStreamId, byte priority, boolean last, boolean unidirectional) {
+        SpdySynStreamFrame spdySynStreamFrame = new DefaultSpdySynStreamFrame(streamId, associatedToStreamId, priority);
+        spdySynStreamFrame.setLast(last);
+        spdySynStreamFrame.setUnidirectional(unidirectional);
+        spdyHeadersFrame = spdySynStreamFrame;
+    }
+
+    @Override
+    public void readSynReplyFrame(int streamId, boolean last) {
+        SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);
+        spdySynReplyFrame.setLast(last);
+        spdyHeadersFrame = spdySynReplyFrame;
+    }
+
+    @Override
+    public void readRstStreamFrame(int streamId, int statusCode) {
+        SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame(streamId, statusCode);
+        ctx.fireChannelRead(spdyRstStreamFrame);
+    }
+
+    @Override
+    public void readSettingsFrame(boolean clearPersisted) {
+        spdySettingsFrame = new DefaultSpdySettingsFrame();
+        spdySettingsFrame.setClearPreviouslyPersistedSettings(clearPersisted);
+    }
+
+    @Override
+    public void readSetting(int id, int value, boolean persistValue, boolean persisted) {
+        spdySettingsFrame.setValue(id, value, persistValue, persisted);
+    }
+
+    @Override
+    public void readSettingsEnd() {
+        Object frame = spdySettingsFrame;
+        spdySettingsFrame = null;
+        ctx.fireChannelRead(frame);
+    }
+
+    @Override
+    public void readPingFrame(int id) {
+        SpdyPingFrame spdyPingFrame = new DefaultSpdyPingFrame(id);
+        ctx.fireChannelRead(spdyPingFrame);
+    }
+
+    @Override
+    public void readGoAwayFrame(int lastGoodStreamId, int statusCode) {
+        SpdyGoAwayFrame spdyGoAwayFrame = new DefaultSpdyGoAwayFrame(lastGoodStreamId, statusCode);
+        ctx.fireChannelRead(spdyGoAwayFrame);
+    }
+
+    @Override
+    public void readHeadersFrame(int streamId, boolean last) {
+        spdyHeadersFrame = new DefaultSpdyHeadersFrame(streamId);
+        spdyHeadersFrame.setLast(last);
+    }
+
+    @Override
+    public void readWindowUpdateFrame(int streamId, int deltaWindowSize) {
+        SpdyWindowUpdateFrame spdyWindowUpdateFrame = new DefaultSpdyWindowUpdateFrame(streamId, deltaWindowSize);
+        ctx.fireChannelRead(spdyWindowUpdateFrame);
+    }
+
+    @Override
+    public void readHeaderBlock(ByteBuf headerBlock) {
+        try {
+            spdyHeaderBlockDecoder.decode(headerBlock, spdyHeadersFrame);
+        } catch (Exception e) {
+            ctx.fireExceptionCaught(e);
+        } finally {
+            headerBlock.release();
+        }
+    }
+
+    @Override
+    public void readHeaderBlockEnd() {
+        Object frame = null;
+        try {
+            spdyHeaderBlockDecoder.endHeaderBlock(spdyHeadersFrame);
+            frame = spdyHeadersFrame;
+            spdyHeadersFrame = null;
+        } catch (Exception e) {
+            ctx.fireExceptionCaught(e);
+        }
+        if (frame != null) {
+            ctx.fireChannelRead(frame);
+        }
+    }
+
+    @Override
+    public void readFrameError(String message) {
+        ctx.fireExceptionCaught(INVALID_FRAME);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
index c44fc277ee26..e0d1112813b7 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -39,511 +39,427 @@
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.getUnsignedMedium;
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.getUnsignedShort;
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.ByteToMessageDecoder;
-
-import java.util.List;
+import io.netty.buffer.Unpooled;
 
 /**
  * Decodes {@link ByteBuf}s into SPDY Frames.
  */
-public class SpdyFrameDecoder extends ByteToMessageDecoder {
-
-    private static final SpdyProtocolException INVALID_FRAME =
-            new SpdyProtocolException("Received invalid frame");
+public class SpdyFrameDecoder {
 
     private final int spdyVersion;
     private final int maxChunkSize;
 
-    private final SpdyHeaderBlockDecoder headerBlockDecoder;
+    private final SpdyFrameDecoderDelegate delegate;
 
     private State state;
-    private SpdySettingsFrame spdySettingsFrame;
-    private SpdyHeadersFrame spdyHeadersFrame;
 
     // SPDY common header fields
     private byte flags;
     private int length;
-    private int version;
-    private int type;
     private int streamId;
 
+    private int numSettings;
+
     private enum State {
         READ_COMMON_HEADER,
-        READ_CONTROL_FRAME,
+        READ_DATA_FRAME,
+        READ_SYN_STREAM_FRAME,
+        READ_SYN_REPLY_FRAME,
+        READ_RST_STREAM_FRAME,
         READ_SETTINGS_FRAME,
-        READ_HEADER_BLOCK_FRAME,
+        READ_SETTING,
+        READ_PING_FRAME,
+        READ_GOAWAY_FRAME,
+        READ_HEADERS_FRAME,
+        READ_WINDOW_UPDATE_FRAME,
         READ_HEADER_BLOCK,
-        READ_DATA_FRAME,
         DISCARD_FRAME,
         FRAME_ERROR
     }
 
     /**
-     * Creates a new instance with the specified {@code version} and the default
-     * {@code maxChunkSize (8192)} and {@code maxHeaderSize (16384)}.
+     * Creates a new instance with the specified {@code version}
+     * and the default {@code maxChunkSize (8192)}.
      */
-    public SpdyFrameDecoder(SpdyVersion version) {
-        this(version, 8192, 16384);
+    public SpdyFrameDecoder(SpdyVersion spdyVersion, SpdyFrameDecoderDelegate delegate) {
+        this(spdyVersion, delegate, 8192);
     }
 
     /**
      * Creates a new instance with the specified parameters.
      */
-    public SpdyFrameDecoder(SpdyVersion version, int maxChunkSize, int maxHeaderSize) {
-        this(version, maxChunkSize, SpdyHeaderBlockDecoder.newInstance(version, maxHeaderSize));
-    }
-
-    protected SpdyFrameDecoder(
-            SpdyVersion version, int maxChunkSize, SpdyHeaderBlockDecoder headerBlockDecoder) {
-        if (version == null) {
-            throw new NullPointerException("version");
+    public SpdyFrameDecoder(SpdyVersion spdyVersion, SpdyFrameDecoderDelegate delegate, int maxChunkSize) {
+        if (spdyVersion == null) {
+            throw new NullPointerException("spdyVersion");
+        }
+        if (delegate == null) {
+            throw new NullPointerException("delegate");
         }
         if (maxChunkSize <= 0) {
             throw new IllegalArgumentException(
                     "maxChunkSize must be a positive integer: " + maxChunkSize);
         }
-        spdyVersion = version.getVersion();
+        this.spdyVersion = spdyVersion.getVersion();
+        this.delegate = delegate;
         this.maxChunkSize = maxChunkSize;
-        this.headerBlockDecoder = headerBlockDecoder;
         state = State.READ_COMMON_HEADER;
     }
 
-    @Override
-    public void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
-        try {
-            decode(ctx, in, out);
-        } finally {
-            headerBlockDecoder.end();
-        }
-    }
-
-    @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {
-        switch(state) {
-        case READ_COMMON_HEADER:
-            state = readCommonHeader(buffer);
-            if (state == State.FRAME_ERROR) {
-                if (version != spdyVersion) {
-                    fireProtocolException(ctx, "Unsupported version: " + version);
-                } else {
-                    fireInvalidFrameException(ctx);
-                }
-            }
-
-            // FrameDecoders must consume data when producing frames
-            // All length 0 frames must be generated now
-            if (length == 0) {
-                if (state == State.READ_DATA_FRAME) {
-                    SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(streamId);
-                    spdyDataFrame.setLast((flags & SPDY_DATA_FLAG_FIN) != 0);
-                    state = State.READ_COMMON_HEADER;
-                    out.add(spdyDataFrame);
-                    return;
-                }
-                // There are no length 0 control frames
-                state = State.READ_COMMON_HEADER;
-            }
+    public void decode(ByteBuf buffer) {
+        boolean last;
+        int statusCode;
 
-            return;
+        while (true) {
+            switch(state) {
+                case READ_COMMON_HEADER:
+                    if (buffer.readableBytes() < SPDY_HEADER_SIZE) {
+                        return;
+                    }
 
-        case READ_CONTROL_FRAME:
-            try {
-                Object frame = readControlFrame(buffer);
-                if (frame != null) {
-                    state = State.READ_COMMON_HEADER;
-                    out.add(frame);
-                }
-                return;
-            } catch (IllegalArgumentException e) {
-                state = State.FRAME_ERROR;
-                fireInvalidFrameException(ctx);
-            }
-            return;
+                    int frameOffset  = buffer.readerIndex();
+                    int flagsOffset  = frameOffset + SPDY_HEADER_FLAGS_OFFSET;
+                    int lengthOffset = frameOffset + SPDY_HEADER_LENGTH_OFFSET;
+                    buffer.skipBytes(SPDY_HEADER_SIZE);
+
+                    boolean control = (buffer.getByte(frameOffset) & 0x80) != 0;
+
+                    int version;
+                    int type;
+                    if (control) {
+                        // Decode control frame common header
+                        version = getUnsignedShort(buffer, frameOffset) & 0x7FFF;
+                        type = getUnsignedShort(buffer, frameOffset + SPDY_HEADER_TYPE_OFFSET);
+                        streamId = 0; // Default to session Stream-ID
+                    } else {
+                        // Decode data frame common header
+                        version = spdyVersion; // Default to expected version
+                        type = SPDY_DATA_FRAME;
+                        streamId = getUnsignedInt(buffer, frameOffset);
+                    }
 
-        case READ_SETTINGS_FRAME:
-            if (spdySettingsFrame == null) {
-                // Validate frame length against number of entries
-                if (buffer.readableBytes() < 4) {
-                    return;
-                }
-                int numEntries = getUnsignedInt(buffer, buffer.readerIndex());
-                buffer.skipBytes(4);
-                length -= 4;
-
-                // Each ID/Value entry is 8 bytes
-                if ((length & 0x07) != 0 || length >> 3 != numEntries) {
-                    state = State.FRAME_ERROR;
-                    fireInvalidFrameException(ctx);
-                    return;
-                }
+                    flags  = buffer.getByte(flagsOffset);
+                    length = getUnsignedMedium(buffer, lengthOffset);
+
+                    // Check version first then validity
+                    if (version != spdyVersion) {
+                        state = State.FRAME_ERROR;
+                        delegate.readFrameError("Invalid SPDY Version");
+                    } else if (!isValidFrameHeader(streamId, type, flags, length)) {
+                        state = State.FRAME_ERROR;
+                        delegate.readFrameError("Invalid Frame Error");
+                    } else {
+                        state = getNextState(type, length);
+                    }
+                    break;
 
-                spdySettingsFrame = new DefaultSpdySettingsFrame();
+                case READ_DATA_FRAME:
+                    if (length == 0) {
+                        state = State.READ_COMMON_HEADER;
+                        delegate.readDataFrame(streamId, hasFlag(flags, SPDY_DATA_FLAG_FIN), Unpooled.buffer(0));
+                        break;
+                    }
 
-                boolean clear = (flags & SPDY_SETTINGS_CLEAR) != 0;
-                spdySettingsFrame.setClearPreviouslyPersistedSettings(clear);
-            }
+                    // Generate data frames that do not exceed maxChunkSize
+                    int dataLength = Math.min(maxChunkSize, length);
 
-            int readableEntries = Math.min(buffer.readableBytes() >> 3, length >> 3);
-            for (int i = 0; i < readableEntries; i ++) {
-                byte ID_flags = buffer.getByte(buffer.readerIndex());
-                int ID = getUnsignedMedium(buffer, buffer.readerIndex() + 1);
-                int value = getSignedInt(buffer, buffer.readerIndex() + 4);
-                buffer.skipBytes(8);
-
-                if (!spdySettingsFrame.isSet(ID)) {
-                    boolean persistVal = (ID_flags & SPDY_SETTINGS_PERSIST_VALUE) != 0;
-                    boolean persisted  = (ID_flags & SPDY_SETTINGS_PERSISTED) != 0;
-                    spdySettingsFrame.setValue(ID, value, persistVal, persisted);
-                }
-            }
+                    // Wait until entire frame is readable
+                    if (buffer.readableBytes() < dataLength) {
+                        return;
+                    }
 
-            length -= 8 * readableEntries;
-            if (length == 0) {
-                state = State.READ_COMMON_HEADER;
-                Object frame = spdySettingsFrame;
-                spdySettingsFrame = null;
-                out.add(frame);
-                return;
-            }
-            return;
+                    ByteBuf data = buffer.alloc().buffer(dataLength);
+                    data.writeBytes(buffer, dataLength);
+                    length -= dataLength;
 
-        case READ_HEADER_BLOCK_FRAME:
-            try {
-                spdyHeadersFrame = readHeaderBlockFrame(buffer);
-                if (spdyHeadersFrame != null) {
                     if (length == 0) {
                         state = State.READ_COMMON_HEADER;
-                        Object frame = spdyHeadersFrame;
-                        spdyHeadersFrame = null;
-                        out.add(frame);
+                    }
+
+                    last = length == 0 && hasFlag(flags, SPDY_DATA_FLAG_FIN);
+
+                    delegate.readDataFrame(streamId, last, data);
+                    break;
+
+                case READ_SYN_STREAM_FRAME:
+                    if (buffer.readableBytes() < 10) {
                         return;
                     }
-                    state = State.READ_HEADER_BLOCK;
-                }
-                return;
-            } catch (IllegalArgumentException e) {
-                state = State.FRAME_ERROR;
-                fireInvalidFrameException(ctx);
-                return;
-            }
 
-        case READ_HEADER_BLOCK:
-            int compressedBytes = Math.min(buffer.readableBytes(), length);
-            ByteBuf compressed = buffer.slice(buffer.readerIndex(), compressedBytes);
-
-            try {
-                headerBlockDecoder.decode(compressed, spdyHeadersFrame);
-            } catch (Exception e) {
-                state = State.FRAME_ERROR;
-                spdyHeadersFrame = null;
-                ctx.fireExceptionCaught(e);
-                return;
-            }
+                    int offset = buffer.readerIndex();
+                    streamId = getUnsignedInt(buffer, offset);
+                    int associatedToStreamId = getUnsignedInt(buffer, offset + 4);
+                    byte priority = (byte) (buffer.getByte(offset + 8) >> 5 & 0x07);
+                    last = hasFlag(flags, SPDY_FLAG_FIN);
+                    boolean unidirectional = hasFlag(flags, SPDY_FLAG_UNIDIRECTIONAL);
+                    buffer.skipBytes(10);
+                    length -= 10;
+
+                    if (streamId == 0) {
+                        state = State.FRAME_ERROR;
+                        delegate.readFrameError("Invalid SYN_STREAM Frame");
+                    } else {
+                        state = State.READ_HEADER_BLOCK;
+                        delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, last, unidirectional);
+                    }
+                    break;
 
-            int readBytes = compressedBytes - compressed.readableBytes();
-            buffer.skipBytes(readBytes);
-            length -= readBytes;
+                case READ_SYN_REPLY_FRAME:
+                    if (buffer.readableBytes() < 4) {
+                        return;
+                    }
 
-            if (spdyHeadersFrame != null &&
-                    (spdyHeadersFrame.isInvalid() || spdyHeadersFrame.isTruncated())) {
+                    streamId = getUnsignedInt(buffer, buffer.readerIndex());
+                    last = hasFlag(flags, SPDY_FLAG_FIN);
 
-                Object frame = spdyHeadersFrame;
-                spdyHeadersFrame = null;
-                if (length == 0) {
-                    headerBlockDecoder.reset();
-                    state = State.READ_COMMON_HEADER;
-                }
-                out.add(frame);
-                return;
-            }
+                    buffer.skipBytes(4);
+                    length -= 4;
 
-            if (length == 0) {
-                Object frame = spdyHeadersFrame;
-                spdyHeadersFrame = null;
-                headerBlockDecoder.reset();
-                state = State.READ_COMMON_HEADER;
-                if (frame != null) {
-                    out.add(frame);
-                }
-            }
-            return;
+                    if (streamId == 0) {
+                        state = State.FRAME_ERROR;
+                        delegate.readFrameError("Invalid SYN_REPLY Frame");
+                    } else {
+                        state = State.READ_HEADER_BLOCK;
+                        delegate.readSynReplyFrame(streamId, last);
+                    }
+                    break;
 
-        case READ_DATA_FRAME:
-            if (streamId == 0) {
-                state = State.FRAME_ERROR;
-                fireProtocolException(ctx, "Received invalid data frame");
-                return;
-            }
+                case READ_RST_STREAM_FRAME:
+                    if (buffer.readableBytes() < 8) {
+                        return;
+                    }
 
-            // Generate data frames that do not exceed maxChunkSize
-            int dataLength = Math.min(maxChunkSize, length);
+                    streamId = getUnsignedInt(buffer, buffer.readerIndex());
+                    statusCode = getSignedInt(buffer, buffer.readerIndex() + 4);
+                    buffer.skipBytes(8);
 
-            // Wait until entire frame is readable
-            if (buffer.readableBytes() < dataLength) {
-                return;
-            }
+                    if (streamId == 0 || statusCode == 0) {
+                        state = State.FRAME_ERROR;
+                        delegate.readFrameError("Invalid RST_STREAM Frame");
+                    } else {
+                        state = State.READ_COMMON_HEADER;
+                        delegate.readRstStreamFrame(streamId, statusCode);
+                    }
+                    break;
 
-            ByteBuf data = ctx.alloc().buffer(dataLength);
-            data.writeBytes(buffer, dataLength);
-            SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(streamId, data);
-            length -= dataLength;
+                case READ_SETTINGS_FRAME:
+                    if (buffer.readableBytes() < 4) {
+                        return;
+                    }
 
-            if (length == 0) {
-                spdyDataFrame.setLast((flags & SPDY_DATA_FLAG_FIN) != 0);
-                state = State.READ_COMMON_HEADER;
-            }
-            out.add(spdyDataFrame);
-            return;
-
-        case DISCARD_FRAME:
-            int numBytes = Math.min(buffer.readableBytes(), length);
-            buffer.skipBytes(numBytes);
-            length -= numBytes;
-            if (length == 0) {
-                state = State.READ_COMMON_HEADER;
-            }
-            return;
+                    boolean clear = hasFlag(flags, SPDY_SETTINGS_CLEAR);
 
-        case FRAME_ERROR:
-            buffer.skipBytes(buffer.readableBytes());
-            return;
+                    numSettings = getUnsignedInt(buffer, buffer.readerIndex());
+                    buffer.skipBytes(4);
+                    length -= 4;
 
-        default:
-            throw new Error("Shouldn't reach here.");
-        }
-    }
+                    // Validate frame length against number of entries. Each ID/Value entry is 8 bytes.
+                    if ((length & 0x07) != 0 || length >> 3 != numSettings) {
+                        state = State.FRAME_ERROR;
+                        delegate.readFrameError("Invalid SETTINGS Frame");
+                    } else {
+                        state = State.READ_SETTING;
+                        delegate.readSettingsFrame(clear);
+                    }
+                    break;
 
-    private State readCommonHeader(ByteBuf buffer) {
-        // Wait until entire header is readable
-        if (buffer.readableBytes() < SPDY_HEADER_SIZE) {
-            return State.READ_COMMON_HEADER;
-        }
+                case READ_SETTING:
+                    if (numSettings == 0) {
+                        state = State.READ_COMMON_HEADER;
+                        delegate.readSettingsEnd();
+                        break;
+                    }
 
-        int frameOffset  = buffer.readerIndex();
-        int flagsOffset  = frameOffset + SPDY_HEADER_FLAGS_OFFSET;
-        int lengthOffset = frameOffset + SPDY_HEADER_LENGTH_OFFSET;
-        buffer.skipBytes(SPDY_HEADER_SIZE);
+                    if (buffer.readableBytes() < 8) {
+                        return;
+                    }
 
-        // Read common header fields
-        boolean control = (buffer.getByte(frameOffset) & 0x80) != 0;
-        flags  = buffer.getByte(flagsOffset);
-        length = getUnsignedMedium(buffer, lengthOffset);
+                    byte settingsFlags = buffer.getByte(buffer.readerIndex());
+                    int id = getUnsignedMedium(buffer, buffer.readerIndex() + 1);
+                    int value = getSignedInt(buffer, buffer.readerIndex() + 4);
+                    boolean persistValue = hasFlag(settingsFlags, SPDY_SETTINGS_PERSIST_VALUE);
+                    boolean persisted = hasFlag(settingsFlags, SPDY_SETTINGS_PERSISTED);
+                    buffer.skipBytes(8);
 
-        if (control) {
-            // Decode control frame common header
-            version = getUnsignedShort(buffer, frameOffset) & 0x7FFF;
+                    --numSettings;
 
-            int typeOffset = frameOffset + SPDY_HEADER_TYPE_OFFSET;
-            type = getUnsignedShort(buffer, typeOffset);
+                    delegate.readSetting(id, value, persistValue, persisted);
+                    break;
 
-            streamId = 0;
-        } else {
-            // Decode data frame common header
-            version = spdyVersion; // Default to expected version
+                case READ_PING_FRAME:
+                    if (buffer.readableBytes() < 4) {
+                        return;
+                    }
 
-            type = SPDY_DATA_FRAME;
+                    int pingId = getSignedInt(buffer, buffer.readerIndex());
+                    buffer.skipBytes(4);
 
-            streamId = getUnsignedInt(buffer, frameOffset);
-        }
-        // Check version first then validity
-        if (version != spdyVersion || !isValidFrameHeader()) {
-            return State.FRAME_ERROR;
-        }
+                    state = State.READ_COMMON_HEADER;
+                    delegate.readPingFrame(pingId);
+                    break;
 
-        // Make sure decoder will produce a frame or consume input
-        State nextState;
-        if (willGenerateFrame()) {
-            switch (type) {
-            case SPDY_DATA_FRAME:
-                nextState = State.READ_DATA_FRAME;
-                break;
+                case READ_GOAWAY_FRAME:
+                    if (buffer.readableBytes() < 8) {
+                        return;
+                    }
 
-            case SPDY_SYN_STREAM_FRAME:
-            case SPDY_SYN_REPLY_FRAME:
-            case SPDY_HEADERS_FRAME:
-                nextState = State.READ_HEADER_BLOCK_FRAME;
-                break;
+                    int lastGoodStreamId = getUnsignedInt(buffer, buffer.readerIndex());
+                    statusCode = getSignedInt(buffer, buffer.readerIndex() + 4);
+                    buffer.skipBytes(8);
 
-            case SPDY_SETTINGS_FRAME:
-                nextState = State.READ_SETTINGS_FRAME;
-                break;
+                    state = State.READ_COMMON_HEADER;
+                    delegate.readGoAwayFrame(lastGoodStreamId, statusCode);
+                    break;
 
-            default:
-                nextState = State.READ_CONTROL_FRAME;
-            }
-        } else if (length != 0) {
-            nextState = State.DISCARD_FRAME;
-        } else {
-            nextState = State.READ_COMMON_HEADER;
-        }
-        return nextState;
-    }
+                case READ_HEADERS_FRAME:
+                    if (buffer.readableBytes() < 4) {
+                        return;
+                    }
 
-    private Object readControlFrame(ByteBuf buffer) {
-        int streamId;
-        int statusCode;
-        switch (type) {
-        case SPDY_RST_STREAM_FRAME:
-            if (buffer.readableBytes() < 8) {
-                return null;
-            }
+                    streamId = getUnsignedInt(buffer, buffer.readerIndex());
+                    last = hasFlag(flags, SPDY_FLAG_FIN);
 
-            streamId = getUnsignedInt(buffer, buffer.readerIndex());
-            statusCode = getSignedInt(buffer, buffer.readerIndex() + 4);
-            buffer.skipBytes(8);
+                    buffer.skipBytes(4);
+                    length -= 4;
 
-            return new DefaultSpdyRstStreamFrame(streamId, statusCode);
+                    if (streamId == 0) {
+                        state = State.FRAME_ERROR;
+                        delegate.readFrameError("Invalid HEADERS Frame");
+                    } else {
+                        state = State.READ_HEADER_BLOCK;
+                        delegate.readHeadersFrame(streamId, last);
+                    }
+                    break;
 
-        case SPDY_PING_FRAME:
-            if (buffer.readableBytes() < 4) {
-                return null;
-            }
+                case READ_WINDOW_UPDATE_FRAME:
+                    if (buffer.readableBytes() < 8) {
+                        return;
+                    }
 
-            int ID = getSignedInt(buffer, buffer.readerIndex());
-            buffer.skipBytes(4);
+                    streamId = getUnsignedInt(buffer, buffer.readerIndex());
+                    int deltaWindowSize = getUnsignedInt(buffer, buffer.readerIndex() + 4);
+                    buffer.skipBytes(8);
 
-            return new DefaultSpdyPingFrame(ID);
+                    if (deltaWindowSize == 0) {
+                        state = State.FRAME_ERROR;
+                        delegate.readFrameError("Invalid WINDOW_UPDATE Frame");
+                    } else {
+                        state = State.READ_COMMON_HEADER;
+                        delegate.readWindowUpdateFrame(streamId, deltaWindowSize);
+                    }
+                    break;
 
-        case SPDY_GOAWAY_FRAME:
-            if (buffer.readableBytes() < 8) {
-                return null;
-            }
+                case READ_HEADER_BLOCK:
+                    if (length == 0) {
+                        state = State.READ_COMMON_HEADER;
+                        delegate.readHeaderBlockEnd();
+                        break;
+                    }
 
-            int lastGoodStreamId = getUnsignedInt(buffer, buffer.readerIndex());
-            statusCode = getSignedInt(buffer, buffer.readerIndex() + 4);
-            buffer.skipBytes(8);
+                    if (!buffer.isReadable()) {
+                        return;
+                    }
 
-            return new DefaultSpdyGoAwayFrame(lastGoodStreamId, statusCode);
+                    int compressedBytes = Math.min(buffer.readableBytes(), length);
+                    ByteBuf headerBlock = buffer.alloc().buffer(compressedBytes);
+                    headerBlock.writeBytes(buffer, compressedBytes);
+                    length -= compressedBytes;
 
-        case SPDY_WINDOW_UPDATE_FRAME:
-            if (buffer.readableBytes() < 8) {
-                return null;
-            }
+                    delegate.readHeaderBlock(headerBlock);
+                    break;
 
-            streamId = getUnsignedInt(buffer, buffer.readerIndex());
-            int deltaWindowSize = getUnsignedInt(buffer, buffer.readerIndex() + 4);
-            buffer.skipBytes(8);
+                case DISCARD_FRAME:
+                    int numBytes = Math.min(buffer.readableBytes(), length);
+                    buffer.skipBytes(numBytes);
+                    length -= numBytes;
+                    if (length == 0) {
+                        state = State.READ_COMMON_HEADER;
+                        break;
+                    }
+                    return;
 
-            return new DefaultSpdyWindowUpdateFrame(streamId, deltaWindowSize);
+                case FRAME_ERROR:
+                    buffer.skipBytes(buffer.readableBytes());
+                    return;
 
-        default:
-            throw new Error("Shouldn't reach here.");
+                default:
+                    throw new Error("Shouldn't reach here.");
+            }
         }
     }
 
-    private SpdyHeadersFrame readHeaderBlockFrame(ByteBuf buffer) {
-        int streamId;
-        switch (type) {
-        case SPDY_SYN_STREAM_FRAME:
-            if (buffer.readableBytes() < 10) {
-                return null;
-            }
-
-            int offset = buffer.readerIndex();
-            streamId = getUnsignedInt(buffer, offset);
-            int associatedToStreamId = getUnsignedInt(buffer, offset + 4);
-            byte priority = (byte) (buffer.getByte(offset + 8) >> 5 & 0x07);
-            buffer.skipBytes(10);
-            length -= 10;
-
-            SpdySynStreamFrame spdySynStreamFrame =
-                    new DefaultSpdySynStreamFrame(streamId, associatedToStreamId, priority);
-            spdySynStreamFrame.setLast((flags & SPDY_FLAG_FIN) != 0);
-            spdySynStreamFrame.setUnidirectional((flags & SPDY_FLAG_UNIDIRECTIONAL) != 0);
+    private static boolean hasFlag(byte flags, byte flag) {
+        return (flags & flag) != 0;
+    }
 
-            return spdySynStreamFrame;
+    private static State getNextState(int type, int length) {
+        switch (type) {
+            case SPDY_DATA_FRAME:
+                return State.READ_DATA_FRAME;
 
-        case SPDY_SYN_REPLY_FRAME:
-            if (buffer.readableBytes() < 4) {
-                return null;
-            }
+            case SPDY_SYN_STREAM_FRAME:
+                return State.READ_SYN_STREAM_FRAME;
 
-            streamId = getUnsignedInt(buffer, buffer.readerIndex());
-            buffer.skipBytes(4);
-            length -= 4;
+            case SPDY_SYN_REPLY_FRAME:
+                return State.READ_SYN_REPLY_FRAME;
 
-            SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);
-            spdySynReplyFrame.setLast((flags & SPDY_FLAG_FIN) != 0);
+            case SPDY_RST_STREAM_FRAME:
+                return State.READ_RST_STREAM_FRAME;
 
-            return spdySynReplyFrame;
+            case SPDY_SETTINGS_FRAME:
+                return State.READ_SETTINGS_FRAME;
 
-        case SPDY_HEADERS_FRAME:
-            if (buffer.readableBytes() < 4) {
-                return null;
-            }
+            case SPDY_PING_FRAME:
+                return State.READ_PING_FRAME;
 
-            streamId = getUnsignedInt(buffer, buffer.readerIndex());
-            buffer.skipBytes(4);
-            length -= 4;
+            case SPDY_GOAWAY_FRAME:
+                return State.READ_GOAWAY_FRAME;
 
-            SpdyHeadersFrame spdyHeadersFrame = new DefaultSpdyHeadersFrame(streamId);
-            spdyHeadersFrame.setLast((flags & SPDY_FLAG_FIN) != 0);
+            case SPDY_HEADERS_FRAME:
+                return State.READ_HEADERS_FRAME;
 
-            return spdyHeadersFrame;
+            case SPDY_WINDOW_UPDATE_FRAME:
+                return State.READ_WINDOW_UPDATE_FRAME;
 
-        default:
-            throw new Error("Shouldn't reach here.");
+            default:
+                if (length != 0) {
+                    return State.DISCARD_FRAME;
+                } else {
+                    return State.READ_COMMON_HEADER;
+                }
         }
     }
 
-    private boolean isValidFrameHeader() {
+    private static boolean isValidFrameHeader(int streamId, int type, byte flags, int length) {
         switch (type) {
-        case SPDY_DATA_FRAME:
-            return streamId != 0;
-
-        case SPDY_SYN_STREAM_FRAME:
-            return length >= 10;
+            case SPDY_DATA_FRAME:
+                return streamId != 0;
 
-        case SPDY_SYN_REPLY_FRAME:
-            return length >= 4;
+            case SPDY_SYN_STREAM_FRAME:
+                return length >= 10;
 
-        case SPDY_RST_STREAM_FRAME:
-            return flags == 0 && length == 8;
+            case SPDY_SYN_REPLY_FRAME:
+                return length >= 4;
 
-        case SPDY_SETTINGS_FRAME:
-            return length >= 4;
+            case SPDY_RST_STREAM_FRAME:
+                return flags == 0 && length == 8;
 
-        case SPDY_PING_FRAME:
-            return length == 4;
+            case SPDY_SETTINGS_FRAME:
+                return length >= 4;
 
-        case SPDY_GOAWAY_FRAME:
-            return length == 8;
+            case SPDY_PING_FRAME:
+                return length == 4;
 
-        case SPDY_HEADERS_FRAME:
-            return length >= 4;
+            case SPDY_GOAWAY_FRAME:
+                return length == 8;
 
-        case SPDY_WINDOW_UPDATE_FRAME:
-            return length == 8;
+            case SPDY_HEADERS_FRAME:
+                return length >= 4;
 
-        default:
-            return true;
-        }
-    }
+            case SPDY_WINDOW_UPDATE_FRAME:
+                return length == 8;
 
-    private boolean willGenerateFrame() {
-        switch (type) {
-        case SPDY_DATA_FRAME:
-        case SPDY_SYN_STREAM_FRAME:
-        case SPDY_SYN_REPLY_FRAME:
-        case SPDY_RST_STREAM_FRAME:
-        case SPDY_SETTINGS_FRAME:
-        case SPDY_PING_FRAME:
-        case SPDY_GOAWAY_FRAME:
-        case SPDY_HEADERS_FRAME:
-        case SPDY_WINDOW_UPDATE_FRAME:
-            return true;
-
-        default:
-            return false;
+            default:
+                return true;
         }
     }
-
-    private static void fireInvalidFrameException(ChannelHandlerContext ctx) {
-        ctx.fireExceptionCaught(INVALID_FRAME);
-    }
-
-    private static void fireProtocolException(ChannelHandlerContext ctx, String message) {
-        ctx.fireExceptionCaught(new SpdyProtocolException(message));
-    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoderDelegate.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoderDelegate.java
new file mode 100644
index 000000000000..52815c787caf
--- /dev/null
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoderDelegate.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.spdy;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * Callback interface for {@link SpdyFrameDecoder}.
+ */
+public interface SpdyFrameDecoderDelegate {
+
+    /**
+     * Called when a DATA frame is received.
+     */
+    void readDataFrame(int streamId, boolean last, ByteBuf data);
+
+    /**
+     * Called when a SYN_STREAM frame is received.
+     * The Name/Value Header Block is not included. See readHeaderBlock().
+     */
+    void readSynStreamFrame(
+            int streamId, int associatedToStreamId, byte priority, boolean last, boolean unidirectional);
+
+    /**
+     * Called when a SYN_REPLY frame is received.
+     * The Name/Value Header Block is not included. See readHeaderBlock().
+     */
+    void readSynReplyFrame(int streamId, boolean last);
+
+    /**
+     * Called when a RST_STREAM frame is received.
+     */
+    void readRstStreamFrame(int streamId, int statusCode);
+
+    /**
+     * Called when a SETTINGS frame is received.
+     * Settings are not included. See readSetting().
+     */
+    void readSettingsFrame(boolean clearPersisted);
+
+    /**
+     * Called when an individual setting within a SETTINGS frame is received.
+     */
+    void readSetting(int id, int value, boolean persistValue, boolean persisted);
+
+    /**
+     * Called when the entire SETTINGS frame has been received.
+     */
+    void readSettingsEnd();
+
+    /**
+     * Called when a PING frame is received.
+     */
+    void readPingFrame(int id);
+
+    /**
+     * Called when a GOAWAY frame is received.
+     */
+    void readGoAwayFrame(int lastGoodStreamId, int statusCode);
+
+    /**
+     * Called when a HEADERS frame is received.
+     * The Name/Value Header Block is not included. See readHeaderBlock().
+     */
+    void readHeadersFrame(int streamId, boolean last);
+
+    /**
+     * Called when a WINDOW_UPDATE frame is received.
+     */
+    void readWindowUpdateFrame(int streamId, int deltaWindowSize);
+
+    /**
+     * Called when the header block within a SYN_STREAM, SYN_REPLY, or HEADERS frame is received.
+     */
+    void readHeaderBlock(ByteBuf headerBlock);
+
+    /**
+     * Called when an entire header block has been received.
+     */
+    void readHeaderBlockEnd();
+
+    /**
+     * Called when an unrecoverable session error has occurred.
+     */
+    void readFrameError(String message);
+}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
index 762c12ad3e2a..1524f9523424 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,12 +16,9 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.MessageToByteEncoder;
-import io.netty.handler.codec.UnsupportedMessageTypeException;
+import io.netty.buffer.ByteBufAllocator;
 
+import java.nio.ByteOrder;
 import java.util.Set;
 
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
@@ -29,188 +26,138 @@
 /**
  * Encodes a SPDY Frame into a {@link ByteBuf}.
  */
-public class SpdyFrameEncoder extends MessageToByteEncoder<SpdyFrame> {
+public class SpdyFrameEncoder {
 
     private final int version;
-    private final SpdyHeaderBlockEncoder headerBlockEncoder;
 
     /**
-     * Creates a new instance with the specified {@code version} and the
-     * default {@code compressionLevel (6)}, {@code windowBits (15)},
-     * and {@code memLevel (8)}.
+     * Creates a new instance with the specified {@code spdyVersion}.
      */
-    public SpdyFrameEncoder(SpdyVersion version) {
-        this(version, 6, 15, 8);
+    public SpdyFrameEncoder(SpdyVersion spdyVersion) {
+        if (spdyVersion == null) {
+            throw new NullPointerException("spdyVersion");
+        }
+        version = spdyVersion.getVersion();
     }
 
-    /**
-     * Creates a new instance with the specified parameters.
-     */
-    public SpdyFrameEncoder(SpdyVersion version, int compressionLevel, int windowBits, int memLevel) {
-        this(version, SpdyHeaderBlockEncoder.newInstance(
-                    version, compressionLevel, windowBits, memLevel));
+    private void writeControlFrameHeader(ByteBuf buffer, int type, byte flags, int length) {
+        buffer.writeShort(version | 0x8000);
+        buffer.writeShort(type);
+        buffer.writeByte(flags);
+        buffer.writeMedium(length);
     }
 
-    protected SpdyFrameEncoder(SpdyVersion version, SpdyHeaderBlockEncoder headerBlockEncoder) {
-        if (version == null) {
-            throw new NullPointerException("version");
-        }
-        this.version = version.getVersion();
-        this.headerBlockEncoder = headerBlockEncoder;
+    public ByteBuf encodeDataFrame(ByteBufAllocator allocator, int streamId, boolean last, ByteBuf data) {
+        byte flags = last ? SPDY_DATA_FLAG_FIN : 0;
+        int length = data.readableBytes();
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        frame.writeInt(streamId & 0x7FFFFFFF);
+        frame.writeByte(flags);
+        frame.writeMedium(length);
+        frame.writeBytes(data, data.readerIndex(), length);
+        return frame;
     }
 
-    @Override
-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-        ctx.channel().closeFuture().addListener(new ChannelFutureListener() {
-            @Override
-            public void operationComplete(ChannelFuture future) throws Exception {
-                headerBlockEncoder.end();
-            }
-        });
+    public ByteBuf encodeSynStreamFrame(ByteBufAllocator allocator,  int streamId, int associatedToStreamId,
+            byte priority, boolean last, boolean unidirectional, ByteBuf headerBlock) {
+        int headerBlockLength = headerBlock.readableBytes();
+        byte flags = last ? SPDY_FLAG_FIN : 0;
+        if (unidirectional) {
+            flags |= SPDY_FLAG_UNIDIRECTIONAL;
+        }
+        int length = 10 + headerBlockLength;
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        writeControlFrameHeader(frame, SPDY_SYN_STREAM_FRAME, flags, length);
+        frame.writeInt(streamId);
+        frame.writeInt(associatedToStreamId);
+        frame.writeShort((priority & 0xFF) << 13);
+        frame.writeBytes(headerBlock, headerBlock.readerIndex(), headerBlockLength);
+        return frame;
     }
 
-    @Override
-    protected void encode(ChannelHandlerContext ctx, SpdyFrame msg, ByteBuf out) throws Exception {
-        if (msg instanceof SpdyDataFrame) {
-
-            SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-            ByteBuf data = spdyDataFrame.content();
-            byte flags = spdyDataFrame.isLast() ? SPDY_DATA_FLAG_FIN : 0;
-            out.ensureWritable(SPDY_HEADER_SIZE + data.readableBytes());
-            out.writeInt(spdyDataFrame.getStreamId() & 0x7FFFFFFF);
-            out.writeByte(flags);
-            out.writeMedium(data.readableBytes());
-            out.writeBytes(data, data.readerIndex(), data.readableBytes());
-
-        } else if (msg instanceof SpdySynStreamFrame) {
-
-            SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
-            ByteBuf data = headerBlockEncoder.encode(spdySynStreamFrame);
-            try {
-                byte flags = spdySynStreamFrame.isLast() ? SPDY_FLAG_FIN : 0;
-                if (spdySynStreamFrame.isUnidirectional()) {
-                    flags |= SPDY_FLAG_UNIDIRECTIONAL;
-                }
-                int headerBlockLength = data.readableBytes();
-                int length = 10 + headerBlockLength;
-                out.ensureWritable(SPDY_HEADER_SIZE + length);
-                out.writeShort(version | 0x8000);
-                out.writeShort(SPDY_SYN_STREAM_FRAME);
-                out.writeByte(flags);
-                out.writeMedium(length);
-                out.writeInt(spdySynStreamFrame.getStreamId());
-                out.writeInt(spdySynStreamFrame.getAssociatedToStreamId());
-                out.writeShort((spdySynStreamFrame.getPriority() & 0xFF) << 13);
-                out.writeBytes(data, data.readerIndex(), headerBlockLength);
-            } finally {
-                data.release();
-            }
-
-        } else if (msg instanceof SpdySynReplyFrame) {
-
-            SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
-            ByteBuf data = headerBlockEncoder.encode(spdySynReplyFrame);
-            try {
-                byte flags = spdySynReplyFrame.isLast() ? SPDY_FLAG_FIN : 0;
-                int headerBlockLength = data.readableBytes();
-                int length = 4 + headerBlockLength;
-                out.ensureWritable(SPDY_HEADER_SIZE + length);
-                out.writeShort(version | 0x8000);
-                out.writeShort(SPDY_SYN_REPLY_FRAME);
-                out.writeByte(flags);
-                out.writeMedium(length);
-                out.writeInt(spdySynReplyFrame.getStreamId());
-                out.writeBytes(data, data.readerIndex(), headerBlockLength);
-            } finally {
-                data.release();
-            }
-
-        } else if (msg instanceof SpdyRstStreamFrame) {
+    public ByteBuf encodeSynReplyFrame(ByteBufAllocator allocator, int streamId, boolean last, ByteBuf headerBlock) {
+        int headerBlockLength = headerBlock.readableBytes();
+        byte flags = last ? SPDY_FLAG_FIN : 0;
+        int length = 4 + headerBlockLength;
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        writeControlFrameHeader(frame, SPDY_SYN_REPLY_FRAME, flags, length);
+        frame.writeInt(streamId);
+        frame.writeBytes(headerBlock, headerBlock.readerIndex(), headerBlockLength);
+        return frame;
+    }
 
-            SpdyRstStreamFrame spdyRstStreamFrame = (SpdyRstStreamFrame) msg;
-            out.ensureWritable(SPDY_HEADER_SIZE + 8);
-            out.writeShort(version | 0x8000);
-            out.writeShort(SPDY_RST_STREAM_FRAME);
-            out.writeInt(8);
-            out.writeInt(spdyRstStreamFrame.getStreamId());
-            out.writeInt(spdyRstStreamFrame.getStatus().getCode());
+    public ByteBuf encodeRstStreamFrame(ByteBufAllocator allocator, int streamId, int statusCode) {
+        byte flags = 0;
+        int length = 8;
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        writeControlFrameHeader(frame, SPDY_RST_STREAM_FRAME, flags, length);
+        frame.writeInt(streamId);
+        frame.writeInt(statusCode);
+        return frame;
+    }
 
-        } else if (msg instanceof SpdySettingsFrame) {
+    public ByteBuf encodeSettingsFrame(ByteBufAllocator allocator, SpdySettingsFrame spdySettingsFrame) {
+        Set<Integer> ids = spdySettingsFrame.ids();
+        int numSettings = ids.size();
 
-            SpdySettingsFrame spdySettingsFrame = (SpdySettingsFrame) msg;
-            byte flags = spdySettingsFrame.clearPreviouslyPersistedSettings() ?
+        byte flags = spdySettingsFrame.clearPreviouslyPersistedSettings() ?
                 SPDY_SETTINGS_CLEAR : 0;
-            Set<Integer> IDs = spdySettingsFrame.getIds();
-            int numEntries = IDs.size();
-            int length = 4 + numEntries * 8;
-            out.ensureWritable(SPDY_HEADER_SIZE + length);
-            out.writeShort(version | 0x8000);
-            out.writeShort(SPDY_SETTINGS_FRAME);
-            out.writeByte(flags);
-            out.writeMedium(length);
-            out.writeInt(numEntries);
-            for (Integer id: IDs) {
-                byte ID_flags = 0;
-                if (spdySettingsFrame.isPersistValue(id)) {
-                    ID_flags |= SPDY_SETTINGS_PERSIST_VALUE;
-                }
-                if (spdySettingsFrame.isPersisted(id)) {
-                    ID_flags |= SPDY_SETTINGS_PERSISTED;
-                }
-                out.writeByte(ID_flags);
-                out.writeMedium(id);
-                out.writeInt(spdySettingsFrame.getValue(id));
+        int length = 4 + 8 * numSettings;
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        writeControlFrameHeader(frame, SPDY_SETTINGS_FRAME, flags, length);
+        frame.writeInt(numSettings);
+        for (Integer id : ids) {
+            flags = 0;
+            if (spdySettingsFrame.isPersistValue(id)) {
+                flags |= SPDY_SETTINGS_PERSIST_VALUE;
             }
-
-        } else if (msg instanceof SpdyPingFrame) {
-
-            SpdyPingFrame spdyPingFrame = (SpdyPingFrame) msg;
-            out.ensureWritable(SPDY_HEADER_SIZE + 4);
-            out.writeShort(version | 0x8000);
-            out.writeShort(SPDY_PING_FRAME);
-            out.writeInt(4);
-            out.writeInt(spdyPingFrame.getId());
-
-        } else if (msg instanceof SpdyGoAwayFrame) {
-
-            SpdyGoAwayFrame spdyGoAwayFrame = (SpdyGoAwayFrame) msg;
-            out.ensureWritable(SPDY_HEADER_SIZE + 8);
-            out.writeShort(version | 0x8000);
-            out.writeShort(SPDY_GOAWAY_FRAME);
-            out.writeInt(8);
-            out.writeInt(spdyGoAwayFrame.getLastGoodStreamId());
-            out.writeInt(spdyGoAwayFrame.getStatus().getCode());
-
-        } else if (msg instanceof SpdyHeadersFrame) {
-
-            SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-            ByteBuf data = headerBlockEncoder.encode(spdyHeadersFrame);
-            try {
-                byte flags = spdyHeadersFrame.isLast() ? SPDY_FLAG_FIN : 0;
-                int headerBlockLength = data.readableBytes();
-                int length = 4 + headerBlockLength;
-                out.ensureWritable(SPDY_HEADER_SIZE + length);
-                out.writeShort(version | 0x8000);
-                out.writeShort(SPDY_HEADERS_FRAME);
-                out.writeByte(flags);
-                out.writeMedium(length);
-                out.writeInt(spdyHeadersFrame.getStreamId());
-                out.writeBytes(data, data.readerIndex(), headerBlockLength);
-            } finally {
-                data.release();
+            if (spdySettingsFrame.isPersisted(id)) {
+                flags |= SPDY_SETTINGS_PERSISTED;
             }
-
-        } else if (msg instanceof SpdyWindowUpdateFrame) {
-
-            SpdyWindowUpdateFrame spdyWindowUpdateFrame = (SpdyWindowUpdateFrame) msg;
-            out.ensureWritable(SPDY_HEADER_SIZE + 8);
-            out.writeShort(version | 0x8000);
-            out.writeShort(SPDY_WINDOW_UPDATE_FRAME);
-            out.writeInt(8);
-            out.writeInt(spdyWindowUpdateFrame.getStreamId());
-            out.writeInt(spdyWindowUpdateFrame.getDeltaWindowSize());
-        } else {
-            throw new UnsupportedMessageTypeException(msg);
+            frame.writeByte(flags);
+            frame.writeMedium(id);
+            frame.writeInt(spdySettingsFrame.getValue(id));
         }
+        return frame;
+    }
+
+    public ByteBuf encodePingFrame(ByteBufAllocator allocator, int id) {
+        byte flags = 0;
+        int length = 4;
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        writeControlFrameHeader(frame, SPDY_PING_FRAME, flags, length);
+        frame.writeInt(id);
+        return frame;
+    }
+
+    public ByteBuf encodeGoAwayFrame(ByteBufAllocator allocator, int lastGoodStreamId, int statusCode) {
+        byte flags = 0;
+        int length = 8;
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        writeControlFrameHeader(frame, SPDY_GOAWAY_FRAME, flags, length);
+        frame.writeInt(lastGoodStreamId);
+        frame.writeInt(statusCode);
+        return frame;
+    }
+
+    public ByteBuf encodeHeadersFrame(ByteBufAllocator allocator, int streamId, boolean last, ByteBuf headerBlock) {
+        int headerBlockLength = headerBlock.readableBytes();
+        byte flags = last ? SPDY_FLAG_FIN : 0;
+        int length = 4 + headerBlockLength;
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        writeControlFrameHeader(frame, SPDY_HEADERS_FRAME, flags, length);
+        frame.writeInt(streamId);
+        frame.writeBytes(headerBlock, headerBlock.readerIndex(), headerBlockLength);
+        return frame;
+    }
+
+    public ByteBuf encodeWindowUpdateFrame(ByteBufAllocator allocator, int streamId, int deltaWindowSize) {
+        byte flags = 0;
+        int length = 8;
+        ByteBuf frame = allocator.ioBuffer(SPDY_HEADER_SIZE + length).order(ByteOrder.BIG_ENDIAN);
+        writeControlFrameHeader(frame, SPDY_WINDOW_UPDATE_FRAME, flags, length);
+        frame.writeInt(streamId);
+        frame.writeInt(deltaWindowSize);
+        return frame;
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java
index 318c6bfe922f..d2abb19b37ea 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java
@@ -23,7 +23,7 @@ public interface SpdyGoAwayFrame extends SpdyFrame {
     /**
      * Returns the Last-good-stream-ID of this frame.
      */
-    int getLastGoodStreamId();
+    int lastGoodStreamId();
 
     /**
      * Sets the Last-good-stream-ID of this frame.  The Last-good-stream-ID
@@ -34,7 +34,7 @@ public interface SpdyGoAwayFrame extends SpdyFrame {
     /**
      * Returns the status of this frame.
      */
-    SpdySessionStatus getStatus();
+    SpdySessionStatus status();
 
     /**
      * Sets the status of this frame.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecoder.java
index 731e7f2b6d69..a4b80aac1692 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -19,11 +19,24 @@
 
 abstract class SpdyHeaderBlockDecoder {
 
-    static SpdyHeaderBlockDecoder newInstance(SpdyVersion version, int maxHeaderSize) {
-        return new SpdyHeaderBlockZlibDecoder(version, maxHeaderSize);
+    static SpdyHeaderBlockDecoder newInstance(SpdyVersion spdyVersion, int maxHeaderSize) {
+        return new SpdyHeaderBlockZlibDecoder(spdyVersion, maxHeaderSize);
     }
 
-    abstract void decode(ByteBuf encoded, SpdyHeadersFrame frame) throws Exception;
-    abstract void reset();
+    /**
+     * Decodes a SPDY Header Block, adding the Name/Value pairs to the given Headers frame.
+     * If the header block is malformed, the Headers frame will be marked as invalid.
+     * A stream error with status code PROTOCOL_ERROR must be issued in response to an invalid frame.
+     *
+     * @param headerBlock the HeaderBlock to decode
+     * @param frame the Headers frame that receives the Name/Value pairs
+     * @throws Exception If the header block is malformed in a way that prevents any future
+     *                   decoding of any other header blocks, an exception will be thrown.
+     *                   A session error with status code PROTOCOL_ERROR must be issued.
+     */
+    abstract void decode(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception;
+
+    abstract void endHeaderBlock(SpdyHeadersFrame frame) throws Exception;
+
     abstract void end();
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java
index 0d2a00c65928..2e1a02c172b1 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -23,20 +23,35 @@ public class SpdyHeaderBlockRawDecoder extends SpdyHeaderBlockDecoder {
 
     private static final int LENGTH_FIELD_SIZE = 4;
 
-    private final int version;
     private final int maxHeaderSize;
 
-    // Header block decoding fields
+    private State state;
+
+    private ByteBuf cumulation;
+
     private int headerSize;
-    private int numHeaders = -1;
+    private int numHeaders;
+    private int length;
+    private String name;
+
+    private enum State {
+        READ_NUM_HEADERS,
+        READ_NAME_LENGTH,
+        READ_NAME,
+        SKIP_NAME,
+        READ_VALUE_LENGTH,
+        READ_VALUE,
+        SKIP_VALUE,
+        END_HEADER_BLOCK,
+        ERROR
+    }
 
     public SpdyHeaderBlockRawDecoder(SpdyVersion spdyVersion, int maxHeaderSize) {
         if (spdyVersion == null) {
             throw new NullPointerException("spdyVersion");
         }
-
-        version = spdyVersion.getVersion();
         this.maxHeaderSize = maxHeaderSize;
+        state = State.READ_NUM_HEADERS;
     }
 
     private static int readLengthField(ByteBuf buffer) {
@@ -46,136 +61,250 @@ private static int readLengthField(ByteBuf buffer) {
     }
 
     @Override
-    void decode(ByteBuf encoded, SpdyHeadersFrame frame) throws Exception {
-        if (encoded == null) {
-            throw new NullPointerException("encoded");
+    void decode(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
+        if (headerBlock == null) {
+            throw new NullPointerException("headerBlock");
         }
         if (frame == null) {
             throw new NullPointerException("frame");
         }
 
-        if (numHeaders == -1) {
-            // Read number of Name/Value pairs
-            if (encoded.readableBytes() < LENGTH_FIELD_SIZE) {
-                return;
+        if (cumulation == null) {
+            decodeHeaderBlock(headerBlock, frame);
+            if (headerBlock.isReadable()) {
+                cumulation = headerBlock.alloc().buffer(headerBlock.readableBytes());
+                cumulation.writeBytes(headerBlock);
             }
-            numHeaders = readLengthField(encoded);
-            if (numHeaders < 0) {
-                frame.setInvalid();
-                return;
+        } else {
+            cumulation.writeBytes(headerBlock);
+            decodeHeaderBlock(cumulation, frame);
+            if (cumulation.isReadable()) {
+                cumulation.discardReadBytes();
+            } else {
+                releaseBuffer();
             }
         }
+    }
 
-        while (numHeaders > 0) {
-            int headerSize = this.headerSize;
-            encoded.markReaderIndex();
+    protected void decodeHeaderBlock(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
+        int skipLength;
+        while (headerBlock.isReadable()) {
+            switch(state) {
+                case READ_NUM_HEADERS:
+                    if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {
+                        return;
+                    }
 
-            // Try to read length of name
-            if (encoded.readableBytes() < LENGTH_FIELD_SIZE) {
-                encoded.resetReaderIndex();
-                return;
-            }
-            int nameLength = readLengthField(encoded);
+                    numHeaders = readLengthField(headerBlock);
 
-            // Recipients of a zero-length name must issue a stream error
-            if (nameLength <= 0) {
-                frame.setInvalid();
-                return;
-            }
-            headerSize += nameLength;
-            if (headerSize > maxHeaderSize) {
-                frame.setTruncated();
-                return;
-            }
+                    if (numHeaders < 0) {
+                        state = State.ERROR;
+                        frame.setInvalid();
+                    } else if (numHeaders == 0) {
+                        state = State.END_HEADER_BLOCK;
+                    } else {
+                        state = State.READ_NAME_LENGTH;
+                    }
+                    break;
 
-            // Try to read name
-            if (encoded.readableBytes() < nameLength) {
-                encoded.resetReaderIndex();
-                return;
-            }
-            byte[] nameBytes = new byte[nameLength];
-            encoded.readBytes(nameBytes);
-            String name = new String(nameBytes, "UTF-8");
-
-            // Check for identically named headers
-            if (frame.headers().contains(name)) {
-                frame.setInvalid();
-                return;
-            }
+                case READ_NAME_LENGTH:
+                    if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {
+                        return;
+                    }
 
-            // Try to read length of value
-            if (encoded.readableBytes() < LENGTH_FIELD_SIZE) {
-                encoded.resetReaderIndex();
-                return;
-            }
-            int valueLength = readLengthField(encoded);
+                    length = readLengthField(headerBlock);
 
-            // Recipients of illegal value fields must issue a stream error
-            if (valueLength < 0) {
-                frame.setInvalid();
-                return;
-            }
+                    // Recipients of a zero-length name must issue a stream error
+                    if (length <= 0) {
+                        state = State.ERROR;
+                        frame.setInvalid();
+                    } else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {
+                        headerSize = maxHeaderSize + 1;
+                        state = State.SKIP_NAME;
+                        frame.setTruncated();
+                    } else {
+                        headerSize += length;
+                        state = State.READ_NAME;
+                    }
+                    break;
 
-            // SPDY/3 allows zero-length (empty) header values
-            if (valueLength == 0) {
-                frame.headers().add(name, "");
-                numHeaders --;
-                this.headerSize = headerSize;
-                continue;
-            }
+                case READ_NAME:
+                    if (headerBlock.readableBytes() < length) {
+                        return;
+                    }
 
-            headerSize += valueLength;
-            if (headerSize > maxHeaderSize) {
-                frame.setTruncated();
-                return;
-            }
+                    byte[] nameBytes = new byte[length];
+                    headerBlock.readBytes(nameBytes);
+                    name = new String(nameBytes, "UTF-8");
+
+                    // Check for identically named headers
+                    if (frame.headers().contains(name)) {
+                        state = State.ERROR;
+                        frame.setInvalid();
+                    } else {
+                        state = State.READ_VALUE_LENGTH;
+                    }
+                    break;
+
+                case SKIP_NAME:
+                    skipLength = Math.min(headerBlock.readableBytes(), length);
+                    headerBlock.skipBytes(skipLength);
+                    length -= skipLength;
+
+                    if (length == 0) {
+                        state = State.READ_VALUE_LENGTH;
+                    }
+                    break;
+
+                case READ_VALUE_LENGTH:
+                    if (headerBlock.readableBytes() < LENGTH_FIELD_SIZE) {
+                        return;
+                    }
+
+                    length = readLengthField(headerBlock);
 
-            // Try to read value
-            if (encoded.readableBytes() < valueLength) {
-                encoded.resetReaderIndex();
-                return;
-            }
-            byte[] valueBytes = new byte[valueLength];
-            encoded.readBytes(valueBytes);
-
-            // Add Name/Value pair to headers
-            int index = 0;
-            int offset = 0;
-            while (index < valueLength) {
-                while (index < valueBytes.length && valueBytes[index] != (byte) 0) {
-                    index ++;
-                }
-                if (index < valueBytes.length && valueBytes[index + 1] == (byte) 0) {
-                    // Received multiple, in-sequence NULL characters
                     // Recipients of illegal value fields must issue a stream error
-                    frame.setInvalid();
-                    return;
-                }
-                String value = new String(valueBytes, offset, index - offset, "UTF-8");
+                    if (length < 0) {
+                        state = State.ERROR;
+                        frame.setInvalid();
+                    } else if (length == 0) {
+                        if (!frame.isTruncated()) {
+                            // SPDY/3 allows zero-length (empty) header values
+                            frame.headers().add(name, "");
+                        }
+
+                        name = null;
+                        if (--numHeaders == 0) {
+                            state = State.END_HEADER_BLOCK;
+                        } else {
+                            state = State.READ_NAME_LENGTH;
+                        }
+
+                    } else if (length > maxHeaderSize || headerSize > maxHeaderSize - length) {
+                        headerSize = maxHeaderSize + 1;
+                        name = null;
+                        state = State.SKIP_VALUE;
+                        frame.setTruncated();
+                    } else {
+                        headerSize += length;
+                        state = State.READ_VALUE;
+                    }
+                    break;
+
+                case READ_VALUE:
+                    if (headerBlock.readableBytes() < length) {
+                        return;
+                    }
+
+                    byte[] valueBytes = new byte[length];
+                    headerBlock.readBytes(valueBytes);
+
+                    // Add Name/Value pair to headers
+                    int index = 0;
+                    int offset = 0;
+
+                    // Value must not start with a NULL character
+                    if (valueBytes[0] == (byte) 0) {
+                        state = State.ERROR;
+                        frame.setInvalid();
+                        break;
+                    }
+
+                    while (index < length) {
+                        while (index < valueBytes.length && valueBytes[index] != (byte) 0) {
+                            index ++;
+                        }
+                        if (index < valueBytes.length) {
+                            // Received NULL character
+                            if (index + 1 == valueBytes.length || valueBytes[index + 1] == (byte) 0) {
+                                // Value field ended with a NULL character or
+                                // received multiple, in-sequence NULL characters.
+                                // Recipients of illegal value fields must issue a stream error
+                                state = State.ERROR;
+                                frame.setInvalid();
+                                break;
+                            }
+                        }
+                        String value = new String(valueBytes, offset, index - offset, "UTF-8");
+
+                        try {
+                            frame.headers().add(name, value);
+                        } catch (IllegalArgumentException e) {
+                            // Name contains NULL or non-ascii characters
+                            state = State.ERROR;
+                            frame.setInvalid();
+                            break;
+                        }
+                        index ++;
+                        offset = index;
+                    }
+
+                    name = null;
+
+                    // If we broke out of the add header loop, break here
+                    if (state == State.ERROR) {
+                        break;
+                    }
 
-                try {
-                    frame.headers().add(name, value);
-                } catch (IllegalArgumentException e) {
-                    // Name contains NULL or non-ascii characters
+                    if (--numHeaders == 0) {
+                        state = State.END_HEADER_BLOCK;
+                    } else {
+                        state = State.READ_NAME_LENGTH;
+                    }
+                    break;
+
+                case SKIP_VALUE:
+                    skipLength = Math.min(headerBlock.readableBytes(), length);
+                    headerBlock.skipBytes(skipLength);
+                    length -= skipLength;
+
+                    if (length == 0) {
+                        if (--numHeaders == 0) {
+                            state = State.END_HEADER_BLOCK;
+                        } else {
+                            state = State.READ_NAME_LENGTH;
+                        }
+                    }
+                    break;
+
+                case END_HEADER_BLOCK:
+                    state = State.ERROR;
                     frame.setInvalid();
+                    break;
+
+                case ERROR:
+                    headerBlock.skipBytes(headerBlock.readableBytes());
                     return;
-                }
-                index ++;
-                offset = index;
+
+                default:
+                    throw new Error("Shouldn't reach here.");
             }
-            numHeaders --;
-            this.headerSize = headerSize;
         }
     }
 
     @Override
-    void reset() {
+    void endHeaderBlock(SpdyHeadersFrame frame) throws Exception {
+        if (state != State.END_HEADER_BLOCK) {
+            frame.setInvalid();
+        }
+
+        releaseBuffer();
+
         // Initialize header block decoding fields
         headerSize = 0;
-        numHeaders = -1;
+        name = null;
+        state = State.READ_NUM_HEADERS;
     }
 
     @Override
     void end() {
+        releaseBuffer();
+    }
+
+    private void releaseBuffer() {
+        if (cumulation != null) {
+            cumulation.release();
+            cumulation = null;
+        }
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java
index bf0ed50257ad..81f9e6f5a60f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java
@@ -33,20 +33,12 @@ public SpdyHeaderBlockRawEncoder(SpdyVersion version) {
         this.version = version.getVersion();
     }
 
-    private void setLengthField(ByteBuf buffer, int writerIndex, int length) {
-        if (version < 3) {
-            buffer.setShort(writerIndex, length);
-        } else {
-            buffer.setInt(writerIndex, length);
-        }
+    private static void setLengthField(ByteBuf buffer, int writerIndex, int length) {
+        buffer.setInt(writerIndex, length);
     }
 
-    private void writeLengthField(ByteBuf buffer, int length) {
-        if (version < 3) {
-            buffer.writeShort(length);
-        } else {
-            buffer.writeInt(length);
-        }
+    private static void writeLengthField(ByteBuf buffer, int length) {
+        buffer.writeInt(length);
     }
 
     @Override
@@ -77,12 +69,7 @@ public ByteBuf encode(SpdyHeadersFrame frame) throws Exception {
                     valueLength += valueBytes.length + 1;
                 }
             }
-            if (valueLength == 0) {
-                if (version < 3) {
-                    throw new IllegalArgumentException(
-                            "header value cannot be empty: " + name);
-                }
-            } else {
+            if (valueLength != 0) {
                 valueLength --;
             }
             if (valueLength > SPDY_MAX_NV_LENGTH) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java
index a4df1230430c..44e7d52ffb91 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -26,6 +26,8 @@
 final class SpdyHeaderBlockZlibDecoder extends SpdyHeaderBlockRawDecoder {
 
     private static final int DEFAULT_BUFFER_CAPACITY = 4096;
+    private static final SpdyProtocolException INVALID_HEADER_BLOCK =
+            new SpdyProtocolException("Invalid Header Block");
 
     private final Inflater decompressor = new Inflater();
 
@@ -36,19 +38,22 @@ final class SpdyHeaderBlockZlibDecoder extends SpdyHeaderBlockRawDecoder {
     }
 
     @Override
-    void decode(ByteBuf encoded, SpdyHeadersFrame frame) throws Exception {
-        int len = setInput(encoded);
+    void decode(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {
+        int len = setInput(headerBlock);
 
         int numBytes;
         do {
-            numBytes = decompress(encoded.alloc(), frame);
+            numBytes = decompress(headerBlock.alloc(), frame);
         } while (numBytes > 0);
 
+        // z_stream has an internal 64-bit hold buffer
+        // it is always capable of consuming the entire input
         if (decompressor.getRemaining() != 0) {
-            throw new SpdyProtocolException("client sent extra data beyond headers");
+            // we reached the end of the deflate stream
+            throw INVALID_HEADER_BLOCK;
         }
 
-        encoded.skipBytes(len);
+        headerBlock.skipBytes(len);
     }
 
     private int setInput(ByteBuf compressed) {
@@ -72,12 +77,16 @@ private int decompress(ByteBufAllocator alloc, SpdyHeadersFrame frame) throws Ex
         try {
             int numBytes = decompressor.inflate(out, off, decompressed.writableBytes());
             if (numBytes == 0 && decompressor.needsDictionary()) {
-                decompressor.setDictionary(SPDY_DICT);
+                try {
+                    decompressor.setDictionary(SPDY_DICT);
+                } catch (IllegalArgumentException ignored) {
+                    throw INVALID_HEADER_BLOCK;
+                }
                 numBytes = decompressor.inflate(out, off, decompressed.writableBytes());
             }
             if (frame != null) {
                 decompressed.writerIndex(decompressed.writerIndex() + numBytes);
-                super.decode(decompressed, frame);
+                decodeHeaderBlock(decompressed, frame);
                 decompressed.discardReadBytes();
             }
 
@@ -95,16 +104,16 @@ private void ensureBuffer(ByteBufAllocator alloc) {
     }
 
     @Override
-    void reset() {
+    void endHeaderBlock(SpdyHeadersFrame frame) throws Exception {
+        super.endHeaderBlock(frame);
         releaseBuffer();
-        super.reset();
     }
 
     @Override
     public void end() {
+        super.end();
         releaseBuffer();
         decompressor.end();
-        super.end();
     }
 
     private void releaseBuffer() {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
index aebaa0804394..ec220db5b510 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
@@ -15,399 +15,75 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpResponseStatus;
-import io.netty.handler.codec.http.HttpVersion;
-
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import io.netty.handler.codec.AsciiString;
+import io.netty.handler.codec.TextHeaderProcessor;
+import io.netty.handler.codec.TextHeaders;
 
 /**
  * Provides the constants for the standard SPDY HTTP header names and commonly
  * used utility methods that access a {@link SpdyHeadersFrame}.
  */
-public abstract class SpdyHeaders implements Iterable<Map.Entry<String, String>> {
-
-    public static final SpdyHeaders EMPTY_HEADERS = new SpdyHeaders() {
-
-        @Override
-        public List<String> getAll(String name) {
-            return Collections.emptyList();
-        }
-
-        @Override
-        public List<Map.Entry<String, String>> entries() {
-            return Collections.emptyList();
-        }
-
-        @Override
-        public boolean contains(String name) {
-            return false;
-        }
-
-        @Override
-        public boolean isEmpty() {
-            return true;
-        }
-
-        @Override
-        public Set<String> names() {
-            return Collections.emptySet();
-        }
-
-        @Override
-        public SpdyHeaders add(String name, Object value) {
-            throw new UnsupportedOperationException("read only");
-        }
-
-        @Override
-        public SpdyHeaders add(String name, Iterable<?> values) {
-            throw new UnsupportedOperationException("read only");
-        }
-
-        @Override
-        public SpdyHeaders set(String name, Object value) {
-            throw new UnsupportedOperationException("read only");
-        }
-
-        @Override
-        public SpdyHeaders set(String name, Iterable<?> values) {
-            throw new UnsupportedOperationException("read only");
-        }
-
-        @Override
-        public SpdyHeaders remove(String name) {
-            throw new UnsupportedOperationException("read only");
-        }
-
-        @Override
-        public SpdyHeaders clear() {
-            throw new UnsupportedOperationException("read only");
-        }
-
-        @Override
-        public Iterator<Map.Entry<String, String>> iterator() {
-            return entries().iterator();
-        }
-
-        @Override
-        public String get(String name) {
-            return null;
-        }
-    };
+public interface SpdyHeaders extends TextHeaders {
 
     /**
      * SPDY HTTP header names
      */
-    public static final class HttpNames {
+    final class HttpNames {
         /**
          * {@code ":host"}
          */
-        public static final String HOST = ":host";
+        public static final AsciiString HOST = new AsciiString(":host");
         /**
          * {@code ":method"}
          */
-        public static final String METHOD = ":method";
+        public static final AsciiString METHOD = new AsciiString(":method");
         /**
          * {@code ":path"}
          */
-        public static final String PATH = ":path";
+        public static final AsciiString PATH = new AsciiString(":path");
         /**
          * {@code ":scheme"}
          */
-        public static final String SCHEME = ":scheme";
+        public static final AsciiString SCHEME = new AsciiString(":scheme");
         /**
          * {@code ":status"}
          */
-        public static final String STATUS = ":status";
+        public static final AsciiString STATUS = new AsciiString(":status");
         /**
          * {@code ":version"}
          */
-        public static final String VERSION = ":version";
+        public static final AsciiString VERSION = new AsciiString(":version");
 
         private HttpNames() { }
     }
 
-    /**
-     * Returns the header value with the specified header name.  If there are
-     * more than one header value for the specified header name, the first
-     * value is returned.
-     *
-     * @return the header value or {@code null} if there is no such header
-     */
-    public static String getHeader(SpdyHeadersFrame frame, String name) {
-        return frame.headers().get(name);
-    }
-
-    /**
-     * Returns the header value with the specified header name.  If there are
-     * more than one header value for the specified header name, the first
-     * value is returned.
-     *
-     * @return the header value or the {@code defaultValue} if there is no such
-     *         header
-     */
-    public static String getHeader(SpdyHeadersFrame frame, String name, String defaultValue) {
-        String value = frame.headers().get(name);
-        if (value == null) {
-            return defaultValue;
-        }
-        return value;
-    }
-
-    /**
-     * Sets a new header with the specified name and value.  If there is an
-     * existing header with the same name, the existing header is removed.
-     */
-    public static void setHeader(SpdyHeadersFrame frame, String name, Object value) {
-        frame.headers().set(name, value);
-    }
-
-    /**
-     * Sets a new header with the specified name and values.  If there is an
-     * existing header with the same name, the existing header is removed.
-     */
-    public static void setHeader(SpdyHeadersFrame frame, String name, Iterable<?> values) {
-        frame.headers().set(name, values);
-    }
-
-    /**
-     * Adds a new header with the specified name and value.
-     */
-    public static void addHeader(SpdyHeadersFrame frame, String name, Object value) {
-        frame.headers().add(name, value);
-    }
-
-    /**
-     * Removes the SPDY host header.
-     */
-    public static void removeHost(SpdyHeadersFrame frame) {
-        frame.headers().remove(HttpNames.HOST);
-    }
-
-    /**
-     * Returns the SPDY host header.
-     */
-    public static String getHost(SpdyHeadersFrame frame) {
-        return frame.headers().get(HttpNames.HOST);
-    }
-
-    /**
-     * Set the SPDY host header.
-     */
-    public static void setHost(SpdyHeadersFrame frame, String host) {
-        frame.headers().set(HttpNames.HOST, host);
-    }
-
-    /**
-     * Removes the HTTP method header.
-     */
-    public static void removeMethod(int spdyVersion, SpdyHeadersFrame frame) {
-        frame.headers().remove(HttpNames.METHOD);
-    }
-
-    /**
-     * Returns the {@link HttpMethod} represented by the HTTP method header.
-     */
-    public static HttpMethod getMethod(int spdyVersion, SpdyHeadersFrame frame) {
-        try {
-            return HttpMethod.valueOf(frame.headers().get(HttpNames.METHOD));
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-    /**
-     * Sets the HTTP method header.
-     */
-    public static void setMethod(int spdyVersion, SpdyHeadersFrame frame, HttpMethod method) {
-        frame.headers().set(HttpNames.METHOD, method.name());
-    }
-
-    /**
-     * Removes the URL scheme header.
-     */
-    public static void removeScheme(int spdyVersion, SpdyHeadersFrame frame) {
-        frame.headers().remove(HttpNames.SCHEME);
-    }
-
-    /**
-     * Returns the value of the URL scheme header.
-     */
-    public static String getScheme(int spdyVersion, SpdyHeadersFrame frame) {
-        return frame.headers().get(HttpNames.SCHEME);
-    }
-
-    /**
-     * Sets the URL scheme header.
-     */
-    public static void setScheme(int spdyVersion, SpdyHeadersFrame frame, String scheme) {
-        frame.headers().set(HttpNames.SCHEME, scheme);
-    }
-
-    /**
-     * Removes the HTTP response status header.
-     */
-    public static void removeStatus(int spdyVersion, SpdyHeadersFrame frame) {
-        frame.headers().remove(HttpNames.STATUS);
-    }
-
-    /**
-     * Returns the {@link HttpResponseStatus} represented by the HTTP response status header.
-     */
-    public static HttpResponseStatus getStatus(int spdyVersion, SpdyHeadersFrame frame) {
-        try {
-            String status = frame.headers().get(HttpNames.STATUS);
-            int space = status.indexOf(' ');
-            if (space == -1) {
-                return HttpResponseStatus.valueOf(Integer.parseInt(status));
-            } else {
-                int code = Integer.parseInt(status.substring(0, space));
-                String reasonPhrase = status.substring(space + 1);
-                HttpResponseStatus responseStatus = HttpResponseStatus.valueOf(code);
-                if (responseStatus.reasonPhrase().equals(reasonPhrase)) {
-                    return responseStatus;
-                } else {
-                    return new HttpResponseStatus(code, reasonPhrase);
-                }
-            }
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-    /**
-     * Sets the HTTP response status header.
-     */
-    public static void setStatus(int spdyVersion, SpdyHeadersFrame frame, HttpResponseStatus status) {
-        frame.headers().set(HttpNames.STATUS, status.toString());
-    }
-
-    /**
-     * Removes the URL path header.
-     */
-    public static void removeUrl(int spdyVersion, SpdyHeadersFrame frame) {
-        frame.headers().remove(HttpNames.PATH);
-    }
-
-    /**
-     * Returns the value of the URL path header.
-     */
-    public static String getUrl(int spdyVersion, SpdyHeadersFrame frame) {
-        return frame.headers().get(HttpNames.PATH);
-    }
-
-    /**
-     * Sets the URL path header.
-     */
-    public static void setUrl(int spdyVersion, SpdyHeadersFrame frame, String path) {
-        frame.headers().set(HttpNames.PATH, path);
-    }
-
-    /**
-     * Removes the HTTP version header.
-     */
-    public static void removeVersion(int spdyVersion, SpdyHeadersFrame frame) {
-        frame.headers().remove(HttpNames.VERSION);
-    }
-
-    /**
-     * Returns the {@link HttpVersion} represented by the HTTP version header.
-     */
-    public static HttpVersion getVersion(int spdyVersion, SpdyHeadersFrame frame) {
-        try {
-            return HttpVersion.valueOf(frame.headers().get(HttpNames.VERSION));
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-    /**
-     * Sets the HTTP version header.
-     */
-    public static void setVersion(int spdyVersion, SpdyHeadersFrame frame, HttpVersion httpVersion) {
-        frame.headers().set(HttpNames.VERSION, httpVersion.text());
-    }
-
     @Override
-    public Iterator<Map.Entry<String, String>> iterator() {
-        return entries().iterator();
-    }
+    SpdyHeaders add(CharSequence name, Object value);
 
-    /**
-     * Returns the header value with the specified header name.  If there is
-     * more than one header value for the specified header name, the first
-     * value is returned.
-     *
-     * @return the header value or {@code null} if there is no such header
-     */
-    public abstract String get(String name);
-
-    /**
-     * Returns the header values with the specified header name.
-     *
-     * @return the {@link List} of header values.  An empty list if there is no
-     *         such header.
-     */
-    public abstract List<String> getAll(String name);
-
-    /**
-     * Returns all header names and values that this frame contains.
-     *
-     * @return the {@link List} of the header name-value pairs.  An empty list
-     *         if there is no header in this message.
-     */
-    public abstract List<Map.Entry<String, String>> entries();
-
-    /**
-     * Returns {@code true} if and only if there is a header with the specified
-     * header name.
-     */
-    public abstract boolean contains(String name);
+    @Override
+    SpdyHeaders add(CharSequence name, Iterable<?> values);
 
-    /**
-     * Returns the {@link Set} of all header names that this frame contains.
-     */
-    public abstract Set<String> names();
+    @Override
+    SpdyHeaders add(CharSequence name, Object... values);
 
-    /**
-     * Adds a new header with the specified name and value.
-     */
-    public abstract SpdyHeaders add(String name, Object value);
+    @Override
+    SpdyHeaders add(TextHeaders headers);
 
-    /**
-     * Adds a new header with the specified name and values.  If there is an
-     * existing header with the same name, the existing header is removed.
-     */
-    public abstract SpdyHeaders add(String name, Iterable<?> values);
+    @Override
+    SpdyHeaders set(CharSequence name, Object value);
 
-    /**
-     * Sets a new header with the specified name and value.  If there is an
-     * existing header with the same name, the existing header is removed.
-     */
-    public abstract SpdyHeaders set(String name, Object value);
+    @Override
+    SpdyHeaders set(CharSequence name, Iterable<?> values);
 
-    /**
-     * Sets a new header with the specified name and values.  If there is an
-     * existing header with the same name, the existing header is removed.
-     */
-    public abstract SpdyHeaders set(String name, Iterable<?> values);
+    @Override
+    SpdyHeaders set(CharSequence name, Object... values);
 
-    /**
-     * Removes the header with the specified name.
-     */
-    public abstract SpdyHeaders remove(String name);
+    @Override
+    SpdyHeaders set(TextHeaders headers);
 
-    /**
-     * Removes all headers from this frame.
-     */
-    public abstract SpdyHeaders clear();
+    @Override
+    SpdyHeaders clear();
 
-    /**
-     * Checks if no header exists.
-     */
-    public abstract boolean isEmpty();
+    @Override
+    SpdyHeaders forEachEntry(TextHeaderProcessor processor);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
index efb2dd426de6..4d7ab23353a3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
@@ -15,13 +15,12 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.channel.CombinedChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerAppender;
 
 /**
  * A combination of {@link SpdyHttpDecoder} and {@link SpdyHttpEncoder}
  */
-public final class SpdyHttpCodec
-        extends CombinedChannelDuplexHandler<SpdyHttpDecoder, SpdyHttpEncoder> {
+public final class SpdyHttpCodec extends ChannelHandlerAppender {
     /**
      * Creates a new instance with the specified decoder options.
      */
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
index 6ad8cf2a955b..0f1a503143b7 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
@@ -28,11 +28,14 @@
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.spdy.SpdyHttpHeaders.Names;
 
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import static io.netty.handler.codec.spdy.SpdyHeaders.HttpNames.*;
+
 /**
  * Decodes {@link SpdySynStreamFrame}s, {@link SpdySynReplyFrame}s,
  * and {@link SpdyDataFrame}s into {@link FullHttpRequest}s and {@link FullHttpResponse}s.
@@ -96,11 +99,11 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
 
             // HTTP requests/responses are mapped one-to-one to SPDY streams.
             SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
-            int streamId = spdySynStreamFrame.getStreamId();
+            int streamId = spdySynStreamFrame.streamId();
 
             if (SpdyCodecUtil.isServerId(streamId)) {
                 // SYN_STREAM frames initiated by the server are pushed resources
-                int associatedToStreamId = spdySynStreamFrame.getAssociatedToStreamId();
+                int associatedToStreamId = spdySynStreamFrame.associatedStreamId();
 
                 // If a client receives a SYN_STREAM with an Associated-To-Stream-ID of 0
                 // it must reply with a RST_STREAM with error code INVALID_STREAM
@@ -111,7 +114,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                     return;
                 }
 
-                String URL = SpdyHeaders.getUrl(spdyVersion, spdySynStreamFrame);
+                String URL = spdySynStreamFrame.headers().get(PATH);
 
                 // If a client receives a SYN_STREAM without a 'url' header
                 // it must reply with a RST_STREAM with error code PROTOCOL_ERROR
@@ -136,10 +139,11 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                             createHttpResponse(spdyVersion, spdySynStreamFrame);
 
                     // Set the Stream-ID, Associated-To-Stream-ID, Priority, and URL as headers
-                    SpdyHttpHeaders.setStreamId(httpResponseWithEntity, streamId);
-                    SpdyHttpHeaders.setAssociatedToStreamId(httpResponseWithEntity, associatedToStreamId);
-                    SpdyHttpHeaders.setPriority(httpResponseWithEntity, spdySynStreamFrame.getPriority());
-                    SpdyHttpHeaders.setUrl(httpResponseWithEntity, URL);
+                    HttpHeaders.setIntHeader(httpResponseWithEntity, Names.STREAM_ID, streamId);
+                    HttpHeaders.setIntHeader(
+                            httpResponseWithEntity, Names.ASSOCIATED_TO_STREAM_ID, associatedToStreamId);
+                    HttpHeaders.setIntHeader(httpResponseWithEntity, Names.PRIORITY, spdySynStreamFrame.priority());
+                    httpResponseWithEntity.headers().set(Names.URL, URL);
 
                     if (spdySynStreamFrame.isLast()) {
                         HttpHeaders.setContentLength(httpResponseWithEntity, 0);
@@ -148,7 +152,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                         // Response body will follow in a series of Data Frames
                         putMessage(streamId, httpResponseWithEntity);
                     }
-                } catch (Exception e) {
+                } catch (Exception ignored) {
                     SpdyRstStreamFrame spdyRstStreamFrame =
                         new DefaultSpdyRstStreamFrame(streamId, SpdyStreamStatus.PROTOCOL_ERROR);
                     ctx.writeAndFlush(spdyRstStreamFrame);
@@ -161,10 +165,9 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                 if (spdySynStreamFrame.isTruncated()) {
                     SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);
                     spdySynReplyFrame.setLast(true);
-                    SpdyHeaders.setStatus(spdyVersion,
-                            spdySynReplyFrame,
-                            HttpResponseStatus.REQUEST_HEADER_FIELDS_TOO_LARGE);
-                    SpdyHeaders.setVersion(spdyVersion, spdySynReplyFrame, HttpVersion.HTTP_1_0);
+                    SpdyHeaders frameHeaders = spdySynReplyFrame.headers();
+                    frameHeaders.set(STATUS, HttpResponseStatus.REQUEST_HEADER_FIELDS_TOO_LARGE);
+                    frameHeaders.set(VERSION, HttpVersion.HTTP_1_0);
                     ctx.writeAndFlush(spdySynReplyFrame);
                     return;
                 }
@@ -173,7 +176,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                     FullHttpRequest httpRequestWithEntity = createHttpRequest(spdyVersion, spdySynStreamFrame);
 
                     // Set the Stream-ID as a header
-                    SpdyHttpHeaders.setStreamId(httpRequestWithEntity, streamId);
+                    HttpHeaders.setIntHeader(httpRequestWithEntity, Names.STREAM_ID, streamId);
 
                     if (spdySynStreamFrame.isLast()) {
                         out.add(httpRequestWithEntity);
@@ -187,8 +190,9 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                     // Also sends HTTP 400 BAD REQUEST reply if header name/value pairs are invalid
                     SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);
                     spdySynReplyFrame.setLast(true);
-                    SpdyHeaders.setStatus(spdyVersion, spdySynReplyFrame, HttpResponseStatus.BAD_REQUEST);
-                    SpdyHeaders.setVersion(spdyVersion, spdySynReplyFrame, HttpVersion.HTTP_1_0);
+                    SpdyHeaders frameHeaders = spdySynReplyFrame.headers();
+                    frameHeaders.set(STATUS, HttpResponseStatus.BAD_REQUEST);
+                    frameHeaders.set(VERSION, HttpVersion.HTTP_1_0);
                     ctx.writeAndFlush(spdySynReplyFrame);
                 }
             }
@@ -196,7 +200,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
         } else if (msg instanceof SpdySynReplyFrame) {
 
             SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
-            int streamId = spdySynReplyFrame.getStreamId();
+            int streamId = spdySynReplyFrame.streamId();
 
             // If a client receives a SYN_REPLY with a truncated header block,
             // reply with a RST_STREAM frame with error code INTERNAL_ERROR.
@@ -211,7 +215,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
                 FullHttpResponse httpResponseWithEntity = createHttpResponse(spdyVersion, spdySynReplyFrame);
 
                 // Set the Stream-ID as a header
-                SpdyHttpHeaders.setStreamId(httpResponseWithEntity, streamId);
+                HttpHeaders.setIntHeader(httpResponseWithEntity, Names.STREAM_ID, streamId);
 
                 if (spdySynReplyFrame.isLast()) {
                     HttpHeaders.setContentLength(httpResponseWithEntity, 0);
@@ -231,7 +235,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
         } else if (msg instanceof SpdyHeadersFrame) {
 
             SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-            int streamId = spdyHeadersFrame.getStreamId();
+            int streamId = spdyHeadersFrame.streamId();
             FullHttpMessage fullHttpMessage = getMessage(streamId);
 
             // If message is not in map discard HEADERS frame.
@@ -255,7 +259,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
         } else if (msg instanceof SpdyDataFrame) {
 
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-            int streamId = spdyDataFrame.getStreamId();
+            int streamId = spdyDataFrame.streamId();
             FullHttpMessage fullHttpMessage = getMessage(streamId);
 
             // If message is not in map discard Data Frame.
@@ -283,7 +287,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
         } else if (msg instanceof SpdyRstStreamFrame) {
 
             SpdyRstStreamFrame spdyRstStreamFrame = (SpdyRstStreamFrame) msg;
-            int streamId = spdyRstStreamFrame.getStreamId();
+            int streamId = spdyRstStreamFrame.streamId();
             removeMessage(streamId);
         }
     }
@@ -291,22 +295,23 @@ protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, List<Object> out
     private static FullHttpRequest createHttpRequest(int spdyVersion, SpdyHeadersFrame requestFrame)
             throws Exception {
         // Create the first line of the request from the name/value pairs
-        HttpMethod  method      = SpdyHeaders.getMethod(spdyVersion, requestFrame);
-        String      url         = SpdyHeaders.getUrl(spdyVersion, requestFrame);
-        HttpVersion httpVersion = SpdyHeaders.getVersion(spdyVersion, requestFrame);
-        SpdyHeaders.removeMethod(spdyVersion, requestFrame);
-        SpdyHeaders.removeUrl(spdyVersion, requestFrame);
-        SpdyHeaders.removeVersion(spdyVersion, requestFrame);
+        SpdyHeaders headers     = requestFrame.headers();
+        HttpMethod  method      = HttpMethod.valueOf(headers.get(METHOD));
+        String      url         = headers.get(PATH);
+        HttpVersion httpVersion = HttpVersion.valueOf(headers.get(VERSION));
+        headers.remove(METHOD);
+        headers.remove(PATH);
+        headers.remove(VERSION);
 
         FullHttpRequest req = new DefaultFullHttpRequest(httpVersion, method, url);
 
         // Remove the scheme header
-        SpdyHeaders.removeScheme(spdyVersion, requestFrame);
+        headers.remove(SCHEME);
 
         if (spdyVersion >= 3) {
             // Replace the SPDY host header with the HTTP host header
-            String host = SpdyHeaders.getHost(requestFrame);
-            SpdyHeaders.removeHost(requestFrame);
+            String host = headers.get(HOST);
+            headers.remove(HOST);
             HttpHeaders.setHost(req, host);
         }
 
@@ -323,13 +328,15 @@ private static FullHttpRequest createHttpRequest(int spdyVersion, SpdyHeadersFra
         return req;
     }
 
-    private static FullHttpResponse createHttpResponse(int spdyVersion, SpdyHeadersFrame responseFrame)
-            throws Exception {
+    private static FullHttpResponse createHttpResponse(
+            int spdyVersion, SpdyHeadersFrame responseFrame) throws Exception {
+
         // Create the first line of the response from the name/value pairs
-        HttpResponseStatus status = SpdyHeaders.getStatus(spdyVersion, responseFrame);
-        HttpVersion version = SpdyHeaders.getVersion(spdyVersion, responseFrame);
-        SpdyHeaders.removeStatus(spdyVersion, responseFrame);
-        SpdyHeaders.removeVersion(spdyVersion, responseFrame);
+        SpdyHeaders headers = responseFrame.headers();
+        HttpResponseStatus status = HttpResponseStatus.parseLine(headers.get(STATUS));
+        HttpVersion version = HttpVersion.valueOf(headers.get(VERSION));
+        headers.remove(STATUS);
+        headers.remove(VERSION);
 
         FullHttpResponse res = new DefaultFullHttpResponse(version, status);
         for (Map.Entry<String, String> e: responseFrame.headers()) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
index 111f9c1ccd2d..926fca67ec1c 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
@@ -27,10 +27,13 @@
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.codec.spdy.SpdyHttpHeaders.Names;
 
 import java.util.List;
 import java.util.Map;
 
+import static io.netty.handler.codec.spdy.SpdyHeaders.HttpNames.*;
+
 /**
  * Encodes {@link HttpRequest}s, {@link HttpResponse}s, and {@link HttpContent}s
  * into {@link SpdySynStreamFrame}s and {@link SpdySynReplyFrame}s.
@@ -205,60 +208,62 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> ou
     private SpdySynStreamFrame createSynStreamFrame(HttpMessage httpMessage)
             throws Exception {
         // Get the Stream-ID, Associated-To-Stream-ID, Priority, URL, and scheme from the headers
-        int streamID = SpdyHttpHeaders.getStreamId(httpMessage);
-        int associatedToStreamId = SpdyHttpHeaders.getAssociatedToStreamId(httpMessage);
-        byte priority = SpdyHttpHeaders.getPriority(httpMessage);
-        String URL = SpdyHttpHeaders.getUrl(httpMessage);
-        String scheme = SpdyHttpHeaders.getScheme(httpMessage);
-        SpdyHttpHeaders.removeStreamId(httpMessage);
-        SpdyHttpHeaders.removeAssociatedToStreamId(httpMessage);
-        SpdyHttpHeaders.removePriority(httpMessage);
-        SpdyHttpHeaders.removeUrl(httpMessage);
-        SpdyHttpHeaders.removeScheme(httpMessage);
+        final HttpHeaders httpHeaders = httpMessage.headers();
+        int streamID = HttpHeaders.getIntHeader(httpMessage, Names.STREAM_ID);
+        int associatedToStreamId = HttpHeaders.getIntHeader(httpMessage, Names.ASSOCIATED_TO_STREAM_ID, 0);
+        byte priority = (byte) HttpHeaders.getIntHeader(httpMessage, Names.PRIORITY, 0);
+        String URL = httpHeaders.get(Names.URL);
+        String scheme = httpHeaders.get(Names.SCHEME);
+        httpHeaders.remove(Names.STREAM_ID);
+        httpHeaders.remove(Names.ASSOCIATED_TO_STREAM_ID);
+        httpHeaders.remove(Names.PRIORITY);
+        httpHeaders.remove(Names.URL);
+        httpHeaders.remove(Names.SCHEME);
 
         // The Connection, Keep-Alive, Proxy-Connection, and Transfer-Encoding
         // headers are not valid and MUST not be sent.
-        httpMessage.headers().remove(HttpHeaders.Names.CONNECTION);
-        httpMessage.headers().remove("Keep-Alive");
-        httpMessage.headers().remove("Proxy-Connection");
-        httpMessage.headers().remove(HttpHeaders.Names.TRANSFER_ENCODING);
+        httpHeaders.remove(HttpHeaders.Names.CONNECTION);
+        httpHeaders.remove("Keep-Alive");
+        httpHeaders.remove("Proxy-Connection");
+        httpHeaders.remove(HttpHeaders.Names.TRANSFER_ENCODING);
 
         SpdySynStreamFrame spdySynStreamFrame =
                 new DefaultSpdySynStreamFrame(streamID, associatedToStreamId, priority);
 
         // Unfold the first line of the message into name/value pairs
+        SpdyHeaders frameHeaders = spdySynStreamFrame.headers();
         if (httpMessage instanceof FullHttpRequest) {
             HttpRequest httpRequest = (HttpRequest) httpMessage;
-            SpdyHeaders.setMethod(spdyVersion, spdySynStreamFrame, httpRequest.getMethod());
-            SpdyHeaders.setUrl(spdyVersion, spdySynStreamFrame, httpRequest.getUri());
-            SpdyHeaders.setVersion(spdyVersion, spdySynStreamFrame, httpMessage.getProtocolVersion());
+            frameHeaders.set(METHOD, httpRequest.method());
+            frameHeaders.set(PATH, httpRequest.uri());
+            frameHeaders.set(VERSION, httpMessage.protocolVersion());
         }
         if (httpMessage instanceof HttpResponse) {
             HttpResponse httpResponse = (HttpResponse) httpMessage;
-            SpdyHeaders.setStatus(spdyVersion, spdySynStreamFrame, httpResponse.getStatus());
-            SpdyHeaders.setUrl(spdyVersion, spdySynStreamFrame, URL);
-            SpdyHeaders.setVersion(spdyVersion, spdySynStreamFrame, httpMessage.getProtocolVersion());
+            frameHeaders.set(STATUS, httpResponse.status());
+            frameHeaders.set(PATH, URL);
+            frameHeaders.set(VERSION, httpMessage.protocolVersion());
             spdySynStreamFrame.setUnidirectional(true);
         }
 
         // Replace the HTTP host header with the SPDY host header
         if (spdyVersion >= 3) {
             String host = HttpHeaders.getHost(httpMessage);
-            httpMessage.headers().remove(HttpHeaders.Names.HOST);
-            SpdyHeaders.setHost(spdySynStreamFrame, host);
+            httpHeaders.remove(HttpHeaders.Names.HOST);
+            frameHeaders.set(HOST, host);
         }
 
         // Set the SPDY scheme header
         if (scheme == null) {
             scheme = "https";
         }
-        SpdyHeaders.setScheme(spdyVersion, spdySynStreamFrame, scheme);
+        frameHeaders.set(SCHEME, scheme);
 
         // Transfer the remaining HTTP headers
-        for (Map.Entry<String, String> entry: httpMessage.headers()) {
-            spdySynStreamFrame.headers().add(entry.getKey(), entry.getValue());
+        for (Map.Entry<String, String> entry: httpHeaders) {
+            frameHeaders.add(entry.getKey(), entry.getValue());
         }
-        currentStreamId = spdySynStreamFrame.getStreamId();
+        currentStreamId = spdySynStreamFrame.streamId();
         spdySynStreamFrame.setLast(isLast(httpMessage));
 
         return spdySynStreamFrame;
@@ -267,24 +272,25 @@ private SpdySynStreamFrame createSynStreamFrame(HttpMessage httpMessage)
     private SpdySynReplyFrame createSynReplyFrame(HttpResponse httpResponse)
             throws Exception {
         // Get the Stream-ID from the headers
-        int streamID = SpdyHttpHeaders.getStreamId(httpResponse);
-        SpdyHttpHeaders.removeStreamId(httpResponse);
+        final HttpHeaders httpHeaders = httpResponse.headers();
+        int streamID = HttpHeaders.getIntHeader(httpResponse, Names.STREAM_ID);
+        httpHeaders.remove(Names.STREAM_ID);
 
         // The Connection, Keep-Alive, Proxy-Connection, and Transfer-Encoding
         // headers are not valid and MUST not be sent.
-        httpResponse.headers().remove(HttpHeaders.Names.CONNECTION);
-        httpResponse.headers().remove("Keep-Alive");
-        httpResponse.headers().remove("Proxy-Connection");
-        httpResponse.headers().remove(HttpHeaders.Names.TRANSFER_ENCODING);
+        httpHeaders.remove(HttpHeaders.Names.CONNECTION);
+        httpHeaders.remove("Keep-Alive");
+        httpHeaders.remove("Proxy-Connection");
+        httpHeaders.remove(HttpHeaders.Names.TRANSFER_ENCODING);
 
         SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamID);
-
+        SpdyHeaders frameHeaders = spdySynReplyFrame.headers();
         // Unfold the first line of the response into name/value pairs
-        SpdyHeaders.setStatus(spdyVersion, spdySynReplyFrame, httpResponse.getStatus());
-        SpdyHeaders.setVersion(spdyVersion, spdySynReplyFrame, httpResponse.getProtocolVersion());
+        frameHeaders.set(STATUS, httpResponse.status());
+        frameHeaders.set(VERSION, httpResponse.protocolVersion());
 
         // Transfer the remaining HTTP headers
-        for (Map.Entry<String, String> entry: httpResponse.headers()) {
+        for (Map.Entry<String, String> entry: httpHeaders) {
             spdySynReplyFrame.headers().add(entry.getKey(), entry.getValue());
         }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java
index 0aa0de913d82..e28a3be2a6c3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java
@@ -15,8 +15,7 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMessage;
+import io.netty.handler.codec.AsciiString;
 
 /**
  * Provides the constants for the header names and the utility methods
@@ -31,138 +30,26 @@ public static final class Names {
         /**
          * {@code "X-SPDY-Stream-ID"}
          */
-        public static final String STREAM_ID = "X-SPDY-Stream-ID";
+        public static final AsciiString STREAM_ID = new AsciiString("X-SPDY-Stream-ID");
         /**
          * {@code "X-SPDY-Associated-To-Stream-ID"}
          */
-        public static final String ASSOCIATED_TO_STREAM_ID = "X-SPDY-Associated-To-Stream-ID";
+        public static final AsciiString ASSOCIATED_TO_STREAM_ID = new AsciiString("X-SPDY-Associated-To-Stream-ID");
         /**
          * {@code "X-SPDY-Priority"}
          */
-        public static final String PRIORITY = "X-SPDY-Priority";
+        public static final AsciiString PRIORITY = new AsciiString("X-SPDY-Priority");
         /**
          * {@code "X-SPDY-URL"}
          */
-        public static final String URL = "X-SPDY-URL";
+        public static final AsciiString URL = new AsciiString("X-SPDY-URL");
         /**
          * {@code "X-SPDY-Scheme"}
          */
-        public static final String SCHEME = "X-SPDY-Scheme";
+        public static final AsciiString SCHEME = new AsciiString("X-SPDY-Scheme");
 
         private Names() { }
     }
 
-    private SpdyHttpHeaders() {
-    }
-
-    /**
-     * Removes the {@code "X-SPDY-Stream-ID"} header.
-     */
-    public static void removeStreamId(HttpMessage message) {
-        message.headers().remove(Names.STREAM_ID);
-    }
-
-    /**
-     * Returns the value of the {@code "X-SPDY-Stream-ID"} header.
-     */
-    public static int getStreamId(HttpMessage message) {
-        return HttpHeaders.getIntHeader(message, Names.STREAM_ID);
-    }
-
-    /**
-     * Sets the {@code "X-SPDY-Stream-ID"} header.
-     */
-    public static void setStreamId(HttpMessage message, int streamId) {
-        HttpHeaders.setIntHeader(message, Names.STREAM_ID, streamId);
-    }
-
-    /**
-     * Removes the {@code "X-SPDY-Associated-To-Stream-ID"} header.
-     */
-    public static void removeAssociatedToStreamId(HttpMessage message) {
-        message.headers().remove(Names.ASSOCIATED_TO_STREAM_ID);
-    }
-
-    /**
-     * Returns the value of the {@code "X-SPDY-Associated-To-Stream-ID"} header.
-     *
-     * @return the header value or {@code 0} if there is no such header or
-     *         if the header value is not a number
-     */
-    public static int getAssociatedToStreamId(HttpMessage message) {
-        return HttpHeaders.getIntHeader(message, Names.ASSOCIATED_TO_STREAM_ID, 0);
-    }
-
-    /**
-     * Sets the {@code "X-SPDY-Associated-To-Stream-ID"} header.
-     */
-    public static void setAssociatedToStreamId(HttpMessage message, int associatedToStreamId) {
-        HttpHeaders.setIntHeader(message, Names.ASSOCIATED_TO_STREAM_ID, associatedToStreamId);
-    }
-
-    /**
-     * Removes the {@code "X-SPDY-Priority"} header.
-     */
-    public static void removePriority(HttpMessage message) {
-        message.headers().remove(Names.PRIORITY);
-    }
-
-    /**
-     * Returns the value of the {@code "X-SPDY-Priority"} header.
-     *
-     * @return the header value or {@code 0} if there is no such header or
-     *         if the header value is not a number
-     */
-    public static byte getPriority(HttpMessage message) {
-        return (byte) HttpHeaders.getIntHeader(message, Names.PRIORITY, 0);
-    }
-
-    /**
-     * Sets the {@code "X-SPDY-Priority"} header.
-     */
-    public static void setPriority(HttpMessage message, byte priority) {
-        HttpHeaders.setIntHeader(message, Names.PRIORITY, priority);
-    }
-
-    /**
-     * Removes the {@code "X-SPDY-URL"} header.
-     */
-    public static void removeUrl(HttpMessage message) {
-        message.headers().remove(Names.URL);
-    }
-
-    /**
-     * Returns the value of the {@code "X-SPDY-URL"} header.
-     */
-    public static String getUrl(HttpMessage message) {
-        return message.headers().get(Names.URL);
-    }
-
-    /**
-     * Sets the {@code "X-SPDY-URL"} header.
-     */
-    public static void setUrl(HttpMessage message, String url) {
-        message.headers().set(Names.URL, url);
-    }
-
-    /**
-     * Removes the {@code "X-SPDY-Scheme"} header.
-     */
-    public static void removeScheme(HttpMessage message) {
-        message.headers().remove(Names.SCHEME);
-    }
-
-    /**
-     * Returns the value of the {@code "X-SPDY-Scheme"} header.
-     */
-    public static String getScheme(HttpMessage message) {
-        return message.headers().get(Names.SCHEME);
-    }
-
-    /**
-     * Sets the {@code "X-SPDY-Scheme"} header.
-     */
-    public static void setScheme(HttpMessage message, String scheme) {
-        message.headers().set(Names.SCHEME, scheme);
-    }
+    private SpdyHttpHeaders() { }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
index 51834a281c3e..06f02adef718 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
@@ -17,7 +17,9 @@
 
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageCodec;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMessage;
+import io.netty.handler.codec.spdy.SpdyHttpHeaders.Names;
 import io.netty.util.ReferenceCountUtil;
 
 import java.util.LinkedList;
@@ -43,7 +45,7 @@ public boolean acceptInboundMessage(Object msg) throws Exception {
     protected void encode(ChannelHandlerContext ctx, HttpMessage msg, List<Object> out) throws Exception {
         Integer id = ids.poll();
         if (id != null && id.intValue() != NO_ID && !msg.headers().contains(SpdyHttpHeaders.Names.STREAM_ID)) {
-            SpdyHttpHeaders.setStreamId(msg, id);
+            HttpHeaders.setIntHeader(msg, Names.STREAM_ID, id);
         }
 
         out.add(ReferenceCountUtil.retain(msg));
@@ -56,10 +58,10 @@ protected void decode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
             if (!contains) {
                 ids.add(NO_ID);
             } else {
-                ids.add(SpdyHttpHeaders.getStreamId((HttpMessage) msg));
+                ids.add(HttpHeaders.getIntHeader((HttpMessage) msg, Names.STREAM_ID));
             }
         } else if (msg instanceof SpdyRstStreamFrame) {
-            ids.remove(((SpdyRstStreamFrame) msg).getStreamId());
+            ids.remove(((SpdyRstStreamFrame) msg).streamId());
         }
 
         out.add(ReferenceCountUtil.retain(msg));
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
index 8010f92db59c..022071aec129 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -26,9 +26,8 @@
 import io.netty.handler.codec.http.HttpResponseEncoder;
 import io.netty.handler.ssl.SslHandler;
 
-import java.util.List;
-
 import javax.net.ssl.SSLEngine;
+import java.util.List;
 
 /**
  * {@link ChannelInboundHandler} which is responsible to setup the {@link ChannelPipeline} either for
@@ -40,7 +39,6 @@ public abstract class SpdyOrHttpChooser extends ByteToMessageDecoder {
     // TODO: Replace with generic NPN handler
 
     public enum SelectedProtocol {
-        SPDY_3("spdy/3"),
         SPDY_3_1("spdy/3.1"),
         HTTP_1_1("http/1.1"),
         HTTP_1_0("http/1.0"),
@@ -113,9 +111,6 @@ private boolean initPipeline(ChannelHandlerContext ctx) {
         case UNKNOWN:
             // Not done with choosing the protocol, so just return here for now,
             return false;
-        case SPDY_3:
-            addSpdyHandlers(ctx, SpdyVersion.SPDY_3);
-            break;
         case SPDY_3_1:
             addSpdyHandlers(ctx, SpdyVersion.SPDY_3_1);
             break;
@@ -134,8 +129,7 @@ private boolean initPipeline(ChannelHandlerContext ctx) {
      */
     protected void addSpdyHandlers(ChannelHandlerContext ctx, SpdyVersion version) {
         ChannelPipeline pipeline = ctx.pipeline();
-        pipeline.addLast("spdyDecoder", new SpdyFrameDecoder(version));
-        pipeline.addLast("spdyEncoder", new SpdyFrameEncoder(version));
+        pipeline.addLast("spdyFrameCodec", new SpdyFrameCodec(version));
         pipeline.addLast("spdySessionHandler", new SpdySessionHandler(version, true));
         pipeline.addLast("spdyHttpEncoder", new SpdyHttpEncoder(version));
         pipeline.addLast("spdyHttpDecoder", new SpdyHttpDecoder(version, maxSpdyContentLength));
@@ -163,8 +157,7 @@ protected void addHttpHandlers(ChannelHandlerContext ctx) {
 
     /**
      * Create the {@link ChannelInboundHandler} that is responsible for handling the http responses
-     * when the {@link SelectedProtocol} was {@link SelectedProtocol#SPDY_3} or
-     * {@link SelectedProtocol#SPDY_3_1}.
+     * when the {@link SelectedProtocol} was {@link SelectedProtocol#SPDY_3_1}.
      *
      * By default this getMethod will just delecate to {@link #createHttpRequestHandlerForHttp()}, but sub-classes may
      * override this to change the behaviour.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java
index d2e98e67b9a3..fc124f8d311b 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java
@@ -23,7 +23,7 @@ public interface SpdyPingFrame extends SpdyFrame {
     /**
      * Returns the ID of this frame.
      */
-    int getId();
+    int id();
 
     /**
      * Sets the ID of this frame.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java
index 0500058b1163..2b5bcbcec2fa 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -15,10 +15,6 @@
  */
 package io.netty.handler.codec.spdy;
 
-/**
- * An {@link Exception} which is thrown when the received frame cannot
- * be decoded by the {@link SpdyFrameDecoder}.
- */
 public class SpdyProtocolException extends Exception {
 
     private static final long serialVersionUID = 7870000537743847264L;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java
index fbab068e8daa..44cadb2c608a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java
@@ -23,7 +23,7 @@ public interface SpdyRstStreamFrame extends SpdyStreamFrame {
     /**
      * Returns the status of this frame.
      */
-    SpdyStreamStatus getStatus();
+    SpdyStreamStatus status();
 
     /**
      * Sets the status of this frame.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
index 0cd1ec6852bf..e447bda73f9b 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
@@ -18,6 +18,7 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.util.internal.PlatformDependent;
 
+import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Map;
 import java.util.Queue;
@@ -37,7 +38,7 @@ final class SpdySession {
     private final AtomicInteger sendWindowSize;
     private final AtomicInteger receiveWindowSize;
 
-    public SpdySession(int sendWindowSize, int receiveWindowSize) {
+    SpdySession(int sendWindowSize, int receiveWindowSize) {
         this.sendWindowSize = new AtomicInteger(sendWindowSize);
         this.receiveWindowSize = new AtomicInteger(receiveWindowSize);
     }
@@ -320,7 +321,10 @@ void clearPendingWrites(Throwable cause) {
         }
     }
 
-    private final class PriorityComparator implements Comparator<Integer> {
+    private final class PriorityComparator implements Comparator<Integer>, Serializable {
+
+        private static final long serialVersionUID = 1161471649740544848L;
+
         @Override
         public int compare(Integer id1, Integer id2) {
             StreamState state1 = activeStreams.get(id1);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
index b7689fb88176..dbffe5428f6a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
@@ -24,13 +24,12 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static io.netty.handler.codec.spdy.SpdyCodecUtil.SPDY_SESSION_STREAM_ID;
+import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 
 /**
  * Manages streams within a SPDY session.
  */
-public class SpdySessionHandler
-        extends ChannelDuplexHandler {
+public class SpdySessionHandler extends ChannelDuplexHandler {
 
     private static final SpdyProtocolException PROTOCOL_EXCEPTION = new SpdyProtocolException();
     private static final SpdyProtocolException STREAM_CLOSED = new SpdyProtocolException("Stream closed");
@@ -43,6 +42,7 @@ public class SpdySessionHandler
     private static final int DEFAULT_WINDOW_SIZE = 64 * 1024; // 64 KB default initial window size
     private int initialSendWindowSize    = DEFAULT_WINDOW_SIZE;
     private int initialReceiveWindowSize = DEFAULT_WINDOW_SIZE;
+    private volatile int initialSessionReceiveWindowSize = DEFAULT_WINDOW_SIZE;
 
     private final SpdySession spdySession = new SpdySession(initialSendWindowSize, initialReceiveWindowSize);
     private int lastGoodStreamId;
@@ -62,7 +62,6 @@ public class SpdySessionHandler
 
     private final boolean server;
     private final int minorVersion;
-    private final boolean sessionFlowControl;
 
     /**
      * Creates a new session handler.
@@ -79,7 +78,19 @@ public SpdySessionHandler(SpdyVersion version, boolean server) {
         }
         this.server = server;
         minorVersion = version.getMinorVersion();
-        sessionFlowControl = version.useSessionFlowControl();
+    }
+
+    public void setSessionReceiveWindowSize(int sessionReceiveWindowSize) {
+      if (sessionReceiveWindowSize < 0) {
+        throw new IllegalArgumentException("sessionReceiveWindowSize");
+      }
+      // This will not send a window update frame immediately.
+      // If this value increases the allowed receive window size,
+      // a WINDOW_UPDATE frame will be sent when only half of the
+      // session window size remains during data frame processing.
+      // If this value decreases the allowed receive window size,
+      // the window will be reduced as data frames are processed.
+      initialSessionReceiveWindowSize = sessionReceiveWindowSize;
     }
 
     @Override
@@ -109,27 +120,25 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
              * a RST_STREAM frame with the getStatus PROTOCOL_ERROR.
              */
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-            int streamId = spdyDataFrame.getStreamId();
+            int streamId = spdyDataFrame.streamId();
 
-            if (sessionFlowControl) {
-                int deltaWindowSize = -1 * spdyDataFrame.content().readableBytes();
-                int newSessionWindowSize =
-                    spdySession.updateReceiveWindowSize(SPDY_SESSION_STREAM_ID, deltaWindowSize);
+            int deltaWindowSize = -1 * spdyDataFrame.content().readableBytes();
+            int newSessionWindowSize =
+                spdySession.updateReceiveWindowSize(SPDY_SESSION_STREAM_ID, deltaWindowSize);
 
-                // Check if session window size is reduced beyond allowable lower bound
-                if (newSessionWindowSize < 0) {
-                    issueSessionError(ctx, SpdySessionStatus.PROTOCOL_ERROR);
-                    return;
-                }
+            // Check if session window size is reduced beyond allowable lower bound
+            if (newSessionWindowSize < 0) {
+                issueSessionError(ctx, SpdySessionStatus.PROTOCOL_ERROR);
+                return;
+            }
 
-                // Send a WINDOW_UPDATE frame if less than half the session window size remains
-                if (newSessionWindowSize <= initialReceiveWindowSize / 2) {
-                    deltaWindowSize = initialReceiveWindowSize - newSessionWindowSize;
-                    spdySession.updateReceiveWindowSize(SPDY_SESSION_STREAM_ID, deltaWindowSize);
-                    SpdyWindowUpdateFrame spdyWindowUpdateFrame =
-                        new DefaultSpdyWindowUpdateFrame(SPDY_SESSION_STREAM_ID, deltaWindowSize);
-                    ctx.writeAndFlush(spdyWindowUpdateFrame);
-                }
+            // Send a WINDOW_UPDATE frame if less than half the session window size remains
+            if (newSessionWindowSize <= initialSessionReceiveWindowSize / 2) {
+                int sessionDeltaWindowSize = initialSessionReceiveWindowSize - newSessionWindowSize;
+                spdySession.updateReceiveWindowSize(SPDY_SESSION_STREAM_ID, sessionDeltaWindowSize);
+                SpdyWindowUpdateFrame spdyWindowUpdateFrame =
+                    new DefaultSpdyWindowUpdateFrame(SPDY_SESSION_STREAM_ID, sessionDeltaWindowSize);
+                ctx.writeAndFlush(spdyWindowUpdateFrame);
             }
 
             // Check if we received a data frame for a Stream-ID which is not open
@@ -166,7 +175,6 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
              */
 
             // Update receive window size
-            int deltaWindowSize = -1 * spdyDataFrame.content().readableBytes();
             int newWindowSize = spdySession.updateReceiveWindowSize(streamId, deltaWindowSize);
 
             // Window size can become negative if we sent a SETTINGS frame that reduces the
@@ -192,10 +200,10 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
             // Send a WINDOW_UPDATE frame if less than half the stream window size remains
             if (newWindowSize <= initialReceiveWindowSize / 2 && !spdyDataFrame.isLast()) {
-                deltaWindowSize = initialReceiveWindowSize - newWindowSize;
-                spdySession.updateReceiveWindowSize(streamId, deltaWindowSize);
+                int streamDeltaWindowSize = initialReceiveWindowSize - newWindowSize;
+                spdySession.updateReceiveWindowSize(streamId, streamDeltaWindowSize);
                 SpdyWindowUpdateFrame spdyWindowUpdateFrame =
-                        new DefaultSpdyWindowUpdateFrame(streamId, deltaWindowSize);
+                        new DefaultSpdyWindowUpdateFrame(streamId, streamDeltaWindowSize);
                 ctx.writeAndFlush(spdyWindowUpdateFrame);
             }
 
@@ -221,7 +229,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
              */
 
             SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
-            int streamId = spdySynStreamFrame.getStreamId();
+            int streamId = spdySynStreamFrame.streamId();
 
             // Check if we received a valid SYN_STREAM frame
             if (spdySynStreamFrame.isInvalid() ||
@@ -238,7 +246,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
             }
 
             // Try to accept the stream
-            byte priority = spdySynStreamFrame.getPriority();
+            byte priority = spdySynStreamFrame.priority();
             boolean remoteSideClosed = spdySynStreamFrame.isLast();
             boolean localSideClosed = spdySynStreamFrame.isUnidirectional();
             if (!acceptStream(streamId, priority, remoteSideClosed, localSideClosed)) {
@@ -256,7 +264,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
              */
 
             SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
-            int streamId = spdySynReplyFrame.getStreamId();
+            int streamId = spdySynReplyFrame.streamId();
 
             // Check if we received a valid SYN_REPLY frame
             if (spdySynReplyFrame.isInvalid() ||
@@ -291,7 +299,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
              */
 
             SpdyRstStreamFrame spdyRstStreamFrame = (SpdyRstStreamFrame) msg;
-            removeStream(spdyRstStreamFrame.getStreamId(), ctx.newSucceededFuture());
+            removeStream(spdyRstStreamFrame.streamId(), ctx.newSucceededFuture());
 
         } else if (msg instanceof SpdySettingsFrame) {
 
@@ -337,7 +345,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
             SpdyPingFrame spdyPingFrame = (SpdyPingFrame) msg;
 
-            if (isRemoteInitiatedId(spdyPingFrame.getId())) {
+            if (isRemoteInitiatedId(spdyPingFrame.id())) {
                 ctx.writeAndFlush(spdyPingFrame);
                 return;
             }
@@ -355,7 +363,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         } else if (msg instanceof SpdyHeadersFrame) {
 
             SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-            int streamId = spdyHeadersFrame.getStreamId();
+            int streamId = spdyHeadersFrame.streamId();
 
             // Check if we received a valid HEADERS frame
             if (spdyHeadersFrame.isInvalid()) {
@@ -386,8 +394,8 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
              */
 
             SpdyWindowUpdateFrame spdyWindowUpdateFrame = (SpdyWindowUpdateFrame) msg;
-            int streamId = spdyWindowUpdateFrame.getStreamId();
-            int deltaWindowSize = spdyWindowUpdateFrame.getDeltaWindowSize();
+            int streamId = spdyWindowUpdateFrame.streamId();
+            int deltaWindowSize = spdyWindowUpdateFrame.deltaWindowSize();
 
             // Ignore frames for half-closed streams
             if (streamId != SPDY_SESSION_STREAM_ID && spdySession.isLocalSideClosed(streamId)) {
@@ -454,7 +462,7 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg, Channe
         if (msg instanceof SpdyDataFrame) {
 
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-            int streamId = spdyDataFrame.getStreamId();
+            int streamId = spdyDataFrame.streamId();
 
             // Frames must not be sent on half-closed streams
             if (spdySession.isLocalSideClosed(streamId)) {
@@ -479,11 +487,8 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg, Channe
             synchronized (flowControlLock) {
                 int dataLength = spdyDataFrame.content().readableBytes();
                 int sendWindowSize = spdySession.getSendWindowSize(streamId);
-
-                if (sessionFlowControl) {
-                    int sessionSendWindowSize = spdySession.getSendWindowSize(SPDY_SESSION_STREAM_ID);
-                    sendWindowSize = Math.min(sendWindowSize, sessionSendWindowSize);
-                }
+                int sessionSendWindowSize = spdySession.getSendWindowSize(SPDY_SESSION_STREAM_ID);
+                sendWindowSize = Math.min(sendWindowSize, sessionSendWindowSize);
 
                 if (sendWindowSize <= 0) {
                     // Stream is stalled -- enqueue Data frame and return
@@ -492,9 +497,7 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg, Channe
                 } else if (sendWindowSize < dataLength) {
                     // Stream is not stalled but we cannot send the entire frame
                     spdySession.updateSendWindowSize(streamId, -1 * sendWindowSize);
-                    if (sessionFlowControl) {
-                        spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * sendWindowSize);
-                    }
+                    spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * sendWindowSize);
 
                     // Create a partial data frame whose length is the current window size
                     SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamId,
@@ -518,9 +521,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                 } else {
                     // Window size is large enough to send entire data frame
                     spdySession.updateSendWindowSize(streamId, -1 * dataLength);
-                    if (sessionFlowControl) {
-                        spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * dataLength);
-                    }
+                    spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * dataLength);
 
                     // The transfer window size is pre-decremented when sending a data frame downstream.
                     // Close the session on write failures that leave the transfer window in a corrupt state.
@@ -544,14 +545,14 @@ public void operationComplete(ChannelFuture future) throws Exception {
         } else if (msg instanceof SpdySynStreamFrame) {
 
             SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
-            int streamId = spdySynStreamFrame.getStreamId();
+            int streamId = spdySynStreamFrame.streamId();
 
             if (isRemoteInitiatedId(streamId)) {
                 promise.setFailure(PROTOCOL_EXCEPTION);
                 return;
             }
 
-            byte priority = spdySynStreamFrame.getPriority();
+            byte priority = spdySynStreamFrame.priority();
             boolean remoteSideClosed = spdySynStreamFrame.isUnidirectional();
             boolean localSideClosed = spdySynStreamFrame.isLast();
             if (!acceptStream(streamId, priority, remoteSideClosed, localSideClosed)) {
@@ -562,7 +563,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
         } else if (msg instanceof SpdySynReplyFrame) {
 
             SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
-            int streamId = spdySynReplyFrame.getStreamId();
+            int streamId = spdySynReplyFrame.streamId();
 
             // Frames must not be sent on half-closed streams
             if (!isRemoteInitiatedId(streamId) || spdySession.isLocalSideClosed(streamId)) {
@@ -578,7 +579,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
         } else if (msg instanceof SpdyRstStreamFrame) {
 
             SpdyRstStreamFrame spdyRstStreamFrame = (SpdyRstStreamFrame) msg;
-            removeStream(spdyRstStreamFrame.getStreamId(), promise);
+            removeStream(spdyRstStreamFrame.streamId(), promise);
 
         } else if (msg instanceof SpdySettingsFrame) {
 
@@ -614,9 +615,9 @@ public void operationComplete(ChannelFuture future) throws Exception {
         } else if (msg instanceof SpdyPingFrame) {
 
             SpdyPingFrame spdyPingFrame = (SpdyPingFrame) msg;
-            if (isRemoteInitiatedId(spdyPingFrame.getId())) {
+            if (isRemoteInitiatedId(spdyPingFrame.id())) {
                 ctx.fireExceptionCaught(new IllegalArgumentException(
-                            "invalid PING ID: " + spdyPingFrame.getId()));
+                            "invalid PING ID: " + spdyPingFrame.id()));
                 return;
             }
             pings.getAndIncrement();
@@ -631,7 +632,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
         } else if (msg instanceof SpdyHeadersFrame) {
 
             SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-            int streamId = spdyHeadersFrame.getStreamId();
+            int streamId = spdyHeadersFrame.streamId();
 
             // Frames must not be sent on half-closed streams
             if (spdySession.isLocalSideClosed(streamId)) {
@@ -697,7 +698,7 @@ private void issueStreamError(ChannelHandlerContext ctx, int streamId, SpdyStrea
      */
 
     private boolean isRemoteInitiatedId(int id) {
-        boolean serverId = SpdyCodecUtil.isServerId(id);
+        boolean serverId = isServerId(id);
         return server && !serverId || !server && serverId;
     }
 
@@ -759,7 +760,7 @@ private void removeStream(int streamId, ChannelFuture future) {
     private void updateSendWindowSize(final ChannelHandlerContext ctx, int streamId, int deltaWindowSize) {
         synchronized (flowControlLock) {
             int newWindowSize = spdySession.updateSendWindowSize(streamId, deltaWindowSize);
-            if (sessionFlowControl && streamId != SPDY_SESSION_STREAM_ID) {
+            if (streamId != SPDY_SESSION_STREAM_ID) {
                 int sessionSendWindowSize = spdySession.getSendWindowSize(SPDY_SESSION_STREAM_ID);
                 newWindowSize = Math.min(newWindowSize, sessionSendWindowSize);
             }
@@ -773,8 +774,8 @@ private void updateSendWindowSize(final ChannelHandlerContext ctx, int streamId,
 
                 SpdyDataFrame spdyDataFrame = pendingWrite.spdyDataFrame;
                 int dataFrameSize = spdyDataFrame.content().readableBytes();
-                int writeStreamId = spdyDataFrame.getStreamId();
-                if (sessionFlowControl && streamId == SPDY_SESSION_STREAM_ID) {
+                int writeStreamId = spdyDataFrame.streamId();
+                if (streamId == SPDY_SESSION_STREAM_ID) {
                     newWindowSize = Math.min(newWindowSize, spdySession.getSendWindowSize(writeStreamId));
                 }
 
@@ -782,11 +783,9 @@ private void updateSendWindowSize(final ChannelHandlerContext ctx, int streamId,
                     // Window size is large enough to send entire data frame
                     spdySession.removePendingWrite(writeStreamId);
                     newWindowSize = spdySession.updateSendWindowSize(writeStreamId, -1 * dataFrameSize);
-                    if (sessionFlowControl) {
-                        int sessionSendWindowSize =
-                                spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * dataFrameSize);
-                        newWindowSize = Math.min(newWindowSize, sessionSendWindowSize);
-                    }
+                    int sessionSendWindowSize =
+                            spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * dataFrameSize);
+                    newWindowSize = Math.min(newWindowSize, sessionSendWindowSize);
 
                     // Close the local side of the stream if this is the last frame
                     if (spdyDataFrame.isLast()) {
@@ -806,9 +805,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                 } else {
                     // We can send a partial frame
                     spdySession.updateSendWindowSize(writeStreamId, -1 * newWindowSize);
-                    if (sessionFlowControl) {
-                        spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * newWindowSize);
-                    }
+                    spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * newWindowSize);
 
                     // Create a partial data frame whose length is the current window size
                     SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(writeStreamId,
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java
index 577f99f390cf..fd79d1ed1257 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java
@@ -76,20 +76,20 @@ public SpdySessionStatus(int code, String statusPhrase) {
     /**
      * Returns the code of this status.
      */
-    public int getCode() {
+    public int code() {
         return code;
     }
 
     /**
      * Returns the status phrase of this status.
      */
-    public String getStatusPhrase() {
+    public String statusPhrase() {
         return statusPhrase;
     }
 
     @Override
     public int hashCode() {
-        return getCode();
+        return code();
     }
 
     @Override
@@ -98,16 +98,16 @@ public boolean equals(Object o) {
             return false;
         }
 
-        return getCode() == ((SpdySessionStatus) o).getCode();
+        return code() == ((SpdySessionStatus) o).code();
     }
 
     @Override
     public String toString() {
-        return getStatusPhrase();
+        return statusPhrase();
     }
 
     @Override
     public int compareTo(SpdySessionStatus o) {
-        return getCode() - o.getCode();
+        return code() - o.code();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySettingsFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySettingsFrame.java
index 92aa8cc563a1..e24f41a0200f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySettingsFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySettingsFrame.java
@@ -36,7 +36,7 @@ public interface SpdySettingsFrame extends SpdyFrame {
      * Returns a {@code Set} of the setting IDs.
      * The set's iterator will return the IDs in ascending order.
      */
-    Set<Integer> getIds();
+    Set<Integer> ids();
 
     /**
      * Returns {@code true} if the setting ID has a value.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamFrame.java
index e5299f9ae957..09c9f2a17911 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamFrame.java
@@ -23,7 +23,7 @@ public interface SpdyStreamFrame extends SpdyFrame {
     /**
      * Returns the Stream-ID of this frame.
      */
-    int getStreamId();
+    int streamId();
 
     /**
      * Sets the Stream-ID of this frame.  The Stream-ID must be positive.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamStatus.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamStatus.java
index ccb0d814d2a8..75ed740a2af3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamStatus.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamStatus.java
@@ -150,20 +150,20 @@ public SpdyStreamStatus(int code, String statusPhrase) {
     /**
      * Returns the code of this status.
      */
-    public int getCode() {
+    public int code() {
         return code;
     }
 
     /**
      * Returns the status phrase of this status.
      */
-    public String getStatusPhrase() {
+    public String statusPhrase() {
         return statusPhrase;
     }
 
     @Override
     public int hashCode() {
-        return getCode();
+        return code();
     }
 
     @Override
@@ -172,16 +172,16 @@ public boolean equals(Object o) {
             return false;
         }
 
-        return getCode() == ((SpdyStreamStatus) o).getCode();
+        return code() == ((SpdyStreamStatus) o).code();
     }
 
     @Override
     public String toString() {
-        return getStatusPhrase();
+        return statusPhrase();
     }
 
     @Override
     public int compareTo(SpdyStreamStatus o) {
-        return getCode() - o.getCode();
+        return code() - o.code();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynStreamFrame.java
index b4e6331f02b5..f2efb8cabe46 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynStreamFrame.java
@@ -23,18 +23,18 @@ public interface SpdySynStreamFrame extends SpdyHeadersFrame {
     /**
      * Returns the Associated-To-Stream-ID of this frame.
      */
-    int getAssociatedToStreamId();
+    int associatedStreamId();
 
     /**
      * Sets the Associated-To-Stream-ID of this frame.
      * The Associated-To-Stream-ID cannot be negative.
      */
-    SpdySynStreamFrame setAssociatedToStreamId(int associatedToStreamId);
+    SpdySynStreamFrame setAssociatedStreamId(int associatedStreamId);
 
     /**
      * Returns the priority of the stream.
      */
-    byte getPriority();
+    byte priority();
 
     /**
      * Sets the priority of the stream.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyVersion.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyVersion.java
index f3adac287cfc..030ee94ec10f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyVersion.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyVersion.java
@@ -16,17 +16,14 @@
 package io.netty.handler.codec.spdy;
 
 public enum SpdyVersion {
-    SPDY_3   (3, 0, false),
-    SPDY_3_1 (3, 1, true);
+    SPDY_3_1 (3, 1);
 
     private final int version;
     private final int minorVersion;
-    private final boolean sessionFlowControl;
 
-    private SpdyVersion(int version, int minorVersion, boolean sessionFlowControl) {
+    SpdyVersion(int version, int minorVersion) {
         this.version = version;
         this.minorVersion = minorVersion;
-        this.sessionFlowControl = sessionFlowControl;
     }
 
     int getVersion() {
@@ -36,8 +33,4 @@ int getVersion() {
     int getMinorVersion() {
         return minorVersion;
     }
-
-    boolean useSessionFlowControl() {
-        return sessionFlowControl;
-    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyWindowUpdateFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyWindowUpdateFrame.java
index 587b1f66d2e3..bbd8730bd047 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyWindowUpdateFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyWindowUpdateFrame.java
@@ -23,7 +23,7 @@ public interface SpdyWindowUpdateFrame extends SpdyFrame {
     /**
      * Returns the Stream-ID of this frame.
      */
-    int getStreamId();
+    int streamId();
 
     /**
      * Sets the Stream-ID of this frame.  The Stream-ID cannot be negative.
@@ -33,7 +33,7 @@ public interface SpdyWindowUpdateFrame extends SpdyFrame {
     /**
      * Returns the Delta-Window-Size of this frame.
      */
-    int getDeltaWindowSize();
+    int deltaWindowSize();
 
     /**
      * Sets the Delta-Window-Size of this frame.
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java
index 4c14954e11df..913c7a160ae6 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import static org.junit.Assert.*;
+import org.junit.Test;
 
 import java.util.Calendar;
 import java.util.Date;
@@ -23,7 +23,7 @@
 import java.util.Set;
 import java.util.TimeZone;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class CookieDecoderTest {
     @Test
@@ -36,27 +36,27 @@ public void testDecodingSingleCookieV0() {
         assertEquals(1, cookies.size());
         Cookie cookie = cookies.iterator().next();
         assertNotNull(cookie);
-        assertEquals("myValue", cookie.getValue());
-        assertNull(cookie.getComment());
-        assertNull(cookie.getCommentUrl());
-        assertEquals(".adomainsomewhere", cookie.getDomain());
+        assertEquals("myValue", cookie.value());
+        assertNull(cookie.comment());
+        assertNull(cookie.commentUrl());
+        assertEquals(".adomainsomewhere", cookie.domain());
         assertFalse(cookie.isDiscard());
 
         boolean fail = true;
         for (int i = 40; i <= 60; i ++) {
-            if (cookie.getMaxAge() == i) {
+            if (cookie.maxAge() == i) {
                 fail = false;
                 break;
             }
         }
         if (fail) {
-            fail("expected: 50, actual: " + cookie.getMaxAge());
+            fail("expected: 50, actual: " + cookie.maxAge());
         }
 
-        assertEquals("/apathsomewhere", cookie.getPath());
-        assertTrue(cookie.getPorts().isEmpty());
+        assertEquals("/apathsomewhere", cookie.path());
+        assertTrue(cookie.ports().isEmpty());
         assertTrue(cookie.isSecure());
-        assertEquals(0, cookie.getVersion());
+        assertEquals(0, cookie.version());
     }
 
     @Test
@@ -68,16 +68,16 @@ public void testDecodingSingleCookieV0ExtraParamsIgnored() {
         assertEquals(1, cookies.size());
         Cookie cookie = cookies.iterator().next();
         assertNotNull(cookie);
-        assertEquals("myValue", cookie.getValue());
-        assertNull(cookie.getComment());
-        assertNull(cookie.getCommentUrl());
-        assertEquals(".adomainsomewhere", cookie.getDomain());
+        assertEquals("myValue", cookie.value());
+        assertNull(cookie.comment());
+        assertNull(cookie.commentUrl());
+        assertEquals(".adomainsomewhere", cookie.domain());
         assertFalse(cookie.isDiscard());
-        assertEquals(50, cookie.getMaxAge());
-        assertEquals("/apathsomewhere", cookie.getPath());
-        assertTrue(cookie.getPorts().isEmpty());
+        assertEquals(50, cookie.maxAge());
+        assertEquals("/apathsomewhere", cookie.path());
+        assertTrue(cookie.ports().isEmpty());
         assertTrue(cookie.isSecure());
-        assertEquals(0, cookie.getVersion());
+        assertEquals(0, cookie.version());
     }
     @Test
     public void testDecodingSingleCookieV1() {
@@ -86,17 +86,17 @@ public void testDecodingSingleCookieV1() {
         Set<Cookie> cookies = CookieDecoder.decode(cookieString);
         assertEquals(1, cookies.size());
         Cookie cookie = cookies.iterator().next();
-        assertEquals("myValue", cookie.getValue());
+        assertEquals("myValue", cookie.value());
         assertNotNull(cookie);
-        assertEquals("this is a comment", cookie.getComment());
-        assertNull(cookie.getCommentUrl());
-        assertEquals(".adomainsomewhere", cookie.getDomain());
+        assertEquals("this is a comment", cookie.comment());
+        assertNull(cookie.commentUrl());
+        assertEquals(".adomainsomewhere", cookie.domain());
         assertFalse(cookie.isDiscard());
-        assertEquals(50, cookie.getMaxAge());
-        assertEquals("/apathsomewhere", cookie.getPath());
-        assertTrue(cookie.getPorts().isEmpty());
+        assertEquals(50, cookie.maxAge());
+        assertEquals("/apathsomewhere", cookie.path());
+        assertTrue(cookie.ports().isEmpty());
         assertTrue(cookie.isSecure());
-        assertEquals(1, cookie.getVersion());
+        assertEquals(1, cookie.version());
     }
 
     @Test
@@ -108,16 +108,16 @@ public void testDecodingSingleCookieV1ExtraParamsIgnored() {
         assertEquals(1, cookies.size());
         Cookie cookie = cookies.iterator().next();
         assertNotNull(cookie);
-        assertEquals("myValue", cookie.getValue());
-        assertEquals("this is a comment", cookie.getComment());
-        assertNull(cookie.getCommentUrl());
-        assertEquals(".adomainsomewhere", cookie.getDomain());
+        assertEquals("myValue", cookie.value());
+        assertEquals("this is a comment", cookie.comment());
+        assertNull(cookie.commentUrl());
+        assertEquals(".adomainsomewhere", cookie.domain());
         assertFalse(cookie.isDiscard());
-        assertEquals(50, cookie.getMaxAge());
-        assertEquals("/apathsomewhere", cookie.getPath());
-        assertTrue(cookie.getPorts().isEmpty());
+        assertEquals(50, cookie.maxAge());
+        assertEquals("/apathsomewhere", cookie.path());
+        assertTrue(cookie.ports().isEmpty());
         assertTrue(cookie.isSecure());
-        assertEquals(1, cookie.getVersion());
+        assertEquals(1, cookie.version());
     }
     @Test
     public void testDecodingSingleCookieV2() {
@@ -128,18 +128,18 @@ public void testDecodingSingleCookieV2() {
         assertEquals(1, cookies.size());
         Cookie cookie = cookies.iterator().next();
         assertNotNull(cookie);
-        assertEquals("myValue", cookie.getValue());
-        assertEquals("this is a comment", cookie.getComment());
-        assertEquals("http://aurl.com", cookie.getCommentUrl());
-        assertEquals(".adomainsomewhere", cookie.getDomain());
+        assertEquals("myValue", cookie.value());
+        assertEquals("this is a comment", cookie.comment());
+        assertEquals("http://aurl.com", cookie.commentUrl());
+        assertEquals(".adomainsomewhere", cookie.domain());
         assertTrue(cookie.isDiscard());
-        assertEquals(50, cookie.getMaxAge());
-        assertEquals("/apathsomewhere", cookie.getPath());
-        assertEquals(2, cookie.getPorts().size());
-        assertTrue(cookie.getPorts().contains(80));
-        assertTrue(cookie.getPorts().contains(8080));
+        assertEquals(50, cookie.maxAge());
+        assertEquals("/apathsomewhere", cookie.path());
+        assertEquals(2, cookie.ports().size());
+        assertTrue(cookie.ports().contains(80));
+        assertTrue(cookie.ports().contains(8080));
         assertTrue(cookie.isSecure());
-        assertEquals(2, cookie.getVersion());
+        assertEquals(2, cookie.version());
     }
 
     @Test
@@ -157,42 +157,42 @@ public void testDecodingMultipleCookies() {
         Iterator<Cookie> it = cookies.iterator();
         Cookie cookie = it.next();
         assertNotNull(cookie);
-        assertEquals("myValue", cookie.getValue());
-        assertEquals("this is a comment", cookie.getComment());
-        assertEquals("http://aurl.com", cookie.getCommentUrl());
-        assertEquals(".adomainsomewhere", cookie.getDomain());
+        assertEquals("myValue", cookie.value());
+        assertEquals("this is a comment", cookie.comment());
+        assertEquals("http://aurl.com", cookie.commentUrl());
+        assertEquals(".adomainsomewhere", cookie.domain());
         assertTrue(cookie.isDiscard());
-        assertEquals(50, cookie.getMaxAge());
-        assertEquals("/apathsomewhere", cookie.getPath());
-        assertEquals(2, cookie.getPorts().size());
-        assertTrue(cookie.getPorts().contains(80));
-        assertTrue(cookie.getPorts().contains(8080));
+        assertEquals(50, cookie.maxAge());
+        assertEquals("/apathsomewhere", cookie.path());
+        assertEquals(2, cookie.ports().size());
+        assertTrue(cookie.ports().contains(80));
+        assertTrue(cookie.ports().contains(8080));
         assertTrue(cookie.isSecure());
-        assertEquals(2, cookie.getVersion());
+        assertEquals(2, cookie.version());
         cookie = it.next();
         assertNotNull(cookie);
-        assertEquals("myValue2", cookie.getValue());
-        assertEquals("this is another comment", cookie.getComment());
-        assertEquals("http://anotherurl.com", cookie.getCommentUrl());
-        assertEquals(".anotherdomainsomewhere", cookie.getDomain());
+        assertEquals("myValue2", cookie.value());
+        assertEquals("this is another comment", cookie.comment());
+        assertEquals("http://anotherurl.com", cookie.commentUrl());
+        assertEquals(".anotherdomainsomewhere", cookie.domain());
         assertFalse(cookie.isDiscard());
-        assertEquals(0, cookie.getMaxAge());
-        assertEquals("/anotherpathsomewhere", cookie.getPath());
-        assertTrue(cookie.getPorts().isEmpty());
+        assertEquals(0, cookie.maxAge());
+        assertEquals("/anotherpathsomewhere", cookie.path());
+        assertTrue(cookie.ports().isEmpty());
         assertFalse(cookie.isSecure());
-        assertEquals(2, cookie.getVersion());
+        assertEquals(2, cookie.version());
         cookie = it.next();
         assertNotNull(cookie);
-        assertEquals("myValue3", cookie.getValue());
-        assertNull(cookie.getComment());
-        assertNull(cookie.getCommentUrl());
-        assertNull(cookie.getDomain());
+        assertEquals("myValue3", cookie.value());
+        assertNull(cookie.comment());
+        assertNull(cookie.commentUrl());
+        assertNull(cookie.domain());
         assertFalse(cookie.isDiscard());
-        assertEquals(0, cookie.getMaxAge());
-        assertNull(cookie.getPath());
-        assertTrue(cookie.getPorts().isEmpty());
+        assertEquals(0, cookie.maxAge());
+        assertNull(cookie.path());
+        assertTrue(cookie.ports().isEmpty());
         assertFalse(cookie.isSecure());
-        assertEquals(2, cookie.getVersion());
+        assertEquals(2, cookie.version());
     }
 
     @Test
@@ -206,26 +206,26 @@ public void testDecodingClientSideCookies() {
         Cookie c;
 
         c = it.next();
-        assertEquals(1, c.getVersion());
-        assertEquals("Part_Number", c.getName());
-        assertEquals("Rocket_Launcher_0001", c.getValue());
-        assertEquals("/acme", c.getPath());
-        assertNull(c.getComment());
-        assertNull(c.getCommentUrl());
-        assertNull(c.getDomain());
-        assertTrue(c.getPorts().isEmpty());
-        assertEquals(Long.MIN_VALUE, c.getMaxAge());
+        assertEquals(1, c.version());
+        assertEquals("Part_Number", c.name());
+        assertEquals("Rocket_Launcher_0001", c.value());
+        assertEquals("/acme", c.path());
+        assertNull(c.comment());
+        assertNull(c.commentUrl());
+        assertNull(c.domain());
+        assertTrue(c.ports().isEmpty());
+        assertEquals(Long.MIN_VALUE, c.maxAge());
 
         c = it.next();
-        assertEquals(1, c.getVersion());
-        assertEquals("Part_Number", c.getName());
-        assertEquals("Riding_Rocket_0023", c.getValue());
-        assertEquals("/acme/ammo", c.getPath());
-        assertNull(c.getComment());
-        assertNull(c.getCommentUrl());
-        assertNull(c.getDomain());
-        assertTrue(c.getPorts().isEmpty());
-        assertEquals(Long.MIN_VALUE, c.getMaxAge());
+        assertEquals(1, c.version());
+        assertEquals("Part_Number", c.name());
+        assertEquals("Riding_Rocket_0023", c.value());
+        assertEquals("/acme/ammo", c.path());
+        assertNull(c.comment());
+        assertNull(c.commentUrl());
+        assertNull(c.domain());
+        assertTrue(c.ports().isEmpty());
+        assertEquals(Long.MIN_VALUE, c.maxAge());
 
         assertFalse(it.hasNext());
     }
@@ -242,27 +242,27 @@ public void testDecodingCommaSeparatedClientSideCookies() {
 
         assertTrue(it.hasNext());
         c = it.next();
-        assertEquals(1, c.getVersion());
-        assertEquals("session_id", c.getName());
-        assertEquals("1234", c.getValue());
-        assertNull(c.getPath());
-        assertNull(c.getComment());
-        assertNull(c.getCommentUrl());
-        assertNull(c.getDomain());
-        assertTrue(c.getPorts().isEmpty());
-        assertEquals(Long.MIN_VALUE, c.getMaxAge());
+        assertEquals(1, c.version());
+        assertEquals("session_id", c.name());
+        assertEquals("1234", c.value());
+        assertNull(c.path());
+        assertNull(c.comment());
+        assertNull(c.commentUrl());
+        assertNull(c.domain());
+        assertTrue(c.ports().isEmpty());
+        assertEquals(Long.MIN_VALUE, c.maxAge());
 
         assertTrue(it.hasNext());
         c = it.next();
-        assertEquals(1, c.getVersion());
-        assertEquals("session_id", c.getName());
-        assertEquals("1111", c.getValue());
-        assertEquals(".cracker.edu", c.getDomain());
-        assertNull(c.getPath());
-        assertNull(c.getComment());
-        assertNull(c.getCommentUrl());
-        assertTrue(c.getPorts().isEmpty());
-        assertEquals(Long.MIN_VALUE, c.getMaxAge());
+        assertEquals(1, c.version());
+        assertEquals("session_id", c.name());
+        assertEquals("1111", c.value());
+        assertEquals(".cracker.edu", c.domain());
+        assertNull(c.path());
+        assertNull(c.comment());
+        assertNull(c.commentUrl());
+        assertTrue(c.ports().isEmpty());
+        assertEquals(Long.MIN_VALUE, c.maxAge());
 
         assertFalse(it.hasNext());
     }
@@ -284,36 +284,36 @@ public void testDecodingQuotedCookie() {
         Cookie c;
 
         c = it.next();
-        assertEquals("a", c.getName());
-        assertEquals("", c.getValue());
+        assertEquals("a", c.name());
+        assertEquals("", c.value());
 
         c = it.next();
-        assertEquals("b", c.getName());
-        assertEquals("1", c.getValue());
+        assertEquals("b", c.name());
+        assertEquals("1", c.value());
 
         c = it.next();
-        assertEquals("c", c.getName());
-        assertEquals("\"1\"2\"", c.getValue());
+        assertEquals("c", c.name());
+        assertEquals("\"1\"2\"", c.value());
 
         c = it.next();
-        assertEquals("d", c.getName());
-        assertEquals("1\"2\"3", c.getValue());
+        assertEquals("d", c.name());
+        assertEquals("1\"2\"3", c.value());
 
         c = it.next();
-        assertEquals("e", c.getName());
-        assertEquals("\"\"", c.getValue());
+        assertEquals("e", c.name());
+        assertEquals("\"\"", c.value());
 
         c = it.next();
-        assertEquals("f", c.getName());
-        assertEquals("1\"\"2", c.getValue());
+        assertEquals("f", c.name());
+        assertEquals("1\"\"2", c.value());
 
         c = it.next();
-        assertEquals("g", c.getName());
-        assertEquals("\\", c.getValue());
+        assertEquals("g", c.name());
+        assertEquals("\\", c.value());
 
         c = it.next();
-        assertEquals("h", c.getName());
-        assertEquals("';,\\x", c.getValue());
+        assertEquals("h", c.name());
+        assertEquals("';,\\x", c.value());
 
         assertFalse(it.hasNext());
     }
@@ -332,30 +332,30 @@ public void testDecodingGoogleAnalyticsCookie() {
         Cookie c;
 
         c = it.next();
-        assertEquals("__utma", c.getName());
-        assertEquals("48461872.1094088325.1258140131.1258140131.1258140131.1", c.getValue());
+        assertEquals("__utma", c.name());
+        assertEquals("48461872.1094088325.1258140131.1258140131.1258140131.1", c.value());
 
         c = it.next();
-        assertEquals("__utmb", c.getName());
-        assertEquals("48461872.13.10.1258140131", c.getValue());
+        assertEquals("__utmb", c.name());
+        assertEquals("48461872.13.10.1258140131", c.value());
 
         c = it.next();
-        assertEquals("__utmc", c.getName());
-        assertEquals("48461872", c.getValue());
+        assertEquals("__utmc", c.name());
+        assertEquals("48461872", c.value());
 
         c = it.next();
-        assertEquals("__utmz", c.getName());
+        assertEquals("__utmz", c.name());
         assertEquals("48461872.1258140131.1.1.utmcsr=overstock.com|" +
                 "utmccn=(referral)|utmcmd=referral|utmcct=/Home-Garden/Furniture/Clearance,/clearance,/32/dept.html",
-                c.getValue());
+                c.value());
 
         c = it.next();
-        assertEquals("ARPT", c.getName());
-        assertEquals("LWUKQPSWRTUN04CKKJI", c.getValue());
+        assertEquals("ARPT", c.name());
+        assertEquals("LWUKQPSWRTUN04CKKJI", c.value());
 
         c = it.next();
-        assertEquals("kw-2E343B92-B097-442c-BFA5-BE371E0325A2", c.getName());
-        assertEquals("unfinished furniture", c.getValue());
+        assertEquals("kw-2E343B92-B097-442c-BFA5-BE371E0325A2", c.name());
+        assertEquals("unfinished furniture", c.value());
 
         assertFalse(it.hasNext());
     }
@@ -371,7 +371,7 @@ public void testDecodingLongDates() {
         Set<Cookie> cookies = CookieDecoder.decode(source);
 
         Cookie c = cookies.iterator().next();
-        assertTrue(Math.abs(expectedMaxAge - c.getMaxAge()) < 2);
+        assertTrue(Math.abs(expectedMaxAge - c.maxAge()) < 2);
     }
 
     @Test
@@ -382,7 +382,7 @@ public void testDecodingValueWithComma() {
         Set<Cookie> cookies = CookieDecoder.decode(source);
 
         Cookie c = cookies.iterator().next();
-        assertEquals("timeZoneName=(GMT+04:00) Moscow, St. Petersburg, Volgograd&promocode=&region=BE", c.getValue());
+        assertEquals("timeZoneName=(GMT+04:00) Moscow, St. Petersburg, Volgograd&promocode=&region=BE", c.value());
     }
 
     @Test
@@ -390,9 +390,9 @@ public void testDecodingWeirdNames1() {
         String src = "path=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=.www.google.com";
         Set<Cookie> cookies = CookieDecoder.decode(src);
         Cookie c = cookies.iterator().next();
-        assertEquals("path", c.getName());
-        assertEquals("", c.getValue());
-        assertEquals("/", c.getPath());
+        assertEquals("path", c.name());
+        assertEquals("", c.value());
+        assertEquals("/", c.path());
     }
 
     @Test
@@ -400,8 +400,8 @@ public void testDecodingWeirdNames2() {
         String src = "HTTPOnly=";
         Set<Cookie> cookies = CookieDecoder.decode(src);
         Cookie c = cookies.iterator().next();
-        assertEquals("HTTPOnly", c.getName());
-        assertEquals("", c.getValue());
+        assertEquals("HTTPOnly", c.name());
+        assertEquals("", c.value());
     }
 
     @Test
@@ -410,11 +410,11 @@ public void testDecodingValuesWithCommasAndEquals() {
         Set<Cookie> cookies = CookieDecoder.decode(src);
         Iterator<Cookie> i = cookies.iterator();
         Cookie c = i.next();
-        assertEquals("A", c.getName());
-        assertEquals("v=1&lg=en-US,it-IT,it&intl=it&np=1", c.getValue());
+        assertEquals("A", c.name());
+        assertEquals("v=1&lg=en-US,it-IT,it&intl=it&np=1", c.value());
         c = i.next();
-        assertEquals("T", c.getName());
-        assertEquals("z=E", c.getValue());
+        assertEquals("T", c.name());
+        assertEquals("z=E", c.value());
     }
 
     @Test
@@ -468,7 +468,7 @@ public void testDecodingLongValue() {
         Set<Cookie> cookies = CookieDecoder.decode("bh=\"" + longValue + "\";");
         assertEquals(1, cookies.size());
         Cookie c = cookies.iterator().next();
-        assertEquals("bh", c.getName());
-        assertEquals(longValue, c.getValue());
+        assertEquals("bh", c.name());
+        assertEquals(longValue, c.value());
     }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpChunkedInputTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpChunkedInputTest.java
index c8fc9d526c23..fbf607536aa4 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpChunkedInputTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpChunkedInputTest.java
@@ -15,8 +15,6 @@
  */
 package io.netty.handler.codec.http;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.stream.ChunkedFile;
@@ -25,6 +23,7 @@
 import io.netty.handler.stream.ChunkedNioStream;
 import io.netty.handler.stream.ChunkedStream;
 import io.netty.handler.stream.ChunkedWriteHandler;
+import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -32,7 +31,7 @@
 import java.io.IOException;
 import java.nio.channels.Channels;
 
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class HttpChunkedInputTest {
     private static final byte[] BYTES = new byte[1024 * 64];
@@ -96,13 +95,12 @@ private static void check(ChunkedInput<?>... inputs) {
         int read = 0;
         HttpContent lastHttpContent = null;
         for (;;) {
-            HttpContent httpContent = (HttpContent) ch.readOutbound();
+            HttpContent httpContent = ch.readOutbound();
             if (httpContent == null) {
                 break;
-            } else {
-                if (lastHttpContent != null) {
-                    assertTrue("Chunk must be DefaultHttpContent", lastHttpContent instanceof DefaultHttpContent);
-                }
+            }
+            if (lastHttpContent != null) {
+                assertTrue("Chunk must be DefaultHttpContent", lastHttpContent instanceof DefaultHttpContent);
             }
 
             ByteBuf buffer = httpContent.content();
@@ -120,6 +118,6 @@ private static void check(ChunkedInput<?>... inputs) {
         }
 
         assertEquals(BYTES.length * inputs.length, read);
-        assertTrue("Last chunk must be DefaultLastHttpContent", lastHttpContent == LastHttpContent.EMPTY_LAST_CONTENT);
+        assertSame("Last chunk must be DefaultLastHttpContent", LastHttpContent.EMPTY_LAST_CONTENT, lastHttpContent);
     }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
index f3df9ea7cf40..5d4f5bf0d12e 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
@@ -70,7 +70,7 @@ public void testEmptyContentCompression() throws Exception {
 
         ch.writeOutbound(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK));
 
-        HttpResponse res = (HttpResponse) ch.readOutbound();
+        HttpResponse res = ch.readOutbound();
         assertThat(res, is(not(instanceOf(FullHttpResponse.class))));
         assertThat(res.headers().get(Names.TRANSFER_ENCODING), is("chunked"));
         assertThat(res.headers().get(Names.CONTENT_LENGTH), is(nullValue()));
@@ -79,12 +79,12 @@ public void testEmptyContentCompression() throws Exception {
         ch.writeOutbound(LastHttpContent.EMPTY_LAST_CONTENT);
 
         HttpContent chunk;
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk, is(instanceOf(HttpContent.class)));
         assertThat(chunk.content().isReadable(), is(true));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
         assertThat(chunk.content().isReadable(), is(false));
         chunk.release();
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java
index 094e6080a75a..681e19acfa0c 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java
@@ -57,19 +57,19 @@ public void testSplitContent() throws Exception {
         assertEncodedResponse(ch);
 
         HttpContent chunk;
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("3"));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("2"));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("1"));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().isReadable(), is(false));
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
         chunk.release();
@@ -93,20 +93,20 @@ public void testChunkedContent() throws Exception {
         ch.writeOutbound(new DefaultLastHttpContent(Unpooled.wrappedBuffer(new byte[1])));
 
         HttpContent chunk;
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("3"));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("2"));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("1"));
         assertThat(chunk, is(instanceOf(HttpContent.class)));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().isReadable(), is(false));
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
         chunk.release();
@@ -132,20 +132,20 @@ public void testChunkedContentWithTrailingHeader() throws Exception {
         ch.writeOutbound(content);
 
         HttpContent chunk;
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("3"));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("2"));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("1"));
         assertThat(chunk, is(instanceOf(HttpContent.class)));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().isReadable(), is(false));
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
         assertEquals("Netty", ((LastHttpContent) chunk).trailingHeaders().get("X-Test"));
@@ -165,12 +165,12 @@ public void testFullContent() throws Exception {
         ch.writeOutbound(res);
 
         assertEncodedResponse(ch);
-        HttpContent c = (HttpContent) ch.readOutbound();
+        HttpContent c = ch.readOutbound();
         assertThat(c.content().readableBytes(), is(2));
         assertThat(c.content().toString(CharsetUtil.US_ASCII), is("42"));
         c.release();
 
-        LastHttpContent last = (LastHttpContent) ch.readOutbound();
+        LastHttpContent last = ch.readOutbound();
         assertThat(last.content().readableBytes(), is(0));
         last.release();
 
@@ -190,12 +190,12 @@ public void testEmptySplitContent() throws Exception {
         assertEncodedResponse(ch);
 
         ch.writeOutbound(LastHttpContent.EMPTY_LAST_CONTENT);
-        HttpContent chunk = (HttpContent) ch.readOutbound();
+        HttpContent chunk = ch.readOutbound();
         assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("0"));
         assertThat(chunk, is(instanceOf(HttpContent.class)));
         chunk.release();
 
-        chunk = (HttpContent) ch.readOutbound();
+        chunk = ch.readOutbound();
         assertThat(chunk.content().isReadable(), is(false));
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
         chunk.release();
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java
index 5a6fe025d934..4f4a6e0fb39e 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java
@@ -15,11 +15,12 @@
  */
 package io.netty.handler.codec.http;
 
+import org.junit.Test;
+
 import java.text.ParseException;
 import java.util.Date;
 
-import org.junit.Assert;
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class HttpHeaderDateFormatTest {
     /**
@@ -35,28 +36,24 @@ public void testParse() throws ParseException {
         HttpHeaderDateFormat format = HttpHeaderDateFormat.get();
 
         final Date parsedDateWithSingleDigitDay = format.parse("Sun, 6 Nov 1994 08:49:37 GMT");
-        Assert.assertNotNull(parsedDateWithSingleDigitDay);
-        Assert.assertEquals(DATE, parsedDateWithSingleDigitDay);
+        assertNotNull(parsedDateWithSingleDigitDay);
+        assertEquals(DATE, parsedDateWithSingleDigitDay);
 
         final Date parsedDateWithDoubleDigitDay = format.parse("Sun, 06 Nov 1994 08:49:37 GMT");
-        Assert.assertNotNull(parsedDateWithDoubleDigitDay);
-        Assert.assertEquals(DATE, parsedDateWithDoubleDigitDay);
+        assertNotNull(parsedDateWithDoubleDigitDay);
+        assertEquals(DATE, parsedDateWithDoubleDigitDay);
 
         final Date parsedDateWithDashSeparatorSingleDigitDay = format.parse("Sunday, 06-Nov-94 08:49:37 GMT");
-        Assert.assertNotNull(parsedDateWithDashSeparatorSingleDigitDay);
-        Assert.assertEquals(DATE, parsedDateWithDashSeparatorSingleDigitDay);
+        assertNotNull(parsedDateWithDashSeparatorSingleDigitDay);
+        assertEquals(DATE, parsedDateWithDashSeparatorSingleDigitDay);
 
         final Date parsedDateWithSingleDoubleDigitDay = format.parse("Sunday, 6-Nov-94 08:49:37 GMT");
-        Assert.assertNotNull(parsedDateWithSingleDoubleDigitDay);
-        Assert.assertEquals(DATE, parsedDateWithSingleDoubleDigitDay);
+        assertNotNull(parsedDateWithSingleDoubleDigitDay);
+        assertEquals(DATE, parsedDateWithSingleDoubleDigitDay);
 
         final Date parsedDateWithoutGMT = format.parse("Sun Nov 6 08:49:37 1994");
-        Assert.assertNotNull(parsedDateWithoutGMT);
-        Assert.assertEquals(DATE, parsedDateWithoutGMT);
-    }
-
-    private Date parseDate(HttpHeaderDateFormat dateFormat, String dateStr) throws ParseException {
-        return dateFormat.parse(dateStr);
+        assertNotNull(parsedDateWithoutGMT);
+        assertEquals(DATE, parsedDateWithoutGMT);
     }
 
     @Test
@@ -64,7 +61,7 @@ public void testFormat() {
         HttpHeaderDateFormat format = HttpHeaderDateFormat.get();
 
         final String formatted = format.format(DATE);
-        Assert.assertNotNull(formatted);
-        Assert.assertEquals("Sun, 06 Nov 1994 08:49:37 GMT", formatted);
+        assertNotNull(formatted);
+        assertEquals("Sun, 06 Nov 1994 08:49:37 GMT", formatted);
     }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java
index 5d9872690575..fa67920f6c57 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java
@@ -15,13 +15,13 @@
  */
 package io.netty.handler.codec.http;
 
-import org.junit.Assert;
+import io.netty.handler.codec.AsciiString;
 import org.junit.Test;
 
 import java.util.List;
 
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
 
 public class HttpHeadersTest {
 
@@ -29,8 +29,9 @@ public class HttpHeadersTest {
     public void testRemoveTransferEncodingIgnoreCase() {
         HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         message.headers().set(HttpHeaders.Names.TRANSFER_ENCODING, "Chunked");
+        assertFalse(message.headers().isEmpty());
         HttpHeaders.removeTransferEncodingChunked(message);
-        Assert.assertTrue(message.headers().isEmpty());
+        assertTrue(message.headers().isEmpty());
     }
 
     // Test for https://github.com/netty/netty/issues/1690
@@ -40,19 +41,19 @@ public void testGetOperations() {
         headers.add("Foo", "1");
         headers.add("Foo", "2");
 
-        Assert.assertEquals("1", headers.get("Foo"));
+        assertEquals("1", headers.get("Foo"));
 
         List<String> values = headers.getAll("Foo");
-        Assert.assertEquals(2, values.size());
-        Assert.assertEquals("1", values.get(0));
-        Assert.assertEquals("2", values.get(1));
+        assertEquals(2, values.size());
+        assertEquals("1", values.get(0));
+        assertEquals("2", values.get(1));
     }
 
     @Test
     public void testEquansIgnoreCase() {
-        assertThat(HttpHeaders.equalsIgnoreCase(null, null), is(true));
-        assertThat(HttpHeaders.equalsIgnoreCase(null, "foo"), is(false));
-        assertThat(HttpHeaders.equalsIgnoreCase("bar", null), is(false));
-        assertThat(HttpHeaders.equalsIgnoreCase("FoO", "fOo"), is(true));
+        assertThat(AsciiString.equalsIgnoreCase(null, null), is(true));
+        assertThat(AsciiString.equalsIgnoreCase(null, "foo"), is(false));
+        assertThat(AsciiString.equalsIgnoreCase("bar", null), is(false));
+        assertThat(AsciiString.equalsIgnoreCase("FoO", "fOo"), is(true));
     }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
index caa5f50fe7eb..4dfecced1b68 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
@@ -34,8 +34,8 @@ public class HttpInvalidMessageTest {
     public void testRequestWithBadInitialLine() throws Exception {
         EmbeddedChannel ch = new EmbeddedChannel(new HttpRequestDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("GET / HTTP/1.0 with extra\r\n", CharsetUtil.UTF_8));
-        HttpRequest req = (HttpRequest) ch.readInbound();
-        DecoderResult dr = req.getDecoderResult();
+        HttpRequest req = ch.readInbound();
+        DecoderResult dr = req.decoderResult();
         assertFalse(dr.isSuccess());
         assertTrue(dr.isFailure());
         ensureInboundTrafficDiscarded(ch);
@@ -48,12 +48,12 @@ public void testRequestWithBadHeader() throws Exception {
         ch.writeInbound(Unpooled.copiedBuffer("Good_Name: Good Value\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("Bad=Name: Bad Value\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.UTF_8));
-        HttpRequest req = (HttpRequest) ch.readInbound();
-        DecoderResult dr = req.getDecoderResult();
+        HttpRequest req = ch.readInbound();
+        DecoderResult dr = req.decoderResult();
         assertFalse(dr.isSuccess());
         assertTrue(dr.isFailure());
         assertEquals("Good Value", req.headers().get("Good_Name"));
-        assertEquals("/maybe-something", req.getUri());
+        assertEquals("/maybe-something", req.uri());
         ensureInboundTrafficDiscarded(ch);
     }
 
@@ -61,8 +61,8 @@ public void testRequestWithBadHeader() throws Exception {
     public void testResponseWithBadInitialLine() throws Exception {
         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.0 BAD_CODE Bad Server\r\n", CharsetUtil.UTF_8));
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        DecoderResult dr = res.getDecoderResult();
+        HttpResponse res = ch.readInbound();
+        DecoderResult dr = res.decoderResult();
         assertFalse(dr.isSuccess());
         assertTrue(dr.isFailure());
         ensureInboundTrafficDiscarded(ch);
@@ -75,11 +75,11 @@ public void testResponseWithBadHeader() throws Exception {
         ch.writeInbound(Unpooled.copiedBuffer("Good_Name: Good Value\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("Bad=Name: Bad Value\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("\r\n", CharsetUtil.UTF_8));
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        DecoderResult dr = res.getDecoderResult();
+        HttpResponse res = ch.readInbound();
+        DecoderResult dr = res.decoderResult();
         assertFalse(dr.isSuccess());
         assertTrue(dr.isFailure());
-        assertEquals("Maybe OK", res.getStatus().reasonPhrase());
+        assertEquals("Maybe OK", res.status().reasonPhrase());
         assertEquals("Good Value", res.headers().get("Good_Name"));
         ensureInboundTrafficDiscarded(ch);
     }
@@ -91,11 +91,11 @@ public void testBadChunk() throws Exception {
         ch.writeInbound(Unpooled.copiedBuffer("Transfer-Encoding: chunked\r\n\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("BAD_LENGTH\r\n", CharsetUtil.UTF_8));
 
-        HttpRequest req = (HttpRequest) ch.readInbound();
-        assertTrue(req.getDecoderResult().isSuccess());
+        HttpRequest req = ch.readInbound();
+        assertTrue(req.decoderResult().isSuccess());
 
-        HttpContent chunk = (HttpContent) ch.readInbound();
-        DecoderResult dr = chunk.getDecoderResult();
+        LastHttpContent chunk = ch.readInbound();
+        DecoderResult dr = chunk.decoderResult();
         assertFalse(dr.isSuccess());
         assertTrue(dr.isFailure());
         ensureInboundTrafficDiscarded(ch);
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
index d8696b1f242b..55800fe2ced2 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
@@ -20,14 +20,18 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.DecoderResultProvider;
 import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.util.CharsetUtil;
 import org.easymock.EasyMock;
 import org.junit.Test;
 
+import java.nio.channels.ClosedChannelException;
 import java.util.List;
 
-import static io.netty.util.ReferenceCountUtil.releaseLater;
+import static io.netty.util.ReferenceCountUtil.*;
+import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
 
 public class HttpObjectAggregatorTest {
@@ -37,8 +41,7 @@ public void testAggregate() {
         HttpObjectAggregator aggr = new HttpObjectAggregator(1024 * 1024);
         EmbeddedChannel embedder = new EmbeddedChannel(aggr);
 
-        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1,
-                HttpMethod.GET, "http://localhost");
+        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "http://localhost");
         HttpHeaders.setHeader(message, "X-Test", true);
         HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));
         HttpContent chunk2 = new DefaultHttpContent(Unpooled.copiedBuffer("test2", CharsetUtil.US_ASCII));
@@ -50,7 +53,7 @@ public void testAggregate() {
         // this should trigger a channelRead event so return true
         assertTrue(embedder.writeInbound(chunk3));
         assertTrue(embedder.finish());
-        DefaultFullHttpRequest aggratedMessage = (DefaultFullHttpRequest) embedder.readInbound();
+        FullHttpRequest aggratedMessage = embedder.readInbound();
         assertNotNull(aggratedMessage);
 
         assertEquals(chunk1.content().readableBytes() + chunk2.content().readableBytes(),
@@ -76,8 +79,7 @@ private static void checkContentBuffer(FullHttpRequest aggregatedMessage) {
     public void testAggregateWithTrailer() {
         HttpObjectAggregator aggr = new HttpObjectAggregator(1024 * 1024);
         EmbeddedChannel embedder = new EmbeddedChannel(aggr);
-        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1,
-                HttpMethod.GET, "http://localhost");
+        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "http://localhost");
         HttpHeaders.setHeader(message, "X-Test", true);
         HttpHeaders.setTransferEncodingChunked(message);
         HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));
@@ -92,7 +94,7 @@ public void testAggregateWithTrailer() {
         // this should trigger a channelRead event so return true
         assertTrue(embedder.writeInbound(trailer));
         assertTrue(embedder.finish());
-        DefaultFullHttpRequest aggratedMessage = (DefaultFullHttpRequest) embedder.readInbound();
+        FullHttpRequest aggratedMessage = embedder.readInbound();
         assertNotNull(aggratedMessage);
 
         assertEquals(chunk1.content().readableBytes() + chunk2.content().readableBytes(),
@@ -104,38 +106,153 @@ public void testAggregateWithTrailer() {
     }
 
     @Test
-    public void testTooLongFrameException() {
-        HttpObjectAggregator aggr = new HttpObjectAggregator(4);
-        EmbeddedChannel embedder = new EmbeddedChannel(aggr);
-        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1,
-                HttpMethod.GET, "http://localhost");
-        HttpContent chunk1 = releaseLater(new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII)));
-        HttpContent chunk2 = releaseLater(new DefaultHttpContent(Unpooled.copiedBuffer("test2", CharsetUtil.US_ASCII)));
-        HttpContent chunk3 = releaseLater(new DefaultHttpContent(Unpooled.copiedBuffer("test3", CharsetUtil.US_ASCII)));
-        HttpContent chunk4 = LastHttpContent.EMPTY_LAST_CONTENT;
+    public void testOversizedRequest() {
+        EmbeddedChannel embedder = new EmbeddedChannel(new HttpObjectAggregator(4));
+        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");
+        HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));
+        HttpContent chunk2 = new DefaultHttpContent(Unpooled.copiedBuffer("test2", CharsetUtil.US_ASCII));
+        HttpContent chunk3 = LastHttpContent.EMPTY_LAST_CONTENT;
 
         assertFalse(embedder.writeInbound(message));
-        assertFalse(embedder.writeInbound(chunk1.copy()));
+        assertFalse(embedder.writeInbound(chunk1));
+        assertFalse(embedder.writeInbound(chunk2));
+
+        FullHttpResponse response = embedder.readOutbound();
+        assertEquals(HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, response.status());
+        assertEquals("0", response.headers().get(Names.CONTENT_LENGTH));
+        assertFalse(embedder.isOpen());
+
         try {
-            embedder.writeInbound(chunk2.copy());
+            assertFalse(embedder.writeInbound(chunk3));
             fail();
-        } catch (TooLongFrameException e) {
-            // expected
+        } catch (Exception e) {
+            assertTrue(e instanceof ClosedChannelException);
         }
-        assertFalse(embedder.writeInbound(chunk3.copy()));
-        assertFalse(embedder.writeInbound(chunk4.copy()));
 
+        assertFalse(embedder.finish());
+    }
+
+    @Test
+    public void testOversizedRequestWithoutKeepAlive() {
+        // send a HTTP/1.0 request with no keep-alive header
+        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.PUT, "http://localhost");
+        HttpHeaders.setContentLength(message, 5);
+        checkOversizedRequest(message);
+    }
+
+    @Test
+    public void testOversizedRequestWithContentLength() {
+        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");
+        HttpHeaders.setContentLength(message, 5);
+        checkOversizedRequest(message);
+    }
+
+    @Test
+    public void testOversizedRequestWith100Continue() {
+        EmbeddedChannel embedder = new EmbeddedChannel(new HttpObjectAggregator(8));
+
+        // send an oversized request with 100 continue
+        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");
+        HttpHeaders.set100ContinueExpected(message);
+        HttpHeaders.setContentLength(message, 16);
+
+        HttpContent chunk1 = releaseLater(new DefaultHttpContent(Unpooled.copiedBuffer("some", CharsetUtil.US_ASCII)));
+        HttpContent chunk2 = releaseLater(new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII)));
+        HttpContent chunk3 = LastHttpContent.EMPTY_LAST_CONTENT;
+
+        // Send a request with 100-continue + large Content-Length header value.
         assertFalse(embedder.writeInbound(message));
-        assertFalse(embedder.writeInbound(chunk1.copy()));
+
+        // The agregator should respond with '413 Request Entity Too Large.'
+        FullHttpResponse response = embedder.readOutbound();
+        assertEquals(HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, response.status());
+        assertEquals("0", response.headers().get(Names.CONTENT_LENGTH));
+
+        // An ill-behaving client could continue to send data without a respect, and such data should be discarded.
+        assertFalse(embedder.writeInbound(chunk1));
+
+        // The aggregator should not close the connection because keep-alive is on.
+        assertTrue(embedder.isOpen());
+
+        // Now send a valid request.
+        HttpRequest message2 = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");
+
+        assertFalse(embedder.writeInbound(message2));
+        assertFalse(embedder.writeInbound(chunk2));
+        assertTrue(embedder.writeInbound(chunk3));
+
+        FullHttpRequest fullMsg = embedder.readInbound();
+        assertNotNull(fullMsg);
+
+        assertEquals(
+                chunk2.content().readableBytes() + chunk3.content().readableBytes(),
+                HttpHeaders.getContentLength(fullMsg));
+
+        assertEquals(HttpHeaders.getContentLength(fullMsg), fullMsg.content().readableBytes());
+
+        fullMsg.release();
+        assertFalse(embedder.finish());
+    }
+
+    @Test
+    public void testOversizedRequestWith100ContinueAndDecoder() {
+        EmbeddedChannel embedder = new EmbeddedChannel(new HttpRequestDecoder(), new HttpObjectAggregator(4));
+        embedder.writeInbound(Unpooled.copiedBuffer(
+                "PUT /upload HTTP/1.1\r\n" +
+                        "Expect: 100-continue\r\n" +
+                        "Content-Length: 100\r\n\r\n", CharsetUtil.US_ASCII));
+
+        assertNull(embedder.readInbound());
+
+        FullHttpResponse response = embedder.readOutbound();
+        assertEquals(HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, response.status());
+        assertEquals("0", response.headers().get(Names.CONTENT_LENGTH));
+
+        // Keep-alive is on by default in HTTP/1.1, so the connection should be still alive.
+        assertTrue(embedder.isOpen());
+
+        // The decoder should be reset by the aggregator at this point and be able to decode the next request.
+        embedder.writeInbound(Unpooled.copiedBuffer("GET /max-upload-size HTTP/1.1\r\n\r\n", CharsetUtil.US_ASCII));
+
+        FullHttpRequest request = embedder.readInbound();
+        assertThat(request.method(), is(HttpMethod.GET));
+        assertThat(request.uri(), is("/max-upload-size"));
+        assertThat(request.content().readableBytes(), is(0));
+        request.release();
+
+        assertFalse(embedder.finish());
+    }
+
+    private static void checkOversizedRequest(HttpRequest message) {
+        EmbeddedChannel embedder = new EmbeddedChannel(new HttpObjectAggregator(4));
+
+        assertFalse(embedder.writeInbound(message));
+        HttpResponse response = embedder.readOutbound();
+        assertEquals(HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, response.status());
+        assertEquals("0", response.headers().get(Names.CONTENT_LENGTH));
+        assertFalse(embedder.isOpen());
+        assertFalse(embedder.finish());
+    }
+
+    @Test
+    public void testOversizedResponse() {
+        EmbeddedChannel embedder = new EmbeddedChannel(new HttpObjectAggregator(4));
+        HttpResponse message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+        HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));
+        HttpContent chunk2 = new DefaultHttpContent(Unpooled.copiedBuffer("test2", CharsetUtil.US_ASCII));
+
+        assertFalse(embedder.writeInbound(message));
+        assertFalse(embedder.writeInbound(chunk1));
+
         try {
-            embedder.writeInbound(chunk2.copy());
+            embedder.writeInbound(chunk2);
             fail();
-        } catch (TooLongFrameException e) {
-            // expected
+        } catch (TooLongFrameException expected) {
+            // Expected
         }
-        assertFalse(embedder.writeInbound(chunk3.copy()));
-        assertFalse(embedder.writeInbound(chunk4.copy()));
-        embedder.finish();
+
+        assertFalse(embedder.isOpen());
+        assertFalse(embedder.finish());
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -163,8 +280,7 @@ public void testAggregateTransferEncodingChunked() {
         HttpObjectAggregator aggr = new HttpObjectAggregator(1024 * 1024);
         EmbeddedChannel embedder = new EmbeddedChannel(aggr);
 
-        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1,
-                HttpMethod.GET, "http://localhost");
+        HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");
         HttpHeaders.setHeader(message, "X-Test", true);
         HttpHeaders.setHeader(message, "Transfer-Encoding", "Chunked");
         HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));
@@ -177,7 +293,7 @@ public void testAggregateTransferEncodingChunked() {
         // this should trigger a channelRead event so return true
         assertTrue(embedder.writeInbound(chunk3));
         assertTrue(embedder.finish());
-        FullHttpRequest aggratedMessage = (FullHttpRequest) embedder.readInbound();
+        FullHttpRequest aggratedMessage = embedder.readInbound();
         assertNotNull(aggratedMessage);
 
         assertEquals(chunk1.content().readableBytes() + chunk2.content().readableBytes(),
@@ -186,4 +302,26 @@ public void testAggregateTransferEncodingChunked() {
         checkContentBuffer(aggratedMessage);
         assertNull(embedder.readInbound());
     }
+
+    @Test
+    public void testBadRequest() {
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpRequestDecoder(), new HttpObjectAggregator(1024 * 1024));
+        ch.writeInbound(Unpooled.copiedBuffer("GET / HTTP/1.0 with extra\r\n", CharsetUtil.UTF_8));
+        Object inbound = ch.readInbound();
+        assertThat(inbound, is(instanceOf(FullHttpRequest.class)));
+        assertTrue(((DecoderResultProvider) inbound).decoderResult().isFailure());
+        assertNull(ch.readInbound());
+        ch.finish();
+    }
+
+    @Test
+    public void testBadResponse() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder(), new HttpObjectAggregator(1024 * 1024));
+        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.0 BAD_CODE Bad Server\r\n", CharsetUtil.UTF_8));
+        Object inbound = ch.readInbound();
+        assertThat(inbound, is(instanceOf(FullHttpResponse.class)));
+        assertTrue(((DecoderResultProvider) inbound).decoderResult().isFailure());
+        assertNull(ch.readInbound());
+        ch.finish();
+    }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
index aed1b84dd92e..8fa745115d42 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java
@@ -23,6 +23,7 @@
 
 import java.util.List;
 
+import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
 
 public class HttpRequestDecoderTest {
@@ -71,10 +72,10 @@ public void testDecodeWholeRequestAtOnceMixedDelimiters() {
     private static void testDecodeWholeRequestAtOnce(byte[] content) {
         EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());
         assertTrue(channel.writeInbound(Unpooled.wrappedBuffer(content)));
-        HttpRequest req = (HttpRequest) channel.readInbound();
+        HttpRequest req = channel.readInbound();
         assertNotNull(req);
         checkHeaders(req.headers());
-        LastHttpContent c = (LastHttpContent) channel.readInbound();
+        LastHttpContent c = channel.readInbound();
         assertEquals(CONTENT_LENGTH, c.content().readableBytes());
         assertEquals(
                 Unpooled.wrappedBuffer(content, content.length - CONTENT_LENGTH, CONTENT_LENGTH),
@@ -135,7 +136,6 @@ private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fr
             }
 
             // if header is done it should produce a HttpRequest
-            boolean headerDone = a + amount == headerLength;
             channel.writeInbound(Unpooled.wrappedBuffer(content, a, amount));
             a += amount;
         }
@@ -145,18 +145,18 @@ private static void testDecodeWholeRequestInMultipleSteps(byte[] content, int fr
             channel.writeInbound(Unpooled.wrappedBuffer(content, content.length - i, 1));
         }
 
-        HttpRequest req = (HttpRequest) channel.readInbound();
+        HttpRequest req = channel.readInbound();
         assertNotNull(req);
         checkHeaders(req.headers());
 
         for (int i = CONTENT_LENGTH; i > 1; i --) {
-            HttpContent c = (HttpContent) channel.readInbound();
+            HttpContent c = channel.readInbound();
             assertEquals(1, c.content().readableBytes());
             assertEquals(content[content.length - i], c.content().readByte());
             c.release();
         }
 
-        LastHttpContent c = (LastHttpContent) channel.readInbound();
+        LastHttpContent c = channel.readInbound();
         assertEquals(1, c.content().readableBytes());
         assertEquals(content[content.length - 1], c.content().readByte());
         c.release();
@@ -173,7 +173,61 @@ public void testEmptyHeaderValue() {
                 "Host: localhost" + crlf +
                 "EmptyHeader:" + crlf + crlf;
         channel.writeInbound(Unpooled.wrappedBuffer(request.getBytes(CharsetUtil.US_ASCII)));
-        HttpRequest req = (HttpRequest) channel.readInbound();
+        HttpRequest req = channel.readInbound();
         assertEquals("", req.headers().get("EmptyHeader"));
     }
+
+    @Test
+    public void test100Continue() {
+        HttpRequestDecoder decoder = new HttpRequestDecoder();
+        EmbeddedChannel channel = new EmbeddedChannel(decoder);
+        String oversized =
+                "PUT /file HTTP/1.1\r\n" +
+                "Expect: 100-continue\r\n" +
+                "Content-Length: 1048576000\r\n\r\n";
+
+        channel.writeInbound(Unpooled.copiedBuffer(oversized, CharsetUtil.US_ASCII));
+        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));
+
+        // At this point, we assume that we sent '413 Entity Too Large' to the peer without closing the connection
+        // so that the client can try again.
+        decoder.reset();
+
+        String query = "GET /max-file-size HTTP/1.1\r\n\r\n";
+        channel.writeInbound(Unpooled.copiedBuffer(query, CharsetUtil.US_ASCII));
+        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));
+        assertThat(channel.readInbound(), is(instanceOf(LastHttpContent.class)));
+
+        assertThat(channel.finish(), is(false));
+    }
+
+    @Test
+    public void test100ContinueWithBadClient() {
+        HttpRequestDecoder decoder = new HttpRequestDecoder();
+        EmbeddedChannel channel = new EmbeddedChannel(decoder);
+        String oversized =
+                "PUT /file HTTP/1.1\r\n" +
+                "Expect: 100-continue\r\n" +
+                "Content-Length: 1048576000\r\n\r\n" +
+                "WAY_TOO_LARGE_DATA_BEGINS";
+
+        channel.writeInbound(Unpooled.copiedBuffer(oversized, CharsetUtil.US_ASCII));
+        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));
+
+        HttpContent prematureData = channel.readInbound();
+        prematureData.release();
+
+        assertThat(channel.readInbound(), is(nullValue()));
+
+        // At this point, we assume that we sent '413 Entity Too Large' to the peer without closing the connection
+        // so that the client can try again.
+        decoder.reset();
+
+        String query = "GET /max-file-size HTTP/1.1\r\n\r\n";
+        channel.writeInbound(Unpooled.copiedBuffer(query, CharsetUtil.US_ASCII));
+        assertThat(channel.readInbound(), is(instanceOf(HttpRequest.class)));
+        assertThat(channel.readInbound(), is(instanceOf(LastHttpContent.class)));
+
+        assertThat(channel.finish(), is(false));
+    }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
index db64d9ed2e1d..03947a00fe11 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
@@ -34,9 +34,9 @@ public void testResponseChunked() {
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n",
                 CharsetUtil.US_ASCII));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
 
         byte[] data = new byte[64];
         for (int i = 0; i < data.length; i++) {
@@ -47,7 +47,7 @@ public void testResponseChunked() {
             assertFalse(ch.writeInbound(Unpooled.copiedBuffer(Integer.toHexString(data.length) + "\r\n",
                     CharsetUtil.US_ASCII)));
             assertTrue(ch.writeInbound(Unpooled.wrappedBuffer(data)));
-            HttpContent content = (HttpContent) ch.readInbound();
+            HttpContent content = ch.readInbound();
             assertEquals(data.length, content.content().readableBytes());
 
             byte[] decodedData = new byte[data.length];
@@ -62,7 +62,7 @@ public void testResponseChunked() {
         ch.writeInbound(Unpooled.copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII));
 
         // Ensure the last chunk was decoded.
-        LastHttpContent content = (LastHttpContent) ch.readInbound();
+        LastHttpContent content = ch.readInbound();
         assertFalse(content.content().isReadable());
         content.release();
 
@@ -76,9 +76,9 @@ public void testResponseChunkedExceedMaxChunkSize() {
         ch.writeInbound(
                 Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n", CharsetUtil.US_ASCII));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
 
         byte[] data = new byte[64];
         for (int i = 0; i < data.length; i++) {
@@ -91,12 +91,12 @@ public void testResponseChunkedExceedMaxChunkSize() {
             assertTrue(ch.writeInbound(Unpooled.wrappedBuffer(data)));
 
             byte[] decodedData = new byte[data.length];
-            HttpContent content = (HttpContent) ch.readInbound();
+            HttpContent content = ch.readInbound();
             assertEquals(32, content.content().readableBytes());
             content.content().readBytes(decodedData, 0, 32);
             content.release();
 
-            content = (HttpContent) ch.readInbound();
+            content = ch.readInbound();
             assertEquals(32, content.content().readableBytes());
 
             content.content().readBytes(decodedData, 32, 32);
@@ -111,7 +111,7 @@ public void testResponseChunkedExceedMaxChunkSize() {
         ch.writeInbound(Unpooled.copiedBuffer("0\r\n\r\n", CharsetUtil.US_ASCII));
 
         // Ensure the last chunk was decoded.
-        LastHttpContent content = (LastHttpContent) ch.readInbound();
+        LastHttpContent content = ch.readInbound();
         assertFalse(content.content().isReadable());
         content.release();
 
@@ -125,16 +125,16 @@ public void testClosureWithoutContentLength1() throws Exception {
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
 
         // Read the response headers.
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
         assertThat(ch.readInbound(), is(nullValue()));
 
         // Close the connection without sending anything.
         assertTrue(ch.finish());
 
         // The decoder should still produce the last content.
-        LastHttpContent content = (LastHttpContent) ch.readInbound();
+        LastHttpContent content = ch.readInbound();
         assertThat(content.content().isReadable(), is(false));
         content.release();
 
@@ -150,12 +150,12 @@ public void testClosureWithoutContentLength2() throws Exception {
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n12345678", CharsetUtil.US_ASCII));
 
         // Read the response headers.
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
 
         // Read the partial content.
-        HttpContent content = (HttpContent) ch.readInbound();
+        HttpContent content = ch.readInbound();
         assertThat(content.content().toString(CharsetUtil.US_ASCII), is("12345678"));
         assertThat(content, is(not(instanceOf(LastHttpContent.class))));
         content.release();
@@ -166,7 +166,7 @@ public void testClosureWithoutContentLength2() throws Exception {
         assertTrue(ch.finish());
 
         // The decoder should still produce the last content.
-        LastHttpContent lastContent = (LastHttpContent) ch.readInbound();
+        LastHttpContent lastContent = ch.readInbound();
         assertThat(lastContent.content().isReadable(), is(false));
         lastContent.release();
 
@@ -181,9 +181,9 @@ public void testPrematureClosureWithChunkedEncoding1() throws Exception {
                 Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n", CharsetUtil.US_ASCII));
 
         // Read the response headers.
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
         assertThat(res.headers().get(Names.TRANSFER_ENCODING), is("chunked"));
         assertThat(ch.readInbound(), is(nullValue()));
 
@@ -202,13 +202,13 @@ public void testPrematureClosureWithChunkedEncoding2() throws Exception {
                 "HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n8\r\n12345678", CharsetUtil.US_ASCII));
 
         // Read the response headers.
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
         assertThat(res.headers().get(Names.TRANSFER_ENCODING), is("chunked"));
 
         // Read the partial content.
-        HttpContent content = (HttpContent) ch.readInbound();
+        HttpContent content = ch.readInbound();
         assertThat(content.content().toString(CharsetUtil.US_ASCII), is("12345678"));
         assertThat(content, is(not(instanceOf(LastHttpContent.class))));
         content.release();
@@ -227,14 +227,14 @@ public void testLastResponseWithEmptyHeaderAndEmptyContent() {
         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
         assertThat(ch.readInbound(), is(nullValue()));
 
         assertThat(ch.finish(), is(true));
 
-        LastHttpContent content = (LastHttpContent) ch.readInbound();
+        LastHttpContent content = ch.readInbound();
         assertThat(content.content().isReadable(), is(false));
         content.release();
 
@@ -246,19 +246,46 @@ public void testLastResponseWithoutContentLengthHeader() {
         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
         assertThat(ch.readInbound(), is(nullValue()));
 
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));
-        HttpContent content = (HttpContent) ch.readInbound();
+        HttpContent content = ch.readInbound();
         assertThat(content.content().readableBytes(), is(1024));
         content.release();
 
         assertThat(ch.finish(), is(true));
 
-        LastHttpContent lastContent = (LastHttpContent) ch.readInbound();
+        LastHttpContent lastContent = ch.readInbound();
+        assertThat(lastContent.content().isReadable(), is(false));
+        lastContent.release();
+
+        assertThat(ch.readInbound(), is(nullValue()));
+    }
+
+    @Test
+    public void testLastResponseWithHeaderRemoveTrailingSpaces() {
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
+        ch.writeInbound(Unpooled.copiedBuffer(
+                "HTTP/1.1 200 OK\r\nX-Header: h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT       \r\n\r\n",
+                CharsetUtil.US_ASCII));
+
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
+        assertThat(res.headers().get("X-Header"), is("h2=h2v2; Expires=Wed, 09-Jun-2021 10:18:14 GMT"));
+        assertThat(ch.readInbound(), is(nullValue()));
+
+        ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));
+        HttpContent content = ch.readInbound();
+        assertThat(content.content().readableBytes(), is(1024));
+        content.release();
+
+        assertThat(ch.finish(), is(true));
+
+        LastHttpContent lastContent = ch.readInbound();
         assertThat(lastContent.content().isReadable(), is(false));
         lastContent.release();
 
@@ -278,11 +305,11 @@ public void testLastResponseWithTrailingHeader() {
                         "\r\n",
                 CharsetUtil.US_ASCII));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
 
-        LastHttpContent lastContent = (LastHttpContent) ch.readInbound();
+        LastHttpContent lastContent = ch.readInbound();
         assertThat(lastContent.content().isReadable(), is(false));
         HttpHeaders headers = lastContent.trailingHeaders();
         assertEquals(1, headers.names().size());
@@ -328,11 +355,11 @@ private static void testLastResponseWithTrailingHeaderFragmented(byte[] content,
         }
 
         ch.writeInbound(Unpooled.wrappedBuffer(content, headerLength, content.length - headerLength));
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
 
-        LastHttpContent lastContent = (LastHttpContent) ch.readInbound();
+        LastHttpContent lastContent = ch.readInbound();
         assertThat(lastContent.content().isReadable(), is(false));
         HttpHeaders headers = lastContent.trailingHeaders();
         assertEquals(1, headers.names().size());
@@ -361,16 +388,16 @@ public void testResponseWithContentLength() {
         ch.writeInbound(Unpooled.wrappedBuffer(data, 0, data.length / 2));
         ch.writeInbound(Unpooled.wrappedBuffer(data, 5, data.length / 2));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
 
-        HttpContent firstContent = (HttpContent) ch.readInbound();
+        HttpContent firstContent = ch.readInbound();
         assertThat(firstContent.content().readableBytes(), is(5));
         assertEquals(Unpooled.wrappedBuffer(data, 0, 5), firstContent.content());
         firstContent.release();
 
-        LastHttpContent lastContent = (LastHttpContent) ch.readInbound();
+        LastHttpContent lastContent = ch.readInbound();
         assertEquals(5, lastContent.content().readableBytes());
         assertEquals(Unpooled.wrappedBuffer(data, 5, 5), lastContent.content());
         lastContent.release();
@@ -409,16 +436,16 @@ private static void testResponseWithContentLengthFragmented(byte[] header, int f
         ch.writeInbound(Unpooled.wrappedBuffer(data, 0, data.length / 2));
         ch.writeInbound(Unpooled.wrappedBuffer(data, 5, data.length / 2));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.OK));
 
-        HttpContent firstContent = (HttpContent) ch.readInbound();
+        HttpContent firstContent = ch.readInbound();
         assertThat(firstContent.content().readableBytes(), is(5));
         assertEquals(Unpooled.wrappedBuffer(data, 0, 5), firstContent.content());
         firstContent.release();
 
-        LastHttpContent lastContent = (LastHttpContent) ch.readInbound();
+        LastHttpContent lastContent = ch.readInbound();
         assertEquals(5, lastContent.content().readableBytes());
         assertEquals(Unpooled.wrappedBuffer(data, 5, 5), lastContent.content());
         lastContent.release();
@@ -439,10 +466,10 @@ public void testWebSocketResponse() {
         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
         ch.writeInbound(Unpooled.wrappedBuffer(data));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));
-        HttpContent content = (HttpContent) ch.readInbound();
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));
+        HttpContent content = ch.readInbound();
         assertThat(content.content().readableBytes(), is(16));
         content.release();
 
@@ -466,10 +493,10 @@ public void testWebSocketResponseWithDataFollowing() {
         EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
         ch.writeInbound(Unpooled.wrappedBuffer(data, otherData));
 
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
-        assertThat(res.getStatus(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));
-        HttpContent content = (HttpContent) ch.readInbound();
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.status(), is(HttpResponseStatus.SWITCHING_PROTOCOLS));
+        HttpContent content = ch.readInbound();
         assertThat(content.content().readableBytes(), is(16));
         content.release();
 
@@ -494,11 +521,11 @@ public void testGarbageHeaders() {
         ch.writeInbound(Unpooled.wrappedBuffer(data));
 
         // Garbage input should generate the 999 Unknown response.
-        HttpResponse res = (HttpResponse) ch.readInbound();
-        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_0));
-        assertThat(res.getStatus().code(), is(999));
-        assertThat(res.getDecoderResult().isFailure(), is(true));
-        assertThat(res.getDecoderResult().isFinished(), is(true));
+        HttpResponse res = ch.readInbound();
+        assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_0));
+        assertThat(res.status().code(), is(999));
+        assertThat(res.decoderResult().isFailure(), is(true));
+        assertThat(res.decoderResult().isFinished(), is(true));
         assertThat(ch.readInbound(), is(nullValue()));
 
         // More garbage should not generate anything (i.e. the decoder discards anything beyond this point.)
@@ -509,4 +536,31 @@ public void testGarbageHeaders() {
         ch.finish();
         assertThat(ch.readInbound(), is(nullValue()));
     }
+
+    /**
+     * Tests if the decoder produces one and only {@link LastHttpContent} when an invalid chunk is received and
+     * the connection is closed.
+     */
+    @Test
+    public void testGarbageChunk() {
+        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());
+        String responseWithIllegalChunk =
+                "HTTP/1.1 200 OK\r\n" +
+                "Transfer-Encoding: chunked\r\n\r\n" +
+                "NOT_A_CHUNK_LENGTH\r\n";
+
+        channel.writeInbound(Unpooled.copiedBuffer(responseWithIllegalChunk, CharsetUtil.US_ASCII));
+        assertThat(channel.readInbound(), is(instanceOf(HttpResponse.class)));
+
+        // Ensure that the decoder generates the last chunk with correct decoder result.
+        LastHttpContent invalidChunk = channel.readInbound();
+        assertThat(invalidChunk.decoderResult().isFailure(), is(true));
+        invalidChunk.release();
+
+        // And no more messages should be produced by the decoder.
+        assertThat(channel.readInbound(), is(nullValue()));
+
+        // .. even after the connection is closed.
+        assertThat(channel.finish(), is(false));
+    }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java
new file mode 100644
index 000000000000..ff2b26065a73
--- /dev/null
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java
@@ -0,0 +1,121 @@
+/*
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+package io.netty.handler.codec.http;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.FileRegion;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.CharsetUtil;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.nio.channels.WritableByteChannel;
+
+import static org.junit.Assert.*;
+
+public class HttpResponseEncoderTest {
+    private static final long INTEGER_OVERLFLOW = (long) Integer.MAX_VALUE + 1;
+    private static final FileRegion FILE_REGION = new DummyLongFileRegion();
+
+    @Test
+    public void testLargeFileRegionChunked() throws Exception {
+        EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseEncoder());
+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+        response.headers().set(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+        assertTrue(channel.writeOutbound(response));
+
+        ByteBuf buffer = channel.readOutbound();
+
+        assertEquals("HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n", buffer.toString(CharsetUtil.US_ASCII));
+        buffer.release();
+        assertTrue(channel.writeOutbound(FILE_REGION));
+        buffer = channel.readOutbound();
+        assertEquals("80000000\r\n", buffer.toString(CharsetUtil.US_ASCII));
+        buffer.release();
+
+        FileRegion region = channel.readOutbound();
+        assertSame(FILE_REGION, region);
+        region.release();
+        buffer = channel.readOutbound();
+        assertEquals("\r\n", buffer.toString(CharsetUtil.US_ASCII));
+        buffer.release();
+
+        assertTrue(channel.writeOutbound(LastHttpContent.EMPTY_LAST_CONTENT));
+        buffer = channel.readOutbound();
+        assertEquals("0\r\n\r\n", buffer.toString(CharsetUtil.US_ASCII));
+        buffer.release();
+
+        assertFalse(channel.finish());
+    }
+
+    private static class DummyLongFileRegion implements FileRegion {
+
+        @Override
+        public long position() {
+            return 0;
+        }
+
+        @Override
+        public long transfered() {
+            return 0;
+        }
+
+        @Override
+        public long count() {
+            return INTEGER_OVERLFLOW;
+        }
+
+        @Override
+        public long transferTo(WritableByteChannel target, long position) throws IOException {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public FileRegion touch(Object hint) {
+            return this;
+        }
+
+        @Override
+        public FileRegion touch() {
+            return this;
+        }
+
+        @Override
+        public FileRegion retain() {
+            return this;
+        }
+
+        @Override
+        public FileRegion retain(int increment) {
+            return this;
+        }
+
+        @Override
+        public int refCnt() {
+            return 1;
+        }
+
+        @Override
+        public boolean release() {
+            return false;
+        }
+
+        @Override
+        public boolean release(int decrement) {
+            return false;
+        }
+    }
+}
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java
index 3ecd40895db7..f0d0faff2dd6 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java
@@ -47,13 +47,13 @@ public void testUnfinishedChunkedHttpRequestIsLastFlag() throws Exception {
         decoderEmbedder.writeInbound(prepareDataChunk(offeredContentLength));
         decoderEmbedder.finish();
 
-        HttpMessage httpMessage = (HttpMessage) decoderEmbedder.readInbound();
+        HttpMessage httpMessage = decoderEmbedder.readInbound();
         assertNotNull(httpMessage);
 
         boolean empty = true;
         int totalBytesPolled = 0;
         for (;;) {
-            HttpContent httpChunk = (HttpContent) decoderEmbedder.readInbound();
+            HttpContent httpChunk = decoderEmbedder.readInbound();
             if (httpChunk == null) {
                 break;
             }
@@ -80,7 +80,7 @@ public void test100Continue() throws Exception {
         assertThat(ch.readInbound(), is(nullValue()));
 
         // Ensure the aggregator writes a 100 Continue response.
-        ByteBuf continueResponse = (ByteBuf) ch.readOutbound();
+        ByteBuf continueResponse = ch.readOutbound();
         assertThat(continueResponse.toString(CharsetUtil.UTF_8), is("HTTP/1.1 100 Continue\r\n\r\n"));
         continueResponse.release();
 
@@ -91,7 +91,7 @@ public void test100Continue() throws Exception {
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 42 }));
 
         // Ensure the aggregator generates a full request.
-        FullHttpRequest req = (FullHttpRequest) ch.readInbound();
+        FullHttpRequest req = ch.readInbound();
         assertThat(req.headers().get(CONTENT_LENGTH), is("1"));
         assertThat(req.content().readableBytes(), is(1));
         assertThat(req.content().readByte(), is((byte) 42));
@@ -107,7 +107,7 @@ public void test100Continue() throws Exception {
         ch.writeOutbound(res);
 
         // Ensure the encoder handles the response after handling 100 Continue.
-        ByteBuf encodedRes = (ByteBuf) ch.readOutbound();
+        ByteBuf encodedRes = ch.readOutbound();
         assertThat(encodedRes.toString(CharsetUtil.UTF_8), is("HTTP/1.1 201 Created\r\nContent-Length: 2\r\n\r\nOK"));
         encodedRes.release();
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/QueryStringEncoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/QueryStringEncoderTest.java
new file mode 100644
index 000000000000..b9f97a325a65
--- /dev/null
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/QueryStringEncoderTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.http;
+
+import java.net.URI;
+import java.nio.charset.Charset;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class QueryStringEncoderTest {
+
+    @Test
+    public void testDefaultEncoding() throws Exception {
+        QueryStringEncoder e;
+
+        e = new QueryStringEncoder("/foo");
+        e.addParam("a", "b=c");
+        Assert.assertEquals("/foo?a=b%3Dc", e.toString());
+        Assert.assertEquals(new URI("/foo?a=b%3Dc"), e.toUri());
+
+        e = new QueryStringEncoder("/foo/\u00A5");
+        e.addParam("a", "\u00A5");
+        Assert.assertEquals("/foo/\u00A5?a=%C2%A5", e.toString());
+        Assert.assertEquals(new URI("/foo/\u00A5?a=%C2%A5"), e.toUri());
+
+        e = new QueryStringEncoder("/foo");
+        e.addParam("a", "1");
+        e.addParam("b", "2");
+        Assert.assertEquals("/foo?a=1&b=2", e.toString());
+        Assert.assertEquals(new URI("/foo?a=1&b=2"), e.toUri());
+
+        e = new QueryStringEncoder("/foo");
+        e.addParam("a", "1");
+        e.addParam("b", "");
+        e.addParam("c", null);
+        e.addParam("d", null);
+        Assert.assertEquals("/foo?a=1&b=&c&d", e.toString());
+        Assert.assertEquals(new URI("/foo?a=1&b=&c&d"), e.toUri());
+    }
+
+    @Test
+    public void testNonDefaultEncoding() throws Exception {
+        QueryStringEncoder e = new QueryStringEncoder("/foo/\u00A5", Charset.forName("UTF-16"));
+        e.addParam("a", "\u00A5");
+        Assert.assertEquals("/foo/\u00A5?a=%FE%FF%00%A5", e.toString());
+        Assert.assertEquals(new URI("/foo/\u00A5?a=%FE%FF%00%A5"), e.toUri());
+    }
+}
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigTest.java
new file mode 100644
index 000000000000..748bb7017f39
--- /dev/null
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigTest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version
+ * 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package io.netty.handler.codec.http.cors;
+
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpHeaders.Names;
+import io.netty.handler.codec.http.HttpMethod;
+import org.junit.Test;
+
+import static io.netty.handler.codec.http.cors.CorsConfig.*;
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+
+public class CorsConfigTest {
+
+    @Test
+    public void disabled() {
+        final CorsConfig cors = withAnyOrigin().disable().build();
+        assertThat(cors.isCorsSupportEnabled(), is(false));
+    }
+
+    @Test
+    public void anyOrigin() {
+        final CorsConfig cors = withAnyOrigin().build();
+        assertThat(cors.isAnyOriginSupported(), is(true));
+        assertThat(cors.origin(), is("*"));
+        assertThat(cors.origins().isEmpty(), is(true));
+    }
+
+    @Test
+    public void wildcardOrigin() {
+        final CorsConfig cors = withOrigin("*").build();
+        assertThat(cors.isAnyOriginSupported(), is(true));
+        assertThat(cors.origin(), equalTo("*"));
+        assertThat(cors.origins().isEmpty(), is(true));
+    }
+
+    @Test
+    public void origin() {
+        final CorsConfig cors = withOrigin("http://localhost:7888").build();
+        assertThat(cors.origin(), is(equalTo("http://localhost:7888")));
+        assertThat(cors.isAnyOriginSupported(), is(false));
+    }
+
+    @Test
+    public void origins() {
+        final String[] origins = {"http://localhost:7888", "https://localhost:7888"};
+        final CorsConfig cors = withOrigins(origins).build();
+        assertThat(cors.origins(), hasItems(origins));
+        assertThat(cors.isAnyOriginSupported(), is(false));
+    }
+
+    @Test
+    public void exposeHeaders() {
+        final CorsConfig cors = withAnyOrigin().exposeHeaders("custom-header1", "custom-header2").build();
+        assertThat(cors.exposedHeaders(), hasItems("custom-header1", "custom-header2"));
+    }
+
+    @Test
+    public void allowCredentials() {
+        final CorsConfig cors = withAnyOrigin().allowCredentials().build();
+        assertThat(cors.isCredentialsAllowed(), is(true));
+    }
+
+    @Test
+    public void maxAge() {
+        final CorsConfig cors = withAnyOrigin().maxAge(3000).build();
+        assertThat(cors.maxAge(), is(3000L));
+    }
+
+    @Test
+    public void requestMethods() {
+        final CorsConfig cors = withAnyOrigin().allowedRequestMethods(HttpMethod.POST, HttpMethod.GET).build();
+        assertThat(cors.allowedRequestMethods(), hasItems(HttpMethod.POST, HttpMethod.GET));
+    }
+
+    @Test
+    public void requestHeaders() {
+        final CorsConfig cors = withAnyOrigin().allowedRequestHeaders("preflight-header1", "preflight-header2").build();
+        assertThat(cors.allowedRequestHeaders(), hasItems("preflight-header1", "preflight-header2"));
+    }
+
+    @Test
+    public void preflightResponseHeadersSingleValue() {
+        final CorsConfig cors = withAnyOrigin().preflightResponseHeader("SingleValue", "value").build();
+        assertThat(cors.preflightResponseHeaders().get("SingleValue"), equalTo("value"));
+    }
+
+    @Test
+    public void preflightResponseHeadersMultipleValues() {
+        final CorsConfig cors = withAnyOrigin().preflightResponseHeader("MultipleValues", "value1", "value2").build();
+        assertThat(cors.preflightResponseHeaders().getAll("MultipleValues"), hasItems("value1", "value2"));
+    }
+
+    @Test
+    public void defaultPreflightResponseHeaders() {
+        final CorsConfig cors = withAnyOrigin().build();
+        assertThat(cors.preflightResponseHeaders().get(Names.DATE), is(notNullValue()));
+        assertThat(cors.preflightResponseHeaders().get(Names.CONTENT_LENGTH), is("0"));
+    }
+
+    @Test
+    public void emptyPreflightResponseHeaders() {
+        final CorsConfig cors = withAnyOrigin().noPreflightResponseHeaders().build();
+        assertThat(cors.preflightResponseHeaders(), equalTo(HttpHeaders.EMPTY_HEADERS));
+    }
+
+    @Test (expected = IllegalArgumentException.class)
+    public void shouldThrowIfValueIsNull() {
+        withOrigin("*").preflightResponseHeader("HeaderName", new Object[]{null}).build();
+    }
+
+    @Test
+    public void shortCurcuit() {
+        final CorsConfig cors = withOrigin("http://localhost:8080").shortCurcuit().build();
+        assertThat(cors.isShortCurcuit(), is(true));
+    }
+
+}
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigurationTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigurationTest.java
deleted file mode 100644
index 293f1b0c78b5..000000000000
--- a/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigurationTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License, version
- * 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at:
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-package io.netty.handler.codec.http.cors;
-
-import static io.netty.handler.codec.http.cors.CorsConfig.withOrigin;
-import static io.netty.handler.codec.http.cors.CorsConfig.anyOrigin;
-import io.netty.handler.codec.http.HttpMethod;
-import org.junit.Test;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.hasItems;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.MatcherAssert.*;
-
-public class CorsConfigurationTest {
-
-    @Test
-    public void disabled() {
-        final CorsConfig cors = withOrigin("*").disable().build();
-        assertThat(cors.isCorsSupportEnabled(), is(false));
-    }
-
-    @Test
-    public void wildcardOrigin() {
-        final CorsConfig cors = anyOrigin().build();
-        assertThat(cors.origin(), is(equalTo("*")));
-    }
-
-    @Test
-    public void origin() {
-        final CorsConfig cors = withOrigin("http://localhost:7888").build();
-        assertThat(cors.origin(), is(equalTo("http://localhost:7888")));
-    }
-
-    @Test
-    public void exposeHeaders() {
-        final CorsConfig cors = withOrigin("*").exposeHeaders("custom-header1", "custom-header2").build();
-        assertThat(cors.exposedHeaders(), hasItems("custom-header1", "custom-header2"));
-    }
-
-    @Test
-    public void allowCredentials() {
-        final CorsConfig cors = withOrigin("*").allowCredentials().build();
-        assertThat(cors.isCredentialsAllowed(), is(true));
-    }
-
-    @Test
-    public void maxAge() {
-        final CorsConfig cors = withOrigin("*").maxAge(3000).build();
-        assertThat(cors.maxAge(), is(3000L));
-    }
-
-    @Test
-    public void requestMethods() {
-        final CorsConfig cors = withOrigin("*").allowedRequestMethods(HttpMethod.POST, HttpMethod.GET).build();
-        assertThat(cors.allowedRequestMethods(), hasItems(HttpMethod.POST, HttpMethod.GET));
-    }
-
-    @Test
-    public void requestHeaders() {
-        final CorsConfig cors = withOrigin("*").allowedRequestHeaders("preflight-header1", "preflight-header2").build();
-        assertThat(cors.allowedRequestHeaders(), hasItems("preflight-header1", "preflight-header2"));
-    }
-
-}
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
index dc7aa94db492..de2c611882a9 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
@@ -15,36 +15,38 @@
  */
 package io.netty.handler.codec.http.cors;
 
-import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
-import static io.netty.handler.codec.http.HttpMethod.GET;
-import static io.netty.handler.codec.http.HttpMethod.OPTIONS;
-import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.MatcherAssert.assertThat;
-
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.embedded.EmbeddedChannel;
-
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
-import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpResponseStatus;
 import org.junit.Test;
 
+import java.util.Arrays;
+import java.util.concurrent.Callable;
+
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static io.netty.handler.codec.http.HttpMethod.*;
+import static io.netty.handler.codec.http.HttpResponseStatus.FORBIDDEN;
+import static io.netty.handler.codec.http.HttpResponseStatus.OK;
+import static io.netty.handler.codec.http.HttpVersion.*;
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+
 public class CorsHandlerTest {
 
     @Test
     public void nonCorsRequest() {
-        final HttpResponse response = simpleRequest(CorsConfig.anyOrigin().build(), null);
+        final HttpResponse response = simpleRequest(CorsConfig.withAnyOrigin().build(), null);
         assertThat(response.headers().contains(ACCESS_CONTROL_ALLOW_ORIGIN), is(false));
     }
 
     @Test
     public void simpleRequestWithAnyOrigin() {
-        final HttpResponse response = simpleRequest(CorsConfig.anyOrigin().build(), "http://localhost:7777");
+        final HttpResponse response = simpleRequest(CorsConfig.withAnyOrigin().build(), "http://localhost:7777");
         assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is("*"));
     }
 
@@ -55,26 +57,99 @@ public void simpleRequestWithOrigin() {
         assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is(origin));
     }
 
+    @Test
+    public void simpleRequestWithOrigins() {
+        final String origin1 = "http://localhost:8888";
+        final String origin2 = "https://localhost:8888";
+        final String[] origins = {origin1, origin2};
+        final HttpResponse response1 = simpleRequest(CorsConfig.withOrigins(origins).build(), origin1);
+        assertThat(response1.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is(origin1));
+        final HttpResponse response2 = simpleRequest(CorsConfig.withOrigins(origins).build(), origin2);
+        assertThat(response2.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is(origin2));
+    }
+
+    @Test
+    public void simpleRequestWithNoMatchingOrigin() {
+        final String origin = "http://localhost:8888";
+        final HttpResponse response = simpleRequest(CorsConfig.withOrigins("https://localhost:8888").build(), origin);
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is(nullValue()));
+    }
+
     @Test
     public void preflightDeleteRequestWithCustomHeaders() {
         final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888")
-                .allowedRequestMethods(HttpMethod.GET, HttpMethod.DELETE)
+                .allowedRequestMethods(GET, DELETE)
                 .build();
         final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
         assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is("http://localhost:8888"));
         assertThat(response.headers().getAll(ACCESS_CONTROL_ALLOW_METHODS), hasItems("GET", "DELETE"));
+        assertThat(response.headers().get(VARY), equalTo(ORIGIN));
     }
 
     @Test
     public void preflightGetRequestWithCustomHeaders() {
         final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888")
-                .allowedRequestMethods(HttpMethod.OPTIONS, HttpMethod.GET, HttpMethod.DELETE)
+                .allowedRequestMethods(OPTIONS, GET, DELETE)
                 .allowedRequestHeaders("content-type", "xheader1")
                 .build();
         final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
         assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is("http://localhost:8888"));
         assertThat(response.headers().getAll(ACCESS_CONTROL_ALLOW_METHODS), hasItems("OPTIONS", "GET"));
         assertThat(response.headers().getAll(ACCESS_CONTROL_ALLOW_HEADERS), hasItems("content-type", "xheader1"));
+        assertThat(response.headers().get(VARY), equalTo(ORIGIN));
+    }
+
+    @Test
+    public void preflightRequestWithDefaultHeaders() {
+        final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888").build();
+        final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
+        assertThat(response.headers().get(CONTENT_LENGTH), is("0"));
+        assertThat(response.headers().get(DATE), is(notNullValue()));
+        assertThat(response.headers().get(VARY), equalTo(ORIGIN));
+    }
+
+    @Test
+    public void preflightRequestWithCustomHeader() {
+        final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888")
+                .preflightResponseHeader("CustomHeader", "somevalue")
+                .build();
+        final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
+        assertThat(response.headers().get("CustomHeader"), equalTo("somevalue"));
+        assertThat(response.headers().get(VARY), equalTo(ORIGIN));
+    }
+
+    @Test
+    public void preflightRequestWithCustomHeaders() {
+        final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888")
+                .preflightResponseHeader("CustomHeader", "value1", "value2")
+                .build();
+        final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
+        assertThat(response.headers().getAll("CustomHeader"), hasItems("value1", "value2"));
+        assertThat(response.headers().get(VARY), equalTo(ORIGIN));
+    }
+
+    @Test
+    public void preflightRequestWithCustomHeadersIterable() {
+        final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888")
+                .preflightResponseHeader("CustomHeader", Arrays.asList("value1", "value2"))
+                .build();
+        final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
+        assertThat(response.headers().getAll("CustomHeader"), hasItems("value1", "value2"));
+        assertThat(response.headers().get(VARY), equalTo(ORIGIN));
+    }
+
+    @Test
+    public void preflightRequestWithValueGenerator() {
+        final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888")
+                .preflightResponseHeader("GenHeader", new Callable<String>() {
+                    @Override
+                    public String call() throws Exception {
+                        return "generatedValue";
+                    }
+                }).build();
+        final HttpResponse response = preflightRequest(config, "http://localhost:8888", "content-type, xheader1");
+        assertThat(response.headers().get("GenHeader"), equalTo("generatedValue"));
+        assertThat(response.headers().get(VARY), equalTo(ORIGIN));
     }
 
     @Test
@@ -103,33 +178,65 @@ public void preflightRequestDoNotAllowCredentials() {
 
     @Test
     public void simpleRequestCustomHeaders() {
-        final CorsConfig config = CorsConfig.anyOrigin().exposeHeaders("custom1", "custom2").build();
-        final HttpResponse response = simpleRequest(config, "http://localhost:7777", "");
+        final CorsConfig config = CorsConfig.withAnyOrigin().exposeHeaders("custom1", "custom2").build();
+        final HttpResponse response = simpleRequest(config, "http://localhost:7777");
         assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), equalTo("*"));
         assertThat(response.headers().getAll(ACCESS_CONTROL_EXPOSE_HEADERS), hasItems("custom1", "custom1"));
     }
 
     @Test
     public void simpleRequestAllowCredentials() {
-        final CorsConfig config = CorsConfig.anyOrigin().allowCredentials().build();
-        final HttpResponse response = simpleRequest(config, "http://localhost:7777", "");
+        final CorsConfig config = CorsConfig.withAnyOrigin().allowCredentials().build();
+        final HttpResponse response = simpleRequest(config, "http://localhost:7777");
         assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_CREDENTIALS), equalTo("true"));
     }
 
     @Test
     public void simpleRequestDoNotAllowCredentials() {
-        final CorsConfig config = CorsConfig.anyOrigin().build();
-        final HttpResponse response = simpleRequest(config, "http://localhost:7777", "");
+        final CorsConfig config = CorsConfig.withAnyOrigin().build();
+        final HttpResponse response = simpleRequest(config, "http://localhost:7777");
         assertThat(response.headers().contains(ACCESS_CONTROL_ALLOW_CREDENTIALS), is(false));
     }
 
+    @Test
+    public void anyOriginAndAllowCredentialsShouldEchoRequestOrigin() {
+        final CorsConfig config = CorsConfig.withAnyOrigin().allowCredentials().build();
+        final HttpResponse response = simpleRequest(config, "http://localhost:7777");
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_CREDENTIALS), equalTo("true"));
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), equalTo("http://localhost:7777"));
+        assertThat(response.headers().get(VARY), equalTo(ORIGIN));
+    }
+
     @Test
     public void simpleRequestExposeHeaders() {
-        final CorsConfig config = CorsConfig.anyOrigin().exposeHeaders("one", "two").build();
-        final HttpResponse response = simpleRequest(config, "http://localhost:7777", "");
+        final CorsConfig config = CorsConfig.withAnyOrigin().exposeHeaders("one", "two").build();
+        final HttpResponse response = simpleRequest(config, "http://localhost:7777");
         assertThat(response.headers().getAll(ACCESS_CONTROL_EXPOSE_HEADERS), hasItems("one", "two"));
     }
 
+    @Test
+    public void simpleRequestShortCurcuit() {
+        final CorsConfig config = CorsConfig.withOrigin("http://localhost:8080").shortCurcuit().build();
+        final HttpResponse response = simpleRequest(config, "http://localhost:7777");
+        assertThat(response.status(), is(FORBIDDEN));
+    }
+
+    @Test
+    public void simpleRequestNoShortCurcuit() {
+        final CorsConfig config = CorsConfig.withOrigin("http://localhost:8080").build();
+        final HttpResponse response = simpleRequest(config, "http://localhost:7777");
+        assertThat(response.status(), is(OK));
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is(nullValue()));
+    }
+
+    @Test
+    public void shortCurcuitNonCorsRequest() {
+        final CorsConfig config = CorsConfig.withOrigin("https://localhost").shortCurcuit().build();
+        final HttpResponse response = simpleRequest(config, null);
+        assertThat(response.status(), is(OK));
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is(nullValue()));
+    }
+
     private static HttpResponse simpleRequest(final CorsConfig config, final String origin) {
         return simpleRequest(config, origin, null);
     }
@@ -162,7 +269,7 @@ private static HttpResponse preflightRequest(final CorsConfig config,
         final EmbeddedChannel channel = new EmbeddedChannel(new CorsHandler(config));
         final FullHttpRequest httpRequest = createHttpRequest(OPTIONS);
         httpRequest.headers().set(ORIGIN, origin);
-        httpRequest.headers().set(ACCESS_CONTROL_REQUEST_METHOD, httpRequest.getMethod().toString());
+        httpRequest.headers().set(ACCESS_CONTROL_REQUEST_METHOD, httpRequest.method().toString());
         httpRequest.headers().set(ACCESS_CONTROL_REQUEST_HEADERS, requestHeaders);
         channel.writeInbound(httpRequest);
         return (HttpResponse) channel.readOutbound();
@@ -173,11 +280,9 @@ private static FullHttpRequest createHttpRequest(HttpMethod method) {
     }
 
     private static class EchoHandler extends SimpleChannelInboundHandler<Object> {
-
         @Override
         public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
-            ctx.writeAndFlush(new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.OK));
+            ctx.writeAndFlush(new DefaultFullHttpResponse(HTTP_1_1, OK));
         }
     }
-
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java
index 34844614ee26..f63da4ce7476 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java
@@ -68,7 +68,7 @@ private static final class TestHttpData extends AbstractMemoryHttpData {
          * @param charset Used charset for data decoding.
          * @param size    Expected data block size.
          */
-        protected TestHttpData(String name, Charset charset, long size) {
+        private TestHttpData(String name, Charset charset, long size) {
             super(name, charset, size);
         }
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
index d1fbd0fd79e8..500d47e3863a 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpVersion;
@@ -128,6 +129,85 @@ public void testFullHttpRequestUpload() throws Exception {
         decoder.destroy();
     }
 
+    // See https://github.com/netty/netty/issues/2544
+    @Test
+    public void testMultipartCodecWithCRasEndOfAttribute() throws Exception {
+        final String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO";
+
+        // Force to use memory-based data.
+        final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory(false);
+        // Build test case
+        String extradata = "aaaa";
+        String[] datas = new String[5];
+        for (int i = 0; i < 4; i++) {
+            datas[i] = extradata;
+            for (int j = 0; j < i; j++) {
+                datas[i] += '\r';
+            }
+        }
+
+        for (int i = 0; i < 4; i++) {
+            final DefaultFullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST,
+                    "http://localhost");
+            req.setDecoderResult(DecoderResult.SUCCESS);
+            req.headers().add(HttpHeaders.Names.CONTENT_TYPE, "multipart/form-data; boundary=" + boundary);
+            req.headers().add(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+            final String body =
+                    "--" + boundary + "\r\n" +
+                            "Content-Disposition: form-data; name=\"file" + i + "\"\r\n" +
+                            "Content-Type: image/gif\r\n" +
+                            "\r\n" +
+                            datas[i] + "\r\n" +
+                            "--" + boundary + "--\r\n";
+
+            req.content().writeBytes(body.getBytes(CharsetUtil.UTF_8));
+            // Create decoder instance to test.
+            final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(inMemoryFactory, req);
+            assertFalse(decoder.getBodyHttpDatas().isEmpty());
+            // Check correctness: data size
+            InterfaceHttpData httpdata = decoder.getBodyHttpData("file" + i);
+            assertNotNull(httpdata);
+            Attribute attribute = (Attribute) httpdata;
+            byte[] datar = attribute.get();
+            assertNotNull(datar);
+            assertEquals(datas[i].getBytes(CharsetUtil.UTF_8).length, datar.length);
+
+            decoder.destroy();
+        }
+    }
+
+    // See https://github.com/netty/netty/issues/2542
+    @Test
+    public void testQuotedBoundary() throws Exception {
+        final String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO";
+
+        final DefaultFullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST,
+                "http://localhost");
+
+        req.setDecoderResult(DecoderResult.SUCCESS);
+        req.headers().add(HttpHeaders.Names.CONTENT_TYPE, "multipart/form-data; boundary=\"" + boundary + '"');
+        req.headers().add(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);
+
+        // Force to use memory-based data.
+        final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory(false);
+
+        for (String data : Arrays.asList("", "\r", "\r\r", "\r\r\r")) {
+            final String body =
+                    "--" + boundary + "\r\n" +
+                            "Content-Disposition: form-data; name=\"file\"; filename=\"tmp-0.txt\"\r\n" +
+                            "Content-Type: image/gif\r\n" +
+                            "\r\n" +
+                            data + "\r\n" +
+                            "--" + boundary + "--\r\n";
+
+            req.content().writeBytes(body.getBytes(CharsetUtil.UTF_8));
+        }
+        // Create decoder instance to test.
+        final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(inMemoryFactory, req);
+        assertFalse(decoder.getBodyHttpDatas().isEmpty());
+        decoder.destroy();
+    }
+
     // See https://github.com/netty/netty/issues/1848
     @Test
     public void testNoZeroOut() throws Exception {
@@ -186,4 +266,58 @@ public void testNoZeroOut() throws Exception {
         aDecodedData.release();
         aDecoder.destroy();
     }
+
+    // See https://github.com/netty/netty/issues/2305
+    @Test
+    public void testChunkCorrect() throws Exception {
+       String payload = "town=794649819&town=784444184&town=794649672&town=794657800&town=" +
+                "794655734&town=794649377&town=794652136&town=789936338&town=789948986&town=" +
+                "789949643&town=786358677&town=794655880&town=786398977&town=789901165&town=" +
+                "789913325&town=789903418&town=789903579&town=794645251&town=794694126&town=" +
+                "794694831&town=794655274&town=789913656&town=794653956&town=794665634&town=" +
+                "789936598&town=789904658&town=789899210&town=799696252&town=794657521&town=" +
+                "789904837&town=789961286&town=789958704&town=789948839&town=789933899&town=" +
+                "793060398&town=794659180&town=794659365&town=799724096&town=794696332&town=" +
+                "789953438&town=786398499&town=794693372&town=789935439&town=794658041&town=" +
+                "789917595&town=794655427&town=791930372&town=794652891&town=794656365&town=" +
+                "789960339&town=794645586&town=794657688&town=794697211&town=789937427&town=" +
+                "789902813&town=789941130&town=794696907&town=789904328&town=789955151&town=" +
+                "789911570&town=794655074&town=789939531&town=789935242&town=789903835&town=" +
+                "789953800&town=794649962&town=789939841&town=789934819&town=789959672&town=" +
+                "794659043&town=794657035&town=794658938&town=794651746&town=794653732&town=" +
+                "794653881&town=786397909&town=794695736&town=799724044&town=794695926&town=" +
+                "789912270&town=794649030&town=794657946&town=794655370&town=794659660&town=" +
+                "794694617&town=799149862&town=789953234&town=789900476&town=794654995&town=" +
+                "794671126&town=789908868&town=794652942&town=789955605&town=789901934&town=" +
+                "789950015&town=789937922&town=789962576&town=786360170&town=789954264&town=" +
+                "789911738&town=789955416&town=799724187&town=789911879&town=794657462&town=" +
+                "789912561&town=789913167&town=794655195&town=789938266&town=789952099&town=" +
+                "794657160&town=789949414&town=794691293&town=794698153&town=789935636&town=" +
+                "789956374&town=789934635&town=789935475&town=789935085&town=794651425&town=" +
+                "794654936&town=794655680&town=789908669&town=794652031&town=789951298&town=" +
+                "789938382&town=794651503&town=794653330&town=817675037&town=789951623&town=" +
+                "789958999&town=789961555&town=794694050&town=794650241&town=794656286&town=" +
+                "794692081&town=794660090&town=794665227&town=794665136&town=794669931";
+        DefaultHttpRequest defaultHttpRequest =
+                    new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/");
+
+        HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(defaultHttpRequest);
+
+        int firstChunk = 10;
+        int middleChunk = 1024;
+
+        HttpContent part1 = new DefaultHttpContent(Unpooled.wrappedBuffer(
+                payload.substring(0, firstChunk).getBytes()));
+        HttpContent part2 = new DefaultHttpContent(Unpooled.wrappedBuffer(
+                payload.substring(firstChunk, firstChunk + middleChunk).getBytes()));
+        HttpContent part3 = new DefaultHttpContent(Unpooled.wrappedBuffer(
+                payload.substring(firstChunk + middleChunk, firstChunk + middleChunk * 2).getBytes()));
+        HttpContent part4 = new DefaultHttpContent(Unpooled.wrappedBuffer(
+                payload.substring(firstChunk + middleChunk * 2).getBytes()));
+
+        decoder.offer(part1);
+        decoder.offer(part2);
+        decoder.offer(part3);
+        decoder.offer(part4);
+    }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoderTest.java
index a97245482489..26273e616009 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoderTest.java
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.multipart.HttpPostRequestEncoder.EncoderMode;
 import io.netty.util.CharsetUtil;
 import io.netty.util.internal.StringUtil;
 import org.junit.Test;
@@ -110,6 +111,81 @@ public void testMultiFileUploadInMixedMode() throws Exception {
         assertEquals(expected, content);
     }
 
+    @Test
+    public void testSingleFileUploadInHtml5Mode() throws Exception {
+        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,
+                HttpMethod.POST, "http://localhost");
+
+        DefaultHttpDataFactory factory = new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE);
+
+        HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(factory,
+                request, true, CharsetUtil.UTF_8, EncoderMode.HTML5);
+        File file1 = new File(getClass().getResource("/file-01.txt").toURI());
+        File file2 = new File(getClass().getResource("/file-02.txt").toURI());
+        encoder.addBodyAttribute("foo", "bar");
+        encoder.addBodyFileUpload("quux", file1, "text/plain", false);
+        encoder.addBodyFileUpload("quux", file2, "text/plain", false);
+
+        String multipartDataBoundary = encoder.multipartDataBoundary;
+        String content = getRequestBody(encoder);
+
+        String expected = "--" + multipartDataBoundary + "\r\n" +
+                "Content-Disposition: form-data; name=\"foo\"" + "\r\n" +
+                "Content-Type: text/plain; charset=UTF-8" + "\r\n" +
+                "\r\n" +
+                "bar" + "\r\n" +
+                "--" + multipartDataBoundary + "\r\n" +
+                "Content-Disposition: form-data; name=\"quux\"; filename=\"file-01.txt\"" + "\r\n" +
+                "Content-Type: text/plain" + "\r\n" +
+                "Content-Transfer-Encoding: binary" + "\r\n" +
+                "\r\n" +
+                "File 01" + StringUtil.NEWLINE + "\r\n" +
+                "--" + multipartDataBoundary + "\r\n" +
+                "Content-Disposition: form-data; name=\"quux\"; filename=\"file-02.txt\"" + "\r\n" +
+                "Content-Type: text/plain" + "\r\n" +
+                "Content-Transfer-Encoding: binary" + "\r\n" +
+                "\r\n" +
+                "File 02" + StringUtil.NEWLINE +
+                "\r\n" +
+                "--" + multipartDataBoundary + "--" + "\r\n";
+
+        assertEquals(expected, content);
+    }
+
+    @Test
+    public void testMultiFileUploadInHtml5Mode() throws Exception {
+        DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,
+                HttpMethod.POST, "http://localhost");
+
+        DefaultHttpDataFactory factory = new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE);
+
+        HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(factory,
+                request, true, CharsetUtil.UTF_8, EncoderMode.HTML5);
+        File file1 = new File(getClass().getResource("/file-01.txt").toURI());
+        encoder.addBodyAttribute("foo", "bar");
+        encoder.addBodyFileUpload("quux", file1, "text/plain", false);
+
+        String multipartDataBoundary = encoder.multipartDataBoundary;
+        String content = getRequestBody(encoder);
+
+        String expected = "--" + multipartDataBoundary + "\r\n" +
+                "Content-Disposition: form-data; name=\"foo\"" + "\r\n" +
+                "Content-Type: text/plain; charset=UTF-8" + "\r\n" +
+                "\r\n" +
+                "bar" +
+                "\r\n" +
+                "--" + multipartDataBoundary + "\r\n" +
+                "Content-Disposition: form-data; name=\"quux\"; filename=\"file-01.txt\"" + "\r\n" +
+                "Content-Type: text/plain" + "\r\n" +
+                "Content-Transfer-Encoding: binary" + "\r\n" +
+                "\r\n" +
+                "File 01" + StringUtil.NEWLINE +
+                "\r\n" +
+                "--" + multipartDataBoundary + "--" + "\r\n";
+
+        assertEquals(expected, content);
+    }
+
     private static String getRequestBody(HttpPostRequestEncoder encoder) throws Exception {
         encoder.finalizeRequest();
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoderTest.java
new file mode 100644
index 000000000000..86816560bb5e
--- /dev/null
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoderTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the "License");
+ * you may not use this file except in compliance with the License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and limitations under the License.
+ */
+package io.netty.handler.codec.http.websocketx;
+
+import io.netty.channel.ChannelHandlerContext;
+
+import org.easymock.EasyMock;
+import org.junit.Test;
+
+public class WebSocket08FrameDecoderTest {
+
+    @Test
+    public void channelInactive() throws Exception {
+        final WebSocket08FrameDecoder decoder = new WebSocket08FrameDecoder(true, true, 65535);
+        final ChannelHandlerContext ctx = EasyMock.createMock(ChannelHandlerContext.class);
+        decoder.channelInactive(ctx);
+    }
+
+}
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java
index 35dd87c66572..1cbd5476af43 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java
@@ -47,25 +47,25 @@ public void testAggregationBinary() {
 
         Assert.assertTrue(channel.finish());
 
-        BinaryWebSocketFrame frame = (BinaryWebSocketFrame) channel.readInbound();
+        BinaryWebSocketFrame frame = channel.readInbound();
         Assert.assertTrue(frame.isFinalFragment());
         Assert.assertEquals(1, frame.rsv());
         Assert.assertEquals(content1, frame.content());
         frame.release();
 
-        PingWebSocketFrame frame2 = (PingWebSocketFrame) channel.readInbound();
+        PingWebSocketFrame frame2 = channel.readInbound();
         Assert.assertTrue(frame2.isFinalFragment());
         Assert.assertEquals(0, frame2.rsv());
         Assert.assertEquals(content1, frame2.content());
         frame2.release();
 
-        PongWebSocketFrame frame3 = (PongWebSocketFrame) channel.readInbound();
+        PongWebSocketFrame frame3 = channel.readInbound();
         Assert.assertTrue(frame3.isFinalFragment());
         Assert.assertEquals(0, frame3.rsv());
         Assert.assertEquals(content1, frame3.content());
         frame3.release();
 
-        BinaryWebSocketFrame frame4 = (BinaryWebSocketFrame) channel.readInbound();
+        BinaryWebSocketFrame frame4 = channel.readInbound();
         Assert.assertTrue(frame4.isFinalFragment());
         Assert.assertEquals(0, frame4.rsv());
         Assert.assertEquals(aggregatedContent, frame4.content());
@@ -86,25 +86,25 @@ public void testAggregationText() {
 
         Assert.assertTrue(channel.finish());
 
-        TextWebSocketFrame frame = (TextWebSocketFrame) channel.readInbound();
+        TextWebSocketFrame frame = channel.readInbound();
         Assert.assertTrue(frame.isFinalFragment());
         Assert.assertEquals(1, frame.rsv());
         Assert.assertEquals(content1, frame.content());
         frame.release();
 
-        PingWebSocketFrame frame2 = (PingWebSocketFrame) channel.readInbound();
+        PingWebSocketFrame frame2 = channel.readInbound();
         Assert.assertTrue(frame2.isFinalFragment());
         Assert.assertEquals(0, frame2.rsv());
         Assert.assertEquals(content1, frame2.content());
         frame2.release();
 
-        PongWebSocketFrame frame3 = (PongWebSocketFrame) channel.readInbound();
+        PongWebSocketFrame frame3 = channel.readInbound();
         Assert.assertTrue(frame3.isFinalFragment());
         Assert.assertEquals(0, frame3.rsv());
         Assert.assertEquals(content1, frame3.content());
         frame3.release();
 
-        TextWebSocketFrame frame4 = (TextWebSocketFrame) channel.readInbound();
+        TextWebSocketFrame frame4 = channel.readInbound();
         Assert.assertTrue(frame4.isFinalFragment());
         Assert.assertEquals(0, frame4.rsv());
         Assert.assertEquals(aggregatedContent, frame4.content());
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
index 12a2caa97d5d..c6e433948d99 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
@@ -72,15 +72,16 @@ private static void testPerformOpeningHandshake0(boolean subProtocol) {
 
         EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(ch.readOutbound());
-        HttpResponse res = (HttpResponse) ch2.readInbound();
+        HttpResponse res = ch2.readInbound();
 
         Assert.assertEquals("ws://example.com/chat", res.headers().get(Names.SEC_WEBSOCKET_LOCATION));
+
         if (subProtocol) {
             Assert.assertEquals("chat", res.headers().get(Names.SEC_WEBSOCKET_PROTOCOL));
         } else {
             Assert.assertNull(res.headers().get(Names.SEC_WEBSOCKET_PROTOCOL));
         }
-        LastHttpContent content = (LastHttpContent) ch2.readInbound();
+        LastHttpContent content = ch2.readInbound();
 
         Assert.assertEquals("8jKS'y:G*Co,Wxa-", content.content().toString(CharsetUtil.US_ASCII));
         content.release();
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
index 86ab216e3061..17593f0651aa 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
@@ -67,11 +67,11 @@ private static void testPerformOpeningHandshake0(boolean subProtocol) {
                     "ws://example.com/chat", null, false, Integer.MAX_VALUE).handshake(ch, req);
         }
 
-        ByteBuf resBuf = (ByteBuf) ch.readOutbound();
+        ByteBuf resBuf = ch.readOutbound();
 
         EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(resBuf);
-        HttpResponse res = (HttpResponse) ch2.readInbound();
+        HttpResponse res = ch2.readInbound();
 
         Assert.assertEquals(
                 "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", res.headers().get(Names.SEC_WEBSOCKET_ACCEPT));
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
index 6a94784e94b8..233ee5ac318b 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
@@ -67,11 +67,11 @@ private static void testPerformOpeningHandshake0(boolean subProtocol) {
                     "ws://example.com/chat", null, false, Integer.MAX_VALUE).handshake(ch, req);
         }
 
-        ByteBuf resBuf = (ByteBuf) ch.readOutbound();
+        ByteBuf resBuf = ch.readOutbound();
 
         EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(resBuf);
-        HttpResponse res = (HttpResponse) ch2.readInbound();
+        HttpResponse res = ch2.readInbound();
 
         Assert.assertEquals(
                 "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=", res.headers().get(Names.SEC_WEBSOCKET_ACCEPT));
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
index bf89cf539e58..98952caf4b46 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
@@ -54,7 +54,7 @@ public void testHttpUpgradeRequest() throws Exception {
         EmbeddedChannel ch = createChannel(new MockOutboundHandler());
         ChannelHandlerContext handshakerCtx = ch.pipeline().context(WebSocketServerProtocolHandshakeHandler.class);
         writeUpgradeRequest(ch);
-        assertEquals(SWITCHING_PROTOCOLS, ReferenceCountUtil.releaseLater(responses.remove()).getStatus());
+        assertEquals(SWITCHING_PROTOCOLS, ReferenceCountUtil.releaseLater(responses.remove()).status());
         assertNotNull(WebSocketServerProtocolHandler.getHandshaker(handshakerCtx));
     }
 
@@ -63,10 +63,10 @@ public void testSubsequentHttpRequestsAfterUpgradeShouldReturn403() throws Excep
         EmbeddedChannel ch = createChannel();
 
         writeUpgradeRequest(ch);
-        assertEquals(SWITCHING_PROTOCOLS, ReferenceCountUtil.releaseLater(responses.remove()).getStatus());
+        assertEquals(SWITCHING_PROTOCOLS, ReferenceCountUtil.releaseLater(responses.remove()).status());
 
         ch.writeInbound(new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, "/test"));
-        assertEquals(FORBIDDEN, ReferenceCountUtil.releaseLater(responses.remove()).getStatus());
+        assertEquals(FORBIDDEN, ReferenceCountUtil.releaseLater(responses.remove()).status());
     }
 
     @Test
@@ -83,7 +83,7 @@ public void testHttpUpgradeRequestInvalidUpgradeHeader() {
         ch.writeInbound(httpRequestWithEntity);
 
         FullHttpResponse response = ReferenceCountUtil.releaseLater(responses.remove());
-        assertEquals(BAD_REQUEST, response.getStatus());
+        assertEquals(BAD_REQUEST, response.status());
         assertEquals("not a WebSocket handshake request: missing upgrade", getResponseMessage(response));
     }
 
@@ -102,7 +102,7 @@ public void testHttpUpgradeRequestMissingWSKeyHeader() {
         ch.writeInbound(httpRequest);
 
         FullHttpResponse response = ReferenceCountUtil.releaseLater(responses.remove());
-        assertEquals(BAD_REQUEST, response.getStatus());
+        assertEquals(BAD_REQUEST, response.status());
         assertEquals("not a WebSocket request: missing key", getResponseMessage(response));
     }
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java
index 6b56ad5736f1..5c42ae362f07 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -15,410 +15,1356 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.bootstrap.Bootstrap;
-import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.channel.socket.nio.NioServerSocketChannel;
-import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.util.NetUtil;
-import org.junit.AfterClass;
+import io.netty.buffer.Unpooled;
+import io.netty.util.ReferenceCountUtil;
+import org.junit.Before;
 import org.junit.Test;
 
-import java.net.InetSocketAddress;
-import java.util.Arrays;
-import java.util.List;
+import java.util.Random;
 
+import static io.netty.handler.codec.spdy.SpdyCodecUtil.SPDY_HEADER_SIZE;
+import static org.easymock.EasyMock.anyObject;
+import static org.easymock.EasyMock.createStrictMock;
+import static org.easymock.EasyMock.expectLastCall;
+import static org.easymock.EasyMock.replay;
+import static org.easymock.EasyMock.verify;
 import static org.junit.Assert.*;
 
 public class SpdyFrameDecoderTest {
 
-    private static final EventLoopGroup group = new NioEventLoopGroup();
+    private static final Random RANDOM = new Random();
 
-    @AfterClass
-    public static void destroy() throws Exception {
-        group.shutdownGracefully().sync();
+    private final SpdyFrameDecoderDelegate delegate = createStrictMock(SpdyFrameDecoderDelegate.class);
+    private SpdyFrameDecoder decoder;
+
+    @Before
+    public void createDecoder() {
+        decoder = new SpdyFrameDecoder(SpdyVersion.SPDY_3_1, new SpdyFrameDecoderDelegate() {
+            @Override
+            public void readDataFrame(int streamId, boolean last, ByteBuf data) {
+                try {
+                    delegate.readDataFrame(streamId, last, data);
+                } finally {
+                    // release the data after we delegate it and so checked it.
+                    data.release();
+                }
+            }
+
+            @Override
+            public void readSynStreamFrame(int streamId, int associatedToStreamId,
+                                           byte priority, boolean last, boolean unidirectional) {
+                delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, last, unidirectional);
+            }
+
+            @Override
+            public void readSynReplyFrame(int streamId, boolean last) {
+                delegate.readSynReplyFrame(streamId, last);
+            }
+
+            @Override
+            public void readRstStreamFrame(int streamId, int statusCode) {
+                delegate.readRstStreamFrame(streamId, statusCode);
+            }
+
+            @Override
+            public void readSettingsFrame(boolean clearPersisted) {
+                delegate.readSettingsFrame(clearPersisted);
+            }
+
+            @Override
+            public void readSetting(int id, int value, boolean persistValue, boolean persisted) {
+                delegate.readSetting(id, value, persistValue, persisted);
+            }
+
+            @Override
+            public void readSettingsEnd() {
+                delegate.readSettingsEnd();
+            }
+
+            @Override
+            public void readPingFrame(int id) {
+                delegate.readPingFrame(id);
+            }
+
+            @Override
+            public void readGoAwayFrame(int lastGoodStreamId, int statusCode) {
+                delegate.readGoAwayFrame(lastGoodStreamId, statusCode);
+            }
+
+            @Override
+            public void readHeadersFrame(int streamId, boolean last) {
+                delegate.readHeadersFrame(streamId, last);
+            }
+
+            @Override
+            public void readWindowUpdateFrame(int streamId, int deltaWindowSize) {
+                delegate.readWindowUpdateFrame(streamId, deltaWindowSize);
+            }
+
+            @Override
+            public void readHeaderBlock(ByteBuf headerBlock) {
+                try {
+                    delegate.readHeaderBlock(headerBlock);
+                } finally {
+                    // release the data after we delegate it and so checked it.
+                    headerBlock.release();
+                }
+            }
+
+            @Override
+            public void readHeaderBlockEnd() {
+                delegate.readHeaderBlockEnd();
+            }
+
+            @Override
+            public void readFrameError(String message) {
+                delegate.readFrameError(message);
+            }
+        });
+    }
+
+    private static void encodeDataFrameHeader(ByteBuf buffer, int streamId, byte flags, int length) {
+        buffer.writeInt(streamId & 0x7FFFFFFF);
+        buffer.writeByte(flags);
+        buffer.writeMedium(length);
+    }
+
+    private static void encodeControlFrameHeader(ByteBuf buffer, short type, byte flags, int length) {
+        buffer.writeShort(0x8000 | SpdyVersion.SPDY_3_1.getVersion());
+        buffer.writeShort(type);
+        buffer.writeByte(flags);
+        buffer.writeMedium(length);
     }
 
     @Test
-    public void testTooLargeHeaderNameOnSynStreamRequest() throws Exception {
-        testTooLargeHeaderNameOnSynStreamRequest(SpdyVersion.SPDY_3);
-        testTooLargeHeaderNameOnSynStreamRequest(SpdyVersion.SPDY_3_1);
+    public void testSpdyDataFrame() throws Exception {
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        byte flags = 0;
+        int length = 1024;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeDataFrameHeader(buf, streamId, flags, length);
+        for (int i = 0; i < 256; i ++) {
+            buf.writeInt(RANDOM.nextInt());
+        }
+        delegate.readDataFrame(streamId, false, buf.slice(SPDY_HEADER_SIZE, length));
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
     }
 
-    private static void testTooLargeHeaderNameOnSynStreamRequest(final SpdyVersion version) throws Exception {
-        List<Integer> headerSizes = Arrays.asList(90, 900);
-        for (final int maxHeaderSize : headerSizes) { // 90 catches the header name, 900 the value
-            SpdyHeadersFrame frame = new DefaultSpdySynStreamFrame(1, 0, (byte) 0);
-            addHeader(frame, 100, 1000);
-            final CaptureHandler captureHandler = new CaptureHandler();
-            ServerBootstrap sb = new ServerBootstrap();
-            sb.group(group);
-            sb.channel(NioServerSocketChannel.class);
-            sb.childHandler(new ChannelInitializer<SocketChannel>() {
-                @Override
-                protected void initChannel(SocketChannel ch) throws Exception {
-                    ch.pipeline().addLast(
-                            new SpdyFrameDecoder(version, 10000, maxHeaderSize),
-                            new SpdySessionHandler(version, true),
-                            captureHandler);
-                }
-            });
-
-            Bootstrap cb = new Bootstrap();
-            cb.group(group);
-            cb.channel(NioSocketChannel.class);
-            cb.handler(new ChannelInitializer<SocketChannel>() {
-                @Override
-                protected void initChannel(SocketChannel ch) throws Exception {
-                    ch.pipeline().addLast(new SpdyFrameEncoder(version));
-                }
-            });
-            Channel sc = sb.bind(0).sync().channel();
-            int port = ((InetSocketAddress) sc.localAddress()).getPort();
+    @Test
+    public void testEmptySpdyDataFrame() throws Exception {
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        byte flags = 0;
+        int length = 0;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeDataFrameHeader(buf, streamId, flags, length);
+
+        delegate.readDataFrame(streamId, false, Unpooled.EMPTY_BUFFER);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-            Channel cc = cb.connect(NetUtil.LOCALHOST, port).sync().channel();
+    @Test
+    public void testLastSpdyDataFrame() throws Exception {
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        byte flags = 0x01; // FLAG_FIN
+        int length = 0;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeDataFrameHeader(buf, streamId, flags, length);
+
+        delegate.readDataFrame(streamId, true, Unpooled.EMPTY_BUFFER);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testUnknownSpdyDataFrameFlags() throws Exception {
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        byte flags = (byte) 0xFE; // should ignore any unknown flags
+        int length = 0;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeDataFrameHeader(buf, streamId, flags, length);
+
+        delegate.readDataFrame(streamId, false, Unpooled.EMPTY_BUFFER);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testIllegalSpdyDataFrameStreamId() throws Exception {
+        int streamId = 0; // illegal stream identifier
+        byte flags = 0;
+        int length = 0;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeDataFrameHeader(buf, streamId, flags, length);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testPipelinedSpdyDataFrames() throws Exception {
+        int streamId1 = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int streamId2 = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        byte flags = 0;
+        int length = 0;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(2 * (SPDY_HEADER_SIZE + length)));
+        encodeDataFrameHeader(buf, streamId1, flags, length);
+        encodeDataFrameHeader(buf, streamId2, flags, length);
+
+        delegate.readDataFrame(streamId1, false, Unpooled.EMPTY_BUFFER);
+        delegate.readDataFrame(streamId2, false, Unpooled.EMPTY_BUFFER);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testSpdySynStreamFrame() throws Exception {
+        short type = 1;
+        byte flags = 0;
+        int length = 10;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        byte priority = (byte) (RANDOM.nextInt() & 0x07);
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(associatedToStreamId);
+        buf.writeByte(priority << 5);
+        buf.writeByte(0);
+
+        delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-            sendAndWaitForFrame(cc, frame, captureHandler);
+    @Test
+    public void testLastSpdySynStreamFrame() throws Exception {
+        short type = 1;
+        byte flags = 0x01; // FLAG_FIN
+        int length = 10;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        byte priority = (byte) (RANDOM.nextInt() & 0x07);
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(associatedToStreamId);
+        buf.writeByte(priority << 5);
+        buf.writeByte(0);
+
+        delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, true, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testUnidirectionalSpdySynStreamFrame() throws Exception {
+        short type = 1;
+        byte flags = 0x02; // FLAG_UNIDIRECTIONAL
+        int length = 10;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        byte priority = (byte) (RANDOM.nextInt() & 0x07);
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(associatedToStreamId);
+        buf.writeByte(priority << 5);
+        buf.writeByte(0);
+
+        delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, false, true);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testIndependentSpdySynStreamFrame() throws Exception {
+        short type = 1;
+        byte flags = 0;
+        int length = 10;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int associatedToStreamId = 0; // independent of all other streams
+        byte priority = (byte) (RANDOM.nextInt() & 0x07);
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(associatedToStreamId);
+        buf.writeByte(priority << 5);
+        buf.writeByte(0);
+
+        delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testUnknownSpdySynStreamFrameFlags() throws Exception {
+        short type = 1;
+        byte flags = (byte) 0xFC; // undefined flags
+        int length = 10;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        byte priority = (byte) (RANDOM.nextInt() & 0x07);
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(associatedToStreamId);
+        buf.writeByte(priority << 5);
+        buf.writeByte(0);
+
+        delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testReservedSpdySynStreamFrameBits() throws Exception {
+        short type = 1;
+        byte flags = 0;
+        int length = 10;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        byte priority = (byte) (RANDOM.nextInt() & 0x07);
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit
+        buf.writeInt(associatedToStreamId | 0x80000000); // should ignore reserved bit
+        buf.writeByte(priority << 5 | 0x1F); // should ignore reserved bits
+        buf.writeByte(0xFF); // should ignore reserved bits
+
+        delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-            assertNotNull("version " + version + ", not null message",
-                    captureHandler.message);
-            String message = "version " + version + ", should be SpdyHeadersFrame, was " +
-                    captureHandler.message.getClass();
-            assertTrue(
-                    message,
-                    captureHandler.message instanceof SpdyHeadersFrame);
-            SpdyHeadersFrame writtenFrame = (SpdyHeadersFrame) captureHandler.message;
+    @Test
+    public void testInvalidSpdySynStreamFrameLength() throws Exception {
+        short type = 1;
+        byte flags = 0;
+        int length = 8; // invalid length
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(associatedToStreamId);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-            assertTrue("should be truncated", writtenFrame.isTruncated());
-            assertFalse("should not be invalid", writtenFrame.isInvalid());
+    @Test
+    public void testIllegalSpdySynStreamFrameStreamId() throws Exception {
+        short type = 1;
+        byte flags = 0;
+        int length = 10;
+        int streamId = 0; // invalid stream identifier
+        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        byte priority = (byte) (RANDOM.nextInt() & 0x07);
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(associatedToStreamId);
+        buf.writeByte(priority << 5);
+        buf.writeByte(0);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-            sc.close().sync();
-            cc.close().sync();
+    @Test
+    public void testSpdySynStreamFrameHeaderBlock() throws Exception {
+        short type = 1;
+        byte flags = 0;
+        int length = 10;
+        int headerBlockLength = 1024;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int associatedToStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        byte priority = (byte) (RANDOM.nextInt() & 0x07);
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length + headerBlockLength));
+        encodeControlFrameHeader(buf, type, flags, length + headerBlockLength);
+        buf.writeInt(streamId);
+        buf.writeInt(associatedToStreamId);
+        buf.writeByte(priority << 5);
+        buf.writeByte(0);
+
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(headerBlockLength));
+        for (int i = 0; i < 256; i ++) {
+            headerBlock.writeInt(RANDOM.nextInt());
         }
+
+        delegate.readSynStreamFrame(streamId, associatedToStreamId, priority, false, false);
+        delegate.readHeaderBlock(headerBlock.duplicate());
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        decoder.decode(headerBlock);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+        assertFalse(headerBlock.isReadable());
     }
 
     @Test
-    public void testLargeHeaderNameOnSynStreamRequest() throws Exception {
-        testLargeHeaderNameOnSynStreamRequest(SpdyVersion.SPDY_3);
-        testLargeHeaderNameOnSynStreamRequest(SpdyVersion.SPDY_3_1);
+    public void testSpdySynReplyFrame() throws Exception {
+        short type = 2;
+        byte flags = 0;
+        int length = 4;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+
+        delegate.readSynReplyFrame(streamId, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
     }
 
-    private static void testLargeHeaderNameOnSynStreamRequest(final SpdyVersion spdyVersion) throws Exception {
-        final int maxHeaderSize = 8192;
+    @Test
+    public void testLastSpdySynReplyFrame() throws Exception {
+        short type = 2;
+        byte flags = 0x01; // FLAG_FIN
+        int length = 4;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+
+        delegate.readSynReplyFrame(streamId, true);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-        String expectedName = createString('h', 100);
-        String expectedValue = createString('v', 5000);
+    @Test
+    public void testUnknownSpdySynReplyFrameFlags() throws Exception {
+        short type = 2;
+        byte flags = (byte) 0xFE; // undefined flags
+        int length = 4;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+
+        delegate.readSynReplyFrame(streamId, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-        SpdyHeadersFrame frame = new DefaultSpdySynStreamFrame(1, 0, (byte) 0);
-        SpdyHeaders headers = frame.headers();
-        headers.add(expectedName, expectedValue);
+    @Test
+    public void testReservedSpdySynReplyFrameBits() throws Exception {
+        short type = 2;
+        byte flags = 0;
+        int length = 4;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit
+
+        delegate.readSynReplyFrame(streamId, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-        final CaptureHandler captureHandler = new CaptureHandler();
-        final ServerBootstrap sb = new ServerBootstrap();
-        Bootstrap cb = new Bootstrap();
+    @Test
+    public void testInvalidSpdySynReplyFrameLength() throws Exception {
+        short type = 2;
+        byte flags = 0;
+        int length = 0; // invalid length
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-        sb.group(new NioEventLoopGroup(1));
-        sb.channel(NioServerSocketChannel.class);
-        sb.childHandler(new ChannelInitializer<Channel>() {
-            @Override
-            protected void initChannel(Channel ch) throws Exception {
-                ChannelPipeline p = ch.pipeline();
-                p.addLast("decoder", new SpdyFrameDecoder(spdyVersion, 10000, maxHeaderSize));
-                p.addLast("sessionHandler", new SpdySessionHandler(spdyVersion, true));
-                p.addLast("handler", captureHandler);
-            }
-        });
+    @Test
+    public void testIllegalSpdySynReplyFrameStreamId() throws Exception {
+        short type = 2;
+        byte flags = 0;
+        int length = 4;
+        int streamId = 0; // invalid stream identifier
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
 
-        cb.group(new NioEventLoopGroup(1));
-        cb.channel(NioSocketChannel.class);
-        cb.handler(new ChannelInitializer<Channel>() {
-            @Override
-            protected void initChannel(Channel ch) throws Exception {
-                ch.pipeline().addLast("encoder", new SpdyFrameEncoder(spdyVersion));
-            }
-        });
+    @Test
+    public void testSpdySynReplyFrameHeaderBlock() throws Exception {
+        short type = 2;
+        byte flags = 0;
+        int length = 4;
+        int headerBlockLength = 1024;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length + headerBlockLength));
+        encodeControlFrameHeader(buf, type, flags, length + headerBlockLength);
+        buf.writeInt(streamId);
+
+        ByteBuf headerBlock = Unpooled.buffer(headerBlockLength);
+        for (int i = 0; i < 256; i ++) {
+            headerBlock.writeInt(RANDOM.nextInt());
+        }
+
+        delegate.readSynReplyFrame(streamId, false);
+        delegate.readHeaderBlock(headerBlock.duplicate());
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        decoder.decode(headerBlock);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+        assertFalse(headerBlock.isReadable());
+    }
 
-        Channel sc = sb.bind(new InetSocketAddress(0)).sync().channel();
-        int port = ((InetSocketAddress) sc.localAddress()).getPort();
-
-        ChannelFuture ccf = cb.connect(new InetSocketAddress(NetUtil.LOCALHOST, port));
-        assertTrue(ccf.awaitUninterruptibly().isSuccess());
-        Channel cc = ccf.channel();
-
-        sendAndWaitForFrame(cc, frame, captureHandler);
-
-        assertNotNull("version " + spdyVersion.getVersion() + ", not null message",
-                captureHandler.message);
-        String message = "version " + spdyVersion.getVersion() + ", should be SpdyHeadersFrame, was " +
-                captureHandler.message.getClass();
-        assertTrue(message, captureHandler.message instanceof SpdyHeadersFrame);
-        SpdyHeadersFrame writtenFrame = (SpdyHeadersFrame) captureHandler.message;
-
-        assertFalse("should not be truncated", writtenFrame.isTruncated());
-        assertFalse("should not be invalid", writtenFrame.isInvalid());
-
-        String val = writtenFrame.headers().get(expectedName);
-        assertEquals(expectedValue, val);
-
-        sc.close().sync();
-        sb.group().shutdownGracefully();
-        cb.group().shutdownGracefully();
-    }
-
-    @Test
-    public void testZlibHeaders() throws Exception {
-
-        SpdyHeadersFrame frame = new DefaultSpdySynStreamFrame(1, 0, (byte) 0);
-        SpdyHeaders headers = frame.headers();
-
-        headers.add(createString('a', 100), createString('b', 100));
-        SpdyHeadersFrame actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        headers.clear();
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(frame.headers().isEmpty());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        headers.clear();
-        actual = roundTrip(frame, 4096);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(frame.headers().isEmpty());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        headers.clear();
-        actual = roundTrip(frame, 128);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(frame.headers().isEmpty());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        headers.clear();
-        headers.add(createString('c', 100), createString('d', 5000));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        headers.clear();
-        headers.add(createString('e', 5000), createString('f', 100));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        headers.clear();
-        headers.add(createString('g', 100), createString('h', 5000));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        headers.clear();
-        headers.add(createString('i', 100), createString('j', 5000));
-        actual = roundTrip(frame, 4096);
-        assertTrue("should be truncated", actual.isTruncated());
-        assertTrue("headers should be empty", actual.headers().isEmpty());
-
-        headers.clear();
-        headers.add(createString('k', 5000), createString('l', 100));
-        actual = roundTrip(frame, 4096);
-        assertTrue("should be truncated", actual.isTruncated());
-        assertTrue("headers should be empty", actual.headers().isEmpty());
-
-        headers.clear();
-        headers.add(createString('m', 100), createString('n', 1000));
-        headers.add(createString('m', 100), createString('n', 1000));
-        headers.add(createString('m', 100), createString('n', 1000));
-        headers.add(createString('m', 100), createString('n', 1000));
-        headers.add(createString('m', 100), createString('n', 1000));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertEquals(1, actual.headers().names().size());
-        assertEquals(5, actual.headers().getAll(createString('m', 100)).size());
-
-        headers.clear();
-        headers.add(createString('o', 1000), createString('p', 100));
-        headers.add(createString('o', 1000), createString('p', 100));
-        headers.add(createString('o', 1000), createString('p', 100));
-        headers.add(createString('o', 1000), createString('p', 100));
-        headers.add(createString('o', 1000), createString('p', 100));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertEquals(1, actual.headers().names().size());
-        assertEquals(5, actual.headers().getAll(createString('o', 1000)).size());
-
-        headers.clear();
-        headers.add(createString('q', 100), createString('r', 1000));
-        headers.add(createString('q', 100), createString('r', 1000));
-        headers.add(createString('q', 100), createString('r', 1000));
-        headers.add(createString('q', 100), createString('r', 1000));
-        headers.add(createString('q', 100), createString('r', 1000));
-        actual = roundTrip(frame, 4096);
-        assertTrue("should be truncated", actual.isTruncated());
-        assertEquals(0, actual.headers().names().size());
-
-        headers.clear();
-        headers.add(createString('s', 1000), createString('t', 100));
-        headers.add(createString('s', 1000), createString('t', 100));
-        headers.add(createString('s', 1000), createString('t', 100));
-        headers.add(createString('s', 1000), createString('t', 100));
-        headers.add(createString('s', 1000), createString('t', 100));
-        actual = roundTrip(frame, 4096);
-        assertFalse("should be truncated", actual.isTruncated());
-        assertEquals(1, actual.headers().names().size());
-        assertEquals(5, actual.headers().getAll(createString('s', 1000)).size());
-    }
-
-    @Test
-    public void testZlibReuseEncoderDecoder() throws Exception {
-        SpdyHeadersFrame frame = new DefaultSpdySynStreamFrame(1, 0, (byte) 0);
-        SpdyHeaders headers = frame.headers();
-
-        SpdyHeaderBlockEncoder encoder = SpdyHeaderBlockEncoder.newInstance(SpdyVersion.SPDY_3_1, 6, 15, 8);
-        SpdyHeaderBlockDecoder decoder = SpdyHeaderBlockDecoder.newInstance(SpdyVersion.SPDY_3_1, 8192);
-
-        headers.add(createString('a', 100), createString('b', 100));
-        SpdyHeadersFrame actual = roundTrip(encoder, decoder, frame);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        encoder.end();
-        decoder.end();
-        decoder.reset();
-
-        headers.clear();
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(frame.headers().isEmpty());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        encoder.end();
-        decoder.end();
-        decoder.reset();
-
-        headers.clear();
-        headers.add(createString('e', 5000), createString('f', 100));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        encoder.end();
-        decoder.end();
-        decoder.reset();
-
-        headers.clear();
-        headers.add(createString('g', 100), createString('h', 5000));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertTrue(equals(frame.headers(), actual.headers()));
-
-        encoder.end();
-        decoder.end();
-        decoder.reset();
-
-        headers.clear();
-        headers.add(createString('m', 100), createString('n', 1000));
-        headers.add(createString('m', 100), createString('n', 1000));
-        headers.add(createString('m', 100), createString('n', 1000));
-        headers.add(createString('m', 100), createString('n', 1000));
-        headers.add(createString('m', 100), createString('n', 1000));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertEquals(1, actual.headers().names().size());
-        assertEquals(5, actual.headers().getAll(createString('m', 100)).size());
-
-        encoder.end();
-        decoder.end();
-        decoder.reset();
-
-        headers.clear();
-        headers.add(createString('o', 1000), createString('p', 100));
-        headers.add(createString('o', 1000), createString('p', 100));
-        headers.add(createString('o', 1000), createString('p', 100));
-        headers.add(createString('o', 1000), createString('p', 100));
-        headers.add(createString('o', 1000), createString('p', 100));
-        actual = roundTrip(frame, 8192);
-        assertFalse("should not be truncated", actual.isTruncated());
-        assertEquals(1, actual.headers().names().size());
-        assertEquals(5, actual.headers().getAll(createString('o', 1000)).size());
-    }
-
-    private static SpdyHeadersFrame roundTrip(SpdyHeadersFrame frame, int maxHeaderSize) throws Exception {
-        SpdyHeaderBlockEncoder encoder = SpdyHeaderBlockEncoder.newInstance(SpdyVersion.SPDY_3_1, 6, 15, 8);
-        SpdyHeaderBlockDecoder decoder = SpdyHeaderBlockDecoder.newInstance(SpdyVersion.SPDY_3_1, maxHeaderSize);
-        return roundTrip(encoder, decoder, frame);
-    }
-
-    private static SpdyHeadersFrame roundTrip(SpdyHeaderBlockEncoder encoder, SpdyHeaderBlockDecoder decoder,
-                                              SpdyHeadersFrame frame) throws Exception {
-        ByteBuf encoded = encoder.encode(frame);
-
-        SpdyHeadersFrame actual = new DefaultSpdySynStreamFrame(1, 0, (byte) 0);
-
-        decoder.decode(encoded, actual);
-        return actual;
-    }
-
-    private static boolean equals(SpdyHeaders h1, SpdyHeaders h2) {
-        if (!h1.names().equals(h2.names())) {
-            return false;
+    @Test
+    public void testSpdyRstStreamFrame() throws Exception {
+        short type = 3;
+        byte flags = 0;
+        int length = 8;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(statusCode);
+
+        delegate.readRstStreamFrame(streamId, statusCode);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testReservedSpdyRstStreamFrameBits() throws Exception {
+        short type = 3;
+        byte flags = 0;
+        int length = 8;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit
+        buf.writeInt(statusCode);
+
+        delegate.readRstStreamFrame(streamId, statusCode);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testInvalidSpdyRstStreamFrameFlags() throws Exception {
+        short type = 3;
+        byte flags = (byte) 0xFF; // invalid flags
+        int length = 8;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(statusCode);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testInvalidSpdyRstStreamFrameLength() throws Exception {
+        short type = 3;
+        byte flags = 0;
+        int length = 12; // invalid length
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(statusCode);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testIllegalSpdyRstStreamFrameStreamId() throws Exception {
+        short type = 3;
+        byte flags = 0;
+        int length = 8;
+        int streamId = 0; // invalid stream identifier
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(statusCode);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testIllegalSpdyRstStreamFrameStatusCode() throws Exception {
+        short type = 3;
+        byte flags = 0;
+        int length = 8;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+        int statusCode = 0; // invalid status code
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(statusCode);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testSpdySettingsFrame() throws Exception {
+        short type = 4;
+        byte flags = 0;
+        int numSettings = 2;
+        int length = 8 * numSettings + 4;
+        byte idFlags = 0;
+        int id = RANDOM.nextInt() & 0x00FFFFFF;
+        int value = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(numSettings);
+        for (int i = 0; i < numSettings; i++) {
+            buf.writeByte(idFlags);
+            buf.writeMedium(id);
+            buf.writeInt(value);
         }
 
-        for (String name : h1.names()) {
-            if (!h1.getAll(name).equals(h2.getAll(name))) {
-                return false;
-            }
+        delegate.readSettingsFrame(false);
+        delegate.readSetting(id, value, false, false);
+        expectLastCall().times(numSettings);
+        delegate.readSettingsEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testEmptySpdySettingsFrame() throws Exception {
+        short type = 4;
+        byte flags = 0;
+        int numSettings = 0;
+        int length = 8 * numSettings + 4;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(numSettings);
+
+        delegate.readSettingsFrame(false);
+        delegate.readSettingsEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testSpdySettingsFrameClearFlag() throws Exception {
+        short type = 4;
+        byte flags = 0x01; // FLAG_SETTINGS_CLEAR_SETTINGS
+        int numSettings = 0;
+        int length = 8 * numSettings + 4;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(numSettings);
+
+        delegate.readSettingsFrame(true);
+        delegate.readSettingsEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testSpdySettingsPersistValues() throws Exception {
+        short type = 4;
+        byte flags = 0;
+        int numSettings = 1;
+        int length = 8 * numSettings + 4;
+        byte idFlags = 0x01; // FLAG_SETTINGS_PERSIST_VALUE
+        int id = RANDOM.nextInt() & 0x00FFFFFF;
+        int value = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(numSettings);
+        for (int i = 0; i < numSettings; i++) {
+            buf.writeByte(idFlags);
+            buf.writeMedium(id);
+            buf.writeInt(value);
         }
-        return true;
+
+        delegate.readSettingsFrame(false);
+        delegate.readSetting(id, value, true, false);
+        expectLastCall().times(numSettings);
+        delegate.readSettingsEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
     }
 
-    private static void sendAndWaitForFrame(Channel cc, SpdyFrame frame, CaptureHandler handler) {
-        cc.writeAndFlush(frame);
-        long theFuture = System.currentTimeMillis() + 3000;
-        while (handler.message == null && System.currentTimeMillis() < theFuture) {
-            try {
-                Thread.sleep(1);
-            } catch (InterruptedException e) {
-                // Ignore.
-            }
+    @Test
+    public void testSpdySettingsPersistedValues() throws Exception {
+        short type = 4;
+        byte flags = 0;
+        int numSettings = 1;
+        int length = 8 * numSettings + 4;
+        byte idFlags = 0x02; // FLAG_SETTINGS_PERSISTED
+        int id = RANDOM.nextInt() & 0x00FFFFFF;
+        int value = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(numSettings);
+        for (int i = 0; i < numSettings; i++) {
+            buf.writeByte(idFlags);
+            buf.writeMedium(id);
+            buf.writeInt(value);
         }
+
+        delegate.readSettingsFrame(false);
+        delegate.readSetting(id, value, false, true);
+        expectLastCall().times(numSettings);
+        delegate.readSettingsEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
     }
 
-    private static void addHeader(SpdyHeadersFrame frame, int headerNameSize, int headerValueSize) {
-        frame.headers().add("k", "v");
-        String headerName = createString('h', headerNameSize);
-        String headerValue = createString('h', headerValueSize);
-        frame.headers().add(headerName, headerValue);
+    @Test
+    public void testUnknownSpdySettingsFrameFlags() throws Exception {
+        short type = 4;
+        byte flags = (byte) 0xFE; // undefined flags
+        int numSettings = 0;
+        int length = 8 * numSettings + 4;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(numSettings);
+
+        delegate.readSettingsFrame(false);
+        delegate.readSettingsEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
     }
 
-    private static String createString(char c, int rep) {
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < rep; i++) {
-            sb.append(c);
+    @Test
+    public void testUnknownSpdySettingsFlags() throws Exception {
+        short type = 4;
+        byte flags = 0;
+        int numSettings = 1;
+        int length = 8 * numSettings + 4;
+        byte idFlags = (byte) 0xFC; // undefined flags
+        int id = RANDOM.nextInt() & 0x00FFFFFF;
+        int value = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(numSettings);
+        for (int i = 0; i < numSettings; i++) {
+            buf.writeByte(idFlags);
+            buf.writeMedium(id);
+            buf.writeInt(value);
         }
-        return sb.toString();
+
+        delegate.readSettingsFrame(false);
+        delegate.readSetting(id, value, false, false);
+        expectLastCall().times(numSettings);
+        delegate.readSettingsEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
     }
 
-    private static class CaptureHandler extends ChannelInboundHandlerAdapter {
-        public volatile Object message;
+    @Test
+    public void testInvalidSpdySettingsFrameLength() throws Exception {
+        short type = 4;
+        byte flags = 0;
+        int numSettings = 2;
+        int length = 8 * numSettings + 8; // invalid length
+        byte idFlags = 0;
+        int id = RANDOM.nextInt() & 0x00FFFFFF;
+        int value = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(numSettings);
+        for (int i = 0; i < numSettings; i++) {
+            buf.writeByte(idFlags);
+            buf.writeMedium(id);
+            buf.writeInt(value);
+        }
 
-        @Override
-        public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {
-            message = m;
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testInvalidSpdySettingsFrameNumSettings() throws Exception {
+        short type = 4;
+        byte flags = 0;
+        int numSettings = 2;
+        int length = 8 * numSettings + 4;
+        byte idFlags = 0;
+        int id = RANDOM.nextInt() & 0x00FFFFFF;
+        int value = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(0); // invalid num_settings
+        for (int i = 0; i < numSettings; i++) {
+            buf.writeByte(idFlags);
+            buf.writeMedium(id);
+            buf.writeInt(value);
         }
 
-        @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-            cause.printStackTrace();
-            message = cause;
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testDiscardUnknownFrame() throws Exception {
+        short type = 5;
+        byte flags = (byte) 0xFF;
+        int length = 8;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeLong(RANDOM.nextLong());
+
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testDiscardUnknownEmptyFrame() throws Exception {
+        short type = 5;
+        byte flags = (byte) 0xFF;
+        int length = 0;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testProgressivelyDiscardUnknownEmptyFrame() throws Exception {
+        short type = 5;
+        byte flags = (byte) 0xFF;
+        int segment = 4;
+        int length = 2 * segment;
+
+        ByteBuf header = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE));
+        ByteBuf segment1 = Unpooled.buffer(segment);
+        ByteBuf segment2 = Unpooled.buffer(segment);
+        encodeControlFrameHeader(header, type, flags, length);
+        segment1.writeInt(RANDOM.nextInt());
+        segment2.writeInt(RANDOM.nextInt());
+
+        replay(delegate);
+        decoder.decode(header);
+        decoder.decode(segment1);
+        decoder.decode(segment2);
+        verify(delegate);
+        assertFalse(header.isReadable());
+        assertFalse(segment1.isReadable());
+        assertFalse(segment2.isReadable());
+    }
+
+    @Test
+    public void testSpdyPingFrame() throws Exception {
+        short type = 6;
+        byte flags = 0;
+        int length = 4;
+        int id = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(id);
+
+        delegate.readPingFrame(id);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testUnknownSpdyPingFrameFlags() throws Exception {
+        short type = 6;
+        byte flags = (byte) 0xFF; // undefined flags
+        int length = 4;
+        int id = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(id);
+
+        delegate.readPingFrame(id);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testInvalidSpdyPingFrameLength() throws Exception {
+        short type = 6;
+        byte flags = 0;
+        int length = 8; // invalid length
+        int id = RANDOM.nextInt();
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(id);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testSpdyGoAwayFrame() throws Exception {
+        short type = 7;
+        byte flags = 0;
+        int length = 8;
+        int lastGoodStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(lastGoodStreamId);
+        buf.writeInt(statusCode);
+
+        delegate.readGoAwayFrame(lastGoodStreamId, statusCode);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testUnknownSpdyGoAwayFrameFlags() throws Exception {
+        short type = 7;
+        byte flags = (byte) 0xFF; // undefined flags
+        int length = 8;
+        int lastGoodStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(lastGoodStreamId);
+        buf.writeInt(statusCode);
+
+        delegate.readGoAwayFrame(lastGoodStreamId, statusCode);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testReservedSpdyGoAwayFrameBits() throws Exception {
+        short type = 7;
+        byte flags = 0;
+        int length = 8;
+        int lastGoodStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(lastGoodStreamId | 0x80000000); // should ignore reserved bit
+        buf.writeInt(statusCode);
+
+        delegate.readGoAwayFrame(lastGoodStreamId, statusCode);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testInvalidSpdyGoAwayFrameLength() throws Exception {
+        short type = 7;
+        byte flags = 0;
+        int length = 12; // invalid length
+        int lastGoodStreamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int statusCode = RANDOM.nextInt() | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(lastGoodStreamId);
+        buf.writeInt(statusCode);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testSpdyHeadersFrame() throws Exception {
+        short type = 8;
+        byte flags = 0;
+        int length = 4;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+
+        delegate.readHeadersFrame(streamId, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testLastSpdyHeadersFrame() throws Exception {
+        short type = 8;
+        byte flags = 0x01; // FLAG_FIN
+        int length = 4;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+
+        delegate.readHeadersFrame(streamId, true);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testUnknownSpdyHeadersFrameFlags() throws Exception {
+        short type = 8;
+        byte flags = (byte) 0xFE; // undefined flags
+        int length = 4;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+
+        delegate.readHeadersFrame(streamId, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testReservedSpdyHeadersFrameBits() throws Exception {
+        short type = 8;
+        byte flags = 0;
+        int length = 4;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit
+
+        delegate.readHeadersFrame(streamId, false);
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testInvalidSpdyHeadersFrameLength() throws Exception {
+        short type = 8;
+        byte flags = 0;
+        int length = 0; // invalid length
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testInvalidSpdyHeadersFrameStreamId() throws Exception {
+        short type = 8;
+        byte flags = 0;
+        int length = 4;
+        int streamId = 0; // invalid stream identifier
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testSpdyHeadersFrameHeaderBlock() throws Exception {
+        short type = 8;
+        byte flags = 0;
+        int length = 4;
+        int headerBlockLength = 1024;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length + headerBlockLength);
+        buf.writeInt(streamId);
+
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(headerBlockLength));
+        for (int i = 0; i < 256; i ++) {
+            headerBlock.writeInt(RANDOM.nextInt());
         }
+
+        delegate.readHeadersFrame(streamId, false);
+        delegate.readHeaderBlock(headerBlock.duplicate());
+        delegate.readHeaderBlockEnd();
+        replay(delegate);
+        decoder.decode(buf);
+        decoder.decode(headerBlock);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+        assertFalse(headerBlock.isReadable());
+    }
+
+    @Test
+    public void testSpdyWindowUpdateFrame() throws Exception {
+        short type = 9;
+        byte flags = 0;
+        int length = 8;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int deltaWindowSize = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = Unpooled.buffer(SPDY_HEADER_SIZE + length);
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(deltaWindowSize);
+
+        delegate.readWindowUpdateFrame(streamId, deltaWindowSize);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testUnknownSpdyWindowUpdateFrameFlags() throws Exception {
+        short type = 9;
+        byte flags = (byte) 0xFF; // undefined flags
+        int length = 8;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int deltaWindowSize = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(deltaWindowSize);
+
+        delegate.readWindowUpdateFrame(streamId, deltaWindowSize);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testReservedSpdyWindowUpdateFrameBits() throws Exception {
+        short type = 9;
+        byte flags = 0;
+        int length = 8;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int deltaWindowSize = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId | 0x80000000); // should ignore reserved bit
+        buf.writeInt(deltaWindowSize | 0x80000000); // should ignore reserved bit
+
+        delegate.readWindowUpdateFrame(streamId, deltaWindowSize);
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testInvalidSpdyWindowUpdateFrameLength() throws Exception {
+        short type = 9;
+        byte flags = 0;
+        int length = 12; // invalid length
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int deltaWindowSize = RANDOM.nextInt() & 0x7FFFFFFF | 0x01;
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(deltaWindowSize);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
+    }
+
+    @Test
+    public void testIllegalSpdyWindowUpdateFrameDeltaWindowSize() throws Exception {
+        short type = 9;
+        byte flags = 0;
+        int length = 8;
+        int streamId = RANDOM.nextInt() & 0x7FFFFFFF;
+        int deltaWindowSize = 0; // invalid delta window size
+
+        ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(SPDY_HEADER_SIZE + length));
+        encodeControlFrameHeader(buf, type, flags, length);
+        buf.writeInt(streamId);
+        buf.writeInt(deltaWindowSize);
+
+        delegate.readFrameError((String) anyObject());
+        replay(delegate);
+        decoder.decode(buf);
+        verify(delegate);
+        assertFalse(buf.isReadable());
     }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java
new file mode 100644
index 000000000000..6ca1df23affb
--- /dev/null
+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java
@@ -0,0 +1,488 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.spdy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.util.ReferenceCountUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class SpdyHeaderBlockRawDecoderTest {
+
+    private static final int maxHeaderSize = 16;
+
+    private static final String name = "name";
+    private static final String value = "value";
+    private static final byte[] nameBytes = name.getBytes();
+    private static final byte[] valueBytes = value.getBytes();
+
+    private SpdyHeaderBlockRawDecoder decoder;
+    private SpdyHeadersFrame frame;
+
+    @Before
+    public void setUp() {
+        decoder = new SpdyHeaderBlockRawDecoder(SpdyVersion.SPDY_3_1, maxHeaderSize);
+        frame = new DefaultSpdyHeadersFrame(1);
+    }
+
+    @After
+    public void tearDown() {
+        decoder.end();
+    }
+
+    @Test
+    public void testEmptyHeaderBlock() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.EMPTY_BUFFER);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testZeroNameValuePairs() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(4));
+        headerBlock.writeInt(0);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertFalse(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testNegativeNameValuePairs() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(4));
+        headerBlock.writeInt(-1);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testOneNameValuePair() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(21));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5);
+        headerBlock.writeBytes(valueBytes);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertFalse(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testMissingNameLength() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(4));
+        headerBlock.writeInt(1);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testZeroNameLength() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(0);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testNegativeNameLength() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(-1);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testMissingName() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testIllegalNameOnlyNull() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(18));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(1);
+        headerBlock.writeByte(0);
+        headerBlock.writeInt(5);
+        headerBlock.writeBytes(valueBytes);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testMissingValueLength() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(12));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testZeroValueLength() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(16));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(0);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertFalse(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals("", frame.headers().get(name));
+    }
+
+    @Test
+    public void testNegativeValueLength() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(16));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(-1);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testMissingValue() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(16));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testIllegalValueOnlyNull() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(17));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(1);
+        headerBlock.writeByte(0);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testIllegalValueStartsWithNull() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(22));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(6);
+        headerBlock.writeByte(0);
+        headerBlock.writeBytes(valueBytes);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testIllegalValueEndsWithNull() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(22));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(6);
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeByte(0);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testMultipleValues() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(27));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(11);
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeByte(0);
+        headerBlock.writeBytes(valueBytes);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertFalse(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(2, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().getAll(name).get(0));
+        assertEquals(value, frame.headers().getAll(name).get(1));
+    }
+
+    @Test
+    public void testMultipleValuesEndsWithNull() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(28));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(12);
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeByte(0);
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeByte(0);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testIllegalValueMultipleNulls() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(28));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(12);
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeByte(0);
+        headerBlock.writeByte(0);
+        headerBlock.writeBytes(valueBytes);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testMissingNextNameValuePair() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(21));
+        headerBlock.writeInt(2);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5);
+        headerBlock.writeBytes(valueBytes);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testMultipleNames() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(38));
+        headerBlock.writeInt(2);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5);
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5);
+        headerBlock.writeBytes(valueBytes);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testExtraData() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(22));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5);
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeByte(0);
+        decoder.decode(headerBlock, frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testMultipleDecodes() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(21));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5);
+        headerBlock.writeBytes(valueBytes);
+
+        int readableBytes = headerBlock.readableBytes();
+        for (int i = 0; i < readableBytes; i++) {
+            ByteBuf headerBlockSegment = headerBlock.slice(i, 1);
+            decoder.decode(headerBlockSegment, frame);
+            assertFalse(headerBlockSegment.isReadable());
+        }
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testContinueAfterInvalidHeaders() throws Exception {
+        ByteBuf numHeaders = ReferenceCountUtil.releaseLater(Unpooled.buffer(4));
+        numHeaders.writeInt(1);
+
+        ByteBuf nameBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8));
+        nameBlock.writeInt(4);
+        nameBlock.writeBytes(nameBytes);
+
+        ByteBuf valueBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(9));
+        valueBlock.writeInt(5);
+        valueBlock.writeBytes(valueBytes);
+
+        decoder.decode(numHeaders, frame);
+        decoder.decode(nameBlock, frame);
+        frame.setInvalid();
+        decoder.decode(valueBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(numHeaders.isReadable());
+        assertFalse(nameBlock.isReadable());
+        assertFalse(valueBlock.isReadable());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testTruncatedHeaderName() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(maxHeaderSize + 18));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(maxHeaderSize + 1);
+        for (int i = 0; i < maxHeaderSize + 1; i++) {
+            headerBlock.writeByte('a');
+        }
+        headerBlock.writeInt(5);
+        headerBlock.writeBytes(valueBytes);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isTruncated());
+        assertFalse(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+
+    @Test
+    public void testTruncatedHeaderValue() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(maxHeaderSize + 13));
+        headerBlock.writeInt(1);
+        headerBlock.writeInt(4);
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(13);
+        for (int i = 0; i < maxHeaderSize - 3; i++) {
+            headerBlock.writeByte('a');
+        }
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertTrue(frame.isTruncated());
+        assertFalse(frame.isInvalid());
+        assertEquals(0, frame.headers().names().size());
+    }
+}
diff --git a/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoderTest.java
new file mode 100644
index 000000000000..cc06893559ae
--- /dev/null
+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoderTest.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.spdy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.util.ReferenceCountUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class SpdyHeaderBlockZlibDecoderTest {
+
+    // zlib header indicating 32K window size fastest deflate algorithm with SPDY dictionary
+    private static final byte[] zlibHeader = {0x78, 0x3f, (byte) 0xe3, (byte) 0xc6, (byte) 0xa7, (byte) 0xc2};
+    private static final byte[] zlibSyncFlush = {0x00, 0x00, 0x00, (byte) 0xff, (byte) 0xff};
+
+    private static final int maxHeaderSize = 8192;
+
+    private static final String name = "name";
+    private static final String value = "value";
+    private static final byte[] nameBytes = name.getBytes();
+    private static final byte[] valueBytes = value.getBytes();
+
+    private SpdyHeaderBlockZlibDecoder decoder;
+    private SpdyHeadersFrame frame;
+
+    @Before
+    public void setUp() {
+        decoder = new SpdyHeaderBlockZlibDecoder(SpdyVersion.SPDY_3_1, maxHeaderSize);
+        frame = new DefaultSpdyHeadersFrame(1);
+    }
+
+    @After
+    public void tearDown() {
+        decoder.end();
+    }
+
+    @Test
+    public void testHeaderBlock() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(37));
+        headerBlock.writeBytes(zlibHeader);
+        headerBlock.writeByte(0); // Non-compressed block
+        headerBlock.writeByte(0x15); // little-endian length (21)
+        headerBlock.writeByte(0x00); // little-endian length (21)
+        headerBlock.writeByte(0xea); // one's compliment of length
+        headerBlock.writeByte(0xff); // one's compliment of length
+        headerBlock.writeInt(1); // number of Name/Value pairs
+        headerBlock.writeInt(4); // length of name
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5); // length of value
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeBytes(zlibSyncFlush);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertFalse(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testHeaderBlockMultipleDecodes() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(37));
+        headerBlock.writeBytes(zlibHeader);
+        headerBlock.writeByte(0); // Non-compressed block
+        headerBlock.writeByte(0x15); // little-endian length (21)
+        headerBlock.writeByte(0x00); // little-endian length (21)
+        headerBlock.writeByte(0xea); // one's compliment of length
+        headerBlock.writeByte(0xff); // one's compliment of length
+        headerBlock.writeInt(1); // number of Name/Value pairs
+        headerBlock.writeInt(4); // length of name
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5); // length of value
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeBytes(zlibSyncFlush);
+
+        int readableBytes = headerBlock.readableBytes();
+        for (int i = 0; i < readableBytes; i++) {
+            ByteBuf headerBlockSegment = headerBlock.slice(i, 1);
+            decoder.decode(headerBlockSegment, frame);
+            assertFalse(headerBlockSegment.isReadable());
+        }
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(frame.isInvalid());
+        assertEquals(1, frame.headers().names().size());
+        assertTrue(frame.headers().contains(name));
+        assertEquals(1, frame.headers().getAll(name).size());
+        assertEquals(value, frame.headers().get(name));
+    }
+
+    @Test
+    public void testLargeHeaderName() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8220));
+        headerBlock.writeBytes(zlibHeader);
+        headerBlock.writeByte(0); // Non-compressed block
+        headerBlock.writeByte(0x0c); // little-endian length (8204)
+        headerBlock.writeByte(0x20); // little-endian length (8204)
+        headerBlock.writeByte(0xf3); // one's compliment of length
+        headerBlock.writeByte(0xdf); // one's compliment of length
+        headerBlock.writeInt(1); // number of Name/Value pairs
+        headerBlock.writeInt(8192); // length of name
+        for (int i = 0; i < 8192; i++) {
+            headerBlock.writeByte('n');
+        }
+        headerBlock.writeInt(0); // length of value
+        headerBlock.writeBytes(zlibSyncFlush);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertFalse(frame.isInvalid());
+        assertFalse(frame.isTruncated());
+        assertEquals(1, frame.headers().names().size());
+    }
+
+    @Test
+    public void testLargeHeaderValue() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8220));
+        headerBlock.writeBytes(zlibHeader);
+        headerBlock.writeByte(0); // Non-compressed block
+        headerBlock.writeByte(0x0c); // little-endian length (8204)
+        headerBlock.writeByte(0x20); // little-endian length (8204)
+        headerBlock.writeByte(0xf3); // one's compliment of length
+        headerBlock.writeByte(0xdf); // one's compliment of length
+        headerBlock.writeInt(1); // number of Name/Value pairs
+        headerBlock.writeInt(1); // length of name
+        headerBlock.writeByte('n');
+        headerBlock.writeInt(8191); // length of value
+        for (int i = 0; i < 8191; i++) {
+            headerBlock.writeByte('v');
+        }
+        headerBlock.writeBytes(zlibSyncFlush);
+        decoder.decode(headerBlock, frame);
+        decoder.endHeaderBlock(frame);
+
+        assertFalse(headerBlock.isReadable());
+        assertFalse(frame.isInvalid());
+        assertFalse(frame.isTruncated());
+        assertEquals(1, frame.headers().names().size());
+        assertEquals(8191, frame.headers().get("n").length());
+    }
+
+    @Test(expected = SpdyProtocolException.class)
+    public void testHeaderBlockExtraData() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(37));
+        headerBlock.writeBytes(zlibHeader);
+        headerBlock.writeByte(0); // Non-compressed block
+        headerBlock.writeByte(0x15); // little-endian length (21)
+        headerBlock.writeByte(0x00); // little-endian length (21)
+        headerBlock.writeByte(0xea); // one's compliment of length
+        headerBlock.writeByte(0xff); // one's compliment of length
+        headerBlock.writeInt(1); // number of Name/Value pairs
+        headerBlock.writeInt(4); // length of name
+        headerBlock.writeBytes(nameBytes);
+        headerBlock.writeInt(5); // length of value
+        headerBlock.writeBytes(valueBytes);
+        headerBlock.writeByte(0x19); // adler-32 checksum
+        headerBlock.writeByte(0xa5); // adler-32 checksum
+        headerBlock.writeByte(0x03); // adler-32 checksum
+        headerBlock.writeByte(0xc9); // adler-32 checksum
+        headerBlock.writeByte(0); // Data following zlib stream
+        decoder.decode(headerBlock, frame);
+    }
+
+    @Test(expected = SpdyProtocolException.class)
+    public void testHeaderBlockInvalidDictionary() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(7));
+        headerBlock.writeByte(0x78);
+        headerBlock.writeByte(0x3f);
+        headerBlock.writeByte(0x01); // Unknown dictionary
+        headerBlock.writeByte(0x02); // Unknown dictionary
+        headerBlock.writeByte(0x03); // Unknown dictionary
+        headerBlock.writeByte(0x04); // Unknown dictionary
+        headerBlock.writeByte(0); // Non-compressed block
+        decoder.decode(headerBlock, frame);
+    }
+
+    @Test(expected = SpdyProtocolException.class)
+    public void testHeaderBlockInvalidDeflateBlock() throws Exception {
+        ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(11));
+        headerBlock.writeBytes(zlibHeader);
+        headerBlock.writeByte(0); // Non-compressed block
+        headerBlock.writeByte(0x00); // little-endian length (0)
+        headerBlock.writeByte(0x00); // little-endian length (0)
+        headerBlock.writeByte(0x00); // invalid one's compliment
+        headerBlock.writeByte(0x00); // invalid one's compliment
+        decoder.decode(headerBlock, frame);
+    }
+}
diff --git a/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
index 55346cbc3266..85b4a518e2b6 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
@@ -43,8 +43,8 @@ private static void assertDataFrame(Object msg, int streamId, boolean last) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyDataFrame);
         SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-        assertEquals(spdyDataFrame.getStreamId(), streamId);
-        assertEquals(spdyDataFrame.isLast(), last);
+        assertEquals(streamId, spdyDataFrame.streamId());
+        assertEquals(last, spdyDataFrame.isLast());
     }
 
     private static void assertSynReply(Object msg, int streamId, boolean last, SpdyHeaders headers) {
@@ -57,30 +57,30 @@ private static void assertRstStream(Object msg, int streamId, SpdyStreamStatus s
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyRstStreamFrame);
         SpdyRstStreamFrame spdyRstStreamFrame = (SpdyRstStreamFrame) msg;
-        assertEquals(spdyRstStreamFrame.getStreamId(), streamId);
-        assertEquals(spdyRstStreamFrame.getStatus(), status);
+        assertEquals(streamId, spdyRstStreamFrame.streamId());
+        assertEquals(status, spdyRstStreamFrame.status());
     }
 
     private static void assertPing(Object msg, int id) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyPingFrame);
         SpdyPingFrame spdyPingFrame = (SpdyPingFrame) msg;
-        assertEquals(spdyPingFrame.getId(), id);
+        assertEquals(id, spdyPingFrame.id());
     }
 
     private static void assertGoAway(Object msg, int lastGoodStreamId) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyGoAwayFrame);
         SpdyGoAwayFrame spdyGoAwayFrame = (SpdyGoAwayFrame) msg;
-        assertEquals(spdyGoAwayFrame.getLastGoodStreamId(), lastGoodStreamId);
+        assertEquals(lastGoodStreamId, spdyGoAwayFrame.lastGoodStreamId());
     }
 
     private static void assertHeaders(Object msg, int streamId, boolean last, SpdyHeaders headers) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyHeadersFrame);
         SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-        assertEquals(spdyHeadersFrame.getStreamId(), streamId);
-        assertEquals(spdyHeadersFrame.isLast(), last);
+        assertEquals(streamId, spdyHeadersFrame.streamId());
+        assertEquals(last, spdyHeadersFrame.isLast());
         for (String name: headers.names()) {
             List<String> expectedValues = headers.getAll(name);
             List<String> receivedValues = spdyHeadersFrame.headers().getAll(name);
@@ -158,7 +158,7 @@ private static void testSpdySessionHandler(SpdyVersion version, boolean server)
         assertNull(sessionHandler.readOutbound());
 
         // Check if session handler rejects HEADERS for closed streams
-        int testStreamId = spdyDataFrame.getStreamId();
+        int testStreamId = spdyDataFrame.streamId();
         sessionHandler.writeInbound(spdyDataFrame);
         assertDataFrame(sessionHandler.readOutbound(), testStreamId, spdyDataFrame.isLast());
         assertNull(sessionHandler.readOutbound());
@@ -172,7 +172,7 @@ private static void testSpdySessionHandler(SpdyVersion version, boolean server)
         // a RST_STREAM frame for that Stream-ID
         sessionHandler.writeInbound(new DefaultSpdyRstStreamFrame(remoteStreamId, 3));
         assertNull(sessionHandler.readOutbound());
-        remoteStreamId += 2;
+        //remoteStreamId += 2;
 
         // Check if session handler honors UNIDIRECTIONAL streams
         spdySynStreamFrame.setLast(false);
@@ -223,7 +223,7 @@ private static void testSpdySessionHandlerPing(SpdyVersion version, boolean serv
 
         // Check if session handler returns identical local PINGs
         sessionHandler.writeInbound(localPingFrame);
-        assertPing(sessionHandler.readOutbound(), localPingFrame.getId());
+        assertPing(sessionHandler.readOutbound(), localPingFrame.id());
         assertNull(sessionHandler.readOutbound());
 
         // Check if session handler ignores un-initiated remote PINGs
@@ -282,48 +282,36 @@ private static void testSpdySessionHandlerGoAway(SpdyVersion version, boolean se
 
     @Test
     public void testSpdyClientSessionHandler() {
-        logger.info("Running: testSpdyClientSessionHandler v3");
-        testSpdySessionHandler(SpdyVersion.SPDY_3, false);
         logger.info("Running: testSpdyClientSessionHandler v3.1");
         testSpdySessionHandler(SpdyVersion.SPDY_3_1, false);
     }
 
     @Test
     public void testSpdyClientSessionHandlerPing() {
-        logger.info("Running: testSpdyClientSessionHandlerPing v3");
-        testSpdySessionHandlerPing(SpdyVersion.SPDY_3, false);
         logger.info("Running: testSpdyClientSessionHandlerPing v3.1");
         testSpdySessionHandlerPing(SpdyVersion.SPDY_3_1, false);
     }
 
     @Test
     public void testSpdyClientSessionHandlerGoAway() {
-        logger.info("Running: testSpdyClientSessionHandlerGoAway v3");
-        testSpdySessionHandlerGoAway(SpdyVersion.SPDY_3, false);
         logger.info("Running: testSpdyClientSessionHandlerGoAway v3.1");
         testSpdySessionHandlerGoAway(SpdyVersion.SPDY_3_1, false);
     }
 
     @Test
     public void testSpdyServerSessionHandler() {
-        logger.info("Running: testSpdyServerSessionHandler v3");
-        testSpdySessionHandler(SpdyVersion.SPDY_3, true);
         logger.info("Running: testSpdyServerSessionHandler v3.1");
         testSpdySessionHandler(SpdyVersion.SPDY_3_1, true);
     }
 
     @Test
     public void testSpdyServerSessionHandlerPing() {
-        logger.info("Running: testSpdyServerSessionHandlerPing v3");
-        testSpdySessionHandlerPing(SpdyVersion.SPDY_3, true);
         logger.info("Running: testSpdyServerSessionHandlerPing v3.1");
         testSpdySessionHandlerPing(SpdyVersion.SPDY_3_1, true);
     }
 
     @Test
     public void testSpdyServerSessionHandlerGoAway() {
-        logger.info("Running: testSpdyServerSessionHandlerGoAway v3");
-        testSpdySessionHandlerGoAway(SpdyVersion.SPDY_3, true);
         logger.info("Running: testSpdyServerSessionHandlerGoAway v3.1");
         testSpdySessionHandlerGoAway(SpdyVersion.SPDY_3_1, true);
     }
@@ -347,11 +335,11 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
                     new DefaultSpdySynStreamFrame(streamId, 0, (byte) 0);
             spdySynStreamFrame.setLast(true);
             ctx.writeAndFlush(spdySynStreamFrame);
-            spdySynStreamFrame.setStreamId(spdySynStreamFrame.getStreamId() + 2);
+            spdySynStreamFrame.setStreamId(spdySynStreamFrame.streamId() + 2);
             ctx.writeAndFlush(spdySynStreamFrame);
-            spdySynStreamFrame.setStreamId(spdySynStreamFrame.getStreamId() + 2);
+            spdySynStreamFrame.setStreamId(spdySynStreamFrame.streamId() + 2);
             ctx.writeAndFlush(spdySynStreamFrame);
-            spdySynStreamFrame.setStreamId(spdySynStreamFrame.getStreamId() + 2);
+            spdySynStreamFrame.setStreamId(spdySynStreamFrame.streamId() + 2);
             ctx.writeAndFlush(spdySynStreamFrame);
 
             // Limit the number of concurrent streams to 1
@@ -366,7 +354,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
                 SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
                 if (!spdySynStreamFrame.isUnidirectional()) {
-                    int streamId = spdySynStreamFrame.getStreamId();
+                    int streamId = spdySynStreamFrame.streamId();
                     SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);
                     spdySynReplyFrame.setLast(spdySynStreamFrame.isLast());
                     for (Map.Entry<String, String> entry: spdySynStreamFrame.headers()) {
diff --git a/codec-memcache/pom.xml b/codec-memcache/pom.xml
new file mode 100644
index 000000000000..55a48f9ab476
--- /dev/null
+++ b/codec-memcache/pom.xml
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2013 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>io.netty</groupId>
+    <artifactId>netty-parent</artifactId>
+    <version>4.1.0.Beta1</version>
+  </parent>
+
+  <artifactId>netty-codec-memcache</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Netty/Codec/Memcache</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+
+</project>
+
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java
new file mode 100644
index 000000000000..9d1ec177502e
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.handler.codec.DecoderResult;
+
+/**
+ * The default {@link MemcacheObject} implementation.
+ */
+public abstract class AbstractMemcacheObject implements MemcacheObject {
+
+    private DecoderResult decoderResult = DecoderResult.SUCCESS;
+
+    protected AbstractMemcacheObject() {
+        // Disallow direct instantiation
+    }
+
+    @Override
+    public DecoderResult decoderResult() {
+        return decoderResult;
+    }
+
+    @Override
+    public void setDecoderResult(DecoderResult result) {
+        if (result == null) {
+            throw new NullPointerException("DecoderResult should not be null.");
+        }
+
+        decoderResult = result;
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java
new file mode 100644
index 000000000000..89850599cf52
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelPipeline;
+import io.netty.handler.codec.MessageAggregator;
+import io.netty.handler.codec.memcache.binary.BinaryMemcacheRequestDecoder;
+import io.netty.handler.codec.memcache.binary.BinaryMemcacheResponseEncoder;
+
+/**
+ * A {@link ChannelHandler} that aggregates an {@link MemcacheMessage}
+ * and its following {@link MemcacheContent}s into a single {@link MemcacheMessage} with
+ * no following {@link MemcacheContent}s.  It is useful when you don't want to take
+ * care of memcache messages where the content comes along in chunks. Insert this
+ * handler after a AbstractMemcacheObjectDecoder in the {@link ChannelPipeline}.
+ * <p/>
+ * For example, here for the binary protocol:
+ * <p/>
+ * <pre>
+ * {@link ChannelPipeline} p = ...;
+ * ...
+ * p.addLast("decoder", new {@link BinaryMemcacheRequestDecoder}());
+ * p.addLast("aggregator", <b>new {@link io.netty.handler.codec.memcache.binary.BinaryMemcacheObjectAggregator}(1048576)
+ * </b>);
+ * ...
+ * p.addLast("encoder", new {@link BinaryMemcacheResponseEncoder}());
+ * p.addLast("handler", new YourMemcacheRequestHandler());
+ * </pre>
+ */
+public abstract class AbstractMemcacheObjectAggregator<H extends MemcacheMessage> extends
+        MessageAggregator<MemcacheObject, H, MemcacheContent, FullMemcacheMessage> {
+
+    protected AbstractMemcacheObjectAggregator(int maxContentLength) {
+        super(maxContentLength);
+    }
+
+    @Override
+    protected boolean isContentMessage(MemcacheObject msg) throws Exception {
+        return msg instanceof MemcacheContent;
+    }
+
+    @Override
+    protected boolean isLastContentMessage(MemcacheContent msg) throws Exception {
+        return msg instanceof LastMemcacheContent;
+    }
+
+    @Override
+    protected boolean isAggregated(MemcacheObject msg) throws Exception {
+        return msg instanceof FullMemcacheMessage;
+    }
+
+    @Override
+    protected boolean hasContentLength(H start) throws Exception {
+        return false;
+    }
+
+    @Override
+    protected long contentLength(H start) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected Object newContinueResponse(H start) throws Exception {
+        return null;
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java
new file mode 100644
index 000000000000..3aff4bf96107
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.handler.codec.ByteToMessageDecoder;
+
+/**
+ * Abstract super class for both ascii and binary decoders.
+ * <p/>
+ * Currently it just acts as a common denominator, but will certainly include methods once the ascii protocol
+ * is implemented.
+ */
+public abstract class AbstractMemcacheObjectDecoder extends ByteToMessageDecoder {
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java
new file mode 100644
index 000000000000..4248f81210b2
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.FileRegion;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.util.internal.StringUtil;
+
+import java.util.List;
+
+/**
+ * A general purpose {@link AbstractMemcacheObjectEncoder} that encodes {@link MemcacheMessage}s.
+ * <p/>
+ * <p>Note that this class is designed to be extended, especially because both the binary and ascii protocol
+ * require different treatment of their messages. Since the content chunk writing is the same for both, the encoder
+ * abstracts this right away.</p>
+ */
+public abstract class AbstractMemcacheObjectEncoder<M extends MemcacheMessage> extends MessageToMessageEncoder<Object> {
+
+    private boolean expectingMoreContent;
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
+        if (msg instanceof MemcacheMessage) {
+            if (expectingMoreContent) {
+                throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
+            }
+
+            @SuppressWarnings({ "unchecked", "CastConflictsWithInstanceof" })
+            final M m = (M) msg;
+            out.add(encodeMessage(ctx, m));
+        }
+
+        if (msg instanceof MemcacheContent || msg instanceof ByteBuf || msg instanceof FileRegion) {
+            int contentLength = contentLength(msg);
+            if (contentLength > 0) {
+                out.add(encodeAndRetain(msg));
+            } else {
+                out.add(Unpooled.EMPTY_BUFFER);
+            }
+
+            expectingMoreContent = !(msg instanceof LastMemcacheContent);
+        }
+    }
+
+    @Override
+    public boolean acceptOutboundMessage(Object msg) throws Exception {
+        return msg instanceof MemcacheObject || msg instanceof ByteBuf || msg instanceof FileRegion;
+    }
+
+    /**
+     * Take the given {@link MemcacheMessage} and encode it into a writable {@link ByteBuf}.
+     *
+     * @param ctx the channel handler context.
+     * @param msg the message to encode.
+     * @return the {@link ByteBuf} representation of the message.
+     */
+    protected abstract ByteBuf encodeMessage(ChannelHandlerContext ctx, M msg);
+
+    /**
+     * Determine the content length of the given object.
+     *
+     * @param msg the object to determine the length of.
+     * @return the determined content length.
+     */
+    private static int contentLength(Object msg) {
+        if (msg instanceof MemcacheContent) {
+            return ((MemcacheContent) msg).content().readableBytes();
+        }
+        if (msg instanceof ByteBuf) {
+            return ((ByteBuf) msg).readableBytes();
+        }
+        if (msg instanceof FileRegion) {
+            return (int) ((FileRegion) msg).count();
+        }
+        throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
+    }
+
+    /**
+     * Encode the content, depending on the object type.
+     *
+     * @param msg the object to encode.
+     * @return the encoded object.
+     */
+    private static Object encodeAndRetain(Object msg) {
+        if (msg instanceof ByteBuf) {
+            return ((ByteBuf) msg).retain();
+        }
+        if (msg instanceof MemcacheContent) {
+            return ((MemcacheContent) msg).content().retain();
+        }
+        if (msg instanceof FileRegion) {
+            return ((FileRegion) msg).retain();
+        }
+        throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg));
+    }
+
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java
new file mode 100644
index 000000000000..67854278788e
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.memcache;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+/**
+ * The default implementation for the {@link LastMemcacheContent}.
+ */
+public class DefaultLastMemcacheContent extends DefaultMemcacheContent implements LastMemcacheContent {
+
+    public DefaultLastMemcacheContent() {
+        super(Unpooled.buffer());
+    }
+
+    public DefaultLastMemcacheContent(ByteBuf content) {
+        super(content);
+    }
+
+    @Override
+    public LastMemcacheContent retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public LastMemcacheContent retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public LastMemcacheContent touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public LastMemcacheContent touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+
+    @Override
+    public LastMemcacheContent copy() {
+        return new DefaultLastMemcacheContent(content().copy());
+    }
+
+    @Override
+    public LastMemcacheContent duplicate() {
+        return new DefaultLastMemcacheContent(content().duplicate());
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java
new file mode 100644
index 000000000000..32f0022ff846
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.StringUtil;
+
+/**
+ * The default {@link MemcacheContent} implementation.
+ */
+public class DefaultMemcacheContent extends AbstractMemcacheObject implements MemcacheContent {
+
+    private final ByteBuf content;
+
+    /**
+     * Creates a new instance with the specified content.
+     */
+    public DefaultMemcacheContent(ByteBuf content) {
+        if (content == null) {
+            throw new NullPointerException("Content cannot be null.");
+        }
+        this.content = content;
+    }
+
+    @Override
+    public ByteBuf content() {
+        return content;
+    }
+
+    @Override
+    public MemcacheContent copy() {
+        return new DefaultMemcacheContent(content.copy());
+    }
+
+    @Override
+    public MemcacheContent duplicate() {
+        return new DefaultMemcacheContent(content.duplicate());
+    }
+
+    @Override
+    public int refCnt() {
+        return content.refCnt();
+    }
+
+    @Override
+    public MemcacheContent retain() {
+        content.retain();
+        return this;
+    }
+
+    @Override
+    public MemcacheContent retain(int increment) {
+        content.retain(increment);
+        return this;
+    }
+
+    @Override
+    public MemcacheContent touch() {
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public MemcacheContent touch(Object hint) {
+        content.touch(hint);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        return content.release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        return content.release(decrement);
+    }
+
+    @Override
+    public String toString() {
+        return StringUtil.simpleClassName(this) +
+               "(data: " + content() + ", decoderResult: " + decoderResult() + ')';
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java
new file mode 100644
index 000000000000..3ae0616b9d1f
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+/**
+ * Combines {@link MemcacheMessage} and {@link LastMemcacheContent} into one
+ * message. So it represent a <i>complete</i> memcache message.
+ */
+public interface FullMemcacheMessage extends MemcacheMessage, LastMemcacheContent {
+
+    @Override
+    FullMemcacheMessage copy();
+
+    @Override
+    FullMemcacheMessage retain(int increment);
+
+    @Override
+    FullMemcacheMessage retain();
+
+    @Override
+    FullMemcacheMessage touch();
+
+    @Override
+    FullMemcacheMessage touch(Object hint);
+
+    @Override
+    FullMemcacheMessage duplicate();
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java
new file mode 100644
index 000000000000..0b20bdd2c626
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.DecoderResult;
+
+/**
+ * The {@link MemcacheContent} which signals the end of the content batch.
+ * <p/>
+ * Note that by design, even when no content is emitted by the protocol, an
+ * empty {@link LastMemcacheContent} is issued to make the upstream parsing
+ * easier.
+ */
+public interface LastMemcacheContent extends MemcacheContent {
+
+    LastMemcacheContent EMPTY_LAST_CONTENT = new LastMemcacheContent() {
+
+        @Override
+        public LastMemcacheContent copy() {
+            return EMPTY_LAST_CONTENT;
+        }
+
+        @Override
+        public LastMemcacheContent retain(int increment) {
+            return this;
+        }
+
+        @Override
+        public LastMemcacheContent retain() {
+            return this;
+        }
+
+        @Override
+        public LastMemcacheContent touch() {
+            return this;
+        }
+
+        @Override
+        public LastMemcacheContent touch(Object hint) {
+            return this;
+        }
+
+        @Override
+        public LastMemcacheContent duplicate() {
+            return this;
+        }
+
+        @Override
+        public ByteBuf content() {
+            return Unpooled.EMPTY_BUFFER;
+        }
+
+        @Override
+        public DecoderResult decoderResult() {
+            return DecoderResult.SUCCESS;
+        }
+
+        @Override
+        public void setDecoderResult(DecoderResult result) {
+            throw new UnsupportedOperationException("read only");
+        }
+
+        @Override
+        public int refCnt() {
+            return 1;
+        }
+
+        @Override
+        public boolean release() {
+            return false;
+        }
+
+        @Override
+        public boolean release(int decrement) {
+            return false;
+        }
+    };
+
+    @Override
+    LastMemcacheContent copy();
+
+    @Override
+    LastMemcacheContent retain(int increment);
+
+    @Override
+    LastMemcacheContent retain();
+
+    @Override
+    LastMemcacheContent touch();
+
+    @Override
+    LastMemcacheContent touch(Object hint);
+
+    @Override
+    LastMemcacheContent duplicate();
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java
new file mode 100644
index 000000000000..86466e838901
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.buffer.ByteBufHolder;
+import io.netty.channel.ChannelPipeline;
+
+/**
+ * An Memcache content chunk.
+ * <p/>
+ * A implementation of a {@link AbstractMemcacheObjectDecoder} generates {@link MemcacheContent} after
+ * {@link MemcacheMessage} when the content is large. If you prefer not to receive {@link MemcacheContent}
+ * in your handler, place a aggregator after an implementation of the {@link AbstractMemcacheObjectDecoder}
+ * in the {@link ChannelPipeline}.
+ */
+public interface MemcacheContent extends MemcacheObject, ByteBufHolder {
+
+    @Override
+    MemcacheContent copy();
+
+    @Override
+    MemcacheContent duplicate();
+
+    @Override
+    MemcacheContent retain();
+
+    @Override
+    MemcacheContent retain(int increment);
+
+    @Override
+    MemcacheContent touch();
+
+    @Override
+    MemcacheContent touch(Object hint);
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java
new file mode 100644
index 000000000000..fdc096a30177
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.util.ReferenceCounted;
+
+/**
+ * Marker interface for both ascii and binary messages.
+ */
+public interface MemcacheMessage extends MemcacheObject, ReferenceCounted {
+
+    /**
+     * Increases the reference count by {@code 1}.
+     */
+    @Override
+    MemcacheMessage retain();
+
+    /**
+     * Increases the reference count by the specified {@code increment}.
+     */
+    @Override
+    MemcacheMessage retain(int increment);
+
+    @Override
+    MemcacheMessage touch();
+
+    @Override
+    MemcacheMessage touch(Object hint);
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java
new file mode 100644
index 000000000000..5cb072de2e3a
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache;
+
+import io.netty.handler.codec.DecoderResultProvider;
+
+/**
+ * Defines a common interface for all {@link MemcacheObject} implementations.
+ */
+public interface MemcacheObject extends DecoderResultProvider { }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java
new file mode 100644
index 000000000000..eb5c5c9c7cbb
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.DecoderResult;
+import io.netty.handler.codec.memcache.AbstractMemcacheObjectDecoder;
+import io.netty.handler.codec.memcache.DefaultLastMemcacheContent;
+import io.netty.handler.codec.memcache.DefaultMemcacheContent;
+import io.netty.handler.codec.memcache.LastMemcacheContent;
+import io.netty.handler.codec.memcache.MemcacheContent;
+import io.netty.util.CharsetUtil;
+
+import java.util.List;
+
+import static io.netty.buffer.ByteBufUtil.*;
+
+/**
+ * Decoder for both {@link BinaryMemcacheRequest} and {@link BinaryMemcacheResponse}.
+ * <p/>
+ * The difference in the protocols (header) is implemented by the subclasses.
+ */
+public abstract class AbstractBinaryMemcacheDecoder<M extends BinaryMemcacheMessage>
+    extends AbstractMemcacheObjectDecoder {
+
+    public static final int DEFAULT_MAX_CHUNK_SIZE = 8192;
+
+    private final int chunkSize;
+
+    private M currentMessage;
+    private int alreadyReadChunkSize;
+
+    private State state = State.READ_HEADER;
+
+    /**
+     * Create a new {@link AbstractBinaryMemcacheDecoder} with default settings.
+     */
+    protected AbstractBinaryMemcacheDecoder() {
+        this(DEFAULT_MAX_CHUNK_SIZE);
+    }
+
+    /**
+     * Create a new {@link AbstractBinaryMemcacheDecoder} with custom settings.
+     *
+     * @param chunkSize the maximum chunk size of the payload.
+     */
+    protected AbstractBinaryMemcacheDecoder(int chunkSize) {
+        if (chunkSize < 0) {
+            throw new IllegalArgumentException("chunkSize must be a positive integer: " + chunkSize);
+        }
+
+        this.chunkSize = chunkSize;
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        switch (state) {
+            case READ_HEADER: try {
+                if (in.readableBytes() < 24) {
+                    return;
+                }
+                resetDecoder();
+
+                currentMessage = decodeHeader(in);
+                state = State.READ_EXTRAS;
+            } catch (Exception e) {
+                out.add(invalidMessage(e));
+                return;
+            }
+            case READ_EXTRAS: try {
+                byte extrasLength = currentMessage.extrasLength();
+                if (extrasLength > 0) {
+                    if (in.readableBytes() < extrasLength) {
+                        return;
+                    }
+
+                    currentMessage.setExtras(readBytes(ctx.alloc(), in, extrasLength));
+                }
+
+                state = State.READ_KEY;
+            } catch (Exception e) {
+                out.add(invalidMessage(e));
+                return;
+            }
+            case READ_KEY: try {
+                short keyLength = currentMessage.keyLength();
+                if (keyLength > 0) {
+                    if (in.readableBytes() < keyLength) {
+                        return;
+                    }
+
+                    currentMessage.setKey(in.toString(in.readerIndex(), keyLength, CharsetUtil.UTF_8));
+                    in.skipBytes(keyLength);
+                }
+
+                out.add(currentMessage);
+                state = State.READ_CONTENT;
+            } catch (Exception e) {
+                out.add(invalidMessage(e));
+                return;
+            }
+            case READ_CONTENT: try {
+                int valueLength = currentMessage.totalBodyLength()
+                    - currentMessage.keyLength()
+                    - currentMessage.extrasLength();
+                int toRead = in.readableBytes();
+                if (valueLength > 0) {
+                    if (toRead == 0) {
+                        return;
+                    }
+
+                    if (toRead > chunkSize) {
+                        toRead = chunkSize;
+                    }
+
+                    int remainingLength = valueLength - alreadyReadChunkSize;
+                    if (toRead > remainingLength) {
+                        toRead = remainingLength;
+                    }
+
+                    ByteBuf chunkBuffer = readBytes(ctx.alloc(), in, toRead);
+
+                    MemcacheContent chunk;
+                    if ((alreadyReadChunkSize += toRead) >= valueLength) {
+                        chunk = new DefaultLastMemcacheContent(chunkBuffer);
+                    } else {
+                        chunk = new DefaultMemcacheContent(chunkBuffer);
+                    }
+
+                    out.add(chunk);
+                    if (alreadyReadChunkSize < valueLength) {
+                        return;
+                    }
+                } else {
+                    out.add(LastMemcacheContent.EMPTY_LAST_CONTENT);
+                }
+
+                state = State.READ_HEADER;
+                return;
+            } catch (Exception e) {
+                out.add(invalidChunk(e));
+                return;
+            }
+            case BAD_MESSAGE:
+                in.skipBytes(actualReadableBytes());
+                return;
+            default:
+                throw new Error("Unknown state reached: " + state);
+        }
+    }
+
+    /**
+     * Helper method to create a message indicating a invalid decoding result.
+     *
+     * @param cause the cause of the decoding failure.
+     * @return a valid message indicating failure.
+     */
+    private M invalidMessage(Exception cause) {
+        state = State.BAD_MESSAGE;
+        M message = buildInvalidMessage();
+        message.setDecoderResult(DecoderResult.failure(cause));
+        return message;
+    }
+
+    /**
+     * Helper method to create a content chunk indicating a invalid decoding result.
+     *
+     * @param cause the cause of the decoding failure.
+     * @return a valid content chunk indicating failure.
+     */
+    private MemcacheContent invalidChunk(Exception cause) {
+        state = State.BAD_MESSAGE;
+        MemcacheContent chunk = new DefaultLastMemcacheContent(Unpooled.EMPTY_BUFFER);
+        chunk.setDecoderResult(DecoderResult.failure(cause));
+        return chunk;
+    }
+
+    /**
+     * When the channel goes inactive, release all frames to prevent data leaks.
+     *
+     * @param ctx handler context
+     * @throws Exception
+     */
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        super.channelInactive(ctx);
+
+        if (currentMessage != null) {
+            currentMessage.release();
+        }
+
+        resetDecoder();
+    }
+
+    /**
+     * Prepare for next decoding iteration.
+     */
+    protected void resetDecoder() {
+        currentMessage = null;
+        alreadyReadChunkSize = 0;
+    }
+
+    /**
+     * Decode and return the parsed {@link BinaryMemcacheMessage}.
+     *
+     * @param in the incoming buffer.
+     * @return the decoded header.
+     */
+    protected abstract M decodeHeader(ByteBuf in);
+
+    /**
+     * Helper method to create a upstream message when the incoming parsing did fail.
+     *
+     * @return a message indicating a decoding failure.
+     */
+    protected abstract M buildInvalidMessage();
+
+    /**
+     * Contains all states this decoder can possibly be in.
+     * <p/>
+     * Note that most of the states can be optional, the only one required is reading
+     * the header ({@link #READ_HEADER}. All other steps depend on the length fields
+     * in the header and will be executed conditionally.
+     */
+    enum State {
+        /**
+         * Currently reading the header portion.
+         */
+        READ_HEADER,
+
+        /**
+         * Currently reading the extras portion (optional).
+         */
+        READ_EXTRAS,
+
+        /**
+         * Currently reading the key portion (optional).
+         */
+        READ_KEY,
+
+        /**
+         * Currently reading the value chunks (optional).
+         */
+        READ_CONTENT,
+
+        /**
+         * Something went wrong while decoding the message or chunks.
+         */
+        BAD_MESSAGE
+    }
+
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
new file mode 100644
index 000000000000..1edd7c4a77c1
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToByteEncoder;
+import io.netty.handler.codec.memcache.AbstractMemcacheObjectEncoder;
+import io.netty.util.CharsetUtil;
+
+/**
+ * A {@link MessageToByteEncoder} that encodes binary memache messages into bytes.
+ */
+public abstract class AbstractBinaryMemcacheEncoder<M extends BinaryMemcacheMessage>
+    extends AbstractMemcacheObjectEncoder<M> {
+
+    /**
+     * Every binary memcache message has at least a 24 bytes header.
+     */
+    private static final int DEFAULT_BUFFER_SIZE = 24;
+
+    @Override
+    protected ByteBuf encodeMessage(ChannelHandlerContext ctx, M msg) {
+        ByteBuf buf = ctx.alloc().buffer(DEFAULT_BUFFER_SIZE);
+
+        encodeHeader(buf, msg);
+        encodeExtras(buf, msg.extras());
+        encodeKey(buf, msg.key());
+
+        return buf;
+    }
+
+    /**
+     * Encode the extras.
+     *
+     * @param buf    the {@link ByteBuf} to write into.
+     * @param extras the extras to encode.
+     */
+    private static void encodeExtras(ByteBuf buf, ByteBuf extras) {
+        if (extras == null || !extras.isReadable()) {
+            return;
+        }
+
+        buf.writeBytes(extras);
+    }
+
+    /**
+     * Encode the key.
+     *
+     * @param buf the {@link ByteBuf} to write into.
+     * @param key the key to encode.
+     */
+    private static void encodeKey(ByteBuf buf, String key) {
+        if (key == null || key.isEmpty()) {
+            return;
+        }
+
+        buf.writeBytes(key.getBytes(CharsetUtil.UTF_8));
+    }
+
+    /**
+     * Encode the header.
+     * <p/>
+     * This methods needs to be implemented by a sub class because the header is different
+     * for both requests and responses.
+     *
+     * @param buf the {@link ByteBuf} to write into.
+     * @param msg the message to encode.
+     */
+    protected abstract void encodeHeader(ByteBuf buf, M msg);
+
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java
new file mode 100644
index 000000000000..abde374cfb83
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.memcache.AbstractMemcacheObject;
+
+/**
+ * Default implementation of a {@link BinaryMemcacheMessage}.
+ */
+public abstract class AbstractBinaryMemcacheMessage
+    extends AbstractMemcacheObject
+    implements BinaryMemcacheMessage {
+
+    /**
+     * Contains the optional key.
+     */
+    private String key;
+
+    /**
+     * Contains the optional extras.
+     */
+    private ByteBuf extras;
+
+    private byte magic;
+    private byte opcode;
+    private short keyLength;
+    private byte extrasLength;
+    private byte dataType;
+    private int totalBodyLength;
+    private int opaque;
+    private long cas;
+
+    /**
+     * Create a new instance with all properties set.
+     *
+     * @param key    the message key.
+     * @param extras the message extras.
+     */
+    protected AbstractBinaryMemcacheMessage(String key, ByteBuf extras) {
+        this.key = key;
+        this.extras = extras;
+    }
+
+    @Override
+    public String key() {
+        return key;
+    }
+
+    @Override
+    public ByteBuf extras() {
+        return extras;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setKey(String key) {
+        this.key = key;
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setExtras(ByteBuf extras) {
+        this.extras = extras;
+        return this;
+    }
+
+    @Override
+    public byte magic() {
+        return magic;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setMagic(byte magic) {
+        this.magic = magic;
+        return this;
+    }
+
+    @Override
+    public long cas() {
+        return cas;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setCas(long cas) {
+        this.cas = cas;
+        return this;
+    }
+
+    @Override
+    public int opaque() {
+        return opaque;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setOpaque(int opaque) {
+        this.opaque = opaque;
+        return this;
+    }
+
+    @Override
+    public int totalBodyLength() {
+        return totalBodyLength;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setTotalBodyLength(int totalBodyLength) {
+        this.totalBodyLength = totalBodyLength;
+        return this;
+    }
+
+    @Override
+    public byte dataType() {
+        return dataType;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setDataType(byte dataType) {
+        this.dataType = dataType;
+        return this;
+    }
+
+    @Override
+    public byte extrasLength() {
+        return extrasLength;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setExtrasLength(byte extrasLength) {
+        this.extrasLength = extrasLength;
+        return this;
+    }
+
+    @Override
+    public short keyLength() {
+        return keyLength;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setKeyLength(short keyLength) {
+        this.keyLength = keyLength;
+        return this;
+    }
+
+    @Override
+    public byte opcode() {
+        return opcode;
+    }
+
+    @Override
+    public BinaryMemcacheMessage setOpcode(byte opcode) {
+        this.opcode = opcode;
+        return this;
+    }
+
+    @Override
+    public int refCnt() {
+        if (extras != null) {
+            return extras.refCnt();
+        }
+        return 1;
+    }
+
+    @Override
+    public BinaryMemcacheMessage retain() {
+        if (extras != null) {
+            extras.retain();
+        }
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheMessage retain(int increment) {
+        if (extras != null) {
+            extras.retain(increment);
+        }
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        if (extras != null) {
+            return extras.release();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        if (extras != null) {
+            return extras.release(decrement);
+        }
+        return false;
+    }
+
+    @Override
+    public BinaryMemcacheMessage touch() {
+        return touch(null);
+    }
+
+    @Override
+    public BinaryMemcacheMessage touch(Object hint) {
+        if (extras != null) {
+            extras.touch(hint);
+        }
+        return this;
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java
new file mode 100644
index 000000000000..b7b67eb9fe9e
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerAppender;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.PrematureChannelClosureException;
+import io.netty.handler.codec.memcache.LastMemcacheContent;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * The client codec that combines the proper encoder and decoder.
+ * <p/>
+ * Use this codec if you want to implement a memcache client that speaks the binary protocol. It
+ * combines both the {@link BinaryMemcacheResponseDecoder} and the {@link BinaryMemcacheRequestEncoder}.
+ * <p/>
+ * Optionally, it counts the number of outstanding responses and raises an exception if - on connection
+ * close - the list is not 0 (this is turned off by default). You can also define a chunk size for the
+ * content, which defaults to 8192. This chunk size is the maximum, so if smaller chunks arrive they
+ * will be passed up the pipeline and not queued up to the chunk size.
+ */
+public final class BinaryMemcacheClientCodec extends ChannelHandlerAppender {
+
+    private final boolean failOnMissingResponse;
+    private final AtomicLong requestResponseCounter = new AtomicLong();
+
+    /**
+     * Create a new {@link BinaryMemcacheClientCodec} with the default settings applied.
+     */
+    public BinaryMemcacheClientCodec() {
+        this(AbstractBinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);
+    }
+
+    /**
+     * Create a new {@link BinaryMemcacheClientCodec} and set a custom chunk size.
+     *
+     * @param decodeChunkSize the maximum chunk size.
+     */
+    public BinaryMemcacheClientCodec(int decodeChunkSize) {
+        this(decodeChunkSize, false);
+    }
+
+    /**
+     * Create a new {@link BinaryMemcacheClientCodec} with custom settings.
+     *
+     * @param decodeChunkSize       the maximum chunk size.
+     * @param failOnMissingResponse report if after close there are outstanding requests.
+     */
+    public BinaryMemcacheClientCodec(int decodeChunkSize, boolean failOnMissingResponse) {
+        this.failOnMissingResponse = failOnMissingResponse;
+        add(new Decoder(decodeChunkSize));
+        add(new Encoder());
+    }
+
+    private final class Encoder extends BinaryMemcacheRequestEncoder {
+
+        @Override
+        protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
+            super.encode(ctx, msg, out);
+
+            if (failOnMissingResponse && msg instanceof LastMemcacheContent) {
+                requestResponseCounter.incrementAndGet();
+            }
+        }
+    }
+
+    private final class Decoder extends BinaryMemcacheResponseDecoder {
+
+        Decoder(int chunkSize) {
+            super(chunkSize);
+        }
+
+        @Override
+        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+            int oldSize = out.size();
+            super.decode(ctx, in, out);
+
+            if (failOnMissingResponse) {
+                final int size = out.size();
+                for (int i = oldSize; i < size; i ++) {
+                    Object msg = out.get(i);
+                    if (msg instanceof LastMemcacheContent) {
+                        requestResponseCounter.decrementAndGet();
+                    }
+                }
+            }
+        }
+
+        @Override
+        public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+            super.channelInactive(ctx);
+
+            if (failOnMissingResponse) {
+                long missingResponses = requestResponseCounter.get();
+                if (missingResponses > 0) {
+                    ctx.fireExceptionCaught(new PrematureChannelClosureException(
+                        "channel gone inactive with " + missingResponses +
+                            " missing response(s)"));
+                }
+            }
+        }
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java
new file mode 100644
index 000000000000..dbeaf75468e0
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.memcache.MemcacheMessage;
+
+/**
+ * An interface that defines a binary Memcache message, providing common properties for
+ * {@link BinaryMemcacheRequest} and {@link BinaryMemcacheResponse}.
+ * <p/>
+ * A {@link BinaryMemcacheMessage} always consists of a header and optional extras or/and
+ * a key.
+ *
+ * @see BinaryMemcacheRequest
+ * @see BinaryMemcacheResponse
+ */
+public interface BinaryMemcacheMessage extends MemcacheMessage {
+
+    /**
+     * Returns the magic byte for the message.
+     *
+     * @return the magic byte.
+     */
+    byte magic();
+
+    /**
+     * Sets the magic byte.
+     *
+     * @param magic the magic byte to use.
+     * @see BinaryMemcacheOpcodes for typesafe opcodes.
+     */
+    BinaryMemcacheMessage setMagic(byte magic);
+
+    /**
+     * Returns the opcode for the message.
+     *
+     * @return the opcode.
+     */
+    byte opcode();
+
+    /**
+     * Sets the opcode for the message.
+     *
+     * @param code the opcode to use.
+     */
+    BinaryMemcacheMessage setOpcode(byte code);
+
+    /**
+     * Returns the key length of the message.
+     * <p/>
+     * This may return 0, since the key is optional.
+     *
+     * @return the key length.
+     */
+    short keyLength();
+
+    /**
+     * Set the key length of the message.
+     * <p/>
+     * This may be 0, since the key is optional.
+     *
+     * @param keyLength the key length to use.
+     */
+    BinaryMemcacheMessage setKeyLength(short keyLength);
+
+    /**
+     * Return the extras length of the message.
+     * <p/>
+     * This may be 0, since the extras content is optional.
+     *
+     * @return the extras length.
+     */
+    byte extrasLength();
+
+    /**
+     * Set the extras length of the message.
+     * <p/>
+     * This may be 0, since the extras content is optional.
+     *
+     * @param extrasLength the extras length.
+     */
+    BinaryMemcacheMessage setExtrasLength(byte extrasLength);
+
+    /**
+     * Returns the data type of the message.
+     *
+     * @return the data type of the message.
+     */
+    byte dataType();
+
+    /**
+     * Sets the data type of the message.
+     *
+     * @param dataType the data type of the message.
+     */
+    BinaryMemcacheMessage setDataType(byte dataType);
+
+    /**
+     * Returns the total body length.
+     * <p/>
+     * Note that this may be 0, since the body is optional.
+     *
+     * @return the total body length.
+     */
+    int totalBodyLength();
+
+    /**
+     * Sets the total body length.
+     * <p/>
+     * Note that this may be 0, since the body length is optional.
+     *
+     * @param totalBodyLength the total body length.
+     */
+    BinaryMemcacheMessage setTotalBodyLength(int totalBodyLength);
+
+    /**
+     * Returns the opaque value.
+     *
+     * @return the opaque value.
+     */
+    int opaque();
+
+    /**
+     * Sets the opaque value.
+     *
+     * @param opaque the opqaue value to use.
+     */
+    BinaryMemcacheMessage setOpaque(int opaque);
+
+    /**
+     * Returns the CAS identifier.
+     *
+     * @return the CAS identifier.
+     */
+    long cas();
+
+    /**
+     * Sets the CAS identifier.
+     *
+     * @param cas the CAS identifier to use.
+     */
+    BinaryMemcacheMessage setCas(long cas);
+
+    /**
+     * Returns the optional key of the document.
+     *
+     * @return the key of the document.
+     */
+    String key();
+
+    /**
+     * Sets the key of the document.
+     *
+     * @param key the key of the message.
+     */
+    BinaryMemcacheMessage setKey(String key);
+
+    /**
+     * Returns a {@link ByteBuf} representation of the optional extras.
+     *
+     * @return the optional extras.
+     */
+    ByteBuf extras();
+
+    /**
+     * Sets the extras buffer on the message.
+     *
+     * @param extras the extras buffer of the document.
+     */
+    BinaryMemcacheMessage setExtras(ByteBuf extras);
+
+    /**
+     * Increases the reference count by {@code 1}.
+     */
+    @Override
+    BinaryMemcacheMessage retain();
+
+    /**
+     * Increases the reference count by the specified {@code increment}.
+     */
+    @Override
+    BinaryMemcacheMessage retain(int increment);
+
+    @Override
+    BinaryMemcacheMessage touch();
+
+    @Override
+    BinaryMemcacheMessage touch(Object hint);
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java
new file mode 100644
index 000000000000..b07db33c4c4f
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.memcache.AbstractMemcacheObjectAggregator;
+import io.netty.handler.codec.memcache.FullMemcacheMessage;
+import io.netty.handler.codec.memcache.MemcacheContent;
+import io.netty.handler.codec.memcache.MemcacheObject;
+
+/**
+ * An object aggregator for the memcache binary protocol.
+ *
+ * It aggregates {@link BinaryMemcacheMessage}s and {@link MemcacheContent} into {@link FullBinaryMemcacheRequest}s
+ * or {@link FullBinaryMemcacheResponse}s.
+ */
+public class BinaryMemcacheObjectAggregator extends AbstractMemcacheObjectAggregator<BinaryMemcacheMessage> {
+
+    public BinaryMemcacheObjectAggregator(int maxContentLength) {
+        super(maxContentLength);
+    }
+
+    @Override
+    protected boolean isStartMessage(MemcacheObject msg) throws Exception {
+        return msg instanceof BinaryMemcacheMessage;
+    }
+
+    @Override
+    protected FullMemcacheMessage beginAggregation(BinaryMemcacheMessage start, ByteBuf content) throws Exception {
+        if (start instanceof BinaryMemcacheRequest) {
+            return toFullRequest((BinaryMemcacheRequest) start, content);
+        }
+
+        if (start instanceof BinaryMemcacheResponse) {
+            return toFullResponse((BinaryMemcacheResponse) start, content);
+        }
+
+        // Should not reach here.
+        throw new Error();
+    }
+
+    private static FullBinaryMemcacheRequest toFullRequest(BinaryMemcacheRequest request, ByteBuf content) {
+        FullBinaryMemcacheRequest fullRequest =
+                new DefaultFullBinaryMemcacheRequest(request.key(), request.extras(), content);
+
+        fullRequest.setMagic(request.magic());
+        fullRequest.setOpcode(request.opcode());
+        fullRequest.setKeyLength(request.keyLength());
+        fullRequest.setExtrasLength(request.extrasLength());
+        fullRequest.setDataType(request.dataType());
+        fullRequest.setTotalBodyLength(request.totalBodyLength());
+        fullRequest.setOpaque(request.opaque());
+        fullRequest.setCas(request.cas());
+        fullRequest.setReserved(request.reserved());
+
+        return fullRequest;
+    }
+
+    private static FullBinaryMemcacheResponse toFullResponse(BinaryMemcacheResponse response, ByteBuf content) {
+        FullBinaryMemcacheResponse fullResponse =
+                new DefaultFullBinaryMemcacheResponse(response.key(), response.extras(), content);
+
+        fullResponse.setMagic(response.magic());
+        fullResponse.setOpcode(response.opcode());
+        fullResponse.setKeyLength(response.keyLength());
+        fullResponse.setExtrasLength(response.extrasLength());
+        fullResponse.setDataType(response.dataType());
+        fullResponse.setTotalBodyLength(response.totalBodyLength());
+        fullResponse.setOpaque(response.opaque());
+        fullResponse.setCas(response.cas());
+        fullResponse.setStatus(response.status());
+
+        return fullResponse;
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java
new file mode 100644
index 000000000000..755c740bdc78
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+/**
+ * Represents all Opcodes that can occur in a {@link BinaryMemcacheMessage}.
+ * <p/>
+ * This class can be extended if a custom application needs to implement a superset of the normally supported
+ * operations by a vanilla memcached protocol.
+ */
+public final class BinaryMemcacheOpcodes {
+
+    private BinaryMemcacheOpcodes() {
+        // disallow construction
+    }
+
+    public static final byte GET = 0x00;
+    public static final byte SET = 0x01;
+    public static final byte ADD = 0x02;
+    public static final byte REPLACE = 0x03;
+    public static final byte DELETE = 0x04;
+    public static final byte INCREMENT = 0x05;
+    public static final byte DECREMENT = 0x06;
+    public static final byte QUIT = 0x07;
+    public static final byte FLUSH = 0x08;
+    public static final byte GETQ = 0x09;
+    public static final byte NOOP = 0x0a;
+    public static final byte VERSION = 0x0b;
+    public static final byte GETK = 0x0c;
+    public static final byte GETKQ = 0x0d;
+    public static final byte APPEND = 0x0e;
+    public static final byte PREPEND = 0x0f;
+    public static final byte STAT = 0x10;
+    public static final byte SETQ = 0x11;
+    public static final byte ADDQ = 0x12;
+    public static final byte REPLACEQ = 0x13;
+    public static final byte DELETEQ = 0x14;
+    public static final byte INCREMENTQ = 0x15;
+    public static final byte DECREMENTQ = 0x16;
+    public static final byte QUITQ = 0x17;
+    public static final byte FLUSHQ = 0x18;
+    public static final byte APPENDQ = 0x19;
+    public static final byte PREPENDQ = 0x1a;
+    public static final byte TOUCH = 0x1c;
+    public static final byte GAT = 0x1d;
+    public static final byte GATQ = 0x1e;
+    public static final byte GATK = 0x23;
+    public static final byte GATKQ = 0x24;
+    public static final byte SASL_LIST_MECHS = 0x20;
+    public static final byte SASL_AUTH = 0x21;
+    public static final byte SASL_STEP = 0x22;
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java
new file mode 100644
index 000000000000..87a9cf4d84db
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+/**
+ * Represents a full {@link BinaryMemcacheRequest}, which contains the header and optional key and extras.
+ */
+public interface BinaryMemcacheRequest extends BinaryMemcacheMessage {
+
+    /**
+     * Returns the reserved field value.
+     *
+     * @return the reserved field value.
+     */
+    short reserved();
+
+    /**
+     * Sets the reserved field value.
+     *
+     * @param reserved the reserved field value.
+     */
+    BinaryMemcacheRequest setReserved(short reserved);
+
+    @Override
+    BinaryMemcacheRequest retain();
+
+    @Override
+    BinaryMemcacheRequest retain(int increment);
+
+    @Override
+    BinaryMemcacheRequest touch();
+
+    @Override
+    BinaryMemcacheRequest touch(Object hint);
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
new file mode 100644
index 000000000000..08e6656a9845
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+/**
+ * The decoder part which takes care of decoding the request-specific headers.
+ */
+public class BinaryMemcacheRequestDecoder
+    extends AbstractBinaryMemcacheDecoder<BinaryMemcacheRequest> {
+
+    public BinaryMemcacheRequestDecoder() {
+        this(DEFAULT_MAX_CHUNK_SIZE);
+    }
+
+    public BinaryMemcacheRequestDecoder(int chunkSize) {
+        super(chunkSize);
+    }
+
+    @Override
+    protected BinaryMemcacheRequest decodeHeader(ByteBuf in) {
+        BinaryMemcacheRequest header = new DefaultBinaryMemcacheRequest();
+        header.setMagic(in.readByte());
+        header.setOpcode(in.readByte());
+        header.setKeyLength(in.readShort());
+        header.setExtrasLength(in.readByte());
+        header.setDataType(in.readByte());
+        header.setReserved(in.readShort());
+        header.setTotalBodyLength(in.readInt());
+        header.setOpaque(in.readInt());
+        header.setCas(in.readLong());
+        return header;
+    }
+
+    @Override
+    protected BinaryMemcacheRequest buildInvalidMessage() {
+        return new DefaultBinaryMemcacheRequest("", Unpooled.EMPTY_BUFFER);
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java
new file mode 100644
index 000000000000..c4261ebe1133
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * The encoder part which takes care of encoding the request headers.
+ */
+public class BinaryMemcacheRequestEncoder
+    extends AbstractBinaryMemcacheEncoder<BinaryMemcacheRequest> {
+
+    @Override
+    protected void encodeHeader(ByteBuf buf, BinaryMemcacheRequest msg) {
+        buf.writeByte(msg.magic());
+        buf.writeByte(msg.opcode());
+        buf.writeShort(msg.keyLength());
+        buf.writeByte(msg.extrasLength());
+        buf.writeByte(msg.dataType());
+        buf.writeShort(msg.reserved());
+        buf.writeInt(msg.totalBodyLength());
+        buf.writeInt(msg.opaque());
+        buf.writeLong(msg.cas());
+    }
+
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java
new file mode 100644
index 000000000000..3adfbce5caab
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+/**
+ * Represents a full {@link BinaryMemcacheResponse}, which contains the header and optional key and extras.
+ */
+public interface BinaryMemcacheResponse extends BinaryMemcacheMessage {
+
+    /**
+     * Returns the status of the response.
+     *
+     * @return the status of the response.
+     */
+    short status();
+
+    /**
+     * Sets the status of the response.
+     *
+     * @param status the status to set.
+     */
+    BinaryMemcacheResponse setStatus(short status);
+
+    @Override
+    BinaryMemcacheResponse retain();
+
+    @Override
+    BinaryMemcacheResponse retain(int increment);
+
+    @Override
+    BinaryMemcacheResponse touch();
+
+    @Override
+    BinaryMemcacheResponse touch(Object hint);
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
new file mode 100644
index 000000000000..5c5d68b5763f
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+/**
+ * The decoder which takes care of decoding the response headers.
+ */
+public class BinaryMemcacheResponseDecoder
+    extends AbstractBinaryMemcacheDecoder<BinaryMemcacheResponse> {
+
+    public BinaryMemcacheResponseDecoder() {
+        this(DEFAULT_MAX_CHUNK_SIZE);
+    }
+
+    public BinaryMemcacheResponseDecoder(int chunkSize) {
+        super(chunkSize);
+    }
+
+    @Override
+    protected BinaryMemcacheResponse decodeHeader(ByteBuf in) {
+        BinaryMemcacheResponse header = new DefaultBinaryMemcacheResponse();
+        header.setMagic(in.readByte());
+        header.setOpcode(in.readByte());
+        header.setKeyLength(in.readShort());
+        header.setExtrasLength(in.readByte());
+        header.setDataType(in.readByte());
+        header.setStatus(in.readShort());
+        header.setTotalBodyLength(in.readInt());
+        header.setOpaque(in.readInt());
+        header.setCas(in.readLong());
+        return header;
+    }
+
+    @Override
+    protected BinaryMemcacheResponse buildInvalidMessage() {
+        return new DefaultBinaryMemcacheResponse("", Unpooled.EMPTY_BUFFER);
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java
new file mode 100644
index 000000000000..c9f2c506a8b4
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * The encoder which takes care of encoding the response headers.
+ */
+public class BinaryMemcacheResponseEncoder
+    extends AbstractBinaryMemcacheEncoder<BinaryMemcacheResponse> {
+
+    @Override
+    protected void encodeHeader(ByteBuf buf, BinaryMemcacheResponse msg) {
+        buf.writeByte(msg.magic());
+        buf.writeByte(msg.opcode());
+        buf.writeShort(msg.keyLength());
+        buf.writeByte(msg.extrasLength());
+        buf.writeByte(msg.dataType());
+        buf.writeShort(msg.status());
+        buf.writeInt(msg.totalBodyLength());
+        buf.writeInt(msg.opaque());
+        buf.writeLong(msg.cas());
+    }
+
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java
new file mode 100644
index 000000000000..f2599cee8a7d
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+/**
+ * Contains all possible status values a {@link BinaryMemcacheResponse} can return.
+ */
+public final class BinaryMemcacheResponseStatus {
+
+    private BinaryMemcacheResponseStatus() {
+        // disallow construction
+    }
+
+    public static final short SUCCESS = 0x00;
+    public static final short KEY_ENOENT = 0x01;
+    public static final short KEY_EEXISTS = 0x02;
+    public static final short E2BIG = 0x03;
+    public static final short EINVA = 0x04;
+    public static final short NOT_STORED = 0x05;
+    public static final short DELTA_BADVAL = 0x06;
+    public static final short AUTH_ERROR = 0x20;
+    public static final short AUTH_CONTINUE = 0x21;
+    public static final short UNKNOWN_COMMAND = 0x81;
+    public static final short ENOMEM = 0x82;
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java
new file mode 100644
index 000000000000..956690782733
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.channel.ChannelHandlerAppender;
+
+/**
+ * The full server codec that combines the correct encoder and decoder.
+ * <p/>
+ * Use this codec if you need to implement a server that speaks the memache binary protocol.
+ * Internally, it combines the {@link BinaryMemcacheRequestDecoder} and the
+ * {@link BinaryMemcacheResponseEncoder} to request decoding and response encoding.
+ */
+public class BinaryMemcacheServerCodec extends ChannelHandlerAppender {
+
+    public BinaryMemcacheServerCodec() {
+        this(AbstractBinaryMemcacheDecoder.DEFAULT_MAX_CHUNK_SIZE);
+    }
+
+    public BinaryMemcacheServerCodec(int decodeChunkSize) {
+        add(new BinaryMemcacheRequestDecoder(decodeChunkSize));
+        add(new BinaryMemcacheResponseEncoder());
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java
new file mode 100644
index 000000000000..dfa7843785d0
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * The default implementation of the {@link BinaryMemcacheRequest}.
+ */
+public class DefaultBinaryMemcacheRequest extends AbstractBinaryMemcacheMessage implements BinaryMemcacheRequest {
+
+    /**
+     * Default magic byte for a request.
+     */
+    public static final byte REQUEST_MAGIC_BYTE = (byte) 0x80;
+
+    private short reserved;
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheRequest} with the header only.
+     */
+    public DefaultBinaryMemcacheRequest() {
+        this(null, null);
+    }
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheRequest} with the header and key.
+     *
+     * @param key    the key to use.
+     */
+    public DefaultBinaryMemcacheRequest(String key) {
+        this(key, null);
+    }
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheRequest} with the header and extras.
+     *
+     * @param extras the extras to use.
+     */
+    public DefaultBinaryMemcacheRequest(ByteBuf extras) {
+        this(null, extras);
+    }
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheRequest} with the header only.
+     *
+     * @param key    the key to use.
+     * @param extras the extras to use.
+     */
+    public DefaultBinaryMemcacheRequest(String key, ByteBuf extras) {
+        super(key, extras);
+        setMagic(REQUEST_MAGIC_BYTE);
+    }
+
+    @Override
+    public short reserved() {
+        return reserved;
+    }
+
+    @Override
+    public BinaryMemcacheRequest setReserved(short reserved) {
+        this.reserved = reserved;
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheRequest retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheRequest retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheRequest touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheRequest touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java
new file mode 100644
index 000000000000..d449214f3b99
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * The default implementation of the {@link BinaryMemcacheResponse}.
+ */
+public class DefaultBinaryMemcacheResponse extends AbstractBinaryMemcacheMessage implements BinaryMemcacheResponse {
+
+    /**
+     * Default magic byte for a request.
+     */
+    public static final byte RESPONSE_MAGIC_BYTE = (byte) 0x81;
+
+    private short status;
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheResponse} with the header only.
+     */
+    public DefaultBinaryMemcacheResponse() {
+        this(null, null);
+    }
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheResponse} with the header and key.
+     *
+     * @param key    the key to use
+     */
+    public DefaultBinaryMemcacheResponse(String key) {
+        this(key, null);
+    }
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheResponse} with the header and extras.
+     *
+     * @param extras the extras to use.
+     */
+    public DefaultBinaryMemcacheResponse(ByteBuf extras) {
+        this(null, extras);
+    }
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheResponse} with the header, key and extras.
+     *
+     * @param key    the key to use.
+     * @param extras the extras to use.
+     */
+    public DefaultBinaryMemcacheResponse(String key, ByteBuf extras) {
+        super(key, extras);
+        setMagic(RESPONSE_MAGIC_BYTE);
+    }
+
+    @Override
+    public short status() {
+        return status;
+    }
+
+    @Override
+    public BinaryMemcacheResponse setStatus(short status) {
+        this.status = status;
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheResponse retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheResponse retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheResponse touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public BinaryMemcacheResponse touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java
new file mode 100644
index 000000000000..60f8c15b7f31
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+/**
+ * The default implementation of a {@link FullBinaryMemcacheRequest}.
+ */
+public class DefaultFullBinaryMemcacheRequest extends DefaultBinaryMemcacheRequest
+    implements FullBinaryMemcacheRequest {
+
+    private final ByteBuf content;
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheRequest} with the header, key and extras.
+     *
+     * @param key    the key to use.
+     * @param extras the extras to use.
+     */
+    public DefaultFullBinaryMemcacheRequest(String key, ByteBuf extras) {
+        this(key, extras, Unpooled.buffer(0));
+    }
+
+    /**
+     * Create a new {@link DefaultBinaryMemcacheRequest} with the header, key, extras and content.
+     *
+     * @param key     the key to use.
+     * @param extras  the extras to use.
+     * @param content the content of the full request.
+     */
+    public DefaultFullBinaryMemcacheRequest(String key, ByteBuf extras,
+                                            ByteBuf content) {
+        super(key, extras);
+        if (content == null) {
+            throw new NullPointerException("Supplied content is null.");
+        }
+
+        this.content = content;
+    }
+
+    @Override
+    public ByteBuf content() {
+        return content;
+    }
+
+    @Override
+    public int refCnt() {
+        return content.refCnt();
+    }
+
+    @Override
+    public FullBinaryMemcacheRequest retain() {
+        super.retain();
+        content.retain();
+        return this;
+    }
+
+    @Override
+    public FullBinaryMemcacheRequest retain(int increment) {
+        super.retain(increment);
+        content.retain(increment);
+        return this;
+    }
+
+    @Override
+    public FullBinaryMemcacheRequest touch() {
+        super.touch();
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public FullBinaryMemcacheRequest touch(Object hint) {
+        super.touch(hint);
+        content.touch(hint);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        super.release();
+        return content.release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        super.release(decrement);
+        return content.release(decrement);
+    }
+
+    @Override
+    public FullBinaryMemcacheRequest copy() {
+        ByteBuf extras = extras();
+        if (extras != null) {
+            extras = extras.copy();
+        }
+        return new DefaultFullBinaryMemcacheRequest(key(), extras, content().copy());
+    }
+
+    @Override
+    public FullBinaryMemcacheRequest duplicate() {
+        ByteBuf extras = extras();
+        if (extras != null) {
+            extras = extras.duplicate();
+        }
+        return new DefaultFullBinaryMemcacheRequest(key(), extras, content().duplicate());
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java
new file mode 100644
index 000000000000..8901b2fca292
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+
+/**
+ * The default implementation of a {@link FullBinaryMemcacheResponse}.
+ */
+public class DefaultFullBinaryMemcacheResponse extends DefaultBinaryMemcacheResponse
+    implements FullBinaryMemcacheResponse {
+
+    private final ByteBuf content;
+
+    /**
+     * Create a new {@link DefaultFullBinaryMemcacheResponse} with the header, key and extras.
+     *
+     * @param key    the key to use.
+     * @param extras the extras to use.
+     */
+    public DefaultFullBinaryMemcacheResponse(String key, ByteBuf extras) {
+        this(key, extras, Unpooled.buffer(0));
+    }
+
+    /**
+     * Create a new {@link DefaultFullBinaryMemcacheResponse} with the header, key, extras and content.
+     *
+     * @param key     the key to use.
+     * @param extras  the extras to use.
+     * @param content the content of the full request.
+     */
+    public DefaultFullBinaryMemcacheResponse(String key, ByteBuf extras,
+        ByteBuf content) {
+        super(key, extras);
+        if (content == null) {
+            throw new NullPointerException("Supplied content is null.");
+        }
+
+        this.content = content;
+    }
+
+    @Override
+    public ByteBuf content() {
+        return content;
+    }
+
+    @Override
+    public int refCnt() {
+        return content.refCnt();
+    }
+
+    @Override
+    public FullBinaryMemcacheResponse retain() {
+        super.retain();
+        content.retain();
+        return this;
+    }
+
+    @Override
+    public FullBinaryMemcacheResponse retain(int increment) {
+        super.retain(increment);
+        content.retain(increment);
+        return this;
+    }
+
+    @Override
+    public FullBinaryMemcacheResponse touch() {
+        super.touch();
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public FullBinaryMemcacheResponse touch(Object hint) {
+        super.touch(hint);
+        content.touch(hint);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        super.release();
+        return content.release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        super.release(decrement);
+        return content.release(decrement);
+    }
+
+    @Override
+    public FullBinaryMemcacheResponse copy() {
+        ByteBuf extras = extras();
+        if (extras != null) {
+            extras = extras.copy();
+        }
+        return new DefaultFullBinaryMemcacheResponse(key(), extras, content().copy());
+    }
+
+    @Override
+    public FullBinaryMemcacheResponse duplicate() {
+        ByteBuf extras = extras();
+        if (extras != null) {
+            extras = extras.duplicate();
+        }
+        return new DefaultFullBinaryMemcacheResponse(key(), extras, content().duplicate());
+    }
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java
new file mode 100644
index 000000000000..3fb26689117f
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.handler.codec.memcache.FullMemcacheMessage;
+
+/**
+ * A {@link BinaryMemcacheRequest} that also includes the content.
+ */
+public interface FullBinaryMemcacheRequest extends BinaryMemcacheRequest, FullMemcacheMessage {
+
+    @Override
+    FullBinaryMemcacheRequest copy();
+
+    @Override
+    FullBinaryMemcacheRequest retain(int increment);
+
+    @Override
+    FullBinaryMemcacheRequest retain();
+
+    @Override
+    FullBinaryMemcacheRequest touch();
+
+    @Override
+    FullBinaryMemcacheRequest touch(Object hint);
+
+    @Override
+    FullBinaryMemcacheRequest duplicate();
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java
new file mode 100644
index 000000000000..a4ff2376d6a0
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.handler.codec.memcache.FullMemcacheMessage;
+
+/**
+ * A {@link BinaryMemcacheResponse} that also includes the content.
+ */
+public interface FullBinaryMemcacheResponse extends BinaryMemcacheResponse, FullMemcacheMessage {
+
+    @Override
+    FullBinaryMemcacheResponse copy();
+
+    @Override
+    FullBinaryMemcacheResponse retain(int increment);
+
+    @Override
+    FullBinaryMemcacheResponse retain();
+
+    @Override
+    FullBinaryMemcacheResponse touch();
+
+    @Override
+    FullBinaryMemcacheResponse touch(Object hint);
+
+    @Override
+    FullBinaryMemcacheResponse duplicate();
+}
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java
new file mode 100644
index 000000000000..9b5491358e62
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Implementations and Interfaces for the Memcache Binary protocol.
+ */
+package io.netty.handler.codec.memcache.binary;
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java
new file mode 100644
index 000000000000..d04be91ce958
--- /dev/null
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Common superset of ascii and binary classes.
+ */
+package io.netty.handler.codec.memcache;
diff --git a/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java
new file mode 100644
index 000000000000..1a27f439520f
--- /dev/null
+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java
@@ -0,0 +1,251 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.memcache.LastMemcacheContent;
+import io.netty.handler.codec.memcache.MemcacheContent;
+import io.netty.util.CharsetUtil;
+import io.netty.util.ReferenceCounted;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.core.IsNull.notNullValue;
+import static org.hamcrest.core.IsNull.nullValue;
+
+/**
+ * Verifies the correct functionality of the {@link AbstractBinaryMemcacheDecoder}.
+ * <p/>
+ * While technically there are both a {@link BinaryMemcacheRequestDecoder} and a {@link BinaryMemcacheResponseDecoder}
+ * they implement the same basics and just differ in the type of headers returned.
+ */
+public class BinaryMemcacheDecoderTest {
+
+    /**
+     * Represents a GET request header with a key size of three.
+     */
+    private static final byte[] GET_REQUEST = {
+        (byte) 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f
+    };
+
+    private static final byte[] SET_REQUEST_WITH_CONTENT = {
+        (byte) 0x80, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6f, 0x6f, 0x01, 0x02, 0x03, 0x04, 0x05,
+        0x06, 0x07, 0x08
+    };
+
+    private static final byte[] GET_RESPONSE_CHUNK_1 =  {
+        (byte) 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x74, 0x20, 0x66, 0x6f, 0x75, 0x6e,
+        0x64, (byte) 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x74, 0x20, 0x66, 0x6f, 0x75,
+    };
+
+    private static final byte[] GET_RESPONSE_CHUNK_2 = {
+            0x6e, 0x64, (byte) 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x74, 0x20, 0x66, 0x6f,
+            0x75, 0x6e, 0x64
+    };
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(new BinaryMemcacheRequestDecoder());
+    }
+
+    @After
+    public void teardown() throws Exception {
+        channel.finish();
+    }
+
+    /**
+     * This tests a simple GET request with a key as the value.
+     */
+    @Test
+    public void shouldDecodeRequestWithSimpleValue() {
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(GET_REQUEST);
+        channel.writeInbound(incoming);
+
+        BinaryMemcacheRequest request = channel.readInbound();
+
+        assertThat(request, notNullValue());
+        assertThat(request.key(), notNullValue());
+        assertThat(request.extras(), nullValue());
+
+        assertThat(request.keyLength(), is((short) 3));
+        assertThat(request.extrasLength(), is((byte) 0));
+        assertThat(request.totalBodyLength(), is(3));
+
+        request.release();
+        assertThat(channel.readInbound(), instanceOf(LastMemcacheContent.class));
+    }
+
+    /**
+     * This test makes sure that large content is emitted in chunks.
+     */
+    @Test
+    public void shouldDecodeRequestWithChunkedContent() {
+        int smallBatchSize = 2;
+        channel = new EmbeddedChannel(new BinaryMemcacheRequestDecoder(smallBatchSize));
+
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(SET_REQUEST_WITH_CONTENT);
+        channel.writeInbound(incoming);
+
+        BinaryMemcacheRequest request = channel.readInbound();
+
+        assertThat(request, notNullValue());
+        assertThat(request.key(), notNullValue());
+        assertThat(request.extras(), nullValue());
+
+        assertThat(request.keyLength(), is((short) 3));
+        assertThat(request.extrasLength(), is((byte) 0));
+        assertThat(request.totalBodyLength(), is(11));
+
+        request.release();
+
+        int expectedContentChunks = 4;
+        for (int i = 1; i <= expectedContentChunks; i++) {
+            MemcacheContent content = channel.readInbound();
+            if (i < expectedContentChunks) {
+                assertThat(content, instanceOf(MemcacheContent.class));
+            } else {
+                assertThat(content, instanceOf(LastMemcacheContent.class));
+            }
+            assertThat(content.content().readableBytes(), is(2));
+            content.release();
+        }
+        assertThat(channel.readInbound(), nullValue());
+    }
+
+    /**
+     * This test makes sure that even when the decoder is confronted with various chunk
+     * sizes in the middle of decoding, it can recover and decode all the time eventually.
+     */
+    @Test
+    public void shouldHandleNonUniformNetworkBatches() {
+        ByteBuf incoming = Unpooled.copiedBuffer(SET_REQUEST_WITH_CONTENT);
+        while (incoming.isReadable()) {
+            channel.writeInbound(incoming.readBytes(5));
+        }
+
+        BinaryMemcacheRequest request = channel.readInbound();
+
+        assertThat(request, notNullValue());
+        assertThat(request.key(), notNullValue());
+        assertThat(request.extras(), nullValue());
+
+        request.release();
+
+        MemcacheContent content1 = channel.readInbound();
+        MemcacheContent content2 = channel.readInbound();
+
+        assertThat(content1, instanceOf(MemcacheContent.class));
+        assertThat(content2, instanceOf(LastMemcacheContent.class));
+
+        assertThat(content1.content().readableBytes(), is(3));
+        assertThat(content2.content().readableBytes(), is(5));
+
+        content1.release();
+        content2.release();
+    }
+
+    /**
+     * This test makes sure that even when more requests arrive in the same batch, they
+     * get emitted as separate messages.
+     */
+    @Test
+    public void shouldHandleTwoMessagesInOneBatch() {
+        channel.writeInbound(Unpooled.buffer().writeBytes(GET_REQUEST).writeBytes(GET_REQUEST));
+
+        BinaryMemcacheRequest request = channel.readInbound();
+        assertThat(request, instanceOf(BinaryMemcacheRequest.class));
+        assertThat(request, notNullValue());
+        request.release();
+
+        Object lastContent = channel.readInbound();
+        assertThat(lastContent, instanceOf(LastMemcacheContent.class));
+        ((ReferenceCounted) lastContent).release();
+
+        request = channel.readInbound();
+        assertThat(request, instanceOf(BinaryMemcacheRequest.class));
+        assertThat(request, notNullValue());
+        request.release();
+
+        lastContent = channel.readInbound();
+        assertThat(lastContent, instanceOf(LastMemcacheContent.class));
+        ((ReferenceCounted) lastContent).release();
+    }
+
+    @Test
+    public void shouldDecodeSeparatedValues() {
+        String msgBody = "Not found";
+        channel = new EmbeddedChannel(new BinaryMemcacheResponseDecoder());
+
+        channel.writeInbound(Unpooled.buffer().writeBytes(GET_RESPONSE_CHUNK_1));
+        channel.writeInbound(Unpooled.buffer().writeBytes(GET_RESPONSE_CHUNK_2));
+
+        // First message
+        BinaryMemcacheResponse response = channel.readInbound();
+        assertThat(response.status(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));
+        assertThat(response.totalBodyLength(), is(msgBody.length()));
+        response.release();
+
+        // First message first content chunk
+        MemcacheContent content = channel.readInbound();
+        assertThat(content, instanceOf(LastMemcacheContent.class));
+        assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody));
+        content.release();
+
+        // Second message
+        response = channel.readInbound();
+        assertThat(response.status(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));
+        assertThat(response.totalBodyLength(), is(msgBody.length()));
+        response.release();
+
+        // Second message first content chunk
+        content = channel.readInbound();
+        assertThat(content, instanceOf(MemcacheContent.class));
+        assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody.substring(0, 7)));
+        content.release();
+
+        // Second message second content chunk
+        content = channel.readInbound();
+        assertThat(content, instanceOf(LastMemcacheContent.class));
+        assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody.substring(7, 9)));
+        content.release();
+
+        // Third message
+        response = channel.readInbound();
+        assertThat(response.status(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));
+        assertThat(response.totalBodyLength(), is(msgBody.length()));
+        response.release();
+
+        // Third message first content chunk
+        content = channel.readInbound();
+        assertThat(content, instanceOf(LastMemcacheContent.class));
+        assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody));
+        content.release();
+    }
+}
diff --git a/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java
new file mode 100644
index 000000000000..cb255f6943ad
--- /dev/null
+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.EncoderException;
+import io.netty.handler.codec.memcache.DefaultLastMemcacheContent;
+import io.netty.handler.codec.memcache.DefaultMemcacheContent;
+import io.netty.util.CharsetUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.core.IsEqual.equalTo;
+import static org.junit.Assert.*;
+
+/**
+ * Verifies the correct functionality of the {@link AbstractBinaryMemcacheEncoder}.
+ */
+public class BinaryMemcacheEncoderTest {
+
+    public static final int DEFAULT_HEADER_SIZE = 24;
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(new BinaryMemcacheRequestEncoder());
+    }
+
+    @After
+    public void teardown() throws Exception {
+        channel.finish();
+    }
+
+    @Test
+    public void shouldEncodeDefaultHeader() {
+        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest();
+
+        boolean result = channel.writeOutbound(request);
+        assertThat(result, is(true));
+
+        ByteBuf written = channel.readOutbound();
+        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE));
+        assertThat(written.readByte(), is((byte) 0x80));
+        assertThat(written.readByte(), is((byte) 0x00));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeCustomHeader() {
+        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest();
+        request.setMagic((byte) 0xAA);
+        request.setOpcode(BinaryMemcacheOpcodes.GET);
+
+        boolean result = channel.writeOutbound(request);
+        assertThat(result, is(true));
+
+        ByteBuf written = channel.readOutbound();
+        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE));
+        assertThat(written.readByte(), is((byte) 0xAA));
+        assertThat(written.readByte(), is(BinaryMemcacheOpcodes.GET));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeExtras() {
+        String extrasContent = "netty<3memcache";
+        ByteBuf extras = Unpooled.copiedBuffer(extrasContent, CharsetUtil.UTF_8);
+        int extrasLength = extras.readableBytes();
+
+        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(extras);
+        request.setExtrasLength((byte) extrasLength);
+
+        boolean result = channel.writeOutbound(request);
+        assertThat(result, is(true));
+
+        ByteBuf written = channel.readOutbound();
+        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE + extrasLength));
+        written.readBytes(DEFAULT_HEADER_SIZE);
+        assertThat(written.readBytes(extrasLength).toString(CharsetUtil.UTF_8), equalTo(extrasContent));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeKey() {
+        String key = "netty";
+        int keyLength = key.length();
+
+        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key);
+        request.setKeyLength((byte) keyLength);
+
+        boolean result = channel.writeOutbound(request);
+        assertThat(result, is(true));
+
+        ByteBuf written = channel.readOutbound();
+        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE + keyLength));
+        written.readBytes(DEFAULT_HEADER_SIZE);
+        assertThat(written.readBytes(keyLength).toString(CharsetUtil.UTF_8), equalTo(key));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeContent() {
+        DefaultMemcacheContent content1 =
+            new DefaultMemcacheContent(Unpooled.copiedBuffer("Netty", CharsetUtil.UTF_8));
+        DefaultLastMemcacheContent content2 =
+            new DefaultLastMemcacheContent(Unpooled.copiedBuffer(" Rocks!", CharsetUtil.UTF_8));
+        int totalBodyLength = content1.content().readableBytes() + content2.content().readableBytes();
+
+        BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest();
+        request.setTotalBodyLength(totalBodyLength);
+
+        boolean result = channel.writeOutbound(request);
+        assertThat(result, is(true));
+        result = channel.writeOutbound(content1);
+        assertThat(result, is(true));
+        result = channel.writeOutbound(content2);
+        assertThat(result, is(true));
+
+        ByteBuf written = channel.readOutbound();
+        assertThat(written.readableBytes(), is(DEFAULT_HEADER_SIZE));
+        written = channel.readOutbound();
+        assertThat(written.readableBytes(), is(content1.content().readableBytes()));
+        assertThat(
+                written.readBytes(content1.content().readableBytes()).toString(CharsetUtil.UTF_8),
+                is("Netty")
+        );
+        written.release();
+
+        written = channel.readOutbound();
+        assertThat(written.readableBytes(), is(content2.content().readableBytes()));
+        assertThat(
+                written.readBytes(content2.content().readableBytes()).toString(CharsetUtil.UTF_8),
+                is(" Rocks!")
+        );
+        written.release();
+    }
+
+    @Test(expected = EncoderException.class)
+    public void shouldFailWithoutLastContent() {
+        channel.writeOutbound(new DefaultMemcacheContent(Unpooled.EMPTY_BUFFER));
+        channel.writeOutbound(new DefaultBinaryMemcacheRequest());
+    }
+}
diff --git a/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
new file mode 100644
index 000000000000..e291d61c3e61
--- /dev/null
+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.MatcherAssert.*;
+import static org.hamcrest.core.IsNull.notNullValue;
+import static org.hamcrest.core.IsNull.nullValue;
+
+/**
+ * Verifies the correct functionality of the {@link BinaryMemcacheObjectAggregator}.
+ */
+public class BinaryMemcacheObjectAggregatorTest {
+
+    private static final byte[] SET_REQUEST_WITH_CONTENT = {
+        (byte) 0x80, 0x01, 0x00, 0x03,
+        0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x0B,
+        0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00,
+        0x66, 0x6f, 0x6f,
+        0x01, 0x02, 0x03, 0x04,
+        0x05, 0x06, 0x07, 0x08
+    };
+
+    public static final int MAX_CONTENT_SIZE = 2 << 10;
+
+    private EmbeddedChannel channel;
+
+    @Test
+    public void shouldAggregateChunksOnDecode() {
+        int smallBatchSize = 2;
+        channel = new EmbeddedChannel(
+            new BinaryMemcacheRequestDecoder(smallBatchSize),
+            new BinaryMemcacheObjectAggregator(MAX_CONTENT_SIZE));
+
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(SET_REQUEST_WITH_CONTENT);
+        channel.writeInbound(incoming);
+
+        FullBinaryMemcacheRequest request = channel.readInbound();
+
+        assertThat(request, instanceOf(FullBinaryMemcacheRequest.class));
+        assertThat(request, notNullValue());
+        assertThat(request.key(), notNullValue());
+        assertThat(request.extras(), nullValue());
+
+        assertThat(request.content().readableBytes(), is(8));
+        assertThat(request.content().readByte(), is((byte) 0x01));
+        assertThat(request.content().readByte(), is((byte) 0x02));
+        request.release();
+
+        assertThat(channel.readInbound(), nullValue());
+
+        channel.finish();
+    }
+}
diff --git a/codec-mqtt/pom.xml b/codec-mqtt/pom.xml
new file mode 100644
index 000000000000..4ea3b0f58a79
--- /dev/null
+++ b/codec-mqtt/pom.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2014 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>io.netty</groupId>
+    <artifactId>netty-parent</artifactId>
+    <version>4.1.0.Beta1</version>
+  </parent>
+
+  <artifactId>netty-codec-mqtt</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Netty/Codec/MQTT</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-all</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java
new file mode 100644
index 000000000000..679a18df6755
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.handler.codec.DecoderException;
+
+final class MqttCodecUtil {
+
+    private static final char[] TOPIC_WILDCARDS = {'#', '+'};
+    private static final int MAX_CLIENT_ID_LENGTH = 23;
+
+    static boolean isValidPublishTopicName(String topicName) {
+        // publish topic name must not contain any wildcard
+        for (char c : TOPIC_WILDCARDS) {
+            if (topicName.indexOf(c) >= 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    static boolean isValidMessageId(int messageId) {
+        return messageId != 0;
+    }
+
+    static boolean isValidClientId(String clientId) {
+        return clientId != null && clientId.length() <= MAX_CLIENT_ID_LENGTH;
+    }
+
+    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader) {
+        switch (mqttFixedHeader.messageType()) {
+            case PUBREL:
+            case SUBSCRIBE:
+            case UNSUBSCRIBE:
+                if (mqttFixedHeader.qosLevel() != MqttQoS.AT_LEAST_ONCE) {
+                    throw new DecoderException(mqttFixedHeader.messageType().name() + " message must have QoS 1");
+                }
+            default:
+                return mqttFixedHeader;
+        }
+    }
+
+    static MqttFixedHeader resetUnusedFields(MqttFixedHeader mqttFixedHeader) {
+        switch (mqttFixedHeader.messageType()) {
+            case CONNECT:
+            case CONNACK:
+            case PUBACK:
+            case PUBREC:
+            case PUBCOMP:
+            case SUBACK:
+            case UNSUBACK:
+            case PINGREQ:
+            case PINGRESP:
+            case DISCONNECT:
+                if (mqttFixedHeader.isDup() ||
+                        mqttFixedHeader.qosLevel() != MqttQoS.AT_MOST_ONCE ||
+                        mqttFixedHeader.isRetain()) {
+                    return new MqttFixedHeader(
+                            mqttFixedHeader.messageType(),
+                            false,
+                            MqttQoS.AT_MOST_ONCE,
+                            false,
+                            mqttFixedHeader.remainingLength());
+                }
+                return mqttFixedHeader;
+            case PUBREL:
+            case SUBSCRIBE:
+            case UNSUBSCRIBE:
+                if (mqttFixedHeader.isRetain()) {
+                    return new MqttFixedHeader(
+                            mqttFixedHeader.messageType(),
+                            mqttFixedHeader.isDup(),
+                            mqttFixedHeader.qosLevel(),
+                            false,
+                            mqttFixedHeader.remainingLength());
+                }
+                return mqttFixedHeader;
+            default:
+                return mqttFixedHeader;
+        }
+    }
+
+    private MqttCodecUtil() { }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckMessage.java
new file mode 100644
index 000000000000..2654b8e0efbf
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckMessage.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#connack">MQTTV3.1/connack</a>
+ */
+public final class MqttConnAckMessage extends MqttMessage {
+
+    public MqttConnAckMessage(MqttFixedHeader mqttFixedHeader, MqttConnAckVariableHeader variableHeader) {
+        super(mqttFixedHeader, variableHeader);
+    }
+
+    @Override
+    public MqttConnAckVariableHeader variableHeader() {
+        return (MqttConnAckVariableHeader) super.variableHeader();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java
new file mode 100644
index 000000000000..1ef1f29e28c9
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+/**
+ * Variable header of {@link MqttConnectMessage}
+ */
+public class MqttConnAckVariableHeader {
+
+    private final MqttConnectReturnCode connectReturnCode;
+
+    public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode) {
+        this.connectReturnCode = connectReturnCode;
+    }
+
+    public MqttConnectReturnCode connectReturnCode() {
+        return connectReturnCode;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("connectReturnCode=").append(connectReturnCode);
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectMessage.java
new file mode 100644
index 000000000000..ffc42b5d61de
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectMessage.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#connect">MQTTV3.1/connect</a>
+ */
+public final class MqttConnectMessage extends MqttMessage {
+
+    public MqttConnectMessage(
+            MqttFixedHeader mqttFixedHeader,
+            MqttConnectVariableHeader variableHeader,
+            MqttConnectPayload payload) {
+        super(mqttFixedHeader, variableHeader, payload);
+    }
+
+    @Override
+    public MqttConnectVariableHeader variableHeader() {
+        return (MqttConnectVariableHeader) super.variableHeader();
+    }
+
+    @Override
+    public MqttConnectPayload payload() {
+        return (MqttConnectPayload) super.payload();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java
new file mode 100644
index 000000000000..a2a70af67e03
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+/**
+ * Payload of {@link MqttConnectMessage}
+ */
+public class MqttConnectPayload {
+
+    private final String clientIdentifier;
+    private final String willTopic;
+    private final String willMessage;
+    private final String userName;
+    private final String password;
+
+    public MqttConnectPayload(
+            String clientIdentifier,
+            String willTopic,
+            String willMessage,
+            String userName,
+            String password) {
+        this.clientIdentifier = clientIdentifier;
+        this.willTopic = willTopic;
+        this.willMessage = willMessage;
+        this.userName = userName;
+        this.password = password;
+    }
+
+    public String clientIdentifier() {
+        return clientIdentifier;
+    }
+
+    public String willTopic() {
+        return willTopic;
+    }
+
+    public String willMessage() {
+        return willMessage;
+    }
+
+    public String userName() {
+        return userName;
+    }
+
+    public String password() {
+        return password;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("clientIdentifier=").append(clientIdentifier);
+        builder.append(", willTopic=").append(willTopic);
+        builder.append(", willMessage=").append(willMessage);
+        builder.append(", userName=").append(userName);
+        builder.append(", password=").append(password);
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java
new file mode 100644
index 000000000000..bf43377bed85
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Return Code of {@link io.netty.handler.codec.mqtt.MqttConnAckMessage}
+ */
+public enum MqttConnectReturnCode {
+    CONNECTION_ACCEPTED((byte) 0x00),
+    CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION((byte) 0X01),
+    CONNECTION_REFUSED_IDENTIFIER_REJECTED((byte) 0x02),
+    CONNECTION_REFUSED_SERVER_UNAVAILABLE((byte) 0x03),
+    CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD((byte) 0x04),
+    CONNECTION_REFUSED_NOT_AUTHORIZED((byte) 0x05);
+
+    private  static final Map<Byte, MqttConnectReturnCode> valueToCodeMap;
+
+    static {
+        final Map<Byte, MqttConnectReturnCode> valueMap = new HashMap<Byte, MqttConnectReturnCode>();
+        for (MqttConnectReturnCode code: values()) {
+            valueMap.put(code.byteValue, code);
+        }
+        valueToCodeMap = Collections.unmodifiableMap(valueMap);
+    }
+
+    private final byte byteValue;
+
+    MqttConnectReturnCode(byte byteValue) {
+        this.byteValue = byteValue;
+    }
+
+    public byte byteValue() {
+        return byteValue;
+    }
+
+    public static MqttConnectReturnCode valueOf(byte b) {
+        if (valueToCodeMap.containsKey(b)) {
+            return valueToCodeMap.get(b);
+        }
+        throw new IllegalArgumentException("unknown connect return code: " + (b & 0xFF));
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java
new file mode 100644
index 000000000000..3e0266e7d05f
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+/**
+ * Variable Header for the {@link MqttConnectMessage}
+ */
+public class MqttConnectVariableHeader {
+
+    private final String name;
+    private final int version;
+    private final boolean hasUserName;
+    private final boolean hasPassword;
+    private final boolean isWillRetain;
+    private final int willQos;
+    private final boolean isWillFlag;
+    private final boolean isCleanSession;
+    private final int keepAliveTimeSeconds;
+
+    public MqttConnectVariableHeader(
+            String name,
+            int version,
+            boolean hasUserName,
+            boolean hasPassword,
+            boolean isWillRetain,
+            int willQos,
+            boolean isWillFlag,
+            boolean isCleanSession,
+            int keepAliveTimeSeconds) {
+        this.name = name;
+        this.version = version;
+        this.hasUserName = hasUserName;
+        this.hasPassword = hasPassword;
+        this.isWillRetain = isWillRetain;
+        this.willQos = willQos;
+        this.isWillFlag = isWillFlag;
+        this.isCleanSession = isCleanSession;
+        this.keepAliveTimeSeconds = keepAliveTimeSeconds;
+    }
+
+    public String name() {
+        return name;
+    }
+
+    public int version() {
+        return version;
+    }
+
+    public boolean hasUserName() {
+        return hasUserName;
+    }
+
+    public boolean hasPassword() {
+        return hasPassword;
+    }
+
+    public boolean isWillRetain() {
+        return isWillRetain;
+    }
+
+    public int willQos() {
+        return willQos;
+    }
+
+    public boolean isWillFlag() {
+        return isWillFlag;
+    }
+
+    public boolean isCleanSession() {
+        return isCleanSession;
+    }
+
+    public int keepAliveTimeSeconds() {
+        return keepAliveTimeSeconds;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("name=").append(name);
+        builder.append(", version=").append(version);
+        builder.append(", hasUserName=").append(hasUserName);
+        builder.append(", hasPassword=").append(hasPassword);
+        builder.append(", isWillRetain=").append(isWillRetain);
+        builder.append(", isWillFlag=").append(isWillFlag);
+        builder.append(", isCleanSession=").append(isCleanSession);
+        builder.append(", keepAliveTimeSeconds=").append(keepAliveTimeSeconds);
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
new file mode 100644
index 000000000000..3013393645f7
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
@@ -0,0 +1,460 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.DecoderException;
+import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.mqtt.MqttDecoder.DecoderState;
+import io.netty.util.CharsetUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static io.netty.handler.codec.mqtt.MqttCodecUtil.*;
+import static io.netty.handler.codec.mqtt.MqttVersion.*;
+
+/**
+ * Decodes Mqtt messages from bytes, following
+ * <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html">
+ *     the MQTT protocl specification v3.1</a>
+ */
+public class MqttDecoder extends ReplayingDecoder<DecoderState> {
+
+    private static final int DEFAULT_MAX_BYTES_IN_MESSAGE = 8092;
+
+    /**
+     * States of the decoder.
+     * We start at READ_FIXED_HEADER, followed by
+     * READ_VARIABLE_HEADER and finally READ_PAYLOAD.
+     */
+    enum DecoderState {
+        READ_FIXED_HEADER,
+        READ_VARIABLE_HEADER,
+        READ_PAYLOAD,
+        BAD_MESSAGE,
+    }
+
+    private MqttFixedHeader mqttFixedHeader;
+    private Object variableHeader;
+    private Object payload;
+    private int bytesRemainingInVariablePart;
+
+    private final int maxBytesInMessage;
+
+    public MqttDecoder() {
+      this(DEFAULT_MAX_BYTES_IN_MESSAGE);
+    }
+
+    public MqttDecoder(int maxBytesInMessage) {
+        super(DecoderState.READ_FIXED_HEADER);
+        this.maxBytesInMessage = maxBytesInMessage;
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {
+        switch (state()) {
+            case READ_FIXED_HEADER:
+                mqttFixedHeader = decodeFixedHeader(buffer);
+                bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();
+                checkpoint(DecoderState.READ_VARIABLE_HEADER);
+                // fall through
+
+            case READ_VARIABLE_HEADER:  try {
+                if (bytesRemainingInVariablePart > maxBytesInMessage) {
+                    throw new DecoderException("too large message: " + bytesRemainingInVariablePart + " bytes");
+                }
+                final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);
+                variableHeader = decodedVariableHeader.value;
+                bytesRemainingInVariablePart -= decodedVariableHeader.numberOfBytesConsumed;
+                checkpoint(DecoderState.READ_PAYLOAD);
+                // fall through
+            } catch (Exception cause) {
+                out.add(invalidMessage(cause));
+                return;
+            }
+
+            case READ_PAYLOAD: try {
+                final Result<?> decodedPayload =
+                        decodePayload(
+                                buffer,
+                                mqttFixedHeader.messageType(),
+                                bytesRemainingInVariablePart,
+                                variableHeader);
+                payload = decodedPayload.value;
+                bytesRemainingInVariablePart -= decodedPayload.numberOfBytesConsumed;
+                if (bytesRemainingInVariablePart != 0) {
+                    throw new DecoderException(
+                            "non-zero remaining payload bytes: " +
+                                    bytesRemainingInVariablePart + " (" + mqttFixedHeader.messageType() + ')');
+                }
+                checkpoint(DecoderState.READ_FIXED_HEADER);
+                MqttMessage message = MqttMessageFactory.newMessage(mqttFixedHeader, variableHeader, payload);
+                mqttFixedHeader = null;
+                variableHeader = null;
+                payload = null;
+                out.add(message);
+                break;
+            } catch (Exception cause) {
+                out.add(invalidMessage(cause));
+                return;
+            }
+
+            case BAD_MESSAGE:
+                // Keep discarding until disconnection.
+                buffer.skipBytes(actualReadableBytes());
+                break;
+
+            default:
+                // Shouldn't reach here.
+                throw new Error();
+        }
+    }
+
+    private MqttMessage invalidMessage(Throwable cause) {
+      checkpoint(DecoderState.BAD_MESSAGE);
+      return MqttMessageFactory.newInvalidMessage(cause);
+    }
+
+    /**
+     * Decodes the fixed header. It's one byte for the flags and then variable bytes for the remaining length.
+     *
+     * @param buffer the buffer to decode from
+     * @return the fixed header
+     */
+    private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {
+        short b1 = buffer.readUnsignedByte();
+
+        MqttMessageType messageType = MqttMessageType.valueOf(b1 >> 4);
+        boolean dupFlag = (b1 & 0x08) == 0x08;
+        int qosLevel = (b1 & 0x06) >> 1;
+        boolean retain = (b1 & 0x01) != 0;
+
+        int remainingLength = 0;
+        int multiplier = 1;
+        short digit;
+        int loops = 0;
+        do {
+            digit = buffer.readUnsignedByte();
+            remainingLength += (digit & 127) * multiplier;
+            multiplier *= 128;
+            loops++;
+        } while ((digit & 128) != 0 && loops < 4);
+
+        // MQTT protocol limits Remaining Length to 4 bytes
+        if (loops == 4 && (digit & 128) != 0) {
+            throw new DecoderException("remaining length exceeds 4 digits (" + messageType + ')');
+        }
+        MqttFixedHeader decodedFixedHeader =
+                new MqttFixedHeader(messageType, dupFlag, MqttQoS.valueOf(qosLevel), retain, remainingLength);
+        return validateFixedHeader(resetUnusedFields(decodedFixedHeader));
+    }
+
+    /**
+     * Decodes the variable header (if any)
+     * @param buffer the buffer to decode from
+     * @param mqttFixedHeader MqttFixedHeader of the same message
+     * @return the variable header
+     */
+    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {
+        switch (mqttFixedHeader.messageType()) {
+            case CONNECT:
+                return decodeConnectionVariableHeader(buffer);
+
+            case CONNACK:
+                return decodeConnAckVariableHeader(buffer);
+
+            case SUBSCRIBE:
+            case UNSUBSCRIBE:
+            case SUBACK:
+            case UNSUBACK:
+            case PUBACK:
+            case PUBREC:
+            case PUBCOMP:
+            case PUBREL:
+                return decodeMessageIdVariableHeader(buffer);
+
+            case PUBLISH:
+                return decodePublishVariableHeader(buffer, mqttFixedHeader);
+
+            case PINGREQ:
+            case PINGRESP:
+            case DISCONNECT:
+                // Empty variable header
+                return new Result<Object>(null, 0);
+        }
+        return new Result<Object>(null, 0); //should never reach here
+    }
+
+    private static Result<MqttConnectVariableHeader> decodeConnectionVariableHeader(ByteBuf buffer) {
+        final Result<String> protoString = decodeString(buffer);
+        if (!PROTOCOL_NAME.equals(protoString.value)) {
+            throw new DecoderException("missing " + PROTOCOL_NAME + " signature");
+        }
+
+        int numberOfBytesConsumed = protoString.numberOfBytesConsumed;
+
+        final byte version = buffer.readByte();
+        final int b1 = buffer.readUnsignedByte();
+        numberOfBytesConsumed += 2;
+
+        final Result<Integer> keepAlive = decodeMsbLsb(buffer);
+        numberOfBytesConsumed += keepAlive.numberOfBytesConsumed;
+
+        final boolean hasUserName = (b1 & 0x80) == 0x80;
+        final boolean hasPassword = (b1 & 0x40) == 0x40;
+        final boolean willRetain = (b1 & 0x20) == 0x20;
+        final int willQos = (b1 & 0x18) >> 3;
+        final boolean willFlag = (b1 & 0x04) == 0x04;
+        final boolean cleanSession = (b1 & 0x02) == 0x02;
+
+        final MqttConnectVariableHeader mqttConnectVariableHeader = new MqttConnectVariableHeader(
+                PROTOCOL_NAME,
+                version,
+                hasUserName,
+                hasPassword,
+                willRetain,
+                willQos,
+                willFlag,
+                cleanSession,
+                keepAlive.value);
+        return new Result<MqttConnectVariableHeader>(mqttConnectVariableHeader, numberOfBytesConsumed);
+    }
+
+    private static Result<MqttConnAckVariableHeader> decodeConnAckVariableHeader(ByteBuf buffer) {
+        buffer.readUnsignedByte(); // reserved byte
+        byte returnCode = buffer.readByte();
+        final int numberOfBytesConsumed = 2;
+        final MqttConnAckVariableHeader mqttConnAckVariableHeader =
+                new MqttConnAckVariableHeader(MqttConnectReturnCode.valueOf(returnCode));
+        return new Result<MqttConnAckVariableHeader>(mqttConnAckVariableHeader, numberOfBytesConsumed);
+    }
+
+    private static Result<MqttMessageIdVariableHeader> decodeMessageIdVariableHeader(ByteBuf buffer) {
+        final Result<Integer> messageId = decodeMessageId(buffer);
+        return new Result<MqttMessageIdVariableHeader>(
+                MqttMessageIdVariableHeader.from(messageId.value),
+                messageId.numberOfBytesConsumed);
+    }
+
+    private static Result<MqttPublishVariableHeader> decodePublishVariableHeader(
+            ByteBuf buffer,
+            MqttFixedHeader mqttFixedHeader) {
+        final Result<String> decodedTopic = decodeString(buffer);
+        if (!isValidPublishTopicName(decodedTopic.value)) {
+            throw new DecoderException("invalid publish topic name: " + decodedTopic.value + " (contains wildcards)");
+        }
+        int numberOfBytesConsumed = decodedTopic.numberOfBytesConsumed;
+
+        int messageId = -1;
+        if (mqttFixedHeader.qosLevel().value() > 0) {
+            final Result<Integer> decodedMessageId = decodeMessageId(buffer);
+            messageId = decodedMessageId.value;
+            numberOfBytesConsumed += decodedMessageId.numberOfBytesConsumed;
+        }
+        final MqttPublishVariableHeader mqttPublishVariableHeader =
+                new MqttPublishVariableHeader(decodedTopic.value, messageId);
+        return new Result<MqttPublishVariableHeader>(mqttPublishVariableHeader, numberOfBytesConsumed);
+    }
+
+    private static Result<Integer> decodeMessageId(ByteBuf buffer) {
+        final Result<Integer> messageId = decodeMsbLsb(buffer);
+        if (!isValidMessageId(messageId.value)) {
+            throw new DecoderException("invalid messageId: " + messageId.value);
+        }
+        return messageId;
+    }
+
+    /**
+     * Decodes the payload.
+     *
+     * @param buffer the buffer to decode from
+     * @param messageType  type of the message being decoded
+     * @param bytesRemainingInVariablePart bytes remaining
+     * @param variableHeader variable header of the same message
+     * @return the payload
+     */
+    private static Result<?> decodePayload(
+            ByteBuf buffer,
+            MqttMessageType messageType,
+            int bytesRemainingInVariablePart,
+            Object variableHeader) {
+        switch (messageType) {
+            case CONNECT:
+                return decodeConnectionPayload(buffer, (MqttConnectVariableHeader) variableHeader);
+
+            case SUBSCRIBE:
+                return decodeSubscribePayload(buffer, bytesRemainingInVariablePart);
+
+            case SUBACK:
+                return decodeSubackPayload(buffer, bytesRemainingInVariablePart);
+
+            case UNSUBSCRIBE:
+                return decodeUnsubscribePayload(buffer, bytesRemainingInVariablePart);
+
+            case PUBLISH:
+                return decodePublishPayload(buffer, bytesRemainingInVariablePart);
+
+            default:
+                // unknown payload , no byte consumed
+                return new Result<Object>(null, 0);
+        }
+    }
+
+    private static Result<MqttConnectPayload> decodeConnectionPayload(
+            ByteBuf buffer,
+            MqttConnectVariableHeader mqttConnectVariableHeader) {
+        final Result<String> decodedClientId = decodeString(buffer);
+        final String decodedClientIdValue = decodedClientId.value;
+        if (!isValidClientId(decodedClientIdValue)) {
+            throw new DecoderException("invalid clientIdentifier: " + decodedClientIdValue);
+        }
+        int numberOfBytesConsumed = decodedClientId.numberOfBytesConsumed;
+
+        Result<String> decodedWillTopic = null;
+        Result<String> decodedWillMessage = null;
+        if (mqttConnectVariableHeader.isWillFlag()) {
+            decodedWillTopic = decodeString(buffer, 0, 32767);
+            numberOfBytesConsumed += decodedWillTopic.numberOfBytesConsumed;
+            decodedWillMessage = decodeAsciiString(buffer);
+            numberOfBytesConsumed += decodedWillMessage.numberOfBytesConsumed;
+        }
+        Result<String> decodedUserName = null;
+        Result<String> decodedPassword = null;
+        if (mqttConnectVariableHeader.hasUserName()) {
+            decodedUserName = decodeString(buffer);
+            numberOfBytesConsumed += decodedUserName.numberOfBytesConsumed;
+        }
+        if (mqttConnectVariableHeader.hasPassword()) {
+            decodedPassword = decodeString(buffer);
+            numberOfBytesConsumed += decodedPassword.numberOfBytesConsumed;
+        }
+
+        final MqttConnectPayload mqttConnectPayload =
+                new MqttConnectPayload(
+                        decodedClientId.value,
+                        decodedWillTopic.value,
+                        decodedWillMessage.value,
+                        decodedUserName.value,
+                        decodedPassword.value);
+        return new Result<MqttConnectPayload>(mqttConnectPayload, numberOfBytesConsumed);
+    }
+
+    private static Result<MqttSubscribePayload> decodeSubscribePayload(
+            ByteBuf buffer,
+            int bytesRemainingInVariablePart) {
+        final List<MqttTopicSubscription> subscribeTopics = new ArrayList<MqttTopicSubscription>();
+        int numberOfBytesConsumed = 0;
+        while (numberOfBytesConsumed < bytesRemainingInVariablePart) {
+            final Result<String> decodedTopicName = decodeString(buffer);
+            numberOfBytesConsumed += decodedTopicName.numberOfBytesConsumed;
+            int qos = buffer.readUnsignedByte() & 0x03;
+            numberOfBytesConsumed++;
+            subscribeTopics.add(new MqttTopicSubscription(decodedTopicName.value, MqttQoS.valueOf(qos)));
+        }
+        return new Result<MqttSubscribePayload>(new MqttSubscribePayload(subscribeTopics), numberOfBytesConsumed);
+    }
+
+    private static Result<MqttSubAckPayload> decodeSubackPayload(
+            ByteBuf buffer,
+            int bytesRemainingInVariablePart) {
+        final List<Integer> grantedQos = new ArrayList<Integer>();
+        int numberOfBytesConsumed = 0;
+        while (numberOfBytesConsumed < bytesRemainingInVariablePart) {
+            int qos = buffer.readUnsignedByte() & 0x03;
+            numberOfBytesConsumed++;
+            grantedQos.add(qos);
+        }
+        return new Result<MqttSubAckPayload>(new MqttSubAckPayload(grantedQos), numberOfBytesConsumed);
+    }
+
+    private static Result<MqttUnsubscribePayload> decodeUnsubscribePayload(
+            ByteBuf buffer,
+            int bytesRemainingInVariablePart) {
+        final List<String> unsubscribeTopics = new ArrayList<String>();
+        int numberOfBytesConsumed = 0;
+        while (numberOfBytesConsumed < bytesRemainingInVariablePart) {
+            final Result<String> decodedTopicName = decodeString(buffer);
+            numberOfBytesConsumed += decodedTopicName.numberOfBytesConsumed;
+            unsubscribeTopics.add(decodedTopicName.value);
+        }
+        return new Result<MqttUnsubscribePayload>(
+                new MqttUnsubscribePayload(unsubscribeTopics),
+                numberOfBytesConsumed);
+    }
+
+    private static Result<ByteBuf> decodePublishPayload(ByteBuf buffer, int bytesRemainingInVariablePart) {
+        ByteBuf b = buffer.readSlice(bytesRemainingInVariablePart).retain();
+        return new Result<ByteBuf>(b, bytesRemainingInVariablePart);
+    }
+
+    private static Result<String> decodeString(ByteBuf buffer) {
+        return decodeString(buffer, 0, Integer.MAX_VALUE);
+    }
+
+    private static Result<String> decodeAsciiString(ByteBuf buffer) {
+        Result<String> result = decodeString(buffer, 0, Integer.MAX_VALUE);
+        final String s = result.value;
+        for (int i = 0; i < s.length(); i++) {
+            if (s.charAt(i) > 127) {
+                return new Result<String>(null, result.numberOfBytesConsumed);
+            }
+        }
+        return new Result<String>(s, result.numberOfBytesConsumed);
+    }
+
+    private static Result<String> decodeString(ByteBuf buffer, int minBytes, int maxBytes) {
+        final Result<Integer> decodedSize = decodeMsbLsb(buffer);
+        int size = decodedSize.value;
+        int numberOfBytesConsumed = decodedSize.numberOfBytesConsumed;
+        if (size < minBytes || size > maxBytes) {
+            buffer.skipBytes(size);
+            numberOfBytesConsumed += size;
+            return new Result<String>(null, numberOfBytesConsumed);
+        }
+        ByteBuf buf = buffer.readBytes(size);
+        numberOfBytesConsumed += size;
+        return new Result<String>(buf.toString(CharsetUtil.UTF_8), numberOfBytesConsumed);
+    }
+
+    private static Result<Integer> decodeMsbLsb(ByteBuf buffer) {
+        return decodeMsbLsb(buffer, 0, 65535);
+    }
+
+    private static Result<Integer> decodeMsbLsb(ByteBuf buffer, int min, int max) {
+        short msbSize = buffer.readUnsignedByte();
+        short lsbSize = buffer.readUnsignedByte();
+        final int numberOfBytesConsumed = 2;
+        int result = msbSize << 8 | lsbSize;
+        if (result < min || result > max) {
+            result = -1;
+        }
+        return new Result<Integer>(result, numberOfBytesConsumed);
+    }
+
+    private static final class Result<T> {
+
+        private final T value;
+        private final int numberOfBytesConsumed;
+
+        Result(T value, int numberOfBytesConsumed) {
+            this.value = value;
+            this.numberOfBytesConsumed = numberOfBytesConsumed;
+        }
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java
new file mode 100644
index 000000000000..817bd86b47fc
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java
@@ -0,0 +1,393 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.util.CharsetUtil;
+
+import java.util.List;
+
+/**
+ * Encodes Mqtt messages into bytes following the protocl specification v3.1
+ * as described here <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html">MQTTV3.1</a>
+ */
+public class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {
+
+    public static final MqttEncoder DEFAUL_ENCODER = new MqttEncoder();
+
+    private static final byte[] EMPTY = new byte[0];
+
+    private static final byte[] CONNECT_VARIABLE_HEADER_START = {0, 6, 'M', 'Q', 'I', 's', 'd', 'p'};
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, MqttMessage msg, List<Object> out) throws Exception {
+        out.add(doEncode(ctx.alloc(), msg));
+    }
+
+    /**
+     * This is the main encoding method.
+     * It's only visible for testing.
+     *
+     * @param byteBufAllocator Allocates ByteBuf
+     * @param message MQTT message to encode
+     * @return ByteBuf with encoded bytes
+     */
+    static ByteBuf doEncode(ByteBufAllocator byteBufAllocator, MqttMessage message) {
+
+        switch (message.fixedHeader().messageType()) {
+            case CONNECT:
+                return encodeConnectMessage(byteBufAllocator, (MqttConnectMessage) message);
+
+            case CONNACK:
+                return encodeConnAckMessage(byteBufAllocator, (MqttConnAckMessage) message);
+
+            case PUBLISH:
+                return encodePublishMessage(byteBufAllocator, (MqttPublishMessage) message);
+
+            case SUBSCRIBE:
+                return encodeSubscribeMessage(byteBufAllocator, (MqttSubscribeMessage) message);
+
+            case UNSUBSCRIBE:
+                return encodeUnsubscribeMessage(byteBufAllocator, (MqttUnsubscribeMessage) message);
+
+            case SUBACK:
+                return encodeSubAckMessage(byteBufAllocator, (MqttSubAckMessage) message);
+
+            case UNSUBACK:
+            case PUBACK:
+            case PUBREC:
+            case PUBREL:
+            case PUBCOMP:
+                return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(byteBufAllocator, message);
+
+            case PINGREQ:
+            case PINGRESP:
+            case DISCONNECT:
+                return encodeMessageWithOnlySingleByteFixedHeader(byteBufAllocator, message);
+
+            default:
+                throw new IllegalArgumentException(
+                        "Unknown message type: " + message.fixedHeader().messageType().value());
+        }
+    }
+
+    private static ByteBuf encodeConnectMessage(
+            ByteBufAllocator byteBufAllocator,
+            MqttConnectMessage message) {
+        int variableHeaderBufferSize = 12;
+        int payloadBufferSize = 0;
+
+        MqttFixedHeader mqttFixedHeader = message.fixedHeader();
+        MqttConnectVariableHeader variableHeader = message.variableHeader();
+        MqttConnectPayload payload = message.payload();
+
+        // Client id
+        String clientIdentifier = payload.clientIdentifier();
+        if (!isValidClientIdentifier(clientIdentifier)) {
+            throw new IllegalArgumentException(
+                    "invalid clientIdentifier: " + clientIdentifier + " (expected: less than 23 chars long)");
+        }
+        byte[] clientIdentifierBytes = encodeStringUtf8(clientIdentifier);
+        payloadBufferSize += 2 + clientIdentifierBytes.length;
+
+        // Will topic and message
+        String willTopic = payload.willTopic();
+        byte[] willTopicBytes = willTopic != null ? encodeStringUtf8(willTopic) : EMPTY;
+        String willMessage = payload.willMessage();
+        byte[] willMessageBytes = willMessage != null ? encodeStringUtf8(willMessage) : EMPTY;
+        if (variableHeader.isWillFlag()) {
+            payloadBufferSize += 2 + willTopicBytes.length;
+            payloadBufferSize += 2 + willMessageBytes.length;
+        }
+
+        String userName = payload.userName();
+        byte[] userNameBytes = userName != null ? encodeStringUtf8(userName) : EMPTY;
+        if (variableHeader.hasUserName()) {
+            payloadBufferSize += 2 + userNameBytes.length;
+        }
+
+        String password = payload.password();
+        byte[] passwordBytes = password != null ? encodeStringUtf8(password) : EMPTY;
+        if (variableHeader.hasPassword()) {
+            payloadBufferSize += 2 + passwordBytes.length;
+        }
+
+        // Fixed header
+        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;
+        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);
+        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);
+        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));
+        writeVariableLengthInt(buf, variablePartSize);
+
+        buf.writeBytes(CONNECT_VARIABLE_HEADER_START);
+
+        buf.writeByte(variableHeader.version());
+        buf.writeByte(getConnVariableHeaderFlag(variableHeader));
+        buf.writeShort(variableHeader.keepAliveTimeSeconds());
+
+        // Payload
+        buf.writeShort(clientIdentifierBytes.length);
+        buf.writeBytes(clientIdentifierBytes, 0, clientIdentifierBytes.length);
+        if (variableHeader.isWillFlag()) {
+            buf.writeShort(willTopicBytes.length);
+            buf.writeBytes(willTopicBytes, 0, willTopicBytes.length);
+            buf.writeShort(willMessageBytes.length);
+            buf.writeBytes(willMessageBytes, 0, willMessageBytes.length);
+        }
+        if (variableHeader.hasUserName()) {
+            buf.writeShort(userNameBytes.length);
+            buf.writeBytes(userNameBytes, 0, userNameBytes.length);
+        }
+        if (variableHeader.hasPassword()) {
+            buf.writeShort(passwordBytes.length);
+            buf.writeBytes(passwordBytes, 0, passwordBytes.length);
+        }
+        return buf;
+    }
+
+    private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableHeader) {
+        int flagByte = 0;
+        if (variableHeader.hasUserName()) {
+            flagByte |= 0x80;
+        }
+        if (variableHeader.hasPassword()) {
+            flagByte |= 0x40;
+        }
+        if (variableHeader.isWillRetain()) {
+            flagByte |= 0x20;
+        }
+        flagByte |= (variableHeader.willQos() & 0x03) << 3;
+        if (variableHeader.isWillFlag()) {
+            flagByte |= 0x04;
+        }
+        if (variableHeader.isCleanSession()) {
+            flagByte |= 0x02;
+        }
+        return flagByte;
+    }
+
+    private static ByteBuf encodeConnAckMessage(
+            ByteBufAllocator byteBufAllocator,
+            MqttConnAckMessage message) {
+        ByteBuf buf = byteBufAllocator.buffer(4);
+        buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));
+        buf.writeByte(2);
+        buf.writeByte(0);
+        buf.writeByte(message.variableHeader().connectReturnCode().byteValue());
+
+        return buf;
+    }
+
+    private static ByteBuf encodeSubscribeMessage(
+            ByteBufAllocator byteBufAllocator,
+            MqttSubscribeMessage message) {
+        int variableHeaderBufferSize = 2;
+        int payloadBufferSize = 0;
+
+        MqttFixedHeader mqttFixedHeader = message.fixedHeader();
+        MqttMessageIdVariableHeader variableHeader = message.variableHeader();
+        MqttSubscribePayload payload = message.payload();
+
+        for (MqttTopicSubscription topic : payload.topicSubscriptions()) {
+            String topicName = topic.topicName();
+            byte[] topicNameBytes = encodeStringUtf8(topicName);
+            payloadBufferSize += 2 + topicNameBytes.length;
+            payloadBufferSize += 1;
+        }
+
+        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;
+        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);
+
+        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);
+        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));
+        writeVariableLengthInt(buf, variablePartSize);
+
+        // Variable Header
+        int messageId = variableHeader.messageId();
+        buf.writeShort(messageId);
+
+        // Payload
+        for (MqttTopicSubscription topic : payload.topicSubscriptions()) {
+            String topicName = topic.topicName();
+            byte[] topicNameBytes = encodeStringUtf8(topicName);
+            buf.writeShort(topicNameBytes.length);
+            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);
+            buf.writeByte(topic.qualityOfService().value());
+        }
+
+        return buf;
+    }
+
+    private static ByteBuf encodeUnsubscribeMessage(
+            ByteBufAllocator byteBufAllocator,
+            MqttUnsubscribeMessage message) {
+        int variableHeaderBufferSize = 2;
+        int payloadBufferSize = 0;
+
+        MqttFixedHeader mqttFixedHeader = message.fixedHeader();
+        MqttMessageIdVariableHeader variableHeader = message.variableHeader();
+        MqttUnsubscribePayload payload = message.payload();
+
+        for (String topicName : payload.topics()) {
+            byte[] topicNameBytes = encodeStringUtf8(topicName);
+            payloadBufferSize += 2 + topicNameBytes.length;
+        }
+
+        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;
+        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);
+
+        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);
+        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));
+        writeVariableLengthInt(buf, variablePartSize);
+
+        // Variable Header
+        int messageId = variableHeader.messageId();
+        buf.writeShort(messageId);
+
+        // Payload
+        for (String topicName : payload.topics()) {
+            byte[] topicNameBytes = encodeStringUtf8(topicName);
+            buf.writeShort(topicNameBytes.length);
+            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);
+        }
+
+        return buf;
+    }
+
+    private static ByteBuf encodeSubAckMessage(
+            ByteBufAllocator byteBufAllocator,
+            MqttSubAckMessage message) {
+        int variableHeaderBufferSize = 2;
+        int payloadBufferSize = message.payload().grantedQoSLevels().size();
+        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;
+        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);
+        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);
+        buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));
+        writeVariableLengthInt(buf, variablePartSize);
+        buf.writeShort(message.variableHeader().messageId());
+        for (int qos : message.payload().grantedQoSLevels()) {
+            buf.writeByte(qos);
+        }
+
+        return buf;
+    }
+
+    private static ByteBuf encodePublishMessage(
+            ByteBufAllocator byteBufAllocator,
+            MqttPublishMessage message) {
+        MqttFixedHeader mqttFixedHeader = message.fixedHeader();
+        MqttPublishVariableHeader variableHeader = message.variableHeader();
+        ByteBuf payload = message.payload().duplicate();
+
+        String topicName = variableHeader.topicName();
+        byte[] topicNameBytes = encodeStringUtf8(topicName);
+
+        int variableHeaderBufferSize = 2 + topicNameBytes.length +
+                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0);
+        int payloadBufferSize = payload.readableBytes();
+        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;
+        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);
+
+        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);
+        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));
+        writeVariableLengthInt(buf, variablePartSize);
+        buf.writeShort(topicNameBytes.length);
+        buf.writeBytes(topicNameBytes);
+        if (mqttFixedHeader.qosLevel().value() > 0) {
+            buf.writeShort(variableHeader.messageId());
+        }
+        buf.writeBytes(payload);
+
+        return buf;
+    }
+
+    private static ByteBuf encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(
+            ByteBufAllocator byteBufAllocator,
+            MqttMessage message) {
+        MqttFixedHeader mqttFixedHeader = message.fixedHeader();
+        MqttMessageIdVariableHeader variableHeader = (MqttMessageIdVariableHeader) message.variableHeader();
+        int msgId = variableHeader.messageId();
+
+        int variableHeaderBufferSize = 2; // variable part only has a message id
+        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variableHeaderBufferSize);
+        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variableHeaderBufferSize);
+        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));
+        writeVariableLengthInt(buf, variableHeaderBufferSize);
+        buf.writeShort(msgId);
+
+        return buf;
+    }
+
+    private static ByteBuf encodeMessageWithOnlySingleByteFixedHeader(
+            ByteBufAllocator byteBufAllocator,
+            MqttMessage message) {
+        MqttFixedHeader mqttFixedHeader = message.fixedHeader();
+        ByteBuf buf = byteBufAllocator.buffer(2);
+        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));
+        buf.writeByte(0);
+
+        return buf;
+    }
+
+    private static int getFixedHeaderByte1(MqttFixedHeader header) {
+        int ret = 0;
+        ret |= header.messageType().value() << 4;
+        if (header.isDup()) {
+            ret |= 0x08;
+        }
+        ret |= header.qosLevel().value() << 1;
+        if (header.isRetain()) {
+            ret |= 0x01;
+        }
+        return ret;
+    }
+
+    private static void writeVariableLengthInt(ByteBuf buf, int num) {
+        do {
+            int digit = num % 128;
+            num /= 128;
+            if (num > 0) {
+                digit |= 0x80;
+            }
+            buf.writeByte(digit);
+        } while (num > 0);
+    }
+
+    private static int getVariableLengthInt(int num) {
+        int count = 0;
+        do {
+            num /= 128;
+            count++;
+        } while (num > 0);
+        return count;
+    }
+
+    private static byte[] encodeStringUtf8(String s) {
+      return s.getBytes(CharsetUtil.UTF_8);
+    }
+
+    private static boolean isValidClientIdentifier(String clientIdentifier) {
+        if (clientIdentifier == null) {
+            return false;
+        }
+        int length = clientIdentifier.length();
+        return length >= 1 && length <= 23;
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttFixedHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttFixedHeader.java
new file mode 100644
index 000000000000..79c1421d8ed3
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttFixedHeader.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#fixed-header">
+ *     MQTTV3.1/fixed-header</a>
+ */
+public class MqttFixedHeader {
+
+    private final MqttMessageType messageType;
+    private final boolean isDup;
+    private final MqttQoS qosLevel;
+    private final boolean isRetain;
+    private final int remainingLength;
+
+    public MqttFixedHeader(
+            MqttMessageType messageType,
+            boolean isDup,
+            MqttQoS qosLevel,
+            boolean isRetain,
+            int remainingLength) {
+        this.messageType = messageType;
+        this.isDup = isDup;
+        this.qosLevel = qosLevel;
+        this.isRetain = isRetain;
+        this.remainingLength = remainingLength;
+    }
+
+    public MqttMessageType messageType() {
+        return messageType;
+    }
+
+    public boolean isDup() {
+        return isDup;
+    }
+
+    public MqttQoS qosLevel() {
+        return qosLevel;
+    }
+
+    public boolean isRetain() {
+        return isRetain;
+    }
+
+    public int remainingLength() {
+        return remainingLength;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("messageType=").append(messageType);
+        builder.append(", isDup=").append(isDup);
+        builder.append(", qosLevel=").append(qosLevel);
+        builder.append(", isRetain=").append(isRetain);
+        builder.append(", remainingLength=").append(remainingLength);
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessage.java
new file mode 100644
index 000000000000..c92aa015cfb7
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessage.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.handler.codec.DecoderResult;
+import io.netty.util.internal.StringUtil;
+
+/**
+ * Base class for all MQTT message types.
+ */
+public class MqttMessage {
+
+    private final MqttFixedHeader mqttFixedHeader;
+    private final Object variableHeader;
+    private final Object payload;
+    private final DecoderResult decoderResult;
+
+    public MqttMessage(MqttFixedHeader mqttFixedHeader) {
+        this(mqttFixedHeader, null, null);
+    }
+
+    public MqttMessage(MqttFixedHeader mqttFixedHeader, Object variableHeader) {
+        this(mqttFixedHeader, variableHeader, null);
+    }
+
+    public MqttMessage(MqttFixedHeader mqttFixedHeader, Object variableHeader, Object payload) {
+        this(mqttFixedHeader, variableHeader, payload, DecoderResult.SUCCESS);
+    }
+
+    public MqttMessage(
+            MqttFixedHeader mqttFixedHeader,
+            Object variableHeader,
+            Object payload,
+            DecoderResult decoderResult) {
+        this.mqttFixedHeader = mqttFixedHeader;
+        this.variableHeader = variableHeader;
+        this.payload = payload;
+        this.decoderResult = decoderResult;
+    }
+
+    public MqttFixedHeader fixedHeader() {
+        return mqttFixedHeader;
+    }
+
+    public Object variableHeader() {
+        return variableHeader;
+    }
+
+    public Object payload() {
+        return payload;
+    }
+
+    public DecoderResult decoderResult() {
+        return decoderResult;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("fixedHeader=").append(fixedHeader() != null ? fixedHeader().toString() : "");
+        builder.append(", variableHeader=").append(variableHeader() != null ? variableHeader.toString() : "");
+        builder.append(", payload=").append(payload() != null ? payload.toString() : "");
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageFactory.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageFactory.java
new file mode 100644
index 000000000000..69f07c07273c
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageFactory.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.DecoderResult;
+
+/**
+ * Utility class with factory methods to create different types of MQTT messages.
+ */
+public final class MqttMessageFactory {
+
+    public static MqttMessage newMessage(MqttFixedHeader mqttFixedHeader, Object variableHeader, Object payload) {
+        switch (mqttFixedHeader.messageType()) {
+            case CONNECT :
+                return new MqttConnectMessage(
+                        mqttFixedHeader,
+                        (MqttConnectVariableHeader) variableHeader,
+                        (MqttConnectPayload) payload);
+
+            case CONNACK:
+                return new MqttConnAckMessage(mqttFixedHeader, (MqttConnAckVariableHeader) variableHeader);
+
+            case SUBSCRIBE:
+                return new MqttSubscribeMessage(
+                        mqttFixedHeader,
+                        (MqttMessageIdVariableHeader) variableHeader,
+                        (MqttSubscribePayload) payload);
+
+            case SUBACK:
+                return new MqttSubAckMessage(
+                        mqttFixedHeader,
+                        (MqttMessageIdVariableHeader) variableHeader,
+                        (MqttSubAckPayload) payload);
+
+            case UNSUBACK:
+                return new MqttUnsubAckMessage(
+                        mqttFixedHeader,
+                        (MqttMessageIdVariableHeader) variableHeader);
+
+            case UNSUBSCRIBE:
+                return new MqttUnsubscribeMessage(
+                        mqttFixedHeader,
+                        (MqttMessageIdVariableHeader) variableHeader,
+                        (MqttUnsubscribePayload) payload);
+
+            case PUBLISH:
+                return new MqttPublishMessage(
+                        mqttFixedHeader,
+                        (MqttPublishVariableHeader) variableHeader,
+                        (ByteBuf) payload);
+
+            case PUBACK:
+                return new MqttPubAckMessage(mqttFixedHeader, (MqttMessageIdVariableHeader) variableHeader);
+            case PUBREC:
+            case PUBREL:
+            case PUBCOMP:
+                return new MqttMessage(mqttFixedHeader, variableHeader);
+
+            case PINGREQ:
+            case PINGRESP:
+            case DISCONNECT:
+                return new MqttMessage(mqttFixedHeader);
+
+            default:
+                throw new IllegalArgumentException("unknown message type: " + mqttFixedHeader.messageType());
+        }
+    }
+
+    public static MqttMessage newInvalidMessage(Throwable cause) {
+        return new MqttMessage(null, null, null, DecoderResult.failure(cause));
+    }
+
+    private MqttMessageFactory() { }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdVariableHeader.java
new file mode 100644
index 000000000000..c4caf5446805
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdVariableHeader.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+/**
+ * Variable Header containing only Message Id
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#msg-id">MQTTV3.1/msg-id</a>
+ */
+public final class MqttMessageIdVariableHeader {
+
+    private final int messageId;
+
+    public static MqttMessageIdVariableHeader from(int messageId) {
+      if (messageId < 1 || messageId > 0xffff) {
+        throw new IllegalArgumentException("messageId: " + messageId + " (expected: 1 ~ 65535)");
+      }
+      return new MqttMessageIdVariableHeader(messageId);
+    }
+
+    private MqttMessageIdVariableHeader(int messageId) {
+        this.messageId = messageId;
+    }
+
+    public int messageId() {
+        return messageId;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("messageId=").append(messageId);
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageType.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageType.java
new file mode 100644
index 000000000000..2db21d40b0f6
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageType.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * MQTT Message Types.
+ */
+public enum MqttMessageType {
+    CONNECT(1),
+    CONNACK(2),
+    PUBLISH(3),
+    PUBACK(4),
+    PUBREC(5),
+    PUBREL(6),
+    PUBCOMP(7),
+    SUBSCRIBE(8),
+    SUBACK(9),
+    UNSUBSCRIBE(10),
+    UNSUBACK(11),
+    PINGREQ(12),
+    PINGRESP(13),
+    DISCONNECT(14);
+
+    private final int value;
+
+    MqttMessageType(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    public static MqttMessageType valueOf(int type) {
+        for (MqttMessageType t : values()) {
+            if (t.value == type) {
+                return t;
+            }
+        }
+        throw new IllegalArgumentException("unknown message type: " + type);
+    }
+}
+
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java
new file mode 100644
index 000000000000..a22414edd94b
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#puback">MQTTV3.1/puback</a>
+ */
+public class MqttPubAckMessage extends MqttMessage {
+
+    public MqttPubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {
+        super(mqttFixedHeader, variableHeader);
+    }
+
+    @Override
+    public MqttMessageIdVariableHeader variableHeader() {
+        return (MqttMessageIdVariableHeader) super.variableHeader();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishMessage.java
new file mode 100644
index 000000000000..57f96665d76a
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishMessage.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufHolder;
+import io.netty.util.IllegalReferenceCountException;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#publish">MQTTV3.1/publish</a>
+ */
+public class MqttPublishMessage extends MqttMessage implements ByteBufHolder {
+
+    public MqttPublishMessage(
+            MqttFixedHeader mqttFixedHeader,
+            MqttPublishVariableHeader variableHeader,
+            ByteBuf payload) {
+        super(mqttFixedHeader, variableHeader, payload);
+    }
+
+    @Override
+    public MqttPublishVariableHeader variableHeader() {
+        return (MqttPublishVariableHeader) super.variableHeader();
+    }
+
+    @Override
+    public ByteBuf payload() {
+        return content();
+    }
+
+    @Override
+    public ByteBuf content() {
+        final ByteBuf data = (ByteBuf) super.payload();
+        if (data.refCnt() <= 0) {
+            throw new IllegalReferenceCountException(data.refCnt());
+        }
+        return data;
+    }
+
+    @Override
+    public MqttPublishMessage copy() {
+        return new MqttPublishMessage(fixedHeader(), variableHeader(), content().copy());
+    }
+
+    @Override
+    public MqttPublishMessage duplicate() {
+        return new MqttPublishMessage(fixedHeader(), variableHeader(), content().duplicate());
+    }
+
+    @Override
+    public int refCnt() {
+        return content().refCnt();
+    }
+
+    @Override
+    public MqttPublishMessage retain() {
+        content().retain();
+        return this;
+    }
+
+    @Override
+    public MqttPublishMessage retain(int increment) {
+        content().retain(increment);
+        return this;
+    }
+
+    @Override
+    public MqttPublishMessage touch() {
+        content().touch();
+        return this;
+    }
+
+    @Override
+    public MqttPublishMessage touch(Object hint) {
+        content().touch(hint);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        return content().release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        return content().release(decrement);
+    }
+
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java
new file mode 100644
index 000000000000..df7e744c071a
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+/**
+ * Variable Header of the {@link MqttPublishMessage}
+ */
+public class MqttPublishVariableHeader {
+
+    private final String topicName;
+    private final int messageId;
+
+    public MqttPublishVariableHeader(String topicName, int messageId) {
+        this.topicName = topicName;
+        this.messageId = messageId;
+    }
+
+    public String topicName() {
+        return topicName;
+    }
+
+    public int messageId() {
+        return messageId;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("topicName=").append(topicName);
+        builder.append(", messageId=").append(messageId);
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttQoS.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttQoS.java
new file mode 100644
index 000000000000..2e654e141a3e
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttQoS.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+public enum MqttQoS {
+    AT_MOST_ONCE(0),
+    AT_LEAST_ONCE(1),
+    EXACTLY_ONCE(2);
+
+    private final int value;
+
+    MqttQoS(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    public static MqttQoS valueOf(int value) {
+        for (MqttQoS q: values()) {
+            if (q.value == value) {
+                return q;
+            }
+        }
+        throw new IllegalArgumentException("invalid QoS: " + value);
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java
new file mode 100644
index 000000000000..95be4e2109aa
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#suback">MQTTV3.1/suback</a>
+ */
+public class MqttSubAckMessage extends MqttMessage {
+
+    public MqttSubAckMessage(
+            MqttFixedHeader mqttFixedHeader,
+            MqttMessageIdVariableHeader variableHeader,
+            MqttSubAckPayload payload) {
+        super(mqttFixedHeader, variableHeader, payload);
+    }
+
+    @Override
+    public MqttMessageIdVariableHeader variableHeader() {
+        return (MqttMessageIdVariableHeader) super.variableHeader();
+    }
+
+    @Override
+    public MqttSubAckPayload payload() {
+        return (MqttSubAckPayload) super.payload();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckPayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckPayload.java
new file mode 100644
index 000000000000..dffb79ad6fc1
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckPayload.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Payload of the {@link MqttSubAckMessage}
+ */
+public class MqttSubAckPayload {
+
+    private final List<Integer> grantedQoSLevels;
+
+    public MqttSubAckPayload(int... grantedQoSLevels) {
+        if (grantedQoSLevels == null) {
+            throw new NullPointerException("grantedQoSLevels");
+        }
+
+        List<Integer> list = new ArrayList<Integer>(grantedQoSLevels.length);
+        for (int v: grantedQoSLevels) {
+            list.add(v);
+        }
+        this.grantedQoSLevels = Collections.unmodifiableList(list);
+    }
+
+    public MqttSubAckPayload(Iterable<Integer> grantedQoSLevels) {
+        if (grantedQoSLevels == null) {
+            throw new NullPointerException("grantedQoSLevels");
+        }
+        List<Integer> list = new ArrayList<Integer>();
+        for (Integer v: grantedQoSLevels) {
+            if (v == null) {
+                break;
+            }
+            list.add(v);
+        }
+        this.grantedQoSLevels = Collections.unmodifiableList(list);
+    }
+
+    public List<Integer> grantedQoSLevels() {
+        return grantedQoSLevels;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("grantedQoSLevels=").append(grantedQoSLevels);
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java
new file mode 100644
index 000000000000..12dcd30229aa
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe">
+ *     MQTTV3.1/subscribe</a>
+ */
+public class MqttSubscribeMessage extends MqttMessage {
+
+    public MqttSubscribeMessage(
+            MqttFixedHeader mqttFixedHeader,
+            MqttMessageIdVariableHeader variableHeader,
+            MqttSubscribePayload payload) {
+        super(mqttFixedHeader, variableHeader, payload);
+    }
+
+    @Override
+    public MqttMessageIdVariableHeader variableHeader() {
+        return (MqttMessageIdVariableHeader) super.variableHeader();
+    }
+
+    @Override
+    public MqttSubscribePayload payload() {
+        return (MqttSubscribePayload) super.payload();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribePayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribePayload.java
new file mode 100644
index 000000000000..dbdb3de18129
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribePayload.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Payload of the {@link MqttSubscribeMessage}
+ */
+public class MqttSubscribePayload {
+
+    private final List<MqttTopicSubscription> topicSubscriptions;
+
+    public MqttSubscribePayload(List<MqttTopicSubscription> topicSubscriptions) {
+        this.topicSubscriptions = Collections.unmodifiableList(topicSubscriptions);
+    }
+
+    public List<MqttTopicSubscription> topicSubscriptions() {
+        return topicSubscriptions;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        for (int i = 0; i < topicSubscriptions.size() - 1; i++) {
+            builder.append(topicSubscriptions.get(i)).append(", ");
+        }
+        builder.append(topicSubscriptions.get(topicSubscriptions.size() - 1));
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttTopicSubscription.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttTopicSubscription.java
new file mode 100644
index 000000000000..839b6f07c4a8
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttTopicSubscription.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+/**
+ * Contains a topic name and Qos Level.
+ * This is part of the {@link MqttSubscribePayload}
+ */
+public class MqttTopicSubscription {
+
+    private final String topicFilter;
+    private final MqttQoS qualityOfService;
+
+    public MqttTopicSubscription(String topicFilter, MqttQoS qualityOfService) {
+        this.topicFilter = topicFilter;
+        this.qualityOfService = qualityOfService;
+    }
+
+    public String topicName() {
+        return topicFilter;
+    }
+
+    public MqttQoS qualityOfService() {
+        return qualityOfService;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        builder.append("topicFilter=").append(topicFilter);
+        builder.append(", qualityOfService=").append(qualityOfService);
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java
new file mode 100644
index 000000000000..032188406d67
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsuback">MQTTV3.1/unsuback</a>
+ */
+public class MqttUnsubAckMessage extends MqttMessage {
+
+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {
+        super(mqttFixedHeader, variableHeader, null);
+    }
+
+    @Override
+    public MqttMessageIdVariableHeader variableHeader() {
+        return (MqttMessageIdVariableHeader) super.variableHeader();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java
new file mode 100644
index 000000000000..bbf770a6025f
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * See <a href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsubscribe">
+ *     MQTTV3.1/unsubscribe</a>
+ */
+public class MqttUnsubscribeMessage extends MqttMessage {
+
+    public MqttUnsubscribeMessage(
+            MqttFixedHeader mqttFixedHeader,
+            MqttMessageIdVariableHeader variableHeader,
+            MqttUnsubscribePayload payload) {
+        super(mqttFixedHeader, variableHeader, payload);
+    }
+
+    @Override
+    public MqttMessageIdVariableHeader variableHeader() {
+        return (MqttMessageIdVariableHeader) super.variableHeader();
+    }
+
+    @Override
+    public MqttUnsubscribePayload payload() {
+        return (MqttUnsubscribePayload) super.payload();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribePayload.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribePayload.java
new file mode 100644
index 000000000000..b203760e07b3
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribePayload.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.util.internal.StringUtil;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Pyaload of the {@link MqttUnsubscribeMessage}
+ */
+public class MqttUnsubscribePayload {
+
+    private final List<String> topics;
+
+    public MqttUnsubscribePayload(List<String> topics) {
+        this.topics = Collections.unmodifiableList(topics);
+    }
+
+    public List<String> topics() {
+        return topics;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
+        for (int i = 0; i < topics.size() - 1; i++) {
+            builder.append("topicName = " + topics.get(i)).append(", ");
+        }
+        builder.append("topicName = " + topics.get(topics.size() - 1));
+        builder.append(']');
+        return builder.toString();
+    }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttVersion.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttVersion.java
new file mode 100644
index 000000000000..260836205827
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttVersion.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+/**
+ * Holds Constant values used by multiple classes in mqtt-codec.
+ */
+final class MqttVersion {
+
+    static final String PROTOCOL_NAME = "MQIsdp";
+
+    private MqttVersion() { }
+}
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/package-info.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/package-info.java
new file mode 100644
index 000000000000..56004883e22e
--- /dev/null
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+/**
+ * Encoder, decoder and different Message Types for MQTT.
+ */
+package io.netty.handler.codec.mqtt;
diff --git a/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java
new file mode 100644
index 000000000000..b4d8c00791ed
--- /dev/null
+++ b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java
@@ -0,0 +1,431 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.mqtt;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.UnpooledByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.CharsetUtil;
+import org.easymock.Mock;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.MockitoAnnotations;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import static io.netty.handler.codec.mqtt.MqttVersion.*;
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+/**
+ * Unit tests for MqttEncoder and MqttDecoder.
+ */
+public class MqttCodecTest {
+
+    private static final String CLIENT_ID = "RANDOM_TEST_CLIENT";
+    private static final String WILL_TOPIC = "/my_will";
+    private static final String WILL_MESSAGE = "gone";
+    private static final String USER_NAME = "happy_user";
+    private static final String PASSWORD = "123_or_no_pwd";
+
+    private static final int PROTOCOL_VERSION = 3;
+    private static final int KEEP_ALIVE_SECONDS = 600;
+
+    private static final ByteBufAllocator ALLOCATOR = new UnpooledByteBufAllocator(false);
+
+    @Mock
+    private final ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);
+
+    @Mock
+    private final Channel channel = mock(Channel.class);
+
+    private final MqttDecoder mqttDecoder = new MqttDecoder();
+
+    @Before
+    public void setup() {
+        MockitoAnnotations.initMocks(this);
+        when(ctx.channel()).thenReturn(channel);
+    }
+
+    @Test
+    public void testConnectMessage() throws Exception {
+        final MqttConnectMessage message = createConnectMessage();
+        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);
+
+        final List<Object> out = new LinkedList<Object>();
+        mqttDecoder.decode(ctx, byteBuf, out);
+
+        assertEquals("Expected one object bout got " + out.size(), 1, out.size());
+
+        final MqttConnectMessage decodedMessage = (MqttConnectMessage) out.get(0);
+
+        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());
+        vlidateConnectVariableHeader(message.variableHeader(), decodedMessage.variableHeader());
+        validateConnectPayload(message.payload(), decodedMessage.payload());
+    }
+
+    @Test
+    public void testConnAckMessage() throws Exception {
+        final MqttConnAckMessage message = createConnAckMessage();
+        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);
+
+        final List<Object> out = new LinkedList<Object>();
+        mqttDecoder.decode(ctx, byteBuf, out);
+
+        assertEquals("Expected one object bout got " + out.size(), 1, out.size());
+
+        final MqttConnAckMessage decodedMessage = (MqttConnAckMessage) out.get(0);
+        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());
+        validateConnAckVariableHeader(message.variableHeader(), decodedMessage.variableHeader());
+    }
+
+    @Test
+    public void testPublishMessage() throws Exception {
+        final MqttPublishMessage message = createPublishMessage();
+        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);
+
+        final List<Object> out = new LinkedList<Object>();
+        mqttDecoder.decode(ctx, byteBuf, out);
+
+        assertEquals("Expected one object bout got " + out.size(), 1, out.size());
+
+        final MqttPublishMessage decodedMessage = (MqttPublishMessage) out.get(0);
+        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());
+        validatePublishVariableHeader(message.variableHeader(), decodedMessage.variableHeader());
+        validatePublishPayload(message.payload(), decodedMessage.payload());
+    }
+
+    @Test
+    public void testPubAckMessage() throws Exception {
+        testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader(MqttMessageType.PUBACK);
+    }
+
+    @Test
+    public void testPubRecMessage() throws Exception {
+        testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader(MqttMessageType.PUBREC);
+    }
+
+    @Test
+    public void testPubRelMessage() throws Exception {
+        testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader(MqttMessageType.PUBREL);
+    }
+
+    @Test
+    public void testPubCompMessage() throws Exception {
+        testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader(MqttMessageType.PUBCOMP);
+    }
+
+    @Test
+    public void testSubscribeMessage() throws Exception {
+        final MqttSubscribeMessage message = createSubscribeMessage();
+        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);
+
+        final List<Object> out = new LinkedList<Object>();
+        mqttDecoder.decode(ctx, byteBuf, out);
+
+        assertEquals("Expected one object bout got " + out.size(), 1, out.size());
+
+        final MqttSubscribeMessage decodedMessage = (MqttSubscribeMessage) out.get(0);
+        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());
+        validateMessageIdVariableHeader(message.variableHeader(), decodedMessage.variableHeader());
+        validateSubscribePayload(message.payload(), decodedMessage.payload());
+    }
+
+    @Test
+    public void testSubAckMessage() throws Exception {
+        final MqttSubAckMessage message = createSubAckMessage();
+        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);
+
+        final List<Object> out = new LinkedList<Object>();
+        mqttDecoder.decode(ctx, byteBuf, out);
+
+        assertEquals("Expected one object bout got " + out.size(), 1, out.size());
+
+        final MqttSubAckMessage decodedMessage = (MqttSubAckMessage) out.get(0);
+        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());
+        validateMessageIdVariableHeader(message.variableHeader(), decodedMessage.variableHeader());
+        validateSubAckPayload(message.payload(), decodedMessage.payload());
+    }
+
+    @Test
+    public void testUnSubscribeMessage() throws Exception {
+        final MqttUnsubscribeMessage message = createUnsubscribeMessage();
+        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);
+
+        final List<Object> out = new LinkedList<Object>();
+        mqttDecoder.decode(ctx, byteBuf, out);
+
+        assertEquals("Expected one object bout got " + out.size(), 1, out.size());
+
+        final MqttUnsubscribeMessage decodedMessage = (MqttUnsubscribeMessage) out.get(0);
+        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());
+        validateMessageIdVariableHeader(message.variableHeader(), decodedMessage.variableHeader());
+        validateUnsubscribePayload(message.payload(), decodedMessage.payload());
+    }
+
+    @Test
+    public void testUnsubAckMessage() throws Exception {
+        testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader(MqttMessageType.UNSUBACK);
+    }
+
+    @Test
+    public void testPingReqMessage() throws Exception {
+        testMessageWithOnlyFixedHeader(MqttMessageType.PINGREQ);
+    }
+
+    @Test
+    public void testPingRespMessage() throws Exception {
+        testMessageWithOnlyFixedHeader(MqttMessageType.PINGRESP);
+    }
+
+    @Test
+    public void testDisconnectMessage() throws Exception {
+        testMessageWithOnlyFixedHeader(MqttMessageType.DISCONNECT);
+    }
+
+    private void testMessageWithOnlyFixedHeader(MqttMessageType messageType) throws Exception {
+        MqttMessage message = createMessageWithFixedHeader(messageType);
+        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);
+
+        final List<Object> out = new LinkedList<Object>();
+        mqttDecoder.decode(ctx, byteBuf, out);
+
+        assertEquals("Expected one object bout got " + out.size(), 1, out.size());
+
+        final MqttMessage decodedMessage = (MqttMessage) out.get(0);
+        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());
+    }
+
+    private void testMessageWithOnlyFixedHeaderAndMessageIdVariableHeader(MqttMessageType messageType)
+            throws Exception {
+        MqttMessage message = createMessageWithFixedHeaderAndMessageIdVariableHeader(messageType);
+
+        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);
+
+        final List<Object> out = new LinkedList<Object>();
+        mqttDecoder.decode(ctx, byteBuf, out);
+
+        assertEquals("Expected one object bout got " + out.size(), 1, out.size());
+
+        final MqttMessage decodedMessage = (MqttMessage) out.get(0);
+        validateFixedHeaders(message.fixedHeader(), decodedMessage.fixedHeader());
+        validateMessageIdVariableHeader(
+                (MqttMessageIdVariableHeader) message.variableHeader(),
+                (MqttMessageIdVariableHeader) decodedMessage.variableHeader());
+    }
+
+    // Factory methods of different MQTT
+    // Message types to help testing
+
+    private static MqttMessage createMessageWithFixedHeader(MqttMessageType messageType) {
+        return new MqttMessage(new MqttFixedHeader(messageType, false, MqttQoS.AT_MOST_ONCE, false, 0));
+    }
+
+    private static MqttMessage createMessageWithFixedHeaderAndMessageIdVariableHeader(MqttMessageType messageType) {
+        MqttFixedHeader mqttFixedHeader =
+                new MqttFixedHeader(
+                        messageType,
+                        false,
+                        messageType == MqttMessageType.PUBREL ? MqttQoS.AT_LEAST_ONCE :  MqttQoS.AT_MOST_ONCE,
+                        false,
+                        0);
+        MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader.from(12345);
+        return new MqttMessage(mqttFixedHeader, mqttMessageIdVariableHeader);
+    }
+
+    private static MqttConnectMessage createConnectMessage() {
+        MqttFixedHeader mqttFixedHeader =
+                new MqttFixedHeader(MqttMessageType.CONNECT, false, MqttQoS.AT_MOST_ONCE, false, 0);
+        MqttConnectVariableHeader mqttConnectVariableHeader =
+                new MqttConnectVariableHeader(
+                        PROTOCOL_NAME,
+                        PROTOCOL_VERSION,
+                        true,
+                        true,
+                        true,
+                        1,
+                        true,
+                        true,
+                        KEEP_ALIVE_SECONDS);
+        MqttConnectPayload mqttConnectPayload =
+                new MqttConnectPayload(CLIENT_ID, WILL_TOPIC, WILL_MESSAGE, USER_NAME, PASSWORD);
+
+        return new MqttConnectMessage(mqttFixedHeader, mqttConnectVariableHeader, mqttConnectPayload);
+    }
+
+    private static MqttConnAckMessage createConnAckMessage() {
+        MqttFixedHeader mqttFixedHeader =
+                new MqttFixedHeader(MqttMessageType.CONNACK, false, MqttQoS.AT_MOST_ONCE, false, 0);
+        MqttConnAckVariableHeader mqttConnAckVariableHeader =
+                new MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_ACCEPTED);
+        return new MqttConnAckMessage(mqttFixedHeader, mqttConnAckVariableHeader);
+    }
+
+    private static MqttPublishMessage createPublishMessage() {
+        MqttFixedHeader mqttFixedHeader =
+                new MqttFixedHeader(MqttMessageType.PUBLISH, false, MqttQoS.AT_LEAST_ONCE, true, 0);
+        MqttPublishVariableHeader mqttPublishVariableHeader = new MqttPublishVariableHeader("/abc", 1234);
+        ByteBuf payload =  ALLOCATOR.buffer();
+        payload.writeBytes("whatever".getBytes(CharsetUtil.UTF_8));
+        return new MqttPublishMessage(mqttFixedHeader, mqttPublishVariableHeader, payload);
+    }
+
+    private static MqttSubscribeMessage createSubscribeMessage() {
+        MqttFixedHeader mqttFixedHeader =
+                new MqttFixedHeader(MqttMessageType.SUBSCRIBE, false, MqttQoS.AT_LEAST_ONCE, true, 0);
+        MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader.from(12345);
+
+        List<MqttTopicSubscription> topicSubscriptions = new LinkedList<MqttTopicSubscription>();
+        topicSubscriptions.add(new MqttTopicSubscription("/abc", MqttQoS.AT_LEAST_ONCE));
+        topicSubscriptions.add(new MqttTopicSubscription("/def", MqttQoS.AT_LEAST_ONCE));
+        topicSubscriptions.add(new MqttTopicSubscription("/xyz", MqttQoS.EXACTLY_ONCE));
+
+        MqttSubscribePayload mqttSubscribePayload = new MqttSubscribePayload(topicSubscriptions);
+        return new MqttSubscribeMessage(mqttFixedHeader, mqttMessageIdVariableHeader, mqttSubscribePayload);
+    }
+
+    private static MqttSubAckMessage createSubAckMessage() {
+        MqttFixedHeader mqttFixedHeader =
+                new MqttFixedHeader(MqttMessageType.SUBACK, false, MqttQoS.AT_MOST_ONCE, false, 0);
+        MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader.from(12345);
+        MqttSubAckPayload mqttSubAckPayload = new MqttSubAckPayload(1, 2, 0);
+        return new MqttSubAckMessage(mqttFixedHeader, mqttMessageIdVariableHeader, mqttSubAckPayload);
+    }
+
+    private static MqttUnsubscribeMessage createUnsubscribeMessage() {
+        MqttFixedHeader mqttFixedHeader =
+                new MqttFixedHeader(MqttMessageType.UNSUBSCRIBE, false, MqttQoS.AT_LEAST_ONCE, true, 0);
+        MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader.from(12345);
+
+        List<String> topics = new LinkedList<String>();
+        topics.add("/abc");
+        topics.add("/def");
+        topics.add("/xyz");
+
+        MqttUnsubscribePayload mqttUnsubscribePayload = new MqttUnsubscribePayload(topics);
+        return new MqttUnsubscribeMessage(mqttFixedHeader, mqttMessageIdVariableHeader, mqttUnsubscribePayload);
+    }
+
+    // Helper methdos to compare expected and actual
+    // MQTT messages
+
+    private static void validateFixedHeaders(MqttFixedHeader expected, MqttFixedHeader actual) {
+        assertEquals("MqttFixedHeader MqttMessageType mismatch ", expected.messageType(), actual.messageType());
+        assertEquals("MqttFixedHeader Qos mismatch ", expected.qosLevel(), actual.qosLevel());
+    }
+
+    private static void vlidateConnectVariableHeader(
+            MqttConnectVariableHeader expected,
+            MqttConnectVariableHeader actual) {
+        assertEquals("MqttConnectVariableHeader Name mismatch ", expected.name(), actual.name());
+        assertEquals(
+                "MqttConnectVariableHeader KeepAliveTimeSeconds mismatch ",
+                expected.keepAliveTimeSeconds(),
+                actual.keepAliveTimeSeconds());
+        assertEquals("MqttConnectVariableHeader Version mismatch ", expected.version(), actual.version());
+        assertEquals("MqttConnectVariableHeader WillQos mismatch ", expected.willQos(), actual.willQos());
+
+        assertEquals("MqttConnectVariableHeader HasUserName mismatch ", expected.hasUserName(), actual.hasUserName());
+        assertEquals("MqttConnectVariableHeader HasPassword mismatch ", expected.hasPassword(), actual.hasPassword());
+        assertEquals(
+                "MqttConnectVariableHeader IsCleanSession mismatch ",
+                expected.isCleanSession(),
+                actual.isCleanSession());
+        assertEquals("MqttConnectVariableHeader IsWillFlag mismatch ", expected.isWillFlag(), actual.isWillFlag());
+        assertEquals(
+                "MqttConnectVariableHeader IsWillRetain mismatch ",
+                expected.isWillRetain(),
+                actual.isWillRetain());
+    }
+
+    private static void validateConnectPayload(MqttConnectPayload expected, MqttConnectPayload actual) {
+        assertEquals(
+                "MqttConnectPayload ClientIdentifier mismatch ",
+                expected.clientIdentifier(),
+                actual.clientIdentifier());
+        assertEquals("MqttConnectPayload UserName mismatch ", expected.userName(), actual.userName());
+        assertEquals("MqttConnectPayload Password mismatch ", expected.password(), actual.password());
+        assertEquals("MqttConnectPayload WillMessage mismatch ", expected.willMessage(), actual.willMessage());
+        assertEquals("MqttConnectPayload WillTopic mismatch ", expected.willTopic(), actual.willTopic());
+    }
+
+    private static void validateConnAckVariableHeader(
+            MqttConnAckVariableHeader expected,
+            MqttConnAckVariableHeader actual) {
+        assertEquals(
+                "MqttConnAckVariableHeader MqttConnectReturnCode mismatch",
+                expected.connectReturnCode(),
+                actual.connectReturnCode());
+    }
+
+    private static void validatePublishVariableHeader(
+            MqttPublishVariableHeader expected,
+            MqttPublishVariableHeader actual) {
+        assertEquals("MqttPublishVariableHeader TopicName mismatch ", expected.topicName(), actual.topicName());
+        assertEquals("MqttPublishVariableHeader MessageId mismatch ", expected.messageId(), actual.messageId());
+    }
+
+    private static void validatePublishPayload(ByteBuf expected, ByteBuf actual) {
+        assertEquals("PublishPayload mismatch ", 0, expected.compareTo(actual));
+    }
+
+    private static void validateMessageIdVariableHeader(
+            MqttMessageIdVariableHeader expected,
+            MqttMessageIdVariableHeader actual) {
+        assertEquals("MqttMessageIdVariableHeader MessageId mismatch ", expected.messageId(), actual.messageId());
+    }
+
+    private static void validateSubscribePayload(MqttSubscribePayload expected, MqttSubscribePayload actual) {
+        List<MqttTopicSubscription> expectedTopicSubscriptions = expected.topicSubscriptions();
+        List<MqttTopicSubscription> actualTopicSubscriptions = actual.topicSubscriptions();
+
+        assertEquals(
+                "MqttSubscribePayload TopicSubscriptionList size mismatch ",
+                expectedTopicSubscriptions.size(),
+                actualTopicSubscriptions.size());
+        for (int i = 0; i < expectedTopicSubscriptions.size(); i++) {
+            validateTopicSubscription(expectedTopicSubscriptions.get(i), actualTopicSubscriptions.get(i));
+        }
+    }
+
+    private static void validateTopicSubscription(
+            MqttTopicSubscription expected,
+            MqttTopicSubscription actual) {
+        assertEquals("MqttTopicSubscription TopicName mismatch ", expected.topicName(), actual.topicName());
+        assertEquals(
+                "MqttTopicSubscription Qos mismatch ",
+                expected.qualityOfService(),
+                actual.qualityOfService());
+    }
+
+    private static void validateSubAckPayload(MqttSubAckPayload expected, MqttSubAckPayload actual) {
+        assertArrayEquals(
+                "MqttSubAckPayload GrantedQosLevels mismatch ",
+                expected.grantedQoSLevels().toArray(),
+                actual.grantedQoSLevels().toArray());
+    }
+
+    private static void validateUnsubscribePayload(MqttUnsubscribePayload expected, MqttUnsubscribePayload actual) {
+        assertArrayEquals(
+                "MqttUnsubscribePayload TopicList mismatch ",
+                expected.topics().toArray(),
+                actual.topics().toArray());
+    }
+}
diff --git a/codec-socks/pom.xml b/codec-socks/pom.xml
index a75046c9d502..beab1830dcfb 100644
--- a/codec-socks/pom.xml
+++ b/codec-socks/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-codec-socks</artifactId>
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAddressType.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAddressType.java
index 5eb157befdf6..856f3e714c33 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAddressType.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAddressType.java
@@ -28,7 +28,15 @@ public enum SocksAddressType {
         this.b = b;
     }
 
+    /**
+     * @deprecated Use {@link #valueOf(byte)} instead.
+     */
+    @Deprecated
     public static SocksAddressType fromByte(byte b) {
+        return valueOf(b);
+    }
+
+    public static SocksAddressType valueOf(byte b) {
         for (SocksAddressType code : values()) {
             if (code.b == b) {
                 return code;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
index 238efe1cc3b1..18634c7ddde1 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksAuthRequestDecoder.State;
 import io.netty.util.CharsetUtil;
 
 import java.util.List;
@@ -26,12 +27,7 @@
  * Decodes {@link ByteBuf}s into {@link SocksAuthRequest}.
  * Before returning SocksRequest decoder removes itself from pipeline.
  */
-public class SocksAuthRequestDecoder extends ReplayingDecoder<SocksAuthRequestDecoder.State> {
-    private static final String name = "SOCKS_AUTH_REQUEST_DECODER";
-
-    public static String getName() {
-        return name;
-    }
+public class SocksAuthRequestDecoder extends ReplayingDecoder<State> {
 
     private SocksSubnegotiationVersion version;
     private int fieldLength;
@@ -47,7 +43,7 @@ public SocksAuthRequestDecoder() {
     protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksSubnegotiationVersion.fromByte(byteBuf.readByte());
+                version = SocksSubnegotiationVersion.valueOf(byteBuf.readByte());
                 if (version != SocksSubnegotiationVersion.AUTH_PASSWORD) {
                     break;
                 }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
index 6695484bd625..e3107fd1f772 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksAuthResponseDecoder.State;
 
 import java.util.List;
 
@@ -25,12 +26,7 @@
  * Decodes {@link ByteBuf}s into {@link SocksAuthResponse}.
  * Before returning SocksResponse decoder removes itself from pipeline.
  */
-public class SocksAuthResponseDecoder extends ReplayingDecoder<SocksAuthResponseDecoder.State> {
-    private static final String name = "SOCKS_AUTH_RESPONSE_DECODER";
-
-    public static String getName() {
-        return name;
-    }
+public class SocksAuthResponseDecoder extends ReplayingDecoder<State> {
 
     private SocksSubnegotiationVersion version;
     private SocksAuthStatus authStatus;
@@ -45,14 +41,14 @@ protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteB
             throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksSubnegotiationVersion.fromByte(byteBuf.readByte());
+                version = SocksSubnegotiationVersion.valueOf(byteBuf.readByte());
                 if (version != SocksSubnegotiationVersion.AUTH_PASSWORD) {
                     break;
                 }
                 checkpoint(State.READ_AUTH_RESPONSE);
             }
             case READ_AUTH_RESPONSE: {
-                authStatus = SocksAuthStatus.fromByte(byteBuf.readByte());
+                authStatus = SocksAuthStatus.valueOf(byteBuf.readByte());
                 msg = new SocksAuthResponse(authStatus);
             }
         }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthScheme.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthScheme.java
index 4d66dc9e66f3..6c2159bcf63f 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthScheme.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthScheme.java
@@ -28,7 +28,15 @@ public enum SocksAuthScheme {
         this.b = b;
     }
 
+    /**
+     * @deprecated Use {@link #valueOf(byte)} instead.
+     */
+    @Deprecated
     public static SocksAuthScheme fromByte(byte b) {
+        return valueOf(b);
+    }
+
+    public static SocksAuthScheme valueOf(byte b) {
         for (SocksAuthScheme code : values()) {
             if (code.b == b) {
                 return code;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthStatus.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthStatus.java
index a6bec04f2a40..6c32353373cc 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthStatus.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthStatus.java
@@ -26,7 +26,15 @@ public enum SocksAuthStatus {
         this.b = b;
     }
 
+    /**
+     * @deprecated Use {@link #valueOf(byte)} instead.
+     */
+    @Deprecated
     public static SocksAuthStatus fromByte(byte b) {
+        return valueOf(b);
+    }
+
+    public static SocksAuthStatus valueOf(byte b) {
         for (SocksAuthStatus code : values()) {
             if (code.b == b) {
                 return code;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java
index c73a5ca5acec..dfcdad87684c 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java
@@ -63,7 +63,7 @@ public SocksCmdRequest(SocksCmdType cmdType, SocksAddressType addressType, Strin
             case UNKNOWN:
                 break;
         }
-        if (port < 0 && port >= 65535) {
+        if (port <= 0 || port >= 65536) {
             throw new IllegalArgumentException(port + " is not in bounds 0 < x < 65536");
         }
         this.cmdType = cmdType;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
index 618f776fd052..518667bde65e 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksCmdRequestDecoder.State;
 import io.netty.util.CharsetUtil;
 
 import java.util.List;
@@ -26,17 +27,13 @@
  * Decodes {@link ByteBuf}s into {@link SocksCmdRequest}.
  * Before returning SocksRequest decoder removes itself from pipeline.
  */
-public class SocksCmdRequestDecoder extends ReplayingDecoder<SocksCmdRequestDecoder.State> {
-    private static final String name = "SOCKS_CMD_REQUEST_DECODER";
-
-    public static String getName() {
-        return name;
-    }
+public class SocksCmdRequestDecoder extends ReplayingDecoder<State> {
 
     private SocksProtocolVersion version;
     private int fieldLength;
     private SocksCmdType cmdType;
     private SocksAddressType addressType;
+    @SuppressWarnings("UnusedDeclaration")
     private byte reserved;
     private String host;
     private int port;
@@ -50,16 +47,16 @@ public SocksCmdRequestDecoder() {
     protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksProtocolVersion.fromByte(byteBuf.readByte());
+                version = SocksProtocolVersion.valueOf(byteBuf.readByte());
                 if (version != SocksProtocolVersion.SOCKS5) {
                     break;
                 }
                 checkpoint(State.READ_CMD_HEADER);
             }
             case READ_CMD_HEADER: {
-                cmdType = SocksCmdType.fromByte(byteBuf.readByte());
+                cmdType = SocksCmdType.valueOf(byteBuf.readByte());
                 reserved = byteBuf.readByte();
-                addressType = SocksAddressType.fromByte(byteBuf.readByte());
+                addressType = SocksAddressType.valueOf(byteBuf.readByte());
                 checkpoint(State.READ_CMD_ADDRESS);
             }
             case READ_CMD_ADDRESS: {
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java
index 567ceb63fff5..c918c3182a7a 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java
@@ -90,8 +90,8 @@ public SocksCmdResponse(SocksCmdStatus cmdStatus, SocksAddressType addressType,
             }
             host = IDN.toASCII(host);
         }
-        if (port < 0 && port >= 65535) {
-            throw new IllegalArgumentException(port + " is not in bounds 0 < x < 65536");
+        if (port < 0 || port > 65535) {
+            throw new IllegalArgumentException(port + " is not in bounds 0 <= x <= 65535");
         }
         this.cmdStatus = cmdStatus;
         this.addressType = addressType;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
index d93674b752db..0b4bca782af7 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksCmdResponseDecoder.State;
 import io.netty.util.CharsetUtil;
 
 import java.util.List;
@@ -26,12 +27,7 @@
  * Decodes {@link ByteBuf}s into {@link SocksCmdResponse}.
  * Before returning SocksResponse decoder removes itself from pipeline.
  */
-public class SocksCmdResponseDecoder extends ReplayingDecoder<SocksCmdResponseDecoder.State> {
-    private static final String name = "SOCKS_CMD_RESPONSE_DECODER";
-
-    public static String getName() {
-        return name;
-    }
+public class SocksCmdResponseDecoder extends ReplayingDecoder<State> {
 
     private SocksProtocolVersion version;
     private int fieldLength;
@@ -50,16 +46,16 @@ public SocksCmdResponseDecoder() {
     protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksProtocolVersion.fromByte(byteBuf.readByte());
+                version = SocksProtocolVersion.valueOf(byteBuf.readByte());
                 if (version != SocksProtocolVersion.SOCKS5) {
                     break;
                 }
                 checkpoint(State.READ_CMD_HEADER);
             }
             case READ_CMD_HEADER: {
-                cmdStatus = SocksCmdStatus.fromByte(byteBuf.readByte());
+                cmdStatus = SocksCmdStatus.valueOf(byteBuf.readByte());
                 reserved = byteBuf.readByte();
-                addressType = SocksAddressType.fromByte(byteBuf.readByte());
+                addressType = SocksAddressType.valueOf(byteBuf.readByte());
                 checkpoint(State.READ_CMD_ADDRESS);
             }
             case READ_CMD_ADDRESS: {
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdStatus.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdStatus.java
index 40c7b9d34634..51886e45d712 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdStatus.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdStatus.java
@@ -34,7 +34,15 @@ public enum SocksCmdStatus {
         this.b = b;
     }
 
+    /**
+     * @deprecated Use {@link #valueOf(byte)} instead.
+     */
+    @Deprecated
     public static SocksCmdStatus fromByte(byte b) {
+        return valueOf(b);
+    }
+
+    public static SocksCmdStatus valueOf(byte b) {
         for (SocksCmdStatus code : values()) {
             if (code.b == b) {
                 return code;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdType.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdType.java
index b236b7712cba..39d3f5f7ad28 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdType.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdType.java
@@ -28,7 +28,15 @@ public enum SocksCmdType {
         this.b = b;
     }
 
+    /**
+     * @deprecated Use {@link #valueOf(byte)} instead.
+     */
+    @Deprecated
     public static SocksCmdType fromByte(byte b) {
+        return valueOf(b);
+    }
+
+    public static SocksCmdType valueOf(byte b) {
         for (SocksCmdType code : values()) {
             if (code.b == b) {
                 return code;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
index 428e6d9b8a87..6604bb1d778a 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksInitRequestDecoder.State;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -26,12 +27,7 @@
  * Decodes {@link ByteBuf}s into {@link SocksInitRequest}.
  * Before returning SocksRequest decoder removes itself from pipeline.
  */
-public class SocksInitRequestDecoder extends ReplayingDecoder<SocksInitRequestDecoder.State> {
-    private static final String name = "SOCKS_INIT_REQUEST_DECODER";
-
-    public static String getName() {
-        return name;
-    }
+public class SocksInitRequestDecoder extends ReplayingDecoder<State> {
 
     private final List<SocksAuthScheme> authSchemes = new ArrayList<SocksAuthScheme>();
     private SocksProtocolVersion version;
@@ -46,7 +42,7 @@ public SocksInitRequestDecoder() {
     protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksProtocolVersion.fromByte(byteBuf.readByte());
+                version = SocksProtocolVersion.valueOf(byteBuf.readByte());
                 if (version != SocksProtocolVersion.SOCKS5) {
                     break;
                 }
@@ -56,7 +52,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> o
                 authSchemes.clear();
                 authSchemeNum = byteBuf.readByte();
                 for (int i = 0; i < authSchemeNum; i++) {
-                    authSchemes.add(SocksAuthScheme.fromByte(byteBuf.readByte()));
+                    authSchemes.add(SocksAuthScheme.valueOf(byteBuf.readByte()));
                 }
                 msg = new SocksInitRequest(authSchemes);
                 break;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
index 3ea3aaa38165..f7c4fe6521eb 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.socks.SocksInitResponseDecoder.State;
 
 import java.util.List;
 
@@ -25,12 +26,7 @@
  * Decodes {@link ByteBuf}s into {@link SocksInitResponse}.
  * Before returning SocksResponse decoder removes itself from pipeline.
  */
-public class SocksInitResponseDecoder extends ReplayingDecoder<SocksInitResponseDecoder.State> {
-    private static final String name = "SOCKS_INIT_RESPONSE_DECODER";
-
-    public static String getName() {
-        return name;
-    }
+public class SocksInitResponseDecoder extends ReplayingDecoder<State> {
 
     private SocksProtocolVersion version;
     private SocksAuthScheme authScheme;
@@ -45,14 +41,14 @@ public SocksInitResponseDecoder() {
     protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
-                version = SocksProtocolVersion.fromByte(byteBuf.readByte());
+                version = SocksProtocolVersion.valueOf(byteBuf.readByte());
                 if (version != SocksProtocolVersion.SOCKS5) {
                     break;
                 }
                 checkpoint(State.READ_PREFFERED_AUTH_TYPE);
             }
             case READ_PREFFERED_AUTH_TYPE: {
-                authScheme = SocksAuthScheme.fromByte(byteBuf.readByte());
+                authScheme = SocksAuthScheme.valueOf(byteBuf.readByte());
                 msg = new SocksInitResponse(authScheme);
                 break;
             }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessage.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessage.java
index ba88e41b6f2a..5f5f48ba39a3 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessage.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessage.java
@@ -55,7 +55,8 @@ public SocksProtocolVersion protocolVersion() {
     }
 
     /**
-     * Encode socks message into its byte representation and write it into byteBuf
+     * @deprecated Do not use; this method was intended for an internal use only.
      */
+    @Deprecated
     public abstract void encodeAsByteBuf(ByteBuf byteBuf);
 }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java
index b71b965fa72a..9653bf2de111 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java
@@ -28,13 +28,8 @@
  */
 @ChannelHandler.Sharable
 public class SocksMessageEncoder extends MessageToByteEncoder<SocksMessage> {
-    private static final String name = "SOCKS_MESSAGE_ENCODER";
-
-    public static String getName() {
-        return name;
-    }
-
     @Override
+    @SuppressWarnings("deprecation")
     protected void encode(ChannelHandlerContext ctx, SocksMessage msg, ByteBuf out) throws Exception {
         msg.encodeAsByteBuf(out);
     }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksProtocolVersion.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksProtocolVersion.java
index f5a242870293..67bbfd15f123 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksProtocolVersion.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksProtocolVersion.java
@@ -27,7 +27,15 @@ public enum SocksProtocolVersion {
         this.b = b;
     }
 
+    /**
+     * @deprecated Use {@link #valueOf(byte)} instead.
+     */
+    @Deprecated
     public static SocksProtocolVersion fromByte(byte b) {
+        return valueOf(b);
+    }
+
+    public static SocksProtocolVersion valueOf(byte b) {
         for (SocksProtocolVersion code : values()) {
             if (code.b == b) {
                 return code;
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksSubnegotiationVersion.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksSubnegotiationVersion.java
index f3846903ff7b..90e7b89041a0 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksSubnegotiationVersion.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksSubnegotiationVersion.java
@@ -26,7 +26,15 @@ public enum SocksSubnegotiationVersion {
         this.b = b;
     }
 
+    /**
+     * @deprecated Use {@link #valueOf(byte)} instead.
+     */
+    @Deprecated
     public static SocksSubnegotiationVersion fromByte(byte b) {
+        return valueOf(b);
+    }
+
+    public static SocksSubnegotiationVersion valueOf(byte b) {
         for (SocksSubnegotiationVersion code : values()) {
             if (code.b == b) {
                 return code;
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java
index ff8692a521b3..6c2cd9c48aa7 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java
@@ -30,7 +30,7 @@ public void testAuthRequestDecoder() {
         SocksAuthRequestDecoder decoder = new SocksAuthRequestDecoder();
         EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
-        msg = (SocksAuthRequest) embedder.readInbound();
+        msg = embedder.readInbound();
         assertEquals(msg.username(), username);
         assertEquals(msg.username(), password);
         assertNull(embedder.readInbound());
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
index 1604f53bb9a1..0f23b6dec94f 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
@@ -31,7 +31,7 @@ private static void testSocksAuthResponseDecoderWithDifferentParams(SocksAuthSta
         SocksAuthResponseDecoder decoder = new SocksAuthResponseDecoder();
         EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
-        msg = (SocksAuthResponse) embedder.readInbound();
+        msg = embedder.readInbound();
         assertSame(msg.authStatus(), authStatus);
         assertNull(embedder.readInbound());
     }
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseTest.java
index 0c1594132704..cde19e2c3436 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseTest.java
@@ -27,4 +27,5 @@ public void testConstructorParamsAreNotNull() {
             assertTrue(e instanceof NullPointerException);
         }
     }
+
 }
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
index 8ae2a726db42..0672453cd71c 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
@@ -39,7 +39,7 @@ private static void testSocksCmdRequestDecoderWithDifferentParams(SocksCmdType c
         if (msg.addressType() == SocksAddressType.UNKNOWN) {
             assertTrue(embedder.readInbound() instanceof UnknownSocksRequest);
         } else {
-            msg = (SocksCmdRequest) embedder.readInbound();
+            msg = embedder.readInbound();
             assertSame(msg.cmdType(), cmdType);
             assertSame(msg.addressType(), addressType);
             assertEquals(msg.host(), host);
@@ -51,7 +51,7 @@ private static void testSocksCmdRequestDecoderWithDifferentParams(SocksCmdType c
     @Test
     public void testCmdRequestDecoderIPv4() {
         String[] hosts = {"127.0.0.1", };
-        int[] ports = {0, 32769, 65535 };
+        int[] ports = {1, 32769, 65535 };
         for (SocksCmdType cmdType : SocksCmdType.values()) {
             for (String host : hosts) {
                 for (int port : ports) {
@@ -64,7 +64,7 @@ public void testCmdRequestDecoderIPv4() {
     @Test
     public void testCmdRequestDecoderIPv6() {
         String[] hosts = {SocksCommonUtils.ipv6toStr(IPAddressUtil.textToNumericFormatV6("::1"))};
-        int[] ports = {0, 32769, 65535};
+        int[] ports = {1, 32769, 65535};
         for (SocksCmdType cmdType : SocksCmdType.values()) {
             for (String host : hosts) {
                 for (int port : ports) {
@@ -88,7 +88,7 @@ public void testCmdRequestDecoderDomain() {
                           "例え.テスト",
                           "실례.테스트",
                           "உதாரணம்.பரிட்சை"};
-        int[] ports = {0, 32769, 65535};
+        int[] ports = {1, 32769, 65535};
         for (SocksCmdType cmdType : SocksCmdType.values()) {
             for (String host : hosts) {
                 for (int port : ports) {
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestTest.java
index 5eb163c33341..1fc0d9c19953 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestTest.java
@@ -23,19 +23,19 @@ public class SocksCmdRequestTest {
     @Test
     public void testConstructorParamsAreNotNull() {
         try {
-            new SocksCmdRequest(null, SocksAddressType.UNKNOWN, "", 0);
+            new SocksCmdRequest(null, SocksAddressType.UNKNOWN, "", 1);
         } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }
 
         try {
-            new SocksCmdRequest(SocksCmdType.UNKNOWN, null, "", 0);
+            new SocksCmdRequest(SocksCmdType.UNKNOWN, null, "", 1);
         } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }
 
         try {
-            new SocksCmdRequest(SocksCmdType.UNKNOWN, SocksAddressType.UNKNOWN, null, 0);
+            new SocksCmdRequest(SocksCmdType.UNKNOWN, SocksAddressType.UNKNOWN, null, 1);
         } catch (Exception e) {
             assertTrue(e instanceof NullPointerException);
         }
@@ -44,7 +44,7 @@ public void testConstructorParamsAreNotNull() {
     @Test
     public void testIPv4CorrectAddress() {
         try {
-            new SocksCmdRequest(SocksCmdType.BIND, SocksAddressType.IPv4, "54.54.1111.253", 0);
+            new SocksCmdRequest(SocksCmdType.BIND, SocksAddressType.IPv4, "54.54.1111.253", 1);
         } catch (Exception e) {
             assertTrue(e instanceof IllegalArgumentException);
         }
@@ -53,7 +53,7 @@ public void testIPv4CorrectAddress() {
     @Test
     public void testIPv6CorrectAddress() {
         try {
-            new SocksCmdRequest(SocksCmdType.BIND, SocksAddressType.IPv6, "xxx:xxx:xxx", 0);
+            new SocksCmdRequest(SocksCmdType.BIND, SocksAddressType.IPv6, "xxx:xxx:xxx", 1);
         } catch (Exception e) {
             assertTrue(e instanceof IllegalArgumentException);
         }
@@ -66,7 +66,7 @@ public void testIDNNotExceeds255CharsLimit() {
                     "παράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμή" +
                     "παράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμή" +
                     "παράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμή" +
-                    "παράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμή", 0);
+                    "παράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμήπαράδειγμα.δοκιμή", 1);
         } catch (Exception e) {
             assertTrue(e instanceof IllegalArgumentException);
         }
@@ -76,7 +76,7 @@ public void testIDNNotExceeds255CharsLimit() {
     public void testValidPortRange() {
         try {
             new SocksCmdRequest(SocksCmdType.BIND, SocksAddressType.DOMAIN,
-                    "παράδειγμα.δοκιμήπαράδει", -1);
+                    "παράδειγμα.δοκιμήπαράδει", 0);
         } catch (Exception e) {
             assertTrue(e instanceof IllegalArgumentException);
         }
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
index 058a06f44cdd..279dcbabec1b 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
@@ -35,7 +35,7 @@ private static void testSocksCmdResponseDecoderWithDifferentParams(
         if (addressType == SocksAddressType.UNKNOWN) {
             assertTrue(embedder.readInbound() instanceof UnknownSocksResponse);
         } else {
-            msg = (SocksResponse) embedder.readInbound();
+            msg = embedder.readInbound();
             assertEquals(((SocksCmdResponse) msg).cmdStatus(), cmdStatus);
             if (host != null) {
                 assertEquals(((SocksCmdResponse) msg).host(), host);
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseTest.java
index f8d69f138f4d..420c5108f7b6 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseTest.java
@@ -123,4 +123,18 @@ private static void assertByteBufEquals(byte[] expected, ByteBuf actual) {
         assertArrayEquals("Generated response differs from expected", expected, actualBytes);
     }
 
+    @Test
+    public void testValidPortRange() {
+        try {
+            new SocksCmdResponse(SocksCmdStatus.SUCCESS, SocksAddressType.IPv4, "127.0.0", 0);
+        } catch (Exception e) {
+            assertTrue(e instanceof IllegalArgumentException);
+        }
+
+        try {
+            new SocksCmdResponse(SocksCmdStatus.SUCCESS, SocksAddressType.IPv4, "127.0.0", 65536);
+        } catch (Exception e) {
+            assertTrue(e instanceof IllegalArgumentException);
+        }
+    }
 }
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java
index f4a54dbad076..35f81ca363d0 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java
@@ -27,6 +27,7 @@ private SocksCommonTestUtils() {
         //NOOP
     }
 
+    @SuppressWarnings("deprecation")
     public static void writeMessageIntoEmbedder(EmbeddedChannel embedder, SocksMessage msg) {
         ByteBuf buf = Unpooled.buffer();
         msg.encodeAsByteBuf(buf);
diff --git a/codec-stomp/pom.xml b/codec-stomp/pom.xml
new file mode 100644
index 000000000000..80f6461b6aeb
--- /dev/null
+++ b/codec-stomp/pom.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2014 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>io.netty</groupId>
+    <artifactId>netty-parent</artifactId>
+    <version>4.1.0.Beta1</version>
+  </parent>
+
+  <artifactId>netty-codec-stomp</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Netty/Codec/Stomp</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+</project>
+
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultLastStompContentSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultLastStompContentSubframe.java
new file mode 100644
index 000000000000..eaca9f9900dd
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultLastStompContentSubframe.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+
+/**
+ * The default implementation for the {@link LastStompContentSubframe}.
+ */
+public class DefaultLastStompContentSubframe extends DefaultStompContentSubframe implements LastStompContentSubframe {
+
+    public DefaultLastStompContentSubframe(ByteBuf content) {
+        super(content);
+    }
+
+    @Override
+    public DefaultLastStompContentSubframe retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public LastStompContentSubframe retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public LastStompContentSubframe touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public LastStompContentSubframe touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+
+    @Override
+    public LastStompContentSubframe copy() {
+        return new DefaultLastStompContentSubframe(content().copy());
+    }
+
+    @Override
+    public LastStompContentSubframe duplicate() {
+        return new DefaultLastStompContentSubframe(content().duplicate());
+    }
+
+    @Override
+    public String toString() {
+        return "DefaultLastStompContent{" +
+                "decoderResult=" + decoderResult() +
+                '}';
+    }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompContentSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompContentSubframe.java
new file mode 100644
index 000000000000..d38566c7b11a
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompContentSubframe.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+
+import io.netty.buffer.ByteBuf;
+import io.netty.handler.codec.DecoderResult;
+
+/**
+ * The default {@link StompContentSubframe} implementation.
+ */
+public class DefaultStompContentSubframe implements StompContentSubframe {
+    private DecoderResult decoderResult = DecoderResult.SUCCESS;
+    private final ByteBuf content;
+
+    public DefaultStompContentSubframe(ByteBuf content) {
+        if (content == null) {
+            throw new NullPointerException("content");
+        }
+        this.content = content;
+    }
+
+    @Override
+    public ByteBuf content() {
+        return content;
+    }
+
+    @Override
+    public StompContentSubframe copy() {
+        return new DefaultStompContentSubframe(content().copy());
+    }
+
+    @Override
+    public StompContentSubframe duplicate() {
+        return new DefaultStompContentSubframe(content().duplicate());
+    }
+
+    @Override
+    public int refCnt() {
+        return content().refCnt();
+    }
+
+    @Override
+    public StompContentSubframe retain() {
+        content().retain();
+        return this;
+    }
+
+    @Override
+    public StompContentSubframe retain(int increment) {
+        content().retain(increment);
+        return this;
+    }
+
+    @Override
+    public StompContentSubframe touch() {
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public StompContentSubframe touch(Object hint) {
+        content.touch(hint);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        return content().release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        return content().release(decrement);
+    }
+
+    @Override
+    public DecoderResult decoderResult() {
+        return decoderResult;
+    }
+
+    @Override
+    public void setDecoderResult(DecoderResult decoderResult) {
+        this.decoderResult = decoderResult;
+    }
+
+    @Override
+    public String toString() {
+        return "DefaultStompContent{" +
+            "decoderResult=" + decoderResult +
+            '}';
+    }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java
new file mode 100644
index 000000000000..90ed4a7950dd
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.util.CharsetUtil;
+
+/**
+ * Default implementation of {@link StompFrame}.
+ */
+public class DefaultStompFrame extends DefaultStompHeadersSubframe implements StompFrame {
+
+    private final ByteBuf content;
+
+    public DefaultStompFrame(StompCommand command) {
+        this(command, Unpooled.buffer(0));
+        if (command == null) {
+            throw new NullPointerException("command");
+        }
+    }
+
+    public DefaultStompFrame(StompCommand command, ByteBuf content) {
+        super(command);
+        if (content == null) {
+            throw new NullPointerException("content");
+        }
+        this.content = content;
+    }
+
+    @Override
+    public ByteBuf content() {
+        return content;
+    }
+
+    @Override
+    public StompFrame copy() {
+        return new DefaultStompFrame(command, content.copy());
+    }
+
+    @Override
+    public StompFrame duplicate() {
+        return new DefaultStompFrame(command, content.duplicate());
+    }
+
+    @Override
+    public int refCnt() {
+        return content.refCnt();
+    }
+
+    @Override
+    public StompFrame retain() {
+        content.retain();
+        return this;
+    }
+
+    @Override
+    public StompFrame retain(int increment) {
+        content.retain();
+        return this;
+    }
+
+    @Override
+    public StompFrame touch() {
+        content.touch();
+        return this;
+    }
+
+    @Override
+    public StompFrame touch(Object hint) {
+        content.touch(hint);
+        return this;
+    }
+
+    @Override
+    public boolean release() {
+        return content.release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        return content.release(decrement);
+    }
+
+    @Override
+    public String toString() {
+        return "DefaultFullStompFrame{" +
+            "command=" + command +
+            ", headers=" + headers +
+            ", content=" + content.toString(CharsetUtil.UTF_8) +
+            '}';
+    }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeaders.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeaders.java
new file mode 100644
index 000000000000..7df231a82f0c
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeaders.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.stomp;
+
+import io.netty.handler.codec.DefaultTextHeaders;
+import io.netty.handler.codec.TextHeaderProcessor;
+import io.netty.handler.codec.TextHeaders;
+
+public class DefaultStompHeaders extends DefaultTextHeaders implements StompHeaders {
+
+    @Override
+    public StompHeaders add(CharSequence name, Object value) {
+        super.add(name, value);
+        return this;
+    }
+
+    @Override
+    public StompHeaders add(CharSequence name, Iterable<?> values) {
+        super.add(name, values);
+        return this;
+    }
+
+    @Override
+    public StompHeaders add(CharSequence name, Object... values) {
+        super.add(name, values);
+        return this;
+    }
+
+    @Override
+    public StompHeaders add(TextHeaders headers) {
+        super.add(headers);
+        return this;
+    }
+
+    @Override
+    public StompHeaders set(CharSequence name, Object value) {
+        super.set(name, value);
+        return this;
+    }
+
+    @Override
+    public StompHeaders set(CharSequence name, Object... values) {
+        super.set(name, values);
+        return this;
+    }
+
+    @Override
+    public StompHeaders set(CharSequence name, Iterable<?> values) {
+        super.set(name, values);
+        return this;
+    }
+
+    @Override
+    public StompHeaders set(TextHeaders headers) {
+        super.set(headers);
+        return this;
+    }
+
+    @Override
+    public StompHeaders clear() {
+        super.clear();
+        return this;
+    }
+
+    @Override
+    public StompHeaders forEachEntry(TextHeaderProcessor processor) {
+        super.forEachEntry(processor);
+        return this;
+    }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeadersSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeadersSubframe.java
new file mode 100644
index 000000000000..ca7db33d13c9
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeadersSubframe.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.handler.codec.DecoderResult;
+
+/**
+ * Default implementation of {@link StompHeadersSubframe}.
+ */
+public class DefaultStompHeadersSubframe implements StompHeadersSubframe {
+
+    protected final StompCommand command;
+    protected DecoderResult decoderResult = DecoderResult.SUCCESS;
+    protected final StompHeaders headers = new DefaultStompHeaders();
+
+    public DefaultStompHeadersSubframe(StompCommand command) {
+        if (command == null) {
+            throw new NullPointerException("command");
+        }
+        this.command = command;
+    }
+
+    @Override
+    public StompCommand command() {
+        return command;
+    }
+
+    @Override
+    public StompHeaders headers() {
+        return headers;
+    }
+
+    @Override
+    public DecoderResult decoderResult() {
+        return decoderResult;
+    }
+
+    @Override
+    public void setDecoderResult(DecoderResult decoderResult) {
+        this.decoderResult = decoderResult;
+    }
+
+    @Override
+    public String toString() {
+        return "StompFrame{" +
+            "command=" + command +
+            ", headers=" + headers +
+            '}';
+    }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/LastStompContentSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/LastStompContentSubframe.java
new file mode 100644
index 000000000000..138d24edbcdc
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/LastStompContentSubframe.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.DecoderResult;
+
+/**
+ * The last {@link StompContentSubframe} which signals the end of the content batch
+ * <p/>
+ * Note, even when no content is emitted by the protocol, an
+ * empty {@link LastStompContentSubframe} is issued to make the upstream parsing
+ * easier.
+ */
+public interface LastStompContentSubframe extends StompContentSubframe {
+
+    LastStompContentSubframe EMPTY_LAST_CONTENT = new LastStompContentSubframe() {
+        @Override
+        public ByteBuf content() {
+            return Unpooled.EMPTY_BUFFER;
+        }
+
+        @Override
+        public LastStompContentSubframe copy() {
+            return EMPTY_LAST_CONTENT;
+        }
+
+        @Override
+        public LastStompContentSubframe duplicate() {
+            return this;
+        }
+
+        @Override
+        public LastStompContentSubframe retain() {
+            return this;
+        }
+
+        @Override
+        public LastStompContentSubframe retain(int increment) {
+            return this;
+        }
+
+        @Override
+        public LastStompContentSubframe touch() {
+            return this;
+        }
+
+        @Override
+        public LastStompContentSubframe touch(Object hint) {
+            return this;
+        }
+
+        @Override
+        public int refCnt() {
+            return 1;
+        }
+
+        @Override
+        public boolean release() {
+            return false;
+        }
+
+        @Override
+        public boolean release(int decrement) {
+            return false;
+        }
+
+        @Override
+        public DecoderResult decoderResult() {
+            return DecoderResult.SUCCESS;
+        }
+
+        @Override
+        public void setDecoderResult(DecoderResult result) {
+            throw new UnsupportedOperationException("read only");
+        }
+    };
+
+    @Override
+    LastStompContentSubframe copy();
+
+    @Override
+    LastStompContentSubframe duplicate();
+
+    @Override
+    LastStompContentSubframe retain();
+
+    @Override
+    LastStompContentSubframe retain(int increment);
+
+    @Override
+    LastStompContentSubframe touch();
+
+    @Override
+    LastStompContentSubframe touch(Object hint);
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompCommand.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompCommand.java
new file mode 100644
index 000000000000..789be1ef0f72
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompCommand.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+/**
+ * STOMP command
+ */
+public enum StompCommand {
+    STOMP,
+    CONNECT,
+    CONNECTED,
+    SEND,
+    SUBSCRIBE,
+    UNSUBSCRIBE,
+    ACK,
+    NACK,
+    BEGIN,
+    DISCONNECT,
+    MESSAGE,
+    RECEIPT,
+    ERROR,
+    UNKNOWN
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompConstants.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompConstants.java
new file mode 100644
index 000000000000..3c9401ab2ede
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompConstants.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+final class StompConstants {
+
+    static final byte CR = 13;
+    static final byte LF = 10;
+    static final byte NUL = 0;
+    static final byte COLON = 58;
+
+    private StompConstants() { }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompContentSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompContentSubframe.java
new file mode 100644
index 000000000000..7b55edb89375
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompContentSubframe.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBufHolder;
+import io.netty.channel.ChannelPipeline;
+
+/**
+ * An STOMP chunk which is used for STOMP chunked transfer-encoding. {@link StompSubframeDecoder} generates
+ * {@link StompContentSubframe} after {@link StompHeadersSubframe} when the content is large or the encoding of
+ * the content is 'chunked.  If you prefer not to receive multiple {@link StompSubframe}s for a single
+ * {@link StompFrame}, place {@link StompSubframeAggregator} after {@link StompSubframeDecoder} in the
+ * {@link ChannelPipeline}.
+ */
+public interface StompContentSubframe extends ByteBufHolder, StompSubframe {
+    @Override
+    StompContentSubframe copy();
+
+    @Override
+    StompContentSubframe duplicate();
+
+    @Override
+    StompContentSubframe retain();
+
+    @Override
+    StompContentSubframe retain(int increment);
+
+    @Override
+    StompContentSubframe touch();
+
+    @Override
+    StompContentSubframe touch(Object hint);
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompFrame.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompFrame.java
new file mode 100644
index 000000000000..254ac6073c3a
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompFrame.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+/**
+ * Combines {@link StompHeadersSubframe} and {@link LastStompContentSubframe} into one
+ * frame. So it represent a <i>complete</i> STOMP frame.
+ */
+public interface StompFrame extends StompHeadersSubframe, LastStompContentSubframe {
+    @Override
+    StompFrame copy();
+
+    @Override
+    StompFrame duplicate();
+
+    @Override
+    StompFrame retain();
+
+    @Override
+    StompFrame retain(int increment);
+
+    @Override
+    StompFrame touch();
+
+    @Override
+    StompFrame touch(Object hint);
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeaders.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeaders.java
new file mode 100644
index 000000000000..b929bb67dce8
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeaders.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.handler.codec.AsciiString;
+import io.netty.handler.codec.TextHeaderProcessor;
+import io.netty.handler.codec.TextHeaders;
+
+/**
+ * The multimap data structure for the STOMP header names and values. It also provides the constants for the standard
+ * STOMP header names and values.
+ */
+public interface StompHeaders extends TextHeaders {
+
+    AsciiString ACCEPT_VERSION = new AsciiString("accept-version");
+    AsciiString HOST = new AsciiString("host");
+    AsciiString LOGIN = new AsciiString("login");
+    AsciiString PASSCODE = new AsciiString("passcode");
+    AsciiString HEART_BEAT = new AsciiString("heart-beat");
+    AsciiString VERSION = new AsciiString("version");
+    AsciiString SESSION = new AsciiString("session");
+    AsciiString SERVER = new AsciiString("server");
+    AsciiString DESTINATION = new AsciiString("destination");
+    AsciiString ID = new AsciiString("id");
+    AsciiString ACK = new AsciiString("ack");
+    AsciiString TRANSACTION = new AsciiString("transaction");
+    AsciiString RECEIPT = new AsciiString("receipt");
+    AsciiString MESSAGE_ID = new AsciiString("message-id");
+    AsciiString SUBSCRIPTION = new AsciiString("subscription");
+    AsciiString RECEIPT_ID = new AsciiString("receipt-id");
+    AsciiString MESSAGE = new AsciiString("message");
+    AsciiString CONTENT_LENGTH = new AsciiString("content-length");
+    AsciiString CONTENT_TYPE = new AsciiString("content-type");
+
+    @Override
+    StompHeaders add(CharSequence name, Object value);
+
+    @Override
+    StompHeaders add(CharSequence name, Iterable<?> values);
+
+    @Override
+    StompHeaders add(CharSequence name, Object... values);
+
+    @Override
+    StompHeaders add(TextHeaders headers);
+
+    @Override
+    StompHeaders set(CharSequence name, Object value);
+
+    @Override
+    StompHeaders set(CharSequence name, Iterable<?> values);
+
+    @Override
+    StompHeaders set(CharSequence name, Object... values);
+
+    @Override
+    StompHeaders set(TextHeaders headers);
+
+    @Override
+    StompHeaders clear();
+
+    @Override
+    StompHeaders forEachEntry(TextHeaderProcessor processor);
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeadersSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeadersSubframe.java
new file mode 100644
index 000000000000..064be80d6292
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeadersSubframe.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+/**
+ * An interface that defines a {@link StompFrame}'s command and headers.
+ *
+ * @see StompCommand
+ * @see StompHeaders
+ */
+public interface StompHeadersSubframe extends StompSubframe {
+    /**
+     * Returns command of this frame.
+     */
+    StompCommand command();
+
+    /**
+     * Returns headers of this frame.
+     */
+    StompHeaders headers();
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframe.java
new file mode 100644
index 000000000000..bedba180468a
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframe.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.handler.codec.DecoderResultProvider;
+
+/**
+ * Defines a common interface for all {@link StompSubframe} implementations.
+ */
+public interface StompSubframe extends DecoderResultProvider { }
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeAggregator.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeAggregator.java
new file mode 100644
index 000000000000..11977da62102
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeAggregator.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelPipeline;
+import io.netty.handler.codec.AsciiString;
+import io.netty.handler.codec.MessageAggregator;
+import io.netty.handler.codec.TooLongFrameException;
+
+/**
+ * A {@link ChannelHandler} that aggregates an {@link StompHeadersSubframe}
+ * and its following {@link StompContentSubframe}s into a single {@link StompFrame}.
+ * It is useful when you don't want to take care of STOMP frames whose content is 'chunked'.  Insert this
+ * handler after {@link StompSubframeDecoder} in the {@link ChannelPipeline}:
+ */
+public class StompSubframeAggregator
+        extends MessageAggregator<StompSubframe, StompHeadersSubframe, StompContentSubframe, StompFrame> {
+
+    /**
+     * Creates a new instance.
+     *
+     * @param maxContentLength
+     *        the maximum length of the aggregated content.
+     *        If the length of the aggregated content exceeds this value,
+     *        a {@link TooLongFrameException} will be raised.
+     */
+    public StompSubframeAggregator(int maxContentLength) {
+        super(maxContentLength);
+    }
+
+    @Override
+    protected boolean isStartMessage(StompSubframe msg) throws Exception {
+        return msg instanceof StompHeadersSubframe;
+    }
+
+    @Override
+    protected boolean isContentMessage(StompSubframe msg) throws Exception {
+        return msg instanceof StompContentSubframe;
+    }
+
+    @Override
+    protected boolean isLastContentMessage(StompContentSubframe msg) throws Exception {
+        return msg instanceof LastStompContentSubframe;
+    }
+
+    @Override
+    protected boolean isAggregated(StompSubframe msg) throws Exception {
+        return msg instanceof StompFrame;
+    }
+
+    @Override
+    protected boolean hasContentLength(StompHeadersSubframe start) throws Exception {
+        return start.headers().contains(StompHeaders.CONTENT_LENGTH);
+    }
+
+    @Override
+    protected long contentLength(StompHeadersSubframe start) throws Exception {
+        CharSequence value = start.headers().get(StompHeaders.CONTENT_LENGTH);
+        if (value instanceof AsciiString) {
+            return ((AsciiString) value).parseLong();
+        }
+
+        return Long.parseLong(value.toString());
+    }
+
+    @Override
+    protected Object newContinueResponse(StompHeadersSubframe start) throws Exception {
+        return null;
+    }
+
+    @Override
+    protected StompFrame beginAggregation(StompHeadersSubframe start, ByteBuf content) throws Exception {
+        StompFrame ret = new DefaultStompFrame(start.command(), content);
+        ret.headers().set(start.headers());
+        return ret;
+    }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java
new file mode 100644
index 000000000000..35dc176b7157
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java
@@ -0,0 +1,284 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.AsciiString;
+import io.netty.handler.codec.DecoderException;
+import io.netty.handler.codec.DecoderResult;
+import io.netty.handler.codec.ReplayingDecoder;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.handler.codec.stomp.StompSubframeDecoder.State;
+import io.netty.util.internal.AppendableCharSequence;
+import io.netty.util.internal.StringUtil;
+
+import java.util.List;
+import java.util.Locale;
+
+import static io.netty.buffer.ByteBufUtil.*;
+
+/**
+ * Decodes {@link ByteBuf}s into {@link StompHeadersSubframe}s and
+ * {@link StompContentSubframe}s.
+ *
+ * <h3>Parameters to control memory consumption: </h3>
+ * {@code maxLineLength} the maximum length of line -
+ * restricts length of command and header lines
+ * If the length of the initial line exceeds this value, a
+ * {@link TooLongFrameException} will be raised.
+ * <br>
+ * {@code maxChunkSize}
+ * The maximum length of the content or each chunk.  If the content length
+ * (or the length of each chunk) exceeds this value, the content or chunk
+ * ill be split into multiple {@link StompContentSubframe}s whose length is
+ * {@code maxChunkSize} at maximum.
+ *
+ * <h3>Chunked Content</h3>
+ *
+ * If the content of a stomp message is greater than {@code maxChunkSize}
+ * the transfer encoding of the HTTP message is 'chunked', this decoder
+ * generates multiple {@link StompContentSubframe} instances to avoid excessive memory
+ * consumption. Note, that every message, even with no content decodes with
+ * {@link LastStompContentSubframe} at the end to simplify upstream message parsing.
+ */
+public class StompSubframeDecoder extends ReplayingDecoder<State> {
+
+    private static final int DEFAULT_CHUNK_SIZE = 8132;
+    private static final int DEFAULT_MAX_LINE_LENGTH = 1024;
+
+    enum State {
+        SKIP_CONTROL_CHARACTERS,
+        READ_HEADERS,
+        READ_CONTENT,
+        FINALIZE_FRAME_READ,
+        BAD_FRAME,
+        INVALID_CHUNK
+    }
+
+    private final int maxLineLength;
+    private final int maxChunkSize;
+    private int alreadyReadChunkSize;
+    private LastStompContentSubframe lastContent;
+    private long contentLength;
+
+    public StompSubframeDecoder() {
+        this(DEFAULT_MAX_LINE_LENGTH, DEFAULT_CHUNK_SIZE);
+    }
+
+    public StompSubframeDecoder(int maxLineLength, int maxChunkSize) {
+        super(State.SKIP_CONTROL_CHARACTERS);
+        if (maxLineLength <= 0) {
+            throw new IllegalArgumentException(
+                    "maxLineLength must be a positive integer: " +
+                            maxLineLength);
+        }
+        if (maxChunkSize <= 0) {
+            throw new IllegalArgumentException(
+                    "maxChunkSize must be a positive integer: " +
+                            maxChunkSize);
+        }
+        this.maxChunkSize = maxChunkSize;
+        this.maxLineLength = maxLineLength;
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        switch (state()) {
+            case SKIP_CONTROL_CHARACTERS:
+                skipControlCharacters(in);
+                checkpoint(State.READ_HEADERS);
+                // Fall through.
+            case READ_HEADERS:
+                StompCommand command = StompCommand.UNKNOWN;
+                StompHeadersSubframe frame = null;
+                try {
+                    command = readCommand(in);
+                    frame = new DefaultStompHeadersSubframe(command);
+                    checkpoint(readHeaders(in, frame.headers()));
+                    out.add(frame);
+                } catch (Exception e) {
+                    if (frame == null) {
+                        frame = new DefaultStompHeadersSubframe(command);
+                    }
+                    frame.setDecoderResult(DecoderResult.failure(e));
+                    out.add(frame);
+                    checkpoint(State.BAD_FRAME);
+                    return;
+                }
+                break;
+            case BAD_FRAME:
+                in.skipBytes(actualReadableBytes());
+                return;
+        }
+        try {
+            switch (state()) {
+                case READ_CONTENT:
+                    int toRead = in.readableBytes();
+                    if (toRead == 0) {
+                        return;
+                    }
+                    if (toRead > maxChunkSize) {
+                        toRead = maxChunkSize;
+                    }
+                    int remainingLength = (int) (contentLength - alreadyReadChunkSize);
+                    if (toRead > remainingLength) {
+                        toRead = remainingLength;
+                    }
+                    ByteBuf chunkBuffer = readBytes(ctx.alloc(), in, toRead);
+                    if ((alreadyReadChunkSize += toRead) >= contentLength) {
+                        lastContent = new DefaultLastStompContentSubframe(chunkBuffer);
+                        checkpoint(State.FINALIZE_FRAME_READ);
+                    } else {
+                        DefaultStompContentSubframe chunk;
+                        chunk = new DefaultStompContentSubframe(chunkBuffer);
+                        out.add(chunk);
+                    }
+                    if (alreadyReadChunkSize < contentLength) {
+                        return;
+                    }
+                    // Fall through.
+                case FINALIZE_FRAME_READ:
+                    skipNullCharacter(in);
+                    if (lastContent == null) {
+                        lastContent = LastStompContentSubframe.EMPTY_LAST_CONTENT;
+                    }
+                    out.add(lastContent);
+                    resetDecoder();
+            }
+        } catch (Exception e) {
+            StompContentSubframe errorContent = new DefaultLastStompContentSubframe(Unpooled.EMPTY_BUFFER);
+            errorContent.setDecoderResult(DecoderResult.failure(e));
+            out.add(errorContent);
+            checkpoint(State.BAD_FRAME);
+        }
+    }
+
+    private StompCommand readCommand(ByteBuf in) {
+        String commandStr = readLine(in, maxLineLength);
+        StompCommand command = null;
+        try {
+            command = StompCommand.valueOf(commandStr);
+        } catch (IllegalArgumentException iae) {
+            //do nothing
+        }
+        if (command == null) {
+            commandStr = commandStr.toUpperCase(Locale.US);
+            try {
+                command = StompCommand.valueOf(commandStr);
+            } catch (IllegalArgumentException iae) {
+                //do nothing
+            }
+        }
+        if (command == null) {
+            throw new DecoderException("failed to read command from channel");
+        }
+        return command;
+    }
+
+    private State readHeaders(ByteBuf buffer, StompHeaders headers) {
+        for (;;) {
+            String line = readLine(buffer, maxLineLength);
+            if (!line.isEmpty()) {
+                String[] split = StringUtil.split(line, ':');
+                if (split.length == 2) {
+                    headers.add(split[0], split[1]);
+                }
+            } else {
+                long contentLength = -1;
+                if (headers.contains(StompHeaders.CONTENT_LENGTH))  {
+                    contentLength = getContentLength(headers, 0);
+                } else {
+                    int globalIndex = indexOf(buffer, buffer.readerIndex(),
+                            buffer.writerIndex(), StompConstants.NUL);
+                    if (globalIndex != -1) {
+                        contentLength = globalIndex - buffer.readerIndex();
+                    }
+                }
+                if (contentLength > 0) {
+                    this.contentLength = contentLength;
+                    return State.READ_CONTENT;
+                } else {
+                    return State.FINALIZE_FRAME_READ;
+                }
+            }
+        }
+    }
+
+    private static long getContentLength(StompHeaders headers, long defaultValue) {
+        CharSequence contentLength = headers.get(StompHeaders.CONTENT_LENGTH);
+        if (contentLength != null) {
+            try {
+                if (contentLength instanceof AsciiString) {
+                    return ((AsciiString) contentLength).parseLong();
+                } else {
+                    return Long.parseLong(contentLength.toString());
+                }
+            } catch (NumberFormatException ignored) {
+                return defaultValue;
+            }
+        }
+        return defaultValue;
+    }
+
+    private static void skipNullCharacter(ByteBuf buffer) {
+        byte b = buffer.readByte();
+        if (b != StompConstants.NUL) {
+            throw new IllegalStateException("unexpected byte in buffer " + b + " while expecting NULL byte");
+        }
+    }
+
+    private static void skipControlCharacters(ByteBuf buffer) {
+        byte b;
+        for (;;) {
+            b = buffer.readByte();
+            if (b != StompConstants.CR && b != StompConstants.LF) {
+                buffer.readerIndex(buffer.readerIndex() - 1);
+                break;
+            }
+        }
+    }
+
+    private static String readLine(ByteBuf buffer, int maxLineLength) {
+        AppendableCharSequence buf = new AppendableCharSequence(128);
+        int lineLength = 0;
+        for (;;) {
+            byte nextByte = buffer.readByte();
+            if (nextByte == StompConstants.CR) {
+                nextByte = buffer.readByte();
+                if (nextByte == StompConstants.LF) {
+                    return buf.toString();
+                }
+            } else if (nextByte == StompConstants.LF) {
+                return buf.toString();
+            } else {
+                if (lineLength >= maxLineLength) {
+                    throw new TooLongFrameException("An STOMP line is larger than " + maxLineLength + " bytes.");
+                }
+                lineLength ++;
+                buf.append((char) nextByte);
+            }
+        }
+    }
+
+    private void resetDecoder() {
+        checkpoint(State.SKIP_CONTROL_CHARACTERS);
+        contentLength = 0;
+        alreadyReadChunkSize = 0;
+        lastContent = null;
+    }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeEncoder.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeEncoder.java
new file mode 100644
index 000000000000..4da373996773
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeEncoder.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.AsciiHeadersEncoder;
+import io.netty.handler.codec.AsciiHeadersEncoder.NewlineType;
+import io.netty.handler.codec.AsciiHeadersEncoder.SeparatorType;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.util.CharsetUtil;
+
+import java.util.List;
+
+/**
+ * Encodes a {@link StompFrame} or a {@link StompSubframe} into a {@link ByteBuf}.
+ */
+public class StompSubframeEncoder extends MessageToMessageEncoder<StompSubframe> {
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, StompSubframe msg, List<Object> out) throws Exception {
+        if (msg instanceof StompFrame) {
+            StompFrame frame = (StompFrame) msg;
+            ByteBuf frameBuf = encodeFrame(frame, ctx);
+            out.add(frameBuf);
+            ByteBuf contentBuf = encodeContent(frame, ctx);
+            out.add(contentBuf);
+        } else if (msg instanceof StompHeadersSubframe) {
+            StompHeadersSubframe frame = (StompHeadersSubframe) msg;
+            ByteBuf buf = encodeFrame(frame, ctx);
+            out.add(buf);
+        } else if (msg instanceof StompContentSubframe) {
+            StompContentSubframe stompContentSubframe = (StompContentSubframe) msg;
+            ByteBuf buf = encodeContent(stompContentSubframe, ctx);
+            out.add(buf);
+        }
+    }
+
+    private static ByteBuf encodeContent(StompContentSubframe content, ChannelHandlerContext ctx) {
+        if (content instanceof LastStompContentSubframe) {
+            ByteBuf buf = ctx.alloc().buffer(content.content().readableBytes() + 1);
+            buf.writeBytes(content.content());
+            buf.writeByte(StompConstants.NUL);
+            return buf;
+        } else {
+            return content.content().retain();
+        }
+    }
+
+    private static ByteBuf encodeFrame(StompHeadersSubframe frame, ChannelHandlerContext ctx) {
+        ByteBuf buf = ctx.alloc().buffer();
+
+        buf.writeBytes(frame.command().toString().getBytes(CharsetUtil.US_ASCII));
+        buf.writeByte(StompConstants.LF);
+        frame.headers().forEachEntry(new AsciiHeadersEncoder(buf, SeparatorType.COLON, NewlineType.LF));
+        buf.writeByte(StompConstants.LF);
+        return buf;
+    }
+}
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/package-info.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/package-info.java
new file mode 100644
index 000000000000..dba4f936b936
--- /dev/null
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * <a href="http://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">STOMP</a> codec
+ */
+package io.netty.handler.codec.stomp;
diff --git a/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeAggregatorTest.java b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeAggregatorTest.java
new file mode 100644
index 000000000000..27c8732563db
--- /dev/null
+++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeAggregatorTest.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.util.CharsetUtil;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class StompSubframeAggregatorTest {
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(new StompSubframeDecoder(), new StompSubframeAggregator(100000));
+    }
+
+    @After
+    public void teardown() throws Exception {
+        Assert.assertFalse(channel.finish());
+    }
+
+    @Test
+    public void testSingleFrameDecoding() {
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.CONNECT_FRAME.getBytes());
+        channel.writeInbound(incoming);
+        StompHeadersSubframe frame = channel.readInbound();
+        Assert.assertTrue(frame instanceof StompFrame);
+        Assert.assertNull(channel.readInbound());
+    }
+
+    @Test
+    public void testSingleFrameWithBodyAndContentLength() {
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.SEND_FRAME_2.getBytes());
+        channel.writeInbound(incoming);
+        StompFrame frame = channel.readInbound();
+        Assert.assertNotNull(frame);
+        Assert.assertEquals(StompCommand.SEND, frame.command());
+        Assert.assertEquals("hello, queue a!!!", frame.content().toString(CharsetUtil.UTF_8));
+        Assert.assertNull(channel.readInbound());
+    }
+
+    @Test
+    public void testSingleFrameChunked() {
+        EmbeddedChannel channel = new EmbeddedChannel(
+                new StompSubframeDecoder(10000, 5), new StompSubframeAggregator(100000));
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.SEND_FRAME_2.getBytes());
+        channel.writeInbound(incoming);
+        StompFrame frame = channel.readInbound();
+        Assert.assertNotNull(frame);
+        Assert.assertEquals(StompCommand.SEND, frame.command());
+        Assert.assertNull(channel.readInbound());
+    }
+
+    @Test
+    public void testMultipleFramesDecoding() {
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.CONNECT_FRAME.getBytes());
+        incoming.writeBytes(StompTestConstants.CONNECTED_FRAME.getBytes());
+        channel.writeInbound(incoming);
+        channel.writeInbound(Unpooled.wrappedBuffer(StompTestConstants.SEND_FRAME_1.getBytes()));
+        StompFrame frame = channel.readInbound();
+        Assert.assertEquals(StompCommand.CONNECT, frame.command());
+        frame = channel.readInbound();
+        Assert.assertEquals(StompCommand.CONNECTED, frame.command());
+        frame = channel.readInbound();
+        Assert.assertEquals(StompCommand.SEND, frame.command());
+        Assert.assertNull(channel.readInbound());
+    }
+
+    @Test(expected = TooLongFrameException.class)
+    public void testTooLongFrameException() {
+        EmbeddedChannel channel = new EmbeddedChannel(new StompSubframeDecoder(), new StompSubframeAggregator(10));
+        channel.writeInbound(Unpooled.wrappedBuffer(StompTestConstants.SEND_FRAME_1.getBytes()));
+    }
+}
diff --git a/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeDecoderTest.java b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeDecoderTest.java
new file mode 100644
index 000000000000..d03fa85ea89b
--- /dev/null
+++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeDecoderTest.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.CharsetUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class StompSubframeDecoderTest {
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(new StompSubframeDecoder());
+    }
+
+    @After
+    public void teardown() throws Exception {
+        assertFalse(channel.finish());
+    }
+
+    @Test
+    public void testSingleFrameDecoding() {
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.CONNECT_FRAME.getBytes());
+        channel.writeInbound(incoming);
+        StompHeadersSubframe frame = channel.readInbound();
+        assertNotNull(frame);
+        assertEquals(StompCommand.CONNECT, frame.command());
+        StompContentSubframe content = channel.readInbound();
+        assertSame(LastStompContentSubframe.EMPTY_LAST_CONTENT, content);
+        Object o = channel.readInbound();
+        assertNull(o);
+    }
+
+    @Test
+    public void testSingleFrameWithBodyAndContentLength() {
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.SEND_FRAME_2.getBytes());
+        channel.writeInbound(incoming);
+        StompHeadersSubframe frame = channel.readInbound();
+        assertNotNull(frame);
+        assertEquals(StompCommand.SEND, frame.command());
+        StompContentSubframe content = channel.readInbound();
+        assertTrue(content instanceof LastStompContentSubframe);
+        String s = content.content().toString(CharsetUtil.UTF_8);
+        assertEquals("hello, queue a!!!", s);
+        assertNull(channel.readInbound());
+    }
+
+    @Test
+    public void testSingleFrameWithBodyWithoutContentLength() {
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.SEND_FRAME_1.getBytes());
+        channel.writeInbound(incoming);
+        StompHeadersSubframe frame = channel.readInbound();
+        assertNotNull(frame);
+        assertEquals(StompCommand.SEND, frame.command());
+        StompContentSubframe content = channel.readInbound();
+        assertTrue(content instanceof LastStompContentSubframe);
+        String s = content.content().toString(CharsetUtil.UTF_8);
+        assertEquals("hello, queue a!", s);
+        assertNull(channel.readInbound());
+    }
+
+    @Test
+    public void testSingleFrameChunked() {
+        EmbeddedChannel channel = new EmbeddedChannel(new StompSubframeDecoder(10000, 5));
+
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.SEND_FRAME_2.getBytes());
+        channel.writeInbound(incoming);
+        StompHeadersSubframe frame = channel.readInbound();
+        assertNotNull(frame);
+        assertEquals(StompCommand.SEND, frame.command());
+        StompContentSubframe content = channel.readInbound();
+        String s = content.content().toString(CharsetUtil.UTF_8);
+        assertEquals("hello", s);
+
+        content = channel.readInbound();
+        s = content.content().toString(CharsetUtil.UTF_8);
+        assertEquals(", que", s);
+
+        content = channel.readInbound();
+        s = content.content().toString(CharsetUtil.UTF_8);
+        assertEquals("ue a!", s);
+
+        content = channel.readInbound();
+        s = content.content().toString(CharsetUtil.UTF_8);
+        assertEquals("!!", s);
+
+        assertNull(channel.readInbound());
+    }
+
+    @Test
+    public void testMultipleFramesDecoding() {
+        ByteBuf incoming = Unpooled.buffer();
+        incoming.writeBytes(StompTestConstants.CONNECT_FRAME.getBytes());
+        incoming.writeBytes(StompTestConstants.CONNECTED_FRAME.getBytes());
+        channel.writeInbound(incoming);
+
+        StompHeadersSubframe frame = channel.readInbound();
+        assertNotNull(frame);
+        assertEquals(StompCommand.CONNECT, frame.command());
+        StompContentSubframe content = channel.readInbound();
+        assertSame(LastStompContentSubframe.EMPTY_LAST_CONTENT, content);
+
+        StompHeadersSubframe frame2 = channel.readInbound();
+        assertNotNull(frame2);
+        assertEquals(StompCommand.CONNECTED, frame2.command());
+        StompContentSubframe content2 = channel.readInbound();
+        assertSame(LastStompContentSubframe.EMPTY_LAST_CONTENT, content2);
+        assertNull(channel.readInbound());
+    }
+}
diff --git a/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeEncoderTest.java b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeEncoderTest.java
new file mode 100644
index 000000000000..1407e8c0c9cd
--- /dev/null
+++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeEncoderTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.CharsetUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class StompSubframeEncoderTest {
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(new StompSubframeEncoder());
+    }
+
+    @After
+    public void teardown() throws Exception {
+        assertFalse(channel.finish());
+    }
+
+    @Test
+    public void testFrameAndContentEncoding() {
+        StompHeadersSubframe frame = new DefaultStompHeadersSubframe(StompCommand.CONNECT);
+        StompHeaders headers = frame.headers();
+        headers.set(StompHeaders.HOST, "stomp.github.org");
+        headers.set(StompHeaders.ACCEPT_VERSION, "1.1,1.2");
+        channel.writeOutbound(frame);
+        channel.writeOutbound(LastStompContentSubframe.EMPTY_LAST_CONTENT);
+        ByteBuf aggregatedBuffer = Unpooled.buffer();
+        ByteBuf byteBuf = channel.readOutbound();
+        assertNotNull(byteBuf);
+        aggregatedBuffer.writeBytes(byteBuf);
+
+        byteBuf = channel.readOutbound();
+        assertNotNull(byteBuf);
+        aggregatedBuffer.writeBytes(byteBuf);
+        aggregatedBuffer.resetReaderIndex();
+        String content = aggregatedBuffer.toString(CharsetUtil.UTF_8);
+        assertEquals(StompTestConstants.CONNECT_FRAME, content);
+    }
+}
diff --git a/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompTestConstants.java b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompTestConstants.java
new file mode 100644
index 000000000000..a427b944cc9c
--- /dev/null
+++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompTestConstants.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.stomp;
+
+public final class StompTestConstants {
+    public static final String CONNECT_FRAME =
+        "CONNECT\n" +
+            "host:stomp.github.org\n" +
+            "accept-version:1.1,1.2\n" +
+            '\n' +
+            '\0';
+    public static final String CONNECTED_FRAME =
+        "CONNECTED\n" +
+            "version:1.2\n" +
+            '\n' +
+            "\0\n";
+    public static final String SEND_FRAME_1 =
+        "SEND\n" +
+            "destination:/queue/a\n" +
+            "content-type:text/plain\n" +
+            '\n' +
+            "hello, queue a!" +
+            "\0\n";
+    public static final String SEND_FRAME_2 =
+        "SEND\n" +
+            "destination:/queue/a\n" +
+            "content-type:text/plain\n" +
+            "content-length:17\n" +
+            '\n' +
+            "hello, queue a!!!" +
+            "\0\n";
+
+    private StompTestConstants() { }
+}
diff --git a/codec/pom.xml b/codec/pom.xml
index 8b249433ddd7..9646a9fa99d3 100644
--- a/codec/pom.xml
+++ b/codec/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-codec</artifactId>
@@ -49,7 +49,7 @@
       <artifactId>jzlib</artifactId>
       <optional>true</optional>
     </dependency>
-    
+
     <!-- Test dependencies for jboss marshalling encoder/decoder -->
     <dependency>
       <groupId>org.jboss.marshalling</groupId>
@@ -61,6 +61,13 @@
       <artifactId>jboss-marshalling-river</artifactId>
       <scope>test</scope>
     </dependency>
+
+    <!-- Test dependency for Bzip2Decoder -->
+    <dependency>
+      <groupId>org.apache.commons</groupId>
+      <artifactId>commons-compress</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
 
diff --git a/codec/src/main/java/io/netty/handler/codec/AsciiHeadersEncoder.java b/codec/src/main/java/io/netty/handler/codec/AsciiHeadersEncoder.java
new file mode 100644
index 000000000000..d1ae85cdbc23
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/AsciiHeadersEncoder.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec;
+
+
+import io.netty.buffer.ByteBuf;
+
+public final class AsciiHeadersEncoder implements TextHeaderProcessor {
+
+    /**
+     * The separator characters to insert between a header name and a header value.
+     */
+    public enum SeparatorType {
+        /**
+         * {@code ':'}
+         */
+        COLON,
+        /**
+         * {@code ': '}
+         */
+        COLON_SPACE,
+    }
+
+    /**
+     * The newline characters to insert between header entries.
+     */
+    public enum NewlineType {
+        /**
+         * {@code '\n'}
+         */
+        LF,
+        /**
+         * {@code '\r\n'}
+         */
+        CRLF
+    }
+
+    private final ByteBuf buf;
+    private final SeparatorType separatorType;
+    private final NewlineType newlineType;
+
+    public AsciiHeadersEncoder(ByteBuf buf) {
+        this(buf, SeparatorType.COLON_SPACE, NewlineType.CRLF);
+    }
+
+    public AsciiHeadersEncoder(ByteBuf buf, SeparatorType separatorType, NewlineType newlineType) {
+        if (buf == null) {
+            throw new NullPointerException("buf");
+        }
+        if (separatorType == null) {
+            throw new NullPointerException("separatorType");
+        }
+        if (newlineType == null) {
+            throw new NullPointerException("newlineType");
+        }
+
+        this.buf = buf;
+        this.separatorType = separatorType;
+        this.newlineType = newlineType;
+    }
+
+    @Override
+    public boolean process(CharSequence name, CharSequence value) throws Exception {
+        final ByteBuf buf = this.buf;
+        final int nameLen = name.length();
+        final int valueLen = value.length();
+        final int entryLen = nameLen + valueLen + 4;
+        int offset = buf.writerIndex();
+        buf.ensureWritable(entryLen);
+        writeAscii(buf, offset, name, nameLen);
+        offset += nameLen;
+
+        switch (separatorType) {
+            case COLON:
+                buf.setByte(offset ++, ':');
+                break;
+            case COLON_SPACE:
+                buf.setByte(offset ++, ':');
+                buf.setByte(offset ++, ' ');
+                break;
+            default:
+                throw new Error();
+        }
+
+        writeAscii(buf, offset, value, valueLen);
+        offset += valueLen;
+
+        switch (newlineType) {
+            case LF:
+                buf.setByte(offset ++, '\n');
+                break;
+            case CRLF:
+                buf.setByte(offset ++, '\r');
+                buf.setByte(offset ++, '\n');
+                break;
+            default:
+                throw new Error();
+        }
+
+        buf.writerIndex(offset);
+        return true;
+    }
+
+    private static void writeAscii(ByteBuf buf, int offset, CharSequence value, int valueLen) {
+        if (value instanceof AsciiString) {
+            writeAsciiString(buf, offset, (AsciiString) value, valueLen);
+        } else {
+            writeCharSequence(buf, offset, value, valueLen);
+        }
+    }
+
+    private static void writeAsciiString(ByteBuf buf, int offset, AsciiString value, int valueLen) {
+        value.copy(0, buf, offset, valueLen);
+    }
+
+    private static void writeCharSequence(ByteBuf buf, int offset, CharSequence value, int valueLen) {
+        for (int i = 0; i < valueLen; i ++) {
+            buf.setByte(offset ++, c2b(value.charAt(i)));
+        }
+    }
+
+    private static int c2b(char ch) {
+        return ch < 256? (byte) ch : '?';
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/AsciiString.java b/codec/src/main/java/io/netty/handler/codec/AsciiString.java
new file mode 100644
index 000000000000..bc0b42fb8dca
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/AsciiString.java
@@ -0,0 +1,1466 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.EmptyArrays;
+
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+
+/**
+ * A string which has been encoded into a character encoding whose character always takes a single byte, similarly
+ * to ASCII.  It internally keeps its content in a byte array unlike {@link String}, which uses a character array,
+ * for reduced memory footprint and faster data transfer from/to byte-based data structures such as a byte array and
+ * {@link ByteBuf}.  It is often used in conjunction with {@link TextHeaders}.
+ */
+public final class AsciiString implements CharSequence, Comparable<CharSequence> {
+
+    public static final AsciiString EMPTY_STRING = new AsciiString("");
+
+    /**
+     * Returns the case-insensitive hash code of the specified string.  Note that this method uses the same hashing
+     * algorithm with {@link #hashCode()} so that you can put both {@link AsciiString}s and arbitrary
+     * {@link CharSequence}s into the same {@link TextHeaders}.
+     */
+    public static int caseInsensitiveHashCode(CharSequence value) {
+        if (value instanceof AsciiString) {
+            return value.hashCode();
+        }
+
+        int hash = 0;
+        final int end = value.length();
+        for (int i = 0; i < end; i ++) {
+            hash = hash * 31 ^ value.charAt(i) & 31;
+        }
+
+        return hash;
+    }
+
+    /**
+     * Returns {@code true} if both {@link CharSequence}'s are equals when ignore the case.
+     * This only supports 8-bit ASCII.
+     */
+    public static boolean equalsIgnoreCase(CharSequence a, CharSequence b) {
+        if (a == b) {
+            return true;
+        }
+
+        if (a instanceof AsciiString) {
+            AsciiString aa = (AsciiString) a;
+            return aa.equalsIgnoreCase(b);
+        }
+
+        if (b instanceof AsciiString) {
+            AsciiString ab = (AsciiString) b;
+            return ab.equalsIgnoreCase(a);
+        }
+
+        if (a == null || b == null) {
+            return false;
+        }
+
+        return a.toString().equalsIgnoreCase(b.toString());
+    }
+
+    /**
+     * Returns {@code true} if both {@link CharSequence}'s are equals. This only supports 8-bit ASCII.
+     */
+    public static boolean equals(CharSequence a, CharSequence b) {
+        if (a == b) {
+            return true;
+        }
+
+        if (a instanceof AsciiString) {
+            AsciiString aa = (AsciiString) a;
+            return aa.equals(b);
+        }
+
+        if (b instanceof AsciiString) {
+            AsciiString ab = (AsciiString) b;
+            return ab.equals(a);
+        }
+
+        if (a == null || b == null) {
+            return false;
+        }
+
+        return a.equals(b);
+    }
+
+    private final byte[] value;
+    private String string;
+    private int hash;
+
+    public AsciiString(byte[] value) {
+        this(value, true);
+    }
+
+    public AsciiString(byte[] value, boolean copy) {
+        checkNull(value);
+        if (copy) {
+            this.value = value.clone();
+        } else {
+            this.value = value;
+        }
+    }
+
+    public AsciiString(byte[] value, int start, int length) {
+        this(value, start, length, true);
+    }
+
+    public AsciiString(byte[] value, int start, int length, boolean copy) {
+        checkNull(value);
+        if (start < 0 || start > value.length - length) {
+            throw new IndexOutOfBoundsException("expected: " +
+                    "0 <= start(" + start + ") <= start + length(" + length + ") <= " +
+                    "value.length(" + value.length + ')');
+        }
+
+        if (copy || start != 0 || length != value.length) {
+            this.value = Arrays.copyOfRange(value, start, start + length);
+        } else {
+            this.value = value;
+        }
+    }
+
+    public AsciiString(char[] value) {
+        this(checkNull(value), 0, value.length);
+    }
+
+    public AsciiString(char[] value, int start, int length) {
+        checkNull(value);
+        if (start < 0 || start > value.length - length) {
+            throw new IndexOutOfBoundsException("expected: " +
+                    "0 <= start(" + start + ") <= start + length(" + length + ") <= " +
+                    "value.length(" + value.length + ')');
+        }
+
+        this.value = new byte[length];
+        for (int i = 0, j = start; i < length; i ++, j ++) {
+            this.value[i] = c2b(value[j]);
+        }
+    }
+
+    public AsciiString(CharSequence value) {
+        this(checkNull(value), 0, value.length());
+    }
+
+    public AsciiString(CharSequence value, int start, int length) {
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+
+        if (start < 0 || length < 0 || length > value.length() - start) {
+            throw new IndexOutOfBoundsException("expected: " +
+                    "0 <= start(" + start + ") <= start + length(" + length + ") <= " +
+                    "value.length(" + value.length() + ')');
+        }
+
+        this.value = new byte[length];
+        for (int i = 0; i < length; i++) {
+            this.value[i] = c2b(value.charAt(start + i));
+        }
+    }
+
+    public AsciiString(ByteBuffer value) {
+        this(checkNull(value), value.position(), value.remaining());
+    }
+
+    public AsciiString(ByteBuffer value, int start, int length) {
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+
+        if (start < 0 || length > value.capacity() - start) {
+            throw new IndexOutOfBoundsException("expected: " +
+                    "0 <= start(" + start + ") <= start + length(" + length + ") <= " +
+                    "value.capacity(" + value.capacity() + ')');
+        }
+
+        if (value.hasArray()) {
+            int baseOffset = value.arrayOffset() + start;
+            this.value = Arrays.copyOfRange(value.array(), baseOffset, baseOffset + length);
+        } else {
+            this.value = new byte[length];
+            int oldPos = value.position();
+            value.get(this.value, 0, this.value.length);
+            value.position(oldPos);
+        }
+    }
+
+    private static <T> T checkNull(T value) {
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+        return value;
+    }
+
+    @Override
+    public int length() {
+        return value.length;
+    }
+
+    @Override
+    public char charAt(int index) {
+        return (char) (byteAt(index) & 0xFF);
+    }
+
+    public byte byteAt(int index) {
+        return value[index];
+    }
+
+    public byte[] array() {
+        return value;
+    }
+
+    public int arrayOffset() {
+        return 0;
+    }
+
+    private static byte c2b(char c) {
+        if (c > 255) {
+            return '?';
+        }
+        return (byte) c;
+    }
+
+    private static byte toLowerCase(byte b) {
+        if ('A' <= b && b <= 'Z') {
+            return (byte) (b + 32);
+        }
+        return b;
+    }
+
+    private static char toLowerCase(char c) {
+        if ('A' <= c && c <= 'Z') {
+            return (char) (c + 32);
+        }
+        return c;
+    }
+
+    private static byte toUpperCase(byte b) {
+        if ('a' <= b && b <= 'z') {
+            return (byte) (b - 32);
+        }
+        return b;
+    }
+
+    /**
+     * Copies a range of characters into a new string.
+     *
+     * @param start
+     *            the offset of the first character.
+     * @return a new string containing the characters from start to the end of
+     *         the string.
+     * @throws IndexOutOfBoundsException
+     *             if {@code start < 0} or {@code start > length()}.
+     */
+    public AsciiString subSequence(int start) {
+        return subSequence(start, length());
+    }
+
+    @Override
+    public AsciiString subSequence(int start, int end) {
+        if (start < 0 || start > end || end > length()) {
+            throw new IndexOutOfBoundsException(
+                    "expected: 0 <= start(" + start + ") <= end (" + end + ") <= length(" + length() + ')');
+        }
+
+        final byte[] value = this.value;
+        if (start == 0 && end == value.length) {
+            return this;
+        }
+
+        if (end == start) {
+            return EMPTY_STRING;
+        }
+
+        return new AsciiString(value, start, end - start, false);
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = this.hash;
+        final byte[] value = this.value;
+        if (hash != 0 || value.length == 0) {
+            return hash;
+        }
+
+        for (byte b: value) {
+            hash = hash * 31 ^ b & 31;
+        }
+
+        return this.hash = hash;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof AsciiString)) {
+            return false;
+        }
+
+        if (this == obj) {
+            return true;
+        }
+
+        AsciiString that = (AsciiString) obj;
+        int thisHash = hashCode();
+        int thatHash = that.hashCode();
+        if (thisHash != thatHash || length() != that.length()) {
+            return false;
+        }
+
+        byte[] thisValue = value;
+        byte[] thatValue = that.value;
+        int end = thisValue.length;
+        for (int i = 0, j = 0; i < end; i ++, j ++) {
+            if (thisValue[i] != thatValue[j]) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public String toString() {
+        String string = this.string;
+        if (string != null) {
+            return string;
+        }
+
+        final byte[] value = this.value;
+        return this.string = new String(value, 0, 0, value.length);
+    }
+
+    @SuppressWarnings("deprecation")
+    public String toString(int start, int end) {
+        final byte[] value = this.value;
+        if (start == 0 && end == value.length) {
+            return toString();
+        }
+
+        int length = end - start;
+        if (length == 0) {
+            return "";
+        }
+
+        return new String(value, 0, start, length);
+    }
+
+    /**
+     * Compares the specified string to this string using the ASCII values of
+     * the characters. Returns 0 if the strings contain the same characters in
+     * the same order. Returns a negative integer if the first non-equal
+     * character in this string has an ASCII value which is less than the
+     * ASCII value of the character at the same position in the specified
+     * string, or if this string is a prefix of the specified string. Returns a
+     * positive integer if the first non-equal character in this string has a
+     * ASCII value which is greater than the ASCII value of the character at
+     * the same position in the specified string, or if the specified string is
+     * a prefix of this string.
+     *
+     * @param string
+     *            the string to compare.
+     * @return 0 if the strings are equal, a negative integer if this string is
+     *         before the specified string, or a positive integer if this string
+     *         is after the specified string.
+     * @throws NullPointerException
+     *             if {@code string} is {@code null}.
+     */
+    @Override
+    public int compareTo(CharSequence string) {
+        if (this == string) {
+            return 0;
+        }
+
+        int result;
+        int length1 = length();
+        int length2 = string.length();
+        int minLength = Math.min(length1, length2);
+        byte[] value = this.value;
+        for (int i = 0, j = 0; j < minLength; i ++, j ++) {
+            result = (value[i] & 0xFF) - string.charAt(j);
+            if (result != 0) {
+                return result;
+            }
+        }
+
+        return length1 - length2;
+    }
+
+    /**
+     * Compares the specified string to this string using the ASCII values of
+     * the characters, ignoring case differences. Returns 0 if the strings
+     * contain the same characters in the same order. Returns a negative integer
+     * if the first non-equal character in this string has an ASCII value which
+     * is less than the ASCII value of the character at the same position in
+     * the specified string, or if this string is a prefix of the specified
+     * string. Returns a positive integer if the first non-equal character in
+     * this string has an ASCII value which is greater than the ASCII value
+     * of the character at the same position in the specified string, or if the
+     * specified string is a prefix of this string.
+     *
+     * @param string
+     *            the string to compare.
+     * @return 0 if the strings are equal, a negative integer if this string is
+     *         before the specified string, or a positive integer if this string
+     *         is after the specified string.
+     * @throws NullPointerException
+     *             if {@code string} is {@code null}.
+     */
+    public int compareToIgnoreCase(CharSequence string) {
+        if (this == string) {
+            return 0;
+        }
+
+        int result;
+        int length1 = length();
+        int length2 = string.length();
+        int minLength = Math.min(length1, length2);
+        byte[] thisValue = value;
+        if (string instanceof AsciiString) {
+            AsciiString that = (AsciiString) string;
+            byte[] thatValue = that.value;
+            for (int i = 0; i < minLength; i ++) {
+                byte v1 = thisValue[i];
+                byte v2 = thatValue[i];
+                if (v1 == v2) {
+                    continue;
+                }
+                int c1 = toLowerCase(v1) & 0xFF;
+                int c2 = toLowerCase(v2) & 0xFF;
+                result = c1 - c2;
+                if (result != 0) {
+                    return result;
+                }
+            }
+        } else {
+            for (int i = 0; i < minLength; i ++) {
+                int c1 = toLowerCase(thisValue[i]) & 0xFF;
+                int c2 = toLowerCase(string.charAt(i));
+                result = c1 - c2;
+                if (result != 0) {
+                    return result;
+                }
+            }
+        }
+
+        return length1 - length2;
+    }
+
+    /**
+     * Concatenates this string and the specified string.
+     *
+     * @param string
+     *            the string to concatenate
+     * @return a new string which is the concatenation of this string and the
+     *         specified string.
+     */
+    public AsciiString concat(CharSequence string) {
+        int thisLen = length();
+        int thatLen = string.length();
+        if (thatLen == 0) {
+            return this;
+        }
+
+        if (string instanceof AsciiString) {
+            AsciiString that = (AsciiString) string;
+            if (isEmpty()) {
+                return that;
+            }
+
+            byte[] newValue = Arrays.copyOf(value, thisLen + thatLen);
+            System.arraycopy(that.value, 0, newValue, thisLen, thatLen);
+
+            return new AsciiString(newValue, false);
+        }
+
+        if (isEmpty()) {
+            return new AsciiString(string);
+        }
+
+        int newLen = thisLen + thatLen;
+        byte[] newValue = Arrays.copyOf(value, newLen);
+        for (int i = thisLen, j = 0; i < newLen; i ++, j ++) {
+            newValue[i] = c2b(string.charAt(j));
+        }
+
+        return new AsciiString(newValue, false);
+    }
+
+    /**
+     * Compares the specified string to this string to determine if the
+     * specified string is a suffix.
+     *
+     * @param suffix
+     *            the suffix to look for.
+     * @return {@code true} if the specified string is a suffix of this string,
+     *         {@code false} otherwise.
+     * @throws NullPointerException
+     *             if {@code suffix} is {@code null}.
+     */
+    public boolean endsWith(CharSequence suffix) {
+        int suffixLen = suffix.length();
+        return regionMatches(length() - suffixLen, suffix, 0, suffixLen);
+    }
+
+    /**
+     * Compares the specified string to this string ignoring the case of the
+     * characters and returns true if they are equal.
+     *
+     * @param string
+     *            the string to compare.
+     * @return {@code true} if the specified string is equal to this string,
+     *         {@code false} otherwise.
+     */
+    public boolean equalsIgnoreCase(CharSequence string) {
+        if (string == this) {
+            return true;
+        }
+
+        if (string == null) {
+            return false;
+        }
+
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+        final int thatLen = string.length();
+        if (thisLen != thatLen) {
+            return false;
+        }
+
+        for (int i = 0; i < thisLen; i ++) {
+            char c1 = (char) (value[i] & 0xFF);
+            char c2 = string.charAt(i);
+            if (c1 != c2 && toLowerCase(c1) != toLowerCase(c2)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Converts this string to a byte array using the ASCII encoding.
+     *
+     * @return the byte array encoding of this string.
+     */
+    public byte[] toByteArray() {
+        return toByteArray(0, length());
+    }
+
+    /**
+     * Converts this string to a byte array using the ASCII encoding.
+     *
+     * @return the byte array encoding of this string.
+     */
+    public byte[] toByteArray(int start, int end) {
+        return Arrays.copyOfRange(value, start, end);
+    }
+
+    /**
+     * Copies the characters in this string to a character array.
+     *
+     * @return a character array containing the characters of this string.
+     */
+    public char[] toCharArray() {
+        return toCharArray(0, length());
+    }
+
+    /**
+     * Copies the characters in this string to a character array.
+     *
+     * @return a character array containing the characters of this string.
+     */
+    public char[] toCharArray(int start, int end) {
+        int length = end - start;
+        if (length == 0) {
+            return EmptyArrays.EMPTY_CHARS;
+        }
+
+        final byte[] value = this.value;
+        final char[] buffer = new char[length];
+        for (int i = 0, j = start; i < length; i ++, j ++) {
+            buffer[i] = (char) (value[j] & 0xFF);
+        }
+        return buffer;
+    }
+
+    /**
+     * Copies the content of this string to a {@link ByteBuf} using {@link ByteBuf#writeBytes(byte[], int, int)}.
+     *
+     * @param srcIdx
+     *            the starting offset of characters to copy.
+     * @param dst
+     *            the destination byte array.
+     * @param dstIdx
+     *            the starting offset in the destination byte array.
+     * @param length
+     *            the number of characters to copy.
+     */
+    public void copy(int srcIdx, ByteBuf dst, int dstIdx, int length) {
+        if (dst == null) {
+            throw new NullPointerException("dst");
+        }
+
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+
+        if (srcIdx < 0 || length > thisLen - srcIdx) {
+            throw new IndexOutOfBoundsException("expected: " +
+                    "0 <= srcIdx(" + srcIdx + ") <= srcIdx + length(" + length + ") <= srcLen(" + thisLen + ')');
+        }
+
+        dst.setBytes(dstIdx, value, srcIdx, length);
+    }
+
+    /**
+     * Copies the content of this string to a {@link ByteBuf} using {@link ByteBuf#writeBytes(byte[], int, int)}.
+     *
+     * @param srcIdx
+     *            the starting offset of characters to copy.
+     * @param dst
+     *            the destination byte array.
+     * @param length
+     *            the number of characters to copy.
+     */
+    public void copy(int srcIdx, ByteBuf dst, int length) {
+        if (dst == null) {
+            throw new NullPointerException("dst");
+        }
+
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+
+        if (srcIdx < 0 || length > thisLen - srcIdx) {
+            throw new IndexOutOfBoundsException("expected: " +
+                    "0 <= srcIdx(" + srcIdx + ") <= srcIdx + length(" + length + ") <= srcLen(" + thisLen + ')');
+        }
+
+        dst.writeBytes(value, srcIdx, length);
+    }
+
+    /**
+     * Copies the content of this string to a byte array.
+     *
+     * @param srcIdx
+     *            the starting offset of characters to copy.
+     * @param dst
+     *            the destination byte array.
+     * @param dstIdx
+     *            the starting offset in the destination byte array.
+     * @param length
+     *            the number of characters to copy.
+     */
+    public void copy(int srcIdx, byte[] dst, int dstIdx, int length) {
+        if (dst == null) {
+            throw new NullPointerException("dst");
+        }
+
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+
+        if (srcIdx < 0 || length > thisLen - srcIdx) {
+            throw new IndexOutOfBoundsException("expected: " +
+                    "0 <= srcIdx(" + srcIdx + ") <= srcIdx + length(" + length + ") <= srcLen(" + thisLen + ')');
+        }
+
+        System.arraycopy(value, srcIdx, dst, dstIdx, length);
+    }
+
+    /**
+     * Copied the content of this string to a character array.
+     *
+     * @param srcIdx
+     *            the starting offset of characters to copy.
+     * @param dst
+     *            the destination character array.
+     * @param dstIdx
+     *            the starting offset in the destination byte array.
+     * @param length
+     *            the number of characters to copy.
+     */
+    public void copy(int srcIdx, char[] dst, int dstIdx, int length) {
+        if (dst == null) {
+            throw new NullPointerException("dst");
+        }
+
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+
+        if (srcIdx < 0 || length > thisLen - srcIdx) {
+            throw new IndexOutOfBoundsException("expected: " +
+                    "0 <= srcIdx(" + srcIdx + ") <= srcIdx + length(" + length + ") <= srcLen(" + thisLen + ')');
+        }
+
+        final int dstEnd = dstIdx + length;
+        for (int i = srcIdx, j = dstIdx; j < dstEnd; i ++, j ++) {
+            dst[j] = (char) (value[i] & 0xFF);
+        }
+    }
+
+    /**
+     * Searches in this string for the first index of the specified character.
+     * The search for the character starts at the beginning and moves towards
+     * the end of this string.
+     *
+     * @param c
+     *            the character to find.
+     * @return the index in this string of the specified character, -1 if the
+     *         character isn't found.
+     */
+    public int indexOf(int c) {
+        return indexOf(c, 0);
+    }
+
+    /**
+     * Searches in this string for the index of the specified character. The
+     * search for the character starts at the specified offset and moves towards
+     * the end of this string.
+     *
+     * @param c
+     *            the character to find.
+     * @param start
+     *            the starting offset.
+     * @return the index in this string of the specified character, -1 if the
+     *         character isn't found.
+     */
+    public int indexOf(int c, int start) {
+        final byte[] value = this.value;
+        final int length = value.length;
+        if (start < length) {
+            if (start < 0) {
+                start = 0;
+            }
+
+            for (int i = start; i < length; i ++) {
+                if ((value[i] & 0xFF) == c) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Searches in this string for the first index of the specified string. The
+     * search for the string starts at the beginning and moves towards the end
+     * of this string.
+     *
+     * @param string
+     *            the string to find.
+     * @return the index of the first character of the specified string in this
+     *         string, -1 if the specified string is not a substring.
+     * @throws NullPointerException
+     *             if {@code string} is {@code null}.
+     */
+    public int indexOf(CharSequence string) {
+        return indexOf(string, 0);
+    }
+
+    /**
+     * Searches in this string for the index of the specified string. The search
+     * for the string starts at the specified offset and moves towards the end
+     * of this string.
+     *
+     * @param subString
+     *            the string to find.
+     * @param start
+     *            the starting offset.
+     * @return the index of the first character of the specified string in this
+     *         string, -1 if the specified string is not a substring.
+     * @throws NullPointerException
+     *             if {@code subString} is {@code null}.
+     */
+    public int indexOf(CharSequence subString, int start) {
+        if (start < 0) {
+            start = 0;
+        }
+
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+
+        int subCount = subString.length();
+        if (subCount <= 0) {
+            return start < thisLen ? start : thisLen;
+        }
+        if (subCount > thisLen - start) {
+            return -1;
+        }
+
+        char firstChar = subString.charAt(0);
+        for (;;) {
+            int i = indexOf(firstChar, start);
+            if (i == -1 || subCount + i > thisLen) {
+                return -1; // handles subCount > count || start >= count
+            }
+            int o1 = i, o2 = 0;
+            while (++o2 < subCount && (value[++o1] & 0xFF) == subString.charAt(o2)) {
+                // Intentionally empty
+            }
+            if (o2 == subCount) {
+                return i;
+            }
+            start = i + 1;
+        }
+    }
+
+    /**
+     * Searches in this string for the last index of the specified character.
+     * The search for the character starts at the end and moves towards the
+     * beginning of this string.
+     *
+     * @param c
+     *            the character to find.
+     * @return the index in this string of the specified character, -1 if the
+     *         character isn't found.
+     */
+    public int lastIndexOf(int c) {
+        return lastIndexOf(c, length() - 1);
+    }
+
+    /**
+     * Searches in this string for the index of the specified character. The
+     * search for the character starts at the specified offset and moves towards
+     * the beginning of this string.
+     *
+     * @param c
+     *            the character to find.
+     * @param start
+     *            the starting offset.
+     * @return the index in this string of the specified character, -1 if the
+     *         character isn't found.
+     */
+    public int lastIndexOf(int c, int start) {
+        if (start >= 0) {
+            final byte[] value = this.value;
+            final int length = value.length;
+            if (start >= length) {
+                start = length - 1;
+            }
+            for (int i = start; i >= 0; -- i) {
+                if ((value[i] & 0xFF) == c) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Searches in this string for the last index of the specified string. The
+     * search for the string starts at the end and moves towards the beginning
+     * of this string.
+     *
+     * @param string
+     *            the string to find.
+     * @return the index of the first character of the specified string in this
+     *         string, -1 if the specified string is not a substring.
+     * @throws NullPointerException
+     *             if {@code string} is {@code null}.
+     */
+    public int lastIndexOf(CharSequence string) {
+        // Use count instead of count - 1 so lastIndexOf("") answers count
+        return lastIndexOf(string, length());
+    }
+
+    /**
+     * Searches in this string for the index of the specified string. The search
+     * for the string starts at the specified offset and moves towards the
+     * beginning of this string.
+     *
+     * @param subString
+     *            the string to find.
+     * @param start
+     *            the starting offset.
+     * @return the index of the first character of the specified string in this
+     *         string , -1 if the specified string is not a substring.
+     * @throws NullPointerException
+     *             if {@code subString} is {@code null}.
+     */
+    public int lastIndexOf(CharSequence subString, int start) {
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+        final int subCount = subString.length();
+
+        if (subCount > thisLen || start < 0) {
+            return -1;
+        }
+
+        if (subCount <= 0) {
+            return start < thisLen ? start : thisLen;
+        }
+
+        start = Math.min(start, thisLen - subCount);
+
+        // count and subCount are both >= 1
+        char firstChar = subString.charAt(0);
+        for (;;) {
+            int i = lastIndexOf(firstChar, start);
+            if (i == -1) {
+                return -1;
+            }
+            int o1 = i, o2 = 0;
+            while (++o2 < subCount && (value[++o1] & 0xFF) == subString.charAt(o2)) {
+                // Intentionally empty
+            }
+            if (o2 == subCount) {
+                return i;
+            }
+            start = i - 1;
+        }
+    }
+
+    /**
+     * Answers if the size of this String is zero.
+     *
+     * @return true if the size of this String is zero, false otherwise
+     */
+    public boolean isEmpty() {
+        return value.length == 0;
+    }
+
+    /**
+     * Compares the specified string to this string and compares the specified
+     * range of characters to determine if they are the same.
+     *
+     * @param thisStart
+     *            the starting offset in this string.
+     * @param string
+     *            the string to compare.
+     * @param start
+     *            the starting offset in the specified string.
+     * @param length
+     *            the number of characters to compare.
+     * @return {@code true} if the ranges of characters are equal, {@code false}
+     *         otherwise
+     * @throws NullPointerException
+     *             if {@code string} is {@code null}.
+     */
+    public boolean regionMatches(int thisStart, CharSequence string, int start, int length) {
+        if (string == null) {
+            throw new NullPointerException("string");
+        }
+
+        if (start < 0 || string.length() - start < length) {
+            return false;
+        }
+
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+        if (thisStart < 0 || thisLen - thisStart < length) {
+            return false;
+        }
+
+        if (length <= 0) {
+            return true;
+        }
+
+        final int thisEnd = thisStart + length;
+        for (int i = thisStart, j = start; i < thisEnd; i ++, j ++) {
+            if ((value[i] & 0xFF) != string.charAt(j)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Compares the specified string to this string and compares the specified
+     * range of characters to determine if they are the same. When ignoreCase is
+     * true, the case of the characters is ignored during the comparison.
+     *
+     * @param ignoreCase
+     *            specifies if case should be ignored.
+     * @param thisStart
+     *            the starting offset in this string.
+     * @param string
+     *            the string to compare.
+     * @param start
+     *            the starting offset in the specified string.
+     * @param length
+     *            the number of characters to compare.
+     * @return {@code true} if the ranges of characters are equal, {@code false}
+     *         otherwise.
+     * @throws NullPointerException
+     *             if {@code string} is {@code null}.
+     */
+    public boolean regionMatches(boolean ignoreCase, int thisStart,
+                                 CharSequence string, int start, int length) {
+        if (!ignoreCase) {
+            return regionMatches(thisStart, string, start, length);
+        }
+
+        if (string == null) {
+            throw new NullPointerException("string");
+        }
+
+        final byte[] value = this.value;
+        final int thisLen = value.length;
+        if (thisStart < 0 || length > thisLen - thisStart) {
+            return false;
+        }
+        if (start < 0 || length > string.length() - start) {
+            return false;
+        }
+
+        int thisEnd = thisStart + length;
+        while (thisStart < thisEnd) {
+            char c1 = (char) (value[thisStart++] & 0xFF);
+            char c2 = string.charAt(start++);
+            if (c1 != c2 && toLowerCase(c1) != toLowerCase(c2)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Copies this string replacing occurrences of the specified character with
+     * another character.
+     *
+     * @param oldChar
+     *            the character to replace.
+     * @param newChar
+     *            the replacement character.
+     * @return a new string with occurrences of oldChar replaced by newChar.
+     */
+    public AsciiString replace(char oldChar, char newChar) {
+        int index = indexOf(oldChar, 0);
+        if (index == -1) {
+            return this;
+        }
+
+        final byte[] value = this.value;
+        final int count = value.length;
+        byte[] buffer = new byte[count];
+        for (int i = 0, j = 0; i < value.length; i ++, j ++) {
+            byte b = value[i];
+            if ((char) (b & 0xFF) == oldChar) {
+                b = (byte) newChar;
+            }
+            buffer[j] = b;
+        }
+
+        return new AsciiString(buffer, false);
+    }
+
+    /**
+     * Compares the specified string to this string to determine if the
+     * specified string is a prefix.
+     *
+     * @param prefix
+     *            the string to look for.
+     * @return {@code true} if the specified string is a prefix of this string,
+     *         {@code false} otherwise
+     * @throws NullPointerException
+     *             if {@code prefix} is {@code null}.
+     */
+    public boolean startsWith(CharSequence prefix) {
+        return startsWith(prefix, 0);
+    }
+
+    /**
+     * Compares the specified string to this string, starting at the specified
+     * offset, to determine if the specified string is a prefix.
+     *
+     * @param prefix
+     *            the string to look for.
+     * @param start
+     *            the starting offset.
+     * @return {@code true} if the specified string occurs in this string at the
+     *         specified offset, {@code false} otherwise.
+     * @throws NullPointerException
+     *             if {@code prefix} is {@code null}.
+     */
+    public boolean startsWith(CharSequence prefix, int start) {
+        return regionMatches(start, prefix, 0, prefix.length());
+    }
+
+    /**
+     * Converts the characters in this string to lowercase, using the default
+     * Locale.
+     *
+     * @return a new string containing the lowercase characters equivalent to
+     *         the characters in this string.
+     */
+    public AsciiString toLowerCase() {
+        boolean lowercased = true;
+        final byte[] value = this.value;
+
+        for (byte b: value) {
+            if (b >= 'A' && b <= 'Z') {
+                lowercased = false;
+                break;
+            }
+        }
+
+        // Check if this string does not contain any uppercase characters.
+        if (lowercased) {
+            return this;
+        }
+
+        final int length = value.length;
+        final byte[] newValue = new byte[length];
+        for (int i = 0, j = 0; i < length; i ++, j ++) {
+            newValue[i] = toLowerCase(value[j]);
+        }
+
+        return new AsciiString(newValue, false);
+    }
+
+    /**
+     * Converts the characters in this string to uppercase, using the default
+     * Locale.
+     *
+     * @return a new string containing the uppercase characters equivalent to
+     *         the characters in this string.
+     */
+    public AsciiString toUpperCase() {
+        final byte[] value = this.value;
+        boolean uppercased = true;
+        for (byte b: value) {
+            if (b >= 'a' && b <= 'z') {
+                uppercased = false;
+                break;
+            }
+        }
+
+        // Check if this string does not contain any lowercase characters.
+        if (uppercased) {
+            return this;
+        }
+
+        final int length = value.length;
+        final byte[] newValue = new byte[length];
+        for (int i = 0, j = 0; i < length; i ++, j ++) {
+            newValue[i] = toUpperCase(value[j]);
+        }
+
+        return new AsciiString(newValue, false);
+    }
+
+    /**
+     * Copies this string removing white space characters from the beginning and
+     * end of the string.
+     *
+     * @return a new string with characters {@code <= \\u0020} removed from
+     *         the beginning and the end.
+     */
+    public AsciiString trim() {
+        final byte[] value = this.value;
+        int start = 0, last = value.length;
+        int end = last;
+        while (start <= end && value[start] <= ' ') {
+            start ++;
+        }
+        while (end >= start && value[end] <= ' ') {
+            end --;
+        }
+        if (start == 0 && end == last) {
+            return this;
+        }
+        return new AsciiString(value, start, end - start + 1, false);
+    }
+
+    /**
+     * Compares a {@code CharSequence} to this {@code String} to determine if
+     * their contents are equal.
+     *
+     * @param cs
+     *            the character sequence to compare to.
+     * @return {@code true} if equal, otherwise {@code false}
+     */
+    public boolean contentEquals(CharSequence cs) {
+        if (cs == null) {
+            throw new NullPointerException();
+        }
+
+        int length1 = length();
+        int length2 = cs.length();
+        if (length1 != length2) {
+            return false;
+        }
+
+        if (length1 == 0 && length2 == 0) {
+            return true; // since both are empty strings
+        }
+
+        return regionMatches(0, cs, 0, length2);
+    }
+
+    /**
+     * Determines whether this string matches a given regular expression.
+     *
+     * @param expr
+     *            the regular expression to be matched.
+     * @return {@code true} if the expression matches, otherwise {@code false}.
+     * @throws PatternSyntaxException
+     *             if the syntax of the supplied regular expression is not
+     *             valid.
+     * @throws NullPointerException
+     *             if {@code expr} is {@code null}.
+     */
+    public boolean matches(String expr) {
+        return Pattern.matches(expr, this);
+    }
+
+    /**
+     * Splits this string using the supplied regular expression {@code expr}.
+     * The parameter {@code max} controls the behavior how many times the
+     * pattern is applied to the string.
+     *
+     * @param expr
+     *            the regular expression used to divide the string.
+     * @param max
+     *            the number of entries in the resulting array.
+     * @return an array of Strings created by separating the string along
+     *         matches of the regular expression.
+     * @throws NullPointerException
+     *             if {@code expr} is {@code null}.
+     * @throws PatternSyntaxException
+     *             if the syntax of the supplied regular expression is not
+     *             valid.
+     * @see Pattern#split(CharSequence, int)
+     */
+    public AsciiString[] split(String expr, int max) {
+        return toAsciiStringArray(Pattern.compile(expr).split(this, max));
+    }
+
+    private static AsciiString[] toAsciiStringArray(String[] jdkResult) {
+        AsciiString[] res = new AsciiString[jdkResult.length];
+        for (int i = 0; i < jdkResult.length; i ++) {
+            res[i] = new AsciiString(jdkResult[i]);
+        }
+        return res;
+    }
+
+    /**
+     * Splits the specified {@link String} with the specified delimiter..
+     */
+    public AsciiString[] split(char delim) {
+        final List<AsciiString> res = new ArrayList<AsciiString>();
+
+        int start = 0;
+        final byte[] value = this.value;
+        final int length = value.length;
+        for (int i = start; i < length; i ++) {
+            if (charAt(i) == delim) {
+                if (start == i) {
+                    res.add(EMPTY_STRING);
+                } else {
+                    res.add(new AsciiString(value, start, i - start, false));
+                }
+                start = i + 1;
+            }
+        }
+
+        if (start == 0) { // If no delimiter was found in the value
+            res.add(this);
+        } else {
+            if (start != length) {
+                // Add the last element if it's not empty.
+                res.add(new AsciiString(value, start, length - start, false));
+            } else {
+                // Truncate trailing empty elements.
+                for (int i = res.size() - 1; i >= 0; i --) {
+                    if (res.get(i).isEmpty()) {
+                        res.remove(i);
+                    } else {
+                        break;
+                    }
+                }
+            }
+        }
+
+        return res.toArray(new AsciiString[res.size()]);
+    }
+
+    /**
+     * Determines if this {@code String} contains the sequence of characters in
+     * the {@code CharSequence} passed.
+     *
+     * @param cs
+     *            the character sequence to search for.
+     * @return {@code true} if the sequence of characters are contained in this
+     *         string, otherwise {@code false}.
+     */
+    public boolean contains(CharSequence cs) {
+        if (cs == null) {
+            throw new NullPointerException();
+        }
+        return indexOf(cs) >= 0;
+    }
+
+    public int parseInt() {
+        return parseInt(0, length(), 10);
+    }
+
+    public int parseInt(int radix) {
+        return parseInt(0, length(), radix);
+    }
+
+    public int parseInt(int start, int end) {
+        return parseInt(start, end, 10);
+    }
+
+    public int parseInt(int start, int end, int radix) {
+        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {
+            throw new NumberFormatException();
+        }
+
+        if (start == end) {
+            throw new NumberFormatException();
+        }
+
+        int i = start;
+        boolean negative = charAt(i) == '-';
+        if (negative && ++ i == end) {
+            throw new NumberFormatException(subSequence(start, end).toString());
+        }
+
+        return parseInt(i, end, radix, negative);
+    }
+
+    private int parseInt(int start, int end, int radix, boolean negative) {
+        final byte[] value = this.value;
+        int max = Integer.MIN_VALUE / radix;
+        int result = 0;
+        int offset = start;
+        while (offset < end) {
+            int digit = Character.digit((char) (value[offset ++] & 0xFF), radix);
+            if (digit == -1) {
+                throw new NumberFormatException(subSequence(start, end).toString());
+            }
+            if (max > result) {
+                throw new NumberFormatException(subSequence(start, end).toString());
+            }
+            int next = result * radix - digit;
+            if (next > result) {
+                throw new NumberFormatException(subSequence(start, end).toString());
+            }
+            result = next;
+        }
+        if (!negative) {
+            result = -result;
+            if (result < 0) {
+                throw new NumberFormatException(subSequence(start, end).toString());
+            }
+        }
+        return result;
+    }
+
+    public long parseLong() {
+        return parseLong(0, length(), 10);
+    }
+
+    public long parseLong(int radix) {
+        return parseLong(0, length(), radix);
+    }
+
+    public long parseLong(int start, int end) {
+        return parseLong(start, end, 10);
+    }
+
+    public long parseLong(int start, int end, int radix) {
+        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX) {
+            throw new NumberFormatException();
+        }
+
+        if (start == end) {
+            throw new NumberFormatException();
+        }
+
+        int i = start;
+        boolean negative = charAt(i) == '-';
+        if (negative && ++ i == end) {
+            throw new NumberFormatException(subSequence(start, end).toString());
+        }
+
+        return parseLong(i, end, radix, negative);
+    }
+
+    private long parseLong(int start, int end, int radix, boolean negative) {
+        final byte[] value = this.value;
+        long max = Long.MIN_VALUE / radix;
+        long result = 0;
+        int offset = start;
+        while (offset < end) {
+            int digit = Character.digit((char) (value[offset ++] & 0xFF), radix);
+            if (digit == -1) {
+                throw new NumberFormatException(subSequence(start, end).toString());
+            }
+            if (max > result) {
+                throw new NumberFormatException(subSequence(start, end).toString());
+            }
+            long next = result * radix - digit;
+            if (next > result) {
+                throw new NumberFormatException(subSequence(start, end).toString());
+            }
+            result = next;
+        }
+        if (!negative) {
+            result = -result;
+            if (result < 0) {
+                throw new NumberFormatException(subSequence(start, end).toString());
+            }
+        }
+        return result;
+    }
+
+    public short parseShort() {
+        return parseShort(0, length(), 10);
+    }
+
+    public short parseShort(int radix) {
+        return parseShort(0, length(), radix);
+    }
+
+    public short parseShort(int start, int end) {
+        return parseShort(start, end, 10);
+    }
+
+    public short parseShort(int start, int end, int radix) {
+        int intValue = parseInt(start, end, radix);
+        short result = (short) intValue;
+        if (result != intValue) {
+            throw new NumberFormatException(subSequence(start, end).toString());
+        }
+        return result;
+    }
+
+    public float parseFloat() {
+        return parseFloat(0, length());
+    }
+
+    public float parseFloat(int start, int end) {
+        return Float.parseFloat(toString(start, end));
+    }
+
+    public double parseDouble() {
+        return parseDouble(0, length());
+    }
+
+    public double parseDouble(int start, int end) {
+        return Double.parseDouble(toString(start, end));
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
index c095d8a65442..bcec34d96026 100644
--- a/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
@@ -89,7 +89,7 @@ protected ByteToMessageCodec(Class<? extends I> outboundMessageType, boolean pre
     }
 
     private void checkForSharableAnnotation() {
-        if (getClass().isAnnotationPresent(Sharable.class)) {
+        if (isSharable()) {
             throw new IllegalStateException("@Sharable annotation is not allowed");
         }
     }
diff --git a/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
index a0867600514f..bd880f9748ed 100644
--- a/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
@@ -52,7 +52,7 @@ public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter
     private boolean first;
 
     protected ByteToMessageDecoder() {
-        if (getClass().isAnnotationPresent(Sharable.class)) {
+        if (isSharable()) {
             throw new IllegalStateException("@Sharable annotation is not allowed");
         }
     }
@@ -132,7 +132,15 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
                 if (first) {
                     cumulation = data;
                 } else {
-                    if (cumulation.writerIndex() > cumulation.maxCapacity() - data.readableBytes()) {
+                    if (cumulation.writerIndex() > cumulation.maxCapacity() - data.readableBytes()
+                            || cumulation.refCnt() > 1) {
+                        // Expand cumulation (by replace it) when either there is not more room in the buffer
+                        // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or
+                        // duplicate().retain().
+                        //
+                        // See:
+                        // - https://github.com/netty/netty/issues/2327
+                        // - https://github.com/netty/netty/issues/1764
                         expandCumulation(ctx, data.readableBytes());
                     }
                     cumulation.writeBytes(data);
@@ -170,9 +178,14 @@ private void expandCumulation(ChannelHandlerContext ctx, int readable) {
 
     @Override
     public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        if (cumulation != null && !first) {
+        if (cumulation != null && !first && cumulation.refCnt() == 1) {
             // discard some bytes if possible to make more room in the
-            // buffer
+            // buffer but only if the refCnt == 1  as otherwise the user may have
+            // used slice().retain() or duplicate().retain().
+            //
+            // See:
+            // - https://github.com/netty/netty/issues/2327
+            // - https://github.com/netty/netty/issues/1764
             cumulation.discardSomeReadBytes();
         }
         if (decodeWasNull) {
diff --git a/codec/src/main/java/io/netty/handler/codec/DecoderResult.java b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java
index d9d10295ffb0..054d3e86a62a 100644
--- a/codec/src/main/java/io/netty/handler/codec/DecoderResult.java
+++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java
@@ -19,8 +19,8 @@
 
 public class DecoderResult {
 
-    protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class.getName() + ".UNFINISHED");
-    protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class.getName() + ".SUCCESS");
+    protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class, "UNFINISHED");
+    protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class, "SUCCESS");
 
     public static final DecoderResult UNFINISHED = new DecoderResult(SIGNAL_UNFINISHED);
     public static final DecoderResult SUCCESS = new DecoderResult(SIGNAL_SUCCESS);
diff --git a/codec/src/main/java/io/netty/handler/codec/DecoderResultProvider.java b/codec/src/main/java/io/netty/handler/codec/DecoderResultProvider.java
new file mode 100644
index 000000000000..082d4bbad251
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/DecoderResultProvider.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec;
+
+/**
+ * Provides the accessor methods for the {@link DecoderResult} property of a decoded message.
+ */
+public interface DecoderResultProvider {
+    /**
+     * Returns the result of decoding this object.
+     */
+    DecoderResult decoderResult();
+
+    /**
+     * Updates the result of decoding this object. This method is supposed to be invoked by a decoder.
+     * Do not call this method unless you know what you are doing.
+     */
+    void setDecoderResult(DecoderResult result);
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java b/codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java
new file mode 100644
index 000000000000..9d36a957a013
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java
@@ -0,0 +1,854 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec;
+
+import io.netty.util.concurrent.FastThreadLocal;
+import io.netty.util.internal.PlatformDependent;
+
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.TimeZone;
+
+public class DefaultTextHeaders implements TextHeaders {
+
+    private static final int BUCKET_SIZE = 17;
+
+    private static int index(int hash) {
+        return Math.abs(hash % BUCKET_SIZE);
+    }
+
+    private final HeaderEntry[] entries = new HeaderEntry[BUCKET_SIZE];
+    private final HeaderEntry head = new HeaderEntry(this);
+    private final boolean ignoreCase;
+    int size;
+
+    public DefaultTextHeaders() {
+        this(true);
+    }
+
+    public DefaultTextHeaders(boolean ignoreCase) {
+        head.before = head.after = head;
+        this.ignoreCase = ignoreCase;
+    }
+
+    protected int hashCode(CharSequence name) {
+        return AsciiString.caseInsensitiveHashCode(name);
+    }
+
+    protected CharSequence convertName(CharSequence name) {
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+        return name;
+    }
+
+    protected CharSequence convertValue(Object value) {
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+        if (value instanceof CharSequence) {
+            return (CharSequence) value;
+        }
+        return value.toString();
+    }
+
+    protected boolean nameEquals(CharSequence a, CharSequence b) {
+        return equals(a, b, ignoreCase);
+    }
+
+    protected boolean valueEquals(CharSequence a, CharSequence b, boolean ignoreCase) {
+        return equals(a, b, ignoreCase);
+    }
+
+    private static boolean equals(CharSequence a, CharSequence b, boolean ignoreCase) {
+        if (a == b) {
+            return true;
+        }
+
+        if (a instanceof AsciiString) {
+            AsciiString aa = (AsciiString) a;
+            if (ignoreCase) {
+                return aa.equalsIgnoreCase(b);
+            } else {
+                return aa.equals(b);
+            }
+        }
+
+        if (b instanceof AsciiString) {
+            AsciiString ab = (AsciiString) b;
+            if (ignoreCase) {
+                return ab.equalsIgnoreCase(a);
+            } else {
+                return ab.equals(a);
+            }
+        }
+
+        if (ignoreCase) {
+            return a.toString().equalsIgnoreCase(b.toString());
+        } else {
+            return a.equals(b);
+        }
+    }
+
+    @Override
+    public TextHeaders add(CharSequence name, Object value) {
+        name = convertName(name);
+        CharSequence convertedVal = convertValue(value);
+        int h = hashCode(name);
+        int i = index(h);
+        add0(h, i, name, convertedVal);
+        return this;
+    }
+
+    @Override
+    public TextHeaders add(CharSequence name, Iterable<?> values) {
+        name = convertName(name);
+        if (values == null) {
+            throw new NullPointerException("values");
+        }
+
+        int h = hashCode(name);
+        int i = index(h);
+        for (Object v: values) {
+            if (v == null) {
+                break;
+            }
+            CharSequence convertedVal = convertValue(v);
+            add0(h, i, name, convertedVal);
+        }
+        return this;
+    }
+
+    @Override
+    public TextHeaders add(CharSequence name, Object... values) {
+        name = convertName(name);
+        if (values == null) {
+            throw new NullPointerException("values");
+        }
+
+        int h = hashCode(name);
+        int i = index(h);
+        for (Object v: values) {
+            if (v == null) {
+                break;
+            }
+            CharSequence convertedVal = convertValue(v);
+            add0(h, i, name, convertedVal);
+        }
+        return this;
+    }
+
+    private void add0(int h, int i, CharSequence name, CharSequence value) {
+        // Update the hash table.
+        HeaderEntry e = entries[i];
+        HeaderEntry newEntry;
+        entries[i] = newEntry = new HeaderEntry(this, h, name, value);
+        newEntry.next = e;
+
+        // Update the linked list.
+        newEntry.addBefore(head);
+    }
+
+    @Override
+    public TextHeaders add(TextHeaders headers) {
+        if (headers == null) {
+            throw new NullPointerException("headers");
+        }
+
+        add0(headers);
+        return this;
+    }
+
+    private void add0(TextHeaders headers) {
+        if (headers.isEmpty()) {
+            return;
+        }
+
+        if (headers instanceof DefaultTextHeaders) {
+            DefaultTextHeaders m = (DefaultTextHeaders) headers;
+            HeaderEntry e = m.head.after;
+            while (e != m.head) {
+                CharSequence name = e.name;
+                name = convertName(name);
+                add(name, convertValue(e.value));
+                e = e.after;
+            }
+        } else {
+            for (Entry<CharSequence, CharSequence> e: headers.unconvertedEntries()) {
+                add(e.getKey(), e.getValue());
+            }
+        }
+    }
+
+    @Override
+    public boolean remove(CharSequence name) {
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+        int h = hashCode(name);
+        int i = index(h);
+        return remove0(h, i, name);
+    }
+
+    private boolean remove0(int h, int i, CharSequence name) {
+        HeaderEntry e = entries[i];
+        if (e == null) {
+            return false;
+        }
+
+        boolean removed = false;
+        for (;;) {
+            if (e.hash == h && nameEquals(e.name, name)) {
+                e.remove();
+                HeaderEntry next = e.next;
+                if (next != null) {
+                    entries[i] = next;
+                    e = next;
+                } else {
+                    entries[i] = null;
+                    return true;
+                }
+                removed = true;
+            } else {
+                break;
+            }
+        }
+
+        for (;;) {
+            HeaderEntry next = e.next;
+            if (next == null) {
+                break;
+            }
+            if (next.hash == h && nameEquals(next.name, name)) {
+                e.next = next.next;
+                next.remove();
+                removed = true;
+            } else {
+                e = next;
+            }
+        }
+
+        return removed;
+    }
+
+    @Override
+    public TextHeaders set(CharSequence name, Object value) {
+        name = convertName(name);
+        CharSequence convertedVal = convertValue(value);
+        int h = hashCode(name);
+        int i = index(h);
+        remove0(h, i, name);
+        add0(h, i, name, convertedVal);
+        return this;
+    }
+
+    @Override
+    public TextHeaders set(CharSequence name, Iterable<?> values) {
+        name = convertName(name);
+        if (values == null) {
+            throw new NullPointerException("values");
+        }
+
+        int h = hashCode(name);
+        int i = index(h);
+
+        remove0(h, i, name);
+        for (Object v: values) {
+            if (v == null) {
+                break;
+            }
+            CharSequence convertedVal = convertValue(v);
+            add0(h, i, name, convertedVal);
+        }
+
+        return this;
+    }
+
+    @Override
+    public TextHeaders set(CharSequence name, Object... values) {
+        name = convertName(name);
+        if (values == null) {
+            throw new NullPointerException("values");
+        }
+
+        int h = hashCode(name);
+        int i = index(h);
+
+        remove0(h, i, name);
+        for (Object v: values) {
+            if (v == null) {
+                break;
+            }
+            CharSequence convertedVal = convertValue(v);
+            add0(h, i, name, convertedVal);
+        }
+
+        return this;
+    }
+
+    @Override
+    public TextHeaders set(TextHeaders headers) {
+        if (headers == null) {
+            throw new NullPointerException("headers");
+        }
+
+        clear();
+        add0(headers);
+        return this;
+    }
+
+    @Override
+    public TextHeaders clear() {
+        Arrays.fill(entries, null);
+        head.before = head.after = head;
+        size = 0;
+        return this;
+    }
+
+    @Override
+    public CharSequence getUnconverted(CharSequence name) {
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+
+        int h = hashCode(name);
+        int i = index(h);
+        HeaderEntry e = entries[i];
+        CharSequence value = null;
+        // loop until the first header was found
+        while (e != null) {
+            if (e.hash == h && nameEquals(e.name, name)) {
+                value = e.value;
+            }
+
+            e = e.next;
+        }
+        if (value != null) {
+            return value;
+        }
+        return null;
+    }
+
+    @Override
+    public String get(CharSequence name) {
+        CharSequence v = getUnconverted(name);
+        if (v == null) {
+            return null;
+        }
+        return v.toString();
+    }
+
+    @Override
+    public String get(CharSequence name, String defaultValue) {
+        CharSequence v = getUnconverted(name);
+        if (v == null) {
+            return defaultValue;
+        }
+        return v.toString();
+    }
+
+    @Override
+    public int getInt(CharSequence name) {
+        CharSequence v = getUnconverted(name);
+        if (v == null) {
+            throw new NoSuchElementException(String.valueOf(name));
+        }
+
+        if (v instanceof AsciiString) {
+            return ((AsciiString) v).parseInt();
+        } else {
+            return Integer.parseInt(v.toString());
+        }
+    }
+
+    @Override
+    public int getInt(CharSequence name, int defaultValue) {
+        CharSequence v = getUnconverted(name);
+        if (v == null) {
+            return defaultValue;
+        }
+
+        try {
+            if (v instanceof AsciiString) {
+                return ((AsciiString) v).parseInt();
+            } else {
+                return Integer.parseInt(v.toString());
+            }
+        } catch (NumberFormatException ignored) {
+            return defaultValue;
+        }
+    }
+
+    @Override
+    public long getLong(CharSequence name) {
+        CharSequence v = getUnconverted(name);
+        if (v == null) {
+            throw new NoSuchElementException(String.valueOf(name));
+        }
+
+        if (v instanceof AsciiString) {
+            return ((AsciiString) v).parseLong();
+        } else {
+            return Long.parseLong(v.toString());
+        }
+    }
+
+    @Override
+    public long getLong(CharSequence name, long defaultValue) {
+        CharSequence v = getUnconverted(name);
+        if (v == null) {
+            return defaultValue;
+        }
+
+        try {
+            if (v instanceof AsciiString) {
+                return ((AsciiString) v).parseLong();
+            } else {
+                return Long.parseLong(v.toString());
+            }
+        } catch (NumberFormatException ignored) {
+            return defaultValue;
+        }
+    }
+
+    @Override
+    public long getTimeMillis(CharSequence name) {
+        CharSequence v = getUnconverted(name);
+        if (v == null) {
+            throw new NoSuchElementException(String.valueOf(name));
+        }
+
+        return HttpHeaderDateFormat.get().parse(v.toString());
+    }
+
+    @Override
+    public long getTimeMillis(CharSequence name, long defaultValue) {
+        CharSequence v = getUnconverted(name);
+        if (v == null) {
+            return defaultValue;
+        }
+
+        return HttpHeaderDateFormat.get().parse(v.toString(), defaultValue);
+    }
+
+    @Override
+    public List<CharSequence> getAllUnconverted(CharSequence name) {
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+
+        List<CharSequence> values = new ArrayList<CharSequence>(4);
+        int h = hashCode(name);
+        int i = index(h);
+        HeaderEntry e = entries[i];
+        while (e != null) {
+            if (e.hash == h && nameEquals(e.name, name)) {
+                values.add(e.getValue());
+            }
+            e = e.next;
+        }
+
+        Collections.reverse(values);
+        return values;
+    }
+
+    @Override
+    public List<String> getAll(CharSequence name) {
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+
+        List<String> values = new ArrayList<String>(4);
+        int h = hashCode(name);
+        int i = index(h);
+        HeaderEntry e = entries[i];
+        while (e != null) {
+            if (e.hash == h && nameEquals(e.name, name)) {
+                values.add(e.getValue().toString());
+            }
+            e = e.next;
+        }
+
+        Collections.reverse(values);
+        return values;
+    }
+
+    @Override
+    public List<Map.Entry<String, String>> entries() {
+        int cnt = 0;
+        int size = size();
+        @SuppressWarnings("unchecked")
+        Map.Entry<String, String>[] all = new Map.Entry[size];
+
+        HeaderEntry e = head.after;
+        while (e != head) {
+            all[cnt ++] = new StringHeaderEntry(e);
+            e = e.after;
+        }
+
+        assert size == cnt;
+        return Arrays.asList(all);
+    }
+
+    @Override
+    public List<Map.Entry<CharSequence, CharSequence>> unconvertedEntries() {
+        int cnt = 0;
+        int size = size();
+        @SuppressWarnings("unchecked")
+        Map.Entry<CharSequence, CharSequence>[] all = new Map.Entry[size];
+
+        HeaderEntry e = head.after;
+        while (e != head) {
+            all[cnt ++] = e;
+            e = e.after;
+        }
+
+        assert size == cnt;
+        return Arrays.asList(all);
+    }
+
+    @Override
+    public Iterator<Entry<String, String>> iterator() {
+        return new StringHeaderIterator();
+    }
+
+    @Override
+    public Iterator<Entry<CharSequence, CharSequence>> unconvertedIterator() {
+        return new HeaderIterator();
+    }
+
+    @Override
+    public boolean contains(CharSequence name) {
+        return getUnconverted(name) != null;
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return head == head.after;
+    }
+
+    @Override
+    public boolean contains(CharSequence name, Object value) {
+        return contains(name, value, false);
+    }
+
+    @Override
+    public boolean contains(CharSequence name, Object value, boolean ignoreCase) {
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+
+        int h = hashCode(name);
+        int i = index(h);
+        CharSequence convertedVal = convertValue(value);
+        HeaderEntry e = entries[i];
+        while (e != null) {
+            if (e.hash == h && nameEquals(e.name, name)) {
+                if (valueEquals(e.value, convertedVal, ignoreCase)) {
+                    return true;
+                }
+            }
+            e = e.next;
+        }
+        return false;
+    }
+
+    @Override
+    public Set<CharSequence> unconvertedNames() {
+        Set<CharSequence> names = new LinkedHashSet<CharSequence>(size());
+        HeaderEntry e = head.after;
+        while (e != head) {
+            names.add(e.getKey());
+            e = e.after;
+        }
+        return names;
+    }
+
+    @Override
+    public Set<String> names() {
+        Set<String> names = new LinkedHashSet<String>(size());
+        HeaderEntry e = head.after;
+        while (e != head) {
+            names.add(e.getKey().toString());
+            e = e.after;
+        }
+        return names;
+    }
+
+    @Override
+    public TextHeaders forEachEntry(TextHeaderProcessor processor) {
+        HeaderEntry e = head.after;
+        try {
+            while (e != head) {
+                if (!processor.process(e.getKey(), e.getValue())) {
+                    break;
+                }
+                e = e.after;
+            }
+        } catch (Exception ex) {
+            PlatformDependent.throwException(ex);
+        }
+        return this;
+    }
+
+    private static final class HeaderEntry implements Map.Entry<CharSequence, CharSequence> {
+        private final DefaultTextHeaders parent;
+        final int hash;
+        final CharSequence name;
+        CharSequence value;
+        HeaderEntry next;
+        HeaderEntry before, after;
+
+        HeaderEntry(DefaultTextHeaders parent, int hash, CharSequence name, CharSequence value) {
+            this.parent = parent;
+            this.hash = hash;
+            this.name = name;
+            this.value = value;
+        }
+
+        HeaderEntry(DefaultTextHeaders parent) {
+            this.parent = parent;
+            hash = -1;
+            name = null;
+            value = null;
+        }
+
+        void remove() {
+            before.after = after;
+            after.before = before;
+            parent.size --;
+        }
+
+        void addBefore(HeaderEntry e) {
+            after  = e;
+            before = e.before;
+            before.after = this;
+            after.before = this;
+            parent.size ++;
+        }
+
+        @Override
+        public CharSequence getKey() {
+            return name;
+        }
+
+        @Override
+        public CharSequence getValue() {
+            return value;
+        }
+
+        @Override
+        public CharSequence setValue(CharSequence value) {
+            if (value == null) {
+                throw new NullPointerException("value");
+            }
+            value = parent.convertValue(value);
+            CharSequence oldValue = this.value;
+            this.value = value;
+            return oldValue;
+        }
+
+        @Override
+        public String toString() {
+            return name.toString() + '=' + value.toString();
+        }
+    }
+
+    private static final class StringHeaderEntry implements Entry<String, String> {
+        private final Entry<CharSequence, CharSequence> entry;
+        private String name;
+        private String value;
+
+        StringHeaderEntry(Entry<CharSequence, CharSequence> entry) {
+            this.entry = entry;
+        }
+
+        @Override
+        public String getKey() {
+            if (name == null) {
+                name = entry.getKey().toString();
+            }
+            return name;
+        }
+
+        @Override
+        public String getValue() {
+            if (value == null) {
+                value = entry.getValue().toString();
+            }
+            return value;
+        }
+
+        @Override
+        public String setValue(String value) {
+            return entry.setValue(value).toString();
+        }
+
+        @Override
+        public String toString() {
+            return entry.toString();
+        }
+    }
+
+    private final class HeaderIterator implements Iterator<Map.Entry<CharSequence, CharSequence>> {
+
+        private HeaderEntry current = head;
+
+        @Override
+        public boolean hasNext() {
+            return current.after != head;
+        }
+
+        @Override
+        public Entry<CharSequence, CharSequence> next() {
+            current = current.after;
+
+            if (current == head) {
+                throw new NoSuchElementException();
+            }
+
+            return current;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    private final class StringHeaderIterator implements Iterator<Map.Entry<String, String>> {
+
+        private HeaderEntry current = head;
+
+        @Override
+        public boolean hasNext() {
+            return current.after != head;
+        }
+
+        @Override
+        public Entry<String, String> next() {
+            current = current.after;
+
+            if (current == head) {
+                throw new NoSuchElementException();
+            }
+
+            return new StringHeaderEntry(current);
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    /**
+     * This DateFormat decodes 3 formats of {@link java.util.Date}, but only encodes the one,
+     * the first:
+     * <ul>
+     * <li>Sun, 06 Nov 1994 08:49:37 GMT: standard specification, the only one with
+     * valid generation</li>
+     * <li>Sun, 06 Nov 1994 08:49:37 GMT: obsolete specification</li>
+     * <li>Sun Nov 6 08:49:37 1994: obsolete specification</li>
+     * </ul>
+     */
+    static final class HttpHeaderDateFormat {
+
+        private static final ParsePosition parsePos = new ParsePosition(0);
+        private static final FastThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal =
+                new FastThreadLocal<HttpHeaderDateFormat>() {
+                    @Override
+                    protected HttpHeaderDateFormat initialValue() {
+                        return new HttpHeaderDateFormat();
+                    }
+                };
+
+        static HttpHeaderDateFormat get() {
+            return dateFormatThreadLocal.get();
+        }
+
+        /**
+         * Standard date format:
+         * <pre>Sun, 06 Nov 1994 08:49:37 GMT -> E, d MMM yyyy HH:mm:ss z</pre>
+         */
+        private final DateFormat dateFormat1 = new SimpleDateFormat("E, dd MMM yyyy HH:mm:ss z", Locale.ENGLISH);
+        /**
+         * First obsolete format:
+         * <pre>Sunday, 06-Nov-94 08:49:37 GMT -> E, d-MMM-y HH:mm:ss z</pre>
+         */
+        private final DateFormat dateFormat2 = new SimpleDateFormat("E, dd-MMM-yy HH:mm:ss z", Locale.ENGLISH);
+        /**
+         * Second obsolete format
+         * <pre>Sun Nov 6 08:49:37 1994 -> EEE, MMM d HH:mm:ss yyyy</pre>
+         */
+        private final DateFormat dateFormat3 = new SimpleDateFormat("E MMM d HH:mm:ss yyyy", Locale.ENGLISH);
+
+        private HttpHeaderDateFormat() {
+            TimeZone tz = TimeZone.getTimeZone("GMT");
+            dateFormat1.setTimeZone(tz);
+            dateFormat2.setTimeZone(tz);
+            dateFormat3.setTimeZone(tz);
+        }
+
+        long parse(String text) {
+            Date date = dateFormat1.parse(text, parsePos);
+            if (date == null) {
+                date = dateFormat2.parse(text, parsePos);
+            }
+            if (date == null) {
+                date = dateFormat3.parse(text, parsePos);
+            }
+            if (date == null) {
+                PlatformDependent.throwException(new ParseException(text, 0));
+            }
+            return date.getTime();
+        }
+
+        long parse(String text, long defaultValue) {
+            Date date = dateFormat1.parse(text, parsePos);
+            if (date == null) {
+                date = dateFormat2.parse(text, parsePos);
+            }
+            if (date == null) {
+                date = dateFormat3.parse(text, parsePos);
+            }
+            if (date == null) {
+                return defaultValue;
+            }
+            return date.getTime();
+        }
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
index e1cf93b45d84..2dbd897ad6c6 100644
--- a/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
@@ -268,13 +268,13 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Except
             }
 
             if (stripDelimiter) {
-                frame = buffer.readBytes(minFrameLength);
+                frame = buffer.readSlice(minFrameLength);
                 buffer.skipBytes(minDelimLength);
             } else {
-                frame = buffer.readBytes(minFrameLength + minDelimLength);
+                frame = buffer.readSlice(minFrameLength + minDelimLength);
             }
 
-            return frame;
+            return frame.retain();
         } else {
             if (!discardingTooLongFrame) {
                 if (buffer.readableBytes() > maxFrameLength) {
diff --git a/codec/src/main/java/io/netty/handler/codec/EmptyTextHeaders.java b/codec/src/main/java/io/netty/handler/codec/EmptyTextHeaders.java
new file mode 100644
index 000000000000..e2e5ebf8fd13
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/EmptyTextHeaders.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec;
+
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+public class EmptyTextHeaders implements TextHeaders {
+
+    protected EmptyTextHeaders() { }
+
+    @Override
+    public String get(CharSequence name) {
+        return null;
+    }
+
+    @Override
+    public String get(CharSequence name, String defaultValue) {
+        return defaultValue;
+    }
+
+    @Override
+    public int getInt(CharSequence name) {
+        throw new NoSuchElementException(String.valueOf(name));
+    }
+
+    @Override
+    public int getInt(CharSequence name, int defaultValue) {
+        return defaultValue;
+    }
+
+    @Override
+    public long getLong(CharSequence name) {
+        throw new NoSuchElementException(String.valueOf(name));
+    }
+
+    @Override
+    public long getLong(CharSequence name, long defaultValue) {
+        return defaultValue;
+    }
+
+    @Override
+    public long getTimeMillis(CharSequence name) {
+        throw new NoSuchElementException(String.valueOf(name));
+    }
+
+    @Override
+    public long getTimeMillis(CharSequence name, long defaultValue) {
+        return defaultValue;
+    }
+
+    @Override
+    public CharSequence getUnconverted(CharSequence name) {
+        return null;
+    }
+
+    @Override
+    public List<String> getAll(CharSequence name) {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public List<CharSequence> getAllUnconverted(CharSequence name) {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public List<Entry<String, String>> entries() {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public List<Entry<CharSequence, CharSequence>> unconvertedEntries() {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean contains(CharSequence name) {
+        return false;
+    }
+
+    @Override
+    public int size() {
+        return 0;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return true;
+    }
+
+    @Override
+    public Set<String> names() {
+        return Collections.emptySet();
+    }
+
+    @Override
+    public Set<CharSequence> unconvertedNames() {
+        return Collections.emptySet();
+    }
+
+    @Override
+    public TextHeaders add(CharSequence name, Object value) {
+        throw new UnsupportedOperationException("read only");
+    }
+
+    @Override
+    public TextHeaders add(CharSequence name, Iterable<?> values) {
+        throw new UnsupportedOperationException("read only");
+    }
+
+    @Override
+    public TextHeaders add(CharSequence name, Object... values) {
+        throw new UnsupportedOperationException("read only");
+    }
+
+    @Override
+    public TextHeaders add(TextHeaders headers) {
+        throw new UnsupportedOperationException("read only");
+    }
+
+    @Override
+    public TextHeaders set(CharSequence name, Object value) {
+        throw new UnsupportedOperationException("read only");
+    }
+
+    @Override
+    public TextHeaders set(CharSequence name, Iterable<?> values) {
+        throw new UnsupportedOperationException("read only");
+    }
+
+    @Override
+    public TextHeaders set(CharSequence name, Object... values) {
+        throw new UnsupportedOperationException("read only");
+    }
+
+    @Override
+    public TextHeaders set(TextHeaders headers) {
+        throw new UnsupportedOperationException("read only");
+    }
+
+    @Override
+    public boolean remove(CharSequence name) {
+        return false;
+    }
+
+    @Override
+    public TextHeaders clear() {
+        return this;
+    }
+
+    @Override
+    public boolean contains(CharSequence name, Object value) {
+        return false;
+    }
+
+    @Override
+    public boolean contains(CharSequence name, Object value, boolean ignoreCase) {
+        return false;
+    }
+
+    @Override
+    public Iterator<Entry<String, String>> iterator() {
+        return entries().iterator();
+    }
+
+    @Override
+    public Iterator<Entry<CharSequence, CharSequence>> unconvertedIterator() {
+        return unconvertedEntries().iterator();
+    }
+
+    @Override
+    public TextHeaders forEachEntry(TextHeaderProcessor processor) {
+        return this;
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
index b4435d97d8fe..bef42a6ab80f 100644
--- a/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
@@ -74,7 +74,7 @@ protected Object decode(
         if (in.readableBytes() < frameLength) {
             return null;
         } else {
-            return in.readBytes(frameLength);
+            return in.readSlice(frameLength).retain();
         }
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java b/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java
index dd8e0e834c84..0bfd23759f4a 100644
--- a/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java
+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java
@@ -19,6 +19,8 @@
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 
+import java.util.List;
+
 
 /**
  * An encoder that prepends the length of the message.  The length value is
@@ -47,7 +49,7 @@
  * </pre>
  */
 @Sharable
-public class LengthFieldPrepender extends MessageToByteEncoder<ByteBuf> {
+public class LengthFieldPrepender extends MessageToMessageEncoder<ByteBuf> {
 
     private final int lengthFieldLength;
     private final boolean lengthIncludesLengthFieldLength;
@@ -128,7 +130,7 @@ public LengthFieldPrepender(int lengthFieldLength, int lengthAdjustment, boolean
     }
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {
         int length = msg.readableBytes() + lengthAdjustment;
         if (lengthIncludesLengthFieldLength) {
             length += lengthFieldLength;
@@ -145,32 +147,31 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throw
                 throw new IllegalArgumentException(
                         "length does not fit into a byte: " + length);
             }
-            out.writeByte((byte) length);
+            out.add(ctx.alloc().buffer(1).writeByte((byte) length));
             break;
         case 2:
             if (length >= 65536) {
                 throw new IllegalArgumentException(
                         "length does not fit into a short integer: " + length);
             }
-            out.writeShort((short) length);
+            out.add(ctx.alloc().buffer(2).writeShort((short) length));
             break;
         case 3:
             if (length >= 16777216) {
                 throw new IllegalArgumentException(
                         "length does not fit into a medium integer: " + length);
             }
-            out.writeMedium(length);
+            out.add(ctx.alloc().buffer(3).writeMedium(length));
             break;
         case 4:
-            out.writeInt(length);
+            out.add(ctx.alloc().buffer(4).writeInt(length));
             break;
         case 8:
-            out.writeLong(length);
+            out.add(ctx.alloc().buffer(8).writeLong(length));
             break;
         default:
             throw new Error("should not reach here");
         }
-
-        out.writeBytes(msg, msg.readerIndex(), msg.readableBytes());
+        out.add(msg.retain());
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
index f16646de02fc..ab49530de516 100644
--- a/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
@@ -100,13 +100,13 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Except
                 }
 
                 if (stripDelimiter) {
-                    frame = buffer.readBytes(length);
+                    frame = buffer.readSlice(length);
                     buffer.skipBytes(delimLength);
                 } else {
-                    frame = buffer.readBytes(length + delimLength);
+                    frame = buffer.readSlice(length + delimLength);
                 }
 
-                return frame;
+                return frame.retain();
             } else {
                 final int length = buffer.readableBytes();
                 if (length > maxLength) {
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageAggregationException.java b/codec/src/main/java/io/netty/handler/codec/MessageAggregationException.java
new file mode 100644
index 000000000000..9fd1f45bd7d7
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregationException.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec;
+
+/**
+ * Raised by {@link MessageAggregator} when aggregation fails due to an unexpected message sequence.
+ */
+public class MessageAggregationException extends IllegalStateException {
+
+    private static final long serialVersionUID = -1995826182950310255L;
+
+    public MessageAggregationException() { }
+
+    public MessageAggregationException(String s) {
+        super(s);
+    }
+
+    public MessageAggregationException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public MessageAggregationException(Throwable cause) {
+        super(cause);
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java
new file mode 100644
index 000000000000..6a84ca4f1e42
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java
@@ -0,0 +1,408 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufHolder;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.ReferenceCountUtil;
+
+import java.util.List;
+
+/**
+ * An abstract {@link ChannelHandler} that aggregates a series of message objects into a single aggregated message.
+ * <p>
+ * 'A series of messages' is composed of the following:
+ * <ul>
+ * <li>a single start message which optionally contains the first part of the content, and</li>
+ * <li>1 or more content messages.</li>
+ * </ul>
+ * The content of the aggregated message will be the merged content of the start message and its following content
+ * messages. If this aggregator encounters a content message where {@link #isLastContentMessage(ByteBufHolder)}
+ * return {@code true} for, the aggregator will finish the aggregation and produce the aggregated message and expect
+ * another start message.
+ * </p>
+ *
+ * @param <I> the type that covers both start message and content message
+ * @param <S> the type of the start message
+ * @param <C> the type of the content message (must be a subtype of {@link ByteBufHolder})
+ * @param <O> the type of the aggregated message (must be a subtype of {@code S} and {@link ByteBufHolder})
+ */
+public abstract class MessageAggregator<I, S, C extends ByteBufHolder, O extends ByteBufHolder>
+        extends MessageToMessageDecoder<I> {
+
+    private static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024;
+
+    private final int maxContentLength;
+    private O currentMessage;
+    private boolean handlingOversizedMessage;
+
+    private int maxCumulationBufferComponents = DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS;
+    private ChannelHandlerContext ctx;
+    private ChannelFutureListener continueResponseWriteListener;
+
+    /**
+     * Creates a new instance.
+     *
+     * @param maxContentLength
+     *        the maximum length of the aggregated content.
+     *        If the length of the aggregated content exceeds this value,
+     *        {@link #handleOversizedMessage(ChannelHandlerContext, Object)} will be called.
+     */
+    protected MessageAggregator(int maxContentLength) {
+        validateMaxContentLength(maxContentLength);
+        this.maxContentLength = maxContentLength;
+    }
+
+    protected MessageAggregator(int maxContentLength, Class<? extends I> inboundMessageType) {
+        super(inboundMessageType);
+        validateMaxContentLength(maxContentLength);
+        this.maxContentLength = maxContentLength;
+    }
+
+    private static void validateMaxContentLength(int maxContentLength) {
+        if (maxContentLength <= 0) {
+            throw new IllegalArgumentException("maxContentLength must be a positive integer: " + maxContentLength);
+        }
+    }
+
+    @Override
+    public boolean acceptInboundMessage(Object msg) throws Exception {
+        // No need to match last and full types because they are subset of first and middle types.
+        if (!super.acceptInboundMessage(msg)) {
+            return false;
+        }
+
+        @SuppressWarnings("unchecked")
+        I in = (I) msg;
+
+        return (isContentMessage(in) || isStartMessage(in)) && !isAggregated(in);
+    }
+
+    /**
+     * Returns {@code true} if and only if the specified message is a start message. Typically, this method is
+     * implemented as a single {@code return} statement with {@code instanceof}:
+     * <pre>
+     * return msg instanceof MyStartMessage;
+     * </pre>
+     */
+    protected abstract boolean isStartMessage(I msg) throws Exception;
+
+    /**
+     * Returns {@code true} if and only if the specified message is a content message. Typically, this method is
+     * implemented as a single {@code return} statement with {@code instanceof}:
+     * <pre>
+     * return msg instanceof MyContentMessage;
+     * </pre>
+     */
+    protected abstract boolean isContentMessage(I msg) throws Exception;
+
+    /**
+     * Returns {@code true} if and only if the specified message is the last content message. Typically, this method is
+     * implemented as a single {@code return} statement with {@code instanceof}:
+     * <pre>
+     * return msg instanceof MyLastContentMessage;
+     * </pre>
+     * or with {@code instanceof} and boolean field check:
+     * <pre>
+     * return msg instanceof MyContentMessage && msg.isLastFragment();
+     * </pre>
+     */
+    protected abstract boolean isLastContentMessage(C msg) throws Exception;
+
+    /**
+     * Returns {@code true} if and only if the specified message is already aggregated.  If this method returns
+     * {@code true}, this handler will simply forward the message to the next handler as-is.
+     */
+    protected abstract boolean isAggregated(I msg) throws Exception;
+
+    /**
+     * Returns the maximum allowed length of the aggregated message.
+     */
+    public final int maxContentLength() {
+        return maxContentLength;
+    }
+
+    /**
+     * Returns the maximum number of components in the cumulation buffer.  If the number of
+     * the components in the cumulation buffer exceeds this value, the components of the
+     * cumulation buffer are consolidated into a single component, involving memory copies.
+     * The default value of this property is {@value #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}.
+     */
+    public final int maxCumulationBufferComponents() {
+        return maxCumulationBufferComponents;
+    }
+
+    /**
+     * Sets the maximum number of components in the cumulation buffer.  If the number of
+     * the components in the cumulation buffer exceeds this value, the components of the
+     * cumulation buffer are consolidated into a single component, involving memory copies.
+     * The default value of this property is {@value #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}
+     * and its minimum allowed value is {@code 2}.
+     */
+    public final void setMaxCumulationBufferComponents(int maxCumulationBufferComponents) {
+        if (maxCumulationBufferComponents < 2) {
+            throw new IllegalArgumentException(
+                    "maxCumulationBufferComponents: " + maxCumulationBufferComponents +
+                    " (expected: >= 2)");
+        }
+
+        if (ctx == null) {
+            this.maxCumulationBufferComponents = maxCumulationBufferComponents;
+        } else {
+            throw new IllegalStateException(
+                    "decoder properties cannot be changed once the decoder is added to a pipeline.");
+        }
+    }
+
+    public final boolean isHandlingOversizedMessage() {
+        return handlingOversizedMessage;
+    }
+
+    protected final ChannelHandlerContext ctx() {
+        if (ctx == null) {
+            throw new IllegalStateException("not added to a pipeline yet");
+        }
+        return ctx;
+    }
+
+    @Override
+    protected void decode(final ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception {
+        O currentMessage = this.currentMessage;
+
+        if (isStartMessage(msg)) {
+            handlingOversizedMessage = false;
+            if (currentMessage != null) {
+                throw new MessageAggregationException();
+            }
+
+            @SuppressWarnings("unchecked")
+            S m = (S) msg;
+
+            // if content length is set, preemptively close if it's too large
+            if (hasContentLength(m)) {
+                if (contentLength(m) > maxContentLength) {
+                    // handle oversized message
+                    invokeHandleOversizedMessage(ctx, m);
+                    return;
+                }
+            }
+
+            // Send the continue response if necessary (e.g. 'Expect: 100-continue' header)
+            Object continueResponse = newContinueResponse(m);
+            if (continueResponse != null) {
+                // Cache the write listener for reuse.
+                ChannelFutureListener listener = continueResponseWriteListener;
+                if (listener == null) {
+                    continueResponseWriteListener = listener = new ChannelFutureListener() {
+                        @Override
+                        public void operationComplete(ChannelFuture future) throws Exception {
+                            if (!future.isSuccess()) {
+                                ctx.fireExceptionCaught(future.cause());
+                            }
+                        }
+                    };
+                }
+                ctx.writeAndFlush(continueResponse).addListener(listener);
+            }
+
+            if (m instanceof DecoderResultProvider && !((DecoderResultProvider) m).decoderResult().isSuccess()) {
+                O aggregated;
+                if (m instanceof ByteBufHolder && ((ByteBufHolder) m).content().isReadable()) {
+                    aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());
+                } else {
+                    aggregated = beginAggregation(m, Unpooled.EMPTY_BUFFER);
+                }
+                finishAggregation(aggregated);
+                out.add(aggregated);
+                this.currentMessage = null;
+                return;
+            }
+
+            // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.
+            CompositeByteBuf content = Unpooled.compositeBuffer(maxCumulationBufferComponents);
+            if (m instanceof ByteBufHolder) {
+                appendPartialContent(content, ((ByteBufHolder) m).content());
+            }
+            this.currentMessage = beginAggregation(m, content);
+
+        } else if (isContentMessage(msg)) {
+            @SuppressWarnings("unchecked")
+            final C m = (C) msg;
+            final ByteBuf partialContent = ((ByteBufHolder) msg).content();
+            final boolean isLastContentMessage = isLastContentMessage(m);
+            if (handlingOversizedMessage) {
+                if (isLastContentMessage) {
+                    this.currentMessage = null;
+                }
+                // already detect the too long frame so just discard the content
+                return;
+            }
+
+            if (currentMessage == null) {
+                throw new MessageAggregationException();
+            }
+
+            // Merge the received chunk into the content of the current message.
+            CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();
+
+            // Handle oversized message.
+            if (content.readableBytes() > maxContentLength - partialContent.readableBytes()) {
+                // By convention, full message type extends first message type.
+                @SuppressWarnings("unchecked")
+                S s = (S) currentMessage;
+                invokeHandleOversizedMessage(ctx, s);
+                return;
+            }
+
+            // Append the content of the chunk.
+            appendPartialContent(content, partialContent);
+
+            // Give the subtypes a chance to merge additional information such as trailing headers.
+            aggregate(currentMessage, m);
+
+            final boolean last;
+            if (m instanceof DecoderResultProvider) {
+                DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();
+                if (!decoderResult.isSuccess()) {
+                    if (currentMessage instanceof DecoderResultProvider) {
+                        ((DecoderResultProvider) currentMessage).setDecoderResult(
+                                DecoderResult.failure(decoderResult.cause()));
+                    }
+                    last = true;
+                } else {
+                    last = isLastContentMessage;
+                }
+            } else {
+                last = isLastContentMessage;
+            }
+
+            if (last) {
+                finishAggregation(currentMessage);
+
+                // All done
+                out.add(currentMessage);
+                this.currentMessage = null;
+            }
+        } else {
+            throw new MessageAggregationException();
+        }
+    }
+
+    private static void appendPartialContent(CompositeByteBuf content, ByteBuf partialContent) {
+        if (partialContent.isReadable()) {
+            partialContent.retain();
+            content.addComponent(partialContent);
+            content.writerIndex(content.writerIndex() + partialContent.readableBytes());
+        }
+    }
+
+    /**
+     * Returns {@code true} if and only if the specified start message already contains the information about the
+     * length of the whole content.
+     */
+    protected abstract boolean hasContentLength(S start) throws Exception;
+
+    /**
+     * Retrieves the length of the whole content from the specified start message. This method is invoked only when
+     * {@link #hasContentLength(Object)} returned {@code true}.
+     */
+    protected abstract long contentLength(S start) throws Exception;
+
+    /**
+     * Returns the 'continue response' for the specified start message if necessary. For example, this method is
+     * useful to handle an HTTP 100-continue header.
+     *
+     * @return the 'continue response', or {@code null} if there's no message to send
+     */
+    protected abstract Object newContinueResponse(S start) throws Exception;
+
+    /**
+     * Creates a new aggregated message from the specified start message and the specified content.  If the start
+     * message implements {@link ByteBufHolder}, its content is appended to the specified {@code content}.
+     * This aggregator will continue to append the received content to the specified {@code content}.
+     */
+    protected abstract O beginAggregation(S start, ByteBuf content) throws Exception;
+
+    /**
+     * Transfers the information provided by the specified content message to the specified aggregated message.
+     * Note that the content of the specified content message has been appended to the content of the specified
+     * aggregated message already, so that you don't need to.  Use this method to transfer the additional information
+     * that the content message provides to {@code aggregated}.
+     */
+    protected void aggregate(O aggregated, C content) throws Exception { }
+
+    /**
+     * Invoked when the specified {@code aggregated} message is about to be passed to the next handler in the pipeline.
+     */
+    protected void finishAggregation(O aggregated) throws Exception { }
+
+    private void invokeHandleOversizedMessage(ChannelHandlerContext ctx, S oversized) throws Exception {
+        handlingOversizedMessage = true;
+        currentMessage = null;
+        try {
+            handleOversizedMessage(ctx, oversized);
+        } finally {
+            // Release the message in case it is a full one.
+            ReferenceCountUtil.release(oversized);
+        }
+    }
+
+    /**
+     * Invoked when an incoming request exceeds the maximum content length.  The default behvaior is to trigger an
+     * {@code exceptionCaught()} event with a {@link TooLongFrameException}.
+     *
+     * @param ctx the {@link ChannelHandlerContext}
+     * @param oversized the accumulated message up to this point, whose type is {@code S} or {@code O}
+     */
+    protected void handleOversizedMessage(ChannelHandlerContext ctx, S oversized) throws Exception {
+        ctx.fireExceptionCaught(
+                new TooLongFrameException("content length exceeded " + maxContentLength() + " bytes."));
+    }
+
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        // release current message if it is not null as it may be a left-over
+        if (currentMessage != null) {
+            currentMessage.release();
+            currentMessage = null;
+        }
+
+        super.channelInactive(ctx);
+    }
+
+    @Override
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+        this.ctx = ctx;
+    }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        super.handlerRemoved(ctx);
+
+        // release current message if it is not null as it may be a left-over as there is not much more we can do in
+        // this case
+        if (currentMessage != null) {
+            currentMessage.release();
+            currentMessage = null;
+        }
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
index f6c506b23752..0aab4247c218 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
@@ -102,11 +102,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
             if (acceptOutboundMessage(msg)) {
                 @SuppressWarnings("unchecked")
                 I cast = (I) msg;
-                if (preferDirect) {
-                    buf = ctx.alloc().ioBuffer();
-                } else {
-                    buf = ctx.alloc().heapBuffer();
-                }
+                buf = allocateBuffer(ctx, cast, preferDirect);
                 try {
                     encode(ctx, cast, buf);
                 } finally {
@@ -134,6 +130,19 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         }
     }
 
+    /**
+     * Allocate a {@link ByteBuf} which will be used as argument of {@link #encode(ChannelHandlerContext, I, ByteBuf)}.
+     * Sub-classes may override this method to returna {@link ByteBuf} with a perfect matching {@code initialCapacity}.
+     */
+    protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, @SuppressWarnings("unused") I msg,
+                               boolean preferDirect) throws Exception {
+        if (preferDirect) {
+            return ctx.alloc().ioBuffer();
+        } else {
+            return ctx.alloc().heapBuffer();
+        }
+    }
+
     /**
      * Encode a message into a {@link ByteBuf}. This method will be called for each written message that can be handled
      * by this encoder.
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
index d0e98efa44e9..1a2cc034c221 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
@@ -108,9 +108,21 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         } finally {
             if (out != null) {
                 final int sizeMinusOne = out.size() - 1;
-                if (sizeMinusOne >= 0) {
+                if (sizeMinusOne == 0) {
+                    ctx.write(out.get(0), promise);
+                } else if (sizeMinusOne > 0) {
+                    // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure
+                    // See https://github.com/netty/netty/issues/2525
+                    ChannelPromise voidPromise = ctx.voidPromise();
+                    boolean isVoidPromise = promise == voidPromise;
                     for (int i = 0; i < sizeMinusOne; i ++) {
-                        ctx.write(out.get(i));
+                        ChannelPromise p;
+                        if (isVoidPromise) {
+                            p = voidPromise;
+                        } else {
+                            p = ctx.newPromise();
+                        }
+                        ctx.write(out.get(i), p);
                     }
                     ctx.write(out.get(sizeMinusOne), promise);
                 }
diff --git a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
index dc442e01e071..5495c1465092 100644
--- a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
@@ -40,21 +40,21 @@
  *
  *   {@code @Override}
  *   protected void decode({@link ChannelHandlerContext} ctx,
- *                           {@link ByteBuf} in, List&lt;Object&gt; out) throws Exception {
+ *                           {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {
  *
- *     if (in.readableBytes() &lt; 4) {
+ *     if (buf.readableBytes() &lt; 4) {
  *        return;
  *     }
  *
- *     in.markReaderIndex();
- *     int length = in.readInt();
+ *     buf.markReaderIndex();
+ *     int length = buf.readInt();
  *
- *     if (in.readableBytes() &lt; length) {
- *        in.resetReaderIndex();
+ *     if (buf.readableBytes() &lt; length) {
+ *        buf.resetReaderIndex();
  *        return;
  *     }
  *
- *     out.add(in.readBytes(length));
+ *     out.add(buf.readBytes(length));
  *   }
  * }
  * </pre>
@@ -108,11 +108,11 @@
  *   private final Queue&lt;Integer&gt; values = new LinkedList&lt;Integer&gt;();
  *
  *   {@code @Override}
- *   public void decode(.., {@link ByteBuf} in, List&lt;Object&gt; out) throws Exception {
+ *   public void decode(.., {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {
  *
  *     // A message contains 2 integers.
- *     values.offer(buffer.readInt());
- *     values.offer(buffer.readInt());
+ *     values.offer(buf.readInt());
+ *     values.offer(buf.readInt());
  *
  *     // This assertion will fail intermittently since values.offer()
  *     // can be called more than two times!
@@ -128,15 +128,15 @@
  *   private final Queue&lt;Integer&gt; values = new LinkedList&lt;Integer&gt;();
  *
  *   {@code @Override}
- *   public void decode(.., {@link ByteBuf} buffer, List&lt;Object&gt; out) throws Exception {
+ *   public void decode(.., {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {
  *
  *     // Revert the state of the variable that might have been changed
  *     // since the last partial decode.
  *     values.clear();
  *
  *     // A message contains 2 integers.
- *     values.offer(buffer.readInt());
- *     values.offer(buffer.readInt());
+ *     values.offer(buf.readInt());
+ *     values.offer(buf.readInt());
  *
  *     // Now we know this assertion will never fail.
  *     assert values.size() == 2;
@@ -181,7 +181,7 @@
  *
  *   {@code @Override}
  *   protected void decode({@link ChannelHandlerContext} ctx,
- *                           {@link ByteBuf} in, List&lt;Object&gt; out) throws Exception {
+ *                           {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {
  *     switch (state()) {
  *     case READ_LENGTH:
  *       length = buf.readInt();
@@ -190,6 +190,7 @@
  *       ByteBuf frame = buf.readBytes(length);
  *       <strong>checkpoint(MyDecoderState.READ_LENGTH);</strong>
  *       out.add(frame);
+ *       break;
  *     default:
  *       throw new Error("Shouldn't reach here.");
  *     }
@@ -209,7 +210,7 @@
  *
  *   {@code @Override}
  *   protected void decode({@link ChannelHandlerContext} ctx,
- *                           {@link ByteBuf} in, List&lt;Object&gt; out) throws Exception {
+ *                           {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {
  *     if (!readLength) {
  *       length = buf.readInt();
  *       <strong>readLength = true;</strong>
@@ -240,7 +241,7 @@
  *
  *     {@code @Override}
  *     protected Object decode({@link ChannelHandlerContext} ctx,
- *                             {@link ByteBuf} in, List&lt;Object&gt; out) {
+ *                             {@link ByteBuf} buf, List&lt;Object&gt; out) {
  *         ...
  *         // Decode the first message
  *         Object firstMessage = ...;
@@ -266,7 +267,7 @@
  */
 public abstract class ReplayingDecoder<S> extends ByteToMessageDecoder {
 
-    static final Signal REPLAY = Signal.valueOf(ReplayingDecoder.class.getName() + ".REPLAY");
+    static final Signal REPLAY = Signal.valueOf(ReplayingDecoder.class, "REPLAY");
 
     private final ReplayingDecoderBuffer replayable = new ReplayingDecoderBuffer();
     private S state;
diff --git a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
index 108608dea534..a610a19a3e92 100644
--- a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
@@ -307,11 +307,15 @@ public int hashCode() {
 
     @Override
     public int indexOf(int fromIndex, int toIndex, byte value) {
-        int endIndex = buffer.indexOf(fromIndex, toIndex, value);
-        if (endIndex < 0) {
+        if (fromIndex == toIndex) {
+            return -1;
+        }
+
+        if (Math.max(fromIndex, toIndex) > buffer.writerIndex()) {
             throw REPLAY;
         }
-        return endIndex;
+
+        return buffer.indexOf(fromIndex, toIndex, value);
     }
 
     @Override
@@ -325,21 +329,27 @@ public int bytesBefore(byte value) {
 
     @Override
     public int bytesBefore(int length, byte value) {
-        checkReadableBytes(length);
-        int bytes = buffer.bytesBefore(length, value);
-        if (bytes < 0) {
-            throw REPLAY;
-        }
-        return bytes;
+        final int readerIndex = buffer.readerIndex();
+        return bytesBefore(readerIndex, buffer.writerIndex() - readerIndex, value);
     }
 
     @Override
     public int bytesBefore(int index, int length, byte value) {
-        int bytes = buffer.bytesBefore(index, length, value);
-        if (bytes < 0) {
+        final int writerIndex = buffer.writerIndex();
+        if (index >= writerIndex) {
             throw REPLAY;
         }
-        return bytes;
+
+        if (index <= writerIndex - length) {
+            return buffer.bytesBefore(index, length, value);
+        }
+
+        int res = buffer.bytesBefore(index, writerIndex - index, value);
+        if (res < 0) {
+            throw REPLAY;
+        } else {
+            return res;
+        }
     }
 
     @Override
@@ -359,7 +369,7 @@ public int forEachByte(int index, int length, ByteBufProcessor processor) {
             throw REPLAY;
         }
 
-        if (index + length <= writerIndex) {
+        if (index <= writerIndex - length) {
             return buffer.forEachByte(index, length, processor);
         }
 
@@ -972,6 +982,18 @@ public ByteBuf retain(int increment) {
         return this;
     }
 
+    @Override
+    public ByteBuf touch() {
+        buffer.touch();
+        return this;
+    }
+
+    @Override
+    public ByteBuf touch(Object hint) {
+        buffer.touch(hint);
+        return this;
+    }
+
     @Override
     public boolean release() {
         reject();
diff --git a/codec/src/main/java/io/netty/handler/codec/TextHeaderProcessor.java b/codec/src/main/java/io/netty/handler/codec/TextHeaderProcessor.java
new file mode 100644
index 000000000000..43aa9df7a688
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/TextHeaderProcessor.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec;
+
+public interface TextHeaderProcessor {
+    boolean process(CharSequence name, CharSequence value) throws Exception;
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/TextHeaders.java b/codec/src/main/java/io/netty/handler/codec/TextHeaders.java
new file mode 100644
index 000000000000..d84b25018204
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/TextHeaders.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+/**
+ * A typical string multimap used by text protocols such as HTTP for the representation of arbitrary key-value data.
+ * One thing to note is that it uses {@link CharSequence} as its primary key and value type rather than {@link String}.
+ * When you invoke the operations that produce {@link String}s such as {@link #get(CharSequence)},
+ * a {@link CharSequence} is implicitly converted to a {@link String}.  This is particularly useful for speed
+ * optimization because this multimap can hold a special {@link CharSequence} implementation that a codec can
+ * treat specially, such as {@link AsciiString}.
+ */
+public interface TextHeaders extends Iterable<Map.Entry<String, String>> {
+    /**
+     * Returns the value of a header with the specified name.  If there are
+     * more than one values for the specified name, the first value is returned.
+     *
+     * @param name The name of the header to search
+     * @return The first header value or {@code null} if there is no such header
+     */
+    String get(CharSequence name);
+
+    String get(CharSequence name, String defaultValue);
+    int getInt(CharSequence name);
+    int getInt(CharSequence name, int defaultValue);
+    long getLong(CharSequence name);
+    long getLong(CharSequence name, long defaultValue);
+    long getTimeMillis(CharSequence name);
+    long getTimeMillis(CharSequence name, long defaultValue);
+
+    /**
+     * Returns the value of a header with the specified name.  If there are
+     * more than one values for the specified name, the first value is returned.
+     *
+     * @param name The name of the header to search
+     * @return The first header value or {@code null} if there is no such header
+     */
+    CharSequence getUnconverted(CharSequence name);
+
+    /**
+     * Returns the values of headers with the specified name
+     *
+     * @param name The name of the headers to search
+     * @return A {@link List} of header values which will be empty if no values are found
+     */
+    List<String> getAll(CharSequence name);
+
+    /**
+     * Returns the values of headers with the specified name
+     *
+     * @param name The name of the headers to search
+     * @return A {@link List} of header values which will be empty if no values are found
+     */
+    List<CharSequence> getAllUnconverted(CharSequence name);
+
+    /**
+     * Returns a new {@link List} that contains all headers in this object.  Note that modifying the
+     * returned {@link List} will not affect the state of this object.  If you intend to enumerate over the header
+     * entries only, use {@link #iterator()} instead, which has much less overhead.
+     */
+    List<Entry<String, String>> entries();
+
+    /**
+     * Returns a new {@link List} that contains all headers in this object.  Note that modifying the
+     * returned {@link List} will not affect the state of this object.  If you intend to enumerate over the header
+     * entries only, use {@link #iterator()} instead, which has much less overhead.
+     */
+    List<Entry<CharSequence, CharSequence>> unconvertedEntries();
+
+    /**
+     * Checks to see if there is a header with the specified name
+     *
+     * @param name The name of the header to search for
+     * @return True if at least one header is found
+     */
+    boolean contains(CharSequence name);
+
+    int size();
+
+    /**
+     * Checks if no header exists.
+     */
+    boolean isEmpty();
+
+    /**
+     * Returns a new {@link Set} that contains the names of all headers in this object.  Note that modifying the
+     * returned {@link Set} will not affect the state of this object.  If you intend to enumerate over the header
+     * entries only, use {@link #iterator()} instead, which has much less overhead.
+     */
+    Set<String> names();
+
+    /**
+     * Returns a new {@link Set} that contains the names of all headers in this object.  Note that modifying the
+     * returned {@link Set} will not affect the state of this object.  If you intend to enumerate over the header
+     * entries only, use {@link #iterator()} instead, which has much less overhead.
+     */
+    Set<CharSequence> unconvertedNames();
+
+    /**
+     * Adds a new header with the specified name and value.
+     *
+     * If the specified value is not a {@link String}, it is converted
+     * into a {@link String} by {@link Object#toString()}, except in the cases
+     * of {@link java.util.Date} and {@link java.util.Calendar}, which are formatted to the date
+     * format defined in <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">RFC2616</a>.
+     *
+     * @param name The name of the header being added
+     * @param value The value of the header being added
+     *
+     * @return {@code this}
+     */
+    TextHeaders add(CharSequence name, Object value);
+
+    /**
+     * Adds a new header with the specified name and values.
+     *
+     * This getMethod can be represented approximately as the following code:
+     * <pre>
+     * for (Object v: values) {
+     *     if (v == null) {
+     *         break;
+     *     }
+     *     headers.add(name, v);
+     * }
+     * </pre>
+     *
+     * @param name The name of the headepublic abstract rs being set
+     * @param values The values of the headers being set
+     * @return {@code this}
+     */
+    TextHeaders add(CharSequence name, Iterable<?> values);
+
+    TextHeaders add(CharSequence name, Object... values);
+
+    /**
+     * Adds all header entries of the specified {@code headers}.
+     *
+     * @return {@code this}
+     */
+    TextHeaders add(TextHeaders headers);
+
+    /**
+     * Sets a header with the specified name and value.
+     *
+     * If there is an existing header with the same name, it is removed.
+     * If the specified value is not a {@link String}, it is converted into a
+     * {@link String} by {@link Object#toString()}, except for {@link java.util.Date}
+     * and {@link java.util.Calendar}, which are formatted to the date format defined in
+     * <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1">RFC2616</a>.
+     *
+     * @param name The name of the header being set
+     * @param value The value of the header being set
+     * @return {@code this}
+     */
+    TextHeaders set(CharSequence name, Object value);
+
+    /**
+     * Sets a header with the specified name and values.
+     *
+     * If there is an existing header with the same name, it is removed.
+     * This getMethod can be represented approximately as the following code:
+     * <pre>
+     * headers.remove(name);
+     * for (Object v: values) {
+     *     if (v == null) {
+     *         break;
+     *     }
+     *     headers.add(name, v);
+     * }
+     * </pre>
+     *
+     * @param name The name of the headers being set
+     * @param values The values of the headers being set
+     * @return {@code this}
+     */
+    TextHeaders set(CharSequence name, Iterable<?> values);
+
+    TextHeaders set(CharSequence name, Object... values);
+
+    /**
+     * Cleans the current header entries and copies all header entries of the specified {@code headers}.
+     *
+     * @return {@code this}
+     */
+    TextHeaders set(TextHeaders headers);
+
+    /**
+     * Removes the header with the specified name.
+     *
+     * @param name The name of the header to remove
+     * @return {@code true} if and only if at least one entry has been removed
+     */
+    boolean remove(CharSequence name);
+
+    /**
+     * Removes all headers.
+     *
+     * @return {@code this}
+     */
+    TextHeaders clear();
+
+    /**
+     * Returns {@code true} if a header with the name and value exists.
+     *
+     * @param name              the headername
+     * @param value             the value
+     * @return {@code true} if it contains it {@code false} otherwise
+     */
+    boolean contains(CharSequence name, Object value);
+
+    boolean contains(CharSequence name, Object value, boolean ignoreCase);
+
+    @Override
+    Iterator<Entry<String, String>> iterator();
+
+    Iterator<Entry<CharSequence, CharSequence>> unconvertedIterator();
+
+    TextHeaders forEachEntry(TextHeaderProcessor processor);
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/base64/Base64.java b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java
index f01072f1594a..e06f67df1559 100644
--- a/codec/src/main/java/io/netty/handler/codec/base64/Base64.java
+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java
@@ -286,7 +286,7 @@ private static int decode4to3(
                         (DECODABET[src[srcOffset + 1]] & 0xFF) << 12 |
                         (DECODABET[src[srcOffset + 2]] & 0xFF) <<  6 |
                          DECODABET[src[srcOffset + 3]] & 0xFF;
-            } catch (IndexOutOfBoundsException e) {
+            } catch (IndexOutOfBoundsException ignored) {
                 throw new IllegalArgumentException("not encoded in Base64");
             }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BlockDecompressor.java b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BlockDecompressor.java
new file mode 100644
index 000000000000..a10133b255d3
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BlockDecompressor.java
@@ -0,0 +1,320 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.compression;
+
+import io.netty.buffer.ByteBuf;
+
+import static io.netty.handler.codec.compression.Bzip2Constants.*;
+
+final class Bzip2BlockDecompressor {
+    /**
+     * Calculates the block CRC from the fully decoded bytes of the block.
+     */
+    private final Crc32 crc = new Crc32();
+
+    /**
+     * The CRC of the current block as read from the block header.
+     */
+    private final int blockCRC;
+
+    /**
+     * {@code true} if the current block is randomised, otherwise {@code false}.
+     */
+    private final boolean blockRandomised;
+
+    /* Huffman Decoding stage */
+    /**
+     * The end-of-block Huffman symbol. Decoding of the block ends when this is encountered.
+     */
+    int huffmanEndOfBlockSymbol;
+
+    /**
+     * Bitmap, of ranges of 16 bytes, present/not present.
+     */
+    int huffmanInUse16;
+
+    /**
+     * A map from Huffman symbol index to output character. Some types of data (e.g. ASCII text)
+     * may contain only a limited number of byte values; Huffman symbols are only allocated to
+     * those values that actually occur in the uncompressed data.
+     */
+    final byte[] huffmanSymbolMap = new byte[256];
+
+    /* Move To Front stage */
+    /**
+     * Counts of each byte value within the {@link Bzip2BlockDecompressor#huffmanSymbolMap} data.
+     * Collected at the Move To Front stage, consumed by the Inverse Burrows Wheeler Transform stage.
+     */
+    private final int[] bwtByteCounts = new int[256];
+
+    /**
+     * The Burrows-Wheeler Transform processed data. Read at the Move To Front stage, consumed by the
+     * Inverse Burrows Wheeler Transform stage.
+     */
+    private final byte[] bwtBlock;
+
+    /**
+     * Starting pointer into BWT for after untransform.
+     */
+    private final int bwtStartPointer;
+
+    /* Inverse Burrows-Wheeler Transform stage */
+    /**
+     * At each position contains the union of :-
+     *   An output character (8 bits)
+     *   A pointer from each position to its successor (24 bits, left shifted 8 bits)
+     * As the pointer cannot exceed the maximum block size of 900k, 24 bits is more than enough to
+     * hold it; Folding the character data into the spare bits while performing the inverse BWT,
+     * when both pieces of information are available, saves a large number of memory accesses in
+     * the final decoding stages.
+     */
+    private int[] bwtMergedPointers;
+
+    /**
+     * The current merged pointer into the Burrow-Wheeler Transform array.
+     */
+    private int bwtCurrentMergedPointer;
+
+    /**
+     * The actual length in bytes of the current block at the Inverse Burrows Wheeler Transform
+     * stage (before final Run-Length Decoding).
+     */
+    private int bwtBlockLength;
+
+    /**
+     * The number of output bytes that have been decoded up to the Inverse Burrows Wheeler Transform stage.
+     */
+    private int bwtBytesDecoded;
+
+    /* Run-Length Encoding and Random Perturbation stage */
+    /**
+     * The most recently RLE decoded byte.
+     */
+    private int rleLastDecodedByte = -1;
+
+    /**
+     * The number of previous identical output bytes decoded. After 4 identical bytes, the next byte
+     * decoded is an RLE repeat count.
+     */
+    private int rleAccumulator;
+
+    /**
+     * The RLE repeat count of the current decoded byte. When this reaches zero, a new byte is decoded.
+     */
+    private int rleRepeat;
+
+    /**
+     * If the current block is randomised, the position within the RNUMS randomisation array.
+     */
+    private int randomIndex;
+
+    /**
+     * If the current block is randomised, the remaining count at the current RNUMS position.
+     */
+    private int randomCount = Bzip2Rand.rNums(0) - 1;
+
+    /**
+     * Table for Move To Front transformations.
+     */
+    final Bzip2MoveToFrontTable symbolMTF = new Bzip2MoveToFrontTable();
+
+    int repeatCount;
+    int repeatIncrement = 1;
+    int mtfValue;
+
+    Bzip2BlockDecompressor(int blockSize, int blockCRC, boolean blockRandomised, int bwtStartPointer) {
+        bwtBlock = new byte[blockSize];
+
+        this.blockCRC = blockCRC;
+        this.blockRandomised = blockRandomised;
+        this.bwtStartPointer = bwtStartPointer;
+    }
+
+    /**
+     * Reads the Huffman encoded data from the input stream, performs Run-Length Decoding and
+     * applies the Move To Front transform to reconstruct the Burrows-Wheeler Transform array.
+     */
+    boolean decodeHuffmanData(final Bzip2HuffmanStageDecoder huffmanDecoder, ByteBuf in) {
+        final byte[] bwtBlock = this.bwtBlock;
+        final byte[] huffmanSymbolMap = this.huffmanSymbolMap;
+        final int streamBlockSize = this.bwtBlock.length;
+        final int huffmanEndOfBlockSymbol = this.huffmanEndOfBlockSymbol;
+        final int[] bwtByteCounts = this.bwtByteCounts;
+        final Bzip2MoveToFrontTable symbolMTF = this.symbolMTF;
+
+        int bwtBlockLength = this.bwtBlockLength;
+        int repeatCount = this.repeatCount;
+        int repeatIncrement = this.repeatIncrement;
+        int mtfValue = this.mtfValue;
+
+        for (;;) {
+            if (in.readableBytes() < 3) {   // 3 = (HUFFMAN_DECODE_MAX_CODE_LENGTH + 1) bits / 8
+                this.bwtBlockLength = bwtBlockLength;
+                this.repeatCount = repeatCount;
+                this.repeatIncrement = repeatIncrement;
+                this.mtfValue = mtfValue;
+                return false;
+            }
+            final int nextSymbol = huffmanDecoder.nextSymbol(in);
+
+            if (nextSymbol == HUFFMAN_SYMBOL_RUNA) {
+                repeatCount += repeatIncrement;
+                repeatIncrement <<= 1;
+            } else if (nextSymbol == HUFFMAN_SYMBOL_RUNB) {
+                repeatCount += repeatIncrement << 1;
+                repeatIncrement <<= 1;
+            } else {
+                if (repeatCount > 0) {
+                    if (bwtBlockLength + repeatCount > streamBlockSize) {
+                        throw new DecompressionException("block exceeds declared block size");
+                    }
+                    final byte nextByte = huffmanSymbolMap[mtfValue];
+                    bwtByteCounts[nextByte & 0xff] += repeatCount;
+                    while (--repeatCount >= 0) {
+                        bwtBlock[bwtBlockLength++] = nextByte;
+                    }
+
+                    repeatCount = 0;
+                    repeatIncrement = 1;
+                }
+
+                if (nextSymbol == huffmanEndOfBlockSymbol) {
+                    break;
+                }
+
+                if (bwtBlockLength >= streamBlockSize) {
+                    throw new DecompressionException("block exceeds declared block size");
+                }
+
+                mtfValue = symbolMTF.indexToFront(nextSymbol - 1) & 0xff;
+
+                final byte nextByte = huffmanSymbolMap[mtfValue];
+                bwtByteCounts[nextByte & 0xff]++;
+                bwtBlock[bwtBlockLength++] = nextByte;
+            }
+        }
+        this.bwtBlockLength = bwtBlockLength;
+        initialiseInverseBWT();
+        return true;
+    }
+
+    /**
+     * Set up the Inverse Burrows-Wheeler Transform merged pointer array.
+     */
+    private void initialiseInverseBWT() {
+        final int bwtStartPointer = this.bwtStartPointer;
+        final byte[] bwtBlock  = this.bwtBlock;
+        final int[] bwtMergedPointers = new int[bwtBlockLength];
+        final int[] characterBase = new int[256];
+
+        if (bwtStartPointer < 0 || bwtStartPointer >= bwtBlockLength) {
+            throw new DecompressionException("start pointer invalid");
+        }
+
+        // Cumulative character counts
+        System.arraycopy(bwtByteCounts, 0, characterBase, 1, 255);
+        for (int i = 2; i <= 255; i++) {
+            characterBase[i] += characterBase[i - 1];
+        }
+
+        // Merged-Array Inverse Burrows-Wheeler Transform
+        // Combining the output characters and forward pointers into a single array here, where we
+        // have already read both of the corresponding values, cuts down on memory accesses in the
+        // final walk through the array
+        for (int i = 0; i < bwtBlockLength; i++) {
+            int value = bwtBlock[i] & 0xff;
+            bwtMergedPointers[characterBase[value]++] = (i << 8) + value;
+        }
+
+        this.bwtMergedPointers = bwtMergedPointers;
+        bwtCurrentMergedPointer = bwtMergedPointers[bwtStartPointer];
+    }
+
+    /**
+     * Decodes a byte from the final Run-Length Encoding stage, pulling a new byte from the
+     * Burrows-Wheeler Transform stage when required.
+     * @return The decoded byte, or -1 if there are no more bytes
+     */
+    public int read() {
+        while (rleRepeat < 1) {
+            if (bwtBytesDecoded == bwtBlockLength) {
+                return -1;
+            }
+
+            int nextByte = decodeNextBWTByte();
+            if (nextByte != rleLastDecodedByte) {
+                // New byte, restart accumulation
+                rleLastDecodedByte = nextByte;
+                rleRepeat = 1;
+                rleAccumulator = 1;
+                crc.updateCRC(nextByte);
+            } else {
+                if (++rleAccumulator == 4) {
+                    // Accumulation complete, start repetition
+                    int rleRepeat = decodeNextBWTByte() + 1;
+                    this.rleRepeat = rleRepeat;
+                    rleAccumulator = 0;
+                    crc.updateCRC(nextByte, rleRepeat);
+                } else {
+                    rleRepeat = 1;
+                    crc.updateCRC(nextByte);
+                }
+            }
+        }
+        rleRepeat--;
+
+        return rleLastDecodedByte;
+    }
+
+    /**
+     * Decodes a byte from the Burrows-Wheeler Transform stage. If the block has randomisation
+     * applied, reverses the randomisation.
+     * @return The decoded byte
+     */
+    private int decodeNextBWTByte() {
+        int mergedPointer = bwtCurrentMergedPointer;
+        int nextDecodedByte =  mergedPointer & 0xff;
+        bwtCurrentMergedPointer = bwtMergedPointers[mergedPointer >>> 8];
+
+        if (blockRandomised) {
+            if (--randomCount == 0) {
+                nextDecodedByte ^= 1;
+                randomIndex = (randomIndex + 1) % 512;
+                randomCount = Bzip2Rand.rNums(randomIndex);
+            }
+        }
+        bwtBytesDecoded++;
+
+        return nextDecodedByte;
+    }
+
+    public int blockLength() {
+        return bwtBlockLength;
+    }
+
+    /**
+     * Verify and return the block CRC. This method may only be called
+     * after all of the block's bytes have been read.
+     * @return The block CRC
+     */
+    int checkCRC() {
+        final int computedBlockCRC = crc.getCRC();
+        if (blockCRC != computedBlockCRC) {
+            throw new DecompressionException("block CRC error");
+        }
+        return computedBlockCRC;
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Constants.java b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Constants.java
new file mode 100644
index 000000000000..cb1276d86674
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Constants.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.compression;
+
+/**
+ * Constants for {@link Bzip2Decoder}.
+ */
+final class Bzip2Constants {
+
+    /**
+     * Magic number of Bzip2 stream.
+     */
+    static final int MAGIC_NUMBER = 'B' << 16 | 'Z' << 8 | 'h';
+
+    /**
+     * Block header magic number. Equals to BCD (pi).
+     */
+    static final long COMPRESSED_MAGIC = 0x314159265359L;
+
+    /**
+     * End of stream magic number. Equals to BCD sqrt(pi).
+     */
+    static final long END_OF_STREAM_MAGIC = 0x177245385090L;
+
+    /**
+     * Base block size.
+     */
+    static final int BASE_BLOCK_SIZE = 100000;
+
+    /**
+     * Minimum and maximum size of one block.
+     * Must be multiplied by {@link Bzip2Constants#BASE_BLOCK_SIZE}.
+     */
+    static final int MIN_BLOCK_SIZE = 1;
+    static final int MAX_BLOCK_SIZE = 9;
+
+    /**
+     * Maximum possible Huffman alphabet size.
+     */
+    static final int HUFFMAN_MAX_ALPHABET_SIZE = 258;
+
+    /**
+     * The longest Huffman code length created by the encoder.
+     */
+    static final int HUFFMAN_ENCODE_MAX_CODE_LENGTH = 20;
+
+    /**
+     * The longest Huffman code length accepted by the decoder.
+     */
+    static final int HUFFMAN_DECODE_MAX_CODE_LENGTH = 23;
+
+    /**
+     * Huffman symbols used for run-length encoding.
+     */
+    static final int HUFFMAN_SYMBOL_RUNA = 0;
+    static final int HUFFMAN_SYMBOL_RUNB = 1;
+
+    /**
+     * Number of symbols decoded after which a new Huffman table is selected.
+     */
+    static final int HUFFMAN_GROUP_RUN_LENGTH = 50;
+
+    /**
+     * Maximum possible number of Huffman table selectors.
+     */
+    static final int MAX_SELECTORS = 2 + 900000 / HUFFMAN_GROUP_RUN_LENGTH; // 18002
+
+    /**
+     * Minimum number of alternative Huffman tables.
+     */
+    static final int HUFFMAN_MINIMUM_TABLES = 2;
+
+    /**
+     * Maximum number of alternative Huffman tables.
+     */
+    static final int HUFFMAN_MAXIMUM_TABLES = 6;
+
+    private Bzip2Constants() { }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java
new file mode 100644
index 000000000000..614dfd7ae79a
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java
@@ -0,0 +1,347 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.compression;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+
+import java.util.List;
+
+import static io.netty.handler.codec.compression.Bzip2Constants.*;
+
+/**
+ * Uncompresses a {@link ByteBuf} encoded with the Bzip2 format.
+ *
+ * See <a href="http://en.wikipedia.org/wiki/Bzip2">Bzip2</a>.
+ */
+public class Bzip2Decoder extends ByteToMessageDecoder {
+    /**
+     * Current state of stream.
+     */
+    enum State {
+        INIT,
+        INIT_BLOCK,
+        INIT_BLOCK_PARAMS,
+        RECEIVE_HUFFMAN_USED_MAP,
+        RECEIVE_HUFFMAN_USED_BITMAPS,
+        RECEIVE_SELECTORS_NUMBER,
+        RECEIVE_SELECTORS,
+        RECEIVE_HUFFMAN_LENGTH,
+        DECODE_HUFFMAN_DATA,
+        END_BLOCK,
+        EOF
+    }
+    private State currentState = State.INIT;
+
+    /**
+     * The decompressor for the current block.
+     */
+    private Bzip2BlockDecompressor blockDecompressor;
+
+    /**
+     * BZip2 Huffman coding stage.
+     */
+    private Bzip2HuffmanStageDecoder huffmanStageDecoder;
+
+    /**
+     * Always: in the range 0 .. 9. The current block size is 100000 * this number.
+     */
+    private int blockSize;
+
+    /**
+     * The CRC of the current block as read from the block header.
+     */
+    private int blockCRC;
+
+    /**
+     * The merged CRC of all blocks decompressed so far.
+     */
+    private int streamCRC;
+
+    // For bitwise access
+    /**
+     * A buffer of bits read from the input stream that have not yet been returned.
+     */
+    private int bitBuffer;
+
+    /**
+     * The number of bits currently buffered in {@link #bitBuffer}.
+     */
+    private int bitCount;
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        if (!in.isReadable()) {
+            return;
+        }
+
+        for (;;) {
+            switch (currentState) {
+                case INIT:
+                    if (in.readableBytes() < 4) {
+                        return;
+                    }
+                    int magicNumber = in.readUnsignedMedium();
+                    if (magicNumber != MAGIC_NUMBER) {
+                        throw new DecompressionException("Unexpected stream identifier contents. Mismatched bzip2 " +
+                                "protocol version?");
+                    }
+                    int blockSize = in.readByte() - '0';
+                    if (blockSize < MIN_BLOCK_SIZE || blockSize > MAX_BLOCK_SIZE) {
+                        throw new DecompressionException("block size is invalid");
+                    }
+                    this.blockSize = blockSize * BASE_BLOCK_SIZE;
+
+                    streamCRC = 0;
+                    currentState = State.INIT_BLOCK;
+                case INIT_BLOCK:
+                    if (in.readableBytes() < 10) {
+                        return;
+                    }
+                    // Get the block magic bytes.
+                    final long magic = (long) readBits(in, 24) << 24 | readBits(in, 24);
+                    if (magic == END_OF_STREAM_MAGIC) {
+                        // End of stream was reached. Check the combined CRC.
+                        final int storedCombinedCRC = readInt(in);
+                        if (storedCombinedCRC != streamCRC) {
+                            throw new DecompressionException("stream CRC error");
+                        }
+                        currentState = State.EOF;
+                        break;
+                    }
+                    if (magic != COMPRESSED_MAGIC) {
+                        throw new DecompressionException("bad block header");
+                    }
+                    blockCRC = readInt(in);
+                    currentState = State.INIT_BLOCK_PARAMS;
+                case INIT_BLOCK_PARAMS:
+                    if (in.readableBytes() < 4) {
+                        return;
+                    }
+                    final boolean blockRandomised = readBoolean(in);
+                    final int bwtStartPointer = readBits(in, 24);
+
+                    blockDecompressor = new Bzip2BlockDecompressor(this.blockSize, blockCRC,
+                                                                    blockRandomised, bwtStartPointer);
+                    currentState = State.RECEIVE_HUFFMAN_USED_MAP;
+                case RECEIVE_HUFFMAN_USED_MAP:
+                    if (in.readableBytes() < 2) {
+                        return;
+                    }
+                    blockDecompressor.huffmanInUse16 = readBits(in, 16);
+                    currentState = State.RECEIVE_HUFFMAN_USED_BITMAPS;
+                case RECEIVE_HUFFMAN_USED_BITMAPS:
+                    Bzip2BlockDecompressor blockDecompressor = this.blockDecompressor;
+                    final int inUse16 = blockDecompressor.huffmanInUse16;
+                    final int bitNumber = Integer.bitCount(inUse16);
+                    final byte[] huffmanSymbolMap = blockDecompressor.huffmanSymbolMap;
+
+                    if (in.readableBytes() < bitNumber * 16 / 8 + 1) {
+                        return;
+                    }
+
+                    int huffmanSymbolCount = 0;
+                    if (bitNumber > 0) {
+                        for (int i = 0; i < 16; i++) {
+                            if ((inUse16 & 1 << 15 >>> i) != 0) {
+                                for (int j = 0, k = i << 4; j < 16; j++, k++) {
+                                    if (readBoolean(in)) {
+                                        huffmanSymbolMap[huffmanSymbolCount++] = (byte) k;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                    blockDecompressor.huffmanEndOfBlockSymbol = huffmanSymbolCount + 1;
+
+                    int totalTables = readBits(in, 3);
+                    if (totalTables < HUFFMAN_MINIMUM_TABLES || totalTables > HUFFMAN_MAXIMUM_TABLES) {
+                        throw new DecompressionException("incorrect huffman groups number");
+                    }
+                    int alphaSize = huffmanSymbolCount + 2;
+                    if (alphaSize > HUFFMAN_MAX_ALPHABET_SIZE) {
+                        throw new DecompressionException("incorrect alphabet size");
+                    }
+                    huffmanStageDecoder = new Bzip2HuffmanStageDecoder(this, totalTables, alphaSize);
+                    currentState = State.RECEIVE_SELECTORS_NUMBER;
+                case RECEIVE_SELECTORS_NUMBER:
+                    if (in.readableBytes() < 2) {
+                        return;
+                    }
+                    int totalSelectors = readBits(in, 15);
+                    if (totalSelectors < 1 || totalSelectors > MAX_SELECTORS) {
+                        throw new DecompressionException("incorrect selectors number");
+                    }
+                    huffmanStageDecoder.selectors = new byte[totalSelectors];
+
+                    currentState = State.RECEIVE_SELECTORS;
+                case RECEIVE_SELECTORS:
+                    Bzip2HuffmanStageDecoder huffmanStageDecoder = this.huffmanStageDecoder;
+                    byte[] selectors = huffmanStageDecoder.selectors;
+                    totalSelectors = selectors.length;
+                    final Bzip2MoveToFrontTable tableMtf = huffmanStageDecoder.tableMTF;
+
+                    int currSelector;
+                    // Get zero-terminated bit runs (0..62) of MTF'ed Huffman table. length = 1..6
+                    for (currSelector = huffmanStageDecoder.currentSelector;
+                                currSelector < totalSelectors; currSelector++) {
+                        if (!in.isReadable()) {
+                            // Save state if end of current ByteBuf was reached
+                            huffmanStageDecoder.currentSelector = currSelector;
+                            return;
+                        }
+                        int index = 0;
+                        while (readBoolean(in)) {
+                            index++;
+                        }
+                        selectors[currSelector] = tableMtf.indexToFront(index);
+                    }
+
+                    currentState = State.RECEIVE_HUFFMAN_LENGTH;
+                case RECEIVE_HUFFMAN_LENGTH:
+                    huffmanStageDecoder = this.huffmanStageDecoder;
+                    totalTables = huffmanStageDecoder.totalTables;
+                    final byte[][] codeLength = huffmanStageDecoder.tableCodeLengths;
+                    alphaSize = huffmanStageDecoder.alphabetSize;
+
+                    /* Now the coding tables */
+                    int currGroup;
+                    int currLength = huffmanStageDecoder.currentLength;
+                    int currAlpha = 0;
+                    boolean modifyLength = huffmanStageDecoder.modifyLength;
+                    boolean saveStateAndReturn = false;
+                    loop: for (currGroup = huffmanStageDecoder.currentGroup; currGroup < totalTables; currGroup++) {
+                        // start_huffman_length
+                        if (!in.isReadable()) {
+                            saveStateAndReturn = true;
+                            break;
+                        }
+                        if (currLength < 0) {
+                            currLength = readBits(in, 5);
+                        }
+                        for (currAlpha = huffmanStageDecoder.currentAlpha; currAlpha < alphaSize; currAlpha++) {
+                            // delta_bit_length: 1..40
+                            if (!hasBit(in)) {
+                                saveStateAndReturn = true;
+                                break loop;
+                            }
+                            while (modifyLength || readBoolean(in)) {  // 0=>next symbol; 1=>alter length
+                                if (!hasBit(in)) {
+                                    modifyLength = true;
+                                    saveStateAndReturn = true;
+                                    break loop;
+                                }
+                                currLength += readBoolean(in) ? -1 : 1; // 1=>decrement length;  0=>increment length
+                                modifyLength = false;
+                                if (!hasBit(in)) {
+                                    saveStateAndReturn = true;
+                                    break loop;
+                                }
+                            }
+                            codeLength[currGroup][currAlpha] = (byte) currLength;
+                        }
+                        currLength = -1;
+                        currAlpha = huffmanStageDecoder.currentAlpha = 0;
+                        modifyLength = false;
+                    }
+                    if (saveStateAndReturn) {
+                        // Save state if end of current ByteBuf was reached
+                        huffmanStageDecoder.currentGroup = currGroup;
+                        huffmanStageDecoder.currentLength = currLength;
+                        huffmanStageDecoder.currentAlpha = currAlpha;
+                        huffmanStageDecoder.modifyLength = modifyLength;
+                        return;
+                    }
+
+                    // Finally create the Huffman tables
+                    huffmanStageDecoder.createHuffmanDecodingTables();
+                    currentState = State.DECODE_HUFFMAN_DATA;
+                case DECODE_HUFFMAN_DATA:
+                    blockDecompressor = this.blockDecompressor;
+                    final boolean decoded = blockDecompressor.decodeHuffmanData(this.huffmanStageDecoder, in);
+                    if (!decoded) {
+                        return;
+                    }
+
+                    final int blockLength = blockDecompressor.blockLength();
+                    final ByteBuf uncompressed = ctx.alloc().buffer(blockLength);
+                    boolean success = false;
+                    try {
+                        int uncByte;
+                        while ((uncByte = blockDecompressor.read()) >= 0) {
+                            uncompressed.writeByte(uncByte);
+                        }
+
+                        int currentBlockCRC = blockDecompressor.checkCRC();
+                        streamCRC = (streamCRC << 1 | streamCRC >>> 31) ^ currentBlockCRC;
+
+                        out.add(uncompressed);
+                        success = true;
+                    } finally {
+                        if (!success) {
+                            uncompressed.release();
+                        }
+                    }
+                    currentState = State.INIT_BLOCK;
+                    break;
+                case EOF:
+                    in.skipBytes(in.readableBytes());
+                    return;
+                default:
+                    throw new IllegalStateException();
+            }
+        }
+    }
+
+    /**
+     * Returns {@code true} if and only if the end of the compressed stream
+     * has been reached.
+     */
+    public boolean isClosed() {
+        return currentState == State.EOF;
+    }
+
+    int readBits(ByteBuf in, final int n) {
+        int bitCount = this.bitCount;
+        int bitBuffer = this.bitBuffer;
+
+        if (bitCount < n) {
+            do {
+                int uByte = in.readUnsignedByte();
+                bitBuffer = bitBuffer << 8 | uByte;
+                bitCount += 8;
+            } while (bitCount < n);
+
+            this.bitBuffer = bitBuffer;
+        }
+
+        this.bitCount = bitCount -= n;
+        return bitBuffer >>> bitCount & (1 << n) - 1;
+    }
+
+    private boolean readBoolean(ByteBuf in) {
+        return readBits(in, 1) != 0;
+    }
+
+    private int readInt(ByteBuf in) {
+        return readBits(in, 16) << 16 | readBits(in, 16);
+    }
+
+    private boolean hasBit(ByteBuf in) {
+        return bitCount > 0 || in.isReadable();
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanStageDecoder.java b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanStageDecoder.java
new file mode 100644
index 000000000000..a95d2171ce79
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanStageDecoder.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.compression;
+
+import io.netty.buffer.ByteBuf;
+
+import static io.netty.handler.codec.compression.Bzip2Constants.*;
+/**
+ * A decoder for the BZip2 Huffman coding stage
+ */
+final class Bzip2HuffmanStageDecoder {
+
+    /**
+     * The Huffman table number to use for each group of 50 symbols.
+     */
+    byte[] selectors;
+
+    /**
+     * The minimum code length for each Huffman table.
+     */
+    private final int[] minimumLengths;
+
+    /**
+     * An array of values for each Huffman table that must be subtracted from the numerical value of
+     * a Huffman code of a given bit length to give its canonical code index.
+     */
+    private final int[][] codeBases;
+
+    /**
+     * An array of values for each Huffman table that gives the highest numerical value of a Huffman
+     * code of a given bit length.
+     */
+    private final int[][] codeLimits;
+
+    /**
+     * A mapping for each Huffman table from canonical code index to output symbol.
+     */
+    private final int[][] codeSymbols;
+
+    /**
+     * The Huffman table for the current group.
+     */
+    private int currentTable;
+
+    /**
+     * The index of the current group within the selectors array.
+     */
+    private int groupIndex = -1;
+
+    /**
+     * The byte position within the current group. A new group is selected every 50 decoded bytes.
+     */
+    private int groupPosition = -1;
+
+    /**
+     * Total number of used Huffman tables in range 2..6.
+     */
+    final int totalTables;
+
+    /**
+     * The total number of codes (uniform for each table).
+     */
+    final int alphabetSize;
+
+    /**
+     * Table for Move To Front transformations.
+     */
+    final Bzip2MoveToFrontTable tableMTF = new Bzip2MoveToFrontTable();
+
+    // For saving state if end of current ByteBuf was reached
+    int currentSelector;
+
+    /**
+     * The Canonical Huffman code lengths for each table.
+     */
+    final byte[][] tableCodeLengths;
+
+    // For saving state if end of current ByteBuf was reached
+    int currentGroup;
+    int currentLength = -1;
+    int currentAlpha;
+    boolean modifyLength;
+
+    final Bzip2Decoder decoder;
+
+    Bzip2HuffmanStageDecoder(final Bzip2Decoder decoder, final int totalTables, final int alphabetSize) {
+        this.decoder = decoder;
+        this.totalTables = totalTables;
+        this.alphabetSize = alphabetSize;
+
+        minimumLengths = new int[totalTables];
+        codeBases = new int[totalTables][HUFFMAN_DECODE_MAX_CODE_LENGTH + 2];
+        codeLimits = new int[totalTables][HUFFMAN_DECODE_MAX_CODE_LENGTH + 1];
+        codeSymbols = new int[totalTables][HUFFMAN_MAX_ALPHABET_SIZE];
+        tableCodeLengths = new byte[totalTables][HUFFMAN_MAX_ALPHABET_SIZE];
+    }
+
+    /**
+     * Constructs Huffman decoding tables from lists of Canonical Huffman code lengths.
+     */
+    void createHuffmanDecodingTables() {
+        final int alphabetSize = this.alphabetSize;
+
+        for (int table = 0; table < tableCodeLengths.length; table++) {
+            final int[] tableBases = codeBases[table];
+            final int[] tableLimits = codeLimits[table];
+            final int[] tableSymbols = codeSymbols[table];
+            final byte[] codeLengths = tableCodeLengths[table];
+
+            int minimumLength = HUFFMAN_DECODE_MAX_CODE_LENGTH;
+            int maximumLength = 0;
+
+            // Find the minimum and maximum code length for the table
+            for (int i = 0; i < alphabetSize; i++) {
+                final byte currLength = codeLengths[i];
+                maximumLength = Math.max(currLength, maximumLength);
+                minimumLength = Math.min(currLength, minimumLength);
+            }
+            minimumLengths[table] = minimumLength;
+
+            // Calculate the first output symbol for each code length
+            for (int i = 0; i < alphabetSize; i++) {
+                tableBases[codeLengths[i] + 1]++;
+            }
+            for (int i = 1, b = tableBases[0]; i < HUFFMAN_DECODE_MAX_CODE_LENGTH + 2; i++) {
+                b += tableBases[i];
+                tableBases[i] = b;
+            }
+
+            // Calculate the first and last Huffman code for each code length (codes at a given
+            // length are sequential in value)
+            for (int i = minimumLength, code = 0; i <= maximumLength; i++) {
+                int base = code;
+                code += tableBases[i + 1] - tableBases[i];
+                tableBases[i] = base - tableBases[i];
+                tableLimits[i] = code - 1;
+                code <<= 1;
+            }
+
+            // Populate the mapping from canonical code index to output symbol
+            for (int bitLength = minimumLength, codeIndex = 0; bitLength <= maximumLength; bitLength++) {
+                for (int symbol = 0; symbol < alphabetSize; symbol++) {
+                    if (codeLengths[symbol] == bitLength) {
+                        tableSymbols[codeIndex++] = symbol;
+                    }
+                }
+            }
+        }
+
+        currentTable = selectors[0];
+    }
+
+    /**
+     * Decodes and returns the next symbol.
+     * @return The decoded symbol
+     */
+    int nextSymbol(ByteBuf in) {
+        // Move to next group selector if required
+        if (++groupPosition % HUFFMAN_GROUP_RUN_LENGTH == 0) {
+            groupIndex++;
+            if (groupIndex == selectors.length) {
+                throw new DecompressionException("error decoding block");
+            }
+            currentTable = selectors[groupIndex] & 0xff;
+        }
+
+        final Bzip2Decoder decoder = this.decoder;
+        final int currentTable = this.currentTable;
+        final int[] tableLimits = codeLimits[currentTable];
+        final int[] tableBases = codeBases[currentTable];
+        final int[] tableSymbols = codeSymbols[currentTable];
+        int codeLength = minimumLengths[currentTable];
+
+        // Starting with the minimum bit length for the table, read additional bits one at a time
+        // until a complete code is recognised
+        int codeBits = decoder.readBits(in, codeLength);
+        for (; codeLength <= HUFFMAN_DECODE_MAX_CODE_LENGTH; codeLength++) {
+            if (codeBits <= tableLimits[codeLength]) {
+                // Convert the code to a symbol index and return
+                return tableSymbols[codeBits - tableBases[codeLength]];
+            }
+            codeBits = codeBits << 1 | decoder.readBits(in, 1);
+        }
+
+        throw new DecompressionException("a valid code was not recognised");
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Bzip2MoveToFrontTable.java b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2MoveToFrontTable.java
new file mode 100644
index 000000000000..18e2512fcfcc
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2MoveToFrontTable.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.compression;
+
+/**
+ * A 256 entry Move To Front transform.
+ */
+class Bzip2MoveToFrontTable {
+    /**
+     * The Move To Front list.
+     */
+    private final byte[] mtf = {
+         0,    1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
+         16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
+         32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
+         48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,
+         64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
+         80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
+         96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
+        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
+        (byte) 128, (byte) 129, (byte) 130, (byte) 131, (byte) 132, (byte) 133, (byte) 134, (byte) 135,
+        (byte) 136, (byte) 137, (byte) 138, (byte) 139, (byte) 140, (byte) 141, (byte) 142, (byte) 143,
+        (byte) 144, (byte) 145, (byte) 146, (byte) 147, (byte) 148, (byte) 149, (byte) 150, (byte) 151,
+        (byte) 152, (byte) 153, (byte) 154, (byte) 155, (byte) 156, (byte) 157, (byte) 158, (byte) 159,
+        (byte) 160, (byte) 161, (byte) 162, (byte) 163, (byte) 164, (byte) 165, (byte) 166, (byte) 167,
+        (byte) 168, (byte) 169, (byte) 170, (byte) 171, (byte) 172, (byte) 173, (byte) 174, (byte) 175,
+        (byte) 176, (byte) 177, (byte) 178, (byte) 179, (byte) 180, (byte) 181, (byte) 182, (byte) 183,
+        (byte) 184, (byte) 185, (byte) 186, (byte) 187, (byte) 188, (byte) 189, (byte) 190, (byte) 191,
+        (byte) 192, (byte) 193, (byte) 194, (byte) 195, (byte) 196, (byte) 197, (byte) 198, (byte) 199,
+        (byte) 200, (byte) 201, (byte) 202, (byte) 203, (byte) 204, (byte) 205, (byte) 206, (byte) 207,
+        (byte) 208, (byte) 209, (byte) 210, (byte) 211, (byte) 212, (byte) 213, (byte) 214, (byte) 215,
+        (byte) 216, (byte) 217, (byte) 218, (byte) 219, (byte) 220, (byte) 221, (byte) 222, (byte) 223,
+        (byte) 224, (byte) 225, (byte) 226, (byte) 227, (byte) 228, (byte) 229, (byte) 230, (byte) 231,
+        (byte) 232, (byte) 233, (byte) 234, (byte) 235, (byte) 236, (byte) 237, (byte) 238, (byte) 239,
+        (byte) 240, (byte) 241, (byte) 242, (byte) 243, (byte) 244, (byte) 245, (byte) 246, (byte) 247,
+        (byte) 248, (byte) 249, (byte) 250, (byte) 251, (byte) 252, (byte) 253, (byte) 254, (byte) 255
+    };
+
+    /**
+     * Moves a value to the head of the MTF list (forward Move To Front transform).
+     * @param value The value to move
+     * @return The position the value moved from
+     */
+    int valueToFront(final byte value) {
+        int index = 0;
+        byte temp = mtf[0];
+        if (value != temp) {
+            mtf[0] = value;
+            while (value != temp) {
+                index++;
+                final byte temp2 = temp;
+                temp = mtf[index];
+                mtf[index] = temp2;
+            }
+        }
+        return index;
+    }
+
+    /**
+     * Gets the value from a given index and moves it to the front of the MTF list (inverse Move To Front transform).
+     * @param index The index to move
+     * @return The value at the given index
+     */
+    byte indexToFront(final int index) {
+        final byte value = mtf[index];
+        System.arraycopy(mtf, 0, mtf, 1, index);
+        mtf[0] = value;
+
+        return value;
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Rand.java b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Rand.java
new file mode 100644
index 000000000000..86326b4aafef
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Rand.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.compression;
+
+final class Bzip2Rand {
+    /**
+     * The BZip2 specification originally included the optional addition of a slight pseudo-random
+     * perturbation to the input data, in order to work around the block sorting algorithm's non-
+     * optimal performance on some types of input. The current mainline bzip2 does not require this
+     * and will not create randomised blocks, but compatibility is still required for old data (and
+     * third party compressors that haven't caught up). When decompressing a randomised block, for
+     * each value N in this array, a 1 will be XOR'd onto the output of the Burrows-Wheeler
+     * transform stage after N bytes, then the next N taken from the following entry.
+     */
+    private static final int[] RNUMS = {
+            619, 720, 127, 481, 931, 816, 813, 233, 566, 247, 985, 724, 205, 454, 863, 491,
+            741, 242, 949, 214, 733, 859, 335, 708, 621, 574,  73, 654, 730, 472, 419, 436,
+            278, 496, 867, 210, 399, 680, 480,  51, 878, 465, 811, 169, 869, 675, 611, 697,
+            867, 561, 862, 687, 507, 283, 482, 129, 807, 591, 733, 623, 150, 238,  59, 379,
+            684, 877, 625, 169, 643, 105, 170, 607, 520, 932, 727, 476, 693, 425, 174, 647,
+             73, 122, 335, 530, 442, 853, 695, 249, 445, 515, 909, 545, 703, 919, 874, 474,
+            882, 500, 594, 612, 641, 801, 220, 162, 819, 984, 589, 513, 495, 799, 161, 604,
+            958, 533, 221, 400, 386, 867, 600, 782, 382, 596, 414, 171, 516, 375, 682, 485,
+            911, 276,  98, 553, 163, 354, 666, 933, 424, 341, 533, 870, 227, 730, 475, 186,
+            263, 647, 537, 686, 600, 224, 469,  68, 770, 919, 190, 373, 294, 822, 808, 206,
+            184, 943, 795, 384, 383, 461, 404, 758, 839, 887, 715,  67, 618, 276, 204, 918,
+            873, 777, 604, 560, 951, 160, 578, 722,  79, 804,  96, 409, 713, 940, 652, 934,
+            970, 447, 318, 353, 859, 672, 112, 785, 645, 863, 803, 350, 139,  93, 354,  99,
+            820, 908, 609, 772, 154, 274, 580, 184,  79, 626, 630, 742, 653, 282, 762, 623,
+            680,  81, 927, 626, 789, 125, 411, 521, 938, 300, 821,  78, 343, 175, 128, 250,
+            170, 774, 972, 275, 999, 639, 495,  78, 352, 126, 857, 956, 358, 619, 580, 124,
+            737, 594, 701, 612, 669, 112, 134, 694, 363, 992, 809, 743, 168, 974, 944, 375,
+            748,  52, 600, 747, 642, 182, 862,  81, 344, 805, 988, 739, 511, 655, 814, 334,
+            249, 515, 897, 955, 664, 981, 649, 113, 974, 459, 893, 228, 433, 837, 553, 268,
+            926, 240, 102, 654, 459,  51, 686, 754, 806, 760, 493, 403, 415, 394, 687, 700,
+            946, 670, 656, 610, 738, 392, 760, 799, 887, 653, 978, 321, 576, 617, 626, 502,
+            894, 679, 243, 440, 680, 879, 194, 572, 640, 724, 926,  56, 204, 700, 707, 151,
+            457, 449, 797, 195, 791, 558, 945, 679, 297,  59,  87, 824, 713, 663, 412, 693,
+            342, 606, 134, 108, 571, 364, 631, 212, 174, 643, 304, 329, 343,  97, 430, 751,
+            497, 314, 983, 374, 822, 928, 140, 206,  73, 263, 980, 736, 876, 478, 430, 305,
+            170, 514, 364, 692, 829,  82, 855, 953, 676, 246, 369, 970, 294, 750, 807, 827,
+            150, 790, 288, 923, 804, 378, 215, 828, 592, 281, 565, 555, 710,  82, 896, 831,
+            547, 261, 524, 462, 293, 465, 502,  56, 661, 821, 976, 991, 658, 869, 905, 758,
+            745, 193, 768, 550, 608, 933, 378, 286, 215, 979, 792, 961,  61, 688, 793, 644,
+            986, 403, 106, 366, 905, 644, 372, 567, 466, 434, 645, 210, 389, 550, 919, 135,
+            780, 773, 635, 389, 707, 100, 626, 958, 165, 504, 920, 176, 193, 713, 857, 265,
+            203,  50, 668, 108, 645, 990, 626, 197, 510, 357, 358, 850, 858, 364, 936, 638
+    };
+
+    /**
+     * Return the random number at a specific index.
+     *
+     * @param i the index
+     * @return the random number
+     */
+    static int rNums(int i) {
+        return RNUMS[i];
+    }
+
+    private Bzip2Rand() { }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Crc32.java b/codec/src/main/java/io/netty/handler/codec/compression/Crc32.java
new file mode 100644
index 000000000000..a66c03b2837f
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Crc32.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.compression;
+
+/**
+ * A CRC32 calculator.
+ */
+final class Crc32 {
+    /**
+     * A static CRC lookup table.
+     */
+    private static final int[] crc32Table = {
+            0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
+            0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
+            0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
+            0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
+            0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
+            0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
+            0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
+            0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
+            0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
+            0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
+            0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
+            0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
+            0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
+            0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
+            0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
+            0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
+            0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
+            0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
+            0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
+            0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
+            0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
+            0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
+            0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
+            0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
+            0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
+            0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
+            0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
+            0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
+            0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
+            0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
+            0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
+            0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
+            0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
+            0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
+            0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
+            0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
+            0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
+            0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
+            0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
+            0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
+            0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
+            0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
+            0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
+            0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
+            0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
+            0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
+            0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
+            0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
+            0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
+            0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
+            0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
+            0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
+            0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
+            0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
+            0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
+            0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
+            0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
+            0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
+            0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
+            0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
+            0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
+            0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
+            0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
+            0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
+    };
+
+    /**
+     * The current CRC.
+     */
+    private int crc = 0xffffffff;
+
+    /**
+     * @return The current CRC.
+     */
+    public int getCRC() {
+        return ~crc;
+    }
+
+    /**
+     * Update the CRC with a single byte.
+     * @param value The value to update the CRC with
+     */
+    public void updateCRC(final int value) {
+        final int crc = this.crc;
+        this.crc = crc << 8 ^ crc32Table[(crc >> 24 ^ value) & 0xff];
+    }
+
+    /**
+     * Update the CRC with a sequence of identical bytes.
+     * @param value The value to update the CRC with
+     * @param count The number of bytes
+     */
+    public void updateCRC(final int value, int count) {
+        while (count-- > 0) {
+            updateCRC(value);
+        }
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Crc32c.java b/codec/src/main/java/io/netty/handler/codec/compression/Crc32c.java
index b67c20004aed..e82380bd4efb 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/Crc32c.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Crc32c.java
@@ -93,7 +93,7 @@ class Crc32c implements Checksum {
             0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,
     };
 
-    private static final int LONG_MASK = 0xFFFFFFFF;
+    private static final long LONG_MASK = 0xFFFFFFFFL;
     private static final int BYTE_MASK = 0xFF;
 
     private int crc = ~0;
@@ -121,6 +121,6 @@ public void reset() {
     }
 
     private static int crc32c(int crc, int b) {
-        return (crc >>> 8) ^ CRC_TABLE[(crc ^ (b & BYTE_MASK)) & BYTE_MASK];
+        return crc >>> 8 ^ CRC_TABLE[(crc ^ b & BYTE_MASK) & BYTE_MASK];
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java
index b346b3f9527c..a35f48fda1b4 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java
@@ -18,7 +18,6 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 
-import java.nio.ByteOrder;
 import java.util.List;
 import java.util.zip.CRC32;
 import java.util.zip.DataFormatException;
@@ -36,7 +35,7 @@ public class JdkZlibDecoder extends ZlibDecoder {
     private static final int FCOMMENT = 0x10;
     private static final int FRESERVED = 0xE0;
 
-    private final Inflater inflater;
+    private Inflater inflater;
     private final byte[] dictionary;
 
     // GZIP related
@@ -59,6 +58,8 @@ private enum GzipState {
 
     private volatile boolean finished;
 
+    private boolean decideZlibOrNone;
+
     /**
      * Creates a new instance with the default wrapper ({@link ZlibWrapper#ZLIB}).
      */
@@ -101,6 +102,11 @@ private JdkZlibDecoder(ZlibWrapper wrapper, byte[] dictionary) {
                 inflater = new Inflater();
                 crc = null;
                 break;
+            case ZLIB_OR_NONE:
+                // Postpone the decision until decode(...) is called.
+                decideZlibOrNone = true;
+                crc = null;
+                break;
             default:
                 throw new IllegalArgumentException("Only GZIP or ZLIB is supported, but you used " + wrapper);
         }
@@ -124,6 +130,17 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             return;
         }
 
+        if (decideZlibOrNone) {
+            // First two bytes are needed to decide if it's a ZLIB stream.
+            if (in.readableBytes() < 2) {
+                return;
+            }
+
+            boolean nowrap = !looksLikeZlib(in.getShort(0));
+            inflater = new Inflater(nowrap);
+            decideZlibOrNone = false;
+        }
+
         if (crc != null) {
             switch (gzipState) {
                 case FOOTER_START:
@@ -155,8 +172,9 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             boolean readFooter = false;
             byte[] outArray = decompressed.array();
             while (!inflater.needsInput()) {
-                int outIndex = decompressed.arrayOffset() + decompressed.writerIndex();
-                int length = outArray.length - outIndex;
+                int writerIndex = decompressed.writerIndex();
+                int outIndex = decompressed.arrayOffset() + writerIndex;
+                int length = decompressed.writableBytes();
 
                 if (length == 0) {
                     // completely filled the buffer allocate a new one and start to fill it
@@ -168,7 +186,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
 
                 int outputLength = inflater.inflate(outArray, outIndex, length);
                 if (outputLength > 0) {
-                    decompressed.writerIndex(decompressed.writerIndex() + outputLength);
+                    decompressed.writerIndex(writerIndex + outputLength);
                     if (crc != null) {
                         crc.update(outArray, outIndex, outputLength);
                     }
@@ -215,7 +233,9 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
     @Override
     protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {
         super.handlerRemoved0(ctx);
-        inflater.end();
+        if (inflater != null) {
+            inflater.end();
+        }
     }
 
     private boolean readGZIPHeader(ByteBuf in) {
@@ -357,4 +377,16 @@ private void verifyCrc(ByteBuf in) {
                     "CRC value missmatch. Expected: " + crcValue + ", Got: " + readCrc);
         }
     }
+
+    /*
+     * Returns true if the cmf_flg parameter (think: first two bytes of a zlib stream)
+     * indicates that this is a zlib stream.
+     * <p>
+     * You can lookup the details in the ZLIB RFC:
+     * <a href="http://tools.ietf.org/html/rfc1950#section-2.2">RFC 1950</a>.
+     */
+    private static boolean looksLikeZlib(short cmf_flg) {
+        return (cmf_flg & 0x7800) == 0x7800 &&
+                cmf_flg % 31 == 0;
+    }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
index 39cc3b92c4d4..b4faa35547c6 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
@@ -34,7 +34,6 @@
 public class JdkZlibEncoder extends ZlibEncoder {
 
     private final ZlibWrapper wrapper;
-    private final byte[] encodeBuf = new byte[8192];
     private final Deflater deflater;
     private volatile boolean finished;
     private volatile ChannelHandlerContext ctx;
@@ -211,23 +210,11 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf o
             offset = 0;
         }
 
-        int sizeEstimate = (int) Math.ceil(inAry.length * 1.001) + 12;
-
         if (writeHeader) {
             writeHeader = false;
-            switch (wrapper) {
-                case GZIP:
-                    out.ensureWritable(sizeEstimate + gzipHeader.length);
-                    out.writeBytes(gzipHeader);
-                    break;
-                case ZLIB:
-                    out.ensureWritable(sizeEstimate + 2); // first two magic bytes
-                    break;
-                default:
-                    out.ensureWritable(sizeEstimate);
+            if (wrapper == ZlibWrapper.GZIP) {
+                out.writeBytes(gzipHeader);
             }
-        } else {
-            out.ensureWritable(sizeEstimate);
         }
 
         if (wrapper == ZlibWrapper.GZIP) {
@@ -240,6 +227,23 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf o
         }
     }
 
+    @Override
+    protected final ByteBuf allocateBuffer(ChannelHandlerContext ctx, ByteBuf msg,
+                                           boolean preferDirect) throws Exception {
+        int sizeEstimate = (int) Math.ceil(msg.readableBytes() * 1.001) + 12;
+        if (writeHeader) {
+            switch (wrapper) {
+                case GZIP:
+                    sizeEstimate += gzipHeader.length;
+                    break;
+                case ZLIB:
+                    sizeEstimate += 2; // first two magic bytes
+                    break;
+            }
+        }
+        return ctx.alloc().heapBuffer(sizeEstimate);
+    }
+
     @Override
     public void close(final ChannelHandlerContext ctx, final ChannelPromise promise) throws Exception {
         ChannelFuture f = finishEncode(ctx, ctx.newPromise());
@@ -268,8 +272,7 @@ private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromi
         }
 
         finished = true;
-
-        ByteBuf footer = ctx.alloc().buffer();
+        ByteBuf footer = ctx.alloc().heapBuffer();
         if (writeHeader && wrapper == ZlibWrapper.GZIP) {
             // Write the GZIP header first if not written yet. (i.e. user wrote nothing.)
             writeHeader = false;
@@ -277,8 +280,14 @@ private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromi
         }
 
         deflater.finish();
+
         while (!deflater.finished()) {
             deflate(footer);
+            if (!footer.isWritable()) {
+                // no more space so write it to the channel and continue
+                ctx.write(footer);
+                footer = ctx.alloc().heapBuffer();
+            }
         }
         if (wrapper == ZlibWrapper.GZIP) {
             int crcValue = (int) crc.getValue();
@@ -299,8 +308,10 @@ private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromi
     private void deflate(ByteBuf out) {
         int numBytes;
         do {
-            numBytes = deflater.deflate(encodeBuf, 0, encodeBuf.length, Deflater.SYNC_FLUSH);
-            out.writeBytes(encodeBuf, 0, numBytes);
+            int writerIndex = out.writerIndex();
+            numBytes = deflater.deflate(
+                    out.array(), out.arrayOffset() + writerIndex, out.writableBytes(), Deflater.SYNC_FLUSH);
+            out.writerIndex(writerIndex + numBytes);
         } while (numBytes > 0);
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
index c521c7bd3e5c..1d61d0c119d3 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
@@ -57,7 +57,7 @@ public void reset() {
         written = 0;
     }
 
-    public void encode(ByteBuf in, ByteBuf out, int length) {
+    public void encode(final ByteBuf in, final ByteBuf out, final int length) {
         // Write the preamble length to the output buffer
         for (int i = 0;; i ++) {
             int b = length >>> i * 7;
@@ -70,15 +70,14 @@ public void encode(ByteBuf in, ByteBuf out, int length) {
         }
 
         int inIndex = in.readerIndex();
-        final int baseIndex = in.readerIndex();
-        final int maxIndex = length;
+        final int baseIndex = inIndex;
 
-        final short[] table = getHashTable(maxIndex);
+        final short[] table = getHashTable(length);
         final int shift = 32 - (int) Math.floor(Math.log(table.length) / Math.log(2));
 
         int nextEmit = inIndex;
 
-        if (maxIndex - inIndex >= MIN_COMPRESSIBLE_BYTES) {
+        if (length - inIndex >= MIN_COMPRESSIBLE_BYTES) {
             int nextHash = hash(in, ++inIndex, shift);
             outer: while (true) {
                 int skip = 32;
@@ -92,7 +91,7 @@ public void encode(ByteBuf in, ByteBuf out, int length) {
                     nextIndex = inIndex + bytesBetweenHashLookups;
 
                     // We need at least 4 remaining bytes to read the hash
-                    if (nextIndex > maxIndex - 4) {
+                    if (nextIndex > length - 4) {
                         break outer;
                     }
 
@@ -109,14 +108,14 @@ public void encode(ByteBuf in, ByteBuf out, int length) {
                 int insertTail;
                 do {
                     int base = inIndex;
-                    int matched = 4 + findMatchingLength(in, candidate + 4, inIndex + 4, maxIndex);
+                    int matched = 4 + findMatchingLength(in, candidate + 4, inIndex + 4, length);
                     inIndex += matched;
                     int offset = base - candidate;
                     encodeCopy(out, offset, matched);
                     in.readerIndex(in.readerIndex() + matched);
                     insertTail = inIndex - 1;
                     nextEmit = inIndex;
-                    if (inIndex >= maxIndex - 4) {
+                    if (inIndex >= length - 4) {
                         break outer;
                     }
 
@@ -134,8 +133,8 @@ public void encode(ByteBuf in, ByteBuf out, int length) {
         }
 
         // If there are any remaining characters, write them out as a literal
-        if (nextEmit < maxIndex) {
-            encodeLiteral(in, out, maxIndex - nextEmit);
+        if (nextEmit < length) {
+            encodeLiteral(in, out, length - nextEmit);
         }
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
index a2db4488c629..f3dee9a8a022 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
@@ -198,7 +198,7 @@ static ChunkType mapChunkType(byte type) {
             return ChunkType.COMPRESSED_DATA;
         } else if (type == 1) {
             return ChunkType.UNCOMPRESSED_DATA;
-        } else if (type == -0x80) {
+        } else if (type == (byte) 0xff) {
             return ChunkType.STREAM_IDENTIFIER;
         } else if ((type & 0x80) == 0x80) {
             return ChunkType.RESERVED_SKIPPABLE;
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
index b22a026c2c38..1cc5301ab764 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
@@ -40,7 +40,7 @@ public class SnappyFramedEncoder extends MessageToByteEncoder<ByteBuf> {
      * type 0xff, a length field of 0x6, and 'sNaPpY' in ASCII.
      */
     private static final byte[] STREAM_START = {
-        -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59
+        (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59
     };
 
     private final Snappy snappy = new Snappy();
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java b/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java
index d3bf88597ef0..db97c24fd851 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java
@@ -98,15 +98,10 @@ public static ZlibDecoder newZlibDecoder() {
     }
 
     public static ZlibDecoder newZlibDecoder(ZlibWrapper wrapper) {
-        switch (wrapper) {
-            case ZLIB_OR_NONE:
-                return new JZlibDecoder(wrapper);
-            default:
-                if (PlatformDependent.javaVersion() < 7 || noJdkZlibDecoder) {
-                    return new JZlibDecoder(wrapper);
-                } else {
-                    return new JdkZlibDecoder(wrapper);
-                }
+        if (PlatformDependent.javaVersion() < 7 || noJdkZlibDecoder) {
+            return new JZlibDecoder(wrapper);
+        } else {
+            return new JdkZlibDecoder(wrapper);
         }
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java
new file mode 100644
index 000000000000..616e70b3ab0f
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.json;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.channel.ChannelHandler;
+import io.netty.handler.codec.CorruptedFrameException;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.channel.ChannelPipeline;
+
+import java.util.List;
+
+/**
+ * Splits a byte stream of JSON objects and arrays into individual objects/arrays and passes them up the
+ * {@link ChannelPipeline}.
+ *
+ * This class does not do any real parsing or validation. A sequence of bytes is considered a JSON object/array
+ * if it contains a matching number of opening and closing braces/brackets. It's up to a subsequent
+ * {@link ChannelHandler} to parse the JSON text into a more usable form i.e. a POJO.
+ */
+public class JsonObjectDecoder extends ByteToMessageDecoder {
+
+    private static final int ST_CORRUPTED = -1;
+    private static final int ST_INIT = 0;
+    private static final int ST_DECODING_NORMAL = 1;
+    private static final int ST_DECODING_ARRAY_STREAM = 2;
+
+    private int openBraces;
+    private int idx;
+
+    private int state;
+    private boolean insideString;
+
+    private final int maxObjectLength;
+    private final boolean streamArrayElements;
+
+    public JsonObjectDecoder() {
+        // 1 MB
+        this(1024 * 1024);
+    }
+
+    public JsonObjectDecoder(int maxObjectLength) {
+        this(maxObjectLength, false);
+    }
+
+    public JsonObjectDecoder(boolean streamArrayElements) {
+        this(1024 * 1024, streamArrayElements);
+    }
+
+    /**
+     * @param maxObjectLength   maximum number of bytes a JSON object/array may use (including braces and all).
+     *                             Objects exceeding this length are dropped and an {@link TooLongFrameException}
+     *                             is thrown.
+     * @param streamArrayElements   if set to true and the "top level" JSON object is an array, each of its entries
+     *                                  is passed through the pipeline individually and immediately after it was fully
+     *                                  received, allowing for arrays with "infinitely" many elements.
+     *
+     */
+    public JsonObjectDecoder(int maxObjectLength, boolean streamArrayElements) {
+        if (maxObjectLength < 1) {
+            throw new IllegalArgumentException("maxObjectLength must be a positive int");
+        }
+        this.maxObjectLength = maxObjectLength;
+        this.streamArrayElements = streamArrayElements;
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        if (state == ST_CORRUPTED) {
+            in.skipBytes(in.readableBytes());
+            return;
+        }
+
+        // index of next byte to process.
+        int idx = this.idx;
+        int wrtIdx = in.writerIndex();
+
+        if (wrtIdx > maxObjectLength) {
+            // buffer size exceeded maxObjectLength; discarding the complete buffer.
+            ctx.fireExceptionCaught(
+                    new TooLongFrameException(
+                            "object length exceeds " + maxObjectLength + ": " + wrtIdx + " bytes discarded")
+            );
+
+            in.skipBytes(in.readableBytes());
+            reset();
+            return;
+        }
+
+        for (/* use current idx */; idx < wrtIdx; idx++) {
+            byte c = in.getByte(idx);
+            if (state == ST_DECODING_NORMAL) {
+                decodeByte(c, in, idx);
+
+                // All opening braces/brackets have been closed. That's enough to conclude
+                // that the JSON object/array is complete.
+                if (openBraces == 0) {
+                    ByteBuf json = extractObject(ctx, in, in.readerIndex(), idx + 1 - in.readerIndex());
+                    if (json != null) {
+                        out.add(json);
+                    }
+
+                    // The JSON object/array was extracted => discard the bytes from
+                    // the input buffer.
+                    in.readerIndex(idx + 1);
+                    // Reset the object state to get ready for the next JSON object/text
+                    // coming along the byte stream.
+                    reset();
+                }
+            } else if (state == ST_DECODING_ARRAY_STREAM) {
+                decodeByte(c, in, idx);
+
+                if (!insideString && (openBraces == 1 && c == ',' || openBraces == 0 && c == ']')) {
+                    // skip leading spaces. No range check is needed and the loop will terminate
+                    // because the byte at position idx is not a whitespace.
+                    for (int i = in.readerIndex(); Character.isWhitespace(in.getByte(i)); i++) {
+                        in.skipBytes(1);
+                    }
+
+                    // skip trailing spaces.
+                    int idxNoSpaces = idx - 1;
+                    while (idxNoSpaces >= in.readerIndex() && Character.isWhitespace(in.getByte(idxNoSpaces))) {
+                        idxNoSpaces--;
+                    }
+
+                    ByteBuf json = extractObject(ctx, in, in.readerIndex(), idxNoSpaces + 1 - in.readerIndex());
+                    if (json != null) {
+                        out.add(json);
+                    }
+
+                    in.readerIndex(idx + 1);
+
+                    if (c == ']') {
+                        reset();
+                    }
+                }
+            // JSON object/array detected. Accumulate bytes until all braces/brackets are closed.
+            } else if (c == '{' || c == '[') {
+                initDecoding(c);
+
+                if (state == ST_DECODING_ARRAY_STREAM) {
+                    // Discard the array bracket
+                    in.skipBytes(1);
+                }
+            // Discard leading spaces in front of a JSON object/array.
+            } else if (Character.isWhitespace(c)) {
+                in.skipBytes(1);
+            } else {
+                state = ST_CORRUPTED;
+                throw new CorruptedFrameException(
+                        "invalid JSON received at byte position " + idx + ": " + ByteBufUtil.hexDump(in));
+            }
+        }
+
+        if (in.readableBytes() == 0) {
+            this.idx = 0;
+        } else {
+            this.idx = idx;
+        }
+    }
+
+    /**
+     * Override this method if you want to filter the json objects/arrays that get passed through the pipeline.
+     */
+    @SuppressWarnings("UnusedParameters")
+    protected ByteBuf extractObject(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {
+        return buffer.slice(index, length).retain();
+    }
+
+    private void decodeByte(byte c, ByteBuf in, int idx) {
+        if ((c == '{' || c == '[') && !insideString) {
+            openBraces++;
+        } else if ((c == '}' || c == ']') && !insideString) {
+            openBraces--;
+        } else if (c == '"') {
+            // start of a new JSON string. It's necessary to detect strings as they may
+            // also contain braces/brackets and that could lead to incorrect results.
+            if (!insideString) {
+                insideString = true;
+            // If the double quote wasn't escaped then this is the end of a string.
+            } else if (in.getByte(idx - 1) != '\\') {
+                insideString = false;
+            }
+        }
+    }
+
+    private void initDecoding(byte openingBrace) {
+        openBraces = 1;
+        if (openingBrace == '[' && streamArrayElements) {
+            state = ST_DECODING_ARRAY_STREAM;
+        } else {
+            state = ST_DECODING_NORMAL;
+        }
+    }
+
+    private void reset() {
+        insideString = false;
+        state = ST_INIT;
+        openBraces = 0;
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/json/package-info.java b/codec/src/main/java/io/netty/handler/codec/json/package-info.java
new file mode 100644
index 000000000000..999318ea7f46
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/json/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> specific codecs.
+ */
+package io.netty.handler.codec.json;
diff --git a/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteInput.java b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteInput.java
index 104c056addd6..c40134df7cde 100644
--- a/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteInput.java
+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteInput.java
@@ -27,7 +27,7 @@ class ChannelBufferByteInput implements ByteInput {
 
     private final ByteBuf buffer;
 
-    public ChannelBufferByteInput(ByteBuf buffer) {
+    ChannelBufferByteInput(ByteBuf buffer) {
         this.buffer = buffer;
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java
index 7610955da51d..416102f2825d 100644
--- a/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java
+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java
@@ -32,7 +32,7 @@ class ChannelBufferByteOutput implements ByteOutput {
     /**
      * Create a new instance which use the given {@link ByteBuf}
      */
-    public ChannelBufferByteOutput(ByteBuf buffer) {
+    ChannelBufferByteOutput(ByteBuf buffer) {
         this.buffer = buffer;
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java b/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
index 998881e615d4..5e15cd1b4bf7 100644
--- a/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
@@ -20,13 +20,12 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
+import org.jboss.marshalling.ByteInput;
+import org.jboss.marshalling.Unmarshaller;
 
 import java.io.ObjectStreamConstants;
 import java.util.List;
 
-import org.jboss.marshalling.ByteInput;
-import org.jboss.marshalling.Unmarshaller;
-
 /**
  * {@link ReplayingDecoder} which use an {@link Unmarshaller} to read the Object out of the {@link ByteBuf}.
  *
@@ -73,7 +72,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
             Object obj = unmarshaller.readObject();
             unmarshaller.finish();
             out.add(obj);
-        } catch (LimitingByteInput.TooBigObjectException e) {
+        } catch (LimitingByteInput.TooBigObjectException ignored) {
             discardingTooLongFrame = true;
             throw new TooLongFrameException();
         } finally {
diff --git a/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java
index 333c9bded9c7..1be65630ccb3 100644
--- a/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java
+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java
@@ -35,7 +35,7 @@
 public class ContextBoundUnmarshallerProvider extends DefaultUnmarshallerProvider {
 
     private static final AttributeKey<Unmarshaller> UNMARSHALLER = AttributeKey.valueOf(
-            ContextBoundUnmarshallerProvider.class.getName() + ".UNMARSHALLER");
+            ContextBoundUnmarshallerProvider.class, "UNMARSHALLER");
 
     public ContextBoundUnmarshallerProvider(MarshallerFactory factory, MarshallingConfiguration config) {
         super(factory, config);
diff --git a/codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java b/codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java
index 47ae2bcf7910..66b4ad6d876e 100644
--- a/codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java
+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java
@@ -32,7 +32,7 @@ class LimitingByteInput implements ByteInput {
     private final long limit;
     private long read;
 
-    public LimitingByteInput(ByteInput input, long limit) {
+    LimitingByteInput(ByteInput input, long limit) {
         if (limit <= 0) {
             throw new IllegalArgumentException("The limit MUST be > 0");
         }
diff --git a/codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalMarshallerProvider.java b/codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalMarshallerProvider.java
index a3ca6f67b711..ce136014912b 100644
--- a/codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalMarshallerProvider.java
+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalMarshallerProvider.java
@@ -17,6 +17,7 @@
 
 import io.netty.channel.ChannelHandlerContext;
 
+import io.netty.util.concurrent.FastThreadLocal;
 import org.jboss.marshalling.Marshaller;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.MarshallingConfiguration;
@@ -27,7 +28,7 @@
  * many small {@link Object}'s and your actual Thread count is not to big
  */
 public class ThreadLocalMarshallerProvider implements MarshallerProvider {
-    private final ThreadLocal<Marshaller> marshallers = new ThreadLocal<Marshaller>();
+    private final FastThreadLocal<Marshaller> marshallers = new FastThreadLocal<Marshaller>();
 
     private final MarshallerFactory factory;
     private final MarshallingConfiguration config;
diff --git a/codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalUnmarshallerProvider.java b/codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalUnmarshallerProvider.java
index 77b278d62466..080d48921a9c 100644
--- a/codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalUnmarshallerProvider.java
+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ThreadLocalUnmarshallerProvider.java
@@ -17,6 +17,7 @@
 
 import io.netty.channel.ChannelHandlerContext;
 
+import io.netty.util.concurrent.FastThreadLocal;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.MarshallingConfiguration;
 import org.jboss.marshalling.Unmarshaller;
@@ -27,7 +28,7 @@
  * many small {@link Object}'s.
  */
 public class ThreadLocalUnmarshallerProvider implements UnmarshallerProvider {
-    private final ThreadLocal<Unmarshaller> unmarshallers = new ThreadLocal<Unmarshaller>();
+    private final FastThreadLocal<Unmarshaller> unmarshallers = new FastThreadLocal<Unmarshaller>();
 
     private final MarshallerFactory factory;
     private final MarshallingConfiguration config;
diff --git a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java
index b9231781d80e..9efd00ff2698 100644
--- a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java
+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java
@@ -47,7 +47,7 @@ protected void encode(
         out.ensureWritable(headerLen + bodyLen);
 
         CodedOutputStream headerOut =
-                CodedOutputStream.newInstance(new ByteBufOutputStream(out));
+                CodedOutputStream.newInstance(new ByteBufOutputStream(out), headerLen);
         headerOut.writeRawVarint32(bodyLen);
         headerOut.flush();
 
diff --git a/codec/src/main/java/io/netty/handler/codec/serialization/ClassLoaderClassResolver.java b/codec/src/main/java/io/netty/handler/codec/serialization/ClassLoaderClassResolver.java
index 89f9c283cd28..b6fbeb783c93 100644
--- a/codec/src/main/java/io/netty/handler/codec/serialization/ClassLoaderClassResolver.java
+++ b/codec/src/main/java/io/netty/handler/codec/serialization/ClassLoaderClassResolver.java
@@ -27,7 +27,7 @@ class ClassLoaderClassResolver implements ClassResolver {
     public Class<?> resolve(String className) throws ClassNotFoundException {
         try {
             return classLoader.loadClass(className);
-        } catch (ClassNotFoundException e) {
+        } catch (ClassNotFoundException ignored) {
             return Class.forName(className, false, classLoader);
         }
     }
diff --git a/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java b/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java
index 9c7bee5f1aab..0d8c11f2f9f3 100644
--- a/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java
+++ b/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java
@@ -90,12 +90,12 @@ static ClassLoader defaultClassLoader(ClassLoader classLoader) {
             return classLoader;
         }
 
-        final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
+        final ClassLoader contextClassLoader = PlatformDependent.getContextClassLoader();
         if (contextClassLoader != null) {
             return contextClassLoader;
         }
 
-        return ClassResolvers.class.getClassLoader();
+        return PlatformDependent.getClassLoader(ClassResolvers.class);
     }
 
     private ClassResolvers() {
diff --git a/codec/src/main/java/io/netty/handler/codec/serialization/CompactObjectInputStream.java b/codec/src/main/java/io/netty/handler/codec/serialization/CompactObjectInputStream.java
index f6e98b12cca0..b80635783a2a 100644
--- a/codec/src/main/java/io/netty/handler/codec/serialization/CompactObjectInputStream.java
+++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompactObjectInputStream.java
@@ -65,7 +65,7 @@ protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, Clas
         Class<?> clazz;
         try {
             clazz = classResolver.resolve(desc.getName());
-        } catch (ClassNotFoundException ex) {
+        } catch (ClassNotFoundException ignored) {
             clazz = super.resolveClass(desc);
         }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java b/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
index 505f154b92be..81543b870c8c 100644
--- a/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java
@@ -37,7 +37,7 @@
 public class CompatibleObjectEncoder extends MessageToByteEncoder<Serializable> {
 
     private static final AttributeKey<ObjectOutputStream> OOS =
-            AttributeKey.valueOf(CompatibleObjectEncoder.class.getName() + ".OOS");
+            AttributeKey.valueOf(CompatibleObjectEncoder.class, "OOS");
 
     private final int resetInterval;
     private int writtenObjects;
diff --git a/codec/src/main/java/io/netty/handler/codec/serialization/SoftReferenceMap.java b/codec/src/main/java/io/netty/handler/codec/serialization/SoftReferenceMap.java
index aa5154acc2db..dcc8fe5af720 100644
--- a/codec/src/main/java/io/netty/handler/codec/serialization/SoftReferenceMap.java
+++ b/codec/src/main/java/io/netty/handler/codec/serialization/SoftReferenceMap.java
@@ -21,7 +21,7 @@
 
 final class SoftReferenceMap<K, V> extends ReferenceMap<K, V> {
 
-    public SoftReferenceMap(Map<K, Reference<V>> delegate) {
+    SoftReferenceMap(Map<K, Reference<V>> delegate) {
         super(delegate);
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/serialization/WeakReferenceMap.java b/codec/src/main/java/io/netty/handler/codec/serialization/WeakReferenceMap.java
index 94ecc17ed8fa..00e720fbcc5c 100644
--- a/codec/src/main/java/io/netty/handler/codec/serialization/WeakReferenceMap.java
+++ b/codec/src/main/java/io/netty/handler/codec/serialization/WeakReferenceMap.java
@@ -21,7 +21,7 @@
 
 final class WeakReferenceMap<K, V> extends ReferenceMap<K, V> {
 
-    public WeakReferenceMap(Map<K, Reference<V>> delegate) {
+    WeakReferenceMap(Map<K, Reference<V>> delegate) {
         super(delegate);
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java
new file mode 100644
index 000000000000..ae499e30a047
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.xml;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.handler.codec.CorruptedFrameException;
+import io.netty.handler.codec.TooLongFrameException;
+
+import java.util.List;
+
+/**
+ * A frame decoder for single separate XML based message streams.
+ * <p/>
+ * A couple examples will better help illustrate
+ * what this decoder actually does.
+ * <p/>
+ * Given an input array of bytes split over 3 frames like this:
+ * <pre>
+ * +-----+-----+-----------+
+ * | &lt;an | Xml | Element/&gt; |
+ * +-----+-----+-----------+
+ * </pre>
+ * <p/>
+ * this decoder would output a single frame:
+ * <p/>
+ * <pre>
+ * +-----------------+
+ * | &lt;anXmlElement/&gt; |
+ * +-----------------+
+ * </pre>
+ *
+ * Given an input array of bytes split over 5 frames like this:
+ * <pre>
+ * +-----+-----+-----------+-----+----------------------------------+
+ * | &lt;an | Xml | Element/&gt; | &lt;ro | ot&gt;&lt;child&gt;content&lt;/child&gt;&lt;/root&gt; |
+ * +-----+-----+-----------+-----+----------------------------------+
+ * </pre>
+ * <p/>
+ * this decoder would output two frames:
+ * <p/>
+ * <pre>
+ * +-----------------+-------------------------------------+
+ * | &lt;anXmlElement/&gt; | &lt;root&gt;&lt;child&gt;content&lt;/child&gt;&lt;/root&gt; |
+ * +-----------------+-------------------------------------+
+ * </pre>
+ *
+ * Please note that this decoder is not suitable for
+ * xml streaming protocols such as
+ * <a href="http://xmpp.org/rfcs/rfc6120.html">XMPP</a>,
+ * where an initial xml element opens the stream and only
+ * gets closed at the end of the session, although this class
+ * could probably allow for such type of message flow with
+ * minor modifications.
+ */
+public class XmlFrameDecoder extends ByteToMessageDecoder {
+
+    private final int maxFrameLength;
+
+    public XmlFrameDecoder(int maxFrameLength) {
+        if (maxFrameLength < 1) {
+            throw new IllegalArgumentException("maxFrameLength must be a positive int");
+        }
+        this.maxFrameLength = maxFrameLength;
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        boolean openingBracketFound = false;
+        boolean atLeastOneXmlElementFound = false;
+        boolean inCDATASection = false;
+        long openBracketsCount = 0;
+        int length = 0;
+        int leadingWhiteSpaceCount = 0;
+        final int bufferLength = in.writerIndex();
+
+        if (bufferLength > maxFrameLength) {
+            // bufferLength exceeded maxFrameLength; dropping frame
+            fail(ctx, bufferLength);
+            in.skipBytes(in.readableBytes());
+            return;
+        }
+
+        for (int i = in.readerIndex(); i < bufferLength; i++) {
+            final byte readByte = in.getByte(i);
+            if (!openingBracketFound && Character.isWhitespace(readByte)) {
+                // xml has not started and whitespace char found
+                leadingWhiteSpaceCount++;
+            } else if (!openingBracketFound && readByte != '<') {
+                // garbage found before xml start
+                fail(ctx);
+                in.skipBytes(in.readableBytes());
+                return;
+            } else if (!inCDATASection && readByte == '<') {
+                openingBracketFound = true;
+
+                if (i < bufferLength - 1) {
+                    final byte peekAheadByte = in.getByte(i + 1);
+                    if (peekAheadByte == '/') {
+                        // found </, decrementing openBracketsCount
+                        openBracketsCount--;
+                    } else if (isValidStartCharForXmlElement(peekAheadByte)) {
+                        atLeastOneXmlElementFound = true;
+                        // char after < is a valid xml element start char,
+                        // incrementing openBracketsCount
+                        openBracketsCount++;
+                    } else if (peekAheadByte == '!') {
+                        if (isCommentBlockStart(in, i)) {
+                            // <!-- comment --> start found
+                            openBracketsCount++;
+                        } else if (isCDATABlockStart(in, i)) {
+                            // <![CDATA[ start found
+                            openBracketsCount++;
+                            inCDATASection = true;
+                        }
+                    } else if (peekAheadByte == '?') {
+                        // <?xml ?> start found
+                        openBracketsCount++;
+                    }
+                }
+            } else if (!inCDATASection && readByte == '/') {
+                if (i < bufferLength - 1 && in.getByte(i + 1) == '>') {
+                    // found />, decrementing openBracketsCount
+                    openBracketsCount--;
+                }
+            } else if (readByte == '>') {
+                length = i + 1;
+
+                if (i - 1 > -1) {
+                    final byte peekBehindByte = in.getByte(i - 1);
+
+                    if (!inCDATASection) {
+                        if (peekBehindByte == '?') {
+                            // an <?xml ?> tag was closed
+                            openBracketsCount--;
+                        } else if (peekBehindByte == '-' && i - 2 > -1 && in.getByte(i - 2) == '-') {
+                            // a <!-- comment --> was closed
+                            openBracketsCount--;
+                        }
+                    } else if (peekBehindByte == ']' && i - 2 > -1 && in.getByte(i - 2) == ']') {
+                        // a <![CDATA[...]]> block was closed
+                        openBracketsCount--;
+                        inCDATASection = false;
+                    }
+                }
+
+                if (atLeastOneXmlElementFound && openBracketsCount == 0) {
+                    // xml is balanced, bailing out
+                    break;
+                }
+            }
+        }
+
+        final int readerIndex = in.readerIndex();
+
+        if (openBracketsCount == 0 && length > 0) {
+            if (length >= bufferLength) {
+                length = in.readableBytes();
+            }
+            final ByteBuf frame =
+                    extractFrame(in, readerIndex + leadingWhiteSpaceCount, length - leadingWhiteSpaceCount);
+            in.skipBytes(length);
+            out.add(frame);
+        }
+    }
+
+    private void fail(ChannelHandlerContext ctx, long frameLength) {
+        if (frameLength > 0) {
+            ctx.fireExceptionCaught(
+                    new TooLongFrameException(
+                            "frame length exceeds " + maxFrameLength + ": " + frameLength + " - discarded"));
+        } else {
+            ctx.fireExceptionCaught(
+                    new TooLongFrameException(
+                            "frame length exceeds " + maxFrameLength + " - discarding"));
+        }
+    }
+
+    private static void fail(ChannelHandlerContext ctx) {
+        ctx.fireExceptionCaught(new CorruptedFrameException("frame contains content before the xml starts"));
+    }
+
+    private static ByteBuf extractFrame(ByteBuf buffer, int index, int length) {
+        return buffer.copy(index, length);
+    }
+
+    /**
+     * Asks whether the given byte is a valid
+     * start char for an xml element name.
+     * <p/>
+     * Please refer to the
+     * <a href="http://www.w3.org/TR/2004/REC-xml11-20040204/#NT-NameStartChar">NameStartChar</a>
+     * formal definition in the W3C XML spec for further info.
+     *
+     * @param b the input char
+     * @return true if the char is a valid start char
+     */
+    private static boolean isValidStartCharForXmlElement(final byte b) {
+        return b >= 'a' && b <= 'z' || b >= 'A' && b <= 'Z' || b == ':' || b == '_';
+    }
+
+    private static boolean isCommentBlockStart(final ByteBuf in, final int i) {
+        return i < in.writerIndex() - 3
+                && in.getByte(i + 2) == '-'
+                && in.getByte(i + 3) == '-';
+    }
+
+    private static boolean isCDATABlockStart(final ByteBuf in, final int i) {
+        return i < in.writerIndex() - 8
+                && in.getByte(i + 2) == '['
+                && in.getByte(i + 3) == 'C'
+                && in.getByte(i + 4) == 'D'
+                && in.getByte(i + 5) == 'A'
+                && in.getByte(i + 6) == 'T'
+                && in.getByte(i + 7) == 'A'
+                && in.getByte(i + 8) == '[';
+    }
+
+}
diff --git a/example/src/main/java/io/netty/example/udt/util/package-info.java b/codec/src/main/java/io/netty/handler/codec/xml/package-info.java
similarity index 90%
rename from example/src/main/java/io/netty/example/udt/util/package-info.java
rename to codec/src/main/java/io/netty/handler/codec/xml/package-info.java
index d07010325b72..22dc8ca6629c 100644
--- a/example/src/main/java/io/netty/example/udt/util/package-info.java
+++ b/codec/src/main/java/io/netty/handler/codec/xml/package-info.java
@@ -15,7 +15,6 @@
  */
 
 /**
- * Utilities for UDT examples.
+ * Xml specific codecs.
  */
-package io.netty.example.udt.util;
-
+package io.netty.handler.codec.xml;
diff --git a/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java
index 3cd8584a62b3..bd3b343165e1 100644
--- a/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java
@@ -43,7 +43,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
 
         ByteBuf buf = Unpooled.wrappedBuffer(new byte[] {'a', 'b', 'c'});
         channel.writeInbound(buf.copy());
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         Assert.assertEquals(b, buf.skipBytes(1));
         b.release();
         buf.release();
@@ -68,7 +68,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         });
 
         channel.writeInbound(buf.copy());
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         Assert.assertEquals(b, Unpooled.wrappedBuffer(new byte[] { 'b', 'c'}));
         buf.release();
         b.release();
diff --git a/codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java
index fe0ab4711775..aa7e86f1ea81 100644
--- a/codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java
@@ -21,7 +21,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 
-import static io.netty.util.ReferenceCountUtil.releaseLater;
+import static io.netty.util.ReferenceCountUtil.*;
 
 public class LengthFieldBasedFrameDecoderTest {
 
@@ -43,7 +43,7 @@ public void testDiscardTooLongFrame1() {
         }
         Assert.assertTrue(channel.finish());
 
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         Assert.assertEquals(5, b.readableBytes());
         Assert.assertEquals(1, b.readInt());
         Assert.assertEquals('a', b.readByte());
@@ -73,7 +73,7 @@ public void testDiscardTooLongFrame2() {
 
         Assert.assertTrue(channel.finish());
 
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         Assert.assertEquals(5, b.readableBytes());
         Assert.assertEquals(1, b.readInt());
         Assert.assertEquals('a', b.readByte());
diff --git a/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
index 3989d0bbe3df..3d2b66644a16 100644
--- a/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
@@ -24,7 +24,7 @@
 
 import java.util.List;
 
-import static io.netty.util.ReferenceCountUtil.releaseLater;
+import static io.netty.util.ReferenceCountUtil.*;
 import static org.junit.Assert.*;
 
 public class ReplayingDecoderTest {
@@ -122,7 +122,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
 
         ByteBuf buf = Unpooled.wrappedBuffer(new byte[] {'a', 'b', 'c'});
         channel.writeInbound(buf.copy());
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         assertEquals(b, buf.skipBytes(1));
         b.release();
         buf.release();
@@ -146,7 +146,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
 
         ByteBuf buf = Unpooled.wrappedBuffer(new byte[] {'a', 'b', 'c'});
         channel.writeInbound(buf.copy());
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
 
         assertEquals("Expect to have still all bytes in the buffer", b, buf);
         b.release();
@@ -172,7 +172,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         });
 
         channel.writeInbound(buf.copy());
-        ByteBuf b = (ByteBuf) channel.readInbound();
+        ByteBuf b = channel.readInbound();
         assertEquals(b, Unpooled.wrappedBuffer(new byte[] { 'b', 'c'}));
         b.release();
         buf.release();
diff --git a/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
index acec3cbf4150..3985728e05d5 100644
--- a/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
@@ -26,9 +26,6 @@
 import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
 
-/**
- */
-@SuppressWarnings("ZeroLengthArrayAllocation")
 public class ByteArrayDecoderTest {
 
     private EmbeddedChannel ch;
diff --git a/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
index 9e46212819c3..bf76071e69bc 100644
--- a/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
@@ -16,20 +16,18 @@
 package io.netty.handler.codec.bytes;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.EmptyArrays;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import java.util.Random;
 
 import static io.netty.buffer.Unpooled.*;
-import static org.hamcrest.core.Is.*;
-import static org.hamcrest.core.IsNull.*;
+import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
 
-@SuppressWarnings("ZeroLengthArrayAllocation")
 public class ByteArrayEncoderTest {
 
     private EmbeddedChannel ch;
@@ -39,18 +37,25 @@ public void setUp() {
         ch = new EmbeddedChannel(new ByteArrayEncoder());
     }
 
+    @After
+    public void tearDown() {
+        assertThat(ch.finish(), is(false));
+    }
+
     @Test
     public void testEncode() {
         byte[] b = new byte[2048];
         new Random().nextBytes(b);
         ch.writeOutbound(b);
-        assertThat((ByteBuf) ch.readOutbound(), is(wrappedBuffer(b)));
+        ByteBuf encoded = ch.readOutbound();
+        assertThat(encoded, is(wrappedBuffer(b)));
+        encoded.release();
     }
 
     @Test
     public void testEncodeEmpty() {
         ch.writeOutbound(EmptyArrays.EMPTY_BYTES);
-        assertThat((ByteBuf) ch.readOutbound(), is(Unpooled.EMPTY_BUFFER));
+        assertThat((ByteBuf) ch.readOutbound(), is(sameInstance(EMPTY_BUFFER)));
     }
 
     @Test
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java
new file mode 100644
index 000000000000..58812f077abe
--- /dev/null
+++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java
@@ -0,0 +1,251 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.compression;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.internal.ThreadLocalRandom;
+import org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import java.io.ByteArrayOutputStream;
+
+import static io.netty.handler.codec.compression.Bzip2Constants.*;
+import static org.junit.Assert.*;
+
+public class Bzip2DecoderTest {
+
+    private static final ThreadLocalRandom rand;
+
+    private static final byte[] BYTES_SMALL = new byte[256];
+    private static final byte[] BYTES_LARGE = new byte[MAX_BLOCK_SIZE * BASE_BLOCK_SIZE * 2];
+
+    static {
+        rand = ThreadLocalRandom.current();
+        rand.nextBytes(BYTES_SMALL);
+        rand.nextBytes(BYTES_LARGE);
+    }
+
+    @Rule
+    public ExpectedException expected = ExpectedException.none();
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void initChannel() {
+        channel = new EmbeddedChannel(new Bzip2Decoder());
+    }
+
+    @Test
+    public void testUnexpectedStreamIdentifier() throws Exception {
+        expected.expect(DecompressionException.class);
+        expected.expectMessage("Unexpected stream identifier contents");
+
+        ByteBuf in = Unpooled.buffer();
+        in.writeLong(1823080128301928729L); //random value
+
+        channel.writeInbound(in);
+    }
+
+    @Test
+    public void testInvalidBlockSize() throws Exception {
+        expected.expect(DecompressionException.class);
+        expected.expectMessage("block size is invalid");
+
+        ByteBuf in = Unpooled.buffer();
+        in.writeMedium(MAGIC_NUMBER);
+        in.writeByte('0');  //incorrect block size
+
+        channel.writeInbound(in);
+    }
+
+    @Test
+    public void testBadBlockHeader() throws Exception {
+        expected.expect(DecompressionException.class);
+        expected.expectMessage("bad block header");
+
+        ByteBuf in = Unpooled.buffer();
+        in.writeMedium(MAGIC_NUMBER);
+        in.writeByte('1');  //block size
+        in.writeInt(11111); //random value
+        in.writeShort(111); //random value
+        in.writeInt(111);   //block CRC
+
+        channel.writeInbound(in);
+    }
+
+    @Test
+    public void testStreamCrcErrorOfEmptyBlock() throws Exception {
+        expected.expect(DecompressionException.class);
+        expected.expectMessage("stream CRC error");
+
+        ByteBuf in = Unpooled.buffer();
+        in.writeMedium(MAGIC_NUMBER);
+        in.writeByte('1');  //block size
+        in.writeInt((int) (END_OF_STREAM_MAGIC >> 16));
+        in.writeShort((int) END_OF_STREAM_MAGIC);
+        in.writeInt(1);  //wrong storedCombinedCRC
+
+        channel.writeInbound(in);
+    }
+
+    @Test
+    public void testStreamCrcError() throws Exception {
+        expected.expect(DecompressionException.class);
+        expected.expectMessage("stream CRC error");
+
+        final byte[] data = { 0x42, 0x5A, 0x68, 0x37, 0x31, 0x41, 0x59, 0x26, 0x53,
+                              0x59, 0x77, 0x7B, (byte) 0xCA, (byte) 0xC0, 0x00, 0x00,
+                              0x00, 0x05, (byte) 0x80, 0x00, 0x01, 0x02, 0x00, 0x04,
+                              0x20, 0x20, 0x00, 0x30, (byte) 0xCD, 0x34, 0x19, (byte) 0xA6,
+                              (byte) 0x89, (byte) 0x99, (byte) 0xC5, (byte) 0xDC, (byte) 0x91,
+                              0x4E, 0x14, 0x24, 0x1D, (byte) 0xDD, (byte) 0xF2, (byte) 0xB0, 0x00 };
+
+        ByteBuf in = Unpooled.wrappedBuffer(data);
+        try {
+            channel.writeInbound(in);
+        } finally {
+            for (;;) {
+                ByteBuf inflated = channel.readInbound();
+                if (inflated == null) {
+                    break;
+                }
+                inflated.release();
+            }
+            channel.finish();
+        }
+    }
+
+    @Test
+    public void testIncorrectHuffmanGroupsNumber() throws Exception {
+        expected.expect(DecompressionException.class);
+        expected.expectMessage("incorrect huffman groups number");
+
+        final byte[] data = { 0x42, 0x5A, 0x68, 0x37, 0x31, 0x41, 0x59, 0x26, 0x53,
+                              0x59, 0x77, 0x7B, (byte) 0xCA, (byte) 0xC0, 0x00, 0x00,
+                              0x00, 0x05, (byte) 0x80, 0x00, 0x01, 0x02, 0x00, 0x04,
+                              0x20, 0x70, 0x00, 0x30, (byte) 0xCD, 0x34, 0x19, (byte) 0xA6,
+                              (byte) 0x89, (byte) 0x99, (byte) 0xC5, (byte) 0xDC, (byte) 0x91,
+                              0x4E, 0x14, 0x24, 0x1D, (byte) 0xDE, (byte) 0xF2, (byte) 0xB0, 0x00 };
+
+        ByteBuf in = Unpooled.wrappedBuffer(data);
+        channel.writeInbound(in);
+    }
+
+    @Test
+    public void testIncorrectSelectorsNumber() throws Exception {
+        expected.expect(DecompressionException.class);
+        expected.expectMessage("incorrect selectors number");
+
+        final byte[] data = { 0x42, 0x5A, 0x68, 0x37, 0x31, 0x41, 0x59, 0x26, 0x53,
+                              0x59, 0x77, 0x7B, (byte) 0xCA, (byte) 0xC0, 0x00, 0x00,
+                              0x00, 0x05, (byte) 0x80, 0x00, 0x01, 0x02, 0x00, 0x04,
+                              0x20, 0x2F, (byte) 0xFF, 0x30, (byte) 0xCD, 0x34, 0x19, (byte) 0xA6,
+                              (byte) 0x89, (byte) 0x99, (byte) 0xC5, (byte) 0xDC, (byte) 0x91,
+                              0x4E, 0x14, 0x24, 0x1D, (byte) 0xDE, (byte) 0xF2, (byte) 0xB0, 0x00 };
+
+        ByteBuf in = Unpooled.wrappedBuffer(data);
+        channel.writeInbound(in);
+    }
+
+    @Test
+    public void testBlockCrcError() throws Exception {
+        expected.expect(DecompressionException.class);
+        expected.expectMessage("block CRC error");
+
+        final byte[] data = { 0x42, 0x5A, 0x68, 0x37, 0x31, 0x41, 0x59, 0x26, 0x53,
+                              0x59, 0x77, 0x77, (byte) 0xCA, (byte) 0xC0, 0x00, 0x00,
+                              0x00, 0x05, (byte) 0x80, 0x00, 0x01, 0x02, 0x00, 0x04,
+                              0x20, 0x20, 0x00, 0x30, (byte) 0xCD, 0x34, 0x19, (byte) 0xA6,
+                              (byte) 0x89, (byte) 0x99, (byte) 0xC5, (byte) 0xDC, (byte) 0x91,
+                              0x4E, 0x14, 0x24, 0x1D, (byte) 0xDE, (byte) 0xF2, (byte) 0xB0, 0x00 };
+
+        ByteBuf in = Unpooled.wrappedBuffer(data);
+        channel.writeInbound(in);
+    }
+
+    private static void testDecompression(final byte[] data) throws Exception {
+        for (int blockSize = MIN_BLOCK_SIZE; blockSize <= MAX_BLOCK_SIZE; blockSize++) {
+            final EmbeddedChannel channel = new EmbeddedChannel(new Bzip2Decoder());
+
+            ByteArrayOutputStream os = new ByteArrayOutputStream();
+            BZip2CompressorOutputStream bZip2Os = new BZip2CompressorOutputStream(os, blockSize);
+            bZip2Os.write(data);
+            bZip2Os.close();
+
+            ByteBuf compressed = Unpooled.wrappedBuffer(os.toByteArray());
+            channel.writeInbound(compressed);
+
+            ByteBuf uncompressed = Unpooled.buffer();
+            ByteBuf msg;
+            while ((msg = channel.readInbound()) != null) {
+                uncompressed.writeBytes(msg);
+                msg.release();
+            }
+            final byte[] result = new byte[uncompressed.readableBytes()];
+            uncompressed.readBytes(result);
+            uncompressed.release();
+
+            assertArrayEquals(data, result);
+        }
+    }
+
+    @Test
+    public void testDecompressionOfSmallChunkOfData() throws Exception {
+        testDecompression(BYTES_SMALL);
+    }
+
+    @Test
+    public void testDecompressionOfLargeChunkOfData() throws Exception {
+        testDecompression(BYTES_LARGE);
+    }
+
+    @Test
+    public void testDecompressionOfBatchedFlowOfData() throws Exception {
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        BZip2CompressorOutputStream bZip2Os = new BZip2CompressorOutputStream(os,
+                                                    rand.nextInt(MIN_BLOCK_SIZE, MAX_BLOCK_SIZE + 1));
+        bZip2Os.write(BYTES_LARGE);
+        bZip2Os.close();
+
+        final byte[] compressedArray = os.toByteArray();
+        int written = 0, length = rand.nextInt(100);
+        while (written + length < compressedArray.length) {
+            ByteBuf compressed = Unpooled.wrappedBuffer(compressedArray, written, length);
+            channel.writeInbound(compressed);
+            written += length;
+            length = rand.nextInt(100);
+        }
+        ByteBuf compressed = Unpooled.wrappedBuffer(compressedArray, written, compressedArray.length - written);
+        channel.writeInbound(compressed);
+
+        ByteBuf uncompressed = Unpooled.buffer();
+        ByteBuf msg;
+        while ((msg = channel.readInbound()) != null) {
+            uncompressed.writeBytes(msg);
+            msg.release();
+        }
+        final byte[] result = new byte[uncompressed.readableBytes()];
+        uncompressed.readBytes(result);
+        uncompressed.release();
+
+        assertArrayEquals(BYTES_LARGE, result);
+    }
+}
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/JdkZlibTest.java b/codec/src/test/java/io/netty/handler/codec/compression/JdkZlibTest.java
index efc010a1af97..23f178d924f4 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/JdkZlibTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/JdkZlibTest.java
@@ -30,21 +30,9 @@ protected ZlibDecoder createDecoder(ZlibWrapper wrapper) {
         return new JdkZlibDecoder(wrapper);
     }
 
+    @Test(expected = DecompressionException.class)
     @Override
-    @Test(expected = IllegalArgumentException.class)
-    public void testZLIB_OR_NONE() throws Exception {
-        new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);
-    }
-
-    @Override
-    @Test(expected = IllegalArgumentException.class)
-    public void testZLIB_OR_NONE2() throws Exception {
-        new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);
-    }
-
-    @Override
-    @Test(expected = IllegalArgumentException.class)
     public void testZLIB_OR_NONE3() throws Exception {
-        new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);
+        super.testZLIB_OR_NONE3();
     }
 }
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java
index 994369b4a173..5c8355fbd5a0 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java
@@ -53,7 +53,7 @@ public void testInvalidStreamIdentifierLength() throws Exception {
     @Test(expected = DecompressionException.class)
     public void testInvalidStreamIdentifierValue() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
-            -0x80, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y'
+            (byte) 0xff, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y'
         });
 
         channel.writeInbound(in);
@@ -89,7 +89,7 @@ public void testCompressedDataBeforeStreamIdentifier() throws Exception {
     @Test
     public void testReservedSkippableSkipsInput() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
-           -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+           (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
            -0x7f, 0x05, 0x00, 0x00, 'n', 'e', 't', 't', 'y'
         });
 
@@ -102,7 +102,7 @@ public void testReservedSkippableSkipsInput() throws Exception {
     @Test
     public void testUncompressedDataAppendsToOut() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
-           -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+           (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
             0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 'n', 'e', 't', 't', 'y'
         });
 
@@ -115,7 +115,7 @@ public void testUncompressedDataAppendsToOut() throws Exception {
     @Test
     public void testCompressedDataDecodesAndAppendsToOut() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
-           -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+           (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
             0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x05, // preamble length
                   0x04 << 2, // literal tag + length
@@ -137,7 +137,7 @@ public void testInvalidChecksumThrowsException() throws Exception {
 
         // checksum here is presented as 0
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
-           -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+           (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
             0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 'n', 'e', 't', 't', 'y'
         });
 
@@ -150,7 +150,7 @@ public void testInvalidChecksumDoesNotThrowException() throws Exception {
 
         // checksum here is presented as a282986f (little endian)
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
-           -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+           (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
             0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y'
         });
 
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
index a193ce6c1eac..9b1d606e143e 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
@@ -22,7 +22,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static io.netty.util.ReferenceCountUtil.releaseLater;
+import static io.netty.util.ReferenceCountUtil.*;
 import static org.junit.Assert.*;
 
 public class SnappyFramedEncoderTest {
@@ -43,7 +43,7 @@ public void testSmallAmountOfDataIsUncompressed() throws Exception {
         assertTrue(channel.finish());
 
         ByteBuf expected = Unpooled.wrappedBuffer(new byte[] {
-            -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+            (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
              0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y'
         });
 
@@ -61,7 +61,7 @@ public void testLargeAmountOfDataIsCompressed() throws Exception {
         assertTrue(channel.finish());
 
         ByteBuf expected = Unpooled.wrappedBuffer(new byte[] {
-            -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+            (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
              0x00, 0x0E, 0x00, 0x00, 0x3b, 0x36, -0x7f, 0x37,
                    0x14, 0x10,
                    'n', 'e', 't', 't', 'y',
@@ -83,14 +83,14 @@ public void testStreamStartIsOnlyWrittenOnce() throws Exception {
         assertTrue(channel.finish());
 
         ByteBuf expected = Unpooled.wrappedBuffer(new byte[] {
-            -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
+            (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,
              0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y',
              0x01, 0x09, 0x00, 0x00, 0x6f, -0x68, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y',
         });
 
         CompositeByteBuf actual = Unpooled.compositeBuffer();
         for (;;) {
-            ByteBuf m = (ByteBuf) channel.readOutbound();
+            ByteBuf m = channel.readOutbound();
             if (m == null) {
                 break;
             }
@@ -145,7 +145,7 @@ public void testInputBufferOverseek() throws Exception {
 
         channel.writeOutbound(in);
         assertTrue(channel.finish());
-        ByteBuf out = (ByteBuf) channel.readOutbound();
+        ByteBuf out = channel.readOutbound();
         out.release();
     }
 }
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java b/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
index c00db3183642..565215b381d3 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
@@ -122,7 +122,7 @@ private static void testIdentity(ByteBuf in) {
         EmbeddedChannel decoder = new EmbeddedChannel(new SnappyFramedDecoder());
         try {
             encoder.writeOutbound(in.copy());
-            ByteBuf compressed = (ByteBuf) encoder.readOutbound();
+            ByteBuf compressed = encoder.readOutbound();
             assertThat(compressed, is(notNullValue()));
             assertThat(compressed, is(not(in)));
             decoder.writeInbound(compressed.retain());
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/ZlibCrossTest2.java b/codec/src/test/java/io/netty/handler/codec/compression/ZlibCrossTest2.java
index 4495bef4c3f6..8717019ed95f 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/ZlibCrossTest2.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibCrossTest2.java
@@ -29,21 +29,9 @@ protected ZlibDecoder createDecoder(ZlibWrapper wrapper) {
         return new JdkZlibDecoder(wrapper);
     }
 
+    @Test(expected = DecompressionException.class)
     @Override
-    @Test(expected = IllegalArgumentException.class)
-    public void testZLIB_OR_NONE() throws Exception {
-        new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);
-    }
-
-    @Override
-    @Test(expected = IllegalArgumentException.class)
-    public void testZLIB_OR_NONE2() throws Exception {
-        new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);
-    }
-
-    @Override
-    @Test(expected = IllegalArgumentException.class)
     public void testZLIB_OR_NONE3() throws Exception {
-        new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);
+        super.testZLIB_OR_NONE3();
     }
 }
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java
index e9d3a5dff5b3..8f32a7189a74 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java
@@ -25,6 +25,8 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
+import java.util.zip.DeflaterOutputStream;
 import java.util.zip.GZIPOutputStream;
 
 import static org.junit.Assert.*;
@@ -33,6 +35,49 @@ public abstract class ZlibTest {
 
     private static final byte[] BYTES_SMALL = new byte[128];
     private static final byte[] BYTES_LARGE = new byte[1024 * 1024];
+    private static final byte[] BYTES_LARGE2 = ("<!--?xml version=\"1.0\" encoding=\"ISO-8859-1\"?-->\n" +
+            "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" " +
+            "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n" +
+            "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\"><head>\n" +
+            "    <title>Apache Tomcat</title>\n" +
+            "</head>\n" +
+            '\n' +
+            "<body>\n" +
+            "<h1>It works !</h1>\n" +
+            '\n' +
+            "<p>If you're seeing this page via a web browser, it means you've setup Tomcat successfully." +
+            " Congratulations!</p>\n" +
+            " \n" +
+            "<p>This is the default Tomcat home page." +
+            " It can be found on the local filesystem at: <code>/var/lib/tomcat7/webapps/ROOT/index.html</code></p>\n" +
+            '\n' +
+            "<p>Tomcat7 veterans might be pleased to learn that this system instance of Tomcat is installed with" +
+            " <code>CATALINA_HOME</code> in <code>/usr/share/tomcat7</code> and <code>CATALINA_BASE</code> in" +
+            " <code>/var/lib/tomcat7</code>, following the rules from" +
+            " <code>/usr/share/doc/tomcat7-common/RUNNING.txt.gz</code>.</p>\n" +
+            '\n' +
+            "<p>You might consider installing the following packages, if you haven't already done so:</p>\n" +
+            '\n' +
+            "<p><b>tomcat7-docs</b>: This package installs a web application that allows to browse the Tomcat 7" +
+            " documentation locally. Once installed, you can access it by clicking <a href=\"docs/\">here</a>.</p>\n" +
+            '\n' +
+            "<p><b>tomcat7-examples</b>: This package installs a web application that allows to access the Tomcat" +
+            " 7 Servlet and JSP examples. Once installed, you can access it by clicking" +
+            " <a href=\"examples/\">here</a>.</p>\n" +
+            '\n' +
+            "<p><b>tomcat7-admin</b>: This package installs two web applications that can help managing this Tomcat" +
+            " instance. Once installed, you can access the <a href=\"manager/html\">manager webapp</a> and" +
+            " the <a href=\"host-manager/html\">host-manager webapp</a>.</p><p>\n" +
+            '\n' +
+            "</p><p>NOTE: For security reasons, using the manager webapp is restricted" +
+            " to users with role \"manager\"." +
+            " The host-manager webapp is restricted to users with role \"admin\". Users are " +
+            "defined in <code>/etc/tomcat7/tomcat-users.xml</code>.</p>\n" +
+            '\n' +
+            '\n' +
+            '\n' +
+            "</body></html>").getBytes(CharsetUtil.UTF_8);
+
     static {
         ThreadLocalRandom rand = ThreadLocalRandom.current();
         rand.nextBytes(BYTES_SMALL);
@@ -44,95 +89,151 @@ public abstract class ZlibTest {
 
     @Test
     public void testGZIP2() throws Exception {
-        ByteBuf data = Unpooled.wrappedBuffer("message".getBytes(CharsetUtil.UTF_8));
-        ByteBuf deflatedData = Unpooled.wrappedBuffer(gzip("message"));
+        byte[] bytes = "message".getBytes(CharsetUtil.UTF_8);
+        ByteBuf data = Unpooled.wrappedBuffer(bytes);
+        ByteBuf deflatedData = Unpooled.wrappedBuffer(gzip(bytes));
 
         EmbeddedChannel chDecoderGZip = new EmbeddedChannel(createDecoder(ZlibWrapper.GZIP));
-        chDecoderGZip.writeInbound(deflatedData.copy());
-        assertTrue(chDecoderGZip.finish());
-        ByteBuf buf = (ByteBuf) chDecoderGZip.readInbound();
-        assertEquals(buf, data);
-        assertNull(chDecoderGZip.readInbound());
-        data.release();
-        deflatedData.release();
-        buf.release();
+        try {
+            chDecoderGZip.writeInbound(deflatedData.copy());
+            assertTrue(chDecoderGZip.finish());
+            ByteBuf buf = chDecoderGZip.readInbound();
+            assertEquals(buf, data);
+            assertNull(chDecoderGZip.readInbound());
+            data.release();
+            deflatedData.release();
+            buf.release();
+        } finally {
+            dispose(chDecoderGZip);
+        }
     }
 
     private void testCompress0(ZlibWrapper encoderWrapper, ZlibWrapper decoderWrapper, ByteBuf data) throws Exception {
         EmbeddedChannel chEncoder = new EmbeddedChannel(createEncoder(encoderWrapper));
+        EmbeddedChannel chDecoderZlib = new EmbeddedChannel(createDecoder(decoderWrapper));
 
-        chEncoder.writeOutbound(data.copy());
-        chEncoder.flush();
+        try {
+            chEncoder.writeOutbound(data.copy());
+            chEncoder.flush();
 
-        EmbeddedChannel chDecoderZlib = new EmbeddedChannel(createDecoder(decoderWrapper));
-        for (;;) {
-            ByteBuf deflatedData = (ByteBuf) chEncoder.readOutbound();
-            if (deflatedData == null) {
-                break;
+            for (;;) {
+                ByteBuf deflatedData = chEncoder.readOutbound();
+                if (deflatedData == null) {
+                    break;
+                }
+                chDecoderZlib.writeInbound(deflatedData);
             }
-            chDecoderZlib.writeInbound(deflatedData);
-        }
 
-        byte[] decompressed = new byte[data.readableBytes()];
-        int offset = 0;
-        for (;;) {
-            ByteBuf buf = (ByteBuf) chDecoderZlib.readInbound();
-            if (buf == null) {
-                break;
+            byte[] decompressed = new byte[data.readableBytes()];
+            int offset = 0;
+            for (;;) {
+                ByteBuf buf = chDecoderZlib.readInbound();
+                if (buf == null) {
+                    break;
+                }
+                int length = buf.readableBytes();
+                buf.readBytes(decompressed, offset, length);
+                offset += length;
+                buf.release();
+                if (offset == decompressed.length) {
+                    break;
+                }
             }
-            int length = buf.readableBytes();
-            buf.readBytes(decompressed, offset, length);
-            offset += length;
-            buf.release();
-            if (offset == decompressed.length) {
-                break;
-            }
-        }
-        assertEquals(data, Unpooled.wrappedBuffer(decompressed));
-        assertNull(chDecoderZlib.readInbound());
+            assertEquals(data, Unpooled.wrappedBuffer(decompressed));
+            assertNull(chDecoderZlib.readInbound());
 
-        // Closing an encoder channel will generate a footer.
-        assertTrue(chEncoder.finish());
-        for (;;) {
-            Object msg = chEncoder.readOutbound();
-            if (msg == null) {
-                break;
+            // Closing an encoder channel will generate a footer.
+            assertTrue(chEncoder.finish());
+            for (;;) {
+                Object msg = chEncoder.readOutbound();
+                if (msg == null) {
+                    break;
+                }
+                ReferenceCountUtil.release(msg);
             }
-            ReferenceCountUtil.release(msg);
-        }
-        // But, the footer will be decoded into nothing. It's only for validation.
-        assertFalse(chDecoderZlib.finish());
+            // But, the footer will be decoded into nothing. It's only for validation.
+            assertFalse(chDecoderZlib.finish());
 
-        data.release();
+            data.release();
+        } finally {
+            dispose(chEncoder);
+            dispose(chDecoderZlib);
+        }
     }
 
     private void testCompressNone(ZlibWrapper encoderWrapper, ZlibWrapper decoderWrapper) throws Exception {
         EmbeddedChannel chEncoder = new EmbeddedChannel(createEncoder(encoderWrapper));
+        EmbeddedChannel chDecoderZlib = new EmbeddedChannel(createDecoder(decoderWrapper));
 
-        // Closing an encoder channel without writing anything should generate both header and footer.
-        assertTrue(chEncoder.finish());
+        try {
+            // Closing an encoder channel without writing anything should generate both header and footer.
+            assertTrue(chEncoder.finish());
 
-        EmbeddedChannel chDecoderZlib = new EmbeddedChannel(createDecoder(decoderWrapper));
-        for (;;) {
-            ByteBuf deflatedData = (ByteBuf) chEncoder.readOutbound();
-            if (deflatedData == null) {
-                break;
+            for (;;) {
+                ByteBuf deflatedData = chEncoder.readOutbound();
+                if (deflatedData == null) {
+                    break;
+                }
+                chDecoderZlib.writeInbound(deflatedData);
+            }
+
+            // Decoder should not generate anything at all.
+            boolean decoded = false;
+            for (;;) {
+                ByteBuf buf = chDecoderZlib.readInbound();
+                if (buf == null) {
+                    break;
+                }
+
+                buf.release();
+                decoded = true;
             }
-            chDecoderZlib.writeInbound(deflatedData);
+            assertFalse("should decode nothing", decoded);
+
+            assertFalse(chDecoderZlib.finish());
+        } finally {
+            dispose(chEncoder);
+            dispose(chDecoderZlib);
         }
+    }
+
+    private static void dispose(EmbeddedChannel ch) {
+        if (ch.finish()) {
+            for (;;) {
+                Object msg = ch.readInbound();
+                if (msg == null) {
+                    break;
+                }
+                ReferenceCountUtil.release(msg);
+            }
+            for (;;) {
+                Object msg = ch.readOutbound();
+                if (msg == null) {
+                    break;
+                }
+                ReferenceCountUtil.release(msg);
+            }
+        }
+    }
+
+    // Test for https://github.com/netty/netty/issues/2572
+    private void testCompressLarge2(ZlibWrapper decoderWrapper, byte[] compressed, byte[] data) throws Exception {
+        EmbeddedChannel chDecoder = new EmbeddedChannel(createDecoder(decoderWrapper));
+        chDecoder.writeInbound(Unpooled.wrappedBuffer(compressed));
+        assertTrue(chDecoder.finish());
+
+        ByteBuf decoded = Unpooled.buffer(data.length);
 
-        // Decoder should not generate anything at all.
         for (;;) {
-            ByteBuf buf = (ByteBuf) chDecoderZlib.readInbound();
+            ByteBuf buf = chDecoder.readInbound();
             if (buf == null) {
                 break;
             }
-
+            decoded.writeBytes(buf);
             buf.release();
-            fail("should decode nothing");
         }
-
-        assertFalse(chDecoderZlib.finish());
+        assertEquals(Unpooled.wrappedBuffer(data), decoded);
+        decoded.release();
     }
 
     private void testCompressSmall(ZlibWrapper encoderWrapper, ZlibWrapper decoderWrapper) throws Exception {
@@ -152,6 +253,7 @@ public void testZLIB() throws Exception {
         testCompressNone(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB);
         testCompressSmall(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB);
         testCompressLarge(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB);
+        testCompressLarge2(ZlibWrapper.ZLIB, deflate(BYTES_LARGE2), BYTES_LARGE2);
     }
 
     @Test
@@ -166,6 +268,7 @@ public void testGZIP() throws Exception {
         testCompressNone(ZlibWrapper.GZIP, ZlibWrapper.GZIP);
         testCompressSmall(ZlibWrapper.GZIP, ZlibWrapper.GZIP);
         testCompressLarge(ZlibWrapper.GZIP, ZlibWrapper.GZIP);
+        testCompressLarge2(ZlibWrapper.GZIP, gzip(BYTES_LARGE2), BYTES_LARGE2);
     }
 
     @Test
@@ -179,7 +282,7 @@ public void testZLIB_OR_NONE() throws Exception {
     public void testZLIB_OR_NONE2() throws Exception {
         testCompressNone(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB_OR_NONE);
         testCompressSmall(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB_OR_NONE);
-        testCompressLarge(ZlibWrapper.GZIP, ZlibWrapper.ZLIB_OR_NONE);
+        testCompressLarge(ZlibWrapper.ZLIB, ZlibWrapper.ZLIB_OR_NONE);
     }
 
     @Test
@@ -189,12 +292,19 @@ public void testZLIB_OR_NONE3() throws Exception {
         testCompressLarge(ZlibWrapper.GZIP, ZlibWrapper.ZLIB_OR_NONE);
     }
 
-    private static byte[] gzip(String message) throws IOException {
+    private static byte[] gzip(byte[] bytes) throws IOException {
         ByteArrayOutputStream out = new ByteArrayOutputStream();
         GZIPOutputStream stream = new GZIPOutputStream(out);
-        stream.write(message.getBytes(CharsetUtil.UTF_8));
+        stream.write(bytes);
         stream.close();
         return out.toByteArray();
     }
 
+    private static byte[] deflate(byte[] bytes) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        OutputStream stream = new DeflaterOutputStream(out);
+        stream.write(bytes);
+        stream.close();
+        return out.toByteArray();
+    }
 }
diff --git a/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java
index c02affe905f5..57b12a81e61e 100644
--- a/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java
@@ -24,7 +24,6 @@
 import org.junit.Test;
 
 import static io.netty.buffer.Unpooled.*;
-import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
 
 public class LengthFieldPrependerTest {
@@ -40,8 +39,13 @@ public void setUp() throws Exception {
     public void testPrependLength() throws Exception {
         final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4));
         ch.writeOutbound(msg);
-        final ByteBuf buf = (ByteBuf) ch.readOutbound();
-        assertThat(buf, is(wrappedBuffer(new byte[]{0, 0, 0, 1, 'A'})));
+        ByteBuf buf = ch.readOutbound();
+        assertEquals(4, buf.readableBytes());
+        assertEquals(msg.readableBytes(), buf.readInt());
+        buf.release();
+
+        buf = ch.readOutbound();
+        assertSame(buf, msg);
         buf.release();
     }
 
@@ -49,8 +53,13 @@ public void testPrependLength() throws Exception {
     public void testPrependLengthIncludesLengthFieldLength() throws Exception {
         final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4, true));
         ch.writeOutbound(msg);
-        final ByteBuf buf = (ByteBuf) ch.readOutbound();
-        assertThat(buf, is(wrappedBuffer(new byte[]{0, 0, 0, 5, 'A'})));
+        ByteBuf buf = ch.readOutbound();
+        assertEquals(4, buf.readableBytes());
+        assertEquals(5, buf.readInt());
+        buf.release();
+
+        buf = ch.readOutbound();
+        assertSame(buf, msg);
         buf.release();
     }
 
@@ -58,8 +67,13 @@ public void testPrependLengthIncludesLengthFieldLength() throws Exception {
     public void testPrependAdjustedLength() throws Exception {
         final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4, -1));
         ch.writeOutbound(msg);
-        final ByteBuf buf = (ByteBuf) ch.readOutbound();
-        assertThat(buf, is(wrappedBuffer(new byte[]{0, 0, 0, 0, 'A'})));
+        ByteBuf buf = ch.readOutbound();
+        assertEquals(4, buf.readableBytes());
+        assertEquals(msg.readableBytes() - 1, buf.readInt());
+        buf.release();
+
+        buf = ch.readOutbound();
+        assertSame(buf, msg);
         buf.release();
     }
 
diff --git a/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java
new file mode 100644
index 000000000000..08ece60917bc
--- /dev/null
+++ b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.json;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.CorruptedFrameException;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.util.CharsetUtil;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class JsonObjectDecoderTest {
+    @Test
+    public void testJsonObjectOverMultipleWrites() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+
+        String objectPart1 = "{ \"firstname\": \"John";
+        String objectPart2 = "\" ,\n \"surname\" :";
+        String objectPart3 = "\"Doe\", age:22   \n}";
+
+        // Test object
+        ch.writeInbound(Unpooled.copiedBuffer("  \n\n  " + objectPart1, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(objectPart2, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(objectPart3 + "   \n\n  \n", CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(objectPart1 + objectPart2 + objectPart3, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testJsonArrayOverMultipleWrites() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+
+        String arrayPart1 = "[{\"test";
+        String arrayPart2 = "case\"  : \"\\\"}]Escaped dou\\\"ble quotes \\\" in JSON str\\\"ing\"";
+        String arrayPart3 = "  }\n\n    , ";
+        String arrayPart4 = "{\"testcase\" : \"Streaming string me";
+        String arrayPart5 = "ssage\"} ]";
+
+        // Test array
+        ch.writeInbound(Unpooled.copiedBuffer("   " + arrayPart1, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(arrayPart2, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(arrayPart3, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(arrayPart4, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(arrayPart5 + "      ", CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(arrayPart1 + arrayPart2 + arrayPart3 + arrayPart4 + arrayPart5, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testSingleByteStream() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+
+        String json = "{\"foo\" : {\"bar\" : [{},{}]}}";
+        for (byte c : json.getBytes(CharsetUtil.UTF_8)) {
+            ch.writeInbound(Unpooled.copiedBuffer(new byte[] {c}));
+        }
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(json, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testMultipleJsonObjectsInOneWrite() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+
+        String object1 = "{\"key\" : \"value1\"}",
+               object2 = "{\"key\" : \"value2\"}",
+               object3 = "{\"key\" : \"value3\"}";
+
+        ch.writeInbound(Unpooled.copiedBuffer(object1 + object2 + object3, CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(object1, res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals(object2, res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals(object3, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
+    @Test(expected = CorruptedFrameException.class)
+    public void testNonJsonContent1() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+        try {
+            ch.writeInbound(Unpooled.copiedBuffer("  b [1,2,3]", CharsetUtil.UTF_8));
+        } finally {
+            assertFalse(ch.finish());
+        }
+
+        fail();
+    }
+
+    @Test(expected = CorruptedFrameException.class)
+    public void testNonJsonContent2() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+        ch.writeInbound(Unpooled.copiedBuffer("  [1,2,3]  ", CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals("[1,2,3]", res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        try {
+            ch.writeInbound(Unpooled.copiedBuffer(" a {\"key\" : 10}", CharsetUtil.UTF_8));
+        } finally {
+            assertFalse(ch.finish());
+        }
+
+        fail();
+    }
+
+    @Test (expected = TooLongFrameException.class)
+    public void testMaxObjectLength() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder(6));
+        try {
+            ch.writeInbound(Unpooled.copiedBuffer("[2,4,5]", CharsetUtil.UTF_8));
+        } finally {
+            assertFalse(ch.finish());
+        }
+
+        fail();
+    }
+
+    @Test
+    public void testOneJsonObjectPerWrite() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+
+        String object1 = "{\"key\" : \"value1\"}",
+               object2 = "{\"key\" : \"value2\"}",
+               object3 = "{\"key\" : \"value3\"}";
+
+        ch.writeInbound(Unpooled.copiedBuffer(object1, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(object2, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(object3, CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(object1, res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals(object2, res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals(object3, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testSpecialJsonCharsInString() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+
+        String object = "{ \"key\" : \"[]{}}\\\"}}'}\"}";
+        ch.writeInbound(Unpooled.copiedBuffer(object, CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(object, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testStreamArrayElementsSimple() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder(Integer.MAX_VALUE, true));
+
+        String array = "[  12, \"bla\"  , 13.4   \t  ,{\"key0\" : [1,2], \"key1\" : 12, \"key2\" : {}} , " +
+                       "true, false, null, [\"bla\", {}, [1,2,3]] ]";
+        String object = "{\"bla\" : \"blub\"}";
+        ch.writeInbound(Unpooled.copiedBuffer(array, CharsetUtil.UTF_8));
+        ch.writeInbound(Unpooled.copiedBuffer(object, CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals("12", res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals("\"bla\"", res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals("13.4", res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals("{\"key0\" : [1,2], \"key1\" : 12, \"key2\" : {}}", res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals("true", res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals("false", res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals("null", res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals("[\"bla\", {}, [1,2,3]]", res.toString(CharsetUtil.UTF_8));
+        res.release();
+        res = ch.readInbound();
+        assertEquals(object, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+}
diff --git a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
index 1b65d5fbb0d0..79c2bfb2174a 100644
--- a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
@@ -53,7 +53,7 @@ public void testSimpleUnmarshalling() throws IOException {
         ch.writeInbound(input(testBytes));
         assertTrue(ch.finish());
 
-        String unmarshalled = (String) ch.readInbound();
+        String unmarshalled = ch.readInbound();
 
         assertEquals(testObject, unmarshalled);
 
@@ -87,7 +87,7 @@ public void testFragmentedUnmarshalling() throws IOException {
         ch.writeInbound(buffer);
         assertTrue(ch.finish());
 
-        String unmarshalled = (String) ch.readInbound();
+        String unmarshalled = ch.readInbound();
 
         assertEquals(testObject, unmarshalled);
 
diff --git a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
index f6dfa4f219c7..7897a0d629ce 100644
--- a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
@@ -24,14 +24,12 @@
 import org.jboss.marshalling.Unmarshaller;
 import org.junit.Test;
 
-import java.io.IOException;
-
 import static org.junit.Assert.*;
 
 public abstract class AbstractCompatibleMarshallingEncoderTest {
 
     @Test
-    public void testMarshalling() throws IOException, ClassNotFoundException {
+    public void testMarshalling() throws Exception {
         @SuppressWarnings("RedundantStringConstructorCall")
         String testObject = new String("test");
 
@@ -43,7 +41,7 @@ public void testMarshalling() throws IOException, ClassNotFoundException {
         ch.writeOutbound(testObject);
         assertTrue(ch.finish());
 
-        ByteBuf buffer = (ByteBuf) ch.readOutbound();
+        ByteBuf buffer = ch.readOutbound();
 
         Unmarshaller unmarshaller = marshallerFactory.createUnmarshaller(configuration);
         unmarshaller.start(Marshalling.createByteInput(truncate(buffer).nioBuffer()));
diff --git a/codec/src/test/java/io/netty/handler/codec/string/StringEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/string/StringEncoderTest.java
index ee9c98864ee8..9cbf827620b7 100644
--- a/codec/src/test/java/io/netty/handler/codec/string/StringEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/string/StringEncoderTest.java
@@ -29,7 +29,7 @@ public void testEncode() {
         EmbeddedChannel channel = new EmbeddedChannel(new StringEncoder());
         Assert.assertTrue(channel.writeOutbound(msg));
         Assert.assertTrue(channel.finish());
-        ByteBuf buf = (ByteBuf) channel.readOutbound();
+        ByteBuf buf = channel.readOutbound();
         byte[] data = new byte[buf.readableBytes()];
         buf.readBytes(data);
         Assert.assertArrayEquals(msg.getBytes(CharsetUtil.UTF_8), data);
diff --git a/codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java
new file mode 100644
index 000000000000..62f6719fd7bc
--- /dev/null
+++ b/codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.xml;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.CorruptedFrameException;
+import io.netty.handler.codec.TooLongFrameException;
+import io.netty.util.CharsetUtil;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+public class XmlFrameDecoderTest {
+
+    private final List<String> xmlSamples;
+
+    public XmlFrameDecoderTest() throws IOException, URISyntaxException {
+        xmlSamples = Arrays.asList(
+                sample("01"), sample("02"), sample("03"),
+                sample("04"), sample("05"), sample("06")
+        );
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testConstructorWithIllegalArgs01() {
+        new XmlFrameDecoder(0);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testConstructorWithIllegalArgs02() {
+        new XmlFrameDecoder(-23);
+    }
+
+    @Test(expected = TooLongFrameException.class)
+    public void testDecodeWithFrameExceedingMaxLength() {
+        XmlFrameDecoder decoder = new XmlFrameDecoder(3);
+        EmbeddedChannel ch = new EmbeddedChannel(decoder);
+        ch.writeInbound(Unpooled.copiedBuffer("<v/>", CharsetUtil.UTF_8));
+    }
+
+    @Test(expected = CorruptedFrameException.class)
+    public void testDecodeWithInvalidInput() {
+        XmlFrameDecoder decoder = new XmlFrameDecoder(1048576);
+        EmbeddedChannel ch = new EmbeddedChannel(decoder);
+        ch.writeInbound(Unpooled.copiedBuffer("invalid XML", CharsetUtil.UTF_8));
+    }
+
+    @Test(expected = CorruptedFrameException.class)
+    public void testDecodeWithInvalidContentBeforeXml() {
+        XmlFrameDecoder decoder = new XmlFrameDecoder(1048576);
+        EmbeddedChannel ch = new EmbeddedChannel(decoder);
+        ch.writeInbound(Unpooled.copiedBuffer("invalid XML<foo/>", CharsetUtil.UTF_8));
+    }
+
+    @Test
+    public void testDecodeShortValidXml() {
+        testDecodeWithXml("<xxx/>", "<xxx/>");
+    }
+
+    @Test
+    public void testDecodeShortValidXmlWithLeadingWhitespace01() {
+        testDecodeWithXml("   <xxx/>", "<xxx/>");
+    }
+
+    @Test
+    public void testDecodeShortValidXmlWithLeadingWhitespace02() {
+        testDecodeWithXml("  \n\r \t<xxx/>\t", "<xxx/>");
+    }
+
+    @Test
+    public void testDecodeShortValidXmlWithLeadingWhitespace02AndTrailingGarbage() {
+        testDecodeWithXml("  \n\r \t<xxx/>\ttrash", "<xxx/>", CorruptedFrameException.class);
+    }
+
+    @Test
+    public void testDecodeWithCDATABlock() {
+        final String xml = "<book>" +
+                "<![CDATA[K&R, a.k.a. Kernighan & Ritchie]]>" +
+                "</book>";
+        testDecodeWithXml(xml, xml);
+    }
+
+    @Test
+    public void testDecodeWithCDATABlockContainingNestedUnbalancedXml() {
+        // <br> isn't closed, also <a> should have been </a>
+        final String xml = "<info>" +
+                "<![CDATA[Copyright 2012-2013,<br><a href=\"http://www.acme.com\">ACME Inc.<a>]]>" +
+                "</info>";
+        testDecodeWithXml(xml, xml);
+    }
+
+    @Test
+    public void testDecodeWithTwoMessages() {
+        final String input = "<root xmlns=\"http://www.acme.com/acme\" status=\"loginok\" " +
+                "timestamp=\"1362410583776\"/>\n\n" +
+                "<root xmlns=\"http://www.acme.com/acme\" status=\"start\" time=\"0\" " +
+                "timestamp=\"1362410584794\">\n<child active=\"1\" status=\"started\" id=\"935449\" " +
+                "msgnr=\"2\"/>\n</root>";
+        final String frame1 = "<root xmlns=\"http://www.acme.com/acme\" status=\"loginok\" " +
+                "timestamp=\"1362410583776\"/>";
+        final String frame2 = "<root xmlns=\"http://www.acme.com/acme\" status=\"start\" time=\"0\" " +
+                "timestamp=\"1362410584794\">\n<child active=\"1\" status=\"started\" id=\"935449\" " +
+                "msgnr=\"2\"/>\n</root>";
+        testDecodeWithXml(input, frame1, frame2);
+    }
+
+    @Test
+    public void testDecodeWithSampleXml() {
+        for (final String xmlSample : xmlSamples) {
+            testDecodeWithXml(xmlSample, xmlSample);
+        }
+    }
+
+    private static void testDecodeWithXml(String xml, Object... expected) {
+        EmbeddedChannel ch = new EmbeddedChannel(new XmlFrameDecoder(1048576));
+        Exception cause = null;
+        try {
+            ch.writeInbound(Unpooled.copiedBuffer(xml, CharsetUtil.UTF_8));
+        } catch (Exception e) {
+            cause = e;
+        }
+        List<Object> actual = new ArrayList<Object>();
+        for (;;) {
+            ByteBuf buf = ch.readInbound();
+            if (buf == null) {
+                break;
+            }
+            actual.add(buf.toString(CharsetUtil.UTF_8));
+            buf.release();
+        }
+
+        if (cause != null) {
+            actual.add(cause.getClass());
+        }
+
+        try {
+            List<Object> expectedList = new ArrayList<Object>();
+            Collections.addAll(expectedList, expected);
+            assertThat(actual, is(expectedList));
+        } finally {
+            ch.finish();
+        }
+    }
+
+    private String sample(String number) throws IOException, URISyntaxException {
+        String path = "io/netty/handler/codec/xml/sample-" + number + ".xml";
+        URL url = getClass().getClassLoader().getResource(path);
+        if (url == null) {
+            throw new IllegalArgumentException("file not found: " + path);
+        }
+        byte[] buf = Files.readAllBytes(Paths.get(url.toURI()));
+        return StandardCharsets.UTF_8.decode(ByteBuffer.wrap(buf)).toString();
+    }
+}
diff --git a/codec/src/test/resources/io/netty/handler/codec/xml/sample-01.xml b/codec/src/test/resources/io/netty/handler/codec/xml/sample-01.xml
new file mode 100644
index 000000000000..2408a6fe9d98
--- /dev/null
+++ b/codec/src/test/resources/io/netty/handler/codec/xml/sample-01.xml
@@ -0,0 +1 @@
+<root xmlns="http://www.acme.com/acme" status="loginok" timestamp="1362392496667"/>
\ No newline at end of file
diff --git a/codec/src/test/resources/io/netty/handler/codec/xml/sample-02.xml b/codec/src/test/resources/io/netty/handler/codec/xml/sample-02.xml
new file mode 100644
index 000000000000..ffd40cdac762
--- /dev/null
+++ b/codec/src/test/resources/io/netty/handler/codec/xml/sample-02.xml
@@ -0,0 +1,3 @@
+<root xmlns="http://www.acme.com/acme" status="start" time="0" timestamp="1362392497684">
+    <child active="1" status="started" id="935449" msgnr="2"/>
+</root>
\ No newline at end of file
diff --git a/.fbfilter.xml b/codec/src/test/resources/io/netty/handler/codec/xml/sample-03.xml
similarity index 99%
rename from .fbfilter.xml
rename to codec/src/test/resources/io/netty/handler/codec/xml/sample-03.xml
index 9e350abcf9a6..bda593493fd5 100644
--- a/.fbfilter.xml
+++ b/codec/src/test/resources/io/netty/handler/codec/xml/sample-03.xml
@@ -62,4 +62,4 @@
     </Or>
     <Bug pattern="SE_TRANSIENT_FIELD_NOT_RESTORED,SE_BAD_FIELD"/>
   </Match>
-</FindBugsFilter>
+</FindBugsFilter>
\ No newline at end of file
diff --git a/codec/src/test/resources/io/netty/handler/codec/xml/sample-04.xml b/codec/src/test/resources/io/netty/handler/codec/xml/sample-04.xml
new file mode 100644
index 000000000000..65bc2ccd8b07
--- /dev/null
+++ b/codec/src/test/resources/io/netty/handler/codec/xml/sample-04.xml
@@ -0,0 +1,773 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2012 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>7</version>
+  </parent>
+
+  <groupId>io.netty</groupId>
+  <artifactId>netty-parent</artifactId>
+  <packaging>pom</packaging>
+  <version>4.0.14.Final-SNAPSHOT</version>
+
+  <name>Netty</name>
+  <url>http://netty.io/</url>
+  <description>
+    Netty is an asynchronous event-driven network application framework for 
+    rapid development of maintainable high performance protocol servers and
+    clients.
+  </description>
+
+  <organization>
+    <name>The Netty Project</name>
+    <url>http://netty.io/</url>
+  </organization>
+
+  <licenses>
+    <license>
+      <name>Apache License, Version 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0</url>
+    </license>
+  </licenses>
+  <inceptionYear>2008</inceptionYear>
+
+  <scm>
+    <url>https://github.com/netty/netty</url>
+    <connection>scm:git:git://github.com/netty/netty.git</connection>
+    <developerConnection>scm:git:ssh://git@github.com/netty/netty.git</developerConnection>
+    <tag>HEAD</tag>
+  </scm>
+
+  <developers>
+    <developer>
+      <id>netty.io</id>
+      <name>The Netty Project Contributors</name>
+      <email>netty@googlegroups.com</email>
+      <url>http://netty.io/</url>
+      <organization>The Netty Project</organization>
+      <organizationUrl>http://netty.io/</organizationUrl>
+    </developer>
+  </developers>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+    <jboss.marshalling.version>1.3.18.GA</jboss.marshalling.version>
+    <test.jvm.argLine>
+      -server 
+      -dsa -da -ea:io.netty...
+      -XX:+AggressiveOpts
+      -XX:+TieredCompilation
+      -XX:+UseBiasedLocking
+      -XX:+UseFastAccessorMethods
+      -XX:+UseStringCache
+      -XX:+OptimizeStringConcat
+      -XX:+HeapDumpOnOutOfMemoryError
+    </test.jvm.argLine>
+  </properties>
+ 
+  <modules>
+    <module>common</module>
+    <module>buffer</module>
+    <module>codec</module>
+    <module>codec-http</module>
+    <module>codec-socks</module>
+    <module>transport</module>
+    <module>transport-rxtx</module>
+    <module>transport-sctp</module>
+    <module>transport-udt</module>
+    <module>handler</module>
+    <module>example</module>
+    <module>testsuite</module>
+    <module>microbench</module>
+    <module>all</module>
+    <module>tarball</module>
+  </modules>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Byte code generator - completely optional -->
+      <dependency>
+        <groupId>org.javassist</groupId>
+        <artifactId>javassist</artifactId>
+        <version>3.18.0-GA</version>
+        <scope>compile</scope>
+        <optional>true</optional>
+      </dependency>
+
+      <!-- JBoss Marshalling - completely optional -->
+      <dependency>
+        <groupId>org.jboss.marshalling</groupId>
+        <artifactId>jboss-marshalling</artifactId>
+        <version>${jboss.marshalling.version}</version>
+        <scope>compile</scope>
+        <optional>true</optional>
+      </dependency>
+    
+      <dependency>
+        <groupId>com.google.protobuf</groupId>
+        <artifactId>protobuf-java</artifactId>
+        <version>2.5.0</version>
+      </dependency>
+      <dependency>
+        <groupId>com.jcraft</groupId>
+        <artifactId>jzlib</artifactId>
+          <version>1.1.2</version>
+      </dependency>
+
+      <dependency>
+        <groupId>org.rxtx</groupId>
+        <artifactId>rxtx</artifactId>
+        <version>2.1.7</version>
+      </dependency>
+
+      <dependency>
+        <groupId>com.barchart.udt</groupId>
+        <artifactId>barchart-udt-bundle</artifactId>
+        <version>2.3.0</version>
+      </dependency>
+
+      <dependency>
+        <groupId>javax.servlet</groupId>
+        <artifactId>servlet-api</artifactId>
+        <version>2.5</version>
+      </dependency>
+
+      <dependency>
+        <groupId>org.slf4j</groupId>
+        <artifactId>slf4j-api</artifactId>
+        <version>1.7.5</version>
+      </dependency>
+      <dependency>
+        <groupId>commons-logging</groupId>
+        <artifactId>commons-logging</artifactId>
+        <version>1.1.3</version>
+      </dependency>
+      <dependency>
+        <groupId>log4j</groupId>
+        <artifactId>log4j</artifactId>
+        <version>1.2.17</version>
+        <exclusions>
+          <exclusion>
+            <artifactId>mail</artifactId>
+            <groupId>javax.mail</groupId>
+          </exclusion>
+          <exclusion>
+            <artifactId>jms</artifactId>
+            <groupId>javax.jms</groupId>
+          </exclusion>
+          <exclusion>
+            <artifactId>jmxtools</artifactId>
+            <groupId>com.sun.jdmk</groupId>
+          </exclusion>
+          <exclusion>
+            <artifactId>jmxri</artifactId>
+            <groupId>com.sun.jmx</groupId>
+          </exclusion>
+        </exclusions>
+        <optional>true</optional>
+      </dependency>
+      
+      <!-- Metrics providers -->
+      <dependency>
+        <groupId>com.yammer.metrics</groupId>
+        <artifactId>metrics-core</artifactId>
+        <version>2.2.0</version>
+      </dependency>
+      
+      <!-- Test dependencies for jboss marshalling encoder/decoder -->
+      <dependency>
+        <groupId>org.jboss.marshalling</groupId>
+        <artifactId>jboss-marshalling-serial</artifactId>
+        <version>${jboss.marshalling.version}</version>
+        <scope>test</scope>
+       </dependency>
+      <dependency>
+        <groupId>org.jboss.marshalling</groupId>
+        <artifactId>jboss-marshalling-river</artifactId>
+        <version>${jboss.marshalling.version}</version>
+        <scope>test</scope>
+      </dependency>
+
+      <!-- Test dependencies for microbench -->
+      <dependency>
+        <groupId>com.google.caliper</groupId>
+        <artifactId>caliper</artifactId>
+        <version>0.5-rc1</version>
+        <scope>test</scope>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+    <!-- Enable Javassist support for all test runs -->
+    <dependency>
+      <groupId>org.javassist</groupId>
+      <artifactId>javassist</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- Testing frameworks and related dependencies -->
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <version>4.11</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.easymock</groupId>
+      <artifactId>easymock</artifactId>
+      <version>3.2</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.easymock</groupId>
+      <artifactId>easymockclassextension</artifactId>
+      <version>3.2</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.jmock</groupId>
+      <artifactId>jmock-junit4</artifactId>
+      <version>2.6.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>ch.qos.logback</groupId>
+      <artifactId>logback-classic</artifactId>
+      <version>1.0.13</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-enforcer-plugin</artifactId>
+        <version>1.3</version>
+        <executions>
+          <execution>
+            <id>enforce-tools</id>
+            <goals>
+              <goal>enforce</goal>
+            </goals>
+            <configuration>
+              <rules>
+                <requireJavaVersion>
+                  <!-- Enforce java 1.7 as minimum for compiling -->
+                  <!-- This is needed because of java.util.zip.Deflater and NIO UDP multicast-->
+                  <version>[1.7.0,)</version>
+                </requireJavaVersion>
+                <requireMavenVersion>
+                  <version>[3.0.5,3.1)</version>
+                </requireMavenVersion>
+              </rules>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <compilerVersion>1.7</compilerVersion>
+          <fork>true</fork>
+          <source>1.6</source>
+          <target>1.6</target>
+          <debug>true</debug>
+          <optimize>true</optimize>
+          <showDeprecation>true</showDeprecation>
+          <showWarnings>true</showWarnings>
+          <compilerArgument>-Xlint:-options</compilerArgument>
+          <!-- XXX: maven-release-plugin complains - MRELEASE-715 -->
+          <!--
+          <compilerArguments>
+            <Xlint:-options />
+            <Xlint:unchecked />
+            <Xlint:deprecation />
+          </compilerArguments>
+          -->
+          <meminitial>256m</meminitial>
+          <maxmem>1024m</maxmem>
+        </configuration>
+      </plugin>
+      <plugin>
+        <!-- ensure that only methods available in java 1.6 can
+             be used even when compiling with java 1.7+ -->
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <version>1.9</version>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java16</artifactId>
+            <version>1.0</version>
+          </signature>
+          <ignores>
+            <ignore>sun.misc.Unsafe</ignore>
+            <ignore>sun.misc.Cleaner</ignore>
+
+            <ignore>java.util.zip.Deflater</ignore>
+
+            <!-- Used for NIO UDP multicast -->
+            <ignore>java.nio.channels.DatagramChannel</ignore>
+            <ignore>java.nio.channels.MembershipKey</ignore>
+            <ignore>java.net.StandardProtocolFamily</ignore>
+
+            <!-- Used for NIO. 2 -->
+            <ignore>java.nio.channels.AsynchronousChannel</ignore>
+            <ignore>java.nio.channels.AsynchronousSocketChannel</ignore>
+            <ignore>java.nio.channels.AsynchronousServerSocketChannel</ignore>
+            <ignore>java.nio.channels.AsynchronousChannelGroup</ignore>
+            <ignore>java.nio.channels.NetworkChannel</ignore>
+            <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>
+            <ignore>java.net.StandardSocketOptions</ignore>
+            <ignore>java.net.SocketOption</ignore>
+          </ignores>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>process-classes</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <artifactId>maven-checkstyle-plugin</artifactId>
+        <version>2.10</version>
+        <executions>
+          <execution>
+            <id>check-style</id>
+            <goals>
+              <goal>check</goal>
+            </goals>
+            <phase>validate</phase>
+            <configuration>
+              <consoleOutput>true</consoleOutput>
+              <logViolationsToConsole>true</logViolationsToConsole>
+              <failsOnError>true</failsOnError>
+              <failOnViolation>true</failOnViolation>
+              <configLocation>io/netty/checkstyle.xml</configLocation>
+              <includeTestSourceDirectory>true</includeTestSourceDirectory>
+            </configuration>
+          </execution>
+        </executions>
+        <dependencies>
+          <dependency>
+            <groupId>${project.groupId}</groupId>
+            <artifactId>netty-build</artifactId>
+            <version>19</version>
+          </dependency>
+        </dependencies>
+      </plugin>
+      <plugin>
+        <artifactId>maven-surefire-plugin</artifactId>
+        <configuration>
+          <includes>
+             <include>**/*Test*.java</include>
+             <include>**/*Benchmark*.java</include>
+          </includes>
+          <excludes>
+            <exclude>**/Abstract*</exclude>
+            <exclude>**/TestUtil*</exclude>
+          </excludes>
+          <runOrder>random</runOrder>
+          <argLine>${test.jvm.argLine}</argLine>
+        </configuration>
+      </plugin>
+      <!-- always produce osgi bundles -->
+      <plugin>
+        <groupId>org.apache.felix</groupId>
+        <artifactId>maven-bundle-plugin</artifactId>
+        <version>2.4.0</version>
+        <executions>
+          <execution>
+            <id>generate-manifest</id>
+            <phase>process-classes</phase>
+            <goals>
+              <goal>manifest</goal>
+            </goals>
+            <configuration>
+              <instructions>
+                <Export-Package>${project.groupId}.*</Export-Package>
+                <!-- enforce JVM vendor package as optional -->
+                <Import-Package>sun.misc.*;resolution:=optional,*</Import-Package>
+                <!-- override "internal" private package convention -->
+                <Private-Package>!*</Private-Package>
+              </instructions>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>             
+      <plugin>
+        <artifactId>maven-source-plugin</artifactId>
+        <version>2.2.1</version>
+        <executions>
+          <!--
+            ~ This workaround prevents Maven from executing the 'generate-sources' phase twice.
+            ~ See http://jira.codehaus.org/browse/MSOURCES-13
+            ~ and http://blog.peterlynch.ca/2010/05/maven-how-to-prevent-generate-sources.html
+            -->
+          <execution>
+            <id>attach-sources</id>
+            <phase>invalid</phase>
+            <goals>
+              <goal>jar</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>attach-sources-no-fork</id>
+            <phase>package</phase>
+            <goals>
+              <goal>jar-no-fork</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.9.1</version>
+        <configuration>
+          <detectOfflineLinks>false</detectOfflineLinks>
+          <breakiterator>true</breakiterator>
+          <version>false</version>
+          <author>false</author>
+          <keywords>true</keywords>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <version>2.7</version>
+        <configuration>
+          <retryFailedDeploymentCount>10</retryFailedDeploymentCount>
+        </configuration>
+      </plugin>
+      <plugin>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.4.1</version>
+        <configuration>
+          <useReleaseProfile>false</useReleaseProfile>
+          <arguments>-P release,sonatype-oss-release,full,no-osgi</arguments>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+          <allowTimestampedSnapshots>false</allowTimestampedSnapshots>
+          <tagNameFormat>netty-@{project.version}</tagNameFormat>
+        </configuration>
+      </plugin>
+
+      <!-- Ensure to put maven-antrun-plugin at the end of the plugin list
+           so that they are run lastly in the same phase. -->
+      <plugin>
+        <artifactId>maven-antrun-plugin</artifactId>
+        <executions>
+          <!-- Generate the version properties for all artifacts. -->
+          <execution>
+            <id>write-version-properties</id>
+            <phase>initialize</phase>
+            <goals>
+              <goal>run</goal>
+            </goals>
+            <configuration>
+              <target>
+                <taskdef resource="net/sf/antcontrib/antlib.xml" />
+
+                <!-- Get the information about the latest commit -->
+                <exec executable="git" outputproperty="gitOutput.shortCommitHash" resultproperty="gitExitCode.shortCommitHash" failonerror="false" failifexecutionfails="false">
+                  <arg value="log" />
+                  <arg value="-1" />
+                  <arg value="--format=format:%h" />
+                </exec>
+                <if>
+                  <equals arg2="0" arg1="${gitExitCode.shortCommitHash}" />
+                  <then>
+                    <property name="shortCommitHash" value="${gitOutput.shortCommitHash}" />
+                  </then>
+                  <else>
+                    <property name="shortCommitHash" value="0" />
+                  </else>
+                </if>
+
+                <exec executable="git" outputproperty="gitOutput.longCommitHash" resultproperty="gitExitCode.longCommitHash" failonerror="false" failifexecutionfails="false">
+                  <arg value="log" />
+                  <arg value="-1" />
+                  <arg value="--format=format:%H" />
+                </exec>
+                <if>
+                  <equals arg2="0" arg1="${gitExitCode.longCommitHash}" />
+                  <then>
+                    <property name="longCommitHash" value="${gitOutput.longCommitHash}" />
+                  </then>
+                  <else>
+                    <property name="longCommitHash" value="0000000000000000000000000000000000000000" />
+                  </else>
+                </if>
+
+                <exec executable="git" outputproperty="gitOutput.commitDate" resultproperty="gitExitCode.commitDate" failonerror="false" failifexecutionfails="false">
+                  <arg value="log" />
+                  <arg value="-1" />
+                  <arg value="--format=format:%cd" />
+                  <arg value="--date=iso" />
+                </exec>
+                <if>
+                  <equals arg2="0" arg1="${gitExitCode.commitDate}" />
+                  <then>
+                    <property name="commitDate" value="${gitOutput.commitDate}" />
+                  </then>
+                  <else>
+                    <property name="commitDate" value="1970-01-01 00:00:00 +0000" />
+                  </else>
+                </if>
+
+                <exec executable="git" outputproperty="gitOutput.repoStatus" resultproperty="gitExitCode.repoStatus" failonerror="false" failifexecutionfails="false">
+                  <arg value="status" />
+                  <arg value="--porcelain" />
+                </exec>
+                <if>
+                  <equals arg2="0" arg1="${gitExitCode.repoStatus}" />
+                  <then>
+                    <if>
+                      <equals arg2="" arg1="${gitOutput.repoStatus}" />
+                      <then>
+                        <property name="repoStatus" value="clean" />
+                      </then>
+                      <else>
+                        <property name="repoStatus" value="dirty" />
+                      </else>
+                    </if>
+                  </then>
+                  <else>
+                    <property name="repoStatus" value="unknown" />
+                  </else>
+                </if>
+
+                <!-- Print the obtained commit information. -->
+                <echo>Current commit: ${shortCommitHash} on ${commitDate}</echo>
+
+                <!-- Generate the .properties file. -->
+                <!--
+                <property name="metaInfDir" value="${project.basedir}/src/main/resources/META-INF" />
+                -->
+                <property name="metaInfDir" value="${project.build.outputDirectory}/META-INF" />
+                <property name="versionPropFile" value="${metaInfDir}/${project.groupId}.versions.properties" />
+                <mkdir dir="${metaInfDir}" />
+                <delete file="${versionPropFile}" quiet="true" />
+
+                <propertyfile file="${versionPropFile}" comment="Generated by netty-parent/pom.xml">
+                  <entry key="${project.artifactId}.version" value="${project.version}" />
+                  <entry key="${project.artifactId}.buildDate" type="date" value="now" pattern="yyyy-MM-dd HH:mm:ss Z" />
+                  <entry key="${project.artifactId}.commitDate" value="${commitDate}" />
+                  <entry key="${project.artifactId}.shortCommitHash" value="${shortCommitHash}" />
+                  <entry key="${project.artifactId}.longCommitHash" value="${longCommitHash}" />
+                  <entry key="${project.artifactId}.repoStatus" value="${repoStatus}" />
+                </propertyfile>
+              </target>
+            </configuration>
+          </execution>
+        </executions>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.ant</groupId>
+            <artifactId>ant</artifactId>
+            <version>1.8.2</version>
+          </dependency>
+          <dependency>
+            <groupId>org.apache.ant</groupId>
+            <artifactId>ant-launcher</artifactId>
+            <version>1.8.2</version>
+          </dependency>
+          <dependency>
+            <groupId>ant-contrib</groupId>
+            <artifactId>ant-contrib</artifactId>
+            <version>1.0b3</version>
+            <exclusions>
+              <exclusion>
+                <groupId>ant</groupId>
+                <artifactId>ant</artifactId>
+              </exclusion>
+            </exclusions>
+          </dependency>
+        </dependencies>
+      </plugin>
+    </plugins>
+
+    <pluginManagement>
+      <plugins>
+        <!-- keep surefire and failsafe in sync -->
+        <plugin>
+          <artifactId>maven-surefire-plugin</artifactId>
+          <version>2.15</version>
+        </plugin>
+        <!-- keep surefire and failsafe in sync -->
+        <plugin>
+          <artifactId>maven-failsafe-plugin</artifactId>
+          <version>2.15</version>
+        </plugin>
+        <plugin>
+          <artifactId>maven-clean-plugin</artifactId>
+          <version>2.5</version>
+        </plugin>
+        <plugin>
+          <artifactId>maven-resources-plugin</artifactId>
+          <version>2.6</version>
+        </plugin>
+        <plugin>
+          <artifactId>maven-jar-plugin</artifactId>
+          <version>2.4</version>
+          <executions>
+            <execution>
+              <id>default-jar</id>
+              <configuration>
+                <archive>
+                  <manifest>
+                    <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
+                  </manifest>
+                  <index>true</index>
+                  <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>
+                </archive>
+              </configuration>
+            </execution>
+          </executions>
+        </plugin>
+        <plugin>
+          <artifactId>maven-dependency-plugin</artifactId>
+          <version>2.8</version>
+        </plugin>
+        <plugin>
+          <artifactId>maven-assembly-plugin</artifactId>
+          <version>2.4</version>
+        </plugin>
+        <plugin>
+          <!-- Do NOT upgrade -->
+          <artifactId>maven-jxr-plugin</artifactId>
+          <version>2.2</version>
+        </plugin>
+        <plugin>
+          <artifactId>maven-antrun-plugin</artifactId>
+          <version>1.7</version>
+          <dependencies>
+            <dependency>
+              <groupId>ant-contrib</groupId>
+              <artifactId>ant-contrib</artifactId>
+              <version>1.0b3</version>
+              <exclusions>
+                <exclusion>
+                  <groupId>ant</groupId>
+                  <artifactId>ant</artifactId>
+                </exclusion>
+              </exclusions>
+            </dependency>
+          </dependencies>
+        </plugin>
+        <plugin>
+          <groupId>org.codehaus.mojo</groupId>
+          <artifactId>build-helper-maven-plugin</artifactId>
+          <version>1.8</version>
+        </plugin>               
+
+        <!-- Workaround for the 'M2E plugin execution not covered' problem.
+             See: http://wiki.eclipse.org/M2E_plugin_execution_not_covered -->
+        <plugin>
+          <groupId>org.eclipse.m2e</groupId>
+          <artifactId>lifecycle-mapping</artifactId>
+          <version>1.0.0</version>
+          <configuration>
+            <lifecycleMappingMetadata>
+              <pluginExecutions>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-antrun-plugin</artifactId>
+                    <versionRange>[1.7,)</versionRange>
+                    <goals>
+                      <goal>run</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <ignore />
+                  </action>
+                </pluginExecution>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-checkstyle-plugin</artifactId>
+                    <versionRange>[1.0,)</versionRange>
+                    <goals>
+                      <goal>check</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <execute>
+                      <runOnIncremental>false</runOnIncremental>
+                    </execute>
+                  </action>
+                </pluginExecution>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-enforcer-plugin</artifactId>
+                    <versionRange>[1.0,)</versionRange>
+                    <goals>
+                      <goal>enforce</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <execute>
+                      <runOnIncremental>false</runOnIncremental>
+                    </execute>
+                  </action>
+                </pluginExecution>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-clean-plugin</artifactId>
+                    <versionRange>[1.0,)</versionRange>
+                    <goals>
+                      <goal>clean</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <execute>
+                      <runOnIncremental>false</runOnIncremental>
+                    </execute>
+                  </action>
+                </pluginExecution>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>org.apache.felix</groupId>
+                    <artifactId>maven-bundle-plugin</artifactId>
+                    <versionRange>[2.4,)</versionRange>
+                    <goals>
+                      <goal>manifest</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <ignore />
+                  </action>
+                </pluginExecution>
+              </pluginExecutions>
+            </lifecycleMappingMetadata>
+          </configuration>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+  </build>
+</project>
\ No newline at end of file
diff --git a/codec/src/test/resources/io/netty/handler/codec/xml/sample-05.xml b/codec/src/test/resources/io/netty/handler/codec/xml/sample-05.xml
new file mode 100644
index 000000000000..427cbf824d5d
--- /dev/null
+++ b/codec/src/test/resources/io/netty/handler/codec/xml/sample-05.xml
@@ -0,0 +1,81 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- this sample file tests CDATA sections -->
+<chapter id="rockets">
+    <title>Rocket Launching</title>
+
+    <sect1 id="rocket-configuration">
+        <title>Configuration</title>
+
+        <para>
+            Configuring rockets should look very familiar if you're used
+            to Jakarta Commons-Rocket or Commons-Space. You will first
+            create a normal
+            <literal>ContextSource</literal>
+            then wrap it in a
+            <literal>RocketContextSource</literal>
+            .
+            <informalexample>
+				<programlisting><![CDATA[
+<beans>
+   ...
+   <bean id="contextSource" class="org.apache.commons.rocket.factory.RocketContextSource">
+      <property name="contextSource" ref="contextSourceTarget" />
+   </bean>
+    
+   <bean id="contextSourceTarget" class="org.apache.commons.rocket.core.support.OrbitContextSource">
+      <property name="url" value="orbit://localhost:12345" />
+      <property name="user" value="neil" />
+      <property name="password" value="secret" />
+      <property name="pooled" value="false"/>
+   </bean>
+   ...
+</beans>
+]]></programlisting>
+            </informalexample>
+            In a real world example you would probably configure the
+            rocket options and enable connection validation; the above
+            serves as an example to demonstrate the general idea.
+        </para>
+
+        <sect2 id="rocket-advanced-configuration">
+            <title>Validation Configuration</title>
+
+            <para>
+                Adding validation and a few rocket configuration tweaks to
+                the above example is straight forward. Inject a
+                <literal>RocketContextValidator</literal>
+                and set when validation should occur and the rocket is
+                ready to go.
+                <informalexample>
+					<programlisting><![CDATA[
+<beans>
+   ...
+   <bean id="contextSource" class="org.apache.commons.rocket.factory.RocketContextSource">
+      <property name="contextSource" ref="contextSourceTarget" />
+      <property name="rocketContextValidator" ref="rocketContextValidator" />
+      <property name="testOnBorrow" value="true" />
+      <property name="testWhileIdle" value="true" />
+   </bean>
+
+   <bean id="rocketContextValidator"
+         class="org.apache.commons.space.validation.DefaultRocketContextValidator" />
+    
+   <bean id="contextSourceTarget" class="org.apache.commons.rocket.core.support.OrbitContextSource">
+      <property name="url" value="orbit://localhost:12345" />
+      <property name="user" value="neil" />
+      <property name="password" value="secret" />
+      <property name="pooled" value="false"/>
+   </bean>
+   ...
+</beans>
+]]></programlisting>
+                </informalexample>
+                The above example will test each
+                <literal>RocketContext</literal>
+                before it is passed to the client application and test
+                <literal>RocketContext</literal>
+                s that have been sitting idle in orbit.
+            </para>
+		</sect2>
+	</sect1>
+</chapter>
\ No newline at end of file
diff --git a/codec/src/test/resources/io/netty/handler/codec/xml/sample-06.xml b/codec/src/test/resources/io/netty/handler/codec/xml/sample-06.xml
new file mode 100644
index 000000000000..ecf5f8d7a06d
--- /dev/null
+++ b/codec/src/test/resources/io/netty/handler/codec/xml/sample-06.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- this sample file tests CDATA blocks with explicitly unbalanced xml inside -->
+<chapter id="rockets">
+	<title>Rocket Launching</title>
+
+	<sect1 id="rocket-configuration">
+		<title>Configuration</title>
+
+		<para>
+			Configuring rockets should look very familiar if you're used
+			to Jakarta Commons-Rocket or Commons-Space. You will first
+			create a normal
+			<literal>ContextSource</literal>
+			then wrap it in a
+			<literal>RocketContextSource</literal>
+			.
+			<informalexample>
+				<programlisting><![CDATA[
+<beans>
+   ...
+   <bean id="contextSource" class="org.apache.commons.rocket.factory.RocketContextSource">
+      <property name="contextSource" ref="contextSourceTarget" />
+   ...
+]]></programlisting>
+			</informalexample>
+			In a real world example you would probably configure the
+			rocket options and enable connection validation; the above
+			serves as an example to demonstrate the general idea.
+		</para>
+
+		<sect2 id="rocket-advanced-configuration">
+			<title>Validation Configuration</title>
+
+			<para>
+				Adding validation and a few rocket configuration tweaks to
+				the above example is straight forward. Inject a
+				<literal>RocketContextValidator</literal>
+				and set when validation should occur and the rocket is
+				ready to go.
+				<informalexample>
+					<programlisting><![CDATA[
+<beans>
+   ...
+   <bean id="contextSource" class="org.apache.commons.rocket.factory.RocketContextSource">
+      <property name="contextSource" ref="contextSourceTarget" />
+   ...
+   <bean id="rocketContextValidator"
+   ...
+   <bean id="contextSourceTarget" class="org.apache.commons.rocket.core.support.OrbitContextSource">
+      <property name="url" value="orbit://localhost:12345" />
+   ...
+]]></programlisting>
+				</informalexample>
+				The above example will test each
+				<literal>RocketContext</literal>
+				before it is passed to the client application and test
+				<literal>RocketContext</literal>
+				s that have been sitting idle in orbit.
+			</para>
+		</sect2>
+	</sect1>
+</chapter>
\ No newline at end of file
diff --git a/common/pom.xml b/common/pom.xml
index e623892ff926..fed69753edb3 100644
--- a/common/pom.xml
+++ b/common/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-common</artifactId>
diff --git a/common/src/main/java/io/netty/util/AbstractConstant.java b/common/src/main/java/io/netty/util/AbstractConstant.java
new file mode 100644
index 000000000000..580c10ed19c6
--- /dev/null
+++ b/common/src/main/java/io/netty/util/AbstractConstant.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util;
+
+/**
+ * Base implementation of {@link Constant}.
+ */
+public abstract class AbstractConstant<T extends AbstractConstant<T>> implements Constant<T> {
+
+    private final int id;
+    private final String name;
+
+    /**
+     * Creates a new instance.
+     */
+    protected AbstractConstant(int id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    @Override
+    public final String name() {
+        return name;
+    }
+
+    @Override
+    public final int id() {
+        return id;
+    }
+
+    @Override
+    public final int hashCode() {
+        return super.hashCode();
+    }
+
+    @Override
+    public final boolean equals(Object o) {
+        return super.equals(o);
+    }
+
+    @Override
+    public final int compareTo(T other) {
+        if (this == other) {
+            return 0;
+        }
+
+        int returnCode = name.compareTo(other.name());
+        if (returnCode != 0) {
+            return returnCode;
+        }
+
+        return ((Integer) id).compareTo(other.id());
+    }
+
+    @Override
+    public final String toString() {
+        return name();
+    }
+}
diff --git a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
index 80f21d19c7d8..20bacafa7eb8 100644
--- a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
@@ -35,7 +35,6 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
         refCntUpdater = updater;
     }
 
-    @SuppressWarnings("FieldMayBeFinal")
     private volatile int refCnt = 1;
 
     @Override
@@ -89,7 +88,12 @@ public ReferenceCounted retain(int increment) {
     }
 
     @Override
-    public final boolean release() {
+    public ReferenceCounted touch() {
+        return touch(null);
+    }
+
+    @Override
+    public boolean release() {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt == 0) {
@@ -107,7 +111,7 @@ public final boolean release() {
     }
 
     @Override
-    public final boolean release(int decrement) {
+    public boolean release(int decrement) {
         if (decrement <= 0) {
             throw new IllegalArgumentException("decrement: " + decrement + " (expected: > 0)");
         }
diff --git a/common/src/main/java/io/netty/util/AttributeKey.java b/common/src/main/java/io/netty/util/AttributeKey.java
index 97d703574d2a..4d52b94207f3 100644
--- a/common/src/main/java/io/netty/util/AttributeKey.java
+++ b/common/src/main/java/io/netty/util/AttributeKey.java
@@ -15,35 +15,39 @@
  */
 package io.netty.util;
 
-import io.netty.util.internal.PlatformDependent;
-
-import java.util.concurrent.ConcurrentMap;
-
 /**
  * Key which can be used to access {@link Attribute} out of the {@link AttributeMap}. Be aware that it is not be
  * possible to have multiple keys with the same name.
  *
- *
  * @param <T>   the type of the {@link Attribute} which can be accessed via this {@link AttributeKey}.
  */
-@SuppressWarnings({ "UnusedDeclaration", "deprecation" }) // 'T' is used only at compile time
-public final class AttributeKey<T> extends UniqueName {
+@SuppressWarnings("UnusedDeclaration") // 'T' is used only at compile time
+public final class AttributeKey<T> extends AbstractConstant<AttributeKey<T>> {
 
-    private static final ConcurrentMap<String, Boolean> names = PlatformDependent.newConcurrentHashMap();
+    private static final ConstantPool<AttributeKey<Object>> pool = new ConstantPool<AttributeKey<Object>>() {
+        @Override
+        protected AttributeKey<Object> newConstant(int id, String name) {
+            return new AttributeKey<Object>(id, name);
+        }
+    };
 
     /**
-     * Creates a new {@link AttributeKey} with the specified {@code name}.
+     * Returns the singleton instance of the {@link AttributeKey} which has the specified {@code name}.
      */
-    @SuppressWarnings("deprecation")
+    @SuppressWarnings("unchecked")
     public static <T> AttributeKey<T> valueOf(String name) {
-        return new AttributeKey<T>(name);
+        return (AttributeKey<T>) pool.valueOf(name);
     }
 
     /**
-     * @deprecated Use {@link #valueOf(String)} instead.
+     * Shortcut of {@link #valueOf(String) valueOf(firstNameComponent.getName() + "#" + secondNameComponent)}.
      */
-    @Deprecated
-    public AttributeKey(String name) {
-        super(names, name);
+    @SuppressWarnings("unchecked")
+    public static <T> AttributeKey<T> valueOf(Class<?> firstNameComponent, String secondNameComponent) {
+        return (AttributeKey<T>) pool.valueOf(firstNameComponent, secondNameComponent);
+    }
+
+    private AttributeKey(int id, String name) {
+        super(id, name);
     }
 }
diff --git a/common/src/main/java/io/netty/util/AttributeMap.java b/common/src/main/java/io/netty/util/AttributeMap.java
index 0524b1f2878e..826e6959a9d7 100644
--- a/common/src/main/java/io/netty/util/AttributeMap.java
+++ b/common/src/main/java/io/netty/util/AttributeMap.java
@@ -26,4 +26,9 @@ public interface AttributeMap {
      * an {@link Attribute} which does not have a value set yet.
      */
     <T> Attribute<T> attr(AttributeKey<T> key);
+
+    /**
+     * Returns {@code} true if and only if the given {@link Attribute} exists in this {@link AttributeMap}.
+     */
+    <T> boolean hasAttr(AttributeKey<T> key);
 }
diff --git a/common/src/main/java/io/netty/util/CharsetUtil.java b/common/src/main/java/io/netty/util/CharsetUtil.java
index d11c07f6b193..74c0a3dc9148 100644
--- a/common/src/main/java/io/netty/util/CharsetUtil.java
+++ b/common/src/main/java/io/netty/util/CharsetUtil.java
@@ -15,11 +15,12 @@
  */
 package io.netty.util;
 
+import io.netty.util.internal.InternalThreadLocalMap;
+
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CodingErrorAction;
-import java.util.IdentityHashMap;
 import java.util.Map;
 
 /**
@@ -60,22 +61,6 @@ public final class CharsetUtil {
      */
     public static final Charset US_ASCII = Charset.forName("US-ASCII");
 
-    private static final ThreadLocal<Map<Charset, CharsetEncoder>> encoders =
-        new ThreadLocal<Map<Charset, CharsetEncoder>>() {
-            @Override
-            protected Map<Charset, CharsetEncoder> initialValue() {
-                return new IdentityHashMap<Charset, CharsetEncoder>();
-            }
-        };
-
-    private static final ThreadLocal<Map<Charset, CharsetDecoder>> decoders =
-        new ThreadLocal<Map<Charset, CharsetDecoder>>() {
-            @Override
-            protected Map<Charset, CharsetDecoder> initialValue() {
-                return new IdentityHashMap<Charset, CharsetDecoder>();
-            }
-        };
-
     /**
      * Returns a cached thread-local {@link CharsetEncoder} for the specified
      * <tt>charset</tt>.
@@ -85,7 +70,7 @@ public static CharsetEncoder getEncoder(Charset charset) {
             throw new NullPointerException("charset");
         }
 
-        Map<Charset, CharsetEncoder> map = encoders.get();
+        Map<Charset, CharsetEncoder> map = InternalThreadLocalMap.get().charsetEncoderCache();
         CharsetEncoder e = map.get(charset);
         if (e != null) {
             e.reset();
@@ -110,7 +95,7 @@ public static CharsetDecoder getDecoder(Charset charset) {
             throw new NullPointerException("charset");
         }
 
-        Map<Charset, CharsetDecoder> map = decoders.get();
+        Map<Charset, CharsetDecoder> map = InternalThreadLocalMap.get().charsetDecoderCache();
         CharsetDecoder d = map.get(charset);
         if (d != null) {
             d.reset();
diff --git a/example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java b/common/src/main/java/io/netty/util/Constant.java
similarity index 53%
rename from example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java
rename to common/src/main/java/io/netty/util/Constant.java
index d1cae68f0a0a..7132d3730cc9 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java
+++ b/common/src/main/java/io/netty/util/Constant.java
@@ -13,16 +13,20 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.example.http.websocketx.html5;
+package io.netty.util;
 
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
+/**
+ * A singleton which is safe to compare via the {@code ==} operator. Created and managed by {@link ConstantPool}.
+ */
+public interface Constant<T extends Constant<T>> extends Comparable<T> {
+
+    /**
+     * Returns the unique number assigned to this {@link Constant}.
+     */
+    int id();
 
-public class CustomTextFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
-    @Override
-    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame frame) throws Exception {
-        String request = frame.text();
-        ctx.channel().writeAndFlush(new TextWebSocketFrame(request.toUpperCase()));
-    }
+    /**
+     * Returns the name of this {@link Constant}.
+     */
+    String name();
 }
diff --git a/common/src/main/java/io/netty/util/ConstantPool.java b/common/src/main/java/io/netty/util/ConstantPool.java
new file mode 100644
index 000000000000..13601e59e841
--- /dev/null
+++ b/common/src/main/java/io/netty/util/ConstantPool.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A pool of {@link Constant}s.
+ *
+ * @param <T> the type of the constant
+ */
+public abstract class ConstantPool<T extends Constant<T>> {
+
+    private final Map<String, T> constants = new HashMap<String, T>();
+
+    private int nextId = 1;
+
+    /**
+     * Shortcut of {@link #valueOf(String) valueOf(firstNameComponent.getName() + "#" + secondNameComponent)}.
+     */
+    public T valueOf(Class<?> firstNameComponent, String secondNameComponent) {
+        if (firstNameComponent == null) {
+            throw new NullPointerException("firstNameComponent");
+        }
+        if (secondNameComponent == null) {
+            throw new NullPointerException("secondNameComponent");
+        }
+
+        return valueOf(firstNameComponent.getName() + '#' + secondNameComponent);
+    }
+
+    /**
+     * Returns the {@link Constant} which is assigned to the specified {@code name}.
+     * If there's no such {@link Constant}, a new one will be created and returned.
+     * Once created, the subsequent calls with the same {@code name} will always return the previously created one
+     * (i.e. singleton.)
+     *
+     * @param name the name of the {@link Constant}
+     */
+    public T valueOf(String name) {
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+
+        if (name.isEmpty()) {
+            throw new IllegalArgumentException("empty name");
+        }
+
+        synchronized (constants) {
+            T c = constants.get(name);
+            if (c == null) {
+                c = newConstant(nextId, name);
+                constants.put(name, c);
+                nextId ++;
+            }
+
+            return c;
+        }
+    }
+
+    protected abstract T newConstant(int id, String name);
+}
diff --git a/common/src/main/java/io/netty/util/DefaultAttributeMap.java b/common/src/main/java/io/netty/util/DefaultAttributeMap.java
index 806610a03544..78ecdd12b04a 100644
--- a/common/src/main/java/io/netty/util/DefaultAttributeMap.java
+++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java
@@ -17,65 +17,150 @@
 
 import io.netty.util.internal.PlatformDependent;
 
-import java.util.IdentityHashMap;
-import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 /**
- * Default {@link AttributeMap} implementation which use simple synchronization to keep the memory overhead
+ * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead
  * as low as possible.
  */
 public class DefaultAttributeMap implements AttributeMap {
 
     @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, Map> updater;
+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater;
 
     static {
         @SuppressWarnings("rawtypes")
-        AtomicReferenceFieldUpdater<DefaultAttributeMap, Map> referenceFieldUpdater =
-                PlatformDependent.newAtomicReferenceFieldUpdater(DefaultAttributeMap.class, "map");
+        AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> referenceFieldUpdater =
+                PlatformDependent.newAtomicReferenceFieldUpdater(DefaultAttributeMap.class, "attributes");
         if (referenceFieldUpdater == null) {
-            referenceFieldUpdater = AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, Map.class, "map");
+            referenceFieldUpdater = AtomicReferenceFieldUpdater
+                            .newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, "attributes");
         }
         updater = referenceFieldUpdater;
     }
 
+    private static final int BUCKET_SIZE = 4;
+    private static final int MASK = BUCKET_SIZE  - 1;
+
     // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.
     @SuppressWarnings("UnusedDeclaration")
-    private volatile Map<AttributeKey<?>, Attribute<?>> map;
+    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;
 
+    @SuppressWarnings("unchecked")
     @Override
     public <T> Attribute<T> attr(AttributeKey<T> key) {
-        Map<AttributeKey<?>, Attribute<?>> map = this.map;
-        if (map == null) {
+        if (key == null) {
+            throw new NullPointerException("key");
+        }
+        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;
+        if (attributes == null) {
             // Not using ConcurrentHashMap due to high memory consumption.
-            map = new IdentityHashMap<AttributeKey<?>, Attribute<?>>(2);
-            if (!updater.compareAndSet(this, null, map)) {
-                map = this.map;
+            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);
+
+            if (!updater.compareAndSet(this, null, attributes)) {
+                attributes = this.attributes;
+            }
+        }
+
+        int i = index(key);
+        DefaultAttribute<?> head = attributes.get(i);
+        if (head == null) {
+            // No head exists yet which means we may be able to add the attribute without synchronization and just
+            // use compare and set. At worst we need to fallback to synchronization
+            head = new DefaultAttribute(key);
+            if (attributes.compareAndSet(i, null, head)) {
+                // we were able to add it so return the head right away
+                return (Attribute<T>) head;
+            } else {
+                head = attributes.get(i);
             }
         }
 
-        synchronized (map) {
-            @SuppressWarnings("unchecked")
-            Attribute<T> attr = (Attribute<T>) map.get(key);
-            if (attr == null) {
-                attr = new DefaultAttribute<T>(map, key);
-                map.put(key, attr);
+        synchronized (head) {
+            DefaultAttribute<?> curr = head;
+            for (;;) {
+                if (!curr.removed && curr.key == key) {
+                    return (Attribute<T>) curr;
+                }
+
+                DefaultAttribute<?> next = curr.next;
+                if (next == null) {
+                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);
+                    curr.next =  attr;
+                    attr.prev = curr;
+                    return attr;
+                } else {
+                    curr = next;
+                }
+            }
+        }
+    }
+
+    @Override
+    public <T> boolean hasAttr(AttributeKey<T> key) {
+        if (key == null) {
+            throw new NullPointerException("key");
+        }
+        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;
+        if (attributes == null) {
+            // no attribute exists
+            return false;
+        }
+
+        int i = index(key);
+        DefaultAttribute<?> head = attributes.get(i);
+        if (head == null) {
+            // No attribute exists which point to the bucket in which the head should be located
+            return false;
+        }
+
+        // check on the head can be done without synchronization
+        if (head.key == key && !head.removed) {
+            return true;
+        }
+
+        synchronized (head) {
+            // we need to synchronize on the head
+            DefaultAttribute<?> curr = head.next;
+            while (curr != null) {
+                if (!curr.removed && curr.key == key) {
+                    return true;
+                }
+                curr = curr.next;
             }
-            return attr;
+            return false;
         }
     }
 
+    private static int index(AttributeKey<?> key) {
+        return key.id() & MASK;
+    }
+
+    @SuppressWarnings("serial")
     private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {
 
         private static final long serialVersionUID = -2661411462200283011L;
 
-        private final Map<AttributeKey<?>, Attribute<?>> map;
+        // The head of the linked-list this attribute belongs to, which may be itself
+        private final DefaultAttribute<?> head;
         private final AttributeKey<T> key;
 
-        DefaultAttribute(Map<AttributeKey<?>, Attribute<?>> map, AttributeKey<T> key) {
-            this.map = map;
+        // Double-linked list to prev and next node to allow fast removal
+        private DefaultAttribute<?> prev;
+        private DefaultAttribute<?> next;
+
+        // Will be set to true one the attribute is removed via getAndRemove() or remove()
+        private volatile boolean removed;
+
+        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {
+            this.head = head;
+            this.key = key;
+        }
+
+        DefaultAttribute(AttributeKey<T> key) {
+            head = this;
             this.key = key;
         }
 
@@ -97,6 +182,7 @@ public T setIfAbsent(T value) {
 
         @Override
         public T getAndRemove() {
+            removed = true;
             T oldValue = getAndSet(null);
             remove0();
             return oldValue;
@@ -104,13 +190,25 @@ public T getAndRemove() {
 
         @Override
         public void remove() {
+            removed = true;
             set(null);
             remove0();
         }
 
         private void remove0() {
-            synchronized (map) {
-                map.remove(key);
+            synchronized (head) {
+                // We only update the linked-list structure if prev != null because if it is null this
+                // DefaultAttribute acts also as head. The head must never be removed completely and just be
+                // marked as removed as all synchronization is done on the head itself for each bucket.
+                // The head itself will be GC'ed once the DefaultAttributeMap is GC'ed. So at most 5 heads will
+                // be removed lazy as the array size is 5.
+                if (prev != null) {
+                    prev.next = next;
+
+                    if (next != null) {
+                        next.prev = prev;
+                    }
+                }
             }
         }
     }
diff --git a/common/src/main/java/io/netty/util/HashedWheelTimer.java b/common/src/main/java/io/netty/util/HashedWheelTimer.java
index 6c5d575f4fb5..eaec8bdc25f6 100644
--- a/common/src/main/java/io/netty/util/HashedWheelTimer.java
+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java
@@ -15,24 +15,21 @@
  */
 package io.netty.util;
 
+import io.netty.util.internal.MpscLinkedQueueNode;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 /**
  * A {@link Timer} optimized for approximated I/O timeout scheduling.
@@ -84,22 +81,33 @@ public class HashedWheelTimer implements Timer {
             new ResourceLeakDetector<HashedWheelTimer>(
                     HashedWheelTimer.class, 1, Runtime.getRuntime().availableProcessors() * 4);
 
+    private static final AtomicIntegerFieldUpdater<HashedWheelTimer> WORKER_STATE_UPDATER;
+    static {
+        AtomicIntegerFieldUpdater<HashedWheelTimer> workerStateUpdater =
+                PlatformDependent.newAtomicIntegerFieldUpdater(HashedWheelTimer.class, "workerState");
+        if (workerStateUpdater == null) {
+            workerStateUpdater = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, "workerState");
+        }
+        WORKER_STATE_UPDATER = workerStateUpdater;
+    }
+
     private final ResourceLeak leak;
     private final Worker worker = new Worker();
-    final Thread workerThread;
+    private final Thread workerThread;
 
     public static final int WORKER_STATE_INIT = 0;
     public static final int WORKER_STATE_STARTED = 1;
     public static final int WORKER_STATE_SHUTDOWN = 2;
-    final AtomicInteger workerState = new AtomicInteger(); // 0 - init, 1 - started, 2 - shut down
+    @SuppressWarnings({ "unused", "FieldMayBeFinal", "RedundantFieldInitialization" })
+    private volatile int workerState = WORKER_STATE_INIT; // 0 - init, 1 - started, 2 - shut down
+
+    private final long tickDuration;
+    private final HashedWheelBucket[] wheel;
+    private final int mask;
+    private final CountDownLatch startTimeInitialized = new CountDownLatch(1);
+    private final Queue<HashedWheelTimeout> timeouts = PlatformDependent.newMpscQueue();
 
-    final long tickDuration;
-    final Set<HashedWheelTimeout>[] wheel;
-    final int mask;
-    final ReadWriteLock lock = new ReentrantReadWriteLock();
-    final CountDownLatch startTimeInitialized = new CountDownLatch(1);
-    volatile long startTime;
-    volatile long tick;
+    private volatile long startTime;
 
     /**
      * Creates a new timer with the default thread factory
@@ -209,13 +217,12 @@ public HashedWheelTimer(
                     "tickDuration: %d (expected: 0 < tickDuration in nanos < %d",
                     tickDuration, Long.MAX_VALUE / wheel.length));
         }
-
         workerThread = threadFactory.newThread(worker);
+
         leak = leakDetector.open(this);
     }
 
-    @SuppressWarnings("unchecked")
-    private static Set<HashedWheelTimeout>[] createWheel(int ticksPerWheel) {
+    private static HashedWheelBucket[] createWheel(int ticksPerWheel) {
         if (ticksPerWheel <= 0) {
             throw new IllegalArgumentException(
                     "ticksPerWheel must be greater than 0: " + ticksPerWheel);
@@ -226,10 +233,9 @@ private static Set<HashedWheelTimeout>[] createWheel(int ticksPerWheel) {
         }
 
         ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);
-        Set<HashedWheelTimeout>[] wheel = new Set[ticksPerWheel];
+        HashedWheelBucket[] wheel = new HashedWheelBucket[ticksPerWheel];
         for (int i = 0; i < wheel.length; i ++) {
-            wheel[i] = Collections.newSetFromMap(
-                    PlatformDependent.<HashedWheelTimeout, Boolean>newConcurrentHashMap());
+            wheel[i] = new HashedWheelBucket();
         }
         return wheel;
     }
@@ -250,9 +256,9 @@ private static int normalizeTicksPerWheel(int ticksPerWheel) {
      *                               {@linkplain #stop() stopped} already
      */
     public void start() {
-        switch (workerState.get()) {
+        switch (WORKER_STATE_UPDATER.get(this)) {
             case WORKER_STATE_INIT:
-                if (workerState.compareAndSet(WORKER_STATE_INIT, WORKER_STATE_STARTED)) {
+                if (WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {
                     workerThread.start();
                 }
                 break;
@@ -283,9 +289,9 @@ public Set<Timeout> stop() {
                             TimerTask.class.getSimpleName());
         }
 
-        if (!workerState.compareAndSet(WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {
+        if (!WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {
             // workerState can be 0 or 2 at this moment - let it always be 2.
-            workerState.set(WORKER_STATE_SHUTDOWN);
+            WORKER_STATE_UPDATER.set(this, WORKER_STATE_SHUTDOWN);
 
             if (leak != null) {
                 leak.close();
@@ -299,7 +305,7 @@ public Set<Timeout> stop() {
             workerThread.interrupt();
             try {
                 workerThread.join(100);
-            } catch (InterruptedException e) {
+            } catch (InterruptedException ignored) {
                 interrupted = true;
             }
         }
@@ -311,49 +317,31 @@ public Set<Timeout> stop() {
         if (leak != null) {
             leak.close();
         }
-
-        Set<Timeout> unprocessedTimeouts = new HashSet<Timeout>();
-        for (Set<HashedWheelTimeout> bucket: wheel) {
-            unprocessedTimeouts.addAll(bucket);
-            bucket.clear();
-        }
-
-        return Collections.unmodifiableSet(unprocessedTimeouts);
+        return worker.unprocessedTimeouts();
     }
 
     @Override
     public Timeout newTimeout(TimerTask task, long delay, TimeUnit unit) {
-        start();
-
         if (task == null) {
             throw new NullPointerException("task");
         }
         if (unit == null) {
             throw new NullPointerException("unit");
         }
+        start();
 
+        // Add the timeout to the timeout queue which will be processed on the next tick.
+        // During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.
         long deadline = System.nanoTime() + unit.toNanos(delay) - startTime;
-
-        // Add the timeout to the wheel.
-        HashedWheelTimeout timeout;
-        lock.readLock().lock();
-        try {
-            timeout = new HashedWheelTimeout(task, deadline);
-            if (workerState.get() == WORKER_STATE_SHUTDOWN) {
-                throw new IllegalStateException("Cannot enqueue after shutdown");
-            }
-            wheel[timeout.stopIndex].add(timeout);
-        } finally {
-            lock.readLock().unlock();
-        }
-
+        HashedWheelTimeout timeout = new HashedWheelTimeout(this, task, deadline);
+        timeouts.add(timeout);
         return timeout;
     }
 
     private final class Worker implements Runnable {
+        private final Set<Timeout> unprocessedTimeouts = new HashSet<Timeout>();
 
-        Worker() {
-        }
+        private long tick;
 
         @Override
         public void run() {
@@ -367,68 +355,56 @@ public void run() {
             // Notify the other threads waiting for the initialization at start().
             startTimeInitialized.countDown();
 
-            List<HashedWheelTimeout> expiredTimeouts = new ArrayList<HashedWheelTimeout>();
-
             do {
                 final long deadline = waitForNextTick();
                 if (deadline > 0) {
-                    fetchExpiredTimeouts(expiredTimeouts, deadline);
-                    notifyExpiredTimeouts(expiredTimeouts);
+                    transferTimeoutsToBuckets();
+                    HashedWheelBucket bucket =
+                            wheel[(int) (tick & mask)];
+                    bucket.expireTimeouts(deadline);
+                    tick++;
                 }
-            } while (workerState.get() == WORKER_STATE_STARTED);
-        }
-
-        private void fetchExpiredTimeouts(
-                List<HashedWheelTimeout> expiredTimeouts, long deadline) {
+            } while (WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == WORKER_STATE_STARTED);
 
-            // Find the expired timeouts and decrease the round counter
-            // if necessary.  Note that we don't send the notification
-            // immediately to make sure the listeners are called without
-            // an exclusive lock.
-            lock.writeLock().lock();
-            try {
-                fetchExpiredTimeouts(expiredTimeouts, wheel[(int) (tick & mask)].iterator(), deadline);
-            } finally {
-                // Note that the tick is updated only while the writer lock is held,
-                // so that newTimeout() and consequently new HashedWheelTimeout() never see an old value
-                // while the reader lock is held.
-                tick ++;
-                lock.writeLock().unlock();
+            // Fill the unprocessedTimeouts so we can return them from stop() method.
+            for (HashedWheelBucket bucket: wheel) {
+                bucket.clearTimeouts(unprocessedTimeouts);
             }
-        }
-
-        private void fetchExpiredTimeouts(
-                List<HashedWheelTimeout> expiredTimeouts,
-                Iterator<HashedWheelTimeout> i, long deadline) {
-
-            while (i.hasNext()) {
-                HashedWheelTimeout timeout = i.next();
-                if (timeout.remainingRounds <= 0) {
-                    i.remove();
-                    if (timeout.deadline <= deadline) {
-                        expiredTimeouts.add(timeout);
-                    } else {
-                        // The timeout was placed into a wrong slot. This should never happen.
-                        throw new Error(String.format(
-                                "timeout.deadline (%d) > deadline (%d)", timeout.deadline, deadline));
-                    }
-                } else {
-                    timeout.remainingRounds --;
+            for (;;) {
+                HashedWheelTimeout timeout = timeouts.poll();
+                if (timeout == null) {
+                    break;
                 }
+                unprocessedTimeouts.add(timeout);
             }
         }
 
-        private void notifyExpiredTimeouts(
-                List<HashedWheelTimeout> expiredTimeouts) {
-            // Notify the expired timeouts.
-            for (int i = expiredTimeouts.size() - 1; i >= 0; i --) {
-                expiredTimeouts.get(i).expire();
-            }
+        private void transferTimeoutsToBuckets() {
+            // transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just
+            // adds new timeouts in a loop.
+            for (int i = 0; i < 100000; i++) {
+                HashedWheelTimeout timeout = timeouts.poll();
+                if (timeout == null) {
+                    // all processed
+                    break;
+                }
+                if (timeout.state() == HashedWheelTimeout.ST_CANCELLED
+                        || !timeout.compareAndSetState(HashedWheelTimeout.ST_INIT, HashedWheelTimeout.ST_IN_BUCKET)) {
+                    // Was cancelled in the meantime. So just remove it and continue with next HashedWheelTimeout
+                    // in the queue
+                    timeout.remove();
+                    continue;
+                }
+                long calculated = timeout.deadline / tickDuration;
+                timeout.remainingRounds = (calculated - tick) / wheel.length;
 
-            // Clean up the temporary list.
-            expiredTimeouts.clear();
-        }
+                final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past.
+                int stopIndex = (int) (ticks & mask);
 
+                HashedWheelBucket bucket = wheel[stopIndex];
+                bucket.addTimeout(timeout);
+            }
+        }
         /**
          * calculate goal nanoTime from startTime and current tick number,
          * then wait until that goal has been reached.
@@ -461,40 +437,65 @@ private long waitForNextTick() {
 
                 try {
                     Thread.sleep(sleepTimeMs);
-                } catch (InterruptedException e) {
-                    if (workerState.get() == WORKER_STATE_SHUTDOWN) {
+                } catch (InterruptedException ignored) {
+                    if (WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == WORKER_STATE_SHUTDOWN) {
                         return Long.MIN_VALUE;
                     }
                 }
             }
         }
+
+        public Set<Timeout> unprocessedTimeouts() {
+            return Collections.unmodifiableSet(unprocessedTimeouts);
+        }
     }
 
-    private final class HashedWheelTimeout implements Timeout {
+    private static final class HashedWheelTimeout extends MpscLinkedQueueNode<Timeout>
+            implements Timeout {
 
         private static final int ST_INIT = 0;
-        private static final int ST_CANCELLED = 1;
-        private static final int ST_EXPIRED = 2;
+        private static final int ST_IN_BUCKET = 1;
+        private static final int ST_CANCELLED = 2;
+        private static final int ST_EXPIRED = 3;
+        private static final AtomicIntegerFieldUpdater<HashedWheelTimeout> STATE_UPDATER;
+
+        static {
+            AtomicIntegerFieldUpdater<HashedWheelTimeout> updater =
+                    PlatformDependent.newAtomicIntegerFieldUpdater(HashedWheelTimeout.class, "state");
+            if (updater == null) {
+                updater = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, "state");
+            }
+            STATE_UPDATER = updater;
+        }
 
+        private final HashedWheelTimer timer;
         private final TimerTask task;
-        final long deadline;
-        final int stopIndex;
-        volatile long remainingRounds;
-        private final AtomicInteger state = new AtomicInteger(ST_INIT);
+        private final long deadline;
+
+        @SuppressWarnings({"unused", "FieldMayBeFinal", "RedundantFieldInitialization" })
+        private volatile int state = ST_INIT;
+
+        // remainingRounds will be calculated and set by Worker.transferTimeoutsToBuckets() before the
+        // HashedWheelTimeout will be added to the correct HashedWheelBucket.
+        long remainingRounds;
+
+        // This will be used to chain timeouts in HashedWheelTimerBucket via a double-linked-list.
+        // As only the workerThread will act on it there is no need for synchronization / volatile.
+        HashedWheelTimeout next;
+        HashedWheelTimeout prev;
 
-        HashedWheelTimeout(TimerTask task, long deadline) {
+        // The bucket to which the timeout was added
+        HashedWheelBucket bucket;
+
+        HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, long deadline) {
+            this.timer = timer;
             this.task = task;
             this.deadline = deadline;
-
-            long calculated = deadline / tickDuration;
-            final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past.
-            stopIndex = (int) (ticks & mask);
-            remainingRounds = (calculated - tick) / wheel.length;
         }
 
         @Override
         public Timer timer() {
-            return HashedWheelTimer.this;
+            return timer;
         }
 
         @Override
@@ -504,26 +505,60 @@ public TimerTask task() {
 
         @Override
         public boolean cancel() {
-            if (!state.compareAndSet(ST_INIT, ST_CANCELLED)) {
+            int state = state();
+            if (state >= ST_CANCELLED) {
+                // fail fast if the task was cancelled or expired before.
                 return false;
             }
-
-            wheel[stopIndex].remove(this);
+            if (state != ST_IN_BUCKET && compareAndSetState(ST_INIT, ST_CANCELLED)) {
+                // Was cancelled before the HashedWheelTimeout was added to its HashedWheelBucket.
+                // In this case we can just return here as it will be discarded by the WorkerThread when handling
+                // the adding of HashedWheelTimeout to the HashedWheelBuckets.
+                return true;
+            }
+            // only update the state it will be removed from HashedWheelBucket on next tick.
+            if (!compareAndSetState(ST_IN_BUCKET, ST_CANCELLED)) {
+                return false;
+            }
+            // Add the HashedWheelTimeout back to the timeouts queue so it will be picked up on the next tick
+            // and remove this HashedTimeTask from the HashedWheelBucket. After this is done it is ready to get
+            // GC'ed once the user has no reference to it anymore.
+            timer.timeouts.add(this);
             return true;
         }
 
+        public void remove() {
+            if (bucket != null) {
+                bucket.remove(this);
+            }
+        }
+
+        public boolean compareAndSetState(int expected, int state) {
+            return STATE_UPDATER.compareAndSet(this, expected, state);
+        }
+
+        public int state() {
+            return state;
+        }
+
         @Override
         public boolean isCancelled() {
-            return state.get() == ST_CANCELLED;
+            return state() == ST_CANCELLED;
         }
 
         @Override
         public boolean isExpired() {
-            return state.get() != ST_INIT;
+            return state() > ST_IN_BUCKET;
+        }
+
+        @Override
+        public HashedWheelTimeout value() {
+            return this;
         }
 
         public void expire() {
-            if (!state.compareAndSet(ST_INIT, ST_EXPIRED)) {
+            if (!compareAndSetState(ST_IN_BUCKET, ST_EXPIRED)) {
+                assert state() != ST_INIT;
                 return;
             }
 
@@ -539,7 +574,7 @@ public void expire() {
         @Override
         public String toString() {
             final long currentTime = System.nanoTime();
-            long remaining = deadline - currentTime + startTime;
+            long remaining = deadline - currentTime + timer.startTime;
 
             StringBuilder buf = new StringBuilder(192);
             buf.append(StringUtil.simpleClassName(this));
@@ -566,4 +601,127 @@ public String toString() {
             return buf.append(')').toString();
         }
     }
+
+    /**
+     * Bucket that stores HashedWheelTimeouts. These are stored in a linked-list like datastructure to allow easy
+     * removal of HashedWheelTimeouts in the middle. Also the HashedWheelTimeout act as nodes themself and so no
+     * extra object creation is needed.
+     */
+    private static final class HashedWheelBucket {
+
+        // Used for the linked-list datastructure
+        private HashedWheelTimeout head;
+        private HashedWheelTimeout tail;
+
+        /**
+         * Add {@link HashedWheelTimeout} to this bucket.
+         */
+        public void addTimeout(HashedWheelTimeout timeout) {
+            assert timeout.bucket == null;
+            timeout.bucket = this;
+            if (head == null) {
+                head = tail = timeout;
+            } else {
+                tail.next = timeout;
+                timeout.prev = tail;
+                tail = timeout;
+            }
+        }
+
+        /**
+         * Expire all {@link HashedWheelTimeout}s for the given {@code deadline}.
+         */
+        public void expireTimeouts(long deadline) {
+            HashedWheelTimeout timeout = head;
+
+            // process all timeouts
+            while (timeout != null) {
+                boolean remove = false;
+                if (timeout.remainingRounds <= 0) {
+                    if (timeout.deadline <= deadline) {
+                        timeout.expire();
+                    } else {
+                        // The timeout was placed into a wrong slot. This should never happen.
+                        throw new IllegalStateException(String.format(
+                                "timeout.deadline (%d) > deadline (%d)", timeout.deadline, deadline));
+                    }
+                    remove = true;
+                } else if (timeout.isCancelled()) {
+                    remove = true;
+                } else {
+                    timeout.remainingRounds --;
+                }
+                // store reference to next as we may null out timeout.next in the remove block.
+                HashedWheelTimeout next = timeout.next;
+                if (remove) {
+                    remove(timeout);
+                }
+                timeout = next;
+            }
+        }
+
+        public void remove(HashedWheelTimeout timeout) {
+            HashedWheelTimeout next = timeout.next;
+            // remove timeout that was either processed or cancelled by updating the linked-list
+            if (timeout.prev != null) {
+                timeout.prev.next = next;
+            }
+            if (timeout.next != null) {
+                timeout.next.prev = timeout.prev;
+            }
+
+            if (timeout == head) {
+                // if timeout is also the tail we need to adjust the entry too
+                if (timeout == tail) {
+                    tail = null;
+                    head = null;
+                } else {
+                    head = next;
+                }
+            } else if (timeout == tail) {
+                // if the timeout is the tail modify the tail to be the prev node.
+                tail = timeout.prev;
+            }
+            // null out prev, next and bucket to allow for GC.
+            timeout.prev = null;
+            timeout.next = null;
+            timeout.bucket = null;
+        }
+
+        /**
+         * Clear this bucket and return all not expired / cancelled {@link Timeout}s.
+         */
+        public void clearTimeouts(Set<Timeout> set) {
+            for (;;) {
+                HashedWheelTimeout timeout = pollTimeout();
+                if (timeout == null) {
+                    return;
+                }
+                if (timeout.isExpired() || timeout.isCancelled()) {
+                    continue;
+                }
+                set.add(timeout);
+            }
+        }
+
+        private HashedWheelTimeout pollTimeout() {
+            HashedWheelTimeout head = this.head;
+            if (head == null) {
+                return null;
+            }
+            HashedWheelTimeout next = head.next;
+            if (next == null) {
+                tail = this.head =  null;
+            } else {
+                this.head = next;
+                next.prev = null;
+            }
+
+            // null out prev and next to allow for GC.
+            head.next = null;
+            head.prev = null;
+            head.bucket = null;
+            return head;
+        }
+    }
 }
diff --git a/common/src/main/java/io/netty/util/NetUtil.java b/common/src/main/java/io/netty/util/NetUtil.java
index 0ae1922ac556..42cb89e94718 100644
--- a/common/src/main/java/io/netty/util/NetUtil.java
+++ b/common/src/main/java/io/netty/util/NetUtil.java
@@ -28,6 +28,7 @@
 import java.net.SocketException;
 import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.List;
 import java.util.StringTokenizer;
 
 /**
@@ -56,7 +57,7 @@ public final class NetUtil {
     public static final InetAddress LOCALHOST;
 
     /**
-     * The loopback {@link NetworkInterface} on the current machine
+     * The loopback {@link NetworkInterface} of the current machine
      */
     public static final NetworkInterface LOOPBACK_IF;
 
@@ -72,48 +73,13 @@ public final class NetUtil {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NetUtil.class);
 
     static {
-        // Find the first loopback interface available.
-        NetworkInterface loopbackIface = null;
-        try {
-            for (Enumeration<NetworkInterface> ifaces = NetworkInterface.getNetworkInterfaces();
-                 ifaces.hasMoreElements();) {
-
-                NetworkInterface iface = ifaces.nextElement();
-                if (iface.isLoopback()) {
-                    // Found
-                    loopbackIface = iface;
-                    break;
-                }
-            }
-            if (loopbackIface == null) {
-                logger.warn("Failed to find the loopback interface");
-            }
-        } catch (SocketException e) {
-            logger.warn("Failed to find the loopback interface", e);
-        }
-
-        LOOPBACK_IF = loopbackIface;
-
-        // Find the localhost address
-        InetAddress localhost = null;
-        if (LOOPBACK_IF != null) {
-            logger.debug("Loopback interface: {}", LOOPBACK_IF.getDisplayName());
-            for (Enumeration<InetAddress> addrs = LOOPBACK_IF.getInetAddresses();
-                 addrs.hasMoreElements();) {
-                InetAddress a = addrs.nextElement();
-                if (localhost == null) {
-                    logger.debug("Loopback address: {} (primary)", a);
-                    localhost = a;
-                } else {
-                    logger.debug("Loopback address: {}", a);
-                }
-            }
-        }
+        byte[] LOCALHOST4_BYTES = {127, 0, 0, 1};
+        byte[] LOCALHOST6_BYTES = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
 
         // Create IPv4 loopback address.
         Inet4Address localhost4 = null;
         try {
-            localhost4 = (Inet4Address) InetAddress.getByAddress(new byte[]{127, 0, 0, 1});
+            localhost4 = (Inet4Address) InetAddress.getByAddress(LOCALHOST4_BYTES);
         } catch (Exception e) {
             // We should not get here as long as the length of the address is correct.
             PlatformDependent.throwException(e);
@@ -123,33 +89,96 @@ public final class NetUtil {
         // Create IPv6 loopback address.
         Inet6Address localhost6 = null;
         try {
-            localhost6 = (Inet6Address) InetAddress.getByAddress(
-                    new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});
+            localhost6 = (Inet6Address) InetAddress.getByAddress(LOCALHOST6_BYTES);
         } catch (Exception e) {
             // We should not get here as long as the length of the address is correct.
             PlatformDependent.throwException(e);
         }
         LOCALHOST6 = localhost6;
 
-        // Try to determine the default loopback address if we couldn't yet.
-        if (localhost == null) {
+        // Retrieve the list of available network interfaces.
+        List<NetworkInterface> ifaces = new ArrayList<NetworkInterface>();
+        try {
+            for (Enumeration<NetworkInterface> i = NetworkInterface.getNetworkInterfaces(); i.hasMoreElements();) {
+                NetworkInterface iface = i.nextElement();
+                // Use the interface with proper INET addresses only.
+                if (iface.getInetAddresses().hasMoreElements()) {
+                    ifaces.add(iface);
+                }
+            }
+        } catch (SocketException e) {
+            logger.warn("Failed to retrieve the list of available network interfaces", e);
+        }
+
+        // Find the first loopback interface available from its INET address (127.0.0.1 or ::1)
+        // Note that we do not use NetworkInterface.isLoopback() in the first place because it takes long time
+        // on a certain environment. (e.g. Windows with -Djava.net.preferIPv4Stack=true)
+        NetworkInterface loopbackIface = null;
+        InetAddress loopbackAddr = null;
+        loop: for (NetworkInterface iface: ifaces) {
+            for (Enumeration<InetAddress> i = iface.getInetAddresses(); i.hasMoreElements();) {
+                InetAddress addr = i.nextElement();
+                if (addr.isLoopbackAddress()) {
+                    // Found
+                    loopbackIface = iface;
+                    loopbackAddr = addr;
+                    break loop;
+                }
+            }
+        }
+
+        // If failed to find the loopback interface from its INET address, fall back to isLoopback().
+        if (loopbackIface == null) {
             try {
-                if (NetworkInterface.getByInetAddress(LOCALHOST6) != null) {
-                    logger.debug("Using hard-coded IPv6 localhost address: {}", localhost6);
-                    localhost = localhost6;
+                for (NetworkInterface iface: ifaces) {
+                    if (iface.isLoopback()) {
+                        Enumeration<InetAddress> i = iface.getInetAddresses();
+                        if (i.hasMoreElements()) {
+                            // Found the one with INET address.
+                            loopbackIface = iface;
+                            loopbackAddr = i.nextElement();
+                            break;
+                        }
+                    }
                 }
-            } catch (Exception e) {
-                // Ignore
-            } finally {
-                if (localhost == null) {
-                    logger.debug("Using hard-coded IPv4 localhost address: {}", localhost4);
-                    localhost = localhost4;
+
+                if (loopbackIface == null) {
+                    logger.warn("Failed to find the loopback interface");
+                }
+            } catch (SocketException e) {
+                logger.warn("Failed to find the loopback interface", e);
+            }
+        }
+
+        if (loopbackIface != null) {
+            // Found the loopback interface with an INET address.
+            logger.debug(
+                    "Loopback interface: {} ({}, {})",
+                    loopbackIface.getName(), loopbackIface.getDisplayName(), loopbackAddr.getHostAddress());
+        } else {
+            // Could not find the loopback interface, but we can't leave LOCALHOST as null.
+            // Use LOCALHOST6 or LOCALHOST4, preferably the IPv6 one.
+            if (loopbackAddr == null) {
+                try {
+                    if (NetworkInterface.getByInetAddress(LOCALHOST6) != null) {
+                        logger.debug("Using hard-coded IPv6 localhost address: {}", localhost6);
+                        loopbackAddr = localhost6;
+                    }
+                } catch (Exception e) {
+                    // Ignore
+                } finally {
+                    if (loopbackAddr == null) {
+                        logger.debug("Using hard-coded IPv4 localhost address: {}", localhost4);
+                        loopbackAddr = localhost4;
+                    }
                 }
             }
         }
 
-        LOCALHOST = localhost;
+        LOOPBACK_IF = loopbackIface;
+        LOCALHOST = loopbackAddr;
 
+        // Determine the default somaxconn (server socket backlog) value of the platform.
         int somaxconn = 3072;
         BufferedReader in = null;
         try {
@@ -446,7 +475,9 @@ public static boolean isValidIpV6Address(String ipAddress) {
                         return false;
                     }
                     try {
-                        Integer.parseInt(ipAddress.substring(i + 1));
+                        if (Integer.parseInt(ipAddress.substring(i + 1)) < 0) {
+                            return false;
+                        }
                     } catch (NumberFormatException e) {
                         // right now we just support an integer after the % so if
                         // this is not
@@ -506,10 +537,7 @@ public static boolean isValidIp4Word(String word) {
                 return false;
             }
         }
-        if (Integer.parseInt(word) > 255) {
-            return false;
-        }
-        return true;
+        return Integer.parseInt(word) <= 255;
     }
 
     static boolean isValidHexChar(char c) {
@@ -560,10 +588,8 @@ public static boolean isValidIpV4Address(String value) {
         if (word.length() == 0 || Integer.parseInt(word.toString()) > 255) {
             return false;
         }
-        if (periods != 3) {
-            return false;
-        }
-        return true;
+
+        return periods == 3;
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index c162da01864a..a1a4c6ceda75 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -16,8 +16,16 @@
 
 package io.netty.util;
 
-import java.util.IdentityHashMap;
+import io.netty.util.concurrent.FastThreadLocal;
+import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
 import java.util.Map;
+import java.util.WeakHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Light-weight object pool based on a thread-local stack.
@@ -26,90 +34,325 @@
  */
 public abstract class Recycler<T> {
 
-    private final ThreadLocal<Stack<T>> threadLocal = new ThreadLocal<Stack<T>>() {
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(Recycler.class);
+
+    private static final AtomicInteger ID_GENERATOR = new AtomicInteger(Integer.MIN_VALUE);
+    private static final int OWN_THREAD_ID = ID_GENERATOR.getAndIncrement();
+    private static final int DEFAULT_MAX_CAPACITY;
+    private static final int INITIAL_CAPACITY;
+
+    static {
+        // In the future, we might have different maxCapacity for different object types.
+        // e.g. io.netty.recycler.maxCapacity.writeTask
+        //      io.netty.recycler.maxCapacity.outboundBuffer
+        int maxCapacity = SystemPropertyUtil.getInt("io.netty.recycler.maxCapacity", 0);
+        if (maxCapacity <= 0) {
+            // TODO: Some arbitrary large number - should adjust as we get more production experience.
+            maxCapacity = 262144;
+        }
+
+        DEFAULT_MAX_CAPACITY = maxCapacity;
+        if (logger.isDebugEnabled()) {
+            logger.debug("-Dio.netty.recycler.maxCapacity: {}", DEFAULT_MAX_CAPACITY);
+        }
+
+        INITIAL_CAPACITY = Math.min(DEFAULT_MAX_CAPACITY, 256);
+    }
+
+    private final int maxCapacity;
+    private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {
         @Override
         protected Stack<T> initialValue() {
-            return new Stack<T>(Recycler.this, Thread.currentThread());
+            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacity);
         }
     };
 
+    protected Recycler() {
+        this(DEFAULT_MAX_CAPACITY);
+    }
+
+    protected Recycler(int maxCapacity) {
+        this.maxCapacity = Math.max(0, maxCapacity);
+    }
+
+    @SuppressWarnings("unchecked")
     public final T get() {
         Stack<T> stack = threadLocal.get();
-        T o = stack.pop();
-        if (o == null) {
-            o = newObject(stack);
+        DefaultHandle<T> handle = stack.pop();
+        if (handle == null) {
+            handle = stack.newHandle();
+            handle.value = newObject(handle);
         }
-        return o;
+        return (T) handle.value;
     }
 
-    public final boolean recycle(T o, Handle handle) {
-        @SuppressWarnings("unchecked")
-        Stack<T> stack = (Stack<T>) handle;
-        if (stack.parent != this) {
+    public final boolean recycle(T o, Handle<T> handle) {
+        DefaultHandle<T> h = (DefaultHandle<T>) handle;
+        if (h.stack.parent != this) {
             return false;
         }
 
-        if (Thread.currentThread() != stack.thread) {
-            return false;
+        h.recycle(o);
+        return true;
+    }
+
+    protected abstract T newObject(Handle<T> handle);
+
+    public interface Handle<T> {
+        void recycle(T object);
+    }
+
+    static final class DefaultHandle<T> implements Handle<T> {
+        private int lastRecycledId;
+        private int recycleId;
+
+        private Stack<?> stack;
+        private Object value;
+
+        DefaultHandle(Stack<?> stack) {
+            this.stack = stack;
         }
 
-        stack.push(o);
-        return true;
+        @Override
+        public void recycle(Object object) {
+            if (object != value) {
+                throw new IllegalArgumentException("object does not belong to handle");
+            }
+            Thread thread = Thread.currentThread();
+            if (thread == stack.thread) {
+                stack.push(this);
+                return;
+            }
+            // we don't want to have a ref to the queue as the value in our weak map
+            // so we null it out; to ensure there are no races with restoring it later
+            // we impose a memory ordering here (no-op on x86)
+            Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();
+            WeakOrderQueue queue = delayedRecycled.get(stack);
+            if (queue == null) {
+                delayedRecycled.put(stack, queue = new WeakOrderQueue(stack, thread));
+            }
+            queue.add(this);
+        }
     }
 
-    protected abstract T newObject(Handle handle);
+    private static final FastThreadLocal<Map<Stack<?>, WeakOrderQueue>> DELAYED_RECYCLED =
+            new FastThreadLocal<Map<Stack<?>, WeakOrderQueue>>() {
+        @Override
+        protected Map<Stack<?>, WeakOrderQueue> initialValue() {
+            return new WeakHashMap<Stack<?>, WeakOrderQueue>();
+        }
+    };
+
+    // a queue that makes only moderate guarantees about visibility: items are seen in the correct order,
+    // but we aren't absolutely guaranteed to ever see anything at all, thereby keeping the queue cheap to maintain
+    private static final class WeakOrderQueue {
+        private static final int LINK_CAPACITY = 16;
 
-    public interface Handle { }
+        // Let Link extend AtomicInteger for intrinsics. The Link itself will be used as writerIndex.
+        @SuppressWarnings("serial")
+        private static final class Link extends AtomicInteger {
+            private final DefaultHandle<?>[] elements = new DefaultHandle[LINK_CAPACITY];
 
-    static final class Stack<T> implements Handle {
+            private int readIndex;
+            private Link next;
+        }
 
-        private static final int INITIAL_CAPACITY = 256;
+        // chain of data items
+        private Link head, tail;
+        // pointer to another queue of delayed items for the same stack
+        private WeakOrderQueue next;
+        private final WeakReference<Thread> owner;
+        private final int id = ID_GENERATOR.getAndIncrement();
 
+        WeakOrderQueue(Stack<?> stack, Thread thread) {
+            head = tail = new Link();
+            owner = new WeakReference<Thread>(thread);
+            synchronized (stack) {
+                next = stack.head;
+                stack.head = this;
+            }
+        }
+
+        void add(DefaultHandle<?> handle) {
+            handle.lastRecycledId = id;
+
+            Link tail = this.tail;
+            int writeIndex;
+            if ((writeIndex = tail.get()) == LINK_CAPACITY) {
+                this.tail = tail = tail.next = new Link();
+                writeIndex = tail.get();
+            }
+            tail.elements[writeIndex] = handle;
+            handle.stack = null;
+            // we lazy set to ensure that setting stack to null appears before we unnull it in the owning thread;
+            // this also means we guarantee visibility of an element in the queue if we see the index updated
+            tail.lazySet(writeIndex + 1);
+        }
+
+        boolean hasFinalData() {
+            return tail.readIndex != tail.get();
+        }
+
+        // transfer as many items as we can from this queue to the stack, returning true if any were transferred
+        @SuppressWarnings("rawtypes")
+        boolean transfer(Stack<?> to) {
+
+            Link head = this.head;
+            if (head == null) {
+                return false;
+            }
+
+            if (head.readIndex == LINK_CAPACITY) {
+                if (head.next == null) {
+                    return false;
+                }
+                this.head = head = head.next;
+            }
+
+            int start = head.readIndex;
+            int end = head.get();
+            if (start == end) {
+                return false;
+            }
+
+            int count = end - start;
+            if (to.size + count > to.elements.length) {
+                to.elements = Arrays.copyOf(to.elements, (to.size + count) * 2);
+            }
+
+            DefaultHandle[] src = head.elements;
+            DefaultHandle[] trg = to.elements;
+            int size = to.size;
+            while (start < end) {
+                DefaultHandle element = src[start];
+                if (element.recycleId == 0) {
+                    element.recycleId = element.lastRecycledId;
+                } else if (element.recycleId != element.lastRecycledId) {
+                    throw new IllegalStateException("recycled already");
+                }
+                element.stack = to;
+                trg[size++] = element;
+                src[start++] = null;
+            }
+            to.size = size;
+
+            if (end == LINK_CAPACITY & head.next != null) {
+                this.head = head.next;
+            }
+
+            head.readIndex = end;
+            return true;
+        }
+    }
+
+    static final class Stack<T> {
+
+        // we keep a queue of per-thread queues, which is appended to once only, each time a new thread other
+        // than the stack owner recycles: when we run out of items in our stack we iterate this collection
+        // to scavenge those that can be reused. this permits us to incur minimal thread synchronisation whilst
+        // still recycling all items.
         final Recycler<T> parent;
         final Thread thread;
-        private T[] elements;
+        private DefaultHandle<?>[] elements;
+        private final int maxCapacity;
         private int size;
-        private final Map<T, Boolean> map = new IdentityHashMap<T, Boolean>(INITIAL_CAPACITY);
 
-        @SuppressWarnings({ "unchecked", "SuspiciousArrayCast" })
-        Stack(Recycler<T> parent, Thread thread) {
+        private volatile WeakOrderQueue head;
+        private WeakOrderQueue cursor, prev;
+
+        Stack(Recycler<T> parent, Thread thread, int maxCapacity) {
             this.parent = parent;
             this.thread = thread;
-            elements = newArray(INITIAL_CAPACITY);
+            this.maxCapacity = maxCapacity;
+            elements = new DefaultHandle[INITIAL_CAPACITY];
         }
 
-        T pop() {
+        @SuppressWarnings({ "unchecked", "rawtypes" })
+        DefaultHandle<T> pop() {
             int size = this.size;
             if (size == 0) {
-                return null;
+                if (!scavenge()) {
+                    return null;
+                }
+                size = this.size;
             }
             size --;
-            T ret = elements[size];
-            elements[size] = null;
-            map.remove(ret);
+            DefaultHandle ret = elements[size];
+            if (ret.lastRecycledId != ret.recycleId) {
+                throw new IllegalStateException("recycled multiple times");
+            }
+            ret.recycleId = 0;
+            ret.lastRecycledId = 0;
             this.size = size;
             return ret;
         }
 
-        void push(T o) {
-            if (map.put(o, Boolean.TRUE) != null) {
+        boolean scavenge() {
+            // continue an existing scavenge, if any
+            if (scavengeSome()) {
+                return true;
+            }
+
+            // reset our scavenge cursor
+            prev = null;
+            cursor = head;
+            return false;
+        }
+
+        boolean scavengeSome() {
+            boolean success = false;
+            WeakOrderQueue cursor = this.cursor, prev = this.prev;
+            while (cursor != null) {
+                if (cursor.transfer(this)) {
+                    success = true;
+                    break;
+                }
+                WeakOrderQueue next = cursor.next;
+                if (cursor.owner.get() == null) {
+                    // if the thread associated with the queue is gone, unlink it, after
+                    // performing a volatile read to confirm there is no data left to collect
+                    // we never unlink the first queue, as we don't want to synchronize on updating the head
+                    if (cursor.hasFinalData()) {
+                        for (;;) {
+                            if (!cursor.transfer(this)) {
+                                break;
+                            }
+                        }
+                    }
+                    if (prev != null) {
+                        prev.next = next;
+                    }
+                } else {
+                    prev = cursor;
+                }
+                cursor = next;
+            }
+            this.prev = prev;
+            this.cursor = cursor;
+            return success;
+        }
+
+        void push(DefaultHandle<?> item) {
+            if ((item.recycleId | item.lastRecycledId) != 0) {
                 throw new IllegalStateException("recycled already");
             }
+            item.recycleId = item.lastRecycledId = OWN_THREAD_ID;
 
             int size = this.size;
             if (size == elements.length) {
-                T[] newElements = newArray(size << 1);
-                System.arraycopy(elements, 0, newElements, 0, size);
-                elements = newElements;
+                if (size == maxCapacity) {
+                    // Hit the maximum capacity - drop the possibly youngest object.
+                    return;
+                }
+                elements = Arrays.copyOf(elements, size << 1);
             }
 
-            elements[size] = o;
+            elements[size] = item;
             this.size = size + 1;
         }
 
-        @SuppressWarnings({ "unchecked", "SuspiciousArrayCast" })
-        private static <T> T[] newArray(int length) {
-            return (T[]) new Object[length];
+        DefaultHandle<T> newHandle() {
+            return new DefaultHandle<T>(this);
         }
     }
 }
diff --git a/common/src/main/java/io/netty/util/ReferenceCountUtil.java b/common/src/main/java/io/netty/util/ReferenceCountUtil.java
index f48e99627ade..c22a05671789 100644
--- a/common/src/main/java/io/netty/util/ReferenceCountUtil.java
+++ b/common/src/main/java/io/netty/util/ReferenceCountUtil.java
@@ -15,19 +15,10 @@
  */
 package io.netty.util;
 
-import io.netty.util.concurrent.GlobalEventExecutor;
-import io.netty.util.concurrent.ScheduledFuture;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.util.ArrayList;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-
 /**
  * Collection of method to handle objects that may implement {@link ReferenceCounted}.
  */
@@ -59,6 +50,31 @@ public static <T> T retain(T msg, int increment) {
         return msg;
     }
 
+    /**
+     * Tries to call {@link ReferenceCounted#touch()} if the specified message implements {@link ReferenceCounted}.
+     * If the specified message doesn't implement {@link ReferenceCounted}, this method does nothing.
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> T touch(T msg) {
+        if (msg instanceof ReferenceCounted) {
+            return (T) ((ReferenceCounted) msg).touch();
+        }
+        return msg;
+    }
+
+    /**
+     * Tries to call {@link ReferenceCounted#touch(Object)} if the specified message implements
+     * {@link ReferenceCounted}.  If the specified message doesn't implement {@link ReferenceCounted},
+     * this method does nothing.
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> T touch(T msg, Object hint) {
+        if (msg instanceof ReferenceCounted) {
+            return (T) ((ReferenceCounted) msg).touch(hint);
+        }
+        return msg;
+    }
+
     /**
      * Try to call {@link ReferenceCounted#release()} if the specified message implements {@link ReferenceCounted}.
      * If the specified message doesn't implement {@link ReferenceCounted}, this method does nothing.
@@ -81,8 +97,6 @@ public static boolean release(Object msg, int decrement) {
         return false;
     }
 
-    private static final Map<Thread, List<Entry>> pendingReleases = new IdentityHashMap<Thread, List<Entry>>();
-
     /**
      * Schedules the specified object to be released when the caller thread terminates. Note that this operation is
      * intended to simplify reference counting of ephemeral objects during unit tests. Do not use it beyond the
@@ -99,82 +113,40 @@ public static <T> T releaseLater(T msg) {
      */
     public static <T> T releaseLater(T msg, int decrement) {
         if (msg instanceof ReferenceCounted) {
-            synchronized (pendingReleases) {
-                Thread thread = Thread.currentThread();
-                List<Entry> entries = pendingReleases.get(thread);
-                if (entries == null) {
-                    // Start the periodic releasing task (if not started yet.)
-                    if (pendingReleases.isEmpty()) {
-                        ReleasingTask task = new ReleasingTask();
-                        task.future = GlobalEventExecutor.INSTANCE.scheduleWithFixedDelay(task, 1, 1, TimeUnit.SECONDS);
-                    }
-
-                    // Create a new entry.
-                    entries = new ArrayList<Entry>();
-                    pendingReleases.put(thread, entries);
-                }
-
-                entries.add(new Entry((ReferenceCounted) msg, decrement));
-            }
+            ThreadDeathWatcher.watch(Thread.currentThread(), new ReleasingTask((ReferenceCounted) msg, decrement));
         }
         return msg;
     }
 
-    private static final class Entry {
-        final ReferenceCounted obj;
-        final int decrement;
-
-        Entry(ReferenceCounted obj, int decrement) {
-            this.obj = obj;
-            this.decrement = decrement;
-        }
-
-        public String toString() {
-            return StringUtil.simpleClassName(obj) + ".release(" + decrement + ") refCnt: " + obj.refCnt();
-        }
-    }
-
     /**
      * Releases the objects when the thread that called {@link #releaseLater(Object)} has been terminated.
      */
     private static final class ReleasingTask implements Runnable {
-        volatile ScheduledFuture<?> future;
-
-        @Override
-        public void run() {
-            synchronized (pendingReleases) {
-                for (Iterator<Map.Entry<Thread, List<Entry>>> i = pendingReleases.entrySet().iterator();
-                     i.hasNext();) {
-
-                    Map.Entry<Thread, List<Entry>> e = i.next();
-                    if (e.getKey().isAlive()) {
-                        continue;
-                    }
 
-                    releaseAll(e.getValue());
+        private final ReferenceCounted obj;
+        private final int decrement;
 
-                    // Remove from the map since the thread is not alive anymore.
-                    i.remove();
-                }
+        ReleasingTask(ReferenceCounted obj, int decrement) {
+            this.obj = obj;
+            this.decrement = decrement;
+        }
 
-                if (pendingReleases.isEmpty()) {
-                    future.cancel(false);
+        @Override
+        public void run() {
+            try {
+                if (!obj.release(decrement)) {
+                    logger.warn("Non-zero refCnt: {}", this);
+                } else {
+                    logger.debug("Released: {}", this);
                 }
+            } catch (Exception ex) {
+                logger.warn("Failed to release an object: {}", obj, ex);
             }
         }
 
-        private static void releaseAll(Iterable<Entry> entries) {
-            for (Entry e: entries) {
-                try {
-                    if (!e.obj.release(e.decrement)) {
-                        logger.warn("Non-zero refCnt: {}", e);
-                    } else {
-                        logger.warn("Released: {}", e);
-                    }
-                } catch (Exception ex) {
-                    logger.warn("Failed to release an object: {}", e.obj, ex);
-                }
-            }
+        @Override
+        public String toString() {
+            return StringUtil.simpleClassName(obj) + ".release(" + decrement + ") refCnt: " + obj.refCnt();
         }
     }
 
diff --git a/common/src/main/java/io/netty/util/ReferenceCounted.java b/common/src/main/java/io/netty/util/ReferenceCounted.java
index ffd20aba3b65..7de7b5bef67c 100644
--- a/common/src/main/java/io/netty/util/ReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/ReferenceCounted.java
@@ -45,6 +45,20 @@ public interface ReferenceCounted {
      */
     ReferenceCounted retain(int increment);
 
+    /**
+     * Records the current access location of this object for debugging purposes.
+     * If this object is determined to be leaked, the information recorded by this operation will be provided to you
+     * via {@link ResourceLeakDetector}.  This method is a shortcut to {@link #touch(Object) touch(null)}.
+     */
+    ReferenceCounted touch();
+
+    /**
+     * Records the current access location of this object with an additonal arbitrary information for debugging
+     * purposes.  If this object is determined to be leaked, the information recorded by this operation will be
+     * provided to you via {@link ResourceLeakDetector}.
+     */
+    ReferenceCounted touch(Object hint);
+
     /**
      * Decreases the reference count by {@code 1} and deallocates this object if the reference count reaches at
      * {@code 0}.
diff --git a/common/src/main/java/io/netty/util/ResourceLeak.java b/common/src/main/java/io/netty/util/ResourceLeak.java
index d45fc71f28b2..e3b10bd128c6 100644
--- a/common/src/main/java/io/netty/util/ResourceLeak.java
+++ b/common/src/main/java/io/netty/util/ResourceLeak.java
@@ -19,10 +19,16 @@
 public interface ResourceLeak {
     /**
      * Records the caller's current stack trace so that the {@link ResourceLeakDetector} can tell where the leaked
-     * resource was accessed lastly.
+     * resource was accessed lastly. This method is a shortcut to {@link #record(Object) record(null)}.
      */
     void record();
 
+    /**
+     * Records the caller's current stack trace and the specified additional arbitrary information
+     * so that the {@link ResourceLeakDetector} can tell where the leaked resource was accessed lastly.
+     */
+    void record(Object hint);
+
     /**
      * Close the leak so that {@link ResourceLeakDetector} does not warn about leaked resources.
      *
diff --git a/common/src/main/java/io/netty/util/ResourceLeakDetector.java b/common/src/main/java/io/netty/util/ResourceLeakDetector.java
index 51a199b3830b..e1d771b1e3c6 100644
--- a/common/src/main/java/io/netty/util/ResourceLeakDetector.java
+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java
@@ -265,7 +265,7 @@ private final class DefaultResourceLeak extends PhantomReference<Object> impleme
             if (referent != null) {
                 Level level = getLevel();
                 if (level.ordinal() >= Level.ADVANCED.ordinal()) {
-                    creationRecord = newRecord(3);
+                    creationRecord = newRecord(null, 3);
                 } else {
                     creationRecord = null;
                 }
@@ -287,8 +287,17 @@ private final class DefaultResourceLeak extends PhantomReference<Object> impleme
 
         @Override
         public void record() {
+            record0(null, 3);
+        }
+
+        @Override
+        public void record(Object hint) {
+            record0(hint, 3);
+        }
+
+        private void record0(Object hint, int recordsToSkip) {
             if (creationRecord != null) {
-                String value = newRecord(2);
+                String value = newRecord(hint, recordsToSkip);
 
                 synchronized (lastRecords) {
                     int size = lastRecords.size();
@@ -353,11 +362,27 @@ public String toString() {
     }
 
     private static final String[] STACK_TRACE_ELEMENT_EXCLUSIONS = {
+            "io.netty.util.ReferenceCountUtil.touch(",
+            "io.netty.buffer.AdvancedLeakAwareByteBuf.touch(",
             "io.netty.buffer.AbstractByteBufAllocator.toLeakAwareBuffer(",
     };
 
-    static String newRecord(int recordsToSkip) {
+    static String newRecord(Object hint, int recordsToSkip) {
         StringBuilder buf = new StringBuilder(4096);
+
+        // Append the hint first if available.
+        if (hint != null) {
+            buf.append("\tHint: ");
+            // Prefer a hint string to a simple string form.
+            if (hint instanceof ResourceLeakHint) {
+                buf.append(((ResourceLeakHint) hint).toHintString());
+            } else {
+                buf.append(hint);
+            }
+            buf.append(NEWLINE);
+        }
+
+        // Append the stack trace.
         StackTraceElement[] array = new Throwable().getStackTrace();
         for (StackTraceElement e: array) {
             if (recordsToSkip > 0) {
diff --git a/common/src/main/java/io/netty/util/ResourceLeakHint.java b/common/src/main/java/io/netty/util/ResourceLeakHint.java
new file mode 100644
index 000000000000..f25d1296f9c2
--- /dev/null
+++ b/common/src/main/java/io/netty/util/ResourceLeakHint.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util;
+
+/**
+ * A hint object that provides human-readable message for easier resource leak tracking.
+ */
+public interface ResourceLeakHint {
+    /**
+     * Returns a human-readable message that potentially enables easier resource leak tracking.
+     */
+    String toHintString();
+}
diff --git a/common/src/main/java/io/netty/util/Signal.java b/common/src/main/java/io/netty/util/Signal.java
index af9cba81942c..320c1d6e7bed 100644
--- a/common/src/main/java/io/netty/util/Signal.java
+++ b/common/src/main/java/io/netty/util/Signal.java
@@ -16,38 +16,44 @@
 package io.netty.util;
 
 
-import io.netty.util.internal.PlatformDependent;
-
-import java.util.concurrent.ConcurrentMap;
-
 /**
  * A special {@link Error} which is used to signal some state or request by throwing it.
  * {@link Signal} has an empty stack trace and has no cause to save the instantiation overhead.
  */
-public final class Signal extends Error {
+public final class Signal extends Error implements Constant<Signal> {
 
     private static final long serialVersionUID = -221145131122459977L;
 
-    private static final ConcurrentMap<String, Boolean> map = PlatformDependent.newConcurrentHashMap();
-
-    @SuppressWarnings("deprecation")
-    private final UniqueName uname;
+    private static final ConstantPool<Signal> pool = new ConstantPool<Signal>() {
+        @Override
+        protected Signal newConstant(int id, String name) {
+            return new Signal(id, name);
+        }
+    };
 
     /**
-     * Creates a new {@link Signal} with the specified {@code name}.
+     * Returns the {@link Signal} of the specified name.
      */
-    @SuppressWarnings("deprecation")
     public static Signal valueOf(String name) {
-        return new Signal(name);
+        return pool.valueOf(name);
     }
 
     /**
-     * @deprecated Use {@link #valueOf(String)} instead.
+     * Shortcut of {@link #valueOf(String) valueOf(firstNameComponent.getName() + "#" + secondNameComponent)}.
      */
-    @Deprecated
-    public Signal(String name) {
-        super(name);
-        uname = new UniqueName(map, name);
+    public static Signal valueOf(Class<?> firstNameComponent, String secondNameComponent) {
+        return pool.valueOf(firstNameComponent, secondNameComponent);
+    }
+
+    private final int id;
+    private final String name;
+
+    /**
+     * Creates a new {@link Signal} with the specified {@code name}.
+     */
+    private Signal(int id, String name) {
+        this.id = id;
+        this.name = name;
     }
 
     /**
@@ -70,8 +76,42 @@ public Throwable fillInStackTrace() {
         return this;
     }
 
+    @Override
+    public int id() {
+        return id;
+    }
+
+    @Override
+    public String name() {
+        return name;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return this == obj;
+    }
+
+    @Override
+    public int hashCode() {
+        return System.identityHashCode(this);
+    }
+
+    @Override
+    public int compareTo(Signal other) {
+        if (this == other) {
+            return 0;
+        }
+
+        int returnCode = name.compareTo(other.name());
+        if (returnCode != 0) {
+            return returnCode;
+        }
+
+        return ((Integer) id).compareTo(other.id());
+    }
+
     @Override
     public String toString() {
-        return uname.name();
+        return name();
     }
 }
diff --git a/common/src/main/java/io/netty/util/ThreadDeathWatcher.java b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java
new file mode 100644
index 000000000000..2e580245f61f
--- /dev/null
+++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util;
+
+import io.netty.util.concurrent.DefaultThreadFactory;
+import io.netty.util.internal.MpscLinkedQueueNode;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/**
+ * Checks if a thread is alive periodically and runs a task when a thread dies.
+ * <p>
+ * This thread starts a daemon thread to check the state of the threads being watched and to invoke their
+ * associated {@link Runnable}s.  When there is no thread to watch (i.e. all threads are dead), the daemon thread
+ * will terminate itself, and a new daemon thread will be started again when a new watch is added.
+ * </p>
+ */
+public final class ThreadDeathWatcher {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(ThreadDeathWatcher.class);
+    private static final ThreadFactory threadFactory =
+            new DefaultThreadFactory(ThreadDeathWatcher.class, true, Thread.MIN_PRIORITY);
+
+    private static final Queue<Entry> pendingEntries = PlatformDependent.newMpscQueue();
+    private static final Watcher watcher = new Watcher();
+    private static final AtomicBoolean started = new AtomicBoolean();
+    private static volatile Thread watcherThread;
+
+    /**
+     * Schedules the specified {@code task} to run when the specified {@code thread} dies.
+     *
+     * @param thread the {@link Thread} to watch
+     * @param task the {@link Runnable} to run when the {@code thread} dies
+     *
+     * @throws IllegalArgumentException if the specified {@code thread} is not alive
+     */
+    public static void watch(Thread thread, Runnable task) {
+        if (thread == null) {
+            throw new NullPointerException("thread");
+        }
+        if (task == null) {
+            throw new NullPointerException("task");
+        }
+        if (!thread.isAlive()) {
+            throw new IllegalArgumentException("thread must be alive.");
+        }
+
+        schedule(thread, task, true);
+    }
+
+    /**
+     * Cancels the task scheduled via {@link #watch(Thread, Runnable)}.
+     */
+    public static void unwatch(Thread thread, Runnable task) {
+        if (thread == null) {
+            throw new NullPointerException("thread");
+        }
+        if (task == null) {
+            throw new NullPointerException("task");
+        }
+
+        schedule(thread, task, false);
+    }
+
+    private static void schedule(Thread thread, Runnable task, boolean isWatch) {
+        pendingEntries.add(new Entry(thread, task, isWatch));
+
+        if (started.compareAndSet(false, true)) {
+            Thread watcherThread = threadFactory.newThread(watcher);
+            watcherThread.start();
+            ThreadDeathWatcher.watcherThread = watcherThread;
+        }
+    }
+
+    /**
+     * Waits until the thread of this watcher has no threads to watch and terminates itself.
+     * Because a new watcher thread will be started again on {@link #watch(Thread, Runnable)},
+     * this operation is only useful when you want to ensure that the watcher thread is terminated
+     * <strong>after</strong> your application is shut down and there's no chance of calling
+     * {@link #watch(Thread, Runnable)} afterwards.
+     *
+     * @return {@code true} if and only if the watcher thread has been terminated
+     */
+    public static boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
+        if (unit == null) {
+            throw new NullPointerException("unit");
+        }
+
+        Thread watcherThread = ThreadDeathWatcher.watcherThread;
+        if (watcherThread != null) {
+            watcherThread.join(unit.toMillis(timeout));
+            return !watcherThread.isAlive();
+        } else {
+            return true;
+        }
+    }
+
+    private ThreadDeathWatcher() { }
+
+    private static final class Watcher implements Runnable {
+
+        private final List<Entry> watchees = new ArrayList<Entry>();
+
+        @Override
+        public void run() {
+            for (;;) {
+                fetchWatchees();
+                notifyWatchees();
+
+                // Try once again just in case notifyWatchees() triggered watch() or unwatch().
+                fetchWatchees();
+                notifyWatchees();
+
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException ignore) {
+                    // Ignore the interrupt; do not terminate until all tasks are run.
+                }
+
+                if (watchees.isEmpty() && pendingEntries.isEmpty()) {
+
+                    // Mark the current worker thread as stopped.
+                    // The following CAS must always success and must be uncontended,
+                    // because only one watcher thread should be running at the same time.
+                    boolean stopped = started.compareAndSet(true, false);
+                    assert stopped;
+
+                    // Check if there are pending entries added by watch() while we do CAS above.
+                    if (pendingEntries.isEmpty()) {
+                        // A) watch() was not invoked and thus there's nothing to handle
+                        //    -> safe to terminate because there's nothing left to do
+                        // B) a new watcher thread started and handled them all
+                        //    -> safe to terminate the new watcher thread will take care the rest
+                        break;
+                    }
+
+                    // There are pending entries again, added by watch()
+                    if (!started.compareAndSet(false, true)) {
+                        // watch() started a new watcher thread and set 'started' to true.
+                        // -> terminate this thread so that the new watcher reads from pendingEntries exclusively.
+                        break;
+                    }
+
+                    // watch() added an entry, but this worker was faster to set 'started' to true.
+                    // i.e. a new watcher thread was not started
+                    // -> keep this thread alive to handle the newly added entries.
+                }
+            }
+        }
+
+        private void fetchWatchees() {
+            for (;;) {
+                Entry e = pendingEntries.poll();
+                if (e == null) {
+                    break;
+                }
+
+                if (e.isWatch) {
+                    watchees.add(e);
+                } else {
+                    watchees.remove(e);
+                }
+            }
+        }
+
+        private void notifyWatchees() {
+            List<Entry> watchees = this.watchees;
+            for (int i = 0; i < watchees.size();) {
+                Entry e = watchees.get(i);
+                if (!e.thread.isAlive()) {
+                    watchees.remove(i);
+                    try {
+                        e.task.run();
+                    } catch (Throwable t) {
+                        logger.warn("Thread death watcher task raised an exception:", t);
+                    }
+                } else {
+                    i ++;
+                }
+            }
+        }
+    }
+
+    private static final class Entry extends MpscLinkedQueueNode<Entry> {
+        final Thread thread;
+        final Runnable task;
+        final boolean isWatch;
+
+        Entry(Thread thread, Runnable task, boolean isWatch) {
+            this.thread = thread;
+            this.task = task;
+            this.isWatch = isWatch;
+        }
+
+        @Override
+        public Entry value() {
+            return this;
+        }
+
+        @Override
+        public int hashCode() {
+            return thread.hashCode() ^ task.hashCode();
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == this) {
+                return true;
+            }
+
+            if (!(obj instanceof Entry)) {
+                return false;
+            }
+
+            Entry that = (Entry) obj;
+            return thread == that.thread && task == that.task;
+        }
+    }
+}
diff --git a/common/src/main/java/io/netty/util/UniqueName.java b/common/src/main/java/io/netty/util/UniqueName.java
deleted file mode 100644
index af9d135fcc41..000000000000
--- a/common/src/main/java/io/netty/util/UniqueName.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.util;
-
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * @deprecated Known to have problems with class loaders.
- *
- * Defines a name that must be unique in the map that is provided during construction.
- */
-@Deprecated
-public class UniqueName implements Comparable<UniqueName> {
-
-    private static final AtomicInteger nextId = new AtomicInteger();
-
-    private final int id;
-    private final String name;
-
-    /**
-     * Constructs a new {@link UniqueName}
-     *
-     * @param map the map of names to compare with
-     * @param name the name of this {@link UniqueName}
-     * @param args the arguments to process
-     */
-    public UniqueName(ConcurrentMap<String, Boolean> map, String name, Object... args) {
-        if (map == null) {
-            throw new NullPointerException("map");
-        }
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
-        if (args != null && args.length > 0) {
-            validateArgs(args);
-        }
-
-        if (map.putIfAbsent(name, Boolean.TRUE) != null) {
-            throw new IllegalArgumentException(String.format("'%s' is already in use", name));
-        }
-
-        id = nextId.incrementAndGet();
-        this.name = name;
-    }
-
-    /**
-     * Validates the given arguments.  This method does not do anything on its own, but must be
-     * overridden by its subclasses.
-     *
-     * @param args arguments to validate
-     */
-    @SuppressWarnings("unused")
-    protected void validateArgs(Object... args) {
-        // Subclasses will override.
-    }
-
-    /**
-     * Returns this {@link UniqueName}'s name
-     *
-     * @return the name
-     */
-    public final String name() {
-        return name;
-    }
-
-    /**
-     * Returns this {@link UniqueName}'s ID
-     *
-     * @return the id
-     */
-    public final int id() {
-        return id;
-    }
-
-    @Override
-    public final int hashCode() {
-        return super.hashCode();
-    }
-
-    @Override
-    public final boolean equals(Object o) {
-        return super.equals(o);
-    }
-
-    @Override
-    public int compareTo(UniqueName other) {
-        if (this == other) {
-            return 0;
-        }
-
-        int returnCode = name.compareTo(other.name);
-        if (returnCode != 0) {
-            return returnCode;
-        }
-
-        return ((Integer) id).compareTo(other.id);
-    }
-
-    @Override
-    public String toString() {
-        return name();
-    }
-}
diff --git a/common/src/main/java/io/netty/util/Version.java b/common/src/main/java/io/netty/util/Version.java
index 7de158239889..2d5637d0ac00 100644
--- a/common/src/main/java/io/netty/util/Version.java
+++ b/common/src/main/java/io/netty/util/Version.java
@@ -16,6 +16,8 @@
 
 package io.netty.util;
 
+import io.netty.util.internal.PlatformDependent;
+
 import java.io.InputStream;
 import java.net.URL;
 import java.text.ParseException;
@@ -61,7 +63,7 @@ public static Map<String, Version> identify() {
      */
     public static Map<String, Version> identify(ClassLoader classLoader) {
         if (classLoader == null) {
-            classLoader = Thread.currentThread().getContextClassLoader();
+            classLoader = PlatformDependent.getContextClassLoader();
         }
 
         // Collect all properties.
@@ -130,7 +132,7 @@ public static Map<String, Version> identify(ClassLoader classLoader) {
     private static long parseIso8601(String value) {
         try {
             return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").parse(value).getTime();
-        } catch (ParseException e) {
+        } catch (ParseException ignored) {
             return 0;
         }
     }
diff --git a/common/src/main/java/io/netty/util/collection/IntObjectHashMap.java b/common/src/main/java/io/netty/util/collection/IntObjectHashMap.java
new file mode 100644
index 000000000000..14ec48a1fef0
--- /dev/null
+++ b/common/src/main/java/io/netty/util/collection/IntObjectHashMap.java
@@ -0,0 +1,493 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.util.collection;
+
+import java.lang.reflect.Array;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * A hash map implementation of {@link IntObjectMap} that uses open addressing for keys. To minimize
+ * the memory footprint, this class uses open addressing rather than chaining. Collisions are
+ * resolved using double hashing.
+ *
+ * @param <V> The value type stored in the map.
+ */
+public class IntObjectHashMap<V> implements IntObjectMap<V>, Iterable<IntObjectMap.Entry<V>> {
+
+    /** State indicating that a slot is available.*/
+    private static final byte AVAILABLE = 0;
+
+    /** State indicating that a slot is occupied. */
+    private static final byte OCCUPIED = 1;
+
+    /** State indicating that a slot was removed. */
+    private static final byte REMOVED = 2;
+
+    /** Default initial capacity. Used if not specified in the constructor */
+    private static final int DEFAULT_CAPACITY = 11;
+
+    /** Default load factor. Used if not specified in the constructor */
+    private static final float DEFAULT_LOAD_FACTOR = 0.5f;
+
+    /** The maximum number of elements allowed without allocating more space. */
+    private int maxSize;
+
+    /** The load factor for the map. Used to calculate {@link #maxSize}. */
+    private final float loadFactor;
+
+    private byte[] states;
+    private int[] keys;
+    private V[] values;
+    private int size;
+    private int available;
+
+    public IntObjectHashMap() {
+        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
+    }
+
+    public IntObjectHashMap(int initialCapacity) {
+        this(initialCapacity, DEFAULT_LOAD_FACTOR);
+    }
+
+    public IntObjectHashMap(int initialCapacity, float loadFactor) {
+        if (initialCapacity < 1) {
+            throw new IllegalArgumentException("initialCapacity must be >= 1");
+        }
+        if (loadFactor <= 0.0f) {
+            throw new IllegalArgumentException("loadFactor must be > 0");
+        }
+
+        this.loadFactor = loadFactor;
+
+        // Adjust the initial capacity if necessary.
+        initialCapacity = adjustCapacity(initialCapacity);
+
+        // Allocate the arrays.
+        states = new byte[initialCapacity];
+        keys = new int[initialCapacity];
+        @SuppressWarnings({ "unchecked", "SuspiciousArrayCast" })
+        V[] temp = (V[]) new Object[initialCapacity];
+        values = temp;
+
+        // Initialize the maximum size value.
+        maxSize = calcMaxSize(initialCapacity);
+
+        // Initialize the available element count
+        available = initialCapacity - size;
+    }
+
+    @Override
+    public V get(int key) {
+        int index = indexOf(key);
+        return index < 0 ? null : values[index];
+    }
+
+    @Override
+    public V put(int key, V value) {
+        int hash = hash(key);
+        int capacity = capacity();
+        int index = hash % capacity;
+        int increment = 1 + hash % (capacity - 2);
+        final int startIndex = index;
+        int firstRemovedIndex = -1;
+        do {
+            switch (states[index]) {
+                case AVAILABLE:
+                    // We only stop probing at a AVAILABLE node, since the value may still exist
+                    // beyond
+                    // a REMOVED node.
+                    if (firstRemovedIndex != -1) {
+                        // We encountered a REMOVED node prior. Store the entry there so that
+                        // retrieval
+                        // will be faster.
+                        insertAt(firstRemovedIndex, key, value);
+                        return null;
+                    }
+
+                    // No REMOVED node, just store the entry here.
+                    insertAt(index, key, value);
+                    return null;
+                case OCCUPIED:
+                    if (keys[index] == key) {
+                        V previousValue = values[index];
+                        insertAt(index, key, value);
+                        return previousValue;
+                    }
+                    break;
+                case REMOVED:
+                    // Check for first removed index.
+                    if (firstRemovedIndex == -1) {
+                        firstRemovedIndex = index;
+                    }
+                    break;
+                default:
+                    throw new AssertionError("Invalid state: " + states[index]);
+            }
+
+            // REMOVED or OCCUPIED but wrong key, keep probing ...
+            index += increment;
+            if (index >= capacity) {
+                // Handle wrap-around by decrement rather than mod.
+                index -= capacity;
+            }
+        } while (index != startIndex);
+
+        if (firstRemovedIndex == -1) {
+            // Should never happen.
+            throw new AssertionError("Unable to insert");
+        }
+
+        // Never found a AVAILABLE slot, just use the first REMOVED.
+        insertAt(firstRemovedIndex, key, value);
+        return null;
+    }
+
+    @Override
+    public void putAll(IntObjectMap<V> sourceMap) {
+        if (sourceMap instanceof IntObjectHashMap) {
+            // Optimization - iterate through the arrays.
+            IntObjectHashMap<V> source = (IntObjectHashMap<V>) sourceMap;
+            int i = -1;
+            while ((i = source.nextEntryIndex(i + 1)) >= 0) {
+                put(source.keys[i], source.values[i]);
+            }
+            return;
+        }
+
+        // Otherwise, just add each entry.
+        for (Entry<V> entry : sourceMap.entries()) {
+            put(entry.key(), entry.value());
+        }
+    }
+
+    @Override
+    public V remove(int key) {
+        int index = indexOf(key);
+        if (index < 0) {
+            return null;
+        }
+
+        V prev = values[index];
+        removeAt(index);
+        return prev;
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return size == 0;
+    }
+
+    @Override
+    public void clear() {
+        Arrays.fill(states, AVAILABLE);
+        Arrays.fill(values, null);
+        size = 0;
+        available = capacity();
+    }
+
+    @Override
+    public boolean containsKey(int key) {
+        return indexOf(key) >= 0;
+    }
+
+    @Override
+    public boolean containsValue(V value) {
+        int i = -1;
+        while ((i = nextEntryIndex(i + 1)) >= 0) {
+            V next = values[i];
+            if (value == next || value != null && value.equals(next)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public Iterable<Entry<V>> entries() {
+        return this;
+    }
+
+    @Override
+    public Iterator<Entry<V>> iterator() {
+        return new IteratorImpl();
+    }
+
+    @Override
+    public int[] keys() {
+        int[] outKeys = new int[size()];
+        copyEntries(keys, outKeys);
+        return outKeys;
+    }
+
+    @Override
+    public V[] values(Class<V> clazz) {
+        @SuppressWarnings("unchecked")
+        V[] outValues = (V[]) Array.newInstance(clazz, size());
+        copyEntries(values, outValues);
+        return outValues;
+    }
+
+    /**
+     * Copies the occupied entries from the source to the target array.
+     */
+    private void copyEntries(Object sourceArray, Object targetArray) {
+        int sourceIx = -1;
+        int targetIx = 0;
+        while ((sourceIx = nextEntryIndex(sourceIx + 1)) >= 0) {
+            Object obj = Array.get(sourceArray, sourceIx);
+            Array.set(targetArray, targetIx++, obj);
+        }
+    }
+
+    /**
+     * Locates the index for the given key. This method probes using double hashing.
+     *
+     * @param key the key for an entry in the map.
+     * @return the index where the key was found, or {@code -1} if no entry is found for that key.
+     */
+    private int indexOf(int key) {
+        int hash = hash(key);
+        int capacity = capacity();
+        int increment = 1 + hash % (capacity - 2);
+        int index = hash % capacity;
+        int startIndex = index;
+        do {
+            switch(states[index]) {
+                case AVAILABLE:
+                    // It's available, so no chance that this value exists anywhere in the map.
+                    return -1;
+                case OCCUPIED:
+                    if (key == keys[index]) {
+                        // Found it!
+                        return index;
+                    }
+                    break;
+                default:
+                    break;
+            }
+
+            // REMOVED or OCCUPIED but wrong key, keep probing ...
+            index += increment;
+            if (index >= capacity) {
+                // Handle wrap-around by decrement rather than mod.
+                index -= capacity;
+            }
+        } while (index != startIndex);
+
+        // Got back to the beginning. Not found.
+        return -1;
+    }
+
+    /**
+     * Determines the current capacity (i.e. size of the arrays).
+     */
+    private int capacity() {
+        return keys.length;
+    }
+
+    /**
+     * Creates a hash value for the given key.
+     */
+    private static int hash(int key) {
+        // Just make sure the integer is positive.
+        return key & Integer.MAX_VALUE;
+    }
+
+    /**
+     * Performs an insert of the key/value at the given index position. If necessary, performs a
+     * rehash of the map.
+     *
+     * @param index the index at which to insert the key/value
+     * @param key the entry key
+     * @param value the entry value
+     */
+    private void insertAt(int index, int key, V value) {
+        byte state = states[index];
+        if (state != OCCUPIED) {
+            // Added a new mapping, increment the size.
+            size++;
+
+            if (state == AVAILABLE) {
+                // Consumed a OCCUPIED slot, decrement the number of available slots.
+                available--;
+            }
+        }
+
+        keys[index] = key;
+        values[index] = value;
+        states[index] = OCCUPIED;
+
+        if (size > maxSize) {
+            // Need to grow the arrays.
+            rehash(adjustCapacity(capacity() * 2));
+        } else if (available == 0) {
+            // Open addressing requires that we have at least 1 slot available. Need to refresh
+            // the arrays to clear any removed elements.
+            rehash(capacity());
+        }
+    }
+
+    /**
+     * Adjusts the given capacity value to ensure that it's odd. Even capacities can break probing.
+     * TODO: would be better to ensure it's prime as well.
+     */
+    private static int adjustCapacity(int capacity) {
+        return capacity | 1;
+    }
+
+    /**
+     * Marks the entry at the given index position as {@link #REMOVED} and sets the value to
+     * {@code null}.
+     * <p>
+     * TODO: consider performing re-compaction.
+     *
+     * @param index the index position of the element to remove.
+     */
+    private void removeAt(int index) {
+        if (states[index] == OCCUPIED) {
+            size--;
+        }
+        states[index] = REMOVED;
+        values[index] = null;
+    }
+
+    /**
+     * Calculates the maximum size allowed before rehashing.
+     */
+    private int calcMaxSize(int capacity) {
+        // Clip the upper bound so that there will always be at least one
+        // available slot.
+        int upperBound = capacity - 1;
+        return Math.min(upperBound, (int) (capacity * loadFactor));
+    }
+
+    /**
+     * Rehashes the map for the given capacity.
+     *
+     * @param newCapacity the new capacity for the map.
+     */
+    private void rehash(int newCapacity) {
+        int oldCapacity = capacity();
+        int[] oldKeys = keys;
+        V[] oldVals = values;
+        byte[] oldStates = states;
+
+        // New states array is automatically initialized to AVAILABLE (i.e. 0 == AVAILABLE).
+        states = new byte[newCapacity];
+        keys = new int[newCapacity];
+        @SuppressWarnings({ "unchecked", "SuspiciousArrayCast" })
+        V[] temp = (V[]) new Object[newCapacity];
+        values = temp;
+
+        size = 0;
+        available = newCapacity;
+        maxSize = calcMaxSize(newCapacity);
+
+        // Insert the new states.
+        for (int i = 0; i < oldCapacity; ++i) {
+            if (oldStates[i] == OCCUPIED) {
+                put(oldKeys[i], oldVals[i]);
+            }
+        }
+    }
+
+    /**
+     * Returns the next index of the next entry in the map.
+     *
+     * @param index the index at which to begin the search.
+     * @return the index of the next entry, or {@code -1} if not found.
+     */
+    private int nextEntryIndex(int index) {
+        int capacity = capacity();
+        for (; index < capacity; ++index) {
+            if (states[index] == OCCUPIED) {
+                return index;
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Iterator for traversing the entries in this map.
+     */
+    private final class IteratorImpl implements Iterator<Entry<V>> {
+        int prevIndex;
+        int nextIndex;
+
+        IteratorImpl() {
+            prevIndex = -1;
+            nextIndex = nextEntryIndex(0);
+        }
+
+        @Override
+        public boolean hasNext() {
+            return nextIndex >= 0;
+        }
+
+        @Override
+        public Entry<V> next() {
+            if (!hasNext()) {
+                throw new NoSuchElementException();
+            }
+
+            prevIndex = nextIndex;
+            nextIndex = nextEntryIndex(nextIndex + 1);
+            return new EntryImpl(prevIndex);
+        }
+
+        @Override
+        public void remove() {
+            if (prevIndex < 0) {
+                throw new IllegalStateException("Next must be called before removing.");
+            }
+            removeAt(prevIndex);
+            prevIndex = -1;
+        }
+    }
+
+    /**
+     * {@link Entry} implementation that just references the key/value at the given index position.
+     */
+    private final class EntryImpl implements Entry<V> {
+        final int index;
+
+        EntryImpl(int index) {
+            this.index = index;
+        }
+
+        @Override
+        public int key() {
+            return keys[index];
+        }
+
+        @Override
+        public V value() {
+            return values[index];
+        }
+
+        @Override
+        public void setValue(V value) {
+            values[index] = value;
+        }
+    }
+}
diff --git a/common/src/main/java/io/netty/util/collection/IntObjectMap.java b/common/src/main/java/io/netty/util/collection/IntObjectMap.java
new file mode 100644
index 000000000000..ae1c9629b6c3
--- /dev/null
+++ b/common/src/main/java/io/netty/util/collection/IntObjectMap.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package io.netty.util.collection;
+
+/**
+ * Interface for a primitive map that uses {@code int}s as keys.
+ *
+ * @param <V> the value type stored in the map.
+ */
+public interface IntObjectMap<V> {
+
+    /**
+     * An Entry in the map.
+     *
+     * @param <V> the value type stored in the map.
+     */
+    interface Entry<V> {
+        /**
+         * Gets the key for this entry.
+         */
+        int key();
+
+        /**
+         * Gets the value for this entry.
+         */
+        V value();
+
+        /**
+         * Sets the value for this entry.
+         */
+        void setValue(V value);
+    }
+
+    /**
+     * Gets the value in the map with the specified key.
+     *
+     * @param key the key whose associated value is to be returned.
+     * @return the value or {@code null} if the key was not found in the map.
+     */
+    V get(int key);
+
+    /**
+     * Puts the given entry into the map.
+     *
+     * @param key the key of the entry.
+     * @param value the value of the entry.
+     * @return the previous value for this key or {@code null} if there was no previous mapping.
+     */
+    V put(int key, V value);
+
+    /**
+     * Puts all of the entries from the given map into this map.
+     */
+    void putAll(IntObjectMap<V> sourceMap);
+
+    /**
+     * Removes the entry with the specified key.
+     *
+     * @param key the key for the entry to be removed from this map.
+     * @return the previous value for the key, or {@code null} if there was no mapping.
+     */
+    V remove(int key);
+
+    /**
+     * Returns the number of entries contained in this map.
+     */
+    int size();
+
+    /**
+     * Indicates whether or not this map is empty (i.e {@link #size()} == {@code 0]).
+
+     */
+    boolean isEmpty();
+
+    /**
+     * Clears all entries from this map.
+     */
+    void clear();
+
+    /**
+     * Indicates whether or not this map contains a value for the specified key.
+     */
+    boolean containsKey(int key);
+
+    /**
+     * Indicates whether or not the map contains the specified value.
+     */
+    boolean containsValue(V value);
+
+    /**
+     * Gets an iterable collection of the entries contained in this map.
+     */
+    Iterable<Entry<V>> entries();
+
+    /**
+     * Gets the keys contained in this map.
+     */
+    int[] keys();
+
+    /**
+     * Gets the values contained in this map.
+     */
+    V[] values(Class<V> clazz);
+}
diff --git a/common/src/main/java/io/netty/util/collection/package-info.java b/common/src/main/java/io/netty/util/collection/package-info.java
new file mode 100644
index 000000000000..b5f6029edb4d
--- /dev/null
+++ b/common/src/main/java/io/netty/util/collection/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Utility classes for commonly used collections.
+ */
+package io.netty.util.collection;
diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
index 142220579e02..0a7d654ef690 100644
--- a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
@@ -15,10 +15,12 @@
  */
 package io.netty.util.concurrent;
 
+import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
 import java.util.concurrent.Callable;
 import java.util.concurrent.RunnableFuture;
@@ -29,6 +31,25 @@
  */
 public abstract class AbstractEventExecutor extends AbstractExecutorService implements EventExecutor {
 
+    static final long DEFAULT_SHUTDOWN_QUIET_PERIOD = 2;
+    static final long DEFAULT_SHUTDOWN_TIMEOUT = 15;
+
+    private final EventExecutorGroup parent;
+    private final Collection<AbstractEventExecutor> selfCollection = Collections.singleton(this);
+
+    protected AbstractEventExecutor() {
+        this(null);
+    }
+
+    protected AbstractEventExecutor(EventExecutorGroup parent) {
+        this.parent = parent;
+    }
+
+    @Override
+    public EventExecutorGroup parent() {
+        return parent;
+    }
+
     @Override
     public EventExecutor next() {
         return this;
@@ -44,9 +65,14 @@ public Iterator<EventExecutor> iterator() {
         return new EventExecutorIterator();
     }
 
+    @Override
+    public <E extends EventExecutor> Set<E> children() {
+        return (Set<E>) selfCollection;
+    }
+
     @Override
     public Future<?> shutdownGracefully() {
-        return shutdownGracefully(2, 15, TimeUnit.SECONDS);
+        return shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java
index 61789d6c93f1..546258a995ce 100644
--- a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java
@@ -23,12 +23,13 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import static io.netty.util.concurrent.AbstractEventExecutor.*;
+
 
 /**
  * Abstract base class for {@link EventExecutorGroup} implementations.
  */
 public abstract class AbstractEventExecutorGroup implements EventExecutorGroup {
-
     @Override
     public Future<?> submit(Runnable task) {
         return next().submit(task);
@@ -66,7 +67,7 @@ public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialD
 
     @Override
     public Future<?> shutdownGracefully() {
-        return shutdownGracefully(2, 15, TimeUnit.SECONDS);
+        return shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java
index f2f704a3a858..2470ec66bf5a 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java
@@ -15,19 +15,39 @@
  */
 package io.netty.util.concurrent;
 
+import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 
 /**
  * Default {@link SingleThreadEventExecutor} implementation which just execute all submitted task in a
- * serial fashion
- *
+ * serial fashion.
  */
-final class DefaultEventExecutor extends SingleThreadEventExecutor {
+public final class DefaultEventExecutor extends SingleThreadEventExecutor {
+
+    public DefaultEventExecutor() {
+        this((EventExecutorGroup) null);
+    }
 
-    DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {
+    public DefaultEventExecutor(ThreadFactory threadFactory) {
+        this(null, threadFactory);
+    }
+
+    public DefaultEventExecutor(Executor executor) {
+        this(null, executor);
+    }
+
+    public DefaultEventExecutor(EventExecutorGroup parent) {
+        this(parent, new DefaultThreadFactory(DefaultEventExecutor.class));
+    }
+
+    public DefaultEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory) {
         super(parent, threadFactory, true);
     }
 
+    public DefaultEventExecutor(EventExecutorGroup parent, Executor executor) {
+        super(parent, executor, true);
+    }
+
     @Override
     protected void run() {
         for (;;) {
diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java
index faf88a0b8be8..5343be1652b5 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java
@@ -15,6 +15,7 @@
  */
 package io.netty.util.concurrent;
 
+import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 
 /**
@@ -41,8 +42,7 @@ public DefaultEventExecutorGroup(int nThreads, ThreadFactory threadFactory) {
     }
 
     @Override
-    protected EventExecutor newChild(
-            ThreadFactory threadFactory, Object... args) throws Exception {
-        return new DefaultEventExecutor(this, threadFactory);
+    protected EventExecutor newChild(Executor executor, Object... args) throws Exception {
+        return new DefaultEventExecutor(this, executor);
     }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultFutureListeners.java b/common/src/main/java/io/netty/util/concurrent/DefaultFutureListeners.java
index 9d895006d342..46124d186f7d 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultFutureListeners.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultFutureListeners.java
@@ -24,7 +24,7 @@ final class DefaultFutureListeners {
     private int progressiveSize; // the number of progressive listeners
 
     @SuppressWarnings("unchecked")
-    public DefaultFutureListeners(
+    DefaultFutureListeners(
             GenericFutureListener<? extends Future<?>> first, GenericFutureListener<? extends Future<?>> second) {
         listeners = new GenericFutureListener[2];
         listeners[0] = first;
diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
index fcacd61832a5..a65671a22dd6 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
@@ -17,6 +17,7 @@
 
 import io.netty.util.Signal;
 import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.InternalThreadLocalMap;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogger;
@@ -35,14 +36,8 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
             InternalLoggerFactory.getInstance(DefaultPromise.class.getName() + ".rejectedExecution");
 
     private static final int MAX_LISTENER_STACK_DEPTH = 8;
-    private static final ThreadLocal<Integer> LISTENER_STACK_DEPTH = new ThreadLocal<Integer>() {
-        @Override
-        protected Integer initialValue() {
-            return 0;
-        }
-    };
-    private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class.getName() + ".SUCCESS");
-    private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class.getName() + ".UNCANCELLABLE");
+    private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class, "SUCCESS");
+    private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class, "UNCANCELLABLE");
     private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(new CancellationException());
 
     static {
@@ -152,7 +147,6 @@ public Promise<V> addListener(GenericFutureListener<? extends Future<? super V>>
                     if (listeners instanceof DefaultFutureListeners) {
                         ((DefaultFutureListeners) listeners).add(listener);
                     } else {
-                        @SuppressWarnings("unchecked")
                         final GenericFutureListener<? extends Future<V>> firstListener =
                                 (GenericFutureListener<? extends Future<V>>) listeners;
                         listeners = new DefaultFutureListeners(firstListener, listener);
@@ -556,21 +550,21 @@ private void notifyListeners() {
 
         EventExecutor executor = executor();
         if (executor.inEventLoop()) {
-            final Integer stackDepth = LISTENER_STACK_DEPTH.get();
+            final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
+            final int stackDepth = threadLocals.futureListenerStackDepth();
             if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                LISTENER_STACK_DEPTH.set(stackDepth + 1);
+                threadLocals.setFutureListenerStackDepth(stackDepth + 1);
                 try {
                     if (listeners instanceof DefaultFutureListeners) {
                         notifyListeners0(this, (DefaultFutureListeners) listeners);
                     } else {
-                        @SuppressWarnings("unchecked")
                         final GenericFutureListener<? extends Future<V>> l =
                                 (GenericFutureListener<? extends Future<V>>) listeners;
                         notifyListener0(this, l);
-                        this.listeners = null;
                     }
                 } finally {
-                    LISTENER_STACK_DEPTH.set(stackDepth);
+                    this.listeners = null;
+                    threadLocals.setFutureListenerStackDepth(stackDepth);
                 }
                 return;
             }
@@ -586,7 +580,6 @@ public void run() {
                 }
             });
         } else {
-            @SuppressWarnings("unchecked")
             final GenericFutureListener<? extends Future<V>> l =
                     (GenericFutureListener<? extends Future<V>>) listeners;
             execute(executor, new Runnable() {
@@ -616,14 +609,16 @@ private void notifyLateListener(final GenericFutureListener<?> l) {
         final EventExecutor executor = executor();
         if (executor.inEventLoop()) {
             if (listeners == null && lateListeners == null) {
-                final Integer stackDepth = LISTENER_STACK_DEPTH.get();
+                final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
+                final int stackDepth = threadLocals.futureListenerStackDepth();
                 if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                    LISTENER_STACK_DEPTH.set(stackDepth + 1);
+                    threadLocals.setFutureListenerStackDepth(stackDepth + 1);
                     try {
                         notifyListener0(this, l);
                     } finally {
-                        LISTENER_STACK_DEPTH.set(stackDepth);
+                        threadLocals.setFutureListenerStackDepth(stackDepth);
                     }
+                    return;
                 }
             } else {
                 LateListeners lateListeners = this.lateListeners;
@@ -632,26 +627,28 @@ private void notifyLateListener(final GenericFutureListener<?> l) {
                 }
                 lateListeners.add(l);
                 execute(executor, lateListeners);
+                return;
             }
-        } else {
-            // Add the late listener to lateListeners in the executor thread for thread safety.
-            // We could just make LateListeners extend ConcurrentLinkedQueue, but it's an overkill considering
-            // that most asynchronous applications won't execute this code path.
-            execute(executor, new LateListenerNotifier(l));
         }
+
+        // Add the late listener to lateListeners in the executor thread for thread safety.
+        // We could just make LateListeners extend ConcurrentLinkedQueue, but it's an overkill considering
+        // that most asynchronous applications won't execute this code path.
+        execute(executor, new LateListenerNotifier(l));
     }
 
     protected static void notifyListener(
             final EventExecutor eventExecutor, final Future<?> future, final GenericFutureListener<?> l) {
 
         if (eventExecutor.inEventLoop()) {
-            final Integer stackDepth = LISTENER_STACK_DEPTH.get();
+            final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
+            final int stackDepth = threadLocals.futureListenerStackDepth();
             if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                LISTENER_STACK_DEPTH.set(stackDepth + 1);
+                threadLocals.setFutureListenerStackDepth(stackDepth + 1);
                 try {
                     notifyListener0(future, l);
                 } finally {
-                    LISTENER_STACK_DEPTH.set(stackDepth);
+                    threadLocals.setFutureListenerStackDepth(stackDepth);
                 }
                 return;
             }
@@ -729,7 +726,7 @@ private synchronized Object progressiveListeners() {
         }
     }
 
-    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @SuppressWarnings("unchecked")
     void notifyProgressiveListeners(final long progress, final long total) {
         final Object listeners = progressiveListeners();
         if (listeners == null) {
@@ -794,7 +791,7 @@ private static void notifyProgressiveListener0(
 
     private static final class CauseHolder {
         final Throwable cause;
-        private CauseHolder(Throwable cause) {
+        CauseHolder(Throwable cause) {
             this.cause = cause;
         }
     }
diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java
index 3142a1b02908..84d72cdf2421 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java
@@ -98,7 +98,7 @@ public DefaultThreadFactory(String poolName, boolean daemon, int priority) {
 
     @Override
     public Thread newThread(Runnable r) {
-        Thread t = new Thread(r, prefix + nextId.incrementAndGet());
+        Thread t = newThread(new DefaultRunnableDecorator(r), prefix + nextId.incrementAndGet());
         try {
             if (t.isDaemon()) {
                 if (!daemon) {
@@ -118,4 +118,26 @@ public Thread newThread(Runnable r) {
         }
         return t;
     }
+
+    protected Thread newThread(Runnable r, String name) {
+        return new FastThreadLocalThread(r, name);
+    }
+
+    private static final class DefaultRunnableDecorator implements Runnable {
+
+        private final Runnable r;
+
+        DefaultRunnableDecorator(Runnable r) {
+            this.r = r;
+        }
+
+        @Override
+        public void run() {
+            try {
+                r.run();
+            } finally {
+                FastThreadLocal.removeAll();
+            }
+        }
+    }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutor.java b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java
index 5f5c3729f1fa..96fb747987ff 100644
--- a/common/src/main/java/io/netty/util/concurrent/EventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java
@@ -15,6 +15,8 @@
  */
 package io.netty.util.concurrent;
 
+import java.util.Set;
+
 /**
  * The {@link EventExecutor} is a special {@link EventExecutorGroup} which comes
  * with some handy methods to see if a {@link Thread} is executed in a event loop.
@@ -30,6 +32,12 @@ public interface EventExecutor extends EventExecutorGroup {
     @Override
     EventExecutor next();
 
+    /**
+     * Returns an unmodifiable singleton set which contains itself.
+     */
+    @Override
+    <E extends EventExecutor> Set<E> children();
+
     /**
      * Return the {@link EventExecutorGroup} which is the parent of this {@link EventExecutor},
      */
@@ -57,14 +65,14 @@ public interface EventExecutor extends EventExecutorGroup {
     <V> ProgressivePromise<V> newProgressivePromise();
 
     /**
-     * Create a new {@link Future} which is marked as successes already. So {@link Future#isSuccess()}
+     * Create a new {@link Future} which is marked as succeeded already. So {@link Future#isSuccess()}
      * will return {@code true}. All {@link FutureListener} added to it will be notified directly. Also
      * every call of blocking methods will just return without blocking.
      */
     <V> Future<V> newSucceededFuture(V result);
 
     /**
-     * Create a new {@link Future} which is marked as fakued already. So {@link Future#isSuccess()}
+     * Create a new {@link Future} which is marked as failed already. So {@link Future#isSuccess()}
      * will return {@code false}. All {@link FutureListener} added to it will be notified directly. Also
      * every call of blocking methods will just return without blocking.
      */
diff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
index 30bd90d88372..5ee3e84060f8 100644
--- a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
@@ -17,6 +17,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
@@ -30,8 +31,8 @@
 public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<EventExecutor> {
 
     /**
-     * Returns {@code true} if and only if this executor was started to be
-     * {@linkplain #shutdownGracefully() shut down gracefuclly} or was {@linkplain #isShutdown() shut down}.
+     * Returns {@code true} if and only if all {@link EventExecutor}s managed by this {@link EventExecutorGroup}
+     * are being {@linkplain #shutdownGracefully() shut down gracefuclly} or was {@linkplain #isShutdown() shut down}.
      */
     boolean isShuttingDown();
 
@@ -59,7 +60,8 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E
     Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit);
 
     /**
-     * Returns the {@link Future} which is notified when this executor has been terminated.
+     * Returns the {@link Future} which is notified when all {@link EventExecutor}s managed by this
+     * {@link EventExecutorGroup} have been terminated.
      */
     Future<?> terminationFuture();
 
@@ -78,17 +80,22 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E
     List<Runnable> shutdownNow();
 
     /**
-     * Returns one of the {@link EventExecutor}s that belong to this group.
+     * Returns one of the {@link EventExecutor}s managed by this {@link EventExecutorGroup}.
      */
     EventExecutor next();
 
     /**
-     * Returns a read-only {@link Iterator} over all {@link EventExecutor}, which are handled by this
-     * {@link EventExecutorGroup} at the time of invoke this method.
+     * @deprecated Use {@link #children()} instead.
      */
     @Override
+    @Deprecated
     Iterator<EventExecutor> iterator();
 
+    /**
+     * Returns the unmodifiable set of {@link EventExecutor}s managed by this {@link EventExecutorGroup}.
+     */
+    <E extends EventExecutor> Set<E> children();
+
     @Override
     Future<?> submit(Runnable task);
 
diff --git a/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java
new file mode 100644
index 000000000000..df943b49973f
--- /dev/null
+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java
@@ -0,0 +1,244 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.concurrent;
+
+import io.netty.util.internal.InternalThreadLocalMap;
+import io.netty.util.internal.PlatformDependent;
+
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.Set;
+
+/**
+ * A special variant of {@link ThreadLocal} that yields higher access performan when accessed from a
+ * {@link FastThreadLocalThread}.
+ * <p>
+ * Internally, a {@link FastThreadLocal} uses a constant index in an array, instead of using hash code and hash table,
+ * to look for a variable.  Although seemingly very subtle, it yields slight performance advantage over using a hash
+ * table, and it is useful when accessed frequently.
+ * </p><p>
+ * To take advantage of this thread-local variable, your thread must be a {@link FastThreadLocalThread} or its subtype.
+ * By default, all threads created by {@link DefaultThreadFactory} are {@link FastThreadLocalThread} due to this reason.
+ * </p><p>
+ * Note that the fast path is only possible on threads that extend {@link FastThreadLocalThread}, because it requires
+ * a special field to store the necessary state.  An access by any other kind of thread falls back to a regular
+ * {@link ThreadLocal}.
+ * </p>
+ *
+ * @param <V> the type of the thread-local variable
+ * @see ThreadLocal
+ */
+public class FastThreadLocal<V> {
+
+    private static final int variablesToRemoveIndex = InternalThreadLocalMap.nextVariableIndex();
+
+    /**
+     * Removes all {@link FastThreadLocal} variables bound to the current thread.  This operation is useful when you
+     * are in a container environment, and you don't want to leave the thread local variables in the threads you do not
+     * manage.
+     */
+    public static void removeAll() {
+        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();
+        if (threadLocalMap == null) {
+            return;
+        }
+
+        try {
+            Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);
+            if (v != null && v != InternalThreadLocalMap.UNSET) {
+                @SuppressWarnings("unchecked")
+                Set<FastThreadLocal<?>> variablesToRemove = (Set<FastThreadLocal<?>>) v;
+                FastThreadLocal<?>[] variablesToRemoveArray =
+                        variablesToRemove.toArray(new FastThreadLocal[variablesToRemove.size()]);
+                for (FastThreadLocal<?> tlv: variablesToRemoveArray) {
+                    tlv.remove(threadLocalMap);
+                }
+            }
+        } finally {
+            InternalThreadLocalMap.remove();
+        }
+    }
+
+    /**
+     * Returns the number of thread local variables bound to the current thread.
+     */
+    public static int size() {
+        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();
+        if (threadLocalMap == null) {
+            return 0;
+        } else {
+            return threadLocalMap.size();
+        }
+    }
+
+    /**
+     * Destroys the data structure that keeps all {@link FastThreadLocal} variables accessed from
+     * non-{@link FastThreadLocalThread}s.  This operation is useful when you are in a container environment, and you
+     * do not want to leave the thread local variables in the threads you do not manage.  Call this method when your
+     * application is being unloaded from the container.
+     */
+    public static void destroy() {
+        InternalThreadLocalMap.destroy();
+    }
+
+    @SuppressWarnings("unchecked")
+    private static void addToVariablesToRemove(InternalThreadLocalMap threadLocalMap, FastThreadLocal<?> variable) {
+        Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);
+        Set<FastThreadLocal<?>> variablesToRemove;
+        if (v == InternalThreadLocalMap.UNSET || v == null) {
+            variablesToRemove = Collections.newSetFromMap(new IdentityHashMap<FastThreadLocal<?>, Boolean>());
+            threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);
+        } else {
+            variablesToRemove = (Set<FastThreadLocal<?>>) v;
+        }
+
+        variablesToRemove.add(variable);
+    }
+
+    private static void removeFromVariablesToRemove(
+            InternalThreadLocalMap threadLocalMap, FastThreadLocal<?> variable) {
+
+        Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);
+
+        if (v == InternalThreadLocalMap.UNSET || v == null) {
+            return;
+        }
+
+        @SuppressWarnings("unchecked")
+        Set<FastThreadLocal<?>> variablesToRemove = (Set<FastThreadLocal<?>>) v;
+        variablesToRemove.remove(variable);
+    }
+
+    private final int index;
+
+    public FastThreadLocal() {
+        index = InternalThreadLocalMap.nextVariableIndex();
+    }
+
+    /**
+     * Returns the current value for the current thread
+     */
+    public final V get() {
+        return get(InternalThreadLocalMap.get());
+    }
+
+    /**
+     * Returns the current value for the specified thread local map.
+     * The specified thread local map must be for the current thread.
+     */
+    @SuppressWarnings("unchecked")
+    public final V get(InternalThreadLocalMap threadLocalMap) {
+        Object v = threadLocalMap.indexedVariable(index);
+        if (v != InternalThreadLocalMap.UNSET) {
+            return (V) v;
+        }
+
+        return initialize(threadLocalMap);
+    }
+
+    private V initialize(InternalThreadLocalMap threadLocalMap) {
+        V v = null;
+        try {
+            v = initialValue();
+        } catch (Exception e) {
+            PlatformDependent.throwException(e);
+        }
+
+        threadLocalMap.setIndexedVariable(index, v);
+        addToVariablesToRemove(threadLocalMap, this);
+        return v;
+    }
+
+    /**
+     * Set the value for the current thread.
+     */
+    public final void set(V value) {
+        if (value != InternalThreadLocalMap.UNSET) {
+            set(InternalThreadLocalMap.get(), value);
+        } else {
+            remove();
+        }
+    }
+
+    /**
+     * Set the value for the specified thread local map. The specified thread local map must be for the current thread.
+     */
+    public final void set(InternalThreadLocalMap threadLocalMap, V value) {
+        if (value != InternalThreadLocalMap.UNSET) {
+            if (threadLocalMap.setIndexedVariable(index, value)) {
+                addToVariablesToRemove(threadLocalMap, this);
+            }
+        } else {
+            remove(threadLocalMap);
+        }
+    }
+
+    /**
+     * Returns {@code true} if and only if this thread-local variable is set.
+     */
+    public final boolean isSet() {
+        return isSet(InternalThreadLocalMap.getIfSet());
+    }
+
+    /**
+     * Returns {@code true} if and only if this thread-local variable is set.
+     * The specified thread local map must be for the current thread.
+     */
+    public final boolean isSet(InternalThreadLocalMap threadLocalMap) {
+        return threadLocalMap != null && threadLocalMap.isIndexedVariableSet(index);
+    }
+    /**
+     * Sets the value to uninitialized; a proceeding call to get() will trigger a call to initialValue().
+     */
+    public final void remove() {
+        remove(InternalThreadLocalMap.getIfSet());
+    }
+
+    /**
+     * Sets the value to uninitialized for the specified thread local map;
+     * a proceeding call to get() will trigger a call to initialValue().
+     * The specified thread local map must be for the current thread.
+     */
+    @SuppressWarnings("unchecked")
+    public final void remove(InternalThreadLocalMap threadLocalMap) {
+        if (threadLocalMap == null) {
+            return;
+        }
+
+        Object v = threadLocalMap.removeIndexedVariable(index);
+        removeFromVariablesToRemove(threadLocalMap, this);
+
+        if (v != InternalThreadLocalMap.UNSET) {
+            try {
+                onRemoval((V) v);
+            } catch (Exception e) {
+                PlatformDependent.throwException(e);
+            }
+        }
+    }
+
+    /**
+     * Returns the initial value for this thread-local variable.
+     */
+    protected V initialValue() throws Exception {
+        return null;
+    }
+
+    /**
+     * Invoked when this thread local variable is removed by {@link #remove()}.
+     */
+    protected void onRemoval(@SuppressWarnings("UnusedParameters") V value) throws Exception { }
+}
diff --git a/common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java b/common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java
new file mode 100644
index 000000000000..bd3e1c4441a0
--- /dev/null
+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java
@@ -0,0 +1,72 @@
+/*
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+package io.netty.util.concurrent;
+
+import io.netty.util.internal.InternalThreadLocalMap;
+
+/**
+ * A special {@link Thread} that provides fast access to {@link FastThreadLocal} variables.
+ */
+public class FastThreadLocalThread extends Thread {
+
+    private InternalThreadLocalMap threadLocalMap;
+
+    public FastThreadLocalThread() { }
+
+    public FastThreadLocalThread(Runnable target) {
+        super(target);
+    }
+
+    public FastThreadLocalThread(ThreadGroup group, Runnable target) {
+        super(group, target);
+    }
+
+    public FastThreadLocalThread(String name) {
+        super(name);
+    }
+
+    public FastThreadLocalThread(ThreadGroup group, String name) {
+        super(group, name);
+    }
+
+    public FastThreadLocalThread(Runnable target, String name) {
+        super(target, name);
+    }
+
+    public FastThreadLocalThread(ThreadGroup group, Runnable target, String name) {
+        super(group, target, name);
+    }
+
+    public FastThreadLocalThread(ThreadGroup group, Runnable target, String name, long stackSize) {
+        super(group, target, name, stackSize);
+    }
+
+    /**
+     * Returns the internal data structure that keeps the thread-local variables bound to this thread.
+     * Note that this method is for internal use only, and thus is subject to change at any time.
+     */
+    public final InternalThreadLocalMap threadLocalMap() {
+        return threadLocalMap;
+    }
+
+    /**
+     * Sets the internal data structure that keeps the thread-local variables bound to this thread.
+     * Note that this method is for internal use only, and thus is subject to change at any time.
+     */
+    public final void setThreadLocalMap(InternalThreadLocalMap threadLocalMap) {
+        this.threadLocalMap = threadLocalMap;
+    }
+}
diff --git a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
index ca00e52a09b1..342679cab50e 100644
--- a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
@@ -28,6 +28,7 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Single-thread singleton {@link EventExecutor}.  It starts the thread automatically and stops it when there is no
@@ -38,14 +39,11 @@ public final class GlobalEventExecutor extends AbstractEventExecutor {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(GlobalEventExecutor.class);
 
-    private static final int ST_NOT_STARTED = 1;
-    private static final int ST_STARTED = 2;
-
     private static final long SCHEDULE_PURGE_INTERVAL = TimeUnit.SECONDS.toNanos(1);
 
     public static final GlobalEventExecutor INSTANCE = new GlobalEventExecutor();
 
-    final Queue<Runnable> taskQueue = new LinkedBlockingQueue<Runnable>();
+    final BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<Runnable>();
     final Queue<ScheduledFutureTask<?>> delayedTaskQueue = new PriorityQueue<ScheduledFutureTask<?>>();
     final ScheduledFutureTask<Void> purgeTask = new ScheduledFutureTask<Void>(
             this, delayedTaskQueue, Executors.<Void>callable(new PurgeTask(), null),
@@ -53,10 +51,8 @@ public final class GlobalEventExecutor extends AbstractEventExecutor {
 
     private final ThreadFactory threadFactory = new DefaultThreadFactory(getClass());
     private final TaskRunner taskRunner = new TaskRunner();
-    private final Object stateLock = new Object();
-
+    private final AtomicBoolean started = new AtomicBoolean();
     volatile Thread thread;
-    private volatile int state = ST_NOT_STARTED;
 
     private final Future<?> terminationFuture = new FailedFuture<Object>(this, new UnsupportedOperationException());
 
@@ -64,18 +60,13 @@ private GlobalEventExecutor() {
         delayedTaskQueue.add(purgeTask);
     }
 
-    @Override
-    public EventExecutorGroup parent() {
-        return null;
-    }
-
     /**
      * Take the next {@link Runnable} from the task queue and so will block if no task is currently present.
      *
      * @return {@code null} if the executor thread has been interrupted or waken up.
      */
     Runnable takeTask() {
-        BlockingQueue<Runnable> taskQueue = (BlockingQueue<Runnable>) this.taskQueue;
+        BlockingQueue<Runnable> taskQueue = this.taskQueue;
         for (;;) {
             ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();
             if (delayedTask == null) {
@@ -93,6 +84,7 @@ Runnable takeTask() {
                     try {
                         task = taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);
                     } catch (InterruptedException e) {
+                        // Waken up.
                         return null;
                     }
                 } else {
@@ -194,6 +186,26 @@ public boolean awaitTermination(long timeout, TimeUnit unit) {
         return false;
     }
 
+    /**
+     * Waits until the worker thread of this executor has no tasks left in its task queue and terminates itself.
+     * Because a new worker thread will be started again when a new task is submitted, this operation is only useful
+     * when you want to ensure that the worker thread is terminated <strong>after</strong> your application is shut
+     * down and there's no chance of submitting a new task afterwards.
+     *
+     * @return {@code true} if and only if the worker thread has been terminated
+     */
+    public boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
+        if (unit == null) {
+            throw new NullPointerException("unit");
+        }
+
+        Thread thread = this.thread;
+        if (thread != null) {
+            thread.join(unit.toMillis(timeout));
+        }
+        return !thread.isAlive();
+    }
+
     @Override
     public void execute(Runnable task) {
         if (task == null) {
@@ -304,14 +316,10 @@ public void run() {
     }
 
     private void startThread() {
-        synchronized (stateLock) {
-            if (state == ST_NOT_STARTED) {
-                state = ST_STARTED;
-
-                thread = threadFactory.newThread(taskRunner);
-
-                thread.start();
-            }
+        if (started.compareAndSet(false, true)) {
+            Thread t = threadFactory.newThread(taskRunner);
+            t.start();
+            thread = t;
         }
     }
 
@@ -332,14 +340,33 @@ public void run() {
                     }
                 }
 
+                // Terminate if there is no task in the queue (except the purge task).
                 if (taskQueue.isEmpty() && delayedTaskQueue.size() == 1) {
-                    synchronized (stateLock) {
-                        // Terminate if there is no task in the queue (except the purge task).
-                        if (taskQueue.isEmpty() && delayedTaskQueue.size() == 1) {
-                            state = ST_NOT_STARTED;
-                            break;
-                        }
+                    // Mark the current thread as stopped.
+                    // The following CAS must always success and must be uncontended,
+                    // because only one thread should be running at the same time.
+                    boolean stopped = started.compareAndSet(true, false);
+                    assert stopped;
+
+                    // Check if there are pending entries added by execute() or schedule*() while we do CAS above.
+                    if (taskQueue.isEmpty() && delayedTaskQueue.size() == 1) {
+                        // A) No new task was added and thus there's nothing to handle
+                        //    -> safe to terminate because there's nothing left to do
+                        // B) A new thread started and handled all the new tasks.
+                        //    -> safe to terminate the new thread will take care the rest
+                        break;
                     }
+
+                    // There are pending tasks added again.
+                    if (!started.compareAndSet(false, true)) {
+                        // startThread() started a new thread and set 'started' to true.
+                        // -> terminate this thread so that the new thread reads from taskQueue exclusively.
+                        break;
+                    }
+
+                    // New tasks were added, but this worker was faster to set 'started' to true.
+                    // i.e. a new worker thread was not started by startThread().
+                    // -> keep this thread alive to handle the newly added entries.
                 }
             }
         }
diff --git a/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
index 0fae5844030a..db74c923911f 100644
--- a/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
@@ -21,18 +21,14 @@
  * {@link AbstractEventExecutor} which execute tasks in the callers thread.
  */
 public final class ImmediateEventExecutor extends AbstractEventExecutor {
+
     public static final ImmediateEventExecutor INSTANCE = new ImmediateEventExecutor();
 
     private final Future<?> terminationFuture = new FailedFuture<Object>(
             GlobalEventExecutor.INSTANCE, new UnsupportedOperationException());
 
     private ImmediateEventExecutor() {
-        // use static instance
-    }
-
-    @Override
-    public EventExecutorGroup parent() {
-        return null;
+        // Singleton
     }
 
     @Override
diff --git a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
index 38efd4912eda..5782b6fe28d0 100644
--- a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
@@ -17,8 +17,9 @@
 
 import java.util.Collections;
 import java.util.Iterator;
-import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.Set;
+import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -30,31 +31,50 @@
 public abstract class MultithreadEventExecutorGroup extends AbstractEventExecutorGroup {
 
     private final EventExecutor[] children;
+    private final Set<EventExecutor> readonlyChildren;
     private final AtomicInteger childIndex = new AtomicInteger();
     private final AtomicInteger terminatedChildren = new AtomicInteger();
     private final Promise<?> terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE);
+    private final EventExecutorChooser chooser;
 
     /**
      * Create a new instance.
      *
      * @param nThreads          the number of threads that will be used by this instance.
      * @param threadFactory     the ThreadFactory to use, or {@code null} if the default should be used.
-     * @param args              arguments which will passed to each {@link #newChild(ThreadFactory, Object...)} call
+     * @param args              arguments which will passed to each {@link #newChild(Executor, Object...)} call
      */
     protected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
+        this(nThreads, threadFactory == null ? null : new ThreadPerTaskExecutor(threadFactory), args);
+    }
+
+    /**
+     * Create a new instance.
+     *
+     * @param nThreads          the number of threads that will be used by this instance.
+     * @param executor          the Executor to use, or {@code null} if the default should be used.
+     * @param args              arguments which will passed to each {@link #newChild(Executor, Object...)} call
+     */
+    protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {
         if (nThreads <= 0) {
             throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
         }
 
-        if (threadFactory == null) {
-            threadFactory = newDefaultThreadFactory();
+        if (executor == null) {
+            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
+        }
+
+        children = new EventExecutor[nThreads];
+        if (isPowerOfTwo(children.length)) {
+            chooser = new PowerOfTwoEventExecutorChooser();
+        } else {
+            chooser = new GenericEventExecutorChooser();
         }
 
-        children = new SingleThreadEventExecutor[nThreads];
         for (int i = 0; i < nThreads; i ++) {
             boolean success = false;
             try {
-                children[i] = newChild(threadFactory, args);
+                children[i] = newChild(executor, args);
                 success = true;
             } catch (Exception e) {
                 // TODO: Think about if this is a good exception type
@@ -72,6 +92,7 @@ protected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactor
                                 e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                             }
                         } catch (InterruptedException interrupted) {
+                            // Let the caller handle the interruption.
                             Thread.currentThread().interrupt();
                             break;
                         }
@@ -92,6 +113,10 @@ public void operationComplete(Future<Object> future) throws Exception {
         for (EventExecutor e: children) {
             e.terminationFuture().addListener(terminationListener);
         }
+
+        Set<EventExecutor> childrenSet = new LinkedHashSet<EventExecutor>(children.length);
+        Collections.addAll(childrenSet, children);
+        readonlyChildren = Collections.unmodifiableSet(childrenSet);
     }
 
     protected ThreadFactory newDefaultThreadFactory() {
@@ -100,7 +125,7 @@ protected ThreadFactory newDefaultThreadFactory() {
 
     @Override
     public EventExecutor next() {
-        return children[Math.abs(childIndex.getAndIncrement() % children.length)];
+        return chooser.next();
     }
 
     @Override
@@ -116,13 +141,10 @@ public final int executorCount() {
         return children.length;
     }
 
-    /**
-     * Return a safe-copy of all of the children of this group.
-     */
-    protected Set<EventExecutor> children() {
-        Set<EventExecutor> children = Collections.newSetFromMap(new LinkedHashMap<EventExecutor, Boolean>());
-        Collections.addAll(children, this.children);
-        return children;
+    @Override
+    @SuppressWarnings("unchecked")
+    public final <E extends EventExecutor> Set<E> children() {
+        return (Set<E>) readonlyChildren;
     }
 
     /**
@@ -130,8 +152,7 @@ protected Set<EventExecutor> children() {
      * called for each thread that will serve this {@link MultithreadEventExecutorGroup}.
      *
      */
-    protected abstract EventExecutor newChild(
-            ThreadFactory threadFactory, Object... args) throws Exception;
+    protected abstract EventExecutor newChild(Executor executor, Object... args) throws Exception;
 
     @Override
     public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
@@ -201,4 +222,26 @@ public boolean awaitTermination(long timeout, TimeUnit unit)
         }
         return isTerminated();
     }
+
+    private static boolean isPowerOfTwo(int val) {
+        return (val & -val) == val;
+    }
+
+    private interface EventExecutorChooser {
+        EventExecutor next();
+    }
+
+    private final class PowerOfTwoEventExecutorChooser implements EventExecutorChooser {
+        @Override
+        public EventExecutor next() {
+            return children[childIndex.getAndIncrement() & children.length - 1];
+        }
+    }
+
+    private final class GenericEventExecutorChooser implements EventExecutorChooser {
+        @Override
+        public EventExecutor next() {
+            return children[Math.abs(childIndex.getAndIncrement() % children.length)];
+        }
+    }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/ScheduledFuture.java b/common/src/main/java/io/netty/util/concurrent/ScheduledFuture.java
index 6d62d0d21b72..2716532e1aa6 100644
--- a/common/src/main/java/io/netty/util/concurrent/ScheduledFuture.java
+++ b/common/src/main/java/io/netty/util/concurrent/ScheduledFuture.java
@@ -18,5 +18,6 @@
 /**
  * The result of an scheduled asynchronous operation.
  */
+@SuppressWarnings("ClassNameSameAsAncestorName")
 public interface ScheduledFuture<V> extends Future<V>, java.util.concurrent.ScheduledFuture<V> {
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
index 37bf9808151d..c5105786c8bc 100644
--- a/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
@@ -15,6 +15,7 @@
  */
 package io.netty.util.concurrent;
 
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -27,12 +28,14 @@
 import java.util.Set;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
+import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 /**
  * Abstract base class for {@link EventExecutor}'s that execute all its submitted tasks in a single thread.
@@ -56,18 +59,32 @@ public void run() {
         }
     };
 
-    private final EventExecutorGroup parent;
+    private static final AtomicIntegerFieldUpdater<SingleThreadEventExecutor> STATE_UPDATER;
+
+    static {
+        AtomicIntegerFieldUpdater<SingleThreadEventExecutor> updater =
+                PlatformDependent.newAtomicIntegerFieldUpdater(SingleThreadEventExecutor.class, "state");
+        if (updater == null) {
+            updater = AtomicIntegerFieldUpdater.newUpdater(SingleThreadEventExecutor.class, "state");
+        }
+        STATE_UPDATER = updater;
+    }
+
     private final Queue<Runnable> taskQueue;
     final Queue<ScheduledFutureTask<?>> delayedTaskQueue = new PriorityQueue<ScheduledFutureTask<?>>();
 
-    private final Thread thread;
-    private final Object stateLock = new Object();
+    private volatile Thread thread;
+    private final Executor executor;
+    private volatile boolean interrupted;
     private final Semaphore threadLock = new Semaphore(0);
     private final Set<Runnable> shutdownHooks = new LinkedHashSet<Runnable>();
     private final boolean addTaskWakesUp;
 
     private long lastExecutionTime;
+
+    @SuppressWarnings({ "FieldMayBeFinal", "unused" })
     private volatile int state = ST_NOT_STARTED;
+
     private volatile long gracefulShutdownQuietPeriod;
     private volatile long gracefulShutdownTimeout;
     private long gracefulShutdownStartTime;
@@ -84,65 +101,26 @@ public void run() {
      */
     protected SingleThreadEventExecutor(
             EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {
+        this(parent, new ThreadPerTaskExecutor(threadFactory), addTaskWakesUp);
+    }
+
+    /**
+     * Create a new instance
+     *
+     * @param parent            the {@link EventExecutorGroup} which is the parent of this instance and belongs to it
+     * @param executor          the {@link Executor} which will be used for executing
+     * @param addTaskWakesUp    {@code true} if and only if invocation of {@link #addTask(Runnable)} will wake up the
+     *                          executor thread
+     */
+    protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp) {
+        super(parent);
 
-        if (threadFactory == null) {
-            throw new NullPointerException("threadFactory");
+        if (executor == null) {
+            throw new NullPointerException("executor");
         }
 
-        this.parent = parent;
         this.addTaskWakesUp = addTaskWakesUp;
-
-        thread = threadFactory.newThread(new Runnable() {
-            @Override
-            public void run() {
-                boolean success = false;
-                updateLastExecutionTime();
-                try {
-                    SingleThreadEventExecutor.this.run();
-                    success = true;
-                } catch (Throwable t) {
-                    logger.warn("Unexpected exception from an event executor: ", t);
-                } finally {
-                    if (state < ST_SHUTTING_DOWN) {
-                        state = ST_SHUTTING_DOWN;
-                    }
-
-                    // Check if confirmShutdown() was called at the end of the loop.
-                    if (success && gracefulShutdownStartTime == 0) {
-                        logger.error(
-                                "Buggy " + EventExecutor.class.getSimpleName() + " implementation; " +
-                                SingleThreadEventExecutor.class.getSimpleName() + ".confirmShutdown() must be called " +
-                                "before run() implementation terminates.");
-                    }
-
-                    try {
-                        // Run all remaining tasks and shutdown hooks.
-                        for (;;) {
-                            if (confirmShutdown()) {
-                                break;
-                            }
-                        }
-                    } finally {
-                        try {
-                            cleanup();
-                        } finally {
-                            synchronized (stateLock) {
-                                state = ST_TERMINATED;
-                            }
-                            threadLock.release();
-                            if (!taskQueue.isEmpty()) {
-                                logger.warn(
-                                        "An event executor terminated with " +
-                                        "non-empty task queue (" + taskQueue.size() + ')');
-                            }
-
-                            terminationFuture.setSuccess(null);
-                        }
-                    }
-                }
-            }
-        });
-
+        this.executor = executor;
         taskQueue = newTaskQueue();
     }
 
@@ -156,16 +134,16 @@ protected Queue<Runnable> newTaskQueue() {
         return new LinkedBlockingQueue<Runnable>();
     }
 
-    @Override
-    public EventExecutorGroup parent() {
-        return parent;
-    }
-
     /**
      * Interrupt the current running {@link Thread}.
      */
     protected void interruptThread() {
-        thread.interrupt();
+        Thread currentThread = thread;
+        if (currentThread == null) {
+            interrupted = true;
+        } else {
+            currentThread.interrupt();
+        }
     }
 
     /**
@@ -218,6 +196,7 @@ protected Runnable takeTask() {
                     try {
                         task = taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);
                     } catch (InterruptedException e) {
+                        // Waken up.
                         return null;
                     }
                 }
@@ -274,6 +253,16 @@ protected boolean hasTasks() {
         return !taskQueue.isEmpty();
     }
 
+    /**
+     * Returns {@code true} if a scheduled task is ready for processing by {@link #runAllTasks()} or
+     * {@link #runAllTasks(long)}.
+     */
+    protected boolean hasScheduledTasks() {
+        assert inEventLoop();
+        ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();
+        return delayedTask != null && delayedTask.deadlineNanos() <= ScheduledFutureTask.nanoTime();
+    }
+
     /**
      * Return the number of tasks that are pending for processing.
      *
@@ -414,7 +403,7 @@ protected void cleanup() {
     }
 
     protected void wakeup(boolean inEventLoop) {
-        if (!inEventLoop || state == ST_SHUTTING_DOWN) {
+        if (!inEventLoop || STATE_UPDATER.get(this) == ST_SHUTTING_DOWN) {
             taskQueue.add(WAKEUP_TASK);
         }
     }
@@ -498,32 +487,37 @@ public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit uni
         }
 
         boolean inEventLoop = inEventLoop();
-        boolean wakeup = true;
-
-        synchronized (stateLock) {
+        boolean wakeup;
+        int oldState;
+        for (;;) {
             if (isShuttingDown()) {
                 return terminationFuture();
             }
-
-            gracefulShutdownQuietPeriod = unit.toNanos(quietPeriod);
-            gracefulShutdownTimeout = unit.toNanos(timeout);
-
+            int newState;
+            wakeup = true;
+            oldState = STATE_UPDATER.get(this);
             if (inEventLoop) {
-                assert state == ST_STARTED;
-                state = ST_SHUTTING_DOWN;
+                newState = ST_SHUTTING_DOWN;
             } else {
-                switch (state) {
+                switch (oldState) {
                     case ST_NOT_STARTED:
-                        state = ST_SHUTTING_DOWN;
-                        thread.start();
-                        break;
                     case ST_STARTED:
-                        state = ST_SHUTTING_DOWN;
+                        newState = ST_SHUTTING_DOWN;
                         break;
                     default:
+                        newState = oldState;
                         wakeup = false;
                 }
             }
+            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
+                break;
+            }
+        }
+        gracefulShutdownQuietPeriod = unit.toNanos(quietPeriod);
+        gracefulShutdownTimeout = unit.toNanos(timeout);
+
+        if (oldState == ST_NOT_STARTED) {
+            doStartThread();
         }
 
         if (wakeup) {
@@ -546,30 +540,36 @@ public void shutdown() {
         }
 
         boolean inEventLoop = inEventLoop();
-        boolean wakeup = true;
-
-        synchronized (stateLock) {
-            if (isShutdown()) {
+        boolean wakeup;
+        int oldState;
+        for (;;) {
+            if (isShuttingDown()) {
                 return;
             }
-
+            int newState;
+            wakeup = true;
+            oldState = STATE_UPDATER.get(this);
             if (inEventLoop) {
-                assert state == ST_STARTED || state == ST_SHUTTING_DOWN;
-                state = ST_SHUTDOWN;
+                newState = ST_SHUTDOWN;
             } else {
-                switch (state) {
-                case ST_NOT_STARTED:
-                    state = ST_SHUTDOWN;
-                    thread.start();
-                    break;
-                case ST_STARTED:
-                case ST_SHUTTING_DOWN:
-                    state = ST_SHUTDOWN;
-                    break;
-                default:
-                    wakeup = false;
+                switch (oldState) {
+                    case ST_NOT_STARTED:
+                    case ST_STARTED:
+                    case ST_SHUTTING_DOWN:
+                        newState = ST_SHUTDOWN;
+                        break;
+                    default:
+                        newState = oldState;
+                        wakeup = false;
                 }
             }
+            if (STATE_UPDATER.compareAndSet(this, oldState, newState)) {
+                break;
+            }
+        }
+
+        if (oldState == ST_NOT_STARTED) {
+            doStartThread();
         }
 
         if (wakeup) {
@@ -579,17 +579,17 @@ public void shutdown() {
 
     @Override
     public boolean isShuttingDown() {
-        return state >= ST_SHUTTING_DOWN;
+        return STATE_UPDATER.get(this) >= ST_SHUTTING_DOWN;
     }
 
     @Override
     public boolean isShutdown() {
-        return state >= ST_SHUTDOWN;
+        return STATE_UPDATER.get(this) >= ST_SHUTDOWN;
     }
 
     @Override
     public boolean isTerminated() {
-        return state == ST_TERMINATED;
+        return STATE_UPDATER.get(this) == ST_TERMINATED;
     }
 
     /**
@@ -808,17 +808,76 @@ public void run() {
     }
 
     private void startThread() {
-        synchronized (stateLock) {
-            if (state == ST_NOT_STARTED) {
-                state = ST_STARTED;
+        if (STATE_UPDATER.get(this) == ST_NOT_STARTED) {
+            if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) {
                 delayedTaskQueue.add(new ScheduledFutureTask<Void>(
                         this, delayedTaskQueue, Executors.<Void>callable(new PurgeTask(), null),
                         ScheduledFutureTask.deadlineNanos(SCHEDULE_PURGE_INTERVAL), -SCHEDULE_PURGE_INTERVAL));
-                thread.start();
+                doStartThread();
             }
         }
     }
 
+    private void doStartThread() {
+        assert thread == null;
+        executor.execute(new Runnable() {
+            @Override
+            public void run() {
+                thread = Thread.currentThread();
+                if (interrupted) {
+                    thread.interrupt();
+                }
+
+                boolean success = false;
+                updateLastExecutionTime();
+                try {
+                    SingleThreadEventExecutor.this.run();
+                    success = true;
+                } catch (Throwable t) {
+                    logger.warn("Unexpected exception from an event executor: ", t);
+                } finally {
+                    for (;;) {
+                        int oldState = STATE_UPDATER.get(SingleThreadEventExecutor.this);
+                        if (oldState >= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(
+                                SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) {
+                            break;
+                        }
+                    }
+
+                    // Check if confirmShutdown() was called at the end of the loop.
+                    if (success && gracefulShutdownStartTime == 0) {
+                        logger.error("Buggy " + EventExecutor.class.getSimpleName() + " implementation; " +
+                                SingleThreadEventExecutor.class.getSimpleName() + ".confirmShutdown() must be called " +
+                                "before run() implementation terminates.");
+                    }
+
+                    try {
+                        // Run all remaining tasks and shutdown hooks.
+                        for (;;) {
+                            if (confirmShutdown()) {
+                                break;
+                            }
+                        }
+                    } finally {
+                        try {
+                            cleanup();
+                        } finally {
+                            STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);
+                            threadLock.release();
+                            if (!taskQueue.isEmpty()) {
+                                logger.warn(
+                                        "An event executor terminated with " +
+                                                "non-empty task queue (" + taskQueue.size() + ')');
+                            }
+
+                            terminationFuture.setSuccess(null);
+                        }
+                    }
+                }
+            }
+        });
+    }
+
     private final class PurgeTask implements Runnable {
         @Override
         public void run() {
diff --git a/example/src/main/java/io/netty/example/udt/util/UtilThreadFactory.java b/common/src/main/java/io/netty/util/concurrent/ThreadPerTaskExecutor.java
similarity index 55%
rename from example/src/main/java/io/netty/example/udt/util/UtilThreadFactory.java
rename to common/src/main/java/io/netty/util/concurrent/ThreadPerTaskExecutor.java
index 05b08e54b224..21210ae06736 100644
--- a/example/src/main/java/io/netty/example/udt/util/UtilThreadFactory.java
+++ b/common/src/main/java/io/netty/util/concurrent/ThreadPerTaskExecutor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -13,27 +13,23 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
+package io.netty.util.concurrent;
 
-package io.netty.example.udt.util;
-
+import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
-
-/**
- * Custom thread factory to use with examples.
- */
-public class UtilThreadFactory implements ThreadFactory {
-
-    private static final AtomicInteger counter = new AtomicInteger();
 
-    private final String name;
+public final class ThreadPerTaskExecutor implements Executor {
+    private final ThreadFactory threadFactory;
 
-    public UtilThreadFactory(final String name) {
-        this.name = name;
+    public ThreadPerTaskExecutor(ThreadFactory threadFactory) {
+        if (threadFactory == null) {
+            throw new NullPointerException("threadFactory");
+        }
+        this.threadFactory = threadFactory;
     }
 
     @Override
-    public Thread newThread(final Runnable runnable) {
-        return new Thread(runnable, name + '-' + counter.getAndIncrement());
+    public void execute(Runnable command) {
+        threadFactory.newThread(command).start();
     }
 }
diff --git a/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java
index b0c5e9a73bdf..32a5acd04e55 100644
--- a/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java
+++ b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java
@@ -31,6 +31,7 @@ public AppendableCharSequence(int length) {
 
     private AppendableCharSequence(char[] chars) {
         this.chars = chars;
+        pos = chars.length;
     }
 
     @Override
diff --git a/common/src/main/java/io/netty/util/internal/Cleaner0.java b/common/src/main/java/io/netty/util/internal/Cleaner0.java
new file mode 100644
index 000000000000..0812c50531a1
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/Cleaner0.java
@@ -0,0 +1,74 @@
+/*
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+package io.netty.util.internal;
+
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+import sun.misc.Cleaner;
+
+import java.lang.reflect.Field;
+import java.nio.ByteBuffer;
+
+
+/**
+ * Allows to free direct {@link ByteBuffer} by using {@link Cleaner}. This is encapsulated in an extra class to be able
+ * to use {@link PlatformDependent0} on Android without problems.
+ *
+ * For more details see <a href="https://github.com/netty/netty/issues/2604">#2604</a>.
+ */
+final class Cleaner0 {
+    private static final long CLEANER_FIELD_OFFSET;
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(Cleaner0.class);
+
+    static {
+        ByteBuffer direct = ByteBuffer.allocateDirect(1);
+        Field cleanerField;
+        long fieldOffset = -1;
+        if (PlatformDependent0.hasUnsafe()) {
+            try {
+                cleanerField = direct.getClass().getDeclaredField("cleaner");
+                cleanerField.setAccessible(true);
+                Cleaner cleaner = (Cleaner) cleanerField.get(direct);
+                cleaner.clean();
+                fieldOffset = PlatformDependent0.objectFieldOffset(cleanerField);
+            } catch (Throwable t) {
+                // We don't have ByteBuffer.cleaner().
+                fieldOffset = -1;
+            }
+        }
+        logger.debug("java.nio.ByteBuffer.cleaner(): {}", fieldOffset != -1? "available" : "unavailable");
+        CLEANER_FIELD_OFFSET = fieldOffset;
+
+        // free buffer if possible
+        freeDirectBuffer(direct);
+    }
+
+    static void freeDirectBuffer(ByteBuffer buffer) {
+        if (CLEANER_FIELD_OFFSET == -1 || !buffer.isDirect()) {
+            return;
+        }
+        try {
+            Cleaner cleaner = (Cleaner) PlatformDependent0.getObject(buffer, CLEANER_FIELD_OFFSET);
+            if (cleaner != null) {
+                cleaner.clean();
+            }
+        } catch (Throwable t) {
+            // Nothing we can do here.
+        }
+    }
+
+    private Cleaner0() { }
+}
diff --git a/common/src/main/java/io/netty/util/internal/EmptyArrays.java b/common/src/main/java/io/netty/util/internal/EmptyArrays.java
index d4e46685a64b..52c9f24bee2c 100644
--- a/common/src/main/java/io/netty/util/internal/EmptyArrays.java
+++ b/common/src/main/java/io/netty/util/internal/EmptyArrays.java
@@ -17,10 +17,12 @@
 package io.netty.util.internal;
 
 import java.nio.ByteBuffer;
+import java.security.cert.X509Certificate;
 
 public final class EmptyArrays {
 
     public static final byte[] EMPTY_BYTES = new byte[0];
+    public static final char[] EMPTY_CHARS = new char[0];
     public static final boolean[] EMPTY_BOOLEANS = new boolean[0];
     public static final double[] EMPTY_DOUBLES = new double[0];
     public static final float[] EMPTY_FLOATS = new float[0];
@@ -28,9 +30,11 @@ public final class EmptyArrays {
     public static final short[] EMPTY_SHORTS = new short[0];
     public static final long[] EMPTY_LONGS = new long[0];
     public static final Object[] EMPTY_OBJECTS = new Object[0];
+    public static final Class<?>[] EMPTY_CLASSES = new Class[0];
     public static final String[] EMPTY_STRINGS = new String[0];
     public static final StackTraceElement[] EMPTY_STACK_TRACE = new StackTraceElement[0];
     public static final ByteBuffer[] EMPTY_BYTE_BUFFERS = new ByteBuffer[0];
+    public static final X509Certificate[] EMPTY_X509_CERTIFICATES = new X509Certificate[0];
 
     private EmptyArrays() { }
 }
diff --git a/common/src/main/java/io/netty/util/internal/IntegerHolder.java b/common/src/main/java/io/netty/util/internal/IntegerHolder.java
new file mode 100644
index 000000000000..2a8d069a2747
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/IntegerHolder.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+public final class IntegerHolder {
+    public int value;
+}
diff --git a/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java
new file mode 100644
index 000000000000..64f3c77ff135
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java
@@ -0,0 +1,310 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+import io.netty.util.concurrent.FastThreadLocal;
+import io.netty.util.concurrent.FastThreadLocalThread;
+
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CharsetEncoder;
+import java.util.Arrays;
+import java.util.IdentityHashMap;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+/**
+ * The internal data structure that stores the thread-local variables for Netty and all {@link FastThreadLocal}s.
+ * Note that this class is for internal use only and is subject to change at any time.  Use {@link FastThreadLocal}
+ * unless you know what you are doing.
+ */
+public final class InternalThreadLocalMap extends UnpaddedInternalThreadLocalMap {
+
+    public static final Object UNSET = new Object();
+
+    public static InternalThreadLocalMap getIfSet() {
+        Thread thread = Thread.currentThread();
+        InternalThreadLocalMap threadLocalMap;
+        if (thread instanceof FastThreadLocalThread) {
+            threadLocalMap = ((FastThreadLocalThread) thread).threadLocalMap();
+        } else {
+            ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;
+            if (slowThreadLocalMap == null) {
+                threadLocalMap = null;
+            } else {
+                threadLocalMap = slowThreadLocalMap.get();
+            }
+        }
+        return threadLocalMap;
+    }
+
+    public static InternalThreadLocalMap get() {
+        Thread thread = Thread.currentThread();
+        if (thread instanceof FastThreadLocalThread) {
+            return fastGet((FastThreadLocalThread) thread);
+        } else {
+            return slowGet();
+        }
+    }
+
+    private static InternalThreadLocalMap fastGet(FastThreadLocalThread thread) {
+        InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();
+        if (threadLocalMap == null) {
+            thread.setThreadLocalMap(threadLocalMap = new InternalThreadLocalMap());
+        }
+        return threadLocalMap;
+    }
+
+    private static InternalThreadLocalMap slowGet() {
+        ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;
+        if (slowThreadLocalMap == null) {
+            UnpaddedInternalThreadLocalMap.slowThreadLocalMap =
+                    slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();
+        }
+
+        InternalThreadLocalMap ret = slowThreadLocalMap.get();
+        if (ret == null) {
+            ret = new InternalThreadLocalMap();
+            slowThreadLocalMap.set(ret);
+        }
+        return ret;
+    }
+
+    public static void remove() {
+        Thread thread = Thread.currentThread();
+        if (thread instanceof FastThreadLocalThread) {
+            ((FastThreadLocalThread) thread).setThreadLocalMap(null);
+        } else {
+            ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;
+            if (slowThreadLocalMap != null) {
+                slowThreadLocalMap.remove();
+            }
+        }
+    }
+
+    public static void destroy() {
+        slowThreadLocalMap = null;
+    }
+
+    public static int nextVariableIndex() {
+        int index = nextIndex.getAndIncrement();
+        if (index < 0) {
+            nextIndex.decrementAndGet();
+            throw new IllegalStateException("too many thread-local indexed variables");
+        }
+        return index;
+    }
+
+    public static int lastVariableIndex() {
+        return nextIndex.get() - 1;
+    }
+
+    // Cache line padding (must be public)
+    // With CompressedOops enabled, an instance of this class should occupy at least 128 bytes.
+    public long rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8, rp9;
+
+    private InternalThreadLocalMap() {
+        super(newIndexedVariableTable());
+    }
+
+    private static Object[] newIndexedVariableTable() {
+        Object[] array = new Object[32];
+        Arrays.fill(array, UNSET);
+        return array;
+    }
+
+    public int size() {
+        int count = 0;
+
+        if (futureListenerStackDepth != 0) {
+            count ++;
+        }
+        if (localChannelReaderStackDepth != 0) {
+            count ++;
+        }
+        if (handlerSharableCache != null) {
+            count ++;
+        }
+        if (counterHashCode != null) {
+            count ++;
+        }
+        if (random != null) {
+            count ++;
+        }
+        if (typeParameterMatcherGetCache != null) {
+            count ++;
+        }
+        if (typeParameterMatcherFindCache != null) {
+            count ++;
+        }
+        if (stringBuilder != null) {
+            count ++;
+        }
+        if (charsetEncoderCache != null) {
+            count ++;
+        }
+        if (charsetDecoderCache != null) {
+            count ++;
+        }
+
+        for (Object o: indexedVariables) {
+            if (o != UNSET) {
+                count ++;
+            }
+        }
+
+        // We should subtract 1 from the count because the first element in 'indexedVariables' is reserved
+        // by 'FastThreadLocal' to keep the list of 'FastThreadLocal's to remove on 'FastThreadLocal.removeAll()'.
+        return count - 1;
+    }
+
+    public StringBuilder stringBuilder() {
+        StringBuilder builder = stringBuilder;
+        if (builder == null) {
+            stringBuilder = builder = new StringBuilder(512);
+        } else {
+            builder.setLength(0);
+        }
+        return builder;
+    }
+
+    public Map<Charset, CharsetEncoder> charsetEncoderCache() {
+        Map<Charset, CharsetEncoder> cache = charsetEncoderCache;
+        if (cache == null) {
+            charsetEncoderCache = cache = new IdentityHashMap<Charset, CharsetEncoder>();
+        }
+        return cache;
+    }
+
+    public Map<Charset, CharsetDecoder> charsetDecoderCache() {
+        Map<Charset, CharsetDecoder> cache = charsetDecoderCache;
+        if (cache == null) {
+            charsetDecoderCache = cache = new IdentityHashMap<Charset, CharsetDecoder>();
+        }
+        return cache;
+    }
+
+    public int futureListenerStackDepth() {
+        return futureListenerStackDepth;
+    }
+
+    public void setFutureListenerStackDepth(int futureListenerStackDepth) {
+        this.futureListenerStackDepth = futureListenerStackDepth;
+    }
+
+    public ThreadLocalRandom random() {
+        ThreadLocalRandom r = random;
+        if (r == null) {
+            random = r = new ThreadLocalRandom();
+        }
+        return r;
+    }
+
+    public Map<Class<?>, TypeParameterMatcher> typeParameterMatcherGetCache() {
+        Map<Class<?>, TypeParameterMatcher> cache = typeParameterMatcherGetCache;
+        if (cache == null) {
+            typeParameterMatcherGetCache = cache = new IdentityHashMap<Class<?>, TypeParameterMatcher>();
+        }
+        return cache;
+    }
+
+    public Map<Class<?>, Map<String, TypeParameterMatcher>> typeParameterMatcherFindCache() {
+        Map<Class<?>, Map<String, TypeParameterMatcher>> cache = typeParameterMatcherFindCache;
+        if (cache == null) {
+            typeParameterMatcherFindCache = cache = new IdentityHashMap<Class<?>, Map<String, TypeParameterMatcher>>();
+        }
+        return cache;
+    }
+
+    public IntegerHolder counterHashCode() {
+        return counterHashCode;
+    }
+
+    public void setCounterHashCode(IntegerHolder counterHashCode) {
+        this.counterHashCode = counterHashCode;
+    }
+
+    public Map<Class<?>, Boolean> handlerSharableCache() {
+        Map<Class<?>, Boolean> cache = handlerSharableCache;
+        if (cache == null) {
+            // Start with small capacity to keep memory overhead as low as possible.
+            handlerSharableCache = cache = new WeakHashMap<Class<?>, Boolean>(4);
+        }
+        return cache;
+    }
+
+    public int localChannelReaderStackDepth() {
+        return localChannelReaderStackDepth;
+    }
+
+    public void setLocalChannelReaderStackDepth(int localChannelReaderStackDepth) {
+        this.localChannelReaderStackDepth = localChannelReaderStackDepth;
+    }
+
+    public Object indexedVariable(int index) {
+        Object[] lookup = indexedVariables;
+        return index < lookup.length? lookup[index] : UNSET;
+    }
+
+    /**
+     * @return {@code true} if and only if a new thread-local variable has been created
+     */
+    public boolean setIndexedVariable(int index, Object value) {
+        Object[] lookup = indexedVariables;
+        if (index < lookup.length) {
+            Object oldValue = lookup[index];
+            lookup[index] = value;
+            return oldValue == UNSET;
+        } else {
+            expandIndexedVariableTableAndSet(index, value);
+            return true;
+        }
+    }
+
+    private void expandIndexedVariableTableAndSet(int index, Object value) {
+        Object[] oldArray = indexedVariables;
+        final int oldCapacity = oldArray.length;
+        int newCapacity = index;
+        newCapacity |= newCapacity >>>  1;
+        newCapacity |= newCapacity >>>  2;
+        newCapacity |= newCapacity >>>  4;
+        newCapacity |= newCapacity >>>  8;
+        newCapacity |= newCapacity >>> 16;
+        newCapacity ++;
+
+        Object[] newArray = Arrays.copyOf(oldArray, newCapacity);
+        Arrays.fill(newArray, oldCapacity, newArray.length, UNSET);
+        newArray[index] = value;
+        indexedVariables = newArray;
+    }
+
+    public Object removeIndexedVariable(int index) {
+        Object[] lookup = indexedVariables;
+        if (index < lookup.length) {
+            Object v = lookup[index];
+            lookup[index] = UNSET;
+            return v;
+        } else {
+            return UNSET;
+        }
+    }
+
+    public boolean isIndexedVariableSet(int index) {
+        Object[] lookup = indexedVariables;
+        return index < lookup.length && lookup[index] != UNSET;
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java b/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
index e3614b331eec..37ef6ea39aaa 100644
--- a/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
+++ b/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
@@ -46,10 +46,14 @@ public static void appendClassPath(String pathname) throws NotFoundException {
         classPool.appendClassPath(pathname);
     }
 
+    public static ClassPool classPool() {
+        return classPool;
+    }
+
     public static TypeParameterMatcher generate(Class<?> type) {
-        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+        ClassLoader classLoader = PlatformDependent.getContextClassLoader();
         if (classLoader == null) {
-            classLoader = ClassLoader.getSystemClassLoader();
+            classLoader = PlatformDependent.getSystemClassLoader();
         }
         return generate(type, classLoader);
     }
diff --git a/common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java b/common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java
new file mode 100644
index 000000000000..10a7daae90df
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java
@@ -0,0 +1,397 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/**
+ * Copyright (C) 2009-2013 Typesafe Inc. <http://www.typesafe.com>
+ */
+package io.netty.util.internal;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.lang.reflect.Array;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.Queue;
+
+/**
+ * A lock-free concurrent single-consumer multi-producer {@link Queue}.
+ * It allows multiple producer threads to perform the following operations simultaneously:
+ * <ul>
+ * <li>{@link #offer(Object)}, {@link #add(Object)}, and {@link #addAll(Collection)}</li>
+ * <li>All other read-only operations:
+ *     <ul>
+ *     <li>{@link #contains(Object)} and {@link #containsAll(Collection)}</li>
+ *     <li>{@link #element()}, {@link #peek()}</li>
+ *     <li>{@link #size()} and {@link #isEmpty()}</li>
+ *     <li>{@link #iterator()} (except {@link Iterator#remove()}</li>
+ *     <li>{@link #toArray()} and {@link #toArray(Object[])}</li>
+ *     </ul>
+ * </li>
+ * </ul>
+ * .. while only one consumer thread is allowed to perform the following operations exclusively:
+ * <ul>
+ * <li>{@link #poll()} and {@link #remove()}</li>
+ * <li>{@link #remove(Object)}, {@link #removeAll(Collection)}, and {@link #retainAll(Collection)}</li>
+ * <li>{@link #clear()}</li> {@link #}
+ * </ul>
+ *
+ * <strong>The behavior of this implementation is undefined if you perform the operations for a consumer thread only
+ * from multiple threads.</strong>
+ *
+ * The initial implementation is based on:
+ * <ul>
+ *   <li><a href="http://goo.gl/sZE3ie">Non-intrusive MPSC node based queue</a> from 1024cores.net</li>
+ *   <li><a href="http://goo.gl/O0spmV">AbstractNodeQueue</a> from Akka</li>
+ * </ul>
+ * and adopted padded head node changes from:
+ * <ul>
+ * <li><a href="http://goo.gl/bD5ZUV">MpscPaddedQueue</a> from RxJava</li>
+ * </ul>
+ * data structure modified to avoid false sharing between head and tail Ref as per implementation of MpscLinkedQueue
+ * on <a href="https://github.com/JCTools/JCTools">JCTools project</a>.
+ */
+final class MpscLinkedQueue<E> extends MpscLinkedQueueTailRef<E> implements Queue<E> {
+
+    private static final long serialVersionUID = -1878402552271506449L;
+
+    long p00, p01, p02, p03, p04, p05, p06, p07;
+    long p30, p31, p32, p33, p34, p35, p36, p37;
+
+    // offer() occurs at the tail of the linked list.
+    // poll() occurs at the head of the linked list.
+    //
+    // Resulting layout is:
+    //
+    //   head --next--> 1st element --next--> 2nd element --next--> ... tail (last element)
+    //
+    // where the head is a dummy node whose value is null.
+    //
+    // offer() appends a new node next to the tail using AtomicReference.getAndSet()
+    // poll() removes head from the linked list and promotes the 1st element to the head,
+    // setting its value to null if possible.
+    //
+    // Also note that this class extends AtomicReference for the "tail" slot (which is the one that is appended to)
+    // since Unsafe does not expose XCHG operation intrinsically.
+    MpscLinkedQueue() {
+        MpscLinkedQueueNode<E> tombstone = new DefaultNode<E>(null);
+        setHeadRef(tombstone);
+        setTailRef(tombstone);
+    }
+
+    /**
+     * Returns the node right next to the head, which contains the first element of this queue.
+     */
+    private MpscLinkedQueueNode<E> peekNode() {
+        for (;;) {
+            final MpscLinkedQueueNode<E> head = headRef();
+            final MpscLinkedQueueNode<E> next = head.next();
+            if (next != null) {
+                return next;
+            }
+            if (head == tailRef()) {
+                return null;
+            }
+
+            // If we are here, it means:
+            // * offer() is adding the first element, and
+            // * it's between replaceTail(newTail) and oldTail.setNext(newTail).
+            //   (i.e. next == oldTail and oldTail.next == null and head == oldTail != newTail)
+        }
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public boolean offer(E value) {
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+
+        final MpscLinkedQueueNode<E> newTail;
+        if (value instanceof MpscLinkedQueueNode) {
+            newTail = (MpscLinkedQueueNode<E>) value;
+            newTail.setNext(null);
+        } else {
+            newTail = new DefaultNode<E>(value);
+        }
+
+        MpscLinkedQueueNode<E> oldTail = getAndSetTailRef(newTail);
+        oldTail.setNext(newTail);
+        return true;
+    }
+
+    @Override
+    public E poll() {
+        final MpscLinkedQueueNode<E> next = peekNode();
+        if (next == null) {
+            return null;
+        }
+
+        // next becomes a new head.
+        MpscLinkedQueueNode<E> oldHead = headRef();
+        // Similar to 'headRef.node = next', but slightly faster (storestore vs loadstore)
+        // See: http://robsjava.blogspot.com/2013/06/a-faster-volatile.html
+        // See: http://psy-lob-saw.blogspot.com/2012/12/atomiclazyset-is-performance-win-for.html
+        lazySetHeadRef(next);
+
+        // Break the linkage between the old head and the new head.
+        oldHead.unlink();
+
+        return next.clearMaybe();
+    }
+
+    @Override
+    public E peek() {
+        final MpscLinkedQueueNode<E> next = peekNode();
+        if (next == null) {
+            return null;
+        }
+        return next.value();
+    }
+
+    @Override
+    public int size() {
+        int count = 0;
+        MpscLinkedQueueNode<E> n = peekNode();
+        for (;;) {
+            if (n == null) {
+                break;
+            }
+            count ++;
+            n = n.next();
+        }
+        return count;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return peekNode() == null;
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        MpscLinkedQueueNode<E> n = peekNode();
+        for (;;) {
+            if (n == null) {
+                break;
+            }
+            if (n.value() == o) {
+                return true;
+            }
+            n = n.next();
+        }
+        return false;
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return new Iterator<E>() {
+            private MpscLinkedQueueNode<E> node = peekNode();
+
+            @Override
+            public boolean hasNext() {
+                return node != null;
+            }
+
+            @Override
+            public E next() {
+                MpscLinkedQueueNode<E> node = this.node;
+                if (node == null) {
+                    throw new NoSuchElementException();
+                }
+                E value = node.value();
+                this.node = node.next();
+                return value;
+            }
+
+            @Override
+            public void remove() {
+                throw new UnsupportedOperationException();
+            }
+        };
+    }
+
+    @Override
+    public boolean add(E e) {
+        if (offer(e)) {
+            return true;
+        }
+        throw new IllegalStateException("queue full");
+    }
+
+    @Override
+    public E remove() {
+        E e = poll();
+        if (e != null) {
+            return e;
+        }
+        throw new NoSuchElementException();
+    }
+
+    @Override
+    public E element() {
+        E e = peek();
+        if (e != null) {
+            return e;
+        }
+        throw new NoSuchElementException();
+    }
+
+    @Override
+    public Object[] toArray() {
+        final Object[] array = new Object[size()];
+        final Iterator<E> it = iterator();
+        for (int i = 0; i < array.length; i ++) {
+            if (it.hasNext()) {
+                array[i] = it.next();
+            } else {
+                return Arrays.copyOf(array, i);
+            }
+        }
+        return array;
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T> T[] toArray(T[] a) {
+        final int size = size();
+        final T[] array;
+        if (a.length >= size) {
+            array = a;
+        } else {
+            array = (T[]) Array.newInstance(a.getClass().getComponentType(), size);
+        }
+
+        final Iterator<E> it = iterator();
+        for (int i = 0; i < array.length; i++) {
+            if (it.hasNext()) {
+                array[i] = (T) it.next();
+            } else {
+                if (a == array) {
+                    array[i] = null;
+                    return array;
+                }
+
+                if (a.length < i) {
+                    return Arrays.copyOf(array, i);
+                }
+
+                System.arraycopy(array, 0, a, 0, i);
+                if (a.length > i) {
+                    a[i] = null;
+                }
+                return a;
+            }
+        }
+        return array;
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        for (Object e: c) {
+            if (!contains(e)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends E> c) {
+        if (c == null) {
+            throw new NullPointerException("c");
+        }
+        if (c == this) {
+            throw new IllegalArgumentException("c == this");
+        }
+
+        boolean modified = false;
+        for (E e: c) {
+            add(e);
+            modified = true;
+        }
+        return modified;
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void clear() {
+        while (poll() != null) {
+            continue;
+        }
+    }
+
+    private void writeObject(ObjectOutputStream out) throws IOException {
+        out.defaultWriteObject();
+        for (E e: this) {
+            out.writeObject(e);
+        }
+        out.writeObject(null);
+    }
+
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+
+        final MpscLinkedQueueNode<E> tombstone = new DefaultNode<E>(null);
+        setHeadRef(tombstone);
+        setTailRef(tombstone);
+
+        for (;;) {
+            @SuppressWarnings("unchecked")
+            E e = (E) in.readObject();
+            if (e == null) {
+                break;
+            }
+            add(e);
+        }
+    }
+
+    private static final class DefaultNode<T> extends MpscLinkedQueueNode<T> {
+
+        private T value;
+
+        DefaultNode(T value) {
+            this.value = value;
+        }
+
+        @Override
+        public T value() {
+            return value;
+        }
+
+        @Override
+        protected T clearMaybe() {
+            T value = this.value;
+            this.value = null;
+            return value;
+        }
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/MpscLinkedQueueHeadRef.java b/common/src/main/java/io/netty/util/internal/MpscLinkedQueueHeadRef.java
new file mode 100644
index 000000000000..cf8d4a91b25b
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/MpscLinkedQueueHeadRef.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+import java.io.Serializable;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+
+
+abstract class MpscLinkedQueueHeadRef<E> extends MpscLinkedQueuePad0<E> implements Serializable {
+
+    private static final long serialVersionUID = 8467054865577874285L;
+
+    @SuppressWarnings("rawtypes")
+    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueHeadRef, MpscLinkedQueueNode> UPDATER;
+
+    static {
+        @SuppressWarnings("rawtypes")
+        AtomicReferenceFieldUpdater<MpscLinkedQueueHeadRef, MpscLinkedQueueNode> updater;
+        updater = PlatformDependent.newAtomicReferenceFieldUpdater(MpscLinkedQueueHeadRef.class, "headRef");
+        if (updater == null) {
+            updater = AtomicReferenceFieldUpdater.newUpdater(
+                    MpscLinkedQueueHeadRef.class, MpscLinkedQueueNode.class, "headRef");
+        }
+        UPDATER = updater;
+    }
+
+    private transient  volatile MpscLinkedQueueNode<E> headRef;
+
+    protected final MpscLinkedQueueNode<E> headRef() {
+        return headRef;
+    }
+
+    protected final void setHeadRef(MpscLinkedQueueNode<E> headRef) {
+        this.headRef = headRef;
+    }
+
+    protected final void lazySetHeadRef(MpscLinkedQueueNode<E> headRef) {
+        UPDATER.lazySet(this, headRef);
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/MpscLinkedQueueNode.java b/common/src/main/java/io/netty/util/internal/MpscLinkedQueueNode.java
new file mode 100644
index 000000000000..050f604bc12c
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/MpscLinkedQueueNode.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+
+public abstract class MpscLinkedQueueNode<T> {
+
+    @SuppressWarnings("rawtypes")
+    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueNode, MpscLinkedQueueNode> nextUpdater;
+
+    static {
+        @SuppressWarnings("rawtypes")
+        AtomicReferenceFieldUpdater<MpscLinkedQueueNode, MpscLinkedQueueNode> u;
+
+        u = PlatformDependent.newAtomicReferenceFieldUpdater(MpscLinkedQueueNode.class, "next");
+        if (u == null) {
+            u = AtomicReferenceFieldUpdater.newUpdater(MpscLinkedQueueNode.class, MpscLinkedQueueNode.class, "next");
+        }
+        nextUpdater = u;
+    }
+
+    @SuppressWarnings("unused")
+    private volatile MpscLinkedQueueNode<T> next;
+
+    final MpscLinkedQueueNode<T> next() {
+        return next;
+    }
+
+    final void setNext(final MpscLinkedQueueNode<T> newNext) {
+        // Similar to 'next = newNext', but slightly faster (storestore vs loadstore)
+        // See: http://robsjava.blogspot.com/2013/06/a-faster-volatile.html
+        nextUpdater.lazySet(this, newNext);
+    }
+
+    public abstract T value();
+
+    /**
+     * Sets the element this node contains to {@code null} so that the node can be used as a tombstone.
+     */
+    protected T clearMaybe() {
+        return value();
+    }
+
+    /**
+     * Unlink to allow GC'ed
+     */
+    void unlink() {
+        setNext(null);
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/MpscLinkedQueuePad0.java b/common/src/main/java/io/netty/util/internal/MpscLinkedQueuePad0.java
new file mode 100644
index 000000000000..04631e78e49d
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/MpscLinkedQueuePad0.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+abstract class MpscLinkedQueuePad0<E> {
+    long p00, p01, p02, p03, p04, p05, p06, p07;
+    long p30, p31, p32, p33, p34, p35, p36, p37;
+}
diff --git a/common/src/main/java/io/netty/util/internal/MpscLinkedQueuePad1.java b/common/src/main/java/io/netty/util/internal/MpscLinkedQueuePad1.java
new file mode 100644
index 000000000000..66b486b5cfa8
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/MpscLinkedQueuePad1.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+abstract class MpscLinkedQueuePad1<E> extends MpscLinkedQueueHeadRef<E> {
+
+    private static final long serialVersionUID = 2886694927079691637L;
+
+    long p00, p01, p02, p03, p04, p05, p06, p07;
+    long p30, p31, p32, p33, p34, p35, p36, p37;
+}
diff --git a/common/src/main/java/io/netty/util/internal/MpscLinkedQueueTailRef.java b/common/src/main/java/io/netty/util/internal/MpscLinkedQueueTailRef.java
new file mode 100644
index 000000000000..4dd99c26aa57
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/MpscLinkedQueueTailRef.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+
+abstract class MpscLinkedQueueTailRef<E> extends MpscLinkedQueuePad1<E> {
+
+    private static final long serialVersionUID = 8717072462993327429L;
+
+    @SuppressWarnings("rawtypes")
+    private static final AtomicReferenceFieldUpdater<MpscLinkedQueueTailRef, MpscLinkedQueueNode> UPDATER;
+
+    static {
+        @SuppressWarnings("rawtypes")
+        AtomicReferenceFieldUpdater<MpscLinkedQueueTailRef, MpscLinkedQueueNode> updater;
+        updater = PlatformDependent.newAtomicReferenceFieldUpdater(MpscLinkedQueueTailRef.class, "tailRef");
+        if (updater == null) {
+            updater = AtomicReferenceFieldUpdater.newUpdater(
+                    MpscLinkedQueueTailRef.class, MpscLinkedQueueNode.class, "tailRef");
+        }
+        UPDATER = updater;
+    }
+
+    private transient volatile MpscLinkedQueueNode<E> tailRef;
+
+    protected final MpscLinkedQueueNode<E> tailRef() {
+        return tailRef;
+    }
+
+    protected final void setTailRef(MpscLinkedQueueNode<E> tailRef) {
+        this.tailRef = tailRef;
+    }
+
+    @SuppressWarnings("unchecked")
+    protected final MpscLinkedQueueNode<E> getAndSetTailRef(MpscLinkedQueueNode<E> tailRef) {
+        // LOCK XCHG in JDK8, a CAS loop in JDK 7/6
+        return (MpscLinkedQueueNode<E>) UPDATER.getAndSet(this, tailRef);
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
new file mode 100644
index 000000000000..8a7cee2ef793
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.internal;
+
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.Locale;
+
+/**
+ * Helper class to load JNI resources.
+ *
+ */
+public final class NativeLibraryLoader {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(NativeLibraryLoader.class);
+
+    private static final String NATIVE_RESOURCE_HOME = "META-INF/native/";
+    private static final String OSNAME;
+    private static final File WORKDIR;
+
+    static {
+        OSNAME = SystemPropertyUtil.get("os.name", "").toLowerCase(Locale.US).replaceAll("[^a-z0-9]+", "");
+
+        String workdir = SystemPropertyUtil.get("io.netty.native.workdir");
+        if (workdir != null) {
+            File f = new File(workdir);
+            if (!f.exists()) {
+                // ok to ignore as createTempFile will take care
+                //noinspection ResultOfMethodCallIgnored
+                f.mkdirs();
+            }
+
+            try {
+                f = f.getAbsoluteFile();
+            } catch (Exception ignored) {
+                // Good to have an absolute path, but it's OK.
+            }
+
+            WORKDIR = f;
+            logger.debug("-Dio.netty.netty.workdir: " + WORKDIR);
+        } else {
+            WORKDIR = tmpdir();
+            logger.debug("-Dio.netty.netty.workdir: " + WORKDIR + " (io.netty.tmpdir)");
+        }
+    }
+
+    private static File tmpdir() {
+        File f;
+        try {
+            f = toDirectory(SystemPropertyUtil.get("io.netty.tmpdir"));
+            if (f != null) {
+                logger.debug("-Dio.netty.tmpdir: " + f);
+                return f;
+            }
+
+            f = toDirectory(SystemPropertyUtil.get("java.io.tmpdir"));
+            if (f != null) {
+                logger.debug("-Dio.netty.tmpdir: " + f + " (java.io.tmpdir)");
+                return f;
+            }
+
+            // This shouldn't happen, but just in case ..
+            if (isWindows()) {
+                f = toDirectory(System.getenv("TEMP"));
+                if (f != null) {
+                    logger.debug("-Dio.netty.tmpdir: " + f + " (%TEMP%)");
+                    return f;
+                }
+
+                String userprofile = System.getenv("USERPROFILE");
+                if (userprofile != null) {
+                    f = toDirectory(userprofile + "\\AppData\\Local\\Temp");
+                    if (f != null) {
+                        logger.debug("-Dio.netty.tmpdir: " + f + " (%USERPROFILE%\\AppData\\Local\\Temp)");
+                        return f;
+                    }
+
+                    f = toDirectory(userprofile + "\\Local Settings\\Temp");
+                    if (f != null) {
+                        logger.debug("-Dio.netty.tmpdir: " + f + " (%USERPROFILE%\\Local Settings\\Temp)");
+                        return f;
+                    }
+                }
+            } else {
+                f = toDirectory(System.getenv("TMPDIR"));
+                if (f != null) {
+                    logger.debug("-Dio.netty.tmpdir: " + f + " ($TMPDIR)");
+                    return f;
+                }
+            }
+        } catch (Exception ignored) {
+            // Environment variable inaccessible
+        }
+
+        // Last resort.
+        if (isWindows()) {
+            f = new File("C:\\Windows\\Temp");
+        } else {
+            f = new File("/tmp");
+        }
+
+        logger.warn("Failed to get the temporary directory; falling back to: " + f);
+        return f;
+    }
+
+    @SuppressWarnings("ResultOfMethodCallIgnored")
+    private static File toDirectory(String path) {
+        if (path == null) {
+            return null;
+        }
+
+        File f = new File(path);
+        if (!f.exists()) {
+            f.mkdirs();
+        }
+
+        if (!f.isDirectory()) {
+            return null;
+        }
+
+        try {
+            return f.getAbsoluteFile();
+        } catch (Exception ignored) {
+            return f;
+        }
+    }
+
+    private static boolean isWindows() {
+        return OSNAME.startsWith("windows");
+    }
+
+    private static boolean isOSX() {
+        return OSNAME.startsWith("macosx") || OSNAME.startsWith("osx");
+    }
+
+    /**
+     * Load the given library with the specified {@link java.lang.ClassLoader}
+     */
+    public static void load(String name, ClassLoader loader) {
+        String libname = System.mapLibraryName(name);
+        String path = NATIVE_RESOURCE_HOME + libname;
+
+        URL url = loader.getResource(path);
+        if (url == null && isOSX()) {
+            if (path.endsWith(".jnilib")) {
+                url = loader.getResource(NATIVE_RESOURCE_HOME + "lib" + name + ".dynlib");
+            } else {
+                url = loader.getResource(NATIVE_RESOURCE_HOME + "lib" + name + ".jnilib");
+            }
+        }
+
+        if (url == null) {
+            // Fall back to normal loading of JNI stuff
+            System.loadLibrary(name);
+            return;
+        }
+
+        int index = libname.lastIndexOf('.');
+        String prefix = libname.substring(0, index);
+        String suffix = libname.substring(index, libname.length());
+        InputStream in = null;
+        OutputStream out = null;
+        File tmpFile = null;
+        boolean loaded = false;
+        try {
+            tmpFile = File.createTempFile(prefix, suffix, WORKDIR);
+            in = url.openStream();
+            out = new FileOutputStream(tmpFile);
+
+            byte[] buffer = new byte[8192];
+            int length;
+            while ((length = in.read(buffer)) > 0) {
+                out.write(buffer, 0, length);
+            }
+            out.flush();
+            out.close();
+            out = null;
+
+            System.load(tmpFile.getPath());
+            loaded = true;
+        } catch (Exception e) {
+            throw (UnsatisfiedLinkError) new UnsatisfiedLinkError(
+                    "could not load a native library: " + name).initCause(e);
+        } finally {
+            if (in != null) {
+                try {
+                    in.close();
+                } catch (IOException ignore) {
+                    // ignore
+                }
+            }
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException ignore) {
+                    // ignore
+                }
+            }
+            if (tmpFile != null) {
+                if (loaded) {
+                    tmpFile.deleteOnExit();
+                } else {
+                    if (!tmpFile.delete()) {
+                        tmpFile.deleteOnExit();
+                    }
+                }
+            }
+        }
+    }
+
+    private NativeLibraryLoader() {
+        // Utility
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/OneTimeTask.java b/common/src/main/java/io/netty/util/internal/OneTimeTask.java
new file mode 100644
index 000000000000..d9473bd45ca8
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/OneTimeTask.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.internal;
+
+import io.netty.util.concurrent.EventExecutor;
+
+/**
+ * {@link Runnable} which represent a one time task which may allow the {@link EventExecutor} to reduce the amount of
+ * produced garbage when queue it for execution.
+ *
+ * <strong>It is important this will not be reused. After submitted it is not allowed to get submitted again!</strong>
+ */
+public abstract class OneTimeTask extends MpscLinkedQueueNode<Runnable> implements Runnable {
+
+    @Override
+    public Runnable value() {
+        return this;
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/PendingWrite.java b/common/src/main/java/io/netty/util/internal/PendingWrite.java
index c731dab60fa7..8621aba5852e 100644
--- a/common/src/main/java/io/netty/util/internal/PendingWrite.java
+++ b/common/src/main/java/io/netty/util/internal/PendingWrite.java
@@ -25,7 +25,7 @@
 public final class PendingWrite {
     private static final Recycler<PendingWrite> RECYCLER = new Recycler<PendingWrite>() {
         @Override
-        protected PendingWrite newObject(Handle handle) {
+        protected PendingWrite newObject(Handle<PendingWrite> handle) {
             return new PendingWrite(handle);
         }
     };
@@ -40,11 +40,11 @@ public static PendingWrite newInstance(Object msg, Promise<Void> promise) {
         return pending;
     }
 
-    private final Recycler.Handle handle;
+    private final Recycler.Handle<PendingWrite> handle;
     private Object msg;
     private Promise<Void> promise;
 
-    private PendingWrite(Recycler.Handle handle) {
+    private PendingWrite(Recycler.Handle<PendingWrite> handle) {
         this.handle = handle;
     }
 
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 667162aad51b..812c75f5e19b 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -21,6 +21,7 @@
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.lang.reflect.Field;
@@ -31,6 +32,7 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Queue;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
@@ -74,12 +76,16 @@ public final class PlatformDependent {
 
     private static final boolean HAS_JAVASSIST = hasJavassist0();
 
+    private static final File TMPDIR = tmpdir0();
+
+    private static final int BIT_MODE = bitMode0();
+
     static {
         if (logger.isDebugEnabled()) {
             logger.debug("-Dio.netty.noPreferDirect: {}", !DIRECT_BUFFER_PREFERRED);
         }
 
-        if (!hasUnsafe()) {
+        if (!hasUnsafe() && !isAndroid()) {
             logger.info(
                     "Your platform does not provide complete low-level API for accessing direct buffers reliably. " +
                     "Unless explicitly requested, heap buffer will always be preferred to avoid potential system " +
@@ -153,6 +159,20 @@ public static boolean hasJavassist() {
         return HAS_JAVASSIST;
     }
 
+    /**
+     * Returns the temporary directory.
+     */
+    public static File tmpdir() {
+        return TMPDIR;
+    }
+
+    /**
+     * Returns the bit mode of the current VM (usually 32 or 64.)
+     */
+    public static int bitMode() {
+        return BIT_MODE;
+    }
+
     /**
      * Raises an exception bypassing compiler checks for checked exceptions.
      */
@@ -230,12 +250,10 @@ public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(Map<? extends K, ?
      * the current platform does not support this operation or the specified buffer is not a direct buffer.
      */
     public static void freeDirectBuffer(ByteBuffer buffer) {
-        if (buffer.isDirect()) {
-            if (hasUnsafe()) {
-                PlatformDependent0.freeDirectBufferUnsafe(buffer);
-            } else {
-                PlatformDependent0.freeDirectBuffer(buffer);
-            }
+        if (hasUnsafe() && !isAndroid()) {
+            // only direct to method if we are not running on android.
+            // See https://github.com/netty/netty/issues/2604
+            PlatformDependent0.freeDirectBuffer(buffer);
         }
     }
 
@@ -247,6 +265,10 @@ public static Object getObject(Object object, long fieldOffset) {
         return PlatformDependent0.getObject(object, fieldOffset);
     }
 
+    public static Object getObjectVolatile(Object object, long fieldOffset) {
+        return PlatformDependent0.getObjectVolatile(object, fieldOffset);
+    }
+
     public static int getInt(Object object, long fieldOffset) {
         return PlatformDependent0.getInt(object, fieldOffset);
     }
@@ -271,6 +293,10 @@ public static long getLong(long address) {
         return PlatformDependent0.getLong(address);
     }
 
+    public static void putOrderedObject(Object object, long address, Object value) {
+        PlatformDependent0.putOrderedObject(object, address, value);
+    }
+
     public static void putByte(long address, byte value) {
         PlatformDependent0.putByte(address, value);
     }
@@ -350,10 +376,39 @@ public static <T> AtomicLongFieldUpdater<T> newAtomicLongFieldUpdater(
         return null;
     }
 
+    /**
+     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single
+     * consumer (one thread!).
+     */
+    public static <T> Queue<T> newMpscQueue() {
+        return new MpscLinkedQueue<T>();
+    }
+
+    /**
+     * Return the {@link ClassLoader} for the given {@link Class}.
+     */
+    public static ClassLoader getClassLoader(final Class<?> clazz) {
+        return PlatformDependent0.getClassLoader(clazz);
+    }
+
+    /**
+     * Return the context {@link ClassLoader} for the current {@link Thread}.
+     */
+    public static ClassLoader getContextClassLoader() {
+        return PlatformDependent0.getContextClassLoader();
+    }
+
+    /**
+     * Return the system {@link ClassLoader}.
+     */
+    public static ClassLoader getSystemClassLoader() {
+        return PlatformDependent0.getSystemClassLoader();
+    }
+
     private static boolean isAndroid0() {
         boolean android;
         try {
-            Class.forName("android.app.Application", false, ClassLoader.getSystemClassLoader());
+            Class.forName("android.app.Application", false, getSystemClassLoader());
             android = true;
         } catch (Exception e) {
             // Failed to load the class uniquely available in Android.
@@ -480,7 +535,7 @@ private static int javaVersion0() {
             }
 
             try {
-                Class.forName("java.time.Clock", false, Object.class.getClassLoader());
+                Class.forName("java.time.Clock", false, getClassLoader(Object.class));
                 javaVersion = 8;
                 break;
             } catch (Exception e) {
@@ -488,7 +543,7 @@ private static int javaVersion0() {
             }
 
             try {
-                Class.forName("java.util.concurrent.LinkedTransferQueue", false, BlockingQueue.class.getClassLoader());
+                Class.forName("java.util.concurrent.LinkedTransferQueue", false, getClassLoader(BlockingQueue.class));
                 javaVersion = 7;
                 break;
             } catch (Exception e) {
@@ -554,7 +609,7 @@ private static long maxDirectMemory0() {
         long maxDirectMemory = 0;
         try {
             // Try to get from sun.misc.VM.maxDirectMemory() which should be most accurate.
-            Class<?> vmClass = Class.forName("sun.misc.VM", true, ClassLoader.getSystemClassLoader());
+            Class<?> vmClass = Class.forName("sun.misc.VM", true, getSystemClassLoader());
             Method m = vmClass.getDeclaredMethod("maxDirectMemory");
             maxDirectMemory = ((Number) m.invoke(null)).longValue();
         } catch (Throwable t) {
@@ -569,9 +624,9 @@ private static long maxDirectMemory0() {
             // Now try to get the JVM option (-XX:MaxDirectMemorySize) and parse it.
             // Note that we are using reflection because Android doesn't have these classes.
             Class<?> mgmtFactoryClass = Class.forName(
-                    "java.lang.management.ManagementFactory", true, ClassLoader.getSystemClassLoader());
+                    "java.lang.management.ManagementFactory", true, getSystemClassLoader());
             Class<?> runtimeClass = Class.forName(
-                    "java.lang.management.RuntimeMXBean", true, ClassLoader.getSystemClassLoader());
+                    "java.lang.management.RuntimeMXBean", true, getSystemClassLoader());
 
             Object runtime = mgmtFactoryClass.getDeclaredMethod("getRuntimeMXBean").invoke(null);
 
@@ -625,7 +680,7 @@ private static boolean hasJavassist0() {
         }
 
         try {
-            JavassistTypeParameterMatcherGenerator.generate(Object.class, PlatformDependent.class.getClassLoader());
+            JavassistTypeParameterMatcherGenerator.generate(Object.class, getClassLoader(PlatformDependent.class));
             logger.debug("Javassist: available");
             return true;
         } catch (Throwable t) {
@@ -638,6 +693,130 @@ private static boolean hasJavassist0() {
         }
     }
 
+    private static File tmpdir0() {
+        File f;
+        try {
+            f = toDirectory(SystemPropertyUtil.get("io.netty.tmpdir"));
+            if (f != null) {
+                logger.debug("-Dio.netty.tmpdir: {}", f);
+                return f;
+            }
+
+            f = toDirectory(SystemPropertyUtil.get("java.io.tmpdir"));
+            if (f != null) {
+                logger.debug("-Dio.netty.tmpdir: {} (java.io.tmpdir)", f);
+                return f;
+            }
+
+            // This shouldn't happen, but just in case ..
+            if (isWindows()) {
+                f = toDirectory(System.getenv("TEMP"));
+                if (f != null) {
+                    logger.debug("-Dio.netty.tmpdir: {} (%TEMP%)", f);
+                    return f;
+                }
+
+                String userprofile = System.getenv("USERPROFILE");
+                if (userprofile != null) {
+                    f = toDirectory(userprofile + "\\AppData\\Local\\Temp");
+                    if (f != null) {
+                        logger.debug("-Dio.netty.tmpdir: {} (%USERPROFILE%\\AppData\\Local\\Temp)", f);
+                        return f;
+                    }
+
+                    f = toDirectory(userprofile + "\\Local Settings\\Temp");
+                    if (f != null) {
+                        logger.debug("-Dio.netty.tmpdir: {} (%USERPROFILE%\\Local Settings\\Temp)", f);
+                        return f;
+                    }
+                }
+            } else {
+                f = toDirectory(System.getenv("TMPDIR"));
+                if (f != null) {
+                    logger.debug("-Dio.netty.tmpdir: {} ($TMPDIR)", f);
+                    return f;
+                }
+            }
+        } catch (Exception ignored) {
+            // Environment variable inaccessible
+        }
+
+        // Last resort.
+        if (isWindows()) {
+            f = new File("C:\\Windows\\Temp");
+        } else {
+            f = new File("/tmp");
+        }
+
+        logger.warn("Failed to get the temporary directory; falling back to: {}", f);
+        return f;
+    }
+
+    @SuppressWarnings("ResultOfMethodCallIgnored")
+    private static File toDirectory(String path) {
+        if (path == null) {
+            return null;
+        }
+
+        File f = new File(path);
+        if (!f.exists()) {
+            f.mkdirs();
+        }
+
+        if (!f.isDirectory()) {
+            return null;
+        }
+
+        try {
+            return f.getAbsoluteFile();
+        } catch (Exception ignored) {
+            return f;
+        }
+    }
+
+    private static int bitMode0() {
+        // Check user-specified bit mode first.
+        int bitMode = SystemPropertyUtil.getInt("io.netty.bitMode", 0);
+        if (bitMode > 0) {
+            logger.debug("-Dio.netty.bitMode: {}", bitMode);
+            return bitMode;
+        }
+
+        // And then the vendor specific ones which is probably most reliable.
+        bitMode = SystemPropertyUtil.getInt("sun.arch.data.model", 0);
+        if (bitMode > 0) {
+            logger.debug("-Dio.netty.bitMode: {} (sun.arch.data.model)", bitMode);
+            return bitMode;
+        }
+        bitMode = SystemPropertyUtil.getInt("com.ibm.vm.bitmode", 0);
+        if (bitMode > 0) {
+            logger.debug("-Dio.netty.bitMode: {} (com.ibm.vm.bitmode)", bitMode);
+            return bitMode;
+        }
+
+        // os.arch also gives us a good hint.
+        String arch = SystemPropertyUtil.get("os.arch", "").toLowerCase(Locale.US).trim();
+        if ("amd64".equals(arch) || "x86_64".equals(arch)) {
+            bitMode = 64;
+        } else if ("i386".equals(arch) || "i486".equals(arch) || "i586".equals(arch) || "i686".equals(arch)) {
+            bitMode = 32;
+        }
+
+        if (bitMode > 0) {
+            logger.debug("-Dio.netty.bitMode: {} (os.arch: {})", bitMode, arch);
+        }
+
+        // Last resort: guess from VM name and then fall back to most common 64-bit mode.
+        String vm = SystemPropertyUtil.get("java.vm.name", "").toLowerCase(Locale.US);
+        Pattern BIT_PATTERN = Pattern.compile("([1-9][0-9]+)-?bit");
+        Matcher m = BIT_PATTERN.matcher(vm);
+        if (m.find()) {
+            return Integer.parseInt(m.group(1));
+        } else {
+            return 64;
+        }
+    }
+
     private PlatformDependent() {
         // only static method supported
     }
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index bf3abc10849b..f58be03d6611 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -17,15 +17,15 @@
 
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
-import sun.misc.Cleaner;
 import sun.misc.Unsafe;
-import sun.nio.ch.DirectBuffer;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
@@ -40,6 +40,12 @@ final class PlatformDependent0 {
     private static final boolean BIG_ENDIAN = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
     private static final long ADDRESS_FIELD_OFFSET;
 
+    /**
+     * Limits the number of bytes to copy per {@link Unsafe#copyMemory(long, long, long)} to allow safepoint polling
+     * during a large copy.
+     */
+    private static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;
+
     /**
      * {@code true} if and only if the platform supports unaligned access.
      *
@@ -49,38 +55,27 @@ final class PlatformDependent0 {
 
     static {
         ByteBuffer direct = ByteBuffer.allocateDirect(1);
-        Field cleanerField;
-        try {
-            cleanerField = direct.getClass().getDeclaredField("cleaner");
-            cleanerField.setAccessible(true);
-            Cleaner cleaner = (Cleaner) cleanerField.get(direct);
-            cleaner.clean();
-        } catch (Throwable t) {
-            cleanerField = null;
-        }
-        logger.debug("java.nio.ByteBuffer.cleaner: {}", cleanerField != null? "available" : "unavailable");
-
         Field addressField;
         try {
             addressField = Buffer.class.getDeclaredField("address");
             addressField.setAccessible(true);
             if (addressField.getLong(ByteBuffer.allocate(1)) != 0) {
+                // A heap buffer must have 0 address.
                 addressField = null;
             } else {
-                direct = ByteBuffer.allocateDirect(1);
                 if (addressField.getLong(direct) == 0) {
+                    // A direct buffer must have non-zero address.
                     addressField = null;
                 }
-                Cleaner cleaner = (Cleaner) cleanerField.get(direct);
-                cleaner.clean();
             }
         } catch (Throwable t) {
+            // Failed to access the address field.
             addressField = null;
         }
         logger.debug("java.nio.Buffer.address: {}", addressField != null? "available" : "unavailable");
 
         Unsafe unsafe;
-        if (addressField != null && cleanerField != null) {
+        if (addressField != null) {
             try {
                 Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
                 unsafeField.setAccessible(true);
@@ -92,8 +87,7 @@ final class PlatformDependent0 {
                 // http://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html
                 try {
                     unsafe.getClass().getDeclaredMethod(
-                            "copyMemory",
-                            new Class[] { Object.class, long.class, Object.class, long.class, long.class });
+                            "copyMemory", Object.class, long.class, Object.class, long.class, long.class);
 
                     logger.debug("sun.misc.Unsafe.copyMemory: available");
                 } catch (NoSuchMethodError t) {
@@ -104,6 +98,7 @@ final class PlatformDependent0 {
                     throw e;
                 }
             } catch (Throwable cause) {
+                // Unsafe.copyMemory(Object, long, Object, long, long) unavailable.
                 unsafe = null;
             }
         } else {
@@ -111,6 +106,7 @@ final class PlatformDependent0 {
             // Let's just pretend unsafe is unavailable for overall simplicity.
             unsafe = null;
         }
+
         UNSAFE = unsafe;
 
         if (unsafe == null) {
@@ -144,33 +140,10 @@ static void throwException(Throwable t) {
         UNSAFE.throwException(t);
     }
 
-    static void freeDirectBufferUnsafe(ByteBuffer buffer) {
-        try {
-            Cleaner cleaner = ((DirectBuffer) buffer).cleaner();
-            if (cleaner == null) {
-                throw new IllegalArgumentException(
-                        "attempted to deallocate the buffer which was allocated via JNIEnv->NewDirectByteBuffer()");
-            }
-            cleaner.clean();
-        } catch (Throwable t) {
-            // Nothing we can do here.
-        }
-    }
-
     static void freeDirectBuffer(ByteBuffer buffer) {
-        if (!(buffer instanceof DirectBuffer)) {
-            return;
-        }
-        try {
-            Cleaner cleaner = ((DirectBuffer) buffer).cleaner();
-            if (cleaner == null) {
-                throw new IllegalArgumentException(
-                        "attempted to deallocate the buffer which was allocated via JNIEnv->NewDirectByteBuffer()");
-            }
-            cleaner.clean();
-        } catch (Throwable t) {
-            // Nothing we can do here.
-        }
+        // Delegate to other class to not break on android
+        // See https://github.com/netty/netty/issues/2604
+        Cleaner0.freeDirectBuffer(buffer);
     }
 
     static long directBufferAddress(ByteBuffer buffer) {
@@ -185,6 +158,10 @@ static Object getObject(Object object, long fieldOffset) {
         return UNSAFE.getObject(object, fieldOffset);
     }
 
+    static Object getObjectVolatile(Object object, long fieldOffset) {
+        return UNSAFE.getObjectVolatile(object, fieldOffset);
+    }
+
     static int getInt(Object object, long fieldOffset) {
         return UNSAFE.getInt(object, fieldOffset);
     }
@@ -251,6 +228,10 @@ static long getLong(long address) {
         }
     }
 
+    static void putOrderedObject(Object object, long address, Object value) {
+        UNSAFE.putOrderedObject(object, address, value);
+    }
+
     static void putByte(long address, byte value) {
         UNSAFE.putByte(address, value);
     }
@@ -308,11 +289,25 @@ static void putLong(long address, long value) {
     }
 
     static void copyMemory(long srcAddr, long dstAddr, long length) {
-        UNSAFE.copyMemory(srcAddr, dstAddr, length);
+        //UNSAFE.copyMemory(srcAddr, dstAddr, length);
+        while (length > 0) {
+            long size = Math.min(length, UNSAFE_COPY_THRESHOLD);
+            UNSAFE.copyMemory(srcAddr, dstAddr, size);
+            length -= size;
+            srcAddr += size;
+            dstAddr += size;
+        }
     }
 
     static void copyMemory(Object src, long srcOffset, Object dst, long dstOffset, long length) {
-        UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, length);
+        //UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, length);
+        while (length > 0) {
+            long size = Math.min(length, UNSAFE_COPY_THRESHOLD);
+            UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);
+            length -= size;
+            srcOffset += size;
+            dstOffset += size;
+        }
     }
 
     static <U, W> AtomicReferenceFieldUpdater<U, W> newAtomicReferenceFieldUpdater(
@@ -330,6 +325,45 @@ static <T> AtomicLongFieldUpdater<T> newAtomicLongFieldUpdater(
         return new UnsafeAtomicLongFieldUpdater<T>(UNSAFE, tclass, fieldName);
     }
 
+    static ClassLoader getClassLoader(final Class<?> clazz) {
+        if (System.getSecurityManager() == null) {
+            return clazz.getClassLoader();
+        } else {
+            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+                @Override
+                public ClassLoader run() {
+                    return clazz.getClassLoader();
+                }
+            });
+        }
+    }
+
+    static ClassLoader getContextClassLoader() {
+        if (System.getSecurityManager() == null) {
+            return Thread.currentThread().getContextClassLoader();
+        } else {
+            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+                @Override
+                public ClassLoader run() {
+                    return Thread.currentThread().getContextClassLoader();
+                }
+            });
+        }
+    }
+
+    static ClassLoader getSystemClassLoader() {
+        if (System.getSecurityManager() == null) {
+            return ClassLoader.getSystemClassLoader();
+        } else {
+            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+                @Override
+                public ClassLoader run() {
+                    return ClassLoader.getSystemClassLoader();
+                }
+            });
+        }
+    }
+
     private PlatformDependent0() {
     }
 
diff --git a/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java b/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java
index 2f9668d4973b..9a4214f9a6ab 100644
--- a/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java
+++ b/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java
@@ -35,7 +35,7 @@ public final class RecyclableArrayList extends ArrayList<Object> {
 
     private static final Recycler<RecyclableArrayList> RECYCLER = new Recycler<RecyclableArrayList>() {
         @Override
-        protected RecyclableArrayList newObject(Handle handle) {
+        protected RecyclableArrayList newObject(Handle<RecyclableArrayList> handle) {
             return new RecyclableArrayList(handle);
         }
     };
@@ -56,13 +56,13 @@ public static RecyclableArrayList newInstance(int minCapacity) {
         return ret;
     }
 
-    private final Handle handle;
+    private final Handle<RecyclableArrayList> handle;
 
-    private RecyclableArrayList(Handle handle) {
+    private RecyclableArrayList(Handle<RecyclableArrayList> handle) {
         this(handle, DEFAULT_INITIAL_CAPACITY);
     }
 
-    private RecyclableArrayList(Handle handle, int initialCapacity) {
+    private RecyclableArrayList(Handle<RecyclableArrayList> handle, int initialCapacity) {
         super(initialCapacity);
         this.handle = handle;
     }
diff --git a/common/src/main/java/io/netty/util/internal/RecyclableMpscLinkedQueueNode.java b/common/src/main/java/io/netty/util/internal/RecyclableMpscLinkedQueueNode.java
new file mode 100644
index 000000000000..5e8e1157298e
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/RecyclableMpscLinkedQueueNode.java
@@ -0,0 +1,42 @@
+/*
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+
+package io.netty.util.internal;
+
+import io.netty.util.Recycler;
+
+/**
+ * {@link MpscLinkedQueueNode} that will automatically call {@link Recycler.Handle#recycle(Object)} when the node was
+ * unlinked.
+ */
+public abstract class RecyclableMpscLinkedQueueNode<T> extends MpscLinkedQueueNode<T> {
+    @SuppressWarnings("rawtypes")
+    private final Recycler.Handle handle;
+
+    protected RecyclableMpscLinkedQueueNode(Recycler.Handle<? extends RecyclableMpscLinkedQueueNode<T>> handle) {
+        if (handle == null) {
+            throw new NullPointerException("handle");
+        }
+        this.handle = handle;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    final void unlink() {
+        super.unlink();
+        handle.recycle(this);
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
index 2877648d01f4..16cd1faa3755 100644
--- a/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
@@ -18,6 +18,8 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
@@ -27,12 +29,12 @@
  */
 public final class SystemPropertyUtil {
 
-    @SuppressWarnings("all")
     private static boolean initializedLogger;
     private static final InternalLogger logger;
     private static boolean loggedException;
 
     static {
+        initializedLogger = false;
         logger = InternalLoggerFactory.getInstance(SystemPropertyUtil.class);
         initializedLogger = true;
     }
@@ -64,7 +66,7 @@ public static String get(String key) {
      *         {@code def} if there's no such property or if an access to the
      *         specified property is not allowed.
      */
-    public static String get(String key, String def) {
+    public static String get(final String key, String def) {
         if (key == null) {
             throw new NullPointerException("key");
         }
@@ -74,7 +76,16 @@ public static String get(String key, String def) {
 
         String value = null;
         try {
-            value = System.getProperty(key);
+            if (System.getSecurityManager() == null) {
+                value = System.getProperty(key);
+            } else {
+                value = AccessController.doPrivileged(new PrivilegedAction<String>() {
+                    @Override
+                    public String run() {
+                        return System.getProperty(key);
+                    }
+                });
+            }
         } catch (Exception e) {
             if (!loggedException) {
                 log("Unable to retrieve a system property '" + key + "'; default values will be used.", e);
diff --git a/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java
index 3049e48274c7..963f90bc5888 100644
--- a/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java
+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java
@@ -25,6 +25,7 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+import java.lang.Thread.UncaughtExceptionHandler;
 import java.security.SecureRandom;
 import java.util.Random;
 import java.util.concurrent.BlockingQueue;
@@ -57,62 +58,107 @@
  * //author Doug Lea
  */
 @SuppressWarnings("all")
-public class ThreadLocalRandom extends Random {
+public final class ThreadLocalRandom extends Random {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(ThreadLocalRandom.class);
 
     private static final AtomicLong seedUniquifier = new AtomicLong();
 
-    private static volatile long initialSeedUniquifier;
+    private static volatile long initialSeedUniquifier =
+            SystemPropertyUtil.getLong("io.netty.initialSeedUniquifier", 0);
 
-    public static void setInitialSeedUniquifier(long initialSeedUniquifier) {
-        ThreadLocalRandom.initialSeedUniquifier = initialSeedUniquifier;
-    }
-
-    public static synchronized long getInitialSeedUniquifier() {
-        // Use the value set via the setter.
-        long initialSeedUniquifier = ThreadLocalRandom.initialSeedUniquifier;
-        if (initialSeedUniquifier == 0) {
-            // Use the system property value.
-            ThreadLocalRandom.initialSeedUniquifier = initialSeedUniquifier =
-                    SystemPropertyUtil.getLong("io.netty.initialSeedUniquifier", 0);
-        }
+    private static final Thread seedGeneratorThread;
+    private static final BlockingQueue<byte[]> seedQueue;
+    private static final long seedGeneratorStartTime;
+    private static volatile long seedGeneratorEndTime;
 
-        // Otherwise, generate one.
+    static {
         if (initialSeedUniquifier == 0) {
             // Try to generate a real random number from /dev/random.
             // Get from a different thread to avoid blocking indefinitely on a machine without much entrophy.
-            final BlockingQueue<Long> queue = new LinkedBlockingQueue<Long>();
-            Thread generatorThread = new Thread("initialSeedUniquifierGenerator") {
+            seedGeneratorThread = new Thread("initialSeedUniquifierGenerator") {
                 @Override
                 public void run() {
-                    SecureRandom random = new SecureRandom(); // Get the real random seed from /dev/random
-                    queue.add(random.nextLong());
+                    final SecureRandom random = new SecureRandom(); // Get the real random seed from /dev/random
+                    final byte[] seed = random.generateSeed(8);
+                    seedGeneratorEndTime = System.nanoTime();
+                    seedQueue.add(seed);
                 }
             };
-            generatorThread.start();
+            seedGeneratorThread.setDaemon(true);
+            seedGeneratorThread.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
+                @Override
+                public void uncaughtException(Thread t, Throwable e) {
+                    logger.debug("An exception has been raised by {}", t.getName(), e);
+                }
+            });
+
+            seedQueue = new LinkedBlockingQueue<byte[]>();
+            seedGeneratorStartTime = System.nanoTime();
+            seedGeneratorThread.start();
+        } else {
+            seedGeneratorThread = null;
+            seedQueue = null;
+            seedGeneratorStartTime = 0L;
+        }
+    }
 
-            // Get the random seed from the thread with timeout.
+    public static void setInitialSeedUniquifier(long initialSeedUniquifier) {
+        ThreadLocalRandom.initialSeedUniquifier = initialSeedUniquifier;
+    }
+
+    public static long getInitialSeedUniquifier() {
+        // Use the value set via the setter.
+        long initialSeedUniquifier = ThreadLocalRandom.initialSeedUniquifier;
+        if (initialSeedUniquifier != 0) {
+            return initialSeedUniquifier;
+        }
+
+        synchronized (ThreadLocalRandom.class) {
+            initialSeedUniquifier = ThreadLocalRandom.initialSeedUniquifier;
+            if (initialSeedUniquifier != 0) {
+                return initialSeedUniquifier;
+            }
+
+            // Get the random seed from the generator thread with timeout.
             final long timeoutSeconds = 3;
-            final long deadLine = System.nanoTime() + TimeUnit.SECONDS.toNanos(timeoutSeconds);
+            final long deadLine = seedGeneratorStartTime + TimeUnit.SECONDS.toNanos(timeoutSeconds);
+            boolean interrupted = false;
             for (;;) {
-                long waitTime = deadLine - System.nanoTime();
-                if (waitTime <= 0) {
-                    logger.warn(
-                            "Failed to get the secure random number from SecureRandom within {} seconds. " +
-                            "Not enough entrophy?", timeoutSeconds);
-                    break;
-                }
-
+                final long waitTime = deadLine - System.nanoTime();
                 try {
-                    Long result = queue.poll(waitTime, TimeUnit.NANOSECONDS);
-                    if (result != null) {
-                        initialSeedUniquifier = result;
+                    final byte[] seed;
+                    if (waitTime <= 0) {
+                        seed = seedQueue.poll();
+                    } else {
+                        seed = seedQueue.poll(waitTime, TimeUnit.NANOSECONDS);
+                    }
+
+                    if (seed != null) {
+                        initialSeedUniquifier =
+                                ((long) seed[0] & 0xff) << 56 |
+                                ((long) seed[1] & 0xff) << 48 |
+                                ((long) seed[2] & 0xff) << 40 |
+                                ((long) seed[3] & 0xff) << 32 |
+                                ((long) seed[4] & 0xff) << 24 |
+                                ((long) seed[5] & 0xff) << 16 |
+                                ((long) seed[6] & 0xff) <<  8 |
+                                (long) seed[7] & 0xff;
                         break;
                     }
                 } catch (InterruptedException e) {
-                    // restore interrupt status because we don't know how to/don't need to handle it here
-                    Thread.currentThread().interrupt();
+                    interrupted = true;
+                    logger.warn("Failed to generate a seed from SecureRandom due to an InterruptedException.");
+                    break;
+                }
+
+                if (waitTime <= 0) {
+                    seedGeneratorThread.interrupt();
+                    logger.warn(
+                            "Failed to generate a seed from SecureRandom within {} seconds. " +
+                            "Not enough entrophy?", timeoutSeconds
+                    );
+                    break;
                 }
             }
 
@@ -121,9 +167,22 @@ public void run() {
             initialSeedUniquifier ^= Long.reverse(System.nanoTime());
 
             ThreadLocalRandom.initialSeedUniquifier = initialSeedUniquifier;
-        }
 
-        return initialSeedUniquifier;
+            if (interrupted) {
+                // Restore the interrupt status because we don't know how to/don't need to handle it here.
+                Thread.currentThread().interrupt();
+
+                // Interrupt the generator thread if it's still running,
+                // in the hope that the SecureRandom provider raises an exception on interruption.
+                seedGeneratorThread.interrupt();
+            }
+
+            if (seedGeneratorEndTime == 0) {
+                seedGeneratorEndTime = System.nanoTime();
+            }
+
+            return initialSeedUniquifier;
+        }
     }
 
     private static long newSeed() {
@@ -136,7 +195,14 @@ private static long newSeed() {
 
             if (seedUniquifier.compareAndSet(current, next)) {
                 if (current == 0 && logger.isDebugEnabled()) {
-                    logger.debug(String.format("-Dio.netty.initialSeedUniquifier: 0x%016x", actualCurrent));
+                    if (seedGeneratorEndTime != 0) {
+                        logger.debug(String.format(
+                                "-Dio.netty.initialSeedUniquifier: 0x%016x (took %d ms)",
+                                actualCurrent,
+                                TimeUnit.NANOSECONDS.toMillis(seedGeneratorEndTime - seedGeneratorStartTime)));
+                    } else {
+                        logger.debug(String.format("-Dio.netty.initialSeedUniquifier: 0x%016x", actualCurrent));
+                    }
                 }
                 return next ^ System.nanoTime();
             }
@@ -174,23 +240,13 @@ private static long newSeed() {
         initialized = true;
     }
 
-    /**
-     * The actual ThreadLocal
-     */
-    private static final ThreadLocal<ThreadLocalRandom> localRandom =
-            new ThreadLocal<ThreadLocalRandom>() {
-                protected ThreadLocalRandom initialValue() {
-                    return new ThreadLocalRandom();
-                }
-            };
-
     /**
      * Returns the current thread's {@code ThreadLocalRandom}.
      *
      * @return the current thread's {@code ThreadLocalRandom}
      */
     public static ThreadLocalRandom current() {
-        return localRandom.get();
+        return InternalThreadLocalMap.get().random();
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java b/common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java
index ab9a676b450f..a10b149d78d9 100644
--- a/common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java
+++ b/common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java
@@ -22,7 +22,6 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.util.HashMap;
-import java.util.IdentityHashMap;
 import java.util.Map;
 
 public abstract class TypeParameterMatcher {
@@ -30,16 +29,9 @@ public abstract class TypeParameterMatcher {
     private static final TypeParameterMatcher NOOP = new NoOpTypeParameterMatcher();
     private static final Object TEST_OBJECT = new Object();
 
-    private static final ThreadLocal<Map<Class<?>, TypeParameterMatcher>> getCache =
-            new ThreadLocal<Map<Class<?>, TypeParameterMatcher>>() {
-                @Override
-                protected Map<Class<?>, TypeParameterMatcher> initialValue() {
-                    return new IdentityHashMap<Class<?>, TypeParameterMatcher>();
-                }
-            };
-
     public static TypeParameterMatcher get(final Class<?> parameterType) {
-        final Map<Class<?>, TypeParameterMatcher> getCache = TypeParameterMatcher.getCache.get();
+        final Map<Class<?>, TypeParameterMatcher> getCache =
+                InternalThreadLocalMap.get().typeParameterMatcherGetCache();
 
         TypeParameterMatcher matcher = getCache.get(parameterType);
         if (matcher == null) {
@@ -68,18 +60,11 @@ public static TypeParameterMatcher get(final Class<?> parameterType) {
         return matcher;
     }
 
-    private static final ThreadLocal<Map<Class<?>, Map<String, TypeParameterMatcher>>> findCache =
-            new ThreadLocal<Map<Class<?>, Map<String, TypeParameterMatcher>>>() {
-                @Override
-                protected Map<Class<?>, Map<String, TypeParameterMatcher>> initialValue() {
-                    return new IdentityHashMap<Class<?>, Map<String, TypeParameterMatcher>>();
-                }
-            };
-
     public static TypeParameterMatcher find(
             final Object object, final Class<?> parameterizedSuperclass, final String typeParamName) {
 
-        final Map<Class<?>, Map<String, TypeParameterMatcher>> findCache = TypeParameterMatcher.findCache.get();
+        final Map<Class<?>, Map<String, TypeParameterMatcher>> findCache =
+                InternalThreadLocalMap.get().typeParameterMatcherFindCache();
         final Class<?> thisClass = object.getClass();
 
         Map<String, TypeParameterMatcher> map = findCache.get(thisClass);
diff --git a/common/src/main/java/io/netty/util/internal/UnpaddedInternalThreadLocalMap.java b/common/src/main/java/io/netty/util/internal/UnpaddedInternalThreadLocalMap.java
new file mode 100644
index 000000000000..21caec99ef29
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/UnpaddedInternalThreadLocalMap.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+import io.netty.util.concurrent.FastThreadLocal;
+
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CharsetEncoder;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * The internal data structure that stores the thread-local variables for Netty and all {@link FastThreadLocal}s.
+ * Note that this class is for internal use only and is subject to change at any time.  Use {@link FastThreadLocal}
+ * unless you know what you are doing.
+ */
+class UnpaddedInternalThreadLocalMap {
+
+    static ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap;
+    static final AtomicInteger nextIndex = new AtomicInteger();
+
+    /** Used by {@link FastThreadLocal} */
+    Object[] indexedVariables;
+
+    // Core thread-locals
+    int futureListenerStackDepth;
+    int localChannelReaderStackDepth;
+    Map<Class<?>, Boolean> handlerSharableCache;
+    IntegerHolder counterHashCode;
+    ThreadLocalRandom random;
+    Map<Class<?>, TypeParameterMatcher> typeParameterMatcherGetCache;
+    Map<Class<?>, Map<String, TypeParameterMatcher>> typeParameterMatcherFindCache;
+
+    // String-related thread-locals
+    StringBuilder stringBuilder;
+    Map<Charset, CharsetEncoder> charsetEncoderCache;
+    Map<Charset, CharsetDecoder> charsetDecoderCache;
+
+    UnpaddedInternalThreadLocalMap(Object[] indexedVariables) {
+        this.indexedVariables = indexedVariables;
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/chmv8/ConcurrentHashMapV8.java b/common/src/main/java/io/netty/util/internal/chmv8/ConcurrentHashMapV8.java
index b0588a7eff2e..fa69fc55dbaf 100644
--- a/common/src/main/java/io/netty/util/internal/chmv8/ConcurrentHashMapV8.java
+++ b/common/src/main/java/io/netty/util/internal/chmv8/ConcurrentHashMapV8.java
@@ -22,6 +22,9 @@
 
 package io.netty.util.internal.chmv8;
 
+import io.netty.util.internal.IntegerHolder;
+import io.netty.util.internal.InternalThreadLocalMap;
+
 import java.io.ObjectStreamField;
 import java.io.Serializable;
 import java.lang.reflect.ParameterizedType;
@@ -2236,14 +2239,15 @@ private final void addCount(long x, int check) {
         CounterCell[] as; long b, s;
         if ((as = counterCells) != null ||
                 !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
-            CounterHashCode hc; CounterCell a; long v; int m;
+            IntegerHolder hc; CounterCell a; long v; int m;
             boolean uncontended = true;
-            if ((hc = threadCounterHashCode.get()) == null ||
+            InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
+            if ((hc = threadLocals.counterHashCode()) == null ||
                     as == null || (m = as.length - 1) < 0 ||
-                    (a = as[m & hc.code]) == null ||
+                    (a = as[m & hc.value]) == null ||
                     !(uncontended =
                             U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
-                fullAddCount(x, hc, uncontended);
+                fullAddCount(threadLocals, x, hc, uncontended);
                 return;
             }
             if (check <= 1)
@@ -2672,7 +2676,7 @@ private final void contendedLock() {
                         return;
                     }
                 }
-                else if ((s | WAITER) == 0) {
+                else if ((s & WAITER) == 0) {
                     if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) {
                         waiting = true;
                         waiter = Thread.currentThread();
@@ -6028,13 +6032,6 @@ static final class CounterHashCode {
      */
     static final int SEED_INCREMENT = 0x61c88647;
 
-    /**
-     * Per-thread counter hash codes. Shared across all instances.
-     */
-    static final ThreadLocal<CounterHashCode> threadCounterHashCode =
-            new ThreadLocal<CounterHashCode>();
-
-
     final long sumCount() {
         CounterCell[] as = counterCells; CounterCell a;
         long sum = baseCount;
@@ -6048,17 +6045,18 @@ final long sumCount() {
     }
 
     // See LongAdder version for explanation
-    private final void fullAddCount(long x, CounterHashCode hc,
+    private final void fullAddCount(InternalThreadLocalMap threadLocals,
+                                    long x, IntegerHolder hc,
                                     boolean wasUncontended) {
         int h;
         if (hc == null) {
-            hc = new CounterHashCode();
+            hc = new IntegerHolder();
             int s = counterHashCodeGenerator.addAndGet(SEED_INCREMENT);
-            h = hc.code = (s == 0) ? 1 : s; // Avoid zero
-            threadCounterHashCode.set(hc);
+            h = hc.value = (s == 0) ? 1 : s; // Avoid zero
+            threadLocals.setCounterHashCode(hc);
         }
         else
-            h = hc.code;
+            h = hc.value;
         boolean collide = false;                // True if last slot nonempty
         for (;;) {
             CounterCell[] as; CounterCell a; int n; long v;
@@ -6133,7 +6131,7 @@ else if (cellsBusy == 0 && counterCells == as &&
             else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
                 break;                          // Fall back on using base
         }
-        hc.code = h;                            // Record index for next time
+        hc.value = h;                           // Record index for next time
     }
 
     // Unsafe mechanics
diff --git a/common/src/main/java/io/netty/util/internal/chmv8/LongAdder.java b/common/src/main/java/io/netty/util/internal/chmv8/LongAdder.java
deleted file mode 100644
index c9d0712a02f6..000000000000
--- a/common/src/main/java/io/netty/util/internal/chmv8/LongAdder.java
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-/*
- * Written by Doug Lea with assistance from members of JCP JSR-166
- * Expert Group and released to the public domain, as explained at
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-package io.netty.util.internal.chmv8;
-
-import java.io.Serializable;
-import java.util.concurrent.atomic.AtomicLong;
-
-/**
- * One or more variables that together maintain an initially zero
- * {@code long} sum.  When updates (method {@link #add}) are contended
- * across threads, the set of variables may grow dynamically to reduce
- * contention. Method {@link #sum} (or, equivalently, {@link
- * #longValue}) returns the current total combined across the
- * variables maintaining the sum.
- *
- * <p>This class is usually preferable to {@link AtomicLong} when
- * multiple threads update a common sum that is used for purposes such
- * as collecting statistics, not for fine-grained synchronization
- * control.  Under low update contention, the two classes have similar
- * characteristics. But under high contention, expected throughput of
- * this class is significantly higher, at the expense of higher space
- * consumption.
- *
- * <p>This class extends {@link Number}, but does <em>not</em> define
- * methods such as {@code equals}, {@code hashCode} and {@code
- * compareTo} because instances are expected to be mutated, and so are
- * not useful as collection keys.
- *
- * <p><em>jsr166e note: This class is targeted to be placed in
- * java.util.concurrent.atomic.</em>
- *
- * @since 1.8
- * @author Doug Lea
- */
-@SuppressWarnings("all")
-public class LongAdder extends Striped64 implements Serializable {
-    private static final long serialVersionUID = 7249069246863182397L;
-
-    /**
-     * Version of plus for use in retryUpdate
-     */
-    final long fn(long v, long x) { return v + x; }
-
-    /**
-     * Creates a new adder with initial sum of zero.
-     */
-    public LongAdder() {
-    }
-
-    /**
-     * Adds the given value.
-     *
-     * @param x the value to add
-     */
-    public void add(long x) {
-        Cell[] as; long b, v; HashCode hc; Cell a; int n;
-        if ((as = cells) != null || !casBase(b = base, b + x)) {
-            boolean uncontended = true;
-            int h = (hc = threadHashCode.get()).code;
-            if (as == null || (n = as.length) < 1 ||
-                    (a = as[(n - 1) & h]) == null ||
-                    !(uncontended = a.cas(v = a.value, v + x)))
-                retryUpdate(x, hc, uncontended);
-        }
-    }
-
-    /**
-     * Equivalent to {@code add(1)}.
-     */
-    public void increment() {
-        add(1L);
-    }
-
-    /**
-     * Equivalent to {@code add(-1)}.
-     */
-    public void decrement() {
-        add(-1L);
-    }
-
-    /**
-     * Returns the current sum.  The returned value is <em>NOT</em> an
-     * atomic snapshot; invocation in the absence of concurrent
-     * updates returns an accurate result, but concurrent updates that
-     * occur while the sum is being calculated might not be
-     * incorporated.
-     *
-     * @return the sum
-     */
-    public long sum() {
-        long sum = base;
-        Cell[] as = cells;
-        if (as != null) {
-            int n = as.length;
-            for (int i = 0; i < n; ++i) {
-                Cell a = as[i];
-                if (a != null)
-                    sum += a.value;
-            }
-        }
-        return sum;
-    }
-
-    /**
-     * Resets variables maintaining the sum to zero.  This method may
-     * be a useful alternative to creating a new adder, but is only
-     * effective if there are no concurrent updates.  Because this
-     * method is intrinsically racy, it should only be used when it is
-     * known that no threads are concurrently updating.
-     */
-    public void reset() {
-        internalReset(0L);
-    }
-
-    /**
-     * Equivalent in effect to {@link #sum} followed by {@link
-     * #reset}. This method may apply for example during quiescent
-     * points between multithreaded computations.  If there are
-     * updates concurrent with this method, the returned value is
-     * <em>not</em> guaranteed to be the final value occurring before
-     * the reset.
-     *
-     * @return the sum
-     */
-    public long sumThenReset() {
-        long sum = base;
-        Cell[] as = cells;
-        base = 0L;
-        if (as != null) {
-            int n = as.length;
-            for (int i = 0; i < n; ++i) {
-                Cell a = as[i];
-                if (a != null) {
-                    sum += a.value;
-                    a.value = 0L;
-                }
-            }
-        }
-        return sum;
-    }
-
-    /**
-     * Returns the String representation of the {@link #sum}.
-     * @return the String representation of the {@link #sum}
-     */
-    public String toString() {
-        return Long.toString(sum());
-    }
-
-    /**
-     * Equivalent to {@link #sum}.
-     *
-     * @return the sum
-     */
-    public long longValue() {
-        return sum();
-    }
-
-    /**
-     * Returns the {@link #sum} as an {@code int} after a narrowing
-     * primitive conversion.
-     */
-    public int intValue() {
-        return (int)sum();
-    }
-
-    /**
-     * Returns the {@link #sum} as a {@code float}
-     * after a widening primitive conversion.
-     */
-    public float floatValue() {
-        return (float)sum();
-    }
-
-    /**
-     * Returns the {@link #sum} as a {@code double} after a widening
-     * primitive conversion.
-     */
-    public double doubleValue() {
-        return (double)sum();
-    }
-
-    private void writeObject(java.io.ObjectOutputStream s)
-            throws java.io.IOException {
-        s.defaultWriteObject();
-        s.writeLong(sum());
-    }
-
-    private void readObject(java.io.ObjectInputStream s)
-            throws java.io.IOException, ClassNotFoundException {
-        s.defaultReadObject();
-        busy = 0;
-        cells = null;
-        base = s.readLong();
-    }
-
-}
diff --git a/common/src/main/java/io/netty/util/internal/chmv8/Striped64.java b/common/src/main/java/io/netty/util/internal/chmv8/Striped64.java
deleted file mode 100644
index 45ae9d6063b3..000000000000
--- a/common/src/main/java/io/netty/util/internal/chmv8/Striped64.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-/*
- * Written by Doug Lea with assistance from members of JCP JSR-166
- * Expert Group and released to the public domain, as explained at
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-package io.netty.util.internal.chmv8;
-
-import java.util.Random;
-
-/**
- * A package-local class holding common representation and mechanics
- * for classes supporting dynamic striping on 64bit values. The class
- * extends Number so that concrete subclasses must publicly do so.
- */
-@SuppressWarnings("all")
-abstract class Striped64 extends Number {
-    /*
-     * This class maintains a lazily-initialized table of atomically
-     * updated variables, plus an extra "base" field. The table size
-     * is a power of two. Indexing uses masked per-thread hash codes.
-     * Nearly all declarations in this class are package-private,
-     * accessed directly by subclasses.
-     *
-     * Table entries are of class Cell; a variant of AtomicLong padded
-     * to reduce cache contention on most processors. Padding is
-     * overkill for most Atomics because they are usually irregularly
-     * scattered in memory and thus don't interfere much with each
-     * other. But Atomic objects residing in arrays will tend to be
-     * placed adjacent to each other, and so will most often share
-     * cache lines (with a huge negative performance impact) without
-     * this precaution.
-     *
-     * In part because Cells are relatively large, we avoid creating
-     * them until they are needed.  When there is no contention, all
-     * updates are made to the base field.  Upon first contention (a
-     * failed CAS on base update), the table is initialized to size 2.
-     * The table size is doubled upon further contention until
-     * reaching the nearest power of two greater than or equal to the
-     * number of CPUS. Table slots remain empty (null) until they are
-     * needed.
-     *
-     * A single spinlock ("busy") is used for initializing and
-     * resizing the table, as well as populating slots with new Cells.
-     * There is no need for a blocking lock; when the lock is not
-     * available, threads try other slots (or the base).  During these
-     * retries, there is increased contention and reduced locality,
-     * which is still better than alternatives.
-     *
-     * Per-thread hash codes are initialized to random values.
-     * Contention and/or table collisions are indicated by failed
-     * CASes when performing an update operation (see method
-     * retryUpdate). Upon a collision, if the table size is less than
-     * the capacity, it is doubled in size unless some other thread
-     * holds the lock. If a hashed slot is empty, and lock is
-     * available, a new Cell is created. Otherwise, if the slot
-     * exists, a CAS is tried.  Retries proceed by "double hashing",
-     * using a secondary hash (Marsaglia XorShift) to try to find a
-     * free slot.
-     *
-     * The table size is capped because, when there are more threads
-     * than CPUs, supposing that each thread were bound to a CPU,
-     * there would exist a perfect hash function mapping threads to
-     * slots that eliminates collisions. When we reach capacity, we
-     * search for this mapping by randomly varying the hash codes of
-     * colliding threads.  Because search is random, and collisions
-     * only become known via CAS failures, convergence can be slow,
-     * and because threads are typically not bound to CPUS forever,
-     * may not occur at all. However, despite these limitations,
-     * observed contention rates are typically low in these cases.
-     *
-     * It is possible for a Cell to become unused when threads that
-     * once hashed to it terminate, as well as in the case where
-     * doubling the table causes no thread to hash to it under
-     * expanded mask.  We do not try to detect or remove such cells,
-     * under the assumption that for long-running instances, observed
-     * contention levels will recur, so the cells will eventually be
-     * needed again; and for short-lived ones, it does not matter.
-     */
-
-    /**
-     * Padded variant of AtomicLong supporting only raw accesses plus CAS.
-     * The value field is placed between pads, hoping that the JVM doesn't
-     * reorder them.
-     *
-     * JVM intrinsics note: It would be possible to use a release-only
-     * form of CAS here, if it were provided.
-     */
-    static final class Cell {
-        volatile long p0, p1, p2, p3, p4, p5, p6;
-        volatile long value;
-        volatile long q0, q1, q2, q3, q4, q5, q6;
-        Cell(long x) { value = x; }
-
-        final boolean cas(long cmp, long val) {
-            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
-        }
-
-        // Unsafe mechanics
-        private static final sun.misc.Unsafe UNSAFE;
-        private static final long valueOffset;
-        static {
-            try {
-                UNSAFE = getUnsafe();
-                Class<?> ak = Cell.class;
-                valueOffset = UNSAFE.objectFieldOffset
-                        (ak.getDeclaredField("value"));
-            } catch (Exception e) {
-                throw new Error(e);
-            }
-        }
-
-    }
-
-    /**
-     * Holder for the thread-local hash code. The code is initially
-     * random, but may be set to a different value upon collisions.
-     */
-    static final class HashCode {
-        static final Random rng = new Random();
-        int code;
-        HashCode() {
-            int h = rng.nextInt(); // Avoid zero to allow xorShift rehash
-            code = (h == 0) ? 1 : h;
-        }
-    }
-
-    /**
-     * The corresponding ThreadLocal class
-     */
-    static final class ThreadHashCode extends ThreadLocal<HashCode> {
-        public HashCode initialValue() { return new HashCode(); }
-    }
-
-    /**
-     * Static per-thread hash codes. Shared across all instances to
-     * reduce ThreadLocal pollution and because adjustments due to
-     * collisions in one table are likely to be appropriate for
-     * others.
-     */
-    static final ThreadHashCode threadHashCode = new ThreadHashCode();
-
-    /** Number of CPUS, to place bound on table size */
-    static final int NCPU = Runtime.getRuntime().availableProcessors();
-
-    /**
-     * Table of cells. When non-null, size is a power of 2.
-     */
-    transient volatile Cell[] cells;
-
-    /**
-     * Base value, used mainly when there is no contention, but also as
-     * a fallback during table initialization races. Updated via CAS.
-     */
-    transient volatile long base;
-
-    /**
-     * Spinlock (locked via CAS) used when resizing and/or creating Cells.
-     */
-    transient volatile int busy;
-
-    /**
-     * Package-private default constructor
-     */
-    Striped64() {
-    }
-
-    /**
-     * CASes the base field.
-     */
-    final boolean casBase(long cmp, long val) {
-        return UNSAFE.compareAndSwapLong(this, baseOffset, cmp, val);
-    }
-
-    /**
-     * CASes the busy field from 0 to 1 to acquire lock.
-     */
-    final boolean casBusy() {
-        return UNSAFE.compareAndSwapInt(this, busyOffset, 0, 1);
-    }
-
-    /**
-     * Computes the function of current and new value. Subclasses
-     * should open-code this update function for most uses, but the
-     * virtualized form is needed within retryUpdate.
-     *
-     * @param currentValue the current value (of either base or a cell)
-     * @param newValue the argument from a user update call
-     * @return result of the update function
-     */
-    abstract long fn(long currentValue, long newValue);
-
-    /**
-     * Handles cases of updates involving initialization, resizing,
-     * creating new Cells, and/or contention. See above for
-     * explanation. This method suffers the usual non-modularity
-     * problems of optimistic retry code, relying on rechecked sets of
-     * reads.
-     *
-     * @param x the value
-     * @param hc the hash code holder
-     * @param wasUncontended false if CAS failed before call
-     */
-    final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {
-        int h = hc.code;
-        boolean collide = false;                // True if last slot nonempty
-        for (;;) {
-            Cell[] as; Cell a; int n; long v;
-            if ((as = cells) != null && (n = as.length) > 0) {
-                if ((a = as[(n - 1) & h]) == null) {
-                    if (busy == 0) {            // Try to attach new Cell
-                        Cell r = new Cell(x);   // Optimistically create
-                        if (busy == 0 && casBusy()) {
-                            boolean created = false;
-                            try {               // Recheck under lock
-                                Cell[] rs; int m, j;
-                                if ((rs = cells) != null &&
-                                        (m = rs.length) > 0 &&
-                                        rs[j = (m - 1) & h] == null) {
-                                    rs[j] = r;
-                                    created = true;
-                                }
-                            } finally {
-                                busy = 0;
-                            }
-                            if (created)
-                                break;
-                            continue;           // Slot is now non-empty
-                        }
-                    }
-                    collide = false;
-                }
-                else if (!wasUncontended)       // CAS already known to fail
-                    wasUncontended = true;      // Continue after rehash
-                else if (a.cas(v = a.value, fn(v, x)))
-                    break;
-                else if (n >= NCPU || cells != as)
-                    collide = false;            // At max size or stale
-                else if (!collide)
-                    collide = true;
-                else if (busy == 0 && casBusy()) {
-                    try {
-                        if (cells == as) {      // Expand table unless stale
-                            Cell[] rs = new Cell[n << 1];
-                            for (int i = 0; i < n; ++i)
-                                rs[i] = as[i];
-                            cells = rs;
-                        }
-                    } finally {
-                        busy = 0;
-                    }
-                    collide = false;
-                    continue;                   // Retry with expanded table
-                }
-                h ^= h << 13;                   // Rehash
-                h ^= h >>> 17;
-                h ^= h << 5;
-            }
-            else if (busy == 0 && cells == as && casBusy()) {
-                boolean init = false;
-                try {                           // Initialize table
-                    if (cells == as) {
-                        Cell[] rs = new Cell[2];
-                        rs[h & 1] = new Cell(x);
-                        cells = rs;
-                        init = true;
-                    }
-                } finally {
-                    busy = 0;
-                }
-                if (init)
-                    break;
-            }
-            else if (casBase(v = base, fn(v, x)))
-                break;                          // Fall back on using base
-        }
-        hc.code = h;                            // Record index for next time
-    }
-
-
-    /**
-     * Sets base and all cells to the given value.
-     */
-    final void internalReset(long initialValue) {
-        Cell[] as = cells;
-        base = initialValue;
-        if (as != null) {
-            int n = as.length;
-            for (int i = 0; i < n; ++i) {
-                Cell a = as[i];
-                if (a != null)
-                    a.value = initialValue;
-            }
-        }
-    }
-
-    // Unsafe mechanics
-    private static final sun.misc.Unsafe UNSAFE;
-    private static final long baseOffset;
-    private static final long busyOffset;
-    static {
-        try {
-            UNSAFE = getUnsafe();
-            Class<?> sk = Striped64.class;
-            baseOffset = UNSAFE.objectFieldOffset
-                    (sk.getDeclaredField("base"));
-            busyOffset = UNSAFE.objectFieldOffset
-                    (sk.getDeclaredField("busy"));
-        } catch (Exception e) {
-            throw new Error(e);
-        }
-    }
-
-    /**
-     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
-     * Replace with a simple call to Unsafe.getUnsafe when integrating
-     * into a jdk.
-     *
-     * @return a sun.misc.Unsafe
-     */
-    private static sun.misc.Unsafe getUnsafe() {
-        try {
-            return sun.misc.Unsafe.getUnsafe();
-        } catch (SecurityException tryReflectionInstead) {}
-        try {
-            return java.security.AccessController.doPrivileged
-                    (new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {
-                        public sun.misc.Unsafe run() throws Exception {
-                            Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;
-                            for (java.lang.reflect.Field f : k.getDeclaredFields()) {
-                                f.setAccessible(true);
-                                Object x = f.get(null);
-                                if (k.isInstance(x))
-                                    return k.cast(x);
-                            }
-                            throw new NoSuchFieldError("the Unsafe");
-                        }});
-        } catch (java.security.PrivilegedActionException e) {
-            throw new RuntimeException("Could not initialize intrinsics",
-                    e.getCause());
-        }
-    }
-}
diff --git a/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java b/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java
index afb45b21d49f..78007c1e4a9a 100644
--- a/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java
+++ b/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java
@@ -29,6 +29,8 @@ public abstract class AbstractInternalLogger implements InternalLogger, Serializ
 
     private static final long serialVersionUID = -6382972526573193470L;
 
+    private static final String EXCEPTION_MESSAGE = "Unexpected exception:";
+
     private final String name;
 
     /**
@@ -64,6 +66,31 @@ public boolean isEnabled(InternalLogLevel level) {
         }
     }
 
+    @Override
+    public void trace(Throwable t) {
+        trace(EXCEPTION_MESSAGE, t);
+    }
+
+    @Override
+    public void debug(Throwable t) {
+        debug(EXCEPTION_MESSAGE, t);
+    }
+
+    @Override
+    public void info(Throwable t) {
+        info(EXCEPTION_MESSAGE, t);
+    }
+
+    @Override
+    public void warn(Throwable t) {
+        warn(EXCEPTION_MESSAGE, t);
+    }
+
+    @Override
+    public void error(Throwable t) {
+        error(EXCEPTION_MESSAGE, t);
+    }
+
     @Override
     public void log(InternalLogLevel level, String msg, Throwable cause) {
         switch (level) {
@@ -87,6 +114,29 @@ public void log(InternalLogLevel level, String msg, Throwable cause) {
         }
     }
 
+    @Override
+    public void log(InternalLogLevel level, Throwable cause) {
+        switch (level) {
+            case TRACE:
+                trace(cause);
+                break;
+            case DEBUG:
+                debug(cause);
+                break;
+            case INFO:
+                info(cause);
+                break;
+            case WARN:
+                warn(cause);
+                break;
+            case ERROR:
+                error(cause);
+                break;
+            default:
+                throw new Error();
+        }
+    }
+
     @Override
     public void log(InternalLogLevel level, String msg) {
         switch (level) {
diff --git a/common/src/main/java/io/netty/util/internal/logging/InternalLogger.java b/common/src/main/java/io/netty/util/internal/logging/InternalLogger.java
index 6cb274f5be9e..335cf32ee782 100644
--- a/common/src/main/java/io/netty/util/internal/logging/InternalLogger.java
+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLogger.java
@@ -116,6 +116,13 @@ public interface InternalLogger {
      */
     void trace(String msg, Throwable t);
 
+    /**
+     * Log an exception (throwable) at the TRACE level.
+     *
+     * @param t   the exception (throwable) to log
+     */
+    void trace(Throwable t);
+
     /**
      * Is the logger instance enabled for the DEBUG level?
      *
@@ -181,6 +188,13 @@ public interface InternalLogger {
      */
     void debug(String msg, Throwable t);
 
+    /**
+     * Log an exception (throwable) at the DEBUG level.
+     *
+     * @param t   the exception (throwable) to log
+     */
+    void debug(Throwable t);
+
     /**
      * Is the logger instance enabled for the INFO level?
      *
@@ -246,6 +260,13 @@ public interface InternalLogger {
      */
     void info(String msg, Throwable t);
 
+    /**
+     * Log an exception (throwable) at the INFO level.
+     *
+     * @param t   the exception (throwable) to log
+     */
+    void info(Throwable t);
+
     /**
      * Is the logger instance enabled for the WARN level?
      *
@@ -311,6 +332,13 @@ public interface InternalLogger {
      */
     void warn(String msg, Throwable t);
 
+    /**
+     * Log an exception (throwable) at the WARN level.
+     *
+     * @param t   the exception (throwable) to log
+     */
+    void warn(Throwable t);
+
     /**
      * Is the logger instance enabled for the ERROR level?
      *
@@ -376,6 +404,13 @@ public interface InternalLogger {
      */
     void error(String msg, Throwable t);
 
+    /**
+     * Log an exception (throwable) at the ERROR level.
+     *
+     * @param t   the exception (throwable) to log
+     */
+    void error(Throwable t);
+
     /**
      * Is the logger instance enabled for the specified {@code level}?
      *
@@ -441,4 +476,11 @@ public interface InternalLogger {
      * @param t   the exception (throwable) to log
      */
     void log(InternalLogLevel level, String msg, Throwable t);
+
+    /**
+     * Log an exception (throwable) at the specified {@code level}.
+     *
+     * @param t   the exception (throwable) to log
+     */
+    void log(InternalLogLevel level, Throwable t);
 }
diff --git a/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java
index a80e94c9c8f0..3f1a6d230340 100644
--- a/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java
+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java
@@ -15,6 +15,8 @@
  */
 package io.netty.util.internal.logging;
 
+import io.netty.util.internal.ThreadLocalRandom;
+
 /**
  * Creates an {@link InternalLogger} or changes the default factory
  * implementation.  This factory allows you to choose what logging framework
@@ -31,15 +33,26 @@
  * as possible and shouldn't be called more than once.
  */
 public abstract class InternalLoggerFactory {
-    private static volatile InternalLoggerFactory defaultFactory;
+
+    private static volatile InternalLoggerFactory defaultFactory =
+            newDefaultFactory(InternalLoggerFactory.class.getName());
 
     static {
-        final String name = InternalLoggerFactory.class.getName();
+        // Initiate some time-consuming background jobs here,
+        // because this class is often initialized at the earliest time.
+        try {
+            Class.forName(ThreadLocalRandom.class.getName(), true, InternalLoggerFactory.class.getClassLoader());
+        } catch (Exception ignored) {
+            // Should not fail, but it does not harm to fail.
+        }
+    }
+
+    @SuppressWarnings("UnusedCatchParameter")
+    private static InternalLoggerFactory newDefaultFactory(String name) {
         InternalLoggerFactory f;
         try {
             f = new Slf4JLoggerFactory(true);
             f.newInstance(name).debug("Using SLF4J as the default logging framework");
-            defaultFactory = f;
         } catch (Throwable t1) {
             try {
                 f = new Log4JLoggerFactory();
@@ -49,8 +62,7 @@ public abstract class InternalLoggerFactory {
                 f.newInstance(name).debug("Using java.util.logging as the default logging framework");
             }
         }
-
-        defaultFactory = f;
+        return f;
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/internal/logging/Log4JLogger.java b/common/src/main/java/io/netty/util/internal/logging/Log4JLogger.java
index 7f5b20f2fea6..27b9130a0814 100644
--- a/common/src/main/java/io/netty/util/internal/logging/Log4JLogger.java
+++ b/common/src/main/java/io/netty/util/internal/logging/Log4JLogger.java
@@ -72,7 +72,7 @@ private boolean isTraceCapable() {
         try {
             logger.isTraceEnabled();
             return true;
-        } catch (NoSuchMethodError e) {
+        } catch (NoSuchMethodError ignored) {
             return false;
         }
     }
diff --git a/common/src/main/java/io/netty/util/internal/logging/Slf4JLogger.java b/common/src/main/java/io/netty/util/internal/logging/Slf4JLogger.java
index a75937210029..e78727ca0f58 100644
--- a/common/src/main/java/io/netty/util/internal/logging/Slf4JLogger.java
+++ b/common/src/main/java/io/netty/util/internal/logging/Slf4JLogger.java
@@ -52,7 +52,7 @@ public void trace(String format, Object argA, Object argB) {
     }
 
     @Override
-    public void trace(String format, Object[] argArray) {
+    public void trace(String format, Object... argArray) {
         logger.trace(format, argArray);
     }
 
@@ -82,7 +82,7 @@ public void debug(String format, Object argA, Object argB) {
     }
 
     @Override
-    public void debug(String format, Object[] argArray) {
+    public void debug(String format, Object... argArray) {
         logger.debug(format, argArray);
     }
 
@@ -112,7 +112,7 @@ public void info(String format, Object argA, Object argB) {
     }
 
     @Override
-    public void info(String format, Object[] argArray) {
+    public void info(String format, Object... argArray) {
         logger.info(format, argArray);
     }
 
@@ -137,7 +137,7 @@ public void warn(String format, Object arg) {
     }
 
     @Override
-    public void warn(String format, Object[] argArray) {
+    public void warn(String format, Object... argArray) {
         logger.warn(format, argArray);
     }
 
@@ -172,7 +172,7 @@ public void error(String format, Object argA, Object argB) {
     }
 
     @Override
-    public void error(String format, Object[] argArray) {
+    public void error(String format, Object... argArray) {
         logger.error(format, argArray);
     }
 
diff --git a/common/src/main/java/io/netty/util/internal/logging/Slf4JLoggerFactory.java b/common/src/main/java/io/netty/util/internal/logging/Slf4JLoggerFactory.java
index ecef300d36e9..e31e55cb98f0 100644
--- a/common/src/main/java/io/netty/util/internal/logging/Slf4JLoggerFactory.java
+++ b/common/src/main/java/io/netty/util/internal/logging/Slf4JLoggerFactory.java
@@ -54,7 +54,7 @@ public void write(int b) {
             if (LoggerFactory.getILoggerFactory() instanceof NOPLoggerFactory) {
                 throw new NoClassDefFoundError(buf.toString());
             } else {
-                err.print(buf.toString());
+                err.print(buf);
                 err.flush();
             }
         } finally {
diff --git a/common/src/test/java/io/netty/util/ConstantPoolTest.java b/common/src/test/java/io/netty/util/ConstantPoolTest.java
new file mode 100644
index 000000000000..9e22109f26ad
--- /dev/null
+++ b/common/src/test/java/io/netty/util/ConstantPoolTest.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util;
+
+import org.junit.Test;
+
+import java.util.Set;
+import java.util.TreeSet;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+public class ConstantPoolTest {
+
+    static final class TestConstant extends AbstractConstant<TestConstant> {
+        TestConstant(int id, String name) {
+            super(id, name);
+        }
+    }
+
+    private static final ConstantPool<TestConstant> pool = new ConstantPool<TestConstant>() {
+        @Override
+        protected TestConstant newConstant(int id, String name) {
+            return new TestConstant(id, name);
+        }
+    };
+
+    @Test(expected = NullPointerException.class)
+    public void testCannotProvideNullName() {
+        pool.valueOf(null);
+    }
+
+    @Test
+    @SuppressWarnings("RedundantStringConstructorCall")
+    public void testUniqueness() {
+        TestConstant a = pool.valueOf(new String("Leroy"));
+        TestConstant b = pool.valueOf(new String("Leroy"));
+        assertThat(a, is(sameInstance(b)));
+    }
+
+    @Test
+    public void testIdUniqueness() {
+        TestConstant one = pool.valueOf("one");
+        TestConstant two = pool.valueOf("two");
+        assertThat(one.id(), is(not(two.id())));
+    }
+
+    @Test
+    public void testCompare() {
+        TestConstant a = pool.valueOf("a_alpha");
+        TestConstant b = pool.valueOf("b_beta");
+        TestConstant c = pool.valueOf("c_gamma");
+        TestConstant d = pool.valueOf("d_delta");
+        TestConstant e = pool.valueOf("e_epsilon");
+
+        Set<TestConstant> set = new TreeSet<TestConstant>();
+        set.add(b);
+        set.add(c);
+        set.add(e);
+        set.add(d);
+        set.add(a);
+
+        TestConstant[] array = set.toArray(new TestConstant[5]);
+        assertThat(array.length, is(5));
+        assertThat(array[0], is(sameInstance(a)));
+        assertThat(array[1], is(sameInstance(b)));
+        assertThat(array[2], is(sameInstance(c)));
+        assertThat(array[3], is(sameInstance(d)));
+        assertThat(array[4], is(sameInstance(e)));
+    }
+
+    @Test
+    public void testComposedName() {
+        TestConstant a = pool.valueOf(Object.class, "A");
+        assertThat(a.name(), is("java.lang.Object#A"));
+    }
+}
diff --git a/common/src/test/java/io/netty/util/DefaultAttributeMapTest.java b/common/src/test/java/io/netty/util/DefaultAttributeMapTest.java
index 7fe574ce57d9..1bdb8b019a81 100644
--- a/common/src/test/java/io/netty/util/DefaultAttributeMapTest.java
+++ b/common/src/test/java/io/netty/util/DefaultAttributeMapTest.java
@@ -42,10 +42,10 @@ public void testGetSetString() {
         assertSame(one, map.attr(key));
 
         one.setIfAbsent("Whoohoo");
-        assertSame(one.get(), "Whoohoo");
+        assertSame("Whoohoo", one.get());
 
         one.setIfAbsent("What");
-        assertNotSame(one.get(), "What");
+        assertNotSame("What", one.get());
 
         one.remove();
         assertNull(one.get());
@@ -62,9 +62,21 @@ public void testGetSetInt() {
         assertEquals(one.get(), Integer.valueOf(3653));
 
         one.setIfAbsent(1);
-        assertNotSame(one.get(), 1);
+        assertNotSame(1, one.get());
 
         one.remove();
         assertNull(one.get());
     }
+
+    // See https://github.com/netty/netty/issues/2523
+    @Test
+    public void testSetRemove() {
+        AttributeKey<Integer> key = AttributeKey.valueOf("key");
+
+        map.attr(key).set(1);
+        assertSame(1, map.attr(key).getAndRemove());
+
+        map.attr(key).set(2);
+        assertSame(2, map.attr(key).get());
+    }
 }
diff --git a/common/src/test/java/io/netty/util/RecyclerTest.java b/common/src/test/java/io/netty/util/RecyclerTest.java
new file mode 100644
index 000000000000..5212e9b4df5a
--- /dev/null
+++ b/common/src/test/java/io/netty/util/RecyclerTest.java
@@ -0,0 +1,62 @@
+/*
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+package io.netty.util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class RecyclerTest {
+
+    @Test(expected = IllegalStateException.class)
+    public void testMultipleRecycle() {
+        RecyclableObject object = RecyclableObject.newInstance();
+        object.recycle();
+        object.recycle();
+    }
+
+    @Test
+    public void testRecycle() {
+        RecyclableObject object = RecyclableObject.newInstance();
+        object.recycle();
+        RecyclableObject object2 = RecyclableObject.newInstance();
+        Assert.assertSame(object, object2);
+        object2.recycle();
+    }
+
+    static final class RecyclableObject {
+
+        private static final Recycler<RecyclableObject> RECYCLER = new Recycler<RecyclableObject>() {
+            @Override
+            protected RecyclableObject newObject(Handle<RecyclableObject> handle) {
+                return new RecyclableObject(handle);
+            }
+        };
+
+        private final Recycler.Handle<RecyclableObject> handle;
+
+        private RecyclableObject(Recycler.Handle<RecyclableObject> handle) {
+            this.handle = handle;
+        }
+
+        public static RecyclableObject newInstance() {
+            return RECYCLER.get();
+        }
+
+        public void recycle() {
+            RECYCLER.recycle(this, handle);
+        }
+    }
+}
diff --git a/common/src/test/java/io/netty/util/ThreadDeathWatcherTest.java b/common/src/test/java/io/netty/util/ThreadDeathWatcherTest.java
new file mode 100644
index 000000000000..9dd088bac7c3
--- /dev/null
+++ b/common/src/test/java/io/netty/util/ThreadDeathWatcherTest.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util;
+
+import org.junit.Test;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+public class ThreadDeathWatcherTest {
+
+    @Test(timeout = 10000)
+    public void testWatch() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final Thread t = new Thread() {
+            @Override
+            public void run() {
+                for (;;) {
+                    try {
+                        Thread.sleep(1000);
+                    } catch (InterruptedException ignore) {
+                        break;
+                    }
+                }
+            }
+        };
+
+        final Runnable task = new Runnable() {
+            @Override
+            public void run() {
+                if (!t.isAlive()) {
+                    latch.countDown();
+                }
+            }
+        };
+
+        try {
+            ThreadDeathWatcher.watch(t, task);
+            fail("must reject to watch a non-alive thread.");
+        } catch (IllegalArgumentException e) {
+            // expected
+        }
+
+        t.start();
+        ThreadDeathWatcher.watch(t, task);
+
+        // As long as the thread is alive, the task should not run.
+        assertThat(latch.await(750, TimeUnit.MILLISECONDS), is(false));
+
+        // Interrupt the thread to terminate it.
+        t.interrupt();
+
+        // The task must be run on termination.
+        latch.await();
+    }
+
+    @Test(timeout = 10000)
+    public void testUnwatch() throws Exception {
+        final AtomicBoolean run = new AtomicBoolean();
+        final Thread t = new Thread() {
+            @Override
+            public void run() {
+                for (;;) {
+                    try {
+                        Thread.sleep(1000);
+                    } catch (InterruptedException ignore) {
+                        break;
+                    }
+                }
+            }
+        };
+
+        final Runnable task = new Runnable() {
+            @Override
+            public void run() {
+                run.set(true);
+            }
+        };
+
+        t.start();
+
+        // Watch and then unwatch.
+        ThreadDeathWatcher.watch(t, task);
+        ThreadDeathWatcher.unwatch(t, task);
+
+        // Interrupt the thread to terminate it.
+        t.interrupt();
+
+        // Wait until the thread dies.
+        t.join();
+
+        // Wait until the watcher thread terminates itself.
+        assertThat(ThreadDeathWatcher.awaitInactivity(Long.MAX_VALUE, TimeUnit.SECONDS), is(true));
+
+        // And the task should not run.
+        assertThat(run.get(), is(false));
+    }
+}
diff --git a/common/src/test/java/io/netty/util/UniqueNameTest.java b/common/src/test/java/io/netty/util/UniqueNameTest.java
deleted file mode 100644
index 1f786f747e22..000000000000
--- a/common/src/test/java/io/netty/util/UniqueNameTest.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.util;
-
-import io.netty.util.internal.PlatformDependent;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.ArrayList;
-import java.util.concurrent.ConcurrentMap;
-
-import static org.junit.Assert.*;
-
-public class UniqueNameTest {
-
-    /**
-     * A {@link ConcurrentMap} of registered names.
-     * This is set up before each test
-     */
-    private ConcurrentMap<String, Boolean> names;
-
-    /**
-     * Registers a {@link UniqueName}
-     *
-     * @param name the name being registered
-     * @return the unique name
-     */
-    public UniqueName registerName(String name) {
-        return new UniqueName(names, name);
-    }
-
-    @Before
-    public void initializeTest() {
-        names = PlatformDependent.newConcurrentHashMap();
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testCannnotProvideNullMap() {
-        new UniqueName(null, "Nothing");
-    }
-
-    @Test(expected = NullPointerException.class)
-    public void testCannotProvideNullName() {
-        new UniqueName(names, null);
-    }
-
-    @Test
-    public void testArgsCanBePassed() {
-        new UniqueName(names, "Argh, matey!", 2, 5, new Object());
-    }
-
-    @Test
-    public void testRegisteringName() {
-        registerName("Abcedrian");
-
-        assertTrue(names.get("Abcedrian"));
-        assertNull(names.get("Hellyes"));
-    }
-
-    @Test
-    public void testNameUniqueness() {
-        registerName("Leroy");
-        boolean failed = false;
-        try {
-            registerName("Leroy");
-        } catch (IllegalArgumentException ex) {
-            failed = true;
-        }
-        assertTrue(failed);
-    }
-
-    @Test
-    public void testIDUniqueness() {
-        UniqueName one = registerName("one");
-        UniqueName two = registerName("two");
-        assertNotSame(one.id(), two.id());
-
-        ArrayList<UniqueName> nameList = new ArrayList<UniqueName>();
-
-        for (int index = 0; index < 2500; index++) {
-            UniqueName currentName = registerName("test" + index);
-            nameList.add(currentName);
-            for (UniqueName otherName : nameList) {
-                if (!currentName.name().equals(otherName.name())) {
-                    assertNotSame(currentName, otherName);
-                    assertNotSame(currentName.hashCode(), otherName.hashCode());
-                    assertFalse(currentName.equals(otherName));
-                    assertNotSame(currentName.toString(), otherName.toString());
-                }
-            }
-        }
-    }
-
-    @Test
-    public void testCompareNames() {
-        UniqueName one = registerName("One");
-        UniqueName two = registerName("Two");
-
-        ConcurrentMap<String, Boolean> mapTwo = PlatformDependent.newConcurrentHashMap();
-
-        UniqueName three = new UniqueName(mapTwo, "One");
-
-        assertSame(one.compareTo(one), 0);
-        assertSame(one.compareTo(two), -5);
-        assertSame(one.compareTo(three), -1);
-        assertSame(three.compareTo(one), 1);
-    }
-
-}
diff --git a/common/src/test/java/io/netty/util/collection/IntObjectHashMapTest.java b/common/src/test/java/io/netty/util/collection/IntObjectHashMapTest.java
new file mode 100644
index 000000000000..7f50134ef855
--- /dev/null
+++ b/common/src/test/java/io/netty/util/collection/IntObjectHashMapTest.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package io.netty.util.collection;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import static org.junit.Assert.*;
+
+/**
+ * Tests for {@link IntObjectHashMap}.
+ */
+public class IntObjectHashMapTest {
+
+    private static class Value {
+        private final String name;
+
+        Value(String name) {
+            this.name = name;
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + (name == null ? 0 : name.hashCode());
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null) {
+                return false;
+            }
+            if (getClass() != obj.getClass()) {
+                return false;
+            }
+            Value other = (Value) obj;
+            if (name == null) {
+                if (other.name != null) {
+                    return false;
+                }
+            } else if (!name.equals(other.name)) {
+                return false;
+            }
+            return true;
+        }
+    }
+
+    private IntObjectHashMap<Value> map;
+
+    @Before
+    public void setup() {
+        map = new IntObjectHashMap<Value>();
+    }
+
+    @Test
+    public void putNewMappingShouldSucceed() {
+        Value v = new Value("v");
+        assertNull(map.put(1, v));
+        assertEquals(1, map.size());
+        assertTrue(map.containsKey(1));
+        assertTrue(map.containsValue(v));
+        assertEquals(v, map.get(1));
+    }
+
+    @Test
+    public void putShouldReplaceValue() {
+        Value v1 = new Value("v1");
+        assertNull(map.put(1, v1));
+
+        // Replace the value.
+        Value v2 = new Value("v2");
+        assertSame(v1, map.put(1, v2));
+
+        assertEquals(1, map.size());
+        assertTrue(map.containsKey(1));
+        assertTrue(map.containsValue(v2));
+        assertEquals(v2, map.get(1));
+    }
+
+    @Test
+    public void putShouldGrowMap() {
+        for (int i = 0; i < 10000; ++i) {
+            Value v = new Value(Integer.toString(i));
+            assertNull(map.put(i, v));
+            assertEquals(i + 1, map.size());
+            assertTrue(map.containsKey(i));
+            assertTrue(map.containsValue(v));
+            assertEquals(v, map.get(i));
+        }
+    }
+
+    @Test
+    public void removeMissingValueShouldReturnNull() {
+        assertNull(map.remove(1));
+        assertEquals(0, map.size());
+    }
+
+    @Test
+    public void removeShouldReturnPreviousValue() {
+        Value v = new Value("v");
+        map.put(1, v);
+        assertSame(v, map.remove(1));
+    }
+
+    /**
+     * This test is a bit internal-centric. We're just forcing a rehash to occur based on no longer
+     * having any FREE slots available. We do this by adding and then removing several keys up to
+     * the capacity, so that no rehash is done. We then add one more, which will cause the rehash
+     * due to a lack of free slots and verify that everything is still behaving properly
+     */
+    @Test
+    public void noFreeSlotsShouldRehash() {
+        for (int i = 0; i < 10; ++i) {
+            map.put(i, new Value(Integer.toString(i)));
+            // Now mark it as REMOVED so that size won't cause the rehash.
+            map.remove(i);
+            assertEquals(0, map.size());
+        }
+
+        // Now add an entry to force the rehash since no FREE slots are available in the map.
+        Value v = new Value("v");
+        map.put(1, v);
+        assertEquals(1, map.size());
+        assertSame(v, map.get(1));
+    }
+
+    @Test
+    public void putAllShouldSucceed() {
+        Value v1 = new Value("v1");
+        Value v2 = new Value("v2");
+        Value v3 = new Value("v3");
+        map.put(1, v1);
+        map.put(2, v2);
+        map.put(3, v3);
+
+        IntObjectHashMap<Value> map2 = new IntObjectHashMap<Value>();
+        map2.putAll(map);
+        assertEquals(3, map2.size());
+        assertSame(v1, map2.get(1));
+        assertSame(v2, map2.get(2));
+        assertSame(v3, map2.get(3));
+    }
+
+    @Test
+    public void clearShouldSucceed() {
+        Value v1 = new Value("v1");
+        Value v2 = new Value("v2");
+        Value v3 = new Value("v3");
+        map.put(1, v1);
+        map.put(2, v2);
+        map.put(3, v3);
+        map.clear();
+        assertEquals(0, map.size());
+        assertTrue(map.isEmpty());
+    }
+
+    @Test
+    public void containsValueShouldFindNull() {
+        map.put(1, new Value("v1"));
+        map.put(2, null);
+        map.put(3, new Value("v2"));
+        assertTrue(map.containsValue(null));
+    }
+
+    @Test
+    public void containsValueShouldFindInstance() {
+        Value v = new Value("v1");
+        map.put(1, new Value("v2"));
+        map.put(2, new Value("v3"));
+        map.put(3, v);
+        assertTrue(map.containsValue(v));
+    }
+
+    @Test
+    public void containsValueShouldFindEquivalentValue() {
+        map.put(1, new Value("v1"));
+        map.put(2, new Value("v2"));
+        map.put(3, new Value("v3"));
+        assertTrue(map.containsValue(new Value("v2")));
+    }
+
+    @Test
+    public void containsValueNotFindMissingValue() {
+        map.put(1, new Value("v1"));
+        map.put(2, new Value("v2"));
+        map.put(3, new Value("v3"));
+        assertFalse(map.containsValue(new Value("v4")));
+    }
+
+    @Test
+    public void iteratorShouldTraverseEntries() {
+        map.put(1, new Value("v1"));
+        map.put(2, new Value("v2"));
+        map.put(3, new Value("v3"));
+
+        // Add and then immediately remove another entry.
+        map.put(4, new Value("v4"));
+        map.remove(4);
+
+        Set<Integer> found = new HashSet<Integer>();
+        for (IntObjectMap.Entry<Value> entry : map.entries()) {
+            assertTrue(found.add(entry.key()));
+        }
+        assertEquals(3, found.size());
+        assertTrue(found.contains(1));
+        assertTrue(found.contains(2));
+        assertTrue(found.contains(3));
+    }
+
+    @Test
+    public void keysShouldBeReturned() {
+        map.put(1, new Value("v1"));
+        map.put(2, new Value("v2"));
+        map.put(3, new Value("v3"));
+
+        // Add and then immediately remove another entry.
+        map.put(4, new Value("v4"));
+        map.remove(4);
+
+        int[] keys = map.keys();
+        assertEquals(3, keys.length);
+
+        Set<Integer> expected = new HashSet<Integer>();
+        expected.add(1);
+        expected.add(2);
+        expected.add(3);
+
+        Set<Integer> found = new HashSet<Integer>();
+        for (int key : keys) {
+            assertTrue(found.add(key));
+        }
+        assertEquals(expected, found);
+    }
+
+    @Test
+    public void valuesShouldBeReturned() {
+        Value v1 = new Value("v1");
+        Value v2 = new Value("v2");
+        Value v3 = new Value("v3");
+        map.put(1, v1);
+        map.put(2, v2);
+        map.put(3, v3);
+
+        // Add and then immediately remove another entry.
+        map.put(4, new Value("v4"));
+        map.remove(4);
+
+        Value[] values = map.values(Value.class);
+        assertEquals(3, values.length);
+
+        Set<Value> expected = new HashSet<Value>();
+        expected.add(v1);
+        expected.add(v2);
+        expected.add(v3);
+
+        Set<Value> found = new HashSet<Value>();
+        for (Value value : values) {
+            assertTrue(found.add(value));
+        }
+        assertEquals(expected, found);
+    }
+}
diff --git a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
index 519802c44915..26f304b09f39 100644
--- a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
+++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
@@ -19,8 +19,10 @@
 import org.junit.Test;
 
 import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
@@ -81,26 +83,9 @@ public void operationComplete(Future<Void> future) throws Exception {
 
     @Test
     public void testListenerNotifyOrder() throws Exception {
-        SingleThreadEventExecutor executor =
-                new SingleThreadEventExecutor(null, Executors.defaultThreadFactory(), true) {
-                    @Override
-                    protected void run() {
-                        for (;;) {
-                            Runnable task = takeTask();
-                            if (task != null) {
-                                task.run();
-                                updateLastExecutionTime();
-                            }
-
-                            if (confirmShutdown()) {
-                                break;
-                            }
-                        }
-                    }
-                };
-
+        EventExecutor executor = new TestEventExecutor();
         final BlockingQueue<FutureListener<Void>> listeners = new LinkedBlockingQueue<FutureListener<Void>>();
-        int runs = 20000;
+        int runs = 100000;
 
         for (int i = 0; i < runs; i++) {
             final Promise<Void> promise = new DefaultPromise<Void>(executor);
@@ -148,4 +133,67 @@ public void run() {
         }
         executor.shutdownGracefully().sync();
     }
+
+    @Test
+    public void testListenerNotifyLater() throws Exception {
+        // Testing first execution path in DefaultPromise
+        testListenerNotifyLater(1);
+
+        // Testing second execution path in DefaultPromise
+        testListenerNotifyLater(2);
+    }
+
+    private static void testListenerNotifyLater(final int numListenersBefore) throws Exception {
+        EventExecutor executor = new TestEventExecutor();
+        int expectedCount = numListenersBefore + 2;
+        final CountDownLatch latch = new CountDownLatch(expectedCount);
+        final FutureListener<Void> listener = new FutureListener<Void>() {
+            @Override
+            public void operationComplete(Future<Void> future) throws Exception {
+                latch.countDown();
+            }
+        };
+        final Promise<Void> promise = new DefaultPromise<Void>(executor);
+        executor.execute(new Runnable() {
+            @Override
+            public void run() {
+                for (int i = 0; i < numListenersBefore; i++) {
+                    promise.addListener(listener);
+                }
+                promise.setSuccess(null);
+
+                GlobalEventExecutor.INSTANCE.execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        promise.addListener(listener);
+                    }
+                });
+                promise.addListener(listener);
+            }
+        });
+
+        assertTrue("Should have notifed " + expectedCount + " listeners", latch.await(5, TimeUnit.SECONDS));
+        executor.shutdownGracefully().sync();
+    }
+
+    private static final class TestEventExecutor extends SingleThreadEventExecutor {
+        TestEventExecutor() {
+            super(null, Executors.defaultThreadFactory(), true);
+        }
+
+        @Override
+        protected void run() {
+            for (;;) {
+                Runnable task = takeTask();
+                if (task != null) {
+                    task.run();
+                    updateLastExecutionTime();
+                }
+
+                if (confirmShutdown()) {
+                    break;
+                }
+            }
+        }
+    }
 }
diff --git a/common/src/test/java/io/netty/util/concurrent/FastThreadLocalTest.java b/common/src/test/java/io/netty/util/concurrent/FastThreadLocalTest.java
new file mode 100644
index 000000000000..2a758781f048
--- /dev/null
+++ b/common/src/test/java/io/netty/util/concurrent/FastThreadLocalTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.concurrent;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.Matchers.nullValue;
+import static org.junit.Assert.*;
+
+public class FastThreadLocalTest {
+    @Before
+    public void setUp() {
+        FastThreadLocal.removeAll();
+        assertThat(FastThreadLocal.size(), is(0));
+    }
+
+    @Test(timeout = 10000)
+    public void testRemoveAll() throws Exception {
+        final AtomicBoolean removed = new AtomicBoolean();
+        final FastThreadLocal<Boolean> var = new FastThreadLocal<Boolean>() {
+            @Override
+            protected void onRemoval(Boolean value) {
+                removed.set(true);
+            }
+        };
+
+        // Initialize a thread-local variable.
+        assertThat(var.get(), is(nullValue()));
+        assertThat(FastThreadLocal.size(), is(1));
+
+        // And then remove it.
+        FastThreadLocal.removeAll();
+        assertThat(removed.get(), is(true));
+        assertThat(FastThreadLocal.size(), is(0));
+    }
+
+    @Test(timeout = 10000)
+    public void testRemoveAllFromFTLThread() throws Throwable {
+        final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();
+        final Thread thread = new FastThreadLocalThread() {
+            @Override
+            public void run() {
+                try {
+                    testRemoveAll();
+                } catch (Throwable t) {
+                    throwable.set(t);
+                }
+            }
+        };
+
+        thread.start();
+        thread.join();
+
+        Throwable t = throwable.get();
+        if (t != null) {
+            throw t;
+        }
+    }
+}
diff --git a/common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java b/common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java
index cbc65df5d558..ca37073301bc 100644
--- a/common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java
+++ b/common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java
@@ -86,7 +86,7 @@ public void testScheduledTasks() throws Exception {
 
         Thread.sleep(1500);
 
-        // Not it should be stopped.
+        // Now it should be stopped.
         assertThat(thread.isAlive(), is(false));
         assertThat(e.thread, sameInstance(thread));
     }
diff --git a/common/src/test/java/io/netty/util/internal/AppendableCharSequenceTest.java b/common/src/test/java/io/netty/util/internal/AppendableCharSequenceTest.java
index 3fca3e15693a..2d7bab4ec849 100644
--- a/common/src/test/java/io/netty/util/internal/AppendableCharSequenceTest.java
+++ b/common/src/test/java/io/netty/util/internal/AppendableCharSequenceTest.java
@@ -57,6 +57,13 @@ public void testAppendStringWithExpand() {
         testAppendString0(new AppendableCharSequence(2));
     }
 
+    @Test
+    public void testSubSequence() {
+        AppendableCharSequence master = new AppendableCharSequence(26);
+        master.append("abcdefghijlkmonpqrstuvwxyz");
+        assertEquals("abcdefghij", master.subSequence(0, 10).toString());
+    }
+
     private static void testSimpleAppend0(AppendableCharSequence seq) {
         String text = "testdata";
         for (int i = 0; i < text.length(); i++) {
diff --git a/common/src/test/java/io/netty/util/internal/TypeParameterMatcherTest.java b/common/src/test/java/io/netty/util/internal/TypeParameterMatcherTest.java
index 47d8fb439851..e427b6f58196 100644
--- a/common/src/test/java/io/netty/util/internal/TypeParameterMatcherTest.java
+++ b/common/src/test/java/io/netty/util/internal/TypeParameterMatcherTest.java
@@ -83,17 +83,14 @@ public abstract static class TypeZ<G extends AA, H extends BB> extends TypeY<CC,
 
     public static class TypeQ<I extends BBB> extends TypeZ<AAA, I> { }
 
-    @SuppressWarnings("ClassMayBeInterface")
     public static class A { }
     public static class AA extends A { }
     public static class AAA extends AA { }
 
-    @SuppressWarnings("ClassMayBeInterface")
     public static class B { }
     public static class BB extends B { }
     public static class BBB extends BB { }
 
-    @SuppressWarnings("ClassMayBeInterface")
     public static class C { }
     public static class CC extends C { }
 
@@ -104,7 +101,6 @@ public void testInaccessibleClass() throws Exception {
         assertTrue(m.match(new T()));
     }
 
-    @SuppressWarnings("ClassMayBeInterface")
     private static class T { }
     private static class U<E> { E a; }
 
diff --git a/example/pom.xml b/example/pom.xml
index 1a8db489f3f8..344342e0d324 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-example</artifactId>
@@ -29,9 +29,6 @@
 
   <name>Netty/Example</name>
 
-  <properties>
-    <npn.version>1.1.6.v20130911</npn.version>
-  </properties>
   <dependencies>
     <dependency>
       <groupId>${project.groupId}</groupId>
@@ -53,15 +50,34 @@
       <artifactId>netty-codec-http</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec-memcache</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>netty-codec-socks</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec-stomp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.google.protobuf</groupId>
       <artifactId>protobuf-java</artifactId>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-tcnative</artifactId>
+      <classifier>${os.detected.classifier}</classifier>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.jetty.npn</groupId>
+      <artifactId>npn-api</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.jcraft</groupId>
       <artifactId>jzlib</artifactId>
@@ -72,10 +88,6 @@
       <artifactId>javassist</artifactId>
       <scope>runtime</scope>
     </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty.npn</groupId>
-      <artifactId>npn-api</artifactId>
-    </dependency>
 
     <!-- see https://github.com/netty/netty/issues/874 -->
     <dependency>
@@ -96,177 +108,24 @@
 
   <build>
     <plugins>
+      <!-- run-example.sh invokes this plugin to launch an example. -->
       <plugin>
-        <artifactId>maven-dependency-plugin</artifactId>
-        <executions>
-          <execution>
-            <id>copy</id>
-            <phase>generate-resources</phase>
-            <goals>
-              <goal>copy</goal>
-            </goals>
-            <configuration>
-              <artifactItems>
-                <artifactItem>
-                  <groupId>org.mortbay.jetty.npn</groupId>
-                  <artifactId>npn-boot</artifactId>
-                  <version>${npn.version}</version>
-                  <type>jar</type>
-                  <overWrite>false</overWrite>
-                  <outputDirectory>${project.build.directory}/npn</outputDirectory>
-                </artifactItem>
-              </artifactItems>
-            </configuration>
-          </execution>
-        </executions>
+        <groupId>kr.motd.maven</groupId>
+        <artifactId>exec-maven-plugin</artifactId>
+        <configuration>
+          <executable>${java.home}/bin/java</executable>
+          <commandlineArgs>
+            ${argLine.common}
+            ${argLine.bootcp}
+            -classpath %classpath
+            ${argLine.leak}
+            ${argLine.coverage}
+            ${argLine.example}
+            ${exampleClass}
+          </commandlineArgs>
+        </configuration>
       </plugin>
     </plugins>
   </build>
-
-  <profiles>
-    <profile>
-      <id>spdy-server</id>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.codehaus.mojo</groupId>
-            <artifactId>exec-maven-plugin</artifactId>
-            <configuration>
-              <executable>${java.home}/bin/java</executable>
-              <arguments>
-                <argument>-Xbootclasspath/p:${project.build.directory}/npn/npn-boot-${npn.version}.jar</argument>
-                <argument>-classpath</argument>
-                <classpath/>
-                <argument>io.netty.example.spdy.server.SpdyServer</argument>
-              </arguments>
-              <classpathScope>runtime</classpathScope>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-    <profile>
-      <id>spdy-client</id>
-      <build>
-        <plugins>
-          <plugin>
-            <groupId>org.codehaus.mojo</groupId>
-            <artifactId>exec-maven-plugin</artifactId>
-            <configuration>
-              <executable>${java.home}/bin/java</executable>
-              <arguments>
-                <argument>-Xbootclasspath/p:${project.build.directory}/npn/npn-boot-${npn.version}.jar</argument>
-                <argument>-classpath</argument>
-                <classpath/>
-                <argument>io.netty.example.spdy.client.SpdyClient</argument>
-              </arguments>
-              <classpathScope>runtime</classpathScope>
-            </configuration>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-
-    <!--
-      profiles for the various npn vs OpenJDK version as found on:
-      http://www.eclipse.org/jetty/documentation/current/npn-chapter.html#npn-versions
-    -->
-    <profile>
-      <id>7u9</id>
-      <activation>
-        <property>
-          <name>java.version</name>
-          <value>1.7.0_9</value>
-        </property>
-      </activation>
-      <properties>
-        <npn.version>1.1.3.v20130313</npn.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>7u10</id>
-      <activation>
-        <property>
-          <name>java.version</name>
-          <value>1.7.0_10</value>
-        </property>
-      </activation>
-      <properties>
-        <npn.version>1.1.3.v20130313</npn.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>7u11</id>
-      <activation>
-        <property>
-          <name>java.version</name>
-          <value>1.7.0_11</value>
-        </property>
-      </activation>
-      <properties>
-        <npn.version>1.1.3.v20130313</npn.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>7u13</id>
-      <activation>
-        <property>
-          <name>java.version</name>
-          <value>1.7.0_13</value>
-        </property>
-      </activation>
-      <properties>
-        <npn.version>1.1.4.v20130313</npn.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>7u15</id>
-      <activation>
-        <property>
-          <name>java.version</name>
-          <value>1.7.0_15</value>
-        </property>
-      </activation>
-      <properties>
-        <npn.version>1.1.5.v20130313</npn.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>7u17</id>
-      <activation>
-        <property>
-          <name>java.version</name>
-          <value>1.7.0_17</value>
-        </property>
-      </activation>
-      <properties>
-        <npn.version>1.1.5.v20130313</npn.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>7u21</id>
-      <activation>
-        <property>
-          <name>java.version</name>
-          <value>1.7.0_21</value>
-        </property>
-      </activation>
-      <properties>
-        <npn.version>1.1.5.v20130313</npn.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>7u25</id>
-      <activation>
-        <property>
-          <name>java.version</name>
-          <value>1.7.0_25</value>
-        </property>
-      </activation>
-      <properties>
-        <npn.version>1.1.5.v20130313</npn.version>
-      </properties>
-    </profile>
-  </profiles>
 </project>
 
diff --git a/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java
deleted file mode 100644
index fac2276e6fdb..000000000000
--- a/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.applet;
-
-import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.channel.socket.nio.NioServerSocketChannel;
-import io.netty.util.CharsetUtil;
-
-import javax.swing.JApplet;
-
-/**
- * {@link JApplet} which starts up a Server that receive data and discard it.
- */
-public class AppletDiscardServer extends JApplet {
-
-    private static final long serialVersionUID = -7824894101960583175L;
-
-    private EventLoopGroup bossGroup;
-    private EventLoopGroup workerGroup;
-
-    @Override
-    public void init() {
-        bossGroup = new NioEventLoopGroup(1);
-        workerGroup = new NioEventLoopGroup();
-        try {
-            ServerBootstrap bootstrap = new ServerBootstrap();
-            bootstrap.group(bossGroup, workerGroup)
-                     .channel(NioServerSocketChannel.class)
-                     .childHandler(new ChannelInitializer<SocketChannel>() {
-                         @Override
-                         public void initChannel(SocketChannel ch) throws Exception {
-                             ch.pipeline().addLast(new DiscardServerHandler());
-                         }
-                     });
-            ChannelFuture f = bootstrap.bind(9999).sync();
-            f.channel().closeFuture().sync();
-        } catch (Exception ex) {
-            ex.printStackTrace();
-            throw new RuntimeException(ex);
-        }
-    }
-
-    @Override
-    public void destroy() {
-        super.destroy();
-        if (bossGroup != null) {
-            bossGroup.shutdownGracefully();
-        }
-        if (workerGroup != null) {
-            workerGroup.shutdownGracefully();
-        }
-    }
-
-    private static final class DiscardServerHandler extends SimpleChannelInboundHandler<ByteBuf> {
-
-        @Override
-        public void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
-            System.out.println("Received: " + msg.toString(CharsetUtil.UTF_8));
-        }
-
-        @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-            cause.printStackTrace();
-            ctx.close();
-        }
-    }
-}
diff --git a/example/src/main/java/io/netty/example/discard/DiscardClient.java b/example/src/main/java/io/netty/example/discard/DiscardClient.java
index 657f28e43714..1f3d57b4cb0a 100644
--- a/example/src/main/java/io/netty/example/discard/DiscardClient.java
+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java
@@ -17,35 +17,52 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 /**
  * Keeps sending random data to the specified address.
  */
-public class DiscardClient {
+public final class DiscardClient {
 
-    private final String host;
-    private final int port;
-    private final int firstMessageSize;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8009"));
+    static final int SIZE = Integer.parseInt(System.getProperty("size", "256"));
 
-    public DiscardClient(String host, int port, int firstMessageSize) {
-        this.host = host;
-        this.port = port;
-        this.firstMessageSize = firstMessageSize;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
             b.group(group)
              .channel(NioSocketChannel.class)
-             .handler(new DiscardClientHandler(firstMessageSize));
+             .handler(new ChannelInitializer<SocketChannel>() {
+                 @Override
+                 protected void initChannel(SocketChannel ch) throws Exception {
+                     ChannelPipeline p = ch.pipeline();
+                     if (sslCtx != null) {
+                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));
+                     }
+                     p.addLast(new DiscardClientHandler());
+                 }
+             });
 
             // Make the connection attempt.
-            ChannelFuture f = b.connect(host, port).sync();
+            ChannelFuture f = b.connect(HOST, PORT).sync();
 
             // Wait until the connection is closed.
             f.channel().closeFuture().sync();
@@ -53,26 +70,4 @@ public void run() throws Exception {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length < 2 || args.length > 3) {
-            System.err.println(
-                    "Usage: " + DiscardClient.class.getSimpleName() +
-                    " <host> <port> [<first message size>]");
-            return;
-        }
-
-        // Parse options.
-        final String host = args[0];
-        final int port = Integer.parseInt(args[1]);
-        final int firstMessageSize;
-        if (args.length == 3) {
-            firstMessageSize = Integer.parseInt(args[2]);
-        } else {
-            firstMessageSize = 256;
-        }
-
-        new DiscardClient(host, port, firstMessageSize).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
index 396c43049d82..0baf355fae8a 100644
--- a/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
+++ b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
@@ -21,43 +21,27 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handles a client-side channel.
  */
 public class DiscardClientHandler extends SimpleChannelInboundHandler<Object> {
 
-    private static final Logger logger = Logger.getLogger(
-            DiscardClientHandler.class.getName());
-
-    private final int messageSize;
     private ByteBuf content;
     private ChannelHandlerContext ctx;
 
-    public DiscardClientHandler(int messageSize) {
-        if (messageSize <= 0) {
-            throw new IllegalArgumentException(
-                    "messageSize: " + messageSize);
-        }
-        this.messageSize = messageSize;
-    }
-
     @Override
-    public void channelActive(ChannelHandlerContext ctx)
-            throws Exception {
+    public void channelActive(ChannelHandlerContext ctx) {
         this.ctx = ctx;
 
         // Initialize the message.
-        content = ctx.alloc().directBuffer(messageSize).writeZero(messageSize);
+        content = ctx.alloc().directBuffer(DiscardClient.SIZE).writeZero(DiscardClient.SIZE);
 
         // Send the initial messages.
         generateTraffic();
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) {
         content.release();
     }
 
@@ -67,13 +51,9 @@ public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx,
-            Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         // Close the connection when an exception is raised.
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.",
-                cause);
+        cause.printStackTrace();
         ctx.close();
     }
 
@@ -87,9 +67,12 @@ private void generateTraffic() {
 
     private final ChannelFutureListener trafficGenerator = new ChannelFutureListener() {
         @Override
-        public void operationComplete(ChannelFuture future) throws Exception {
+        public void operationComplete(ChannelFuture future) {
             if (future.isSuccess()) {
                 generateTraffic();
+            } else {
+                future.cause().printStackTrace();
+                future.channel().close();
             }
         }
     };
diff --git a/example/src/main/java/io/netty/example/discard/DiscardServer.java b/example/src/main/java/io/netty/example/discard/DiscardServer.java
index ca253572aefd..81dd9e2217f2 100644
--- a/example/src/main/java/io/netty/example/discard/DiscardServer.java
+++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java
@@ -18,38 +18,54 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * Discards any incoming data.
  */
-public class DiscardServer {
+public final class DiscardServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8009"));
 
-    public DiscardServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
+             .handler(new LoggingHandler(LogLevel.INFO))
              .childHandler(new ChannelInitializer<SocketChannel>() {
                  @Override
-                 public void initChannel(SocketChannel ch) throws Exception {
-                     ch.pipeline().addLast(new DiscardServerHandler());
+                 public void initChannel(SocketChannel ch) {
+                     ChannelPipeline p = ch.pipeline();
+                     if (sslCtx != null) {
+                         p.addLast(sslCtx.newHandler(ch.alloc()));
+                     }
+                     p.addLast(new DiscardServerHandler());
                  }
              });
 
             // Bind and start to accept incoming connections.
-            ChannelFuture f = b.bind(port).sync();
+            ChannelFuture f = b.bind(PORT).sync();
 
             // Wait until the server socket is closed.
             // In this example, this does not happen, but you can do that to gracefully
@@ -60,14 +76,4 @@ public void initChannel(SocketChannel ch) throws Exception {
             bossGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new DiscardServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
index a9ab5ee08dd5..1f72a878ede1 100644
--- a/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
+++ b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
@@ -18,30 +18,20 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handles a server-side channel.
  */
 public class DiscardServerHandler extends SimpleChannelInboundHandler<Object> {
 
-    private static final Logger logger = Logger.getLogger(
-            DiscardServerHandler.class.getName());
-
     @Override
     public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
         // discard
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx,
-            Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         // Close the connection when an exception is raised.
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.",
-                cause);
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/echo/EchoClient.java b/example/src/main/java/io/netty/example/echo/EchoClient.java
index 15eafffab986..f0023e897582 100644
--- a/example/src/main/java/io/netty/example/echo/EchoClient.java
+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java
@@ -19,10 +19,13 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 /**
  * Sends one message when a connection is open and echoes back any received
@@ -30,19 +33,22 @@
  * traffic between the echo client and server by sending the first message to
  * the server.
  */
-public class EchoClient {
+public final class EchoClient {
 
-    private final String host;
-    private final int port;
-    private final int firstMessageSize;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
+    static final int SIZE = Integer.parseInt(System.getProperty("size", "256"));
 
-    public EchoClient(String host, int port, int firstMessageSize) {
-        this.host = host;
-        this.port = port;
-        this.firstMessageSize = firstMessageSize;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.git
+        final SslContext sslCtx;
+        if (SSL) {
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         // Configure the client.
         EventLoopGroup group = new NioEventLoopGroup();
         try {
@@ -53,14 +59,17 @@ public void run() throws Exception {
              .handler(new ChannelInitializer<SocketChannel>() {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
-                     ch.pipeline().addLast(
-                             //new LoggingHandler(LogLevel.INFO),
-                             new EchoClientHandler(firstMessageSize));
+                     ChannelPipeline p = ch.pipeline();
+                     if (sslCtx != null) {
+                         p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));
+                     }
+                     //p.addLast(new LoggingHandler(LogLevel.INFO));
+                     p.addLast(new EchoClientHandler());
                  }
              });
 
             // Start the client.
-            ChannelFuture f = b.connect(host, port).sync();
+            ChannelFuture f = b.connect(HOST, PORT).sync();
 
             // Wait until the connection is closed.
             f.channel().closeFuture().sync();
@@ -69,26 +78,4 @@ public void initChannel(SocketChannel ch) throws Exception {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length < 2 || args.length > 3) {
-            System.err.println(
-                    "Usage: " + EchoClient.class.getSimpleName() +
-                    " <host> <port> [<first message size>]");
-            return;
-        }
-
-        // Parse options.
-        final String host = args[0];
-        final int port = Integer.parseInt(args[1]);
-        final int firstMessageSize;
-        if (args.length == 3) {
-            firstMessageSize = Integer.parseInt(args[2]);
-        } else {
-            firstMessageSize = 256;
-        }
-
-        new EchoClient(host, port, firstMessageSize).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/echo/EchoClientHandler.java b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java
index a70c0570b520..1bab895236a6 100644
--- a/example/src/main/java/io/netty/example/echo/EchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java
@@ -20,9 +20,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the echo client.  It initiates the ping-pong
  * traffic between the echo client and server by sending the first message to
@@ -30,19 +27,13 @@
  */
 public class EchoClientHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger logger = Logger.getLogger(
-            EchoClientHandler.class.getName());
-
     private final ByteBuf firstMessage;
 
     /**
      * Creates a client-side handler.
      */
-    public EchoClientHandler(int firstMessageSize) {
-        if (firstMessageSize <= 0) {
-            throw new IllegalArgumentException("firstMessageSize: " + firstMessageSize);
-        }
-        firstMessage = Unpooled.buffer(firstMessageSize);
+    public EchoClientHandler() {
+        firstMessage = Unpooled.buffer(EchoClient.SIZE);
         for (int i = 0; i < firstMessage.capacity(); i ++) {
             firstMessage.writeByte((byte) i);
         }
@@ -54,19 +45,19 @@ public void channelActive(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         ctx.write(msg);
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         // Close the connection when an exception is raised.
-        logger.log(Level.WARNING, "Unexpected exception from downstream.", cause);
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/echo/EchoServer.java b/example/src/main/java/io/netty/example/echo/EchoServer.java
index 8c85b58effcb..b4e4029bbb4c 100644
--- a/example/src/main/java/io/netty/example/echo/EchoServer.java
+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java
@@ -19,25 +19,34 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * Echoes back any received data from a client.
  */
-public class EchoServer {
+public final class EchoServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
 
-    public EchoServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         // Configure the server.
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
@@ -50,14 +59,17 @@ public void run() throws Exception {
              .childHandler(new ChannelInitializer<SocketChannel>() {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
-                     ch.pipeline().addLast(
-                             //new LoggingHandler(LogLevel.INFO),
-                             new EchoServerHandler());
+                     ChannelPipeline p = ch.pipeline();
+                     if (sslCtx != null) {
+                         p.addLast(sslCtx.newHandler(ch.alloc()));
+                     }
+                     //p.addLast(new LoggingHandler(LogLevel.INFO));
+                     p.addLast(new EchoServerHandler());
                  }
              });
 
             // Start the server.
-            ChannelFuture f = b.bind(port).sync();
+            ChannelFuture f = b.bind(PORT).sync();
 
             // Wait until the server socket is closed.
             f.channel().closeFuture().sync();
@@ -67,14 +79,4 @@ public void initChannel(SocketChannel ch) throws Exception {
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new EchoServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/echo/EchoServerHandler.java b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java
index a68b7637b013..095e2c3a20e4 100644
--- a/example/src/main/java/io/netty/example/echo/EchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java
@@ -19,32 +19,26 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the echo server.
  */
 @Sharable
 public class EchoServerHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger logger = Logger.getLogger(
-            EchoServerHandler.class.getName());
-
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         ctx.write(msg);
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         // Close the connection when an exception is raised.
-        logger.log(Level.WARNING, "Unexpected exception from downstream.", cause);
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java b/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
index a635ba50449b..71bb6e355008 100644
--- a/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
+++ b/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
@@ -44,8 +44,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
         int magicNumber = in.readUnsignedByte();
         if (magicNumber != 'F') {
             in.resetReaderIndex();
-            throw new CorruptedFrameException(
-                    "Invalid magic number: " + magicNumber);
+            throw new CorruptedFrameException("Invalid magic number: " + magicNumber);
         }
 
         // Wait until the whole data is available.
diff --git a/example/src/main/java/io/netty/example/factorial/FactorialClient.java b/example/src/main/java/io/netty/example/factorial/FactorialClient.java
index a7e77cbf2a1f..38c8855066a3 100644
--- a/example/src/main/java/io/netty/example/factorial/FactorialClient.java
+++ b/example/src/main/java/io/netty/example/factorial/FactorialClient.java
@@ -20,63 +20,47 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 /**
  * Sends a sequence of integers to a {@link FactorialServer} to calculate
  * the factorial of the specified integer.
  */
-public class FactorialClient {
+public final class FactorialClient {
 
-    private final String host;
-    private final int port;
-    private final int count;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8322"));
+    static final int COUNT = Integer.parseInt(System.getProperty("count", "1000"));
 
-    public FactorialClient(String host, int port, int count) {
-        this.host = host;
-        this.port = port;
-        this.count = count;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
             b.group(group)
              .channel(NioSocketChannel.class)
-             .handler(new FactorialClientInitializer(count));
+             .handler(new FactorialClientInitializer(sslCtx));
 
             // Make a new connection.
-            ChannelFuture f = b.connect(host, port).sync();
+            ChannelFuture f = b.connect(HOST, PORT).sync();
 
             // Get the handler instance to retrieve the answer.
             FactorialClientHandler handler =
                 (FactorialClientHandler) f.channel().pipeline().last();
 
             // Print out the answer.
-            System.err.format(
-                    "Factorial of %,d is: %,d", count, handler.getFactorial());
+            System.err.format("Factorial of %,d is: %,d", COUNT, handler.getFactorial());
         } finally {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length != 3) {
-            System.err.println(
-                    "Usage: " + FactorialClient.class.getSimpleName() +
-                    " <host> <port> <count>");
-            return;
-        }
-
-        // Parse options.
-        String host = args[0];
-        int port = Integer.parseInt(args[1]);
-        int count = Integer.parseInt(args[2]);
-        if (count <= 0) {
-            throw new IllegalArgumentException("count must be a positive integer.");
-        }
-
-        new FactorialClient(host, port, count).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java b/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
index eb678cdb7fb8..257eba81ae17 100644
--- a/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
+++ b/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
@@ -23,8 +23,6 @@
 import java.math.BigInteger;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * Handler for a client-side channel.  This handler maintains stateful
@@ -35,30 +33,24 @@
  */
 public class FactorialClientHandler extends SimpleChannelInboundHandler<BigInteger> {
 
-    private static final Logger logger = Logger.getLogger(
-            FactorialClientHandler.class.getName());
-
     private ChannelHandlerContext ctx;
     private int receivedMessages;
     private int next = 1;
-    private final int count;
     final BlockingQueue<BigInteger> answer = new LinkedBlockingQueue<BigInteger>();
 
-    public FactorialClientHandler(int count) {
-        this.count = count;
-    }
-
     public BigInteger getFactorial() {
         boolean interrupted = false;
-        for (;;) {
-            try {
-                BigInteger factorial = answer.take();
-                if (interrupted) {
-                    Thread.currentThread().interrupt();
+        try {
+            for (;;) {
+                try {
+                    return answer.take();
+                } catch (InterruptedException ignore) {
+                    interrupted = true;
                 }
-                return factorial;
-            } catch (InterruptedException e) {
-                interrupted = true;
+            }
+        } finally {
+            if (interrupted) {
+                Thread.currentThread().interrupt();
             }
         }
     }
@@ -72,7 +64,7 @@ public void channelActive(ChannelHandlerContext ctx) {
     @Override
     public void channelRead0(ChannelHandlerContext ctx, final BigInteger msg) {
         receivedMessages ++;
-        if (receivedMessages == count) {
+        if (receivedMessages == FactorialClient.COUNT) {
             // Offer the answer after closing the connection.
             ctx.channel().close().addListener(new ChannelFutureListener() {
                 @Override
@@ -85,22 +77,19 @@ public void operationComplete(ChannelFuture future) {
     }
 
     @Override
-    public void exceptionCaught(
-            ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 
     private void sendNumbers() {
         // Do not send more than 4096 numbers.
         ChannelFuture future = null;
-        for (int i = 0; i < 4096 && next <= count; i++) {
+        for (int i = 0; i < 4096 && next <= FactorialClient.COUNT; i++) {
             future = ctx.write(Integer.valueOf(next));
             next++;
         }
-        if (next <= count) {
+        if (next <= FactorialClient.COUNT) {
             assert future != null;
             future.addListener(numberSender);
         }
@@ -112,6 +101,9 @@ private void sendNumbers() {
         public void operationComplete(ChannelFuture future) throws Exception {
             if (future.isSuccess()) {
                 sendNumbers();
+            } else {
+                future.cause().printStackTrace();
+                future.channel().close();
             }
         }
     };
diff --git a/example/src/main/java/io/netty/example/factorial/FactorialClientInitializer.java b/example/src/main/java/io/netty/example/factorial/FactorialClientInitializer.java
index 959c1d6ffcf7..ecfdfebd4e5d 100644
--- a/example/src/main/java/io/netty/example/factorial/FactorialClientInitializer.java
+++ b/example/src/main/java/io/netty/example/factorial/FactorialClientInitializer.java
@@ -20,31 +20,36 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
+import io.netty.handler.ssl.SslContext;
 
 /**
  * Creates a newly configured {@link ChannelPipeline} for a client-side channel.
  */
 public class FactorialClientInitializer extends ChannelInitializer<SocketChannel> {
 
-    private final int count;
+    private final SslContext sslCtx;
 
-    public FactorialClientInitializer(int count) {
-        this.count = count;
+    public FactorialClientInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
     }
 
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
 
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc(), FactorialClient.HOST, FactorialClient.PORT));
+        }
+
         // Enable stream compression (you can remove these two if unnecessary)
-        pipeline.addLast("deflater", ZlibCodecFactory.newZlibEncoder(ZlibWrapper.GZIP));
-        pipeline.addLast("inflater", ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));
+        pipeline.addLast(ZlibCodecFactory.newZlibEncoder(ZlibWrapper.GZIP));
+        pipeline.addLast(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));
 
         // Add the number codec first,
-        pipeline.addLast("decoder", new BigIntegerDecoder());
-        pipeline.addLast("encoder", new NumberEncoder());
+        pipeline.addLast(new BigIntegerDecoder());
+        pipeline.addLast(new NumberEncoder());
 
         // and then business logic.
-        pipeline.addLast("handler", new FactorialClientHandler(count));
+        pipeline.addLast(new FactorialClientHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/factorial/FactorialServer.java b/example/src/main/java/io/netty/example/factorial/FactorialServer.java
index f21f6080480b..73f2c7264472 100644
--- a/example/src/main/java/io/netty/example/factorial/FactorialServer.java
+++ b/example/src/main/java/io/netty/example/factorial/FactorialServer.java
@@ -19,42 +19,43 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * Receives a sequence of integers from a {@link FactorialClient} to calculate
  * the factorial of the specified integer.
  */
-public class FactorialServer {
+public final class FactorialServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8322"));
 
-    public FactorialServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new FactorialServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new FactorialServerInitializer(sslCtx));
 
-            b.bind(port).sync().channel().closeFuture().sync();
+            b.bind(PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new FactorialServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java b/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java
index 236993c6d42f..3b11c1fa53d2 100644
--- a/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java
+++ b/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java
@@ -19,9 +19,6 @@
 import io.netty.channel.SimpleChannelInboundHandler;
 
 import java.math.BigInteger;
-import java.util.Formatter;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * Handler for a server-side channel.  This handler maintains stateful
@@ -32,9 +29,6 @@
  */
 public class FactorialServerHandler extends SimpleChannelInboundHandler<BigInteger> {
 
-    private static final Logger logger = Logger.getLogger(
-            FactorialServerHandler.class.getName());
-
     private BigInteger lastMultiplier = new BigInteger("1");
     private BigInteger factorial = new BigInteger("1");
 
@@ -48,17 +42,12 @@ public void channelRead0(ChannelHandlerContext ctx, BigInteger msg) throws Excep
 
     @Override
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        Formatter fmt = new Formatter();
-        logger.info(fmt.format(
-                "Factorial of %,d is: %,d", lastMultiplier, factorial).toString());
-        fmt.close();
+        System.err.printf("Factorial of %,d is: %,d%n", lastMultiplier, factorial);
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/factorial/FactorialServerInitializer.java b/example/src/main/java/io/netty/example/factorial/FactorialServerInitializer.java
index df2fba4bea91..aeeb9802e256 100644
--- a/example/src/main/java/io/netty/example/factorial/FactorialServerInitializer.java
+++ b/example/src/main/java/io/netty/example/factorial/FactorialServerInitializer.java
@@ -20,26 +20,38 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
+import io.netty.handler.ssl.SslContext;
 
 /**
  * Creates a newly configured {@link ChannelPipeline} for a server-side channel.
  */
 public class FactorialServerInitializer extends ChannelInitializer<SocketChannel> {
+
+    private final SslContext sslCtx;
+
+    public FactorialServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
+
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
 
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
+        }
+
         // Enable stream compression (you can remove these two if unnecessary)
-        pipeline.addLast("deflater", ZlibCodecFactory.newZlibEncoder(ZlibWrapper.GZIP));
-        pipeline.addLast("inflater", ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));
+        pipeline.addLast(ZlibCodecFactory.newZlibEncoder(ZlibWrapper.GZIP));
+        pipeline.addLast(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));
 
         // Add the number codec first,
-        pipeline.addLast("decoder", new BigIntegerDecoder());
-        pipeline.addLast("encoder", new NumberEncoder());
+        pipeline.addLast(new BigIntegerDecoder());
+        pipeline.addLast(new NumberEncoder());
 
         // and then business logic.
         // Please note we create a handler for every new channel
         // because it has stateful properties.
-        pipeline.addLast("handler", new FactorialServerHandler());
+        pipeline.addLast(new FactorialServerHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/factorial/NumberEncoder.java b/example/src/main/java/io/netty/example/factorial/NumberEncoder.java
index f667d64926f2..5b9887769827 100644
--- a/example/src/main/java/io/netty/example/factorial/NumberEncoder.java
+++ b/example/src/main/java/io/netty/example/factorial/NumberEncoder.java
@@ -29,7 +29,7 @@
 public class NumberEncoder extends MessageToByteEncoder<Number> {
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, Number msg, ByteBuf out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, Number msg, ByteBuf out) {
         // Convert to a BigInteger first for easier implementation.
         BigInteger v;
         if (msg instanceof BigInteger) {
diff --git a/example/src/main/java/io/netty/example/filetransfer/FileServer.java b/example/src/main/java/io/netty/example/file/FileServer.java
similarity index 59%
rename from example/src/main/java/io/netty/example/filetransfer/FileServer.java
rename to example/src/main/java/io/netty/example/file/FileServer.java
index 340009267018..f03f42aa7ddb 100644
--- a/example/src/main/java/io/netty/example/filetransfer/FileServer.java
+++ b/example/src/main/java/io/netty/example/file/FileServer.java
@@ -13,17 +13,14 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.example.filetransfer;
+package io.netty.example.file;
 
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
-import io.netty.channel.DefaultFileRegion;
+import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
-import io.netty.channel.FileRegion;
-import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
@@ -32,23 +29,30 @@
 import io.netty.handler.codec.string.StringEncoder;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
+import io.netty.handler.stream.ChunkedWriteHandler;
 import io.netty.util.CharsetUtil;
 
-import java.io.File;
-import java.io.FileInputStream;
-
 /**
  * Server that accept the path of a file an echo back its content.
  */
-public class FileServer {
+public final class FileServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    // Use the same default port with the telnet example so that we can use the telnet client example to access it.
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8992" : "8023"));
 
-    public FileServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         // Configure the server.
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
@@ -61,16 +65,21 @@ public void run() throws Exception {
              .childHandler(new ChannelInitializer<SocketChannel>() {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
-                     ch.pipeline().addLast(
+                     ChannelPipeline p = ch.pipeline();
+                     if (sslCtx != null) {
+                         p.addLast(sslCtx.newHandler(ch.alloc()));
+                     }
+                     p.addLast(
                              new StringEncoder(CharsetUtil.UTF_8),
                              new LineBasedFrameDecoder(8192),
                              new StringDecoder(CharsetUtil.UTF_8),
-                             new FileHandler());
+                             new ChunkedWriteHandler(),
+                             new FileServerHandler());
                  }
              });
 
             // Start the server.
-            ChannelFuture f = b.bind(port).sync();
+            ChannelFuture f = b.bind(PORT).sync();
 
             // Wait until the server socket is closed.
             f.channel().closeFuture().sync();
@@ -80,41 +89,4 @@ public void initChannel(SocketChannel ch) throws Exception {
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new FileServer(port).run();
-    }
-
-    private static final class FileHandler extends SimpleChannelInboundHandler<String> {
-        @Override
-        public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
-            File file = new File(msg);
-            if (file.exists()) {
-                if (!file.isFile()) {
-                    ctx.writeAndFlush("Not a file: " + file + '\n');
-                    return;
-                }
-                ctx.write(file + " " + file.length() + '\n');
-                FileInputStream fis = new FileInputStream(file);
-                FileRegion region = new DefaultFileRegion(fis.getChannel(), 0, file.length());
-                ctx.write(region);
-                ctx.writeAndFlush("\n");
-                fis.close();
-            } else {
-                ctx.writeAndFlush("File not found: " + file + '\n');
-            }
-        }
-
-        @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-            cause.printStackTrace();
-            ctx.close();
-        }
-    }
 }
diff --git a/example/src/main/java/io/netty/example/file/FileServerHandler.java b/example/src/main/java/io/netty/example/file/FileServerHandler.java
new file mode 100644
index 000000000000..d117bf8e2ddc
--- /dev/null
+++ b/example/src/main/java/io/netty/example/file/FileServerHandler.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.example.file;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.DefaultFileRegion;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.handler.ssl.SslHandler;
+import io.netty.handler.stream.ChunkedFile;
+
+import java.io.RandomAccessFile;
+
+public class FileServerHandler extends SimpleChannelInboundHandler<String> {
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) {
+        ctx.writeAndFlush("HELO: Type the path of the file to retrieve.\n");
+    }
+
+    @Override
+    public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
+        RandomAccessFile raf = null;
+        long length = -1;
+        try {
+            raf = new RandomAccessFile(msg, "r");
+            length = raf.length();
+        } catch (Exception e) {
+            ctx.writeAndFlush("ERR: " + e.getClass().getSimpleName() + ": " + e.getMessage() + '\n');
+            return;
+        } finally {
+            if (length < 0 && raf != null) {
+                raf.close();
+            }
+        }
+
+        ctx.write("OK: " + raf.length() + '\n');
+        if (ctx.pipeline().get(SslHandler.class) == null) {
+            // SSL not enabled - can use zero-copy file transfer.
+            ctx.write(new DefaultFileRegion(raf.getChannel(), 0, length));
+        } else {
+            // SSL enabled - cannot use zero-copy file transfer.
+            ctx.write(new ChunkedFile(raf));
+        }
+        ctx.writeAndFlush("\n");
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
+
+        if (ctx.channel().isActive()) {
+            ctx.writeAndFlush("ERR: " +
+                    cause.getClass().getSimpleName() + ": " +
+                    cause.getMessage() + '\n').addListener(ChannelFutureListener.CLOSE);
+        }
+    }
+}
+
diff --git a/example/src/main/java/io/netty/example/http/cors/HttpServer.java b/example/src/main/java/io/netty/example/http/cors/HttpCorsServer.java
similarity index 77%
rename from example/src/main/java/io/netty/example/http/cors/HttpServer.java
rename to example/src/main/java/io/netty/example/http/cors/HttpCorsServer.java
index 631e13c3b6ee..203893611f44 100644
--- a/example/src/main/java/io/netty/example/http/cors/HttpServer.java
+++ b/example/src/main/java/io/netty/example/http/cors/HttpCorsServer.java
@@ -19,6 +19,10 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * This example server aims to demonstrate
@@ -27,7 +31,7 @@
  * a html page that is loaded to try out CORS support in a web brower.
  * <p>
  *
- * CORS is configured in {@link HttpServerInitializer} and by updating the config you can
+ * CORS is configured in {@link HttpCorsServerInitializer} and by updating the config you can
  * try out various combinations, like using a specific origin instead of a
  * wildcard origin ('*').
  * <p>
@@ -63,40 +67,37 @@
  * If you inspect the headers being sent using your browser you'll see that the 'Origin'
  * request header is {@code 'null'}. This is expected and happens when you load a file from the
  * local file system. Netty can handle this by configuring the CorsHandler which is done
- * in the {@link HttpServerInitializer}.
+ * in the {@link HttpCorsServerInitializer}.
  *
  */
-public class HttpServer {
+public final class HttpCorsServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));
 
-    public HttpServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new HttpServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new HttpCorsServerInitializer(sslCtx));
 
-            b.bind(port).sync().channel().closeFuture().sync();
+            b.bind(PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new HttpServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java b/example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
similarity index 76%
rename from example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java
rename to example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
index ec4778f4fa5c..3852aecd1d3b 100644
--- a/example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java
+++ b/example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.http.HttpResponseEncoder;
 import io.netty.handler.codec.http.cors.CorsConfig;
 import io.netty.handler.codec.http.cors.CorsHandler;
+import io.netty.handler.ssl.SslContext;
 import io.netty.handler.stream.ChunkedWriteHandler;
 
 /**
@@ -68,20 +69,27 @@
  * corsConfig.exposedHeaders("custom-response-header");
  * </pre>
  */
-public class HttpServerInitializer extends ChannelInitializer<SocketChannel> {
+public class HttpCorsServerInitializer extends ChannelInitializer<SocketChannel> {
 
-    @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        ChannelPipeline pipeline = ch.pipeline();
+    private final SslContext sslCtx;
 
-        CorsConfig corsConfig = CorsConfig.anyOrigin().build();
+    public HttpCorsServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
 
-        pipeline.addLast("decoder", new HttpRequestDecoder());
-        pipeline.addLast("aggregator", new HttpObjectAggregator(65536));
-        pipeline.addLast("encoder", new HttpResponseEncoder());
-        pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
-        pipeline.addLast("cors", new CorsHandler(corsConfig));
-        pipeline.addLast("handler", new OkResponseHandler());
+    @Override
+    public void initChannel(SocketChannel ch) {
+        CorsConfig corsConfig = CorsConfig.withAnyOrigin().build();
+        ChannelPipeline pipeline = ch.pipeline();
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
+        }
+        pipeline.addLast(new HttpResponseEncoder());
+        pipeline.addLast(new HttpRequestDecoder());
+        pipeline.addLast(new HttpObjectAggregator(65536));
+        pipeline.addLast(new ChunkedWriteHandler());
+        pipeline.addLast(new CorsHandler(corsConfig));
+        pipeline.addLast(new OkResponseHandler());
     }
 
 }
diff --git a/example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java b/example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java
index c2ab705372b5..4ad71e6296b0 100644
--- a/example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java
+++ b/example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java
@@ -18,7 +18,8 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 
@@ -27,10 +28,9 @@
  * response for any request.
  */
 public class OkResponseHandler extends SimpleChannelInboundHandler<Object> {
-
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
-        final DefaultHttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+    public void channelRead0(ChannelHandlerContext ctx, Object msg) {
+        final FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         response.headers().set("custom-response-header", "Some value");
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
diff --git a/example/src/main/java/io/netty/example/http/file/HttpStaticFileServer.java b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServer.java
index 62d426a621d5..3acb69708678 100644
--- a/example/src/main/java/io/netty/example/http/file/HttpStaticFileServer.java
+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServer.java
@@ -16,41 +16,49 @@
 package io.netty.example.http.file;
 
 import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.Channel;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslProvider;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
-public class HttpStaticFileServer {
+public final class HttpStaticFileServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));
 
-    public HttpStaticFileServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(SslProvider.JDK, ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new HttpStaticFileServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new HttpStaticFileServerInitializer(sslCtx));
+
+            Channel ch = b.bind(PORT).sync().channel();
+
+            System.err.println("Open your web browser and navigate to " +
+                    (SSL? "https" : "http") + "://127.0.0.1:" + PORT + '/');
 
-            b.bind(port).sync().channel().closeFuture().sync();
+            ch.closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new HttpStaticFileServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
index 948cc4546170..32443d6eb8da 100644
--- a/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
@@ -28,12 +28,15 @@
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpChunkedInput;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedFile;
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.SystemPropertyUtil;
 
 import javax.activation.MimetypesFileTypeMap;
 import java.io.File;
@@ -50,7 +53,6 @@
 import java.util.regex.Pattern;
 
 import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpHeaders.*;
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
@@ -107,26 +109,19 @@ public class HttpStaticFileServerHandler extends SimpleChannelInboundHandler<Ful
     public static final String HTTP_DATE_GMT_TIMEZONE = "GMT";
     public static final int HTTP_CACHE_SECONDS = 60;
 
-    private final boolean useSendFile;
-
-    public HttpStaticFileServerHandler(boolean useSendFile) {
-        this.useSendFile = useSendFile;
-    }
-
     @Override
-    public void channelRead0(
-            ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
-        if (!request.getDecoderResult().isSuccess()) {
+    public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
+        if (!request.decoderResult().isSuccess()) {
             sendError(ctx, BAD_REQUEST);
             return;
         }
 
-        if (request.getMethod() != GET) {
+        if (request.method() != GET) {
             sendError(ctx, METHOD_NOT_ALLOWED);
             return;
         }
 
-        final String uri = request.getUri();
+        final String uri = request.uri();
         final String path = sanitizeUri(uri);
         if (path == null) {
             sendError(ctx, FORBIDDEN);
@@ -172,17 +167,17 @@ public void channelRead0(
         RandomAccessFile raf;
         try {
             raf = new RandomAccessFile(file, "r");
-        } catch (FileNotFoundException fnfe) {
+        } catch (FileNotFoundException ignore) {
             sendError(ctx, NOT_FOUND);
             return;
         }
         long fileLength = raf.length();
 
         HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
-        setContentLength(response, fileLength);
+        HttpHeaders.setContentLength(response, fileLength);
         setContentTypeHeader(response, file);
         setDateAndCacheHeaders(response, file);
-        if (isKeepAlive(request)) {
+        if (HttpHeaders.isKeepAlive(request)) {
             response.headers().set(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);
         }
 
@@ -191,27 +186,28 @@ public void channelRead0(
 
         // Write the content.
         ChannelFuture sendFileFuture;
-        if (useSendFile) {
+        if (ctx.pipeline().get(SslHandler.class) == null) {
             sendFileFuture =
                     ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength), ctx.newProgressivePromise());
         } else {
             sendFileFuture =
-                    ctx.write(new ChunkedFile(raf, 0, fileLength, 8192), ctx.newProgressivePromise());
+                    ctx.write(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)),
+                            ctx.newProgressivePromise());
         }
 
         sendFileFuture.addListener(new ChannelProgressiveFutureListener() {
             @Override
             public void operationProgressed(ChannelProgressiveFuture future, long progress, long total) {
                 if (total < 0) { // total unknown
-                    System.err.println("Transfer progress: " + progress);
+                    System.err.println(future.channel() + " Transfer progress: " + progress);
                 } else {
-                    System.err.println("Transfer progress: " + progress + " / " + total);
+                    System.err.println(future.channel() + " Transfer progress: " + progress + " / " + total);
                 }
             }
 
             @Override
-            public void operationComplete(ChannelProgressiveFuture future) throws Exception {
-                System.err.println("Transfer complete.");
+            public void operationComplete(ChannelProgressiveFuture future) {
+                System.err.println(future.channel() + " Transfer complete.");
             }
         });
 
@@ -219,14 +215,14 @@ public void operationComplete(ChannelProgressiveFuture future) throws Exception
         ChannelFuture lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
 
         // Decide whether to close the connection or not.
-        if (!isKeepAlive(request)) {
+        if (!HttpHeaders.isKeepAlive(request)) {
             // Close the connection when the whole content is written out.
             lastContentFuture.addListener(ChannelFutureListener.CLOSE);
         }
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         if (ctx.channel().isActive()) {
             sendError(ctx, INTERNAL_SERVER_ERROR);
@@ -240,11 +236,7 @@ private static String sanitizeUri(String uri) {
         try {
             uri = URLDecoder.decode(uri, "UTF-8");
         } catch (UnsupportedEncodingException e) {
-            try {
-                uri = URLDecoder.decode(uri, "ISO-8859-1");
-            } catch (UnsupportedEncodingException e1) {
-                throw new Error();
-            }
+            throw new Error(e);
         }
 
         if (!uri.startsWith("/")) {
@@ -264,7 +256,7 @@ private static String sanitizeUri(String uri) {
         }
 
         // Convert to absolute path.
-        return System.getProperty("user.dir") + File.separator + uri;
+        return SystemPropertyUtil.get("user.dir") + File.separator + uri;
     }
 
     private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[A-Za-z0-9][-_A-Za-z0-9\\.]*");
@@ -325,7 +317,7 @@ private static void sendRedirect(ChannelHandlerContext ctx, String newUri) {
 
     private static void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
         FullHttpResponse response = new DefaultFullHttpResponse(
-                HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status.toString() + "\r\n", CharsetUtil.UTF_8));
+                HTTP_1_1, status, Unpooled.copiedBuffer("Failure: " + status + "\r\n", CharsetUtil.UTF_8));
         response.headers().set(CONTENT_TYPE, "text/plain; charset=UTF-8");
 
         // Close the connection as soon as the error message is sent.
@@ -396,5 +388,4 @@ private static void setContentTypeHeader(HttpResponse response, File file) {
         MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
         response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
     }
-
 }
diff --git a/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java
index 5edb82af5db5..017f6d6ae8a2 100644
--- a/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java
+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java
@@ -19,26 +19,27 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.http.HttpObjectAggregator;
-import io.netty.handler.codec.http.HttpRequestDecoder;
-import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.codec.http.HttpServerCodec;
+import io.netty.handler.ssl.SslContext;
 import io.netty.handler.stream.ChunkedWriteHandler;
 
 public class HttpStaticFileServerInitializer extends ChannelInitializer<SocketChannel> {
-    @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        // Create a default pipeline implementation.
-        ChannelPipeline pipeline = ch.pipeline();
 
-        // Uncomment the following line if you want HTTPS
-        //SSLEngine engine = SecureChatSslContextFactory.getServerContext().createSSLEngine();
-        //engine.setUseClientMode(false);
-        //pipeline.addLast("ssl", new SslHandler(engine));
+    private final SslContext sslCtx;
 
-        pipeline.addLast("decoder", new HttpRequestDecoder());
-        pipeline.addLast("aggregator", new HttpObjectAggregator(65536));
-        pipeline.addLast("encoder", new HttpResponseEncoder());
-        pipeline.addLast("chunkedWriter", new ChunkedWriteHandler());
+    public HttpStaticFileServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
 
-        pipeline.addLast("handler", new HttpStaticFileServerHandler(true)); // Specify false if SSL.
+    @Override
+    public void initChannel(SocketChannel ch) {
+        ChannelPipeline pipeline = ch.pipeline();
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
+        }
+        pipeline.addLast(new HttpServerCodec());
+        pipeline.addLast(new HttpObjectAggregator(65536));
+        pipeline.addLast(new ChunkedWriteHandler());
+        pipeline.addLast(new HttpStaticFileServerHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java
index 2571b3f1a7a5..3fc34bba8612 100644
--- a/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java
+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java
@@ -21,20 +21,30 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * An HTTP server that sends back the content of the received HTTP request
  * in a pretty plaintext form.
  */
-public class HttpHelloWorldServer {
+public final class HttpHelloWorldServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));
 
-    public HttpHelloWorldServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         // Configure the server.
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
@@ -43,23 +53,18 @@ public void run() throws Exception {
             b.option(ChannelOption.SO_BACKLOG, 1024);
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new HttpHelloWorldServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new HttpHelloWorldServerInitializer(sslCtx));
+
+            Channel ch = b.bind(PORT).sync().channel();
+
+            System.err.println("Open your web browser and navigate to " +
+                    (SSL? "https" : "http") + "://127.0.0.1:" + PORT + '/');
 
-            Channel ch = b.bind(port).sync().channel();
             ch.closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new HttpHelloWorldServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
index 162cb439f020..b5ece1a266da 100644
--- a/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
@@ -19,32 +19,37 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.AsciiString;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpRequest;
 
-import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpHeaders.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 
 public class HttpHelloWorldServerHandler extends ChannelInboundHandlerAdapter {
     private static final byte[] CONTENT = { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };
 
+    private static final AsciiString CONTENT_TYPE = new AsciiString("Content-Type");
+    private static final AsciiString CONTENT_LENGTH = new AsciiString("Content-Length");
+    private static final AsciiString CONNECTION = new AsciiString("Connection");
+    private static final AsciiString KEEP_ALIVE = new AsciiString("keep-alive");
+
     @Override
     public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         if (msg instanceof HttpRequest) {
             HttpRequest req = (HttpRequest) msg;
 
-            if (is100ContinueExpected(req)) {
+            if (HttpHeaders.is100ContinueExpected(req)) {
                 ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
             }
-            boolean keepAlive = isKeepAlive(req);
+            boolean keepAlive = HttpHeaders.isKeepAlive(req);
             FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT));
             response.headers().set(CONTENT_TYPE, "text/plain");
             response.headers().set(CONTENT_LENGTH, response.content().readableBytes());
@@ -52,14 +57,14 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
             if (!keepAlive) {
                 ctx.write(response).addListener(ChannelFutureListener.CLOSE);
             } else {
-                response.headers().set(CONNECTION, Values.KEEP_ALIVE);
+                response.headers().set(CONNECTION, KEEP_ALIVE);
                 ctx.write(response);
             }
         }
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }
diff --git a/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerInitializer.java b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerInitializer.java
index d77a72aabe54..f6e638767c8b 100644
--- a/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerInitializer.java
+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerInitializer.java
@@ -19,18 +19,23 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.http.HttpServerCodec;
+import io.netty.handler.ssl.SslContext;
 
 public class HttpHelloWorldServerInitializer extends ChannelInitializer<SocketChannel> {
-    @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        ChannelPipeline p = ch.pipeline();
 
-        // Uncomment the following line if you want HTTPS
-        //SSLEngine engine = SecureChatSslContextFactory.getServerContext().createSSLEngine();
-        //engine.setUseClientMode(false);
-        //p.addLast("ssl", new SslHandler(engine));
+    private final SslContext sslCtx;
+
+    public HttpHelloWorldServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
 
-        p.addLast("codec", new HttpServerCodec());
-        p.addLast("handler", new HttpHelloWorldServerHandler());
+    @Override
+    public void initChannel(SocketChannel ch) {
+        ChannelPipeline p = ch.pipeline();
+        if (sslCtx != null) {
+            p.addLast(sslCtx.newHandler(ch.alloc()));
+        }
+        p.addLast(new HttpServerCodec());
+        p.addLast(new HttpHelloWorldServerHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
index 4f52b2beefb7..cece2bf20df9 100644
--- a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java
@@ -27,6 +27,8 @@
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.net.URI;
 
@@ -34,17 +36,14 @@
  * A simple HTTP client that prints out the content of the HTTP response to
  * {@link System#out} to test {@link HttpSnoopServer}.
  */
-public class HttpSnoopClient {
+public final class HttpSnoopClient {
 
-    private final URI uri;
+    static final String URL = System.getProperty("url", "http://127.0.0.1:8080/");
 
-    public HttpSnoopClient(URI uri) {
-        this.uri = uri;
-    }
-
-    public void run() throws Exception {
+    public static void main(String[] args) throws Exception {
+        URI uri = new URI(URL);
         String scheme = uri.getScheme() == null? "http" : uri.getScheme();
-        String host = uri.getHost() == null? "localhost" : uri.getHost();
+        String host = uri.getHost() == null? "127.0.0.1" : uri.getHost();
         int port = uri.getPort();
         if (port == -1) {
             if ("http".equalsIgnoreCase(scheme)) {
@@ -59,7 +58,14 @@ public void run() throws Exception {
             return;
         }
 
-        boolean ssl = "https".equalsIgnoreCase(scheme);
+        // Configure SSL context if necessary.
+        final boolean ssl = "https".equalsIgnoreCase(scheme);
+        final SslContext sslCtx;
+        if (ssl) {
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        } else {
+            sslCtx = null;
+        }
 
         // Configure the client.
         EventLoopGroup group = new NioEventLoopGroup();
@@ -67,7 +73,7 @@ public void run() throws Exception {
             Bootstrap b = new Bootstrap();
             b.group(group)
              .channel(NioSocketChannel.class)
-             .handler(new HttpSnoopClientInitializer(ssl));
+             .handler(new HttpSnoopClientInitializer(sslCtx));
 
             // Make the connection attempt.
             Channel ch = b.connect(host, port).sync().channel();
@@ -96,16 +102,4 @@ public void run() throws Exception {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        if (args.length != 1) {
-            System.err.println(
-                    "Usage: " + HttpSnoopClient.class.getSimpleName() +
-                    " <URL>");
-            return;
-        }
-
-        URI uri = new URI(args[0]);
-        new HttpSnoopClient(uri).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
index de0310fcba66..0761b192e8f6 100644
--- a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
@@ -27,44 +27,44 @@
 public class HttpSnoopClientHandler extends SimpleChannelInboundHandler<HttpObject> {
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
+    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 
-            System.out.println("STATUS: " + response.getStatus());
-            System.out.println("VERSION: " + response.getProtocolVersion());
-            System.out.println();
+            System.err.println("STATUS: " + response.status());
+            System.err.println("VERSION: " + response.protocolVersion());
+            System.err.println();
 
             if (!response.headers().isEmpty()) {
                 for (String name: response.headers().names()) {
                     for (String value: response.headers().getAll(name)) {
-                        System.out.println("HEADER: " + name + " = " + value);
+                        System.err.println("HEADER: " + name + " = " + value);
                     }
                 }
-                System.out.println();
+                System.err.println();
             }
 
             if (HttpHeaders.isTransferEncodingChunked(response)) {
-                System.out.println("CHUNKED CONTENT {");
+                System.err.println("CHUNKED CONTENT {");
             } else {
-                System.out.println("CONTENT {");
+                System.err.println("CONTENT {");
             }
         }
         if (msg instanceof HttpContent) {
             HttpContent content = (HttpContent) msg;
 
-            System.out.print(content.content().toString(CharsetUtil.UTF_8));
-            System.out.flush();
+            System.err.print(content.content().toString(CharsetUtil.UTF_8));
+            System.err.flush();
 
             if (content instanceof LastHttpContent) {
-                System.out.println("} END OF CONTENT");
+                System.err.println("} END OF CONTENT");
+                ctx.close();
             }
         }
     }
 
     @Override
-    public void exceptionCaught(
-            ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }
diff --git a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java
index 9989b12878cc..fd4647f42a31 100644
--- a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java
+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java
@@ -18,46 +18,35 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.example.securechat.SecureChatSslContextFactory;
 import io.netty.handler.codec.http.HttpClientCodec;
 import io.netty.handler.codec.http.HttpContentDecompressor;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
-import io.netty.handler.ssl.SslHandler;
-
-import javax.net.ssl.SSLEngine;
+import io.netty.handler.ssl.SslContext;
 
 public class HttpSnoopClientInitializer extends ChannelInitializer<SocketChannel> {
 
-    private final boolean ssl;
+    private final SslContext sslCtx;
 
-    public HttpSnoopClientInitializer(boolean ssl) {
-        this.ssl = ssl;
+    public HttpSnoopClientInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
     }
 
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        // Create a default pipeline implementation.
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline p = ch.pipeline();
 
-        p.addLast("log", new LoggingHandler(LogLevel.INFO));
         // Enable HTTPS if necessary.
-        if (ssl) {
-            SSLEngine engine =
-                SecureChatSslContextFactory.getClientContext().createSSLEngine();
-            engine.setUseClientMode(true);
-
-            p.addLast("ssl", new SslHandler(engine));
+        if (sslCtx != null) {
+            p.addLast(sslCtx.newHandler(ch.alloc()));
         }
 
-        p.addLast("codec", new HttpClientCodec());
+        p.addLast(new HttpClientCodec());
 
         // Remove the following line if you don't want automatic content decompression.
-        p.addLast("inflater", new HttpContentDecompressor());
+        p.addLast(new HttpContentDecompressor());
 
-        // Uncomment the following line if you don't want to handle HttpChunks.
-        //p.addLast("aggregator", new HttpObjectAggregator(1048576));
+        // Uncomment the following line if you don't want to handle HttpContents.
+        //p.addLast(new HttpObjectAggregator(1048576));
 
-        p.addLast("handler", new HttpSnoopClientHandler());
+        p.addLast(new HttpSnoopClientHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
index 9fe0291b22f2..3628d3c2ef35 100644
--- a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServer.java
@@ -20,20 +20,30 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * An HTTP server that sends back the content of the received HTTP request
  * in a pretty plaintext form.
  */
-public class HttpSnoopServer {
+public final class HttpSnoopServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));
 
-    public HttpSnoopServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         // Configure the server.
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
@@ -41,23 +51,18 @@ public void run() throws Exception {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new HttpSnoopServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new HttpSnoopServerInitializer(sslCtx));
+
+            Channel ch = b.bind(PORT).sync().channel();
+
+            System.err.println("Open your web browser and navigate to " +
+                    (SSL? "https" : "http") + "://127.0.0.1:" + PORT + '/');
 
-            Channel ch = b.bind(port).sync().channel();
             ch.closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new HttpSnoopServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
index 314203f42df8..8e20875ca103 100644
--- a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.DecoderResult;
@@ -39,7 +40,6 @@
 import java.util.Set;
 
 import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpHeaders.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 
@@ -50,7 +50,7 @@ public class HttpSnoopServerHandler extends SimpleChannelInboundHandler<Object>
     private final StringBuilder buf = new StringBuilder();
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
@@ -59,7 +59,7 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
         if (msg instanceof HttpRequest) {
             HttpRequest request = this.request = (HttpRequest) msg;
 
-            if (is100ContinueExpected(request)) {
+            if (HttpHeaders.is100ContinueExpected(request)) {
                 send100Continue(ctx);
             }
 
@@ -67,9 +67,9 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
             buf.append("WELCOME TO THE WILD WILD WEB SERVER\r\n");
             buf.append("===================================\r\n");
 
-            buf.append("VERSION: ").append(request.getProtocolVersion()).append("\r\n");
-            buf.append("HOSTNAME: ").append(getHost(request, "unknown")).append("\r\n");
-            buf.append("REQUEST_URI: ").append(request.getUri()).append("\r\n\r\n");
+            buf.append("VERSION: ").append(request.protocolVersion()).append("\r\n");
+            buf.append("HOSTNAME: ").append(HttpHeaders.getHost(request, "unknown")).append("\r\n");
+            buf.append("REQUEST_URI: ").append(request.uri()).append("\r\n\r\n");
 
             HttpHeaders headers = request.headers();
             if (!headers.isEmpty()) {
@@ -81,7 +81,7 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
                 buf.append("\r\n");
             }
 
-            QueryStringDecoder queryStringDecoder = new QueryStringDecoder(request.getUri());
+            QueryStringDecoder queryStringDecoder = new QueryStringDecoder(request.uri());
             Map<String, List<String>> params = queryStringDecoder.parameters();
             if (!params.isEmpty()) {
                 for (Entry<String, List<String>> p: params.entrySet()) {
@@ -123,13 +123,16 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {
                     buf.append("\r\n");
                 }
 
-                writeResponse(trailer, ctx);
+                if (!writeResponse(trailer, ctx)) {
+                    // If keep-alive is off, close the connection once the content is fully written.
+                    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
+                }
             }
         }
     }
 
     private static void appendDecoderResult(StringBuilder buf, HttpObject o) {
-        DecoderResult result = o.getDecoderResult();
+        DecoderResult result = o.decoderResult();
         if (result.isSuccess()) {
             return;
         }
@@ -141,10 +144,10 @@ private static void appendDecoderResult(StringBuilder buf, HttpObject o) {
 
     private boolean writeResponse(HttpObject currentObj, ChannelHandlerContext ctx) {
         // Decide whether to close the connection or not.
-        boolean keepAlive = isKeepAlive(request);
+        boolean keepAlive = HttpHeaders.isKeepAlive(request);
         // Build the response object.
         FullHttpResponse response = new DefaultFullHttpResponse(
-                HTTP_1_1, currentObj.getDecoderResult().isSuccess()? OK : BAD_REQUEST,
+                HTTP_1_1, currentObj.decoderResult().isSuccess()? OK : BAD_REQUEST,
                 Unpooled.copiedBuffer(buf.toString(), CharsetUtil.UTF_8));
 
         response.headers().set(CONTENT_TYPE, "text/plain; charset=UTF-8");
@@ -185,7 +188,7 @@ private static void send100Continue(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }
diff --git a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java
index 0c1d5bdeb2cd..ef445e15b471 100644
--- a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java
+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java
@@ -20,24 +20,28 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.ssl.SslContext;
 
 public class HttpSnoopServerInitializer extends ChannelInitializer<SocketChannel> {
-    @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        // Create a default pipeline implementation.
-        ChannelPipeline p = ch.pipeline();
 
-        // Uncomment the following line if you want HTTPS
-        //SSLEngine engine = SecureChatSslContextFactory.getServerContext().createSSLEngine();
-        //engine.setUseClientMode(false);
-        //p.addLast("ssl", new SslHandler(engine));
+    private final SslContext sslCtx;
+
+    public HttpSnoopServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
 
-        p.addLast("decoder", new HttpRequestDecoder());
+    @Override
+    public void initChannel(SocketChannel ch) {
+        ChannelPipeline p = ch.pipeline();
+        if (sslCtx != null) {
+            p.addLast(sslCtx.newHandler(ch.alloc()));
+        }
+        p.addLast(new HttpRequestDecoder());
         // Uncomment the following line if you don't want to handle HttpChunks.
-        //p.addLast("aggregator", new HttpObjectAggregator(1048576));
-        p.addLast("encoder", new HttpResponseEncoder());
+        //p.addLast(new HttpObjectAggregator(1048576));
+        p.addLast(new HttpResponseEncoder());
         // Remove the following line if you don't want automatic content compression.
-        //p.addLast("deflater", new HttpContentCompressor());
-        p.addLast("handler", new HttpSnoopServerHandler());
+        //p.addLast(new HttpContentCompressor());
+        p.addLast(new HttpSnoopServerHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
index 93c6587d1881..8fcafdc005c9 100644
--- a/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java
@@ -17,14 +17,13 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.http.ClientCookieEncoder;
 import io.netty.handler.codec.http.DefaultCookie;
-import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpRequest;
-import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
@@ -35,54 +34,40 @@
 import io.netty.handler.codec.http.multipart.DiskFileUpload;
 import io.netty.handler.codec.http.multipart.HttpDataFactory;
 import io.netty.handler.codec.http.multipart.HttpPostRequestEncoder;
-import io.netty.handler.codec.http.multipart.HttpPostRequestEncoder.ErrorDataEncoderException;
 import io.netty.handler.codec.http.multipart.InterfaceHttpData;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
-import java.io.BufferedWriter;
 import java.io.File;
-import java.io.FileWriter;
+import java.io.FileNotFoundException;
+import java.net.InetSocketAddress;
 import java.net.URI;
-import java.net.URISyntaxException;
 import java.util.List;
 import java.util.Map.Entry;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * This class is meant to be run against {@link HttpUploadServer}.
  */
-public class HttpUploadClient {
+public final class HttpUploadClient {
 
-    private static final Logger logger = Logger.getLogger(HttpUploadClient.class.getName());
+    static final String BASE_URL = System.getProperty("baseUrl", "http://127.0.0.1:8080/");
+    static final String FILE = System.getProperty("file", "upload.txt");
 
-    private final String baseUri;
-    private final String filePath;
-
-    public HttpUploadClient(String baseUri, String filePath) {
-        this.baseUri = baseUri;
-        this.filePath = filePath;
-    }
-
-    public void run() throws Exception {
+    public static void main(String[] args) throws Exception {
         String postSimple, postFile, get;
-        if (baseUri.endsWith("/")) {
-            postSimple = baseUri + "formpost";
-            postFile = baseUri + "formpostmultipart";
-            get = baseUri + "formget";
+        if (BASE_URL.endsWith("/")) {
+            postSimple = BASE_URL + "formpost";
+            postFile = BASE_URL + "formpostmultipart";
+            get = BASE_URL + "formget";
         } else {
-            postSimple = baseUri + "/formpost";
-            postFile = baseUri + "/formpostmultipart";
-            get = baseUri + "/formget";
-        }
-        URI uriSimple;
-        try {
-            uriSimple = new URI(postSimple);
-        } catch (URISyntaxException e) {
-            logger.log(Level.WARNING, "Invalid URI syntax", e);
-            return;
+            postSimple = BASE_URL + "/formpost";
+            postFile = BASE_URL + "/formpostmultipart";
+            get = BASE_URL + "/formget";
         }
-        String scheme = uriSimple.getScheme() == null ? "http" : uriSimple.getScheme();
-        String host = uriSimple.getHost() == null ? "localhost" : uriSimple.getHost();
+
+        URI uriSimple = new URI(postSimple);
+        String scheme = uriSimple.getScheme() == null? "http" : uriSimple.getScheme();
+        String host = uriSimple.getHost() == null? "127.0.0.1" : uriSimple.getHost();
         int port = uriSimple.getPort();
         if (port == -1) {
             if ("http".equalsIgnoreCase(scheme)) {
@@ -93,23 +78,23 @@ public void run() throws Exception {
         }
 
         if (!"http".equalsIgnoreCase(scheme) && !"https".equalsIgnoreCase(scheme)) {
-            logger.log(Level.WARNING, "Only HTTP(S) is supported.");
+            System.err.println("Only HTTP(S) is supported.");
             return;
         }
 
-        boolean ssl = "https".equalsIgnoreCase(scheme);
-
-        URI uriFile;
-        try {
-            uriFile = new URI(postFile);
-        } catch (URISyntaxException e) {
-            logger.log(Level.WARNING, "Error: ", e);
-            return;
+        final boolean ssl = "https".equalsIgnoreCase(scheme);
+        final SslContext sslCtx;
+        if (ssl) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
         }
-        File file = new File(filePath);
+
+        URI uriFile = new URI(postFile);
+        File file = new File(FILE);
         if (!file.canRead()) {
-            logger.log(Level.WARNING, "A correct path is needed");
-            return;
+            throw new FileNotFoundException(FILE);
         }
 
         // Configure the client.
@@ -125,42 +110,42 @@ public void run() throws Exception {
 
         try {
             Bootstrap b = new Bootstrap();
-            b.group(group).channel(NioSocketChannel.class).handler(new HttpUploadClientIntializer(ssl));
+            b.group(group).channel(NioSocketChannel.class).handler(new HttpUploadClientIntializer(sslCtx));
 
             // Simple Get form: no factory used (not usable)
-            List<Entry<String, String>> headers = formGet(b, host, port, get, uriSimple);
+            List<Entry<String, String>> headers = formget(b, host, port, get, uriSimple);
             if (headers == null) {
-                factory.cleanAllHttpDatas();
+                factory.cleanAllHttpData();
                 return;
             }
 
             // Simple Post form: factory used for big attributes
-            List<InterfaceHttpData> bodylist = formPost(b, host, port, uriSimple, file, factory, headers);
+            List<InterfaceHttpData> bodylist = formpost(b, host, port, uriSimple, file, factory, headers);
             if (bodylist == null) {
-                factory.cleanAllHttpDatas();
+                factory.cleanAllHttpData();
                 return;
             }
 
             // Multipart Post form: factory used
-            formPostMultipart(b, host, port, uriFile, factory, headers, bodylist);
+            formpostmultipart(b, host, port, uriFile, factory, headers, bodylist);
         } finally {
             // Shut down executor threads to exit.
             group.shutdownGracefully();
 
             // Really clean all temporary files if they still exist
-            factory.cleanAllHttpDatas();
+            factory.cleanAllHttpData();
         }
     }
 
     /**
-     * Standard usage of HTTP API in Netty without file Upload (get is not able to achieve File upload due to limitation
-     * on request size).
+     * Standard usage of HTTP API in Netty without file Upload (get is not able to achieve File upload
+     * due to limitation on request size).
      *
      * @return the list of headers that will be used in every example after
      **/
-    private static List<Entry<String, String>> formGet(Bootstrap bootstrap, String host, int port, String get,
-            URI uriSimple) throws Exception {
-        // Start the connection attempt.
+    private static List<Entry<String, String>> formget(
+            Bootstrap bootstrap, String host, int port, String get, URI uriSimple) throws Exception {
+        // XXX /formget
         // No use of HttpPostRequestEncoder since not a POST
         Channel channel = bootstrap.connect(host, port).sync().channel();
 
@@ -175,21 +160,12 @@ private static List<Entry<String, String>> formGet(Bootstrap bootstrap, String h
         encoder.addParam("thirdinfo", "third value\r\ntest second line\r\n\r\nnew line\r\n");
         encoder.addParam("Send", "Send");
 
-        URI uriGet;
-        try {
-            uriGet = new URI(encoder.toString());
-        } catch (URISyntaxException e) {
-            logger.log(Level.WARNING, "Error: ", e);
-            return null;
-        }
-
-        FullHttpRequest request =
-                new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uriGet.toASCIIString());
+        URI uriGet = new URI(encoder.toString());
+        HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uriGet.toASCIIString());
         HttpHeaders headers = request.headers();
         headers.set(HttpHeaders.Names.HOST, host);
         headers.set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.CLOSE);
-        headers.set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP + ','
-                + HttpHeaders.Values.DEFLATE);
+        headers.set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP + ',' + HttpHeaders.Values.DEFLATE);
 
         headers.set(HttpHeaders.Names.ACCEPT_CHARSET, "ISO-8859-1,utf-8;q=0.7,*;q=0.7");
         headers.set(HttpHeaders.Names.ACCEPT_LANGUAGE, "fr");
@@ -197,12 +173,19 @@ private static List<Entry<String, String>> formGet(Bootstrap bootstrap, String h
         headers.set(HttpHeaders.Names.USER_AGENT, "Netty Simple Http Client side");
         headers.set(HttpHeaders.Names.ACCEPT, "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
 
-        headers.set(HttpHeaders.Names.COOKIE, ClientCookieEncoder.encode(new DefaultCookie("my-cookie", "foo"),
-                new DefaultCookie("another-cookie", "bar")));
+        //connection will not close but needed
+        // headers.set("Connection","keep-alive");
+        // headers.set("Keep-Alive","300");
+
+        headers.set(
+                HttpHeaders.Names.COOKIE, ClientCookieEncoder.encode(
+                        new DefaultCookie("my-cookie", "foo"),
+                        new DefaultCookie("another-cookie", "bar"))
+        );
 
         // send request
         List<Entry<String, String>> entries = headers.entries();
-        channel.writeAndFlush(request).sync();
+        channel.writeAndFlush(request);
 
         // Wait for the server to close the connection.
         channel.closeFuture().sync();
@@ -215,27 +198,22 @@ private static List<Entry<String, String>> formGet(Bootstrap bootstrap, String h
      *
      * @return the list of HttpData object (attribute and file) to be reused on next post
      */
-    private static List<InterfaceHttpData> formPost(Bootstrap bootstrap, String host, int port, URI uriSimple,
-            File file, HttpDataFactory factory, List<Entry<String, String>> headers) throws Exception {
-
-        // Start the connection attempt
-        Channel channel = bootstrap.connect(host, port).sync().channel();
+    private static List<InterfaceHttpData> formpost(
+            Bootstrap bootstrap,
+            String host, int port, URI uriSimple, File file, HttpDataFactory factory,
+            List<Entry<String, String>> headers) throws Exception {
+        // XXX /formpost
+        // Start the connection attempt.
+        ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
+        // Wait until the connection attempt succeeds or fails.
+        Channel channel = future.sync().channel();
 
         // Prepare the HTTP request.
-        HttpRequest request =
-                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uriSimple.toASCIIString());
+        HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uriSimple.toASCIIString());
 
         // Use the PostBody encoder
-        HttpPostRequestEncoder bodyRequestEncoder = null;
-        try {
-            bodyRequestEncoder = new HttpPostRequestEncoder(factory, request, false); // false not multipart
-        } catch (NullPointerException e) {
-            // should not be since args are not null
-            e.printStackTrace();
-        } catch (ErrorDataEncoderException e) {
-            // test if getMethod is a POST getMethod
-            e.printStackTrace();
-        }
+        HttpPostRequestEncoder bodyRequestEncoder =
+                new HttpPostRequestEncoder(factory, request, false);  // false => not multipart
 
         // it is legal to add directly header or cookie into the request until finalize
         for (Entry<String, String> entry : headers) {
@@ -243,28 +221,15 @@ private static List<InterfaceHttpData> formPost(Bootstrap bootstrap, String host
         }
 
         // add Form attribute
-        try {
-            bodyRequestEncoder.addBodyAttribute("getform", "POST");
-            bodyRequestEncoder.addBodyAttribute("info", "first value");
-            bodyRequestEncoder.addBodyAttribute("secondinfo", "secondvalue ���&");
-            bodyRequestEncoder.addBodyAttribute("thirdinfo", textArea);
-            bodyRequestEncoder.addBodyFileUpload("myfile", file, "application/x-zip-compressed", false);
-            bodyRequestEncoder.addBodyAttribute("Send", "Send");
-        } catch (NullPointerException e) {
-            // should not be since not null args
-            e.printStackTrace();
-        } catch (ErrorDataEncoderException e) {
-            // if an encoding error occurs
-            e.printStackTrace();
-        }
+        bodyRequestEncoder.addBodyAttribute("getform", "POST");
+        bodyRequestEncoder.addBodyAttribute("info", "first value");
+        bodyRequestEncoder.addBodyAttribute("secondinfo", "secondvalue ���&");
+        bodyRequestEncoder.addBodyAttribute("thirdinfo", textArea);
+        bodyRequestEncoder.addBodyAttribute("fourthinfo", textAreaLong);
+        bodyRequestEncoder.addBodyFileUpload("myfile", file, "application/x-zip-compressed", false);
 
         // finalize request
-        try {
-            request = bodyRequestEncoder.finalizeRequest();
-        } catch (ErrorDataEncoderException e) {
-            // if an encoding error occurs
-            e.printStackTrace();
-        }
+        request = bodyRequestEncoder.finalizeRequest();
 
         // Create the bodylist to be reused on the last version with Multipart support
         List<InterfaceHttpData> bodylist = bodyRequestEncoder.getBodyListAttributes();
@@ -273,55 +238,41 @@ private static List<InterfaceHttpData> formPost(Bootstrap bootstrap, String host
         channel.write(request);
 
         // test if request was chunked and if so, finish the write
-        if (bodyRequestEncoder.isChunked()) {
-            // could do either request.isChunked()
+        if (bodyRequestEncoder.isChunked()) { // could do either request.isChunked()
             // either do it through ChunkedWriteHandler
-            channel.writeAndFlush(bodyRequestEncoder).awaitUninterruptibly();
-        }  else {
-            channel.flush();
+            channel.write(bodyRequestEncoder).sync();
         }
 
-        // Do not clear here since we will reuse the InterfaceHttpData on the
-        // next request
-        // for the example (limit action on client side). Take this as a
-        // broadcast of the same
+        // Do not clear here since we will reuse the InterfaceHttpData on the next request
+        // for the example (limit action on client side). Take this as a broadcast of the same
         // request on both Post actions.
         //
-        // On standard program, it is clearly recommended to clean all files
-        // after each request
+        // On standard program, it is clearly recommended to clean all files after each request
         // bodyRequestEncoder.cleanFiles();
 
         // Wait for the server to close the connection.
         channel.closeFuture().sync();
-
         return bodylist;
     }
 
     /**
      * Multipart example
      */
-    private static void formPostMultipart(Bootstrap bootstrap, String host, int port, URI uriFile,
-            HttpDataFactory factory, List<Entry<String, String>> headers, List<InterfaceHttpData> bodylist)
-            throws Exception {
-
-        // Start the connection attempt
-        Channel channel = bootstrap.connect(host, port).sync().channel();
+    private static void formpostmultipart(
+            Bootstrap bootstrap, String host, int port, URI uriFile, HttpDataFactory factory,
+            List<Entry<String, String>> headers, List<InterfaceHttpData> bodylist) throws Exception {
+        // XXX /formpostmultipart
+        // Start the connection attempt.
+        ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));
+        // Wait until the connection attempt succeeds or fails.
+        Channel channel = future.sync().channel();
 
         // Prepare the HTTP request.
-        HttpRequest request =
-                new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uriFile.toASCIIString());
+        HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, uriFile.toASCIIString());
 
         // Use the PostBody encoder
-        HttpPostRequestEncoder bodyRequestEncoder = null;
-        try {
-            bodyRequestEncoder = new HttpPostRequestEncoder(factory, request, true); // true => multipart
-        } catch (NullPointerException e) {
-            // should not be since no null args
-            e.printStackTrace();
-        } catch (ErrorDataEncoderException e) {
-            // test if getMethod is a POST getMethod
-            e.printStackTrace();
-        }
+        HttpPostRequestEncoder bodyRequestEncoder =
+                new HttpPostRequestEncoder(factory, request, true); // true => multipart
 
         // it is legal to add directly header or cookie into the request until finalize
         for (Entry<String, String> entry : headers) {
@@ -329,33 +280,17 @@ private static void formPostMultipart(Bootstrap bootstrap, String host, int port
         }
 
         // add Form attribute from previous request in formpost()
-        try {
-            bodyRequestEncoder.setBodyHttpDatas(bodylist);
-        } catch (NullPointerException e1) {
-            // should not be since previously created
-            e1.printStackTrace();
-        } catch (ErrorDataEncoderException e1) {
-            // again should not be since previously encoded (except if an error
-            // occurs previously)
-            e1.printStackTrace();
-        }
+        bodyRequestEncoder.setBodyHttpDatas(bodylist);
 
         // finalize request
-        try {
-            request = bodyRequestEncoder.finalizeRequest();
-        } catch (ErrorDataEncoderException e) {
-            // if an encoding error occurs
-            e.printStackTrace();
-        }
+        bodyRequestEncoder.finalizeRequest();
 
         // send request
         channel.write(request);
 
         // test if request was chunked and if so, finish the write
         if (bodyRequestEncoder.isChunked()) {
-            channel.writeAndFlush(bodyRequestEncoder).awaitUninterruptibly();
-        } else {
-            channel.flush();
+            channel.write(bodyRequestEncoder).sync();
         }
 
         // Now no more use of file representation (and list of HttpData)
@@ -365,617 +300,594 @@ private static void formPostMultipart(Bootstrap bootstrap, String host, int port
         channel.closeFuture().sync();
     }
 
-    public static void main(String[] args) throws Exception {
-        String baseUri;
-        String filePath;
-        if (args.length == 2) {
-            baseUri = args[0];
-            filePath = args[1];
-        } else {
-            baseUri = "http://localhost:8080";
-
-            File f = File.createTempFile("upload", ".txt");
-            BufferedWriter bw = new BufferedWriter(new FileWriter(f));
-            bw.write("Some text data in a file to be posted");
-            bw.close();
-            filePath = f.getPath();
-            f.deleteOnExit();
-        }
-
-        logger.info("Posting to " + baseUri + ". Using file " + filePath);
-        new HttpUploadClient(baseUri, filePath).run();
-    }
-
     // use to simulate a small TEXTAREA field in a form
     private static final String textArea = "short text";
     // use to simulate a big TEXTAREA field in a form
-    /*
     private static final String textAreaLong =
-            "lkjlkjlKJLKJLKJLKJLJlkj lklkj\r\n\r\nLKJJJJJJJJKKKKKKKKKKKKKKK ����&\r\n\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n"
-            + "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n";
-     */
+            "lkjlkjlKJLKJLKJLKJLJlkj lklkj\r\n\r\nLKJJJJJJJJKKKKKKKKKKKKKKK ����&\r\n\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n" +
+            "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\n";
 }
diff --git a/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java b/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
index c920afb7f5a3..37377cf40bfa 100644
--- a/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
@@ -24,59 +24,55 @@
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.util.CharsetUtil;
 
-import java.util.logging.Logger;
-
 /**
  * Handler that just dumps the contents of the response from the server
  */
 public class HttpUploadClientHandler extends SimpleChannelInboundHandler<HttpObject> {
 
-    private static final Logger logger = Logger.getLogger(HttpUploadClientHandler.class.getName());
-
     private boolean readingChunks;
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
+    public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 
-            logger.info("STATUS: " + response.getStatus());
-            logger.info("VERSION: " + response.getProtocolVersion());
+            System.err.println("STATUS: " + response.status());
+            System.err.println("VERSION: " + response.protocolVersion());
 
             if (!response.headers().isEmpty()) {
                 for (String name : response.headers().names()) {
                     for (String value : response.headers().getAll(name)) {
-                        logger.info("HEADER: " + name + " = " + value);
+                        System.err.println("HEADER: " + name + " = " + value);
                     }
                 }
             }
 
-            if (response.getStatus().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
+            if (response.status().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
                 readingChunks = true;
-                logger.info("CHUNKED CONTENT {");
+                System.err.println("CHUNKED CONTENT {");
             } else {
-                logger.info("CONTENT {");
+                System.err.println("CONTENT {");
             }
         }
         if (msg instanceof HttpContent) {
             HttpContent chunk = (HttpContent) msg;
-            logger.info(chunk.content().toString(CharsetUtil.UTF_8));
+            System.err.println(chunk.content().toString(CharsetUtil.UTF_8));
 
             if (chunk instanceof LastHttpContent) {
                 if (readingChunks) {
-                    logger.info("} END OF CHUNKED CONTENT");
+                    System.err.println("} END OF CHUNKED CONTENT");
                 } else {
-                    logger.info("} END OF CONTENT");
+                    System.err.println("} END OF CONTENT");
                 }
                 readingChunks = false;
             } else {
-                logger.info(chunk.content().toString(CharsetUtil.UTF_8));
+                System.err.println(chunk.content().toString(CharsetUtil.UTF_8));
             }
         }
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.channel().close();
     }
diff --git a/example/src/main/java/io/netty/example/http/upload/HttpUploadClientIntializer.java b/example/src/main/java/io/netty/example/http/upload/HttpUploadClientIntializer.java
index 1e7eaa6b5c67..e87532ad2df8 100644
--- a/example/src/main/java/io/netty/example/http/upload/HttpUploadClientIntializer.java
+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClientIntializer.java
@@ -18,30 +18,25 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.example.securechat.SecureChatSslContextFactory;
 import io.netty.handler.codec.http.HttpClientCodec;
 import io.netty.handler.codec.http.HttpContentDecompressor;
-import io.netty.handler.ssl.SslHandler;
+import io.netty.handler.ssl.SslContext;
 import io.netty.handler.stream.ChunkedWriteHandler;
 
-import javax.net.ssl.SSLEngine;
-
 public class HttpUploadClientIntializer extends ChannelInitializer<SocketChannel> {
-    private final boolean ssl;
 
-    public HttpUploadClientIntializer(boolean ssl) {
-        this.ssl = ssl;
+    private final SslContext sslCtx;
+
+    public HttpUploadClientIntializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
     }
 
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        // Create a default pipeline implementation.
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
 
-        if (ssl) {
-            SSLEngine engine = SecureChatSslContextFactory.getClientContext().createSSLEngine();
-            engine.setUseClientMode(true);
-            pipeline.addLast("ssl", new SslHandler(engine));
+        if (sslCtx != null) {
+            pipeline.addLast("ssl", sslCtx.newHandler(ch.alloc()));
         }
 
         pipeline.addLast("codec", new HttpClientCodec());
diff --git a/example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java b/example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java
index 17c72aaf3723..5e5d3cbf8eaf 100644
--- a/example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java
+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java
@@ -20,30 +20,42 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * A HTTP server showing how to use the HTTP multipart package for file uploads and decoding post data.
  */
-public class HttpUploadServer {
+public final class HttpUploadServer {
 
-    private final int port;
-    public static boolean isSSL;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));
 
-    public HttpUploadServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
-            b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)
-                    .childHandler(new HttpUploadServerInitializer());
+            b.group(bossGroup, workerGroup);
+            b.channel(NioServerSocketChannel.class);
+            b.handler(new LoggingHandler(LogLevel.INFO));
+            b.childHandler(new HttpUploadServerInitializer(sslCtx));
+
+            Channel ch = b.bind(PORT).sync().channel();
 
-            Channel ch = b.bind(port).sync().channel();
-            System.out.println("HTTP Upload Server at port " + port + '.');
-            System.out.println("Open your browser and navigate to http://localhost:" + port + '/');
+            System.err.println("Open your web browser and navigate to " +
+                    (SSL? "https" : "http") + "://127.0.0.1:" + PORT + '/');
 
             ch.closeFuture().sync();
         } finally {
@@ -51,17 +63,4 @@ public void run() throws Exception {
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        if (args.length > 1) {
-            isSSL = true;
-        }
-        new HttpUploadServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
index 6fbff4aea264..8e192b1e1b81 100644
--- a/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
@@ -27,6 +27,7 @@
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponseStatus;
@@ -43,7 +44,6 @@
 import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
 import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
 import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
-import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.IncompatibleDataDecoderException;
 import io.netty.handler.codec.http.multipart.InterfaceHttpData;
 import io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;
 import io.netty.util.CharsetUtil;
@@ -71,12 +71,11 @@ public class HttpUploadServerHandler extends SimpleChannelInboundHandler<HttpObj
 
     private final StringBuilder responseContent = new StringBuilder();
 
-    private static final HttpDataFactory factory = new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE); //Disk
-                                                                                                              // if
-                                                                                                              // size
-                                                                                                              // exceed
+    private static final HttpDataFactory factory =
+            new DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE); // Disk if size exceed
 
     private HttpPostRequestDecoder decoder;
+
     static {
         DiskFileUpload.deleteOnExitTemporaryFile = true; // should delete file
                                                          // on exit (in normal
@@ -88,7 +87,7 @@ public class HttpUploadServerHandler extends SimpleChannelInboundHandler<HttpObj
     }
 
     @Override
-    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         if (decoder != null) {
             decoder.cleanFiles();
         }
@@ -98,7 +97,7 @@ public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
     public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
         if (msg instanceof HttpRequest) {
             HttpRequest request = this.request = (HttpRequest) msg;
-            URI uri = new URI(request.getUri());
+            URI uri = new URI(request.uri());
             if (!uri.getPath().startsWith("/form")) {
                 // Write Menu
                 writeMenu(ctx);
@@ -108,9 +107,9 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
             responseContent.append("WELCOME TO THE WILD WILD WEB SERVER\r\n");
             responseContent.append("===================================\r\n");
 
-            responseContent.append("VERSION: " + request.getProtocolVersion().text() + "\r\n");
+            responseContent.append("VERSION: " + request.protocolVersion().text() + "\r\n");
 
-            responseContent.append("REQUEST_URI: " + request.getUri() + "\r\n\r\n");
+            responseContent.append("REQUEST_URI: " + request.uri() + "\r\n\r\n");
             responseContent.append("\r\n\r\n");
 
             // new getMethod
@@ -128,11 +127,11 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
                 cookies = CookieDecoder.decode(value);
             }
             for (Cookie cookie : cookies) {
-                responseContent.append("COOKIE: " + cookie.toString() + "\r\n");
+                responseContent.append("COOKIE: " + cookie + "\r\n");
             }
             responseContent.append("\r\n\r\n");
 
-            QueryStringDecoder decoderQuery = new QueryStringDecoder(request.getUri());
+            QueryStringDecoder decoderQuery = new QueryStringDecoder(request.uri());
             Map<String, List<String>> uriAttributes = decoderQuery.parameters();
             for (Entry<String, List<String>> attr: uriAttributes.entrySet()) {
                 for (String attrVal: attr.getValue()) {
@@ -142,6 +141,13 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
             responseContent.append("\r\n\r\n");
 
             // if GET Method: should not try to create a HttpPostRequestDecoder
+            if (request.method().equals(HttpMethod.GET)) {
+                // GET Method: should not try to create a HttpPostRequestDecoder
+                // So stop here
+                responseContent.append("\r\n\r\nEND OF GET CONTENT\r\n");
+                writeResponse(ctx.channel());
+                return;
+            }
             try {
                 decoder = new HttpPostRequestDecoder(factory, request);
             } catch (ErrorDataDecoderException e1) {
@@ -150,13 +156,6 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
                 writeResponse(ctx.channel());
                 ctx.channel().close();
                 return;
-            } catch (IncompatibleDataDecoderException e1) {
-                // GET Method: should not try to create a HttpPostRequestDecoder
-                // So OK but stop here
-                responseContent.append(e1.getMessage());
-                responseContent.append("\r\n\r\nEND OF GET CONTENT\r\n");
-                writeResponse(ctx.channel());
-                return;
             }
 
             readingChunks = HttpHeaders.isTransferEncodingChunked(request);
@@ -247,10 +246,10 @@ private void writeHttpData(InterfaceHttpData data) {
                         + attribute.getName() + " data too long\r\n");
             } else {
                 responseContent.append("\r\nBODY Attribute: " + attribute.getHttpDataType().name() + ": "
-                        + attribute.toString() + "\r\n");
+                        + attribute + "\r\n");
             }
         } else {
-            responseContent.append("\r\nBODY FileUpload: " + data.getHttpDataType().name() + ": " + data.toString()
+            responseContent.append("\r\nBODY FileUpload: " + data.getHttpDataType().name() + ": " + data
                     + "\r\n");
             if (data.getHttpDataType() == HttpDataType.FileUpload) {
                 FileUpload fileUpload = (FileUpload) data;
@@ -286,9 +285,9 @@ private void writeResponse(Channel channel) {
         responseContent.setLength(0);
 
         // Decide whether to close the connection or not.
-        boolean close = HttpHeaders.Values.CLOSE.equalsIgnoreCase(request.headers().get(CONNECTION))
-                || request.getProtocolVersion().equals(HttpVersion.HTTP_1_0)
-                && !HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(request.headers().get(CONNECTION));
+        boolean close = request.headers().contains(CONNECTION, HttpHeaders.Values.CLOSE, true)
+                || request.protocolVersion().equals(HttpVersion.HTTP_1_0)
+                && !request.headers().contains(CONNECTION, HttpHeaders.Values.KEEP_ALIVE, true);
 
         // Build the response object.
         FullHttpResponse response = new DefaultFullHttpResponse(
diff --git a/example/src/main/java/io/netty/example/http/upload/HttpUploadServerInitializer.java b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerInitializer.java
index 78ebf6e43f6e..b300bff30fdc 100644
--- a/example/src/main/java/io/netty/example/http/upload/HttpUploadServerInitializer.java
+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerInitializer.java
@@ -18,33 +18,33 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.example.securechat.SecureChatSslContextFactory;
 import io.netty.handler.codec.http.HttpContentCompressor;
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
-import io.netty.handler.ssl.SslHandler;
-
-import javax.net.ssl.SSLEngine;
+import io.netty.handler.ssl.SslContext;
 
 public class HttpUploadServerInitializer extends ChannelInitializer<SocketChannel> {
+
+    private final SslContext sslCtx;
+
+    public HttpUploadServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
+
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        // Create a default pipeline implementation.
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
 
-        if (HttpUploadServer.isSSL) {
-            SSLEngine engine = SecureChatSslContextFactory.getServerContext().createSSLEngine();
-            engine.setUseClientMode(false);
-            pipeline.addLast("ssl", new SslHandler(engine));
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
         }
 
-        pipeline.addLast("decoder", new HttpRequestDecoder());
-        pipeline.addLast("encoder", new HttpResponseEncoder());
+        pipeline.addLast(new HttpRequestDecoder());
+        pipeline.addLast(new HttpResponseEncoder());
 
-        // Remove the following line if you don't want automatic content
-        // compression.
-        pipeline.addLast("deflater", new HttpContentCompressor());
+        // Remove the following line if you don't want automatic content compression.
+        pipeline.addLast(new HttpContentCompressor());
 
-        pipeline.addLast("handler", new HttpUploadServerHandler());
+        pipeline.addLast(new HttpUploadServerHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
index 5e6095167f37..7f954497fd93 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2014 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -13,27 +13,6 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-//The MIT License
-//
-//Copyright (c) 2009 Carl Bystršm
-//
-//Permission is hereby granted, free of charge, to any person obtaining a copy
-//of this software and associated documentation files (the "Software"), to deal
-//in the Software without restriction, including without limitation the rights
-//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-//copies of the Software, and to permit persons to whom the Software is
-//furnished to do so, subject to the following conditions:
-//
-//The above copyright notice and this permission notice shall be included in
-//all copies or substantial portions of the Software.
-//
-//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-//THE SOFTWARE.
 package io.netty.example.http.websocketx.client;
 
 import io.netty.bootstrap.Bootstrap;
@@ -47,89 +26,117 @@
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.HttpClientCodec;
-import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;
+import io.netty.handler.codec.http.websocketx.WebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketVersion;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
 import java.net.URI;
 
-public class WebSocketClient {
-
-    private final URI uri;
+/**
+ * This is an example of a WebSocket client.
+ * <p>
+ * In order to run this example you need a compatible WebSocket server.
+ * Therefore you can either start the WebSocket server from the examples
+ * by running {@link io.netty.example.http.websocketx.server.WebSocketServer}
+ * or connect to an existing WebSocket server such as
+ * <a href="http://www.websocket.org/echo.html">ws://echo.websocket.org</a>.
+ * <p>
+ * The client will attempt to connect to the URI passed to it as the first argument.
+ * You don't have to specify any arguments if you want to connect to the example WebSocket server,
+ * as this is the default.
+ */
+public final class WebSocketClient {
 
-    public WebSocketClient(URI uri) {
-        this.uri = uri;
-    }
+    static final String URL = System.getProperty("url", "ws://127.0.0.1:8080/websocket");
 
-    public void run() throws Exception {
-        EventLoopGroup group = new NioEventLoopGroup();
-        try {
-            Bootstrap b = new Bootstrap();
-            String protocol = uri.getScheme();
-            if (!"ws".equals(protocol)) {
-                throw new IllegalArgumentException("Unsupported protocol: " + protocol);
+    public static void main(String[] args) throws Exception {
+        URI uri = new URI(URL);
+        String scheme = uri.getScheme() == null? "http" : uri.getScheme();
+        final String host = uri.getHost() == null? "127.0.0.1" : uri.getHost();
+        final int port;
+        if (uri.getPort() == -1) {
+            if ("http".equalsIgnoreCase(scheme)) {
+                port = 80;
+            } else if ("https".equalsIgnoreCase(scheme)) {
+                port = 443;
+            } else {
+                port = -1;
             }
+        } else {
+            port = uri.getPort();
+        }
 
-            HttpHeaders customHeaders = new DefaultHttpHeaders();
-            customHeaders.add("MyHeader", "MyValue");
+        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
+            System.err.println("Only WS(S) is supported.");
+            return;
+        }
+
+        final boolean ssl = "wss".equalsIgnoreCase(scheme);
+        final SslContext sslCtx;
+        if (ssl) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
+        EventLoopGroup group = new NioEventLoopGroup();
+        try {
             // Connect with V13 (RFC 6455 aka HyBi-17). You can change it to V08 or V00.
             // If you change it to V00, ping is not supported and remember to change
             // HttpResponseDecoder to WebSocketHttpResponseDecoder in the pipeline.
             final WebSocketClientHandler handler =
                     new WebSocketClientHandler(
                             WebSocketClientHandshakerFactory.newHandshaker(
-                                    uri, WebSocketVersion.V13, null, false, customHeaders));
+                                    uri, WebSocketVersion.V13, null, false, new DefaultHttpHeaders()));
 
+            Bootstrap b = new Bootstrap();
             b.group(group)
              .channel(NioSocketChannel.class)
              .handler(new ChannelInitializer<SocketChannel>() {
                  @Override
-                 public void initChannel(SocketChannel ch) throws Exception {
-                     ChannelPipeline pipeline = ch.pipeline();
-                     pipeline.addLast("http-codec", new HttpClientCodec());
-                     pipeline.addLast("aggregator", new HttpObjectAggregator(8192));
-                     pipeline.addLast("ws-handler", handler);
+                 protected void initChannel(SocketChannel ch) {
+                     ChannelPipeline p = ch.pipeline();
+                     if (sslCtx != null) {
+                         p.addLast(sslCtx.newHandler(ch.alloc(), host, port));
+                     }
+                     p.addLast(
+                             new HttpClientCodec(),
+                             new HttpObjectAggregator(8192),
+                             handler);
                  }
              });
 
-            System.out.println("WebSocket Client connecting");
-            Channel ch = b.connect(uri.getHost(), uri.getPort()).sync().channel();
+            Channel ch = b.connect(uri.getHost(), port).sync().channel();
             handler.handshakeFuture().sync();
 
-            // Send 10 messages and wait for responses
-            System.out.println("WebSocket Client sending message");
-            for (int i = 0; i < 10; i++) {
-                ch.writeAndFlush(new TextWebSocketFrame("Message #" + i));
+            BufferedReader console = new BufferedReader(new InputStreamReader(System.in));
+            while (true) {
+                String msg = console.readLine();
+                if (msg == null) {
+                    break;
+                } else if ("bye".equals(msg.toLowerCase())) {
+                    ch.writeAndFlush(new CloseWebSocketFrame());
+                    ch.closeFuture().sync();
+                    break;
+                } else if ("ping".equals(msg.toLowerCase())) {
+                    WebSocketFrame frame = new PingWebSocketFrame(Unpooled.wrappedBuffer(new byte[] { 8, 1, 8, 1 }));
+                    ch.writeAndFlush(frame);
+                } else {
+                    WebSocketFrame frame = new TextWebSocketFrame(msg);
+                    ch.writeAndFlush(frame);
+                }
             }
-
-            // Ping
-            System.out.println("WebSocket Client sending ping");
-            ch.writeAndFlush(new PingWebSocketFrame(Unpooled.copiedBuffer(new byte[]{1, 2, 3, 4, 5, 6})));
-
-            // Close
-            System.out.println("WebSocket Client sending close");
-            ch.writeAndFlush(new CloseWebSocketFrame());
-
-            // WebSocketClientHandler will close the connection when the server
-            // responds to the CloseWebSocketFrame.
-            ch.closeFuture().sync();
         } finally {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        URI uri;
-        if (args.length > 0) {
-            uri = new URI(args[0]);
-        } else {
-            uri = new URI("ws://localhost:8080/websocket");
-        }
-        new WebSocketClient(uri).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
index 25846a59a595..c36283cd8ef7 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
@@ -64,17 +64,17 @@ public ChannelFuture handshakeFuture() {
     }
 
     @Override
-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+    public void handlerAdded(ChannelHandlerContext ctx) {
         handshakeFuture = ctx.newPromise();
     }
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+    public void channelActive(ChannelHandlerContext ctx) {
         handshaker.handshake(ctx.channel());
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) {
         System.out.println("WebSocket Client disconnected!");
     }
 
@@ -90,8 +90,9 @@ public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception
 
         if (msg instanceof FullHttpResponse) {
             FullHttpResponse response = (FullHttpResponse) msg;
-            throw new Exception("Unexpected FullHttpResponse (getStatus=" + response.getStatus() + ", content="
-                    + response.content().toString(CharsetUtil.UTF_8) + ')');
+            throw new IllegalStateException(
+                    "Unexpected FullHttpResponse (getStatus=" + response.status() +
+                            ", content=" + response.content().toString(CharsetUtil.UTF_8) + ')');
         }
 
         WebSocketFrame frame = (WebSocketFrame) msg;
@@ -107,13 +108,11 @@ public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
-
         if (!handshakeFuture.isDone()) {
             handshakeFuture.setFailure(cause);
         }
-
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/websocketx/html5/WebSocketServer.java b/example/src/main/java/io/netty/example/http/websocketx/html5/WebSocketServer.java
deleted file mode 100644
index db4072280edf..000000000000
--- a/example/src/main/java/io/netty/example/http/websocketx/html5/WebSocketServer.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License, version
- * 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at:
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-package io.netty.example.http.websocketx.html5;
-
-import io.netty.bootstrap.ServerBootstrap;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.channel.socket.nio.NioServerSocketChannel;
-import io.netty.handler.codec.http.HttpObjectAggregator;
-import io.netty.handler.codec.http.HttpRequestDecoder;
-import io.netty.handler.codec.http.HttpResponseEncoder;
-import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;
-
-/**
- * A WebSocket Server that respondes to requests at:
- *
- * <pre>
- * http://localhost:8080/websocket
- * </pre>
- *
- * The example differs from many of the other examples in Netty in that is does
- * not have an acomponying client. Instead a html page is provided that
- * interacts with this server. <br>
- * Open up the following file a web browser that supports WebSocket's:
- *
- * <pre>
- * example/src/main/resources/websocketx/html5/websocket.html
- * </pre>
- *
- * The html page is very simple were you simply enter some text and the server
- * will echo the same text back, but in uppercase. You, also see getStatus messages
- * in the "Response From Server" area when client has connected, disconnected
- * etc.
- *
- */
-public class WebSocketServer {
-
-    private final int port;
-
-    public WebSocketServer(int port) {
-        this.port = port;
-    }
-
-    public void run() throws Exception {
-        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
-        EventLoopGroup workerGroup = new NioEventLoopGroup();
-        try {
-            final ServerBootstrap sb = new ServerBootstrap();
-            sb.group(bossGroup, workerGroup)
-             .channel(NioServerSocketChannel.class)
-             .childHandler(new ChannelInitializer<SocketChannel>() {
-                @Override
-                public void initChannel(final SocketChannel ch) throws Exception {
-                    ch.pipeline().addLast(
-                        new HttpRequestDecoder(),
-                        new HttpObjectAggregator(65536),
-                        new HttpResponseEncoder(),
-                        new WebSocketServerProtocolHandler("/websocket"),
-                        new CustomTextFrameHandler());
-                }
-            });
-
-            final Channel ch = sb.bind(port).sync().channel();
-            System.out.println("Web socket server started at port " + port);
-
-            ch.closeFuture().sync();
-        } finally {
-            bossGroup.shutdownGracefully();
-            workerGroup.shutdownGracefully();
-        }
-    }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new WebSocketServer(port).run();
-    }
-
-}
diff --git a/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java
index 840b560147bd..81e5265443d4 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java
@@ -20,6 +20,10 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * A HTTP server which serves Web Socket requests at:
@@ -40,26 +44,34 @@
  * <li>Firefox 11+ (RFC 6455 aka draft-ietf-hybi-thewebsocketprotocol-17)
  * </ul>
  */
-public class WebSocketServer {
+public final class WebSocketServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));
 
-    public WebSocketServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new WebSocketServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new WebSocketServerInitializer(sslCtx));
+
+            Channel ch = b.bind(PORT).sync().channel();
 
-            Channel ch = b.bind(port).sync().channel();
-            System.out.println("Web socket server started at port " + port + '.');
-            System.out.println("Open your browser and navigate to http://localhost:" + port + '/');
+            System.err.println("Open your web browser and navigate to " +
+                    (SSL? "https" : "http") + "://127.0.0.1:" + PORT + '/');
 
             ch.closeFuture().sync();
         } finally {
@@ -67,14 +79,4 @@ public void run() throws Exception {
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new WebSocketServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
index 88276b06e366..14e03608571c 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
@@ -33,11 +34,7 @@
 import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
 import io.netty.util.CharsetUtil;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpHeaders.*;
 import static io.netty.handler.codec.http.HttpMethod.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
@@ -46,14 +43,13 @@
  * Handles handshakes and messages
  */
 public class WebSocketServerHandler extends SimpleChannelInboundHandler<Object> {
-    private static final Logger logger = Logger.getLogger(WebSocketServerHandler.class.getName());
 
     private static final String WEBSOCKET_PATH = "/websocket";
 
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead0(ChannelHandlerContext ctx, Object msg) {
         if (msg instanceof FullHttpRequest) {
             handleHttpRequest(ctx, (FullHttpRequest) msg);
         } else if (msg instanceof WebSocketFrame) {
@@ -62,35 +58,35 @@ public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
-    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
+    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) {
         // Handle a bad request.
-        if (!req.getDecoderResult().isSuccess()) {
+        if (!req.decoderResult().isSuccess()) {
             sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
             return;
         }
 
         // Allow only GET methods.
-        if (req.getMethod() != GET) {
+        if (req.method() != GET) {
             sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
             return;
         }
 
         // Send the demo page and favicon.ico
-        if ("/".equals(req.getUri())) {
+        if ("/".equals(req.uri())) {
             ByteBuf content = WebSocketServerIndexPage.getContent(getWebSocketLocation(req));
             FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, OK, content);
 
             res.headers().set(CONTENT_TYPE, "text/html; charset=UTF-8");
-            setContentLength(res, content.readableBytes());
+            HttpHeaders.setContentLength(res, content.readableBytes());
 
             sendHttpResponse(ctx, req, res);
             return;
         }
-        if ("/favicon.ico".equals(req.getUri())) {
+        if ("/favicon.ico".equals(req.uri())) {
             FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, NOT_FOUND);
             sendHttpResponse(ctx, req, res);
             return;
@@ -125,36 +121,39 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
 
         // Send the uppercase string back.
         String request = ((TextWebSocketFrame) frame).text();
-        if (logger.isLoggable(Level.FINE)) {
-            logger.fine(String.format("%s received %s", ctx.channel(), request));
-        }
+        System.err.printf("%s received %s%n", ctx.channel(), request);
         ctx.channel().write(new TextWebSocketFrame(request.toUpperCase()));
     }
 
     private static void sendHttpResponse(
             ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {
         // Generate an error page if response getStatus code is not OK (200).
-        if (res.getStatus().code() != 200) {
-            ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8);
+        if (res.status().code() != 200) {
+            ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8);
             res.content().writeBytes(buf);
             buf.release();
-            setContentLength(res, res.content().readableBytes());
+            HttpHeaders.setContentLength(res, res.content().readableBytes());
         }
 
         // Send the response and close the connection if necessary.
         ChannelFuture f = ctx.channel().writeAndFlush(res);
-        if (!isKeepAlive(req) || res.getStatus().code() != 200) {
+        if (!HttpHeaders.isKeepAlive(req) || res.status().code() != 200) {
             f.addListener(ChannelFutureListener.CLOSE);
         }
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }
 
     private static String getWebSocketLocation(FullHttpRequest req) {
-        return "ws://" + req.headers().get(HOST) + WEBSOCKET_PATH;
+        String location =  req.headers().get(HOST) + WEBSOCKET_PATH;
+        if (WebSocketServer.SSL) {
+            return "wss://" + location;
+        } else {
+            return "ws://" + location;
+        }
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerInitializer.java b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerInitializer.java
index 420dec755da2..f012004c2f79 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerInitializer.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerInitializer.java
@@ -20,15 +20,26 @@
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpServerCodec;
+import io.netty.handler.ssl.SslContext;
 
 /**
  */
 public class WebSocketServerInitializer extends ChannelInitializer<SocketChannel> {
+
+    private final SslContext sslCtx;
+
+    public WebSocketServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
+
     @Override
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline pipeline = ch.pipeline();
-        pipeline.addLast("codec-http", new HttpServerCodec());
-        pipeline.addLast("aggregator", new HttpObjectAggregator(65536));
-        pipeline.addLast("handler", new WebSocketServerHandler());
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
+        }
+        pipeline.addLast(new HttpServerCodec());
+        pipeline.addLast(new HttpObjectAggregator(65536));
+        pipeline.addLast(new WebSocketServerHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java
deleted file mode 100644
index 6cca57a084da..000000000000
--- a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.http.websocketx.sslserver;
-
-import io.netty.bootstrap.ServerBootstrap;
-import io.netty.channel.Channel;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.nio.NioServerSocketChannel;
-
-/**
- * A HTTP server which serves Web Socket requests at:
- *
- * https://localhost:8081/websocket
- *
- * Open your browser at https://localhost:8081/, then the demo page will be loaded and a Web Socket connection will be
- * made automatically.
- *
- * This server illustrates support for the different web socket specification versions and will work with:
- *
- * <ul>
- * <li>Safari 5+ (draft-ietf-hybi-thewebsocketprotocol-00)
- * <li>Chrome 6-13 (draft-ietf-hybi-thewebsocketprotocol-00)
- * <li>Chrome 14+ (draft-ietf-hybi-thewebsocketprotocol-10)
- * <li>Chrome 16+ (RFC 6455 aka draft-ietf-hybi-thewebsocketprotocol-17)
- * <li>Firefox 7+ (draft-ietf-hybi-thewebsocketprotocol-10)
- * </ul>
- */
-public class WebSocketSslServer {
-
-    private final int port;
-
-    public WebSocketSslServer(int port) {
-        this.port = port;
-    }
-
-    public void run() throws Exception {
-        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
-        EventLoopGroup workerGroup = new NioEventLoopGroup();
-        try {
-            ServerBootstrap b = new ServerBootstrap();
-            b.group(bossGroup, workerGroup)
-             .channel(NioServerSocketChannel.class)
-             .childHandler(new WebSocketSslServerInitializer());
-
-            Channel ch = b.bind(port).sync().channel();
-            System.out.println("Web socket server started at port " + port + '.');
-            System.out.println("Open your browser and navigate to https://localhost:" + port + '/');
-            ch.closeFuture().sync();
-        } finally {
-            bossGroup.shutdownGracefully();
-            workerGroup.shutdownGracefully();
-        }
-    }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8443;
-        }
-
-        String keyStoreFilePath = System.getProperty("keystore.file.path");
-        if (keyStoreFilePath == null || keyStoreFilePath.isEmpty()) {
-            System.out.println("ERROR: System property keystore.file.path not set. Exiting now!");
-            System.exit(1);
-        }
-
-        String keyStoreFilePassword = System.getProperty("keystore.file.password");
-        if (keyStoreFilePassword == null || keyStoreFilePassword.isEmpty()) {
-            System.out.println("ERROR: System property keystore.file.password not set. Exiting now!");
-            System.exit(1);
-        }
-
-        new WebSocketSslServer(port).run();
-    }
-}
diff --git a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
deleted file mode 100644
index 89992607f63a..000000000000
--- a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.http.websocketx.sslserver;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.example.http.websocketx.server.WebSocketServerIndexPage;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
-import io.netty.handler.codec.http.websocketx.WebSocketFrame;
-import io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
-import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
-import io.netty.util.CharsetUtil;
-
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-import static io.netty.handler.codec.http.HttpHeaders.Names.*;
-import static io.netty.handler.codec.http.HttpHeaders.*;
-import static io.netty.handler.codec.http.HttpMethod.*;
-import static io.netty.handler.codec.http.HttpResponseStatus.*;
-import static io.netty.handler.codec.http.HttpVersion.*;
-
-/**
- * Handles handshakes and messages
- */
-public class WebSocketSslServerHandler extends SimpleChannelInboundHandler<Object> {
-    private static final Logger logger = Logger.getLogger(WebSocketSslServerHandler.class.getName());
-
-    private static final String WEBSOCKET_PATH = "/websocket";
-
-    private WebSocketServerHandshaker handshaker;
-
-    @Override
-    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
-        if (msg instanceof FullHttpRequest) {
-            handleHttpRequest(ctx, (FullHttpRequest) msg);
-        } else if (msg instanceof WebSocketFrame) {
-            handleWebSocketFrame(ctx, (WebSocketFrame) msg);
-        }
-    }
-
-    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
-        // Handle a bad request.
-        if (!req.getDecoderResult().isSuccess()) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
-            return;
-        }
-
-        // Allow only GET methods.
-        if (req.getMethod() != GET) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
-            return;
-        }
-
-        // Send the demo page and favicon.ico
-        if ("/".equals(req.getUri())) {
-            ByteBuf content = WebSocketServerIndexPage.getContent(getWebSocketLocation(req));
-            FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, OK, content);
-
-            res.headers().set(CONTENT_TYPE, "text/html; charset=UTF-8");
-            setContentLength(res, content.readableBytes());
-
-            sendHttpResponse(ctx, req, res);
-            return;
-        }
-
-        if ("/favicon.ico".equals(req.getUri())) {
-            FullHttpResponse res = new DefaultFullHttpResponse(HTTP_1_1, NOT_FOUND);
-            sendHttpResponse(ctx, req, res);
-            return;
-        }
-
-        // Handshake
-        WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(
-                getWebSocketLocation(req), null, false);
-        handshaker = wsFactory.newHandshaker(req);
-        if (handshaker == null) {
-            WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());
-        } else {
-            handshaker.handshake(ctx.channel(), req);
-        }
-    }
-
-    private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
-
-        // Check for closing frame
-        if (frame instanceof CloseWebSocketFrame) {
-            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
-            return;
-        }
-        if (frame instanceof PingWebSocketFrame) {
-            ctx.channel().write(new PongWebSocketFrame(frame.content().retain()));
-            return;
-        }
-        if (!(frame instanceof TextWebSocketFrame)) {
-            throw new UnsupportedOperationException(String.format("%s frame types not supported", frame.getClass()
-                    .getName()));
-        }
-
-        // Send the uppercase string back.
-        String request = ((TextWebSocketFrame) frame).text();
-        if (logger.isLoggable(Level.FINE)) {
-            logger.fine(String.format("%s received %s", ctx.channel(), request));
-        }
-        ctx.channel().write(new TextWebSocketFrame(request.toUpperCase()));
-    }
-
-    private static void sendHttpResponse(
-            ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {
-        // Generate an error page if response getStatus code is not OK (200).
-        if (res.getStatus().code() != 200) {
-            ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8);
-            res.content().writeBytes(buf);
-            buf.release();
-            setContentLength(res, res.content().readableBytes());
-        }
-
-        // Send the response and close the connection if necessary.
-        ChannelFuture f = ctx.channel().write(res);
-        if (!isKeepAlive(req) || res.getStatus().code() != 200) {
-            f.addListener(ChannelFutureListener.CLOSE);
-        }
-    }
-
-    @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        ctx.flush();
-    }
-
-    @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        cause.printStackTrace();
-        ctx.close();
-    }
-
-    private static String getWebSocketLocation(FullHttpRequest req) {
-        return "wss://" + req.headers().get(HOST) + WEBSOCKET_PATH;
-    }
-}
diff --git a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerInitializer.java b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerInitializer.java
deleted file mode 100644
index f8de25fc7446..000000000000
--- a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerInitializer.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.http.websocketx.sslserver;
-
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.handler.codec.http.HttpObjectAggregator;
-import io.netty.handler.codec.http.HttpRequestDecoder;
-import io.netty.handler.codec.http.HttpResponseEncoder;
-import io.netty.handler.ssl.SslHandler;
-
-import javax.net.ssl.SSLEngine;
-
-/**
- */
-public class WebSocketSslServerInitializer extends ChannelInitializer<SocketChannel> {
-    @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        ChannelPipeline pipeline = ch.pipeline();
-
-        SSLEngine engine = WebSocketSslServerSslContext.getInstance().serverContext().createSSLEngine();
-        engine.setUseClientMode(false);
-        pipeline.addLast("ssl", new SslHandler(engine));
-
-        pipeline.addLast("decoder", new HttpRequestDecoder());
-        pipeline.addLast("aggregator", new HttpObjectAggregator(65536));
-        pipeline.addLast("encoder", new HttpResponseEncoder());
-        pipeline.addLast("handler", new WebSocketSslServerHandler());
-    }
-}
diff --git a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java
deleted file mode 100644
index b6be874838b3..000000000000
--- a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.http.websocketx.sslserver;
-
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import java.io.FileInputStream;
-import java.security.KeyStore;
-import java.security.Security;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-/**
- * Creates a {@link SSLContext} for just server certificates.
- */
-public final class WebSocketSslServerSslContext {
-
-    private static final Logger logger = Logger.getLogger(WebSocketSslServerSslContext.class.getName());
-    private static final String PROTOCOL = "TLS";
-    private final SSLContext _serverContext;
-
-    /**
-     * Returns the singleton instance for this class
-     */
-    public static WebSocketSslServerSslContext getInstance() {
-        return SingletonHolder.INSTANCE;
-    }
-
-    /**
-     * SingletonHolder is loaded on the first execution of Singleton.getInstance() or the first access to
-     * SingletonHolder.INSTANCE, not before.
-     *
-     * See http://en.wikipedia.org/wiki/Singleton_pattern
-     */
-    private interface SingletonHolder {
-        WebSocketSslServerSslContext INSTANCE = new WebSocketSslServerSslContext();
-    }
-
-    /**
-     * Constructor for singleton
-     */
-    private WebSocketSslServerSslContext() {
-        SSLContext serverContext = null;
-        try {
-            // Key store (Server side certificate)
-            String algorithm = Security.getProperty("ssl.KeyManagerFactory.algorithm");
-            if (algorithm == null) {
-                algorithm = "SunX509";
-            }
-
-            try {
-                String keyStoreFilePath = System.getProperty("keystore.file.path");
-                String keyStoreFilePassword = System.getProperty("keystore.file.password");
-
-                KeyStore ks = KeyStore.getInstance("JKS");
-                FileInputStream fin = new FileInputStream(keyStoreFilePath);
-                ks.load(fin, keyStoreFilePassword.toCharArray());
-
-                // Set up key manager factory to use our key store
-                // Assume key password is the same as the key store file
-                // password
-                KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
-                kmf.init(ks, keyStoreFilePassword.toCharArray());
-
-                // Initialise the SSLContext to work with our key managers.
-                serverContext = SSLContext.getInstance(PROTOCOL);
-                serverContext.init(kmf.getKeyManagers(), null, null);
-            } catch (Exception e) {
-                throw new Error("Failed to initialize the server-side SSLContext", e);
-            }
-        } catch (Exception ex) {
-            logger.log(Level.WARNING, "Error initializing SslContextManager.", ex);
-            System.exit(1);
-        } finally {
-            _serverContext = serverContext;
-        }
-    }
-
-    /**
-     * Returns the server context with server side key store
-     */
-    public SSLContext serverContext() {
-        return _serverContext;
-    }
-
-}
diff --git a/example/src/main/java/io/netty/example/http/websocketx/sslserver/package-info.java b/example/src/main/java/io/netty/example/http/websocketx/sslserver/package-info.java
deleted file mode 100644
index bbe9c39e44cf..000000000000
--- a/example/src/main/java/io/netty/example/http/websocketx/sslserver/package-info.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-/**
- * <p>This package contains an example web socket web server with server SSL.
- * <p>To run this example, follow the steps below:
- * <dl>
- *   <dt>Step 1. Generate Your Key
- *   <dd>
- *     {@code keytool -genkey -keystore mySrvKeystore -keyalg RSA}.
- *     Make sure that you set the key password to be the same the key file password.
- *   <dt>Step 2. Specify your key store file and password as system properties
- *   <dd>
- *     {@code -Dkeystore.file.path=<path to mySrvKeystore> -Dkeystore.file.password=<password>}
- *   <dt>Step 3. Run WebSocketSslServer as a Java application
- *   <dd>
- *     Once started, you can test the web server against your browser by navigating to https://localhost:8081/
- * </dl>
- * <p>To find out more about setting up key stores, refer to this
- * <a href="http://download.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html">giude</a>.
- */
-package io.netty.example.http.websocketx.sslserver;
diff --git a/example/src/main/java/io/netty/example/localecho/LocalEcho.java b/example/src/main/java/io/netty/example/localecho/LocalEcho.java
index cd707fcdc09f..583ce02e4f92 100644
--- a/example/src/main/java/io/netty/example/localecho/LocalEcho.java
+++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java
@@ -20,10 +20,10 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.DefaultEventLoopGroup;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
-import io.netty.channel.local.LocalEventLoopGroup;
 import io.netty.channel.local.LocalServerChannel;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.handler.logging.LogLevel;
@@ -32,19 +32,15 @@
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 
-public class LocalEcho {
+public final class LocalEcho {
 
-    private final String port;
+    static final String PORT = System.getProperty("port", "test_port");
 
-    public LocalEcho(String port) {
-        this.port = port;
-    }
-
-    public void run() throws Exception {
+    public static void main(String[] args) throws Exception {
         // Address to bind on / connect to.
-        final LocalAddress addr = new LocalAddress(port);
+        final LocalAddress addr = new LocalAddress(PORT);
 
-        EventLoopGroup serverGroup = new LocalEventLoopGroup();
+        EventLoopGroup serverGroup = new DefaultEventLoopGroup();
         EventLoopGroup clientGroup = new NioEventLoopGroup(); // NIO event loops are also OK
         try {
             // Note that we can use any event loop to ensure certain local channels
@@ -109,8 +105,4 @@ public void initChannel(LocalChannel ch) throws Exception {
             clientGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        new LocalEcho("1").run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java b/example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java
index 86e327ac4875..af2d60977540 100644
--- a/example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java
@@ -18,17 +18,16 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 
-
 public class LocalEchoServerHandler extends ChannelInboundHandlerAdapter {
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         // Write back as received
         ctx.write(msg);
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
diff --git a/example/src/main/java/io/netty/example/memcache/binary/MemcacheClient.java b/example/src/main/java/io/netty/example/memcache/binary/MemcacheClient.java
new file mode 100644
index 000000000000..9a8b21c29fd3
--- /dev/null
+++ b/example/src/main/java/io/netty/example/memcache/binary/MemcacheClient.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.example.memcache.binary;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.memcache.binary.BinaryMemcacheClientCodec;
+import io.netty.handler.codec.memcache.binary.BinaryMemcacheObjectAggregator;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+
+/**
+ * Simple memcache client that demonstrates get and set commands against a memcache server.
+ */
+public final class MemcacheClient {
+
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "11211"));
+
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        } else {
+            sslCtx = null;
+        }
+
+        EventLoopGroup group = new NioEventLoopGroup();
+        try {
+            Bootstrap b = new Bootstrap();
+            b.group(group)
+                    .channel(NioSocketChannel.class)
+                    .handler(new ChannelInitializer<SocketChannel>() {
+                        @Override
+                        protected void initChannel(SocketChannel ch) throws Exception {
+                            ChannelPipeline p = ch.pipeline();
+                            if (sslCtx != null) {
+                                p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));
+                            }
+                            p.addLast(new BinaryMemcacheClientCodec());
+                            p.addLast(new BinaryMemcacheObjectAggregator(Integer.MAX_VALUE));
+                            p.addLast(new MemcacheClientHandler());
+                        }
+                    });
+
+            // Start the connection attempt.
+            Channel ch = b.connect(HOST, PORT).sync().channel();
+
+            // Read commands from the stdin.
+            System.out.println("Enter commands (quit to end)");
+            System.out.println("get <key>");
+            System.out.println("set <key> <value>");
+            ChannelFuture lastWriteFuture = null;
+            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
+            for (;;) {
+                String line = in.readLine();
+                if (line == null) {
+                    break;
+                }
+                if ("quit".equals(line.toLowerCase())) {
+                    ch.close().sync();
+                    break;
+                }
+                // Sends the received line to the server.
+                lastWriteFuture = ch.writeAndFlush(line);
+            }
+
+            // Wait until all messages are flushed before closing the channel.
+            if (lastWriteFuture != null) {
+                lastWriteFuture.sync();
+            }
+        } finally {
+            group.shutdownGracefully();
+        }
+    }
+}
diff --git a/example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java b/example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java
new file mode 100644
index 000000000000..d7eb127d4ed5
--- /dev/null
+++ b/example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.example.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.memcache.binary.BinaryMemcacheOpcodes;
+import io.netty.handler.codec.memcache.binary.BinaryMemcacheRequest;
+import io.netty.handler.codec.memcache.binary.DefaultBinaryMemcacheRequest;
+import io.netty.handler.codec.memcache.binary.DefaultFullBinaryMemcacheRequest;
+import io.netty.handler.codec.memcache.binary.FullBinaryMemcacheResponse;
+import io.netty.util.CharsetUtil;
+
+public class MemcacheClientHandler extends ChannelDuplexHandler {
+
+    /**
+     * Transforms basic string requests to binary memcache requests
+     */
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+        String command = (String) msg;
+        if (command.startsWith("get ")) {
+            String key = command.substring("get ".length());
+
+            BinaryMemcacheRequest req = new DefaultBinaryMemcacheRequest(key);
+            req.setOpcode(BinaryMemcacheOpcodes.GET);
+            req.setKeyLength((short) key.length());
+            req.setTotalBodyLength(key.length());
+
+            ctx.write(req, promise);
+        } else if (command.startsWith("set ")) {
+            String[] parts = command.split(" ", 3);
+            if (parts.length < 3) {
+                throw new IllegalArgumentException("Malformed Command: " + command);
+            }
+            String key = parts[1];
+            String value = parts[2];
+
+            ByteBuf content = Unpooled.wrappedBuffer(value.getBytes(CharsetUtil.UTF_8));
+            ByteBuf extras = ctx.alloc().buffer(8);
+
+            BinaryMemcacheRequest req = new DefaultFullBinaryMemcacheRequest(key, extras, content);
+            req.setOpcode(BinaryMemcacheOpcodes.SET);
+            req.setKeyLength((short) key.length());
+            req.setExtrasLength((byte) 8);
+            req.setTotalBodyLength(key.length() + 8 + value.length());
+
+            ctx.write(req, promise);
+        } else {
+            throw new IllegalStateException("Unknown Message: " + msg);
+        }
+    }
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
+        FullBinaryMemcacheResponse res = (FullBinaryMemcacheResponse) msg;
+        System.out.println(res.content().toString(CharsetUtil.UTF_8));
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
+        ctx.close();
+    }
+}
diff --git a/example/src/main/java/io/netty/example/objectecho/ObjectEchoClient.java b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClient.java
index 49bd94853700..ce2f49ea28ad 100644
--- a/example/src/main/java/io/netty/example/objectecho/ObjectEchoClient.java
+++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClient.java
@@ -17,6 +17,7 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
@@ -25,23 +26,28 @@
 import io.netty.handler.codec.serialization.ClassResolvers;
 import io.netty.handler.codec.serialization.ObjectDecoder;
 import io.netty.handler.codec.serialization.ObjectEncoder;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 /**
  * Modification of {@link EchoClient} which utilizes Java object serialization.
  */
-public class ObjectEchoClient {
+public final class ObjectEchoClient {
 
-    private final String host;
-    private final int port;
-    private final int firstMessageSize;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
+    static final int SIZE = Integer.parseInt(System.getProperty("size", "256"));
 
-    public ObjectEchoClient(String host, int port, int firstMessageSize) {
-        this.host = host;
-        this.port = port;
-        this.firstMessageSize = firstMessageSize;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
@@ -50,40 +56,21 @@ public void run() throws Exception {
              .handler(new ChannelInitializer<SocketChannel>() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
-                    ch.pipeline().addLast(
+                    ChannelPipeline p = ch.pipeline();
+                    if (sslCtx != null) {
+                        p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));
+                    }
+                    p.addLast(
                             new ObjectEncoder(),
                             new ObjectDecoder(ClassResolvers.cacheDisabled(null)),
-                            new ObjectEchoClientHandler(firstMessageSize));
+                            new ObjectEchoClientHandler());
                 }
              });
 
             // Start the connection attempt.
-            b.connect(host, port).sync().channel().closeFuture().sync();
+            b.connect(HOST, PORT).sync().channel().closeFuture().sync();
         } finally {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length < 2 || args.length > 3) {
-            System.err.println(
-                    "Usage: " + ObjectEchoClient.class.getSimpleName() +
-                    " <host> <port> [<first message size>]");
-            return;
-        }
-
-        // Parse options.
-        final String host = args[0];
-        final int port = Integer.parseInt(args[1]);
-        final int firstMessageSize;
-
-        if (args.length == 3) {
-            firstMessageSize = Integer.parseInt(args[2]);
-        } else {
-            firstMessageSize = 256;
-        }
-
-        new ObjectEchoClient(host, port, firstMessageSize).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
index dd55cc41edba..2f6580cb373c 100644
--- a/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
@@ -20,8 +20,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * Handler implementation for the object echo client.  It initiates the
@@ -30,48 +28,38 @@
  */
 public class ObjectEchoClientHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger logger = Logger.getLogger(
-            ObjectEchoClientHandler.class.getName());
-
     private final List<Integer> firstMessage;
 
     /**
      * Creates a client-side handler.
      */
-    public ObjectEchoClientHandler(int firstMessageSize) {
-        if (firstMessageSize <= 0) {
-            throw new IllegalArgumentException(
-                    "firstMessageSize: " + firstMessageSize);
-        }
-        firstMessage = new ArrayList<Integer>(firstMessageSize);
-        for (int i = 0; i < firstMessageSize; i ++) {
+    public ObjectEchoClientHandler() {
+        firstMessage = new ArrayList<Integer>(ObjectEchoClient.SIZE);
+        for (int i = 0; i < ObjectEchoClient.SIZE; i ++) {
             firstMessage.add(Integer.valueOf(i));
         }
     }
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+    public void channelActive(ChannelHandlerContext ctx) {
         // Send the first message if this handler is a client-side handler.
         ctx.writeAndFlush(firstMessage);
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         // Echo back the received object to the server.
         ctx.write(msg);
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(
-            ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/objectecho/ObjectEchoServer.java b/example/src/main/java/io/netty/example/objectecho/ObjectEchoServer.java
index 031b93737dcf..9b277ea7caaa 100644
--- a/example/src/main/java/io/netty/example/objectecho/ObjectEchoServer.java
+++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoServer.java
@@ -17,6 +17,7 @@
 
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
@@ -25,29 +26,44 @@
 import io.netty.handler.codec.serialization.ClassResolvers;
 import io.netty.handler.codec.serialization.ObjectDecoder;
 import io.netty.handler.codec.serialization.ObjectEncoder;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * Modification of {@link EchoServer} which utilizes Java object serialization.
  */
-public class ObjectEchoServer {
+public final class ObjectEchoServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
 
-    public ObjectEchoServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
+             .handler(new LoggingHandler(LogLevel.INFO))
              .childHandler(new ChannelInitializer<SocketChannel>() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
-                    ch.pipeline().addLast(
+                    ChannelPipeline p = ch.pipeline();
+                    if (sslCtx != null) {
+                        p.addLast(sslCtx.newHandler(ch.alloc()));
+                    }
+                    p.addLast(
                             new ObjectEncoder(),
                             new ObjectDecoder(ClassResolvers.cacheDisabled(null)),
                             new ObjectEchoServerHandler());
@@ -55,20 +71,10 @@ public void initChannel(SocketChannel ch) throws Exception {
              });
 
             // Bind and start to accept incoming connections.
-            b.bind(port).sync().channel().closeFuture().sync();
+            b.bind(PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new ObjectEchoServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java b/example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java
index 001193f1c85a..151abd31106e 100644
--- a/example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java
@@ -18,36 +18,26 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handles both client-side and server-side handler depending on which
  * constructor was called.
  */
 public class ObjectEchoServerHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger logger = Logger.getLogger(
-            ObjectEchoServerHandler.class.getName());
-
     @Override
-    public void channelRead(
-            ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         // Echo back the received object to the client.
         ctx.write(msg);
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(
-            ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/portunification/PortUnificationServer.java b/example/src/main/java/io/netty/example/portunification/PortUnificationServer.java
index 04533918c948..68f70f978ecc 100644
--- a/example/src/main/java/io/netty/example/portunification/PortUnificationServer.java
+++ b/example/src/main/java/io/netty/example/portunification/PortUnificationServer.java
@@ -21,6 +21,10 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * Serves two protocols (HTTP and Factorial) using only one port, enabling
@@ -29,43 +33,34 @@
  * Because SSL and GZIP are enabled on demand, 5 combinations per protocol
  * are possible: none, SSL only, GZIP only, SSL + GZIP, and GZIP + SSL.
  */
-public class PortUnificationServer {
+public final class PortUnificationServer {
 
-    private final int port;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8080"));
 
-    public PortUnificationServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL context
+        SelfSignedCertificate ssc = new SelfSignedCertificate();
+        final SslContext sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
+             .handler(new LoggingHandler(LogLevel.INFO))
              .childHandler(new ChannelInitializer<SocketChannel>() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
-                    ch.pipeline().addLast(new PortUnificationServerHandler());
+                    ch.pipeline().addLast(new PortUnificationServerHandler(sslCtx));
                 }
             });
 
             // Bind and start to accept incoming connections.
-            b.bind(port).sync().channel().closeFuture().sync();
+            b.bind(PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new PortUnificationServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java b/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
index d3f4b2ede752..dae32b035600 100644
--- a/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
+++ b/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
@@ -22,16 +22,15 @@
 import io.netty.example.factorial.FactorialServerHandler;
 import io.netty.example.factorial.NumberEncoder;
 import io.netty.example.http.snoop.HttpSnoopServerHandler;
-import io.netty.example.securechat.SecureChatSslContextFactory;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.handler.codec.http.HttpContentCompressor;
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
+import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslHandler;
 
-import javax.net.ssl.SSLEngine;
 import java.util.List;
 
 /**
@@ -40,14 +39,16 @@
  */
 public class PortUnificationServerHandler extends ByteToMessageDecoder {
 
+    private final SslContext sslCtx;
     private final boolean detectSsl;
     private final boolean detectGzip;
 
-    public PortUnificationServerHandler() {
-        this(true, true);
+    public PortUnificationServerHandler(SslContext sslCtx) {
+        this(sslCtx, true, true);
     }
 
-    private PortUnificationServerHandler(boolean detectSsl, boolean detectGzip) {
+    private PortUnificationServerHandler(SslContext sslCtx, boolean detectSsl, boolean detectGzip) {
+        this.sslCtx = sslCtx;
         this.detectSsl = detectSsl;
         this.detectGzip = detectGzip;
     }
@@ -111,13 +112,8 @@ private static boolean isFactorial(int magic1) {
 
     private void enableSsl(ChannelHandlerContext ctx) {
         ChannelPipeline p = ctx.pipeline();
-
-        SSLEngine engine =
-            SecureChatSslContextFactory.getServerContext().createSSLEngine();
-        engine.setUseClientMode(false);
-
-        p.addLast("ssl", new SslHandler(engine));
-        p.addLast("unificationA", new PortUnificationServerHandler(false, detectGzip));
+        p.addLast("ssl", sslCtx.newHandler(ctx.alloc()));
+        p.addLast("unificationA", new PortUnificationServerHandler(sslCtx, false, detectGzip));
         p.remove(this);
     }
 
@@ -125,7 +121,7 @@ private void enableGzip(ChannelHandlerContext ctx) {
         ChannelPipeline p = ctx.pipeline();
         p.addLast("gzipdeflater", ZlibCodecFactory.newZlibEncoder(ZlibWrapper.GZIP));
         p.addLast("gzipinflater", ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));
-        p.addLast("unificationB", new PortUnificationServerHandler(detectSsl, false));
+        p.addLast("unificationB", new PortUnificationServerHandler(sslCtx, detectSsl, false));
         p.remove(this);
     }
 
diff --git a/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java b/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java
index e68ed6fc04fd..6038cffbf315 100644
--- a/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java
+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java
@@ -20,23 +20,17 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
 
-public class HexDumpProxy {
+public final class HexDumpProxy {
 
-    private final int localPort;
-    private final String remoteHost;
-    private final int remotePort;
+    static final int LOCAL_PORT = Integer.parseInt(System.getProperty("localPort", "8443"));
+    static final String REMOTE_HOST = System.getProperty("remoteHost", "www.google.com");
+    static final int REMOTE_PORT = Integer.parseInt(System.getProperty("remotePort", "443"));
 
-    public HexDumpProxy(int localPort, String remoteHost, int remotePort) {
-        this.localPort = localPort;
-        this.remoteHost = remoteHost;
-        this.remotePort = remotePort;
-    }
-
-    public void run() throws Exception {
-        System.err.println(
-                "Proxying *:" + localPort + " to " +
-                remoteHost + ':' + remotePort + " ...");
+    public static void main(String[] args) throws Exception {
+        System.err.println("Proxying *:" + LOCAL_PORT + " to " + REMOTE_HOST + ':' + REMOTE_PORT + " ...");
 
         // Configure the bootstrap.
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
@@ -45,29 +39,13 @@ public void run() throws Exception {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new HexDumpProxyInitializer(remoteHost, remotePort))
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new HexDumpProxyInitializer(REMOTE_HOST, REMOTE_PORT))
              .childOption(ChannelOption.AUTO_READ, false)
-             .bind(localPort).sync().channel().closeFuture().sync();
+             .bind(LOCAL_PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Validate command line options.
-        if (args.length != 3) {
-            System.err.println(
-                    "Usage: " + HexDumpProxy.class.getSimpleName() +
-                    " <local port> <remote host> <remote port>");
-            return;
-        }
-
-        // Parse command line options.
-        int localPort = Integer.parseInt(args[0]);
-        String remoteHost = args[1];
-        int remotePort = Integer.parseInt(args[2]);
-
-        new HexDumpProxy(localPort, remoteHost, remotePort).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java b/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
index 9f93b270bc9f..da6af5abf279 100644
--- a/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
@@ -31,16 +31,16 @@ public HexDumpProxyBackendHandler(Channel inboundChannel) {
     }
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+    public void channelActive(ChannelHandlerContext ctx) {
         ctx.read();
         ctx.write(Unpooled.EMPTY_BUFFER);
     }
 
     @Override
-    public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(final ChannelHandlerContext ctx, Object msg) {
         inboundChannel.writeAndFlush(msg).addListener(new ChannelFutureListener() {
             @Override
-            public void operationComplete(ChannelFuture future) throws Exception {
+            public void operationComplete(ChannelFuture future) {
                 if (future.isSuccess()) {
                     ctx.channel().read();
                 } else {
@@ -51,12 +51,12 @@ public void operationComplete(ChannelFuture future) throws Exception {
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) {
         HexDumpProxyFrontendHandler.closeOnFlush(inboundChannel);
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         HexDumpProxyFrontendHandler.closeOnFlush(ctx.channel());
     }
diff --git a/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
index 39a6de28dff1..8b44d2d160bf 100644
--- a/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
@@ -37,7 +37,7 @@ public HexDumpProxyFrontendHandler(String remoteHost, int remotePort) {
     }
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+    public void channelActive(ChannelHandlerContext ctx) {
         final Channel inboundChannel = ctx.channel();
 
         // Start the connection attempt.
@@ -50,7 +50,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         outboundChannel = f.channel();
         f.addListener(new ChannelFutureListener() {
             @Override
-            public void operationComplete(ChannelFuture future) throws Exception {
+            public void operationComplete(ChannelFuture future) {
                 if (future.isSuccess()) {
                     // connection complete start to read first data
                     inboundChannel.read();
@@ -63,11 +63,11 @@ public void operationComplete(ChannelFuture future) throws Exception {
     }
 
     @Override
-    public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(final ChannelHandlerContext ctx, Object msg) {
         if (outboundChannel.isActive()) {
             outboundChannel.writeAndFlush(msg).addListener(new ChannelFutureListener() {
                 @Override
-                public void operationComplete(ChannelFuture future) throws Exception {
+                public void operationComplete(ChannelFuture future) {
                     if (future.isSuccess()) {
                         // was able to flush out data, start to read the next chunk
                         ctx.channel().read();
@@ -80,14 +80,14 @@ public void operationComplete(ChannelFuture future) throws Exception {
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) {
         if (outboundChannel != null) {
             closeOnFlush(outboundChannel);
         }
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         closeOnFlush(ctx.channel());
     }
diff --git a/example/src/main/java/io/netty/example/proxy/HexDumpProxyInitializer.java b/example/src/main/java/io/netty/example/proxy/HexDumpProxyInitializer.java
index 7005c73828bf..441d596a214e 100644
--- a/example/src/main/java/io/netty/example/proxy/HexDumpProxyInitializer.java
+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyInitializer.java
@@ -31,7 +31,7 @@ public HexDumpProxyInitializer(String remoteHost, int remotePort) {
     }
 
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
+    public void initChannel(SocketChannel ch) {
         ch.pipeline().addLast(
                 new LoggingHandler(LogLevel.INFO),
                 new HexDumpProxyFrontendHandler(remoteHost, remotePort));
diff --git a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java
index d5c4d03e57f7..20e3ca4f3c6b 100644
--- a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java
+++ b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java
@@ -28,20 +28,17 @@
 import java.net.InetSocketAddress;
 
 /**
- * A UDP broadcast client that asks for a quote of the moment (QOTM) to
- * {@link QuoteOfTheMomentServer}.
+ * A UDP broadcast client that asks for a quote of the moment (QOTM) to {@link QuoteOfTheMomentServer}.
  *
- * Inspired by <a href="http://goo.gl/BsXVR">the official Java tutorial</a>.
+ * Inspired by <a href="http://docs.oracle.com/javase/tutorial/networking/datagrams/clientServer.html">the official
+ * Java tutorial</a>.
  */
-public class QuoteOfTheMomentClient {
+public final class QuoteOfTheMomentClient {
 
-    private final int port;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "7686"));
 
-    public QuoteOfTheMomentClient(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
 
-    public void run() throws Exception {
         EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
@@ -55,7 +52,7 @@ public void run() throws Exception {
             // Broadcast the QOTM request to port 8080.
             ch.writeAndFlush(new DatagramPacket(
                     Unpooled.copiedBuffer("QOTM?", CharsetUtil.UTF_8),
-                    new InetSocketAddress("255.255.255.255", port))).sync();
+                    new InetSocketAddress("255.255.255.255", PORT))).sync();
 
             // QuoteOfTheMomentClientHandler will close the DatagramChannel when a
             // response is received.  If the channel is not closed within 5 seconds,
@@ -67,14 +64,4 @@ public void run() throws Exception {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new QuoteOfTheMomentClient(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
index eaab48d67801..de5fbb0b0ffe 100644
--- a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
+++ b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
@@ -32,7 +32,7 @@ public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws E
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }
diff --git a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServer.java b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServer.java
index 72f67604a729..c8954a3ee396 100644
--- a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServer.java
+++ b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServer.java
@@ -22,20 +22,16 @@
 import io.netty.channel.socket.nio.NioDatagramChannel;
 
 /**
- * A UDP server that responds to the QOTM (quote of the moment) request to a
- * {@link QuoteOfTheMomentClient}.
+ * A UDP server that responds to the QOTM (quote of the moment) request to a {@link QuoteOfTheMomentClient}.
  *
- * Inspired by <a href="http://goo.gl/BsXVR">the official Java tutorial</a>.
+ * Inspired by <a href="http://docs.oracle.com/javase/tutorial/networking/datagrams/clientServer.html">the official
+ * Java tutorial</a>.
  */
-public class QuoteOfTheMomentServer {
+public final class QuoteOfTheMomentServer {
 
-    private final int port;
+    private static final int PORT = Integer.parseInt(System.getProperty("port", "7686"));
 
-    public QuoteOfTheMomentServer(int port) {
-        this.port = port;
-    }
-
-    public void run() throws Exception {
+    public static void main(String[] args) throws Exception {
         EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
@@ -44,19 +40,9 @@ public void run() throws Exception {
              .option(ChannelOption.SO_BROADCAST, true)
              .handler(new QuoteOfTheMomentServerHandler());
 
-            b.bind(port).sync().channel().closeFuture().await();
+            b.bind(PORT).sync().channel().closeFuture().await();
         } finally {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new QuoteOfTheMomentServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
index f08384e2e04f..302c731c3d8e 100644
--- a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
+++ b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
@@ -53,14 +53,12 @@ public void channelRead0(ChannelHandlerContext ctx, DatagramPacket packet) throw
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(
-            ChannelHandlerContext ctx, Throwable cause)
-            throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         // We don't close the channel because we can keep serving requests.
     }
diff --git a/example/src/main/java/io/netty/example/rxtx/RxtxClient.java b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java
index 7737e12a7e0a..955bb06ec7e6 100644
--- a/example/src/main/java/io/netty/example/rxtx/RxtxClient.java
+++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java
@@ -31,6 +31,8 @@
  */
 public final class RxtxClient {
 
+    static final String PORT = System.getProperty("port", "/dev/ttyUSB0");
+
     public static void main(String[] args) throws Exception {
         EventLoopGroup group = new OioEventLoopGroup();
         try {
@@ -49,14 +51,11 @@ public void initChannel(RxtxChannel ch) throws Exception {
                  }
              });
 
-            ChannelFuture f = b.connect(new RxtxDeviceAddress("/dev/ttyUSB0")).sync();
+            ChannelFuture f = b.connect(new RxtxDeviceAddress(PORT)).sync();
 
             f.channel().closeFuture().sync();
         } finally {
             group.shutdownGracefully();
         }
     }
-
-    private RxtxClient() {
-    }
 }
diff --git a/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java b/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java
deleted file mode 100644
index 26f94ff3037f..000000000000
--- a/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.sctp;
-
-import io.netty.bootstrap.Bootstrap;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.oio.OioEventLoopGroup;
-import io.netty.channel.sctp.SctpChannel;
-import io.netty.channel.sctp.SctpChannelOption;
-import io.netty.channel.sctp.oio.OioSctpChannel;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
-
-/**
- * Sends one message when a connection is open and echoes back any received
- * data to the server over SCTP connection.
- *
- * Simply put, the echo client initiates the ping-pong
- * traffic between the echo client and server by sending the first message to
- * the server.
- */
-public class OioSctpEchoClient {
-
-    private final String host;
-    private final int port;
-    private final int firstMessageSize;
-
-    public OioSctpEchoClient(String host, int port, int firstMessageSize) {
-        this.host = host;
-        this.port = port;
-        this.firstMessageSize = firstMessageSize;
-    }
-
-    public void run() throws Exception {
-        // Configure the client.
-        EventLoopGroup group = new OioEventLoopGroup();
-        try {
-            Bootstrap b = new Bootstrap();
-            b.group(group)
-             .channel(OioSctpChannel.class)
-             .option(SctpChannelOption.SCTP_NODELAY, true)
-             .handler(new ChannelInitializer<SctpChannel>() {
-                 @Override
-                 public void initChannel(SctpChannel ch) throws Exception {
-                     ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
-                             new SctpEchoClientHandler(firstMessageSize));
-                 }
-             });
-
-            // Start the client.
-            ChannelFuture f = b.connect(host, port).sync();
-
-            // Wait until the connection is closed.
-            f.channel().closeFuture().sync();
-        } finally {
-            // Shut down the event loop to terminate all threads.
-            group.shutdownGracefully();
-        }
-    }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length < 2 || args.length > 3) {
-            System.err.println(
-                    "Usage: " + OioSctpEchoClient.class.getSimpleName() +
-                            " <host> <port> [<first message size>]");
-            return;
-        }
-
-        // Parse options.
-        final String host = args[0];
-        final int port = Integer.parseInt(args[1]);
-        final int firstMessageSize;
-        if (args.length == 3) {
-            firstMessageSize = Integer.parseInt(args[2]);
-        } else {
-            firstMessageSize = 256;
-        }
-
-        new OioSctpEchoClient(host, port, firstMessageSize).run();
-    }
-}
diff --git a/example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java b/example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java
deleted file mode 100644
index 1e036b6cb562..000000000000
--- a/example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.sctp;
-
-import io.netty.bootstrap.ServerBootstrap;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
-import io.netty.channel.oio.OioEventLoopGroup;
-import io.netty.channel.sctp.SctpChannel;
-import io.netty.channel.sctp.oio.OioSctpServerChannel;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
-
-/**
- * Echoes back any received data from a SCTP client.
- */
-public class OioSctpEchoServer {
-
-    private final int port;
-
-    public OioSctpEchoServer(int port) {
-        this.port = port;
-    }
-
-    public void run() throws Exception {
-        // Configure the server.
-        EventLoopGroup bossGroup = new OioEventLoopGroup(1);
-        EventLoopGroup workerGroup = new OioEventLoopGroup();
-        try {
-            ServerBootstrap b = new ServerBootstrap();
-            b.group(bossGroup, workerGroup)
-             .channel(OioSctpServerChannel.class)
-             .option(ChannelOption.SO_BACKLOG, 100)
-             .handler(new LoggingHandler(LogLevel.INFO))
-             .childHandler(new ChannelInitializer<SctpChannel>() {
-                 @Override
-                 public void initChannel(SctpChannel ch) throws Exception {
-                     ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
-                             new SctpEchoServerHandler());
-                 }
-             });
-
-            // Start the server.
-            ChannelFuture f = b.bind(port).sync();
-
-            // Wait until the server socket is closed.
-            f.channel().closeFuture().sync();
-        } finally {
-            // Shut down all event loops to terminate all threads.
-            bossGroup.shutdownGracefully();
-            workerGroup.shutdownGracefully();
-        }
-    }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 2556;
-        }
-        new OioSctpEchoServer(port).run();
-    }
-}
diff --git a/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java b/example/src/main/java/io/netty/example/sctp/SctpEchoClient.java
similarity index 61%
rename from example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java
rename to example/src/main/java/io/netty/example/sctp/SctpEchoClient.java
index c7eecbda2ded..326ad66adfbc 100644
--- a/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java
+++ b/example/src/main/java/io/netty/example/sctp/SctpEchoClient.java
@@ -23,8 +23,6 @@
 import io.netty.channel.sctp.SctpChannel;
 import io.netty.channel.sctp.SctpChannelOption;
 import io.netty.channel.sctp.nio.NioSctpChannel;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
 
 /**
  * Sends one message when a connection is open and echoes back any received
@@ -34,19 +32,13 @@
  * traffic between the echo client and server by sending the first message to
  * the server.
  */
-public class NioSctpEchoClient {
+public final class SctpEchoClient {
 
-    private final String host;
-    private final int port;
-    private final int firstMessageSize;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
+    static final int SIZE = Integer.parseInt(System.getProperty("size", "256"));
 
-    public NioSctpEchoClient(String host, int port, int firstMessageSize) {
-        this.host = host;
-        this.port = port;
-        this.firstMessageSize = firstMessageSize;
-    }
-
-    public void run() throws Exception {
+    public static void main(String[] args) throws Exception {
         // Configure the client.
         EventLoopGroup group = new NioEventLoopGroup();
         try {
@@ -58,13 +50,13 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SctpChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
-                             new SctpEchoClientHandler(firstMessageSize));
+                             //new LoggingHandler(LogLevel.INFO),
+                             new SctpEchoClientHandler());
                  }
              });
 
             // Start the client.
-            ChannelFuture f = b.connect(host, port).sync();
+            ChannelFuture f = b.connect(HOST, PORT).sync();
 
             // Wait until the connection is closed.
             f.channel().closeFuture().sync();
@@ -73,26 +65,4 @@ public void initChannel(SctpChannel ch) throws Exception {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length < 2 || args.length > 3) {
-            System.err.println(
-                    "Usage: " + NioSctpEchoClient.class.getSimpleName() +
-                    " <host> <port> [<first message size>]");
-            return;
-        }
-
-        // Parse options.
-        final String host = args[0];
-        final int port = Integer.parseInt(args[1]);
-        final int firstMessageSize;
-        if (args.length == 3) {
-            firstMessageSize = Integer.parseInt(args[2]);
-        } else {
-            firstMessageSize = 256;
-        }
-
-        new NioSctpEchoClient(host, port, firstMessageSize).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java b/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java
index 78740ef02369..56fe025553b7 100644
--- a/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java
@@ -21,9 +21,6 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.sctp.SctpMessage;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the SCTP echo client.  It initiates the ping-pong
  * traffic between the echo client and server by sending the first message to
@@ -31,19 +28,13 @@
  */
 public class SctpEchoClientHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger logger = Logger.getLogger(
-            SctpEchoClientHandler.class.getName());
-
     private final ByteBuf firstMessage;
 
     /**
      * Creates a client-side handler.
      */
-    public SctpEchoClientHandler(int firstMessageSize) {
-        if (firstMessageSize <= 0) {
-            throw new IllegalArgumentException("firstMessageSize: " + firstMessageSize);
-        }
-        firstMessage = Unpooled.buffer(firstMessageSize);
+    public SctpEchoClientHandler() {
+        firstMessage = Unpooled.buffer(SctpEchoClient.SIZE);
         for (int i = 0; i < firstMessage.capacity(); i++) {
             firstMessage.writeByte((byte) i);
         }
@@ -55,19 +46,19 @@ public void channelActive(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         ctx.write(msg);
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         // Close the connection when an exception is raised.
-        logger.log(Level.WARNING, "Unexpected exception from downstream.", cause);
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java b/example/src/main/java/io/netty/example/sctp/SctpEchoServer.java
similarity index 82%
rename from example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java
rename to example/src/main/java/io/netty/example/sctp/SctpEchoServer.java
index a38dce628871..96493f4ddfa4 100644
--- a/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java
+++ b/example/src/main/java/io/netty/example/sctp/SctpEchoServer.java
@@ -29,15 +29,11 @@
 /**
  * Echoes back any received data from a SCTP client.
  */
-public class NioSctpEchoServer {
+public final class SctpEchoServer {
 
-    private final int port;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
 
-    public NioSctpEchoServer(int port) {
-        this.port = port;
-    }
-
-    public void run() throws Exception {
+    public static void main(String[] args) throws Exception {
         // Configure the server.
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
@@ -51,13 +47,13 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SctpChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
+                             //new LoggingHandler(LogLevel.INFO),
                              new SctpEchoServerHandler());
                  }
              });
 
             // Start the server.
-            ChannelFuture f = b.bind(port).sync();
+            ChannelFuture f = b.bind(PORT).sync();
 
             // Wait until the server socket is closed.
             f.channel().closeFuture().sync();
@@ -67,14 +63,4 @@ public void initChannel(SctpChannel ch) throws Exception {
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 2556;
-        }
-        new NioSctpEchoServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/sctp/SctpEchoServerHandler.java b/example/src/main/java/io/netty/example/sctp/SctpEchoServerHandler.java
index 9681fc439a9d..cfacaa74e57b 100644
--- a/example/src/main/java/io/netty/example/sctp/SctpEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/sctp/SctpEchoServerHandler.java
@@ -19,32 +19,26 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the SCTP echo server.
  */
 @Sharable
 public class SctpEchoServerHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger logger = Logger.getLogger(
-            SctpEchoServerHandler.class.getName());
-
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
-        // Close the connection when an exception is raised.
-        logger.log(Level.WARNING, "Unexpected exception from downstream.", cause);
-        ctx.close();
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
+        ctx.write(msg);
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        ctx.write(msg);
+    public void channelReadComplete(ChannelHandlerContext ctx) {
+        ctx.flush();
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        ctx.flush();
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        // Close the connection when an exception is raised.
+        cause.printStackTrace();
+        ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatClient.java b/example/src/main/java/io/netty/example/securechat/SecureChatClient.java
index 66230bd7c281..390775e2cd88 100644
--- a/example/src/main/java/io/netty/example/securechat/SecureChatClient.java
+++ b/example/src/main/java/io/netty/example/securechat/SecureChatClient.java
@@ -22,6 +22,8 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.example.telnet.TelnetClient;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
@@ -29,26 +31,24 @@
 /**
  * Simple SSL chat client modified from {@link TelnetClient}.
  */
-public class SecureChatClient {
+public final class SecureChatClient {
 
-    private final String host;
-    private final int port;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8992"));
 
-    public SecureChatClient(String host, int port) {
-        this.host = host;
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
 
-    public void run() throws Exception {
         EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
             b.group(group)
              .channel(NioSocketChannel.class)
-             .handler(new SecureChatClientInitializer());
+             .handler(new SecureChatClientInitializer(sslCtx));
 
             // Start the connection attempt.
-            Channel ch = b.connect(host, port).sync().channel();
+            Channel ch = b.connect(HOST, PORT).sync().channel();
 
             // Read commands from the stdin.
             ChannelFuture lastWriteFuture = null;
@@ -79,20 +79,4 @@ public void run() throws Exception {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length != 2) {
-            System.err.println(
-                    "Usage: " + SecureChatClient.class.getSimpleName() +
-                    " <host> <port>");
-            return;
-        }
-
-        // Parse options.
-        String host = args[0];
-        int port = Integer.parseInt(args[1]);
-
-        new SecureChatClient(host, port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
index 5b4c9abbb122..894227ec4e6f 100644
--- a/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
+++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
@@ -18,27 +18,19 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handles a client-side channel.
  */
 public class SecureChatClientHandler extends SimpleChannelInboundHandler<String> {
 
-    private static final Logger logger = Logger.getLogger(
-            SecureChatClientHandler.class.getName());
-
     @Override
     public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
         System.err.println(msg);
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java b/example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java
index 413d659c1ae3..ed293240d166 100644
--- a/example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java
+++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java
@@ -22,15 +22,19 @@
 import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
-import io.netty.handler.ssl.SslHandler;
-
-import javax.net.ssl.SSLEngine;
+import io.netty.handler.ssl.SslContext;
 
 /**
  * Creates a newly configured {@link ChannelPipeline} for a new channel.
  */
 public class SecureChatClientInitializer extends ChannelInitializer<SocketChannel> {
 
+    private final SslContext sslCtx;
+
+    public SecureChatClientInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
+
     @Override
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline pipeline = ch.pipeline();
@@ -40,20 +44,14 @@ public void initChannel(SocketChannel ch) throws Exception {
         // and accept any invalid certificates in the client side.
         // You will need something more complicated to identify both
         // and server in the real world.
-
-        SSLEngine engine =
-            SecureChatSslContextFactory.getClientContext().createSSLEngine();
-        engine.setUseClientMode(true);
-
-        pipeline.addLast("ssl", new SslHandler(engine));
+        pipeline.addLast(sslCtx.newHandler(ch.alloc(), SecureChatClient.HOST, SecureChatClient.PORT));
 
         // On top of the SSL handler, add the text line codec.
-        pipeline.addLast("framer", new DelimiterBasedFrameDecoder(
-                8192, Delimiters.lineDelimiter()));
-        pipeline.addLast("decoder", new StringDecoder());
-        pipeline.addLast("encoder", new StringEncoder());
+        pipeline.addLast(new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()));
+        pipeline.addLast(new StringDecoder());
+        pipeline.addLast(new StringEncoder());
 
         // and then business logic.
-        pipeline.addLast("handler", new SecureChatClientHandler());
+        pipeline.addLast(new SecureChatClientHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatKeyStore.java b/example/src/main/java/io/netty/example/securechat/SecureChatKeyStore.java
deleted file mode 100644
index 2aea9478acde..000000000000
--- a/example/src/main/java/io/netty/example/securechat/SecureChatKeyStore.java
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.securechat;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-
-/**
- * A bogus key store which provides all the required information to
- * create an example SSL connection.
- *
- * To generate a bogus key store:
- * <pre>
- * keytool  -genkey -alias securechat -keysize 2048 -validity 36500
- *          -keyalg RSA -dname "CN=securechat"
- *          -keypass secret -storepass secret
- *          -keystore cert.jks
- * </pre>
- */
-public final class SecureChatKeyStore {
-    private static final short[] DATA = {
-        0xfe, 0xed, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x02,
-        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
-        0x00, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c,
-        0x65, 0x00, 0x00, 0x01, 0x1a, 0x9f, 0x57, 0xa5,
-        0x27, 0x00, 0x00, 0x01, 0x9a, 0x30, 0x82, 0x01,
-        0x96, 0x30, 0x0e, 0x06, 0x0a, 0x2b, 0x06, 0x01,
-        0x04, 0x01, 0x2a, 0x02, 0x11, 0x01, 0x01, 0x05,
-        0x00, 0x04, 0x82, 0x01, 0x82, 0x48, 0x6d, 0xcf,
-        0x16, 0xb5, 0x50, 0x95, 0x36, 0xbf, 0x47, 0x27,
-        0x50, 0x58, 0x0d, 0xa2, 0x52, 0x7e, 0x25, 0xab,
-        0x14, 0x1a, 0x26, 0x5e, 0x2d, 0x8a, 0x23, 0x90,
-        0x60, 0x7f, 0x12, 0x20, 0x56, 0xd1, 0x43, 0xa2,
-        0x6b, 0x47, 0x5d, 0xed, 0x9d, 0xd4, 0xe5, 0x83,
-        0x28, 0x89, 0xc2, 0x16, 0x4c, 0x76, 0x06, 0xad,
-        0x8e, 0x8c, 0x29, 0x1a, 0x9b, 0x0f, 0xdd, 0x60,
-        0x4b, 0xb4, 0x62, 0x82, 0x9e, 0x4a, 0x63, 0x83,
-        0x2e, 0xd2, 0x43, 0x78, 0xc2, 0x32, 0x1f, 0x60,
-        0xa9, 0x8a, 0x7f, 0x0f, 0x7c, 0xa6, 0x1d, 0xe6,
-        0x92, 0x9e, 0x52, 0xc7, 0x7d, 0xbb, 0x35, 0x3b,
-        0xaa, 0x89, 0x73, 0x4c, 0xfb, 0x99, 0x54, 0x97,
-        0x99, 0x28, 0x6e, 0x66, 0x5b, 0xf7, 0x9b, 0x7e,
-        0x6d, 0x8a, 0x2f, 0xfa, 0xc3, 0x1e, 0x71, 0xb9,
-        0xbd, 0x8f, 0xc5, 0x63, 0x25, 0x31, 0x20, 0x02,
-        0xff, 0x02, 0xf0, 0xc9, 0x2c, 0xdd, 0x3a, 0x10,
-        0x30, 0xab, 0xe5, 0xad, 0x3d, 0x1a, 0x82, 0x77,
-        0x46, 0xed, 0x03, 0x38, 0xa4, 0x73, 0x6d, 0x36,
-        0x36, 0x33, 0x70, 0xb2, 0x63, 0x20, 0xca, 0x03,
-        0xbf, 0x5a, 0xf4, 0x7c, 0x35, 0xf0, 0x63, 0x1a,
-        0x12, 0x33, 0x12, 0x58, 0xd9, 0xa2, 0x63, 0x6b,
-        0x63, 0x82, 0x41, 0x65, 0x70, 0x37, 0x4b, 0x99,
-        0x04, 0x9f, 0xdd, 0x5e, 0x07, 0x01, 0x95, 0x9f,
-        0x36, 0xe8, 0xc3, 0x66, 0x2a, 0x21, 0x69, 0x68,
-        0x40, 0xe6, 0xbc, 0xbb, 0x85, 0x81, 0x21, 0x13,
-        0xe6, 0xa4, 0xcf, 0xd3, 0x67, 0xe3, 0xfd, 0x75,
-        0xf0, 0xdf, 0x83, 0xe0, 0xc5, 0x36, 0x09, 0xac,
-        0x1b, 0xd4, 0xf7, 0x2a, 0x23, 0x57, 0x1c, 0x5c,
-        0x0f, 0xf4, 0xcf, 0xa2, 0xcf, 0xf5, 0xbd, 0x9c,
-        0x69, 0x98, 0x78, 0x3a, 0x25, 0xe4, 0xfd, 0x85,
-        0x11, 0xcc, 0x7d, 0xef, 0xeb, 0x74, 0x60, 0xb1,
-        0xb7, 0xfb, 0x1f, 0x0e, 0x62, 0xff, 0xfe, 0x09,
-        0x0a, 0xc3, 0x80, 0x2f, 0x10, 0x49, 0x89, 0x78,
-        0xd2, 0x08, 0xfa, 0x89, 0x22, 0x45, 0x91, 0x21,
-        0xbc, 0x90, 0x3e, 0xad, 0xb3, 0x0a, 0xb4, 0x0e,
-        0x1c, 0xa1, 0x93, 0x92, 0xd8, 0x72, 0x07, 0x54,
-        0x60, 0xe7, 0x91, 0xfc, 0xd9, 0x3c, 0xe1, 0x6f,
-        0x08, 0xe4, 0x56, 0xf6, 0x0b, 0xb0, 0x3c, 0x39,
-        0x8a, 0x2d, 0x48, 0x44, 0x28, 0x13, 0xca, 0xe9,
-        0xf7, 0xa3, 0xb6, 0x8a, 0x5f, 0x31, 0xa9, 0x72,
-        0xf2, 0xde, 0x96, 0xf2, 0xb1, 0x53, 0xb1, 0x3e,
-        0x24, 0x57, 0xfd, 0x18, 0x45, 0x1f, 0xc5, 0x33,
-        0x1b, 0xa4, 0xe8, 0x21, 0xfa, 0x0e, 0xb2, 0xb9,
-        0xcb, 0xc7, 0x07, 0x41, 0xdd, 0x2f, 0xb6, 0x6a,
-        0x23, 0x18, 0xed, 0xc1, 0xef, 0xe2, 0x4b, 0xec,
-        0xc9, 0xba, 0xfb, 0x46, 0x43, 0x90, 0xd7, 0xb5,
-        0x68, 0x28, 0x31, 0x2b, 0x8d, 0xa8, 0x51, 0x63,
-        0xf7, 0x53, 0x99, 0x19, 0x68, 0x85, 0x66, 0x00,
-        0x00, 0x00, 0x01, 0x00, 0x05, 0x58, 0x2e, 0x35,
-        0x30, 0x39, 0x00, 0x00, 0x02, 0x3a, 0x30, 0x82,
-        0x02, 0x36, 0x30, 0x82, 0x01, 0xe0, 0xa0, 0x03,
-        0x02, 0x01, 0x02, 0x02, 0x04, 0x48, 0x59, 0xf1,
-        0x92, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
-        0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00,
-        0x30, 0x81, 0xa0, 0x31, 0x0b, 0x30, 0x09, 0x06,
-        0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4b, 0x52,
-        0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04,
-        0x08, 0x13, 0x0a, 0x4b, 0x79, 0x75, 0x6e, 0x67,
-        0x67, 0x69, 0x2d, 0x64, 0x6f, 0x31, 0x14, 0x30,
-        0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x0b,
-        0x53, 0x65, 0x6f, 0x6e, 0x67, 0x6e, 0x61, 0x6d,
-        0x2d, 0x73, 0x69, 0x31, 0x1a, 0x30, 0x18, 0x06,
-        0x03, 0x55, 0x04, 0x0a, 0x13, 0x11, 0x54, 0x68,
-        0x65, 0x20, 0x4e, 0x65, 0x74, 0x74, 0x79, 0x20,
-        0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x31,
-        0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x0b,
-        0x13, 0x0f, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c,
-        0x65, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72,
-        0x73, 0x31, 0x30, 0x30, 0x2e, 0x06, 0x03, 0x55,
-        0x04, 0x03, 0x13, 0x27, 0x73, 0x65, 0x63, 0x75,
-        0x72, 0x65, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x65,
-        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x6e,
-        0x65, 0x74, 0x74, 0x79, 0x2e, 0x67, 0x6c, 0x65,
-        0x61, 0x6d, 0x79, 0x6e, 0x6f, 0x64, 0x65, 0x2e,
-        0x6e, 0x65, 0x74, 0x30, 0x20, 0x17, 0x0d, 0x30,
-        0x38, 0x30, 0x36, 0x31, 0x39, 0x30, 0x35, 0x34,
-        0x31, 0x33, 0x38, 0x5a, 0x18, 0x0f, 0x32, 0x31,
-        0x38, 0x37, 0x31, 0x31, 0x32, 0x34, 0x30, 0x35,
-        0x34, 0x31, 0x33, 0x38, 0x5a, 0x30, 0x81, 0xa0,
-        0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
-        0x06, 0x13, 0x02, 0x4b, 0x52, 0x31, 0x13, 0x30,
-        0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a,
-        0x4b, 0x79, 0x75, 0x6e, 0x67, 0x67, 0x69, 0x2d,
-        0x64, 0x6f, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03,
-        0x55, 0x04, 0x07, 0x13, 0x0b, 0x53, 0x65, 0x6f,
-        0x6e, 0x67, 0x6e, 0x61, 0x6d, 0x2d, 0x73, 0x69,
-        0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04,
-        0x0a, 0x13, 0x11, 0x54, 0x68, 0x65, 0x20, 0x4e,
-        0x65, 0x74, 0x74, 0x79, 0x20, 0x50, 0x72, 0x6f,
-        0x6a, 0x65, 0x63, 0x74, 0x31, 0x18, 0x30, 0x16,
-        0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x0f, 0x45,
-        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x41,
-        0x75, 0x74, 0x68, 0x6f, 0x72, 0x73, 0x31, 0x30,
-        0x30, 0x2e, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
-        0x27, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x63,
-        0x68, 0x61, 0x74, 0x2e, 0x65, 0x78, 0x61, 0x6d,
-        0x70, 0x6c, 0x65, 0x2e, 0x6e, 0x65, 0x74, 0x74,
-        0x79, 0x2e, 0x67, 0x6c, 0x65, 0x61, 0x6d, 0x79,
-        0x6e, 0x6f, 0x64, 0x65, 0x2e, 0x6e, 0x65, 0x74,
-        0x30, 0x5c, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
-        0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,
-        0x00, 0x03, 0x4b, 0x00, 0x30, 0x48, 0x02, 0x41,
-        0x00, 0xc3, 0xe3, 0x5e, 0x41, 0xa7, 0x87, 0x11,
-        0x00, 0x42, 0x2a, 0xb0, 0x4b, 0xed, 0xb2, 0xe0,
-        0x23, 0xdb, 0xb1, 0x3d, 0x58, 0x97, 0x35, 0x60,
-        0x0b, 0x82, 0x59, 0xd3, 0x00, 0xea, 0xd4, 0x61,
-        0xb8, 0x79, 0x3f, 0xb6, 0x3c, 0x12, 0x05, 0x93,
-        0x2e, 0x9a, 0x59, 0x68, 0x14, 0x77, 0x3a, 0xc8,
-        0x50, 0x25, 0x57, 0xa4, 0x49, 0x18, 0x63, 0x41,
-        0xf0, 0x2d, 0x28, 0xec, 0x06, 0xfb, 0xb4, 0x9f,
-        0xbf, 0x02, 0x03, 0x01, 0x00, 0x01, 0x30, 0x0d,
-        0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
-        0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x41, 0x00,
-        0x65, 0x6c, 0x30, 0x01, 0xc2, 0x8e, 0x3e, 0xcb,
-        0xb3, 0x77, 0x48, 0xe9, 0x66, 0x61, 0x9a, 0x40,
-        0x86, 0xaf, 0xf6, 0x03, 0xeb, 0xba, 0x6a, 0xf2,
-        0xfd, 0xe2, 0xaf, 0x36, 0x5e, 0x7b, 0xaa, 0x22,
-        0x04, 0xdd, 0x2c, 0x20, 0xc4, 0xfc, 0xdd, 0xd0,
-        0x82, 0x20, 0x1c, 0x3d, 0xd7, 0x9e, 0x5e, 0x5c,
-        0x92, 0x5a, 0x76, 0x71, 0x28, 0xf5, 0x07, 0x7d,
-        0xa2, 0x81, 0xba, 0x77, 0x9f, 0x2a, 0xd9, 0x44,
-        0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x6d, 0x79,
-        0x6b, 0x65, 0x79, 0x00, 0x00, 0x01, 0x1a, 0x9f,
-        0x5b, 0x56, 0xa0, 0x00, 0x00, 0x01, 0x99, 0x30,
-        0x82, 0x01, 0x95, 0x30, 0x0e, 0x06, 0x0a, 0x2b,
-        0x06, 0x01, 0x04, 0x01, 0x2a, 0x02, 0x11, 0x01,
-        0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x81, 0x29,
-        0xa8, 0xb6, 0x08, 0x0c, 0x85, 0x75, 0x3e, 0xdd,
-        0xb5, 0xe5, 0x1a, 0x87, 0x68, 0xd1, 0x90, 0x4b,
-        0x29, 0x31, 0xee, 0x90, 0xbc, 0x9d, 0x73, 0xa0,
-        0x3f, 0xe9, 0x0b, 0xa4, 0xef, 0x30, 0x9b, 0x36,
-        0x9a, 0xb2, 0x54, 0x77, 0x81, 0x07, 0x4b, 0xaa,
-        0xa5, 0x77, 0x98, 0xe1, 0xeb, 0xb5, 0x7c, 0x4e,
-        0x48, 0xd5, 0x08, 0xfc, 0x2c, 0x36, 0xe2, 0x65,
-        0x03, 0xac, 0xe5, 0xf3, 0x96, 0xb7, 0xd0, 0xb5,
-        0x3b, 0x92, 0xe4, 0x14, 0x05, 0x7a, 0x6a, 0x92,
-        0x56, 0xfe, 0x4e, 0xab, 0xd3, 0x0e, 0x32, 0x04,
-        0x22, 0x22, 0x74, 0x47, 0x7d, 0xec, 0x21, 0x99,
-        0x30, 0x31, 0x64, 0x46, 0x64, 0x9b, 0xc7, 0x13,
-        0xbf, 0xbe, 0xd0, 0x31, 0x49, 0xe7, 0x3c, 0xbf,
-        0xba, 0xb1, 0x20, 0xf9, 0x42, 0xf4, 0xa9, 0xa9,
-        0xe5, 0x13, 0x65, 0x32, 0xbf, 0x7c, 0xcc, 0x91,
-        0xd3, 0xfd, 0x24, 0x47, 0x0b, 0xe5, 0x53, 0xad,
-        0x50, 0x30, 0x56, 0xd1, 0xfa, 0x9c, 0x37, 0xa8,
-        0xc1, 0xce, 0xf6, 0x0b, 0x18, 0xaa, 0x7c, 0xab,
-        0xbd, 0x1f, 0xdf, 0xe4, 0x80, 0xb8, 0xa7, 0xe0,
-        0xad, 0x7d, 0x50, 0x74, 0xf1, 0x98, 0x78, 0xbc,
-        0x58, 0xb9, 0xc2, 0x52, 0xbe, 0xd2, 0x5b, 0x81,
-        0x94, 0x83, 0x8f, 0xb9, 0x4c, 0xee, 0x01, 0x2b,
-        0x5e, 0xc9, 0x6e, 0x9b, 0xf5, 0x63, 0x69, 0xe4,
-        0xd8, 0x0b, 0x47, 0xd8, 0xfd, 0xd8, 0xe0, 0xed,
-        0xa8, 0x27, 0x03, 0x74, 0x1e, 0x5d, 0x32, 0xe6,
-        0x5c, 0x63, 0xc2, 0xfb, 0x3f, 0xee, 0xb4, 0x13,
-        0xc6, 0x0e, 0x6e, 0x74, 0xe0, 0x22, 0xac, 0xce,
-        0x79, 0xf9, 0x43, 0x68, 0xc1, 0x03, 0x74, 0x2b,
-        0xe1, 0x18, 0xf8, 0x7f, 0x76, 0x9a, 0xea, 0x82,
-        0x3f, 0xc2, 0xa6, 0xa7, 0x4c, 0xfe, 0xae, 0x29,
-        0x3b, 0xc1, 0x10, 0x7c, 0xd5, 0x77, 0x17, 0x79,
-        0x5f, 0xcb, 0xad, 0x1f, 0xd8, 0xa1, 0xfd, 0x90,
-        0xe1, 0x6b, 0xb2, 0xef, 0xb9, 0x41, 0x26, 0xa4,
-        0x0b, 0x4f, 0xc6, 0x83, 0x05, 0x6f, 0xf0, 0x64,
-        0x40, 0xe1, 0x44, 0xc4, 0xf9, 0x40, 0x2b, 0x3b,
-        0x40, 0xdb, 0xaf, 0x35, 0xa4, 0x9b, 0x9f, 0xc4,
-        0x74, 0x07, 0xe5, 0x18, 0x60, 0xc5, 0xfe, 0x15,
-        0x0e, 0x3a, 0x25, 0x2a, 0x11, 0xee, 0x78, 0x2f,
-        0xb8, 0xd1, 0x6e, 0x4e, 0x3c, 0x0a, 0xb5, 0xb9,
-        0x40, 0x86, 0x27, 0x6d, 0x8f, 0x53, 0xb7, 0x77,
-        0x36, 0xec, 0x5d, 0xed, 0x32, 0x40, 0x43, 0x82,
-        0xc3, 0x52, 0x58, 0xc4, 0x26, 0x39, 0xf3, 0xb3,
-        0xad, 0x58, 0xab, 0xb7, 0xf7, 0x8e, 0x0e, 0xba,
-        0x8e, 0x78, 0x9d, 0xbf, 0x58, 0x34, 0xbd, 0x77,
-        0x73, 0xa6, 0x50, 0x55, 0x00, 0x60, 0x26, 0xbf,
-        0x6d, 0xb4, 0x98, 0x8a, 0x18, 0x83, 0x89, 0xf8,
-        0xcd, 0x0d, 0x49, 0x06, 0xae, 0x51, 0x6e, 0xaf,
-        0xbd, 0xe2, 0x07, 0x13, 0xd8, 0x64, 0xcc, 0xbf,
-        0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x58, 0x2e,
-        0x35, 0x30, 0x39, 0x00, 0x00, 0x02, 0x34, 0x30,
-        0x82, 0x02, 0x30, 0x30, 0x82, 0x01, 0xda, 0xa0,
-        0x03, 0x02, 0x01, 0x02, 0x02, 0x04, 0x48, 0x59,
-        0xf2, 0x84, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
-        0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05,
-        0x00, 0x30, 0x81, 0x9d, 0x31, 0x0b, 0x30, 0x09,
-        0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4b,
-        0x52, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55,
-        0x04, 0x08, 0x13, 0x0a, 0x4b, 0x79, 0x75, 0x6e,
-        0x67, 0x67, 0x69, 0x2d, 0x64, 0x6f, 0x31, 0x14,
-        0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13,
-        0x0b, 0x53, 0x65, 0x6f, 0x6e, 0x67, 0x6e, 0x61,
-        0x6d, 0x2d, 0x73, 0x69, 0x31, 0x1a, 0x30, 0x18,
-        0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x11, 0x54,
-        0x68, 0x65, 0x20, 0x4e, 0x65, 0x74, 0x74, 0x79,
-        0x20, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74,
-        0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04,
-        0x0b, 0x13, 0x0c, 0x43, 0x6f, 0x6e, 0x74, 0x72,
-        0x69, 0x62, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x31,
-        0x30, 0x30, 0x2e, 0x06, 0x03, 0x55, 0x04, 0x03,
-        0x13, 0x27, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65,
-        0x63, 0x68, 0x61, 0x74, 0x2e, 0x65, 0x78, 0x61,
-        0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x6e, 0x65, 0x74,
-        0x74, 0x79, 0x2e, 0x67, 0x6c, 0x65, 0x61, 0x6d,
-        0x79, 0x6e, 0x6f, 0x64, 0x65, 0x2e, 0x6e, 0x65,
-        0x74, 0x30, 0x20, 0x17, 0x0d, 0x30, 0x38, 0x30,
-        0x36, 0x31, 0x39, 0x30, 0x35, 0x34, 0x35, 0x34,
-        0x30, 0x5a, 0x18, 0x0f, 0x32, 0x31, 0x38, 0x37,
-        0x31, 0x31, 0x32, 0x33, 0x30, 0x35, 0x34, 0x35,
-        0x34, 0x30, 0x5a, 0x30, 0x81, 0x9d, 0x31, 0x0b,
-        0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
-        0x02, 0x4b, 0x52, 0x31, 0x13, 0x30, 0x11, 0x06,
-        0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x4b, 0x79,
-        0x75, 0x6e, 0x67, 0x67, 0x69, 0x2d, 0x64, 0x6f,
-        0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04,
-        0x07, 0x13, 0x0b, 0x53, 0x65, 0x6f, 0x6e, 0x67,
-        0x6e, 0x61, 0x6d, 0x2d, 0x73, 0x69, 0x31, 0x1a,
-        0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,
-        0x11, 0x54, 0x68, 0x65, 0x20, 0x4e, 0x65, 0x74,
-        0x74, 0x79, 0x20, 0x50, 0x72, 0x6f, 0x6a, 0x65,
-        0x63, 0x74, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03,
-        0x55, 0x04, 0x0b, 0x13, 0x0c, 0x43, 0x6f, 0x6e,
-        0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x6f, 0x72,
-        0x73, 0x31, 0x30, 0x30, 0x2e, 0x06, 0x03, 0x55,
-        0x04, 0x03, 0x13, 0x27, 0x73, 0x65, 0x63, 0x75,
-        0x72, 0x65, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x65,
-        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x6e,
-        0x65, 0x74, 0x74, 0x79, 0x2e, 0x67, 0x6c, 0x65,
-        0x61, 0x6d, 0x79, 0x6e, 0x6f, 0x64, 0x65, 0x2e,
-        0x6e, 0x65, 0x74, 0x30, 0x5c, 0x30, 0x0d, 0x06,
-        0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
-        0x01, 0x01, 0x05, 0x00, 0x03, 0x4b, 0x00, 0x30,
-        0x48, 0x02, 0x41, 0x00, 0x95, 0xb3, 0x47, 0x17,
-        0x95, 0x0f, 0x57, 0xcf, 0x66, 0x72, 0x0a, 0x7e,
-        0x5b, 0x54, 0xea, 0x8c, 0x6f, 0x79, 0xde, 0x94,
-        0xac, 0x0b, 0x5a, 0xd4, 0xd6, 0x1b, 0x58, 0x12,
-        0x1a, 0x16, 0x3d, 0xfe, 0xdf, 0xa5, 0x2b, 0x86,
-        0xbc, 0x64, 0xd4, 0x80, 0x1e, 0x3f, 0xf9, 0xe2,
-        0x04, 0x03, 0x79, 0x9b, 0xc1, 0x5c, 0xf0, 0xf1,
-        0xf3, 0xf1, 0xe3, 0xbf, 0x3f, 0xc0, 0x1f, 0xdd,
-        0xdb, 0xc0, 0x5b, 0x21, 0x02, 0x03, 0x01, 0x00,
-        0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
-        0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00,
-        0x03, 0x41, 0x00, 0x02, 0xd7, 0xdd, 0xbd, 0x0c,
-        0x8e, 0x21, 0x20, 0xef, 0x9e, 0x4f, 0x1f, 0xf5,
-        0x49, 0xf1, 0xae, 0x58, 0x9b, 0x94, 0x3a, 0x1f,
-        0x70, 0x33, 0xf0, 0x9b, 0xbb, 0xe9, 0xc0, 0xf3,
-        0x72, 0xcb, 0xde, 0xb6, 0x56, 0x72, 0xcc, 0x1c,
-        0xf0, 0xd6, 0x5a, 0x2a, 0xbc, 0xa1, 0x7e, 0x23,
-        0x83, 0xe9, 0xe7, 0xcf, 0x9e, 0xa5, 0xf9, 0xcc,
-        0xc2, 0x61, 0xf4, 0xdb, 0x40, 0x93, 0x1d, 0x63,
-        0x8a, 0x50, 0x4c, 0x11, 0x39, 0xb1, 0x91, 0xc1,
-        0xe6, 0x9d, 0xd9, 0x1a, 0x62, 0x1b, 0xb8, 0xd3,
-        0xd6, 0x9a, 0x6d, 0xb9, 0x8e, 0x15, 0x51 };
-
-    public static InputStream asInputStream() {
-        byte[] data = new byte[DATA.length];
-        for (int i = 0; i < data.length; i ++) {
-            data[i] = (byte) DATA[i];
-        }
-        return new ByteArrayInputStream(data);
-    }
-
-    public static char[] getCertificatePassword() {
-        return "secret".toCharArray();
-    }
-
-    public static char[] getKeyStorePassword() {
-        return "secret".toCharArray();
-    }
-
-    private SecureChatKeyStore() {
-        // Unused
-    }
-}
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatServer.java b/example/src/main/java/io/netty/example/securechat/SecureChatServer.java
index 14de0d482796..072624609809 100644
--- a/example/src/main/java/io/netty/example/securechat/SecureChatServer.java
+++ b/example/src/main/java/io/netty/example/securechat/SecureChatServer.java
@@ -20,41 +20,35 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.example.telnet.TelnetServer;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * Simple SSL chat server modified from {@link TelnetServer}.
  */
-public class SecureChatServer {
+public final class SecureChatServer {
 
-    private final int port;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8992"));
 
-    public SecureChatServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        SelfSignedCertificate ssc = new SelfSignedCertificate();
+        SslContext sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
 
-    public void run() throws InterruptedException {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new SecureChatServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new SecureChatServerInitializer(sslCtx));
 
-            b.bind(port).sync().channel().closeFuture().sync();
+            b.bind(PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8443;
-        }
-        new SecureChatServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
index 0e599fbaf277..a40e1644f7d0 100644
--- a/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
+++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
@@ -26,37 +26,31 @@
 import io.netty.util.concurrent.GlobalEventExecutor;
 
 import java.net.InetAddress;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * Handles a server-side channel.
  */
 public class SecureChatServerHandler extends SimpleChannelInboundHandler<String> {
 
-    private static final Logger logger = Logger.getLogger(
-            SecureChatServerHandler.class.getName());
-
     static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
 
     @Override
-    public void channelActive(final ChannelHandlerContext ctx) throws Exception {
+    public void channelActive(final ChannelHandlerContext ctx) {
         // Once session is secured, send a greeting and register the channel to the global channel
         // list so the channel received the messages from others.
         ctx.pipeline().get(SslHandler.class).handshakeFuture().addListener(
                 new GenericFutureListener<Future<Channel>>() {
-            @Override
-            public void operationComplete(Future<Channel> future) throws Exception {
-                ctx.writeAndFlush(
-                        "Welcome to " + InetAddress.getLocalHost().getHostName() +
-                        " secure chat service!\n");
-                ctx.writeAndFlush(
-                        "Your session is protected by " +
-                        ctx.pipeline().get(SslHandler.class).engine().getSession().getCipherSuite() +
-                        " cipher suite.\n");
+                    @Override
+                    public void operationComplete(Future<Channel> future) throws Exception {
+                        ctx.writeAndFlush(
+                                "Welcome to " + InetAddress.getLocalHost().getHostName() + " secure chat service!\n");
+                        ctx.writeAndFlush(
+                                "Your session is protected by " +
+                                        ctx.pipeline().get(SslHandler.class).engine().getSession().getCipherSuite() +
+                                        " cipher suite.\n");
 
-                channels.add(ctx.channel());
-            }
+                        channels.add(ctx.channel());
+                    }
         });
     }
 
@@ -65,8 +59,7 @@ public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception
         // Send the received message to all channels but the current one.
         for (Channel c: channels) {
             if (c != ctx.channel()) {
-                c.writeAndFlush("[" + ctx.channel().remoteAddress() + "] " +
-                        msg + '\n');
+                c.writeAndFlush("[" + ctx.channel().remoteAddress() + "] " + msg + '\n');
             } else {
                 c.writeAndFlush("[you] " + msg + '\n');
             }
@@ -79,10 +72,8 @@ public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatServerInitializer.java b/example/src/main/java/io/netty/example/securechat/SecureChatServerInitializer.java
index f089a4f4f8d1..7a3d27ca3aa8 100644
--- a/example/src/main/java/io/netty/example/securechat/SecureChatServerInitializer.java
+++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerInitializer.java
@@ -22,15 +22,19 @@
 import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
-import io.netty.handler.ssl.SslHandler;
-
-import javax.net.ssl.SSLEngine;
+import io.netty.handler.ssl.SslContext;
 
 /**
  * Creates a newly configured {@link ChannelPipeline} for a new channel.
  */
 public class SecureChatServerInitializer extends ChannelInitializer<SocketChannel> {
 
+    private final SslContext sslCtx;
+
+    public SecureChatServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
+
     @Override
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline pipeline = ch.pipeline();
@@ -40,23 +44,14 @@ public void initChannel(SocketChannel ch) throws Exception {
         // and accept any invalid certificates in the client side.
         // You will need something more complicated to identify both
         // and server in the real world.
-        //
-        // Read SecureChatSslContextFactory
-        // if you need client certificate authentication.
-
-        SSLEngine engine =
-            SecureChatSslContextFactory.getServerContext().createSSLEngine();
-        engine.setUseClientMode(false);
-
-        pipeline.addLast("ssl", new SslHandler(engine));
+        pipeline.addLast(sslCtx.newHandler(ch.alloc()));
 
         // On top of the SSL handler, add the text line codec.
-        pipeline.addLast("framer", new DelimiterBasedFrameDecoder(
-                8192, Delimiters.lineDelimiter()));
-        pipeline.addLast("decoder", new StringDecoder());
-        pipeline.addLast("encoder", new StringEncoder());
+        pipeline.addLast(new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()));
+        pipeline.addLast(new StringDecoder());
+        pipeline.addLast(new StringEncoder());
 
         // and then business logic.
-        pipeline.addLast("handler", new SecureChatServerHandler());
+        pipeline.addLast(new SecureChatServerHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatSslContextFactory.java b/example/src/main/java/io/netty/example/securechat/SecureChatSslContextFactory.java
deleted file mode 100644
index 37a57f2261a3..000000000000
--- a/example/src/main/java/io/netty/example/securechat/SecureChatSslContextFactory.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.securechat;
-
-import io.netty.handler.ssl.SslHandler;
-
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.Security;
-
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.TrustManager;
-
-/**
- * Creates a bogus {@link SSLContext}.  A client-side context created by this
- * factory accepts any certificate even if it is invalid.  A server-side context
- * created by this factory sends a bogus certificate defined in {@link SecureChatKeyStore}.
- * <p>
- * You will have to create your context differently in a real world application.
- *
- * <h3>Client Certificate Authentication</h3>
- *
- * To enable client certificate authentication:
- * <ul>
- * <li>Enable client authentication on the server side by calling
- *     {@link SSLEngine#setNeedClientAuth(boolean)} before creating
- *     {@link SslHandler}.</li>
- * <li>When initializing an {@link SSLContext} on the client side,
- *     specify the {@link KeyManager} that contains the client certificate as
- *     the first argument of {@link SSLContext#init(KeyManager[], TrustManager[], SecureRandom)}.</li>
- * <li>When initializing an {@link SSLContext} on the server side,
- *     specify the proper {@link TrustManager} as the second argument of
- *     {@link SSLContext#init(KeyManager[], TrustManager[], SecureRandom)}
- *     to validate the client certificate.</li>
- * </ul>
- */
-public final class SecureChatSslContextFactory {
-
-    private static final String PROTOCOL = "TLS";
-    private static final SSLContext SERVER_CONTEXT;
-    private static final SSLContext CLIENT_CONTEXT;
-
-    static {
-        String algorithm = Security.getProperty("ssl.KeyManagerFactory.algorithm");
-        if (algorithm == null) {
-            algorithm = "SunX509";
-        }
-
-        SSLContext serverContext;
-        SSLContext clientContext;
-        try {
-            KeyStore ks = KeyStore.getInstance("JKS");
-            ks.load(SecureChatKeyStore.asInputStream(),
-                    SecureChatKeyStore.getKeyStorePassword());
-
-            // Set up key manager factory to use our key store
-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
-            kmf.init(ks, SecureChatKeyStore.getCertificatePassword());
-
-            // Initialize the SSLContext to work with our key managers.
-            serverContext = SSLContext.getInstance(PROTOCOL);
-            serverContext.init(kmf.getKeyManagers(), null, null);
-        } catch (Exception e) {
-            throw new Error(
-                    "Failed to initialize the server-side SSLContext", e);
-        }
-
-        try {
-            clientContext = SSLContext.getInstance(PROTOCOL);
-            clientContext.init(null, SecureChatTrustManagerFactory.getTrustManagers(), null);
-        } catch (Exception e) {
-            throw new Error(
-                    "Failed to initialize the client-side SSLContext", e);
-        }
-
-        SERVER_CONTEXT = serverContext;
-        CLIENT_CONTEXT = clientContext;
-    }
-
-    public static SSLContext getServerContext() {
-        return SERVER_CONTEXT;
-    }
-
-    public static SSLContext getClientContext() {
-        return CLIENT_CONTEXT;
-    }
-
-    private SecureChatSslContextFactory() {
-        // Unused
-    }
-}
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatTrustManagerFactory.java b/example/src/main/java/io/netty/example/securechat/SecureChatTrustManagerFactory.java
deleted file mode 100644
index 28dafea70f6f..000000000000
--- a/example/src/main/java/io/netty/example/securechat/SecureChatTrustManagerFactory.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.securechat;
-
-import javax.net.ssl.ManagerFactoryParameters;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactorySpi;
-import javax.net.ssl.X509TrustManager;
-import java.security.InvalidAlgorithmParameterException;
-import java.security.KeyStore;
-import java.security.KeyStoreException;
-import java.security.cert.X509Certificate;
-
-/**
- * Bogus {@link TrustManagerFactorySpi} which accepts any certificate
- * even if it is invalid.
- */
-public class SecureChatTrustManagerFactory extends TrustManagerFactorySpi {
-
-    private static final TrustManager DUMMY_TRUST_MANAGER = new X509TrustManager() {
-        @Override
-        public X509Certificate[] getAcceptedIssuers() {
-            return new X509Certificate[0];
-        }
-
-        @Override
-        public void checkClientTrusted(X509Certificate[] chain, String authType) {
-            // Always trust - it is an example.
-            // You should do something in the real world.
-            // You will reach here only if you enabled client certificate auth,
-            // as described in SecureChatSslContextFactory.
-            System.err.println(
-                    "UNKNOWN CLIENT CERTIFICATE: " + chain[0].getSubjectDN());
-        }
-
-        @Override
-        public void checkServerTrusted(X509Certificate[] chain, String authType) {
-            // Always trust - it is an example.
-            // You should do something in the real world.
-            System.err.println(
-                    "UNKNOWN SERVER CERTIFICATE: " + chain[0].getSubjectDN());
-        }
-    };
-
-    public static TrustManager[] getTrustManagers() {
-        return new TrustManager[] { DUMMY_TRUST_MANAGER };
-    }
-
-    @Override
-    protected TrustManager[] engineGetTrustManagers() {
-        return getTrustManagers();
-    }
-
-    @Override
-    protected void engineInit(KeyStore keystore) throws KeyStoreException {
-        // Unused
-    }
-
-    @Override
-    protected void engineInit(ManagerFactoryParameters managerFactoryParameters)
-            throws InvalidAlgorithmParameterException {
-        // Unused
-    }
-}
diff --git a/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java b/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java
index 4c41916ed149..c143495989ba 100644
--- a/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java
@@ -15,20 +15,16 @@
  */
 package io.netty.example.socksproxy;
 
+import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.util.concurrent.Promise;
 
-
 public final class DirectClientHandler extends ChannelInboundHandlerAdapter {
-    private static final String name = "DIRECT_CLIENT_HANDLER";
 
-    public static String getName() {
-        return name;
-    }
-    private final Promise promise;
+    private final Promise<Channel> promise;
 
-    public DirectClientHandler(Promise promise) {
+    public DirectClientHandler(Promise<Channel> promise) {
         this.promise = promise;
     }
 
@@ -39,7 +35,7 @@ public void channelActive(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable throwable) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable throwable) {
         promise.setFailure(throwable);
     }
 }
diff --git a/example/src/main/java/io/netty/example/socksproxy/DirectClientInitializer.java b/example/src/main/java/io/netty/example/socksproxy/DirectClientInitializer.java
deleted file mode 100644
index c4d1bc818636..000000000000
--- a/example/src/main/java/io/netty/example/socksproxy/DirectClientInitializer.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.socksproxy;
-
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.util.concurrent.Promise;
-
-
-public final class DirectClientInitializer extends ChannelInitializer<SocketChannel> {
-
-    private final Promise promise;
-
-    public DirectClientInitializer(Promise promise) {
-        this.promise = promise;
-    }
-
-    @Override
-    public void initChannel(SocketChannel socketChannel) throws Exception {
-        ChannelPipeline channelPipeline = socketChannel.pipeline();
-        channelPipeline.addLast(DirectClientHandler.getName(), new DirectClientHandler(promise));
-    }
-}
diff --git a/example/src/main/java/io/netty/example/socksproxy/RelayHandler.java b/example/src/main/java/io/netty/example/socksproxy/RelayHandler.java
index b50fe7875796..f353802a392f 100644
--- a/example/src/main/java/io/netty/example/socksproxy/RelayHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/RelayHandler.java
@@ -21,13 +21,7 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.util.ReferenceCountUtil;
 
-
 public final class RelayHandler extends ChannelInboundHandlerAdapter {
-    private static final String name = "RELAY_HANDLER";
-
-    public static String getName() {
-        return name;
-    }
 
     private final Channel relayChannel;
 
@@ -36,12 +30,12 @@ public RelayHandler(Channel relayChannel) {
     }
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+    public void channelActive(ChannelHandlerContext ctx) {
         ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         if (relayChannel.isActive()) {
             relayChannel.writeAndFlush(msg);
         } else {
@@ -50,16 +44,15 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) {
         if (relayChannel.isActive()) {
             SocksServerUtils.closeOnFlush(relayChannel);
         }
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }
-
 }
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServer.java b/example/src/main/java/io/netty/example/socksproxy/SocksServer.java
index d196a1476278..2d6ee8ccc60f 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServer.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServer.java
@@ -19,32 +19,26 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
 
 public final class SocksServer {
-    private final int localPort;
 
-    public SocksServer(int localPort) {
-        this.localPort = localPort;
-    }
+    static final int PORT = Integer.parseInt(System.getProperty("port", "1080"));
 
-    public void run() throws Exception {
-        System.err.println(
-                "Listening on*:" + localPort + "...");
+    public static void main(String[] args) throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
+             .handler(new LoggingHandler(LogLevel.INFO))
              .childHandler(new SocksServerInitializer());
-            b.bind(localPort).sync().channel().closeFuture().sync();
+            b.bind(PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        new SocksServer(1080).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
index 647fbecce717..46428e461cf2 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
@@ -33,11 +33,6 @@
 
 @ChannelHandler.Sharable
 public final class SocksServerConnectHandler extends SimpleChannelInboundHandler<SocksCmdRequest> {
-    private static final String name = "SOCKS_SERVER_CONNECT_HANDLER";
-
-    public static String getName() {
-        return name;
-    }
 
     private final Bootstrap b = new Bootstrap();
 
@@ -53,10 +48,10 @@ public void operationComplete(final Future<Channel> future) throws Exception {
                     ctx.channel().writeAndFlush(new SocksCmdResponse(SocksCmdStatus.SUCCESS, request.addressType()))
                             .addListener(new ChannelFutureListener() {
                                 @Override
-                                public void operationComplete(ChannelFuture channelFuture) throws Exception {
-                                    ctx.pipeline().remove(getName());
+                                public void operationComplete(ChannelFuture channelFuture) {
+                                    ctx.pipeline().remove(SocksServerConnectHandler.this);
                                     outboundChannel.pipeline().addLast(new RelayHandler(ctx.channel()));
-                                    ctx.channel().pipeline().addLast(new RelayHandler(outboundChannel));
+                                    ctx.pipeline().addLast(new RelayHandler(outboundChannel));
                                 }
                             });
                 } else {
@@ -67,25 +62,26 @@ public void operationComplete(ChannelFuture channelFuture) throws Exception {
         });
 
         final Channel inboundChannel = ctx.channel();
+
         b.group(inboundChannel.eventLoop())
                 .channel(NioSocketChannel.class)
                 .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)
                 .option(ChannelOption.SO_KEEPALIVE, true)
-                .handler(new DirectClientInitializer(promise));
-        b.connect(request.host(), request.port())
-          .addListener(new ChannelFutureListener() {
-                @Override
-                public void operationComplete(ChannelFuture future) throws Exception {
-                    if (future.isSuccess()) {
-                        // Connection established use handler provided results
-                    } else {
-                        // Close the connection if the connection attempt has failed.
-                        ctx.channel().writeAndFlush(
-                                new SocksCmdResponse(SocksCmdStatus.FAILURE, request.addressType()));
-                        SocksServerUtils.closeOnFlush(ctx.channel());
-                    }
+                .handler(new DirectClientHandler(promise));
+
+        b.connect(request.host(), request.port()).addListener(new ChannelFutureListener() {
+            @Override
+            public void operationComplete(ChannelFuture future) throws Exception {
+                if (future.isSuccess()) {
+                    // Connection established use handler provided results
+                } else {
+                    // Close the connection if the connection attempt has failed.
+                    ctx.channel().writeAndFlush(
+                            new SocksCmdResponse(SocksCmdStatus.FAILURE, request.addressType()));
+                    SocksServerUtils.closeOnFlush(ctx.channel());
                 }
-           });
+            }
+        });
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
index 056d34230342..df71ce3ca834 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
@@ -30,31 +30,26 @@
 
 @ChannelHandler.Sharable
 public final class SocksServerHandler extends SimpleChannelInboundHandler<SocksRequest> {
-    private static final String name = "SOCKS_SERVER_HANDLER";
-
-    public static String getName() {
-        return name;
-    }
 
     @Override
     public void channelRead0(ChannelHandlerContext ctx, SocksRequest socksRequest) throws Exception {
         switch (socksRequest.requestType()) {
             case INIT: {
-//                auth support example
-//                ctx.pipeline().addFirst("socksAuthRequestDecoder",new SocksAuthRequestDecoder());
-//                ctx.write(new SocksInitResponse(SocksMessage.SocksAuthScheme.AUTH_PASSWORD));
-                ctx.pipeline().addFirst(SocksCmdRequestDecoder.getName(), new SocksCmdRequestDecoder());
+                // auth support example
+                //ctx.pipeline().addFirst(new SocksAuthRequestDecoder());
+                //ctx.write(new SocksInitResponse(SocksAuthScheme.AUTH_PASSWORD));
+                ctx.pipeline().addFirst(new SocksCmdRequestDecoder());
                 ctx.write(new SocksInitResponse(SocksAuthScheme.NO_AUTH));
                 break;
             }
             case AUTH:
-                ctx.pipeline().addFirst(SocksCmdRequestDecoder.getName(), new SocksCmdRequestDecoder());
+                ctx.pipeline().addFirst(new SocksCmdRequestDecoder());
                 ctx.write(new SocksAuthResponse(SocksAuthStatus.SUCCESS));
                 break;
             case CMD:
                 SocksCmdRequest req = (SocksCmdRequest) socksRequest;
                 if (req.cmdType() == SocksCmdType.CONNECT) {
-                    ctx.pipeline().addLast(SocksServerConnectHandler.getName(), new SocksServerConnectHandler());
+                    ctx.pipeline().addLast(new SocksServerConnectHandler());
                     ctx.pipeline().remove(this);
                     ctx.fireChannelRead(socksRequest);
                 } else {
@@ -68,12 +63,12 @@ public void channelRead0(ChannelHandlerContext ctx, SocksRequest socksRequest) t
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable throwable) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable throwable) {
         throwable.printStackTrace();
         SocksServerUtils.closeOnFlush(ctx.channel());
     }
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServerInitializer.java b/example/src/main/java/io/netty/example/socksproxy/SocksServerInitializer.java
index 8649de66a01d..7b544d74bfbc 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServerInitializer.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerInitializer.java
@@ -22,14 +22,15 @@
 import io.netty.handler.codec.socks.SocksMessageEncoder;
 
 public final class SocksServerInitializer extends ChannelInitializer<SocketChannel> {
+
     private final SocksMessageEncoder socksMessageEncoder = new SocksMessageEncoder();
     private final SocksServerHandler socksServerHandler = new SocksServerHandler();
 
     @Override
     public void initChannel(SocketChannel socketChannel) throws Exception {
-        ChannelPipeline channelPipeline = socketChannel.pipeline();
-        channelPipeline.addLast(SocksInitRequestDecoder.getName(), new SocksInitRequestDecoder());
-        channelPipeline.addLast(SocksMessageEncoder.getName(), socksMessageEncoder);
-        channelPipeline.addLast(SocksServerHandler.getName(), socksServerHandler);
+        ChannelPipeline p = socketChannel.pipeline();
+        p.addLast(new SocksInitRequestDecoder());
+        p.addLast(socksMessageEncoder);
+        p.addLast(socksServerHandler);
     }
 }
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java b/example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java
index 97195432317e..b9e7226309d5 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java
@@ -21,10 +21,6 @@
 
 public final class SocksServerUtils {
 
-    private SocksServerUtils() {
-        //NOOP
-    }
-
     /**
      * Closes the specified channel after all queued write requests are flushed.
      */
@@ -33,4 +29,6 @@ public static void closeOnFlush(Channel ch) {
             ch.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
         }
     }
+
+    private SocksServerUtils() { }
 }
diff --git a/example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java b/example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java
index 29fb74b4b046..a6e3da284f54 100644
--- a/example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java
+++ b/example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java
@@ -42,8 +42,8 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
         if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
 
-            System.out.println("STATUS: " + response.getStatus());
-            System.out.println("VERSION: " + response.getProtocolVersion());
+            System.out.println("STATUS: " + response.status());
+            System.out.println("VERSION: " + response.protocolVersion());
             System.out.println();
 
             if (!response.headers().isEmpty()) {
@@ -75,7 +75,7 @@ public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Excep
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         queue.add(ctx.channel().newFailedFuture(cause));
         cause.printStackTrace();
         ctx.close();
@@ -84,5 +84,4 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     public BlockingQueue<ChannelFuture> queue() {
         return queue;
     }
-
 }
diff --git a/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
index e334cd467379..bccbe9e560f0 100644
--- a/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
+++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
@@ -17,7 +17,6 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
@@ -27,11 +26,11 @@
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.spdy.SpdyOrHttpChooser.SelectedProtocol;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
-import java.net.InetSocketAddress;
-import java.util.concurrent.BlockingQueue;
-
-import static java.util.concurrent.TimeUnit.*;
+import java.util.Arrays;
 
 /**
  * An SPDY client that allows you to send HTTP GET to a SPDY server.
@@ -41,47 +40,51 @@
  * coordinates org.mortbay.jetty.npn:npn-boot. Different versions applies to different OpenJDK versions. See
  * <a href="http://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty docs</a> for more information.
  * <p>
- * You may also use maven to start the client from the command line:
+ * You may also use the {@code run-example.sh} script to start the client from the command line:
  * <pre>
- *     mvn exec:exec -Pspdy-client
+ *     ./run-example.sh spdy-client
  * </pre>
  */
-public class SpdyClient {
+public final class SpdyClient {
 
-    private final String host;
-    private final int port;
-    private final HttpResponseClientHandler httpResponseHandler;
-    private Channel channel;
-    private EventLoopGroup workerGroup;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8443" : "8080"));
 
-    public SpdyClient(String host, int port) {
-        this.host = host;
-        this.port = port;
-        httpResponseHandler = new HttpResponseClientHandler();
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx = SslContext.newClientContext(
+                null, InsecureTrustManagerFactory.INSTANCE, null,
+                Arrays.asList(SelectedProtocol.SPDY_3_1.protocolName(), SelectedProtocol.HTTP_1_1.protocolName()),
+                0, 0);
 
-    public void start() {
-        if (channel != null) {
-            System.out.println("Already running!");
-            return;
-        }
+        HttpResponseClientHandler httpResponseHandler = new HttpResponseClientHandler();
+        EventLoopGroup workerGroup = new NioEventLoopGroup();
 
-        workerGroup = new NioEventLoopGroup();
+        try {
+            Bootstrap b = new Bootstrap();
+            b.group(workerGroup);
+            b.channel(NioSocketChannel.class);
+            b.option(ChannelOption.SO_KEEPALIVE, true);
+            b.remoteAddress(HOST, PORT);
+            b.handler(new SpdyClientInitializer(sslCtx, httpResponseHandler));
 
-        Bootstrap b = new Bootstrap();
-        b.group(workerGroup);
-        b.channel(NioSocketChannel.class);
-        b.option(ChannelOption.SO_KEEPALIVE, true);
-        b.remoteAddress(new InetSocketAddress(host, port));
-        b.handler(new SpdyClientInitializer(httpResponseHandler));
+            // Start the client.
+            Channel channel = b.connect().syncUninterruptibly().channel();
+            System.out.println("Connected to " + HOST + ':' + PORT);
 
-        // Start the client.
-        channel = b.connect().syncUninterruptibly().channel();
-        System.out.println("Connected to [" + host + ':' + port + ']');
-    }
+            // Create a GET request.
+            HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "");
+            request.headers().set(HttpHeaders.Names.HOST, HOST);
+            request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+
+            // Send the GET request.
+            channel.writeAndFlush(request).sync();
+
+            // Waits for the complete HTTP response
+            httpResponseHandler.queue().take().sync();
+            System.out.println("Finished SPDY HTTP GET");
 
-    public void stop() {
-        try {
             // Wait until the connection is closed.
             channel.close().syncUninterruptibly();
         } finally {
@@ -90,51 +93,4 @@ public void stop() {
             }
         }
     }
-
-    public ChannelFuture send(HttpRequest request) {
-        // Sends the HTTP request.
-        return channel.writeAndFlush(request);
-    }
-
-    public HttpRequest get() {
-        HttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "");
-        request.headers().set(HttpHeaders.Names.HOST, host);
-        request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
-        return request;
-    }
-
-    public BlockingQueue<ChannelFuture> httpResponseQueue() {
-        return httpResponseHandler.queue();
-    }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8443;
-        }
-
-        final SpdyClient client = new SpdyClient("localhost", port);
-
-        try {
-            client.start();
-            ChannelFuture requestFuture = client.send(client.get()).sync();
-
-            if (!requestFuture.isSuccess()) {
-                requestFuture.cause().printStackTrace();
-            }
-
-            // Waits for the complete HTTP response
-            ChannelFuture responseFuture = client.httpResponseQueue().poll(5, SECONDS);
-
-            if (!responseFuture.isSuccess()) {
-                responseFuture.cause().printStackTrace();
-            }
-
-            System.out.println("Finished SPDY HTTP GET");
-        } finally {
-            client.stop();
-        }
-    }
 }
diff --git a/example/src/main/java/io/netty/example/spdy/client/SpdyClientInitializer.java b/example/src/main/java/io/netty/example/spdy/client/SpdyClientInitializer.java
index 545cedb19352..931f415531ec 100644
--- a/example/src/main/java/io/netty/example/spdy/client/SpdyClientInitializer.java
+++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClientInitializer.java
@@ -18,42 +18,32 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.example.securechat.SecureChatSslContextFactory;
-import io.netty.handler.codec.spdy.SpdyFrameDecoder;
-import io.netty.handler.codec.spdy.SpdyFrameEncoder;
+import io.netty.handler.codec.spdy.SpdyFrameCodec;
 import io.netty.handler.codec.spdy.SpdyHttpDecoder;
 import io.netty.handler.codec.spdy.SpdyHttpEncoder;
 import io.netty.handler.codec.spdy.SpdySessionHandler;
-import io.netty.handler.ssl.SslHandler;
-import org.eclipse.jetty.npn.NextProtoNego;
-
-import javax.net.ssl.SSLEngine;
+import io.netty.handler.ssl.SslContext;
 
 import static io.netty.handler.codec.spdy.SpdyVersion.*;
 import static io.netty.util.internal.logging.InternalLogLevel.*;
 
 public class SpdyClientInitializer extends ChannelInitializer<SocketChannel> {
 
+    private static final int MAX_SPDY_CONTENT_LENGTH = 1024 * 1024; // 1 MB
+
+    private final SslContext sslCtx;
     private final HttpResponseClientHandler httpResponseHandler;
 
-    public SpdyClientInitializer(HttpResponseClientHandler httpResponseHandler) {
+    public SpdyClientInitializer(SslContext sslCtx, HttpResponseClientHandler httpResponseHandler) {
+        this.sslCtx = sslCtx;
         this.httpResponseHandler = httpResponseHandler;
     }
 
-    private static final int MAX_SPDY_CONTENT_LENGTH = 1024 * 1024; // 1 MB
-
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        SSLEngine engine = SecureChatSslContextFactory.getClientContext().createSSLEngine();
-        engine.setUseClientMode(true);
-        NextProtoNego.put(engine, new SpdyClientProvider());
-        NextProtoNego.debug = true;
-
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
-
-        pipeline.addLast("ssl", new SslHandler(engine));
-        pipeline.addLast("spdyEncoder", new SpdyFrameEncoder(SPDY_3_1));
-        pipeline.addLast("spdyDecoder", new SpdyFrameDecoder(SPDY_3_1));
+        pipeline.addLast("ssl", sslCtx.newHandler(ch.alloc()));
+        pipeline.addLast("spdyFrameCodec", new SpdyFrameCodec(SPDY_3_1));
         pipeline.addLast("spdyFrameLogger", new SpdyFrameLogger(INFO));
         pipeline.addLast("spdySessionHandler", new SpdySessionHandler(SPDY_3_1, false));
         pipeline.addLast("spdyHttpEncoder", new SpdyHttpEncoder(SPDY_3_1));
diff --git a/example/src/main/java/io/netty/example/spdy/client/SpdyClientProvider.java b/example/src/main/java/io/netty/example/spdy/client/SpdyClientProvider.java
deleted file mode 100644
index c4adedf39b15..000000000000
--- a/example/src/main/java/io/netty/example/spdy/client/SpdyClientProvider.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright 2014 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.spdy.client;
-
-import org.eclipse.jetty.npn.NextProtoNego.ClientProvider;
-
-import java.util.List;
-
-import static io.netty.handler.codec.spdy.SpdyOrHttpChooser.SelectedProtocol.*;
-
-/**
- * The Jetty project provides an implementation of the Transport Layer Security (TLS) extension for Next Protocol
- * Negotiation (NPN) for OpenJDK 7 or greater. NPN allows the application layer to negotiate which protocol to use
- * over the secure connection.
- * <p>
- * This NPN service provider negotiates using SPDY.
- * <p>
- * To enable NPN support, start the JVM with: {@code java -Xbootclasspath/p:<path_to_npn_boot_jar> ...}. The
- * "path_to_npn_boot_jar" is the path on the file system for the NPN Boot Jar file which can be downloaded from Maven
- * at coordinates org.mortbay.jetty.npn:npn-boot. Different versions applies to different OpenJDK versions.
- *
- * @see <a href="http://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty documentation</a>
- */
-public class SpdyClientProvider implements ClientProvider {
-
-    private String selectedProtocol;
-
-    @Override
-    public String selectProtocol(List<String> protocols) {
-        if (protocols.contains(SPDY_3_1.protocolName())) {
-            return SPDY_3_1.protocolName();
-        }
-        return selectedProtocol;
-    }
-
-    @Override
-    public boolean supports() {
-        return true;
-    }
-
-    @Override
-    public void unsupported() {
-        selectedProtocol = HTTP_1_1.protocolName();
-    }
-}
diff --git a/example/src/main/java/io/netty/example/spdy/client/SpdyClientStreamIdHandler.java b/example/src/main/java/io/netty/example/spdy/client/SpdyClientStreamIdHandler.java
index 32c7ccbc9461..a1eaefdd4106 100644
--- a/example/src/main/java/io/netty/example/spdy/client/SpdyClientStreamIdHandler.java
+++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClientStreamIdHandler.java
@@ -18,8 +18,10 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMessage;
 import io.netty.handler.codec.spdy.SpdyHttpHeaders;
+import io.netty.handler.codec.spdy.SpdyHttpHeaders.Names;
 
 /**
  * Adds a unique client stream ID to the SPDY header. Client stream IDs MUST be odd.
@@ -28,20 +30,20 @@ public class SpdyClientStreamIdHandler extends ChannelOutboundHandlerAdapter {
 
     private int currentStreamId = 1;
 
-    public boolean acceptOutboundMessage(Object msg) throws Exception {
+    public boolean acceptOutboundMessage(Object msg) {
         return msg instanceof HttpMessage;
     }
 
     @Override
-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
         if (acceptOutboundMessage(msg)) {
             HttpMessage httpMsg = (HttpMessage) msg;
             if (!httpMsg.headers().contains(SpdyHttpHeaders.Names.STREAM_ID)) {
-                SpdyHttpHeaders.setStreamId(httpMsg, currentStreamId);
+                HttpHeaders.setIntHeader(httpMsg, Names.STREAM_ID, currentStreamId);
                 // Client stream IDs are always odd
                 currentStreamId += 2;
             }
         }
-        super.write(ctx, msg, promise);
+        ctx.write(msg, promise);
     }
 }
diff --git a/example/src/main/java/io/netty/example/spdy/client/SpdyFrameLogger.java b/example/src/main/java/io/netty/example/spdy/client/SpdyFrameLogger.java
index fd59242180d6..b9a58b901af5 100644
--- a/example/src/main/java/io/netty/example/spdy/client/SpdyFrameLogger.java
+++ b/example/src/main/java/io/netty/example/spdy/client/SpdyFrameLogger.java
@@ -45,22 +45,22 @@ public SpdyFrameLogger(InternalLogLevel level) {
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
         if (acceptMessage(msg)) {
             log((SpdyFrame) msg, Direction.INBOUND);
         }
-        super.channelRead(ctx, msg);
+        ctx.fireChannelRead(msg);
     }
 
     @Override
-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
         if (acceptMessage(msg)) {
             log((SpdyFrame) msg, Direction.OUTBOUND);
         }
-        super.write(ctx, msg, promise);
+        ctx.write(msg, promise);
     }
 
-    private static boolean acceptMessage(Object msg) throws Exception {
+    private static boolean acceptMessage(Object msg) {
         return msg instanceof SpdyFrame;
     }
 
diff --git a/example/src/main/java/io/netty/example/spdy/client/package-info.java b/example/src/main/java/io/netty/example/spdy/client/package-info.java
index c9e8d44fec28..de3f6d40ed3f 100644
--- a/example/src/main/java/io/netty/example/spdy/client/package-info.java
+++ b/example/src/main/java/io/netty/example/spdy/client/package-info.java
@@ -33,11 +33,13 @@
  * After that, you can run {@link io.netty.example.spdy.client.SpdyClient}, also settings the JVM parameter
  * mentioned above.
  * <p>
- * You may also use maven to start the server and the client from the command line:
+ * You may also use the {@code run-example.sh} script to start the server and the client from the command line:
  * <pre>
- *     mvn exec:exec -Pspdy-server
+ *     ./run-example spdy-server
  * </pre>
  * Then start the client in a different terminal window:
- *     mvn exec:exec -Pspdy-client
+ * <pre>
+ *     ./run-example spdy-client
+ * </pre>
  */
 package io.netty.example.spdy.client;
diff --git a/example/src/main/java/io/netty/example/spdy/server/SpdyOrHttpHandler.java b/example/src/main/java/io/netty/example/spdy/server/SpdyOrHttpHandler.java
index b22c070d1344..629f64dcce97 100644
--- a/example/src/main/java/io/netty/example/spdy/server/SpdyOrHttpHandler.java
+++ b/example/src/main/java/io/netty/example/spdy/server/SpdyOrHttpHandler.java
@@ -17,18 +17,15 @@
 
 import io.netty.channel.ChannelInboundHandler;
 import io.netty.handler.codec.spdy.SpdyOrHttpChooser;
-import org.eclipse.jetty.npn.NextProtoNego;
 
 import javax.net.ssl.SSLEngine;
-import java.util.logging.Logger;
 
 /**
  * Negotiates with the browser if SPDY or HTTP is going to be used. Once decided, the Netty pipeline is setup with
  * the correct handlers for the selected protocol.
  */
 public class SpdyOrHttpHandler extends SpdyOrHttpChooser {
-    private static final Logger logger = Logger.getLogger(
-            SpdyOrHttpHandler.class.getName());
+
     private static final int MAX_CONTENT_LENGTH = 1024 * 100;
 
     public SpdyOrHttpHandler() {
@@ -41,10 +38,9 @@ public SpdyOrHttpHandler(int maxSpdyContentLength, int maxHttpContentLength) {
 
     @Override
     protected SelectedProtocol getProtocol(SSLEngine engine) {
-        SpdyServerProvider provider = (SpdyServerProvider) NextProtoNego.get(engine);
-        SelectedProtocol selectedProtocol = provider.getSelectedProtocol();
-
-        logger.info("Selected Protocol is " + selectedProtocol);
+        String[] protocol = engine.getSession().getProtocol().split(":");
+        SelectedProtocol selectedProtocol = SelectedProtocol.protocol(protocol[1]);
+        System.err.println("Selected Protocol is " + selectedProtocol);
         return selectedProtocol;
     }
 
diff --git a/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java b/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java
index 64dce6a778b9..991d727a22ba 100644
--- a/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java
+++ b/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java
@@ -21,6 +21,13 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.codec.spdy.SpdyOrHttpChooser.SelectedProtocol;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
+
+import java.util.Arrays;
 
 /**
  * A SPDY Server that responds to a GET request with a Hello World.
@@ -31,53 +38,47 @@
  * See <a href="http://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty docs</a> for more
  * information.
  * <p>
- * You may also use maven to start the server from the command line:
+ * You may also use the {@code run-example.sh} script to start the server from the command line:
  * <pre>
- *     mvn exec:exec -Pspdy-server
+ *     ./run-example.sh spdy-server
  * </pre>
  * <p>
  * Once started, you can test the server with your
  * <a href="http://en.wikipedia.org/wiki/SPDY#Browser_support_and_usage">SPDY enabled web browser</a> by navigating
  * to <a href="https://localhost:8443/">https://localhost:8443/</a>
  */
-public class SpdyServer {
+public final class SpdyServer {
 
-    private final int port;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8443"));
 
-    public SpdyServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        SelfSignedCertificate ssc = new SelfSignedCertificate();
+        SslContext sslCtx = SslContext.newServerContext(
+                ssc.certificate(), ssc.privateKey(), null, null,
+                Arrays.asList(SelectedProtocol.SPDY_3_1.protocolName(), SelectedProtocol.HTTP_1_1.protocolName()),
+                0, 0);
 
-    public void run() throws Exception {
         // Configure the server.
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.option(ChannelOption.SO_BACKLOG, 1024);
-            b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)
-                    .childHandler(new SpdyServerInitializer());
+            b.group(bossGroup, workerGroup)
+             .channel(NioServerSocketChannel.class)
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new SpdyServerInitializer(sslCtx));
+
+            Channel ch = b.bind(PORT).sync().channel();
+
+            System.err.println("Open your SPDY-enabled web browser and navigate to https://127.0.0.1:" + PORT + '/');
+            System.err.println("If using Chrome browser, check your SPDY sessions at chrome://net-internals/#spdy");
 
-            Channel ch = b.bind(port).sync().channel();
             ch.closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8443;
-        }
-
-        System.out.println("SPDY web server started at port " + port + '.');
-        System.out.println("Open your SPDY enabled browser and navigate to https://localhost:" + port + '/');
-        System.out.println("If using Chrome browser, check your SPDY sessions at chrome://net-internals/#spdy");
-
-        new SpdyServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/spdy/server/SpdyServerHandler.java b/example/src/main/java/io/netty/example/spdy/server/SpdyServerHandler.java
index 9f695081426b..e49604200960 100644
--- a/example/src/main/java/io/netty/example/spdy/server/SpdyServerHandler.java
+++ b/example/src/main/java/io/netty/example/spdy/server/SpdyServerHandler.java
@@ -36,10 +36,6 @@
  * HTTP handler that responds with a "Hello World"
  */
 public class SpdyServerHandler extends SimpleChannelInboundHandler<Object> {
-    @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) {
-        ctx.flush();
-    }
 
     @Override
     public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
@@ -67,7 +63,12 @@ public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
+        ctx.flush();
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }
diff --git a/example/src/main/java/io/netty/example/spdy/server/SpdyServerInitializer.java b/example/src/main/java/io/netty/example/spdy/server/SpdyServerInitializer.java
index 33b0dbed01e2..eb63027bcb31 100644
--- a/example/src/main/java/io/netty/example/spdy/server/SpdyServerInitializer.java
+++ b/example/src/main/java/io/netty/example/spdy/server/SpdyServerInitializer.java
@@ -18,29 +18,24 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.example.securechat.SecureChatSslContextFactory;
-import io.netty.handler.ssl.SslHandler;
-import org.eclipse.jetty.npn.NextProtoNego;
-
-import javax.net.ssl.SSLEngine;
+import io.netty.handler.ssl.SslContext;
 
 /**
  * Sets up the Netty pipeline
  */
 public class SpdyServerInitializer extends ChannelInitializer<SocketChannel> {
-    @Override
-    public void initChannel(SocketChannel ch) throws Exception {
-        ChannelPipeline p = ch.pipeline();
 
-        SSLEngine engine = SecureChatSslContextFactory.getServerContext().createSSLEngine();
-        engine.setUseClientMode(false);
-        p.addLast("ssl", new SslHandler(engine));
+    private final SslContext sslCtx;
 
-        // Setup NextProtoNego with our server provider
-        NextProtoNego.put(engine, new SpdyServerProvider());
-        NextProtoNego.debug = true;
+    public SpdyServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
 
+    @Override
+    public void initChannel(SocketChannel ch) {
+        ChannelPipeline p = ch.pipeline();
+        p.addLast(sslCtx.newHandler(ch.alloc()));
         // Negotiates with the browser if SPDY or HTTP is going to be used
-        p.addLast("handler", new SpdyOrHttpHandler());
+        p.addLast(new SpdyOrHttpHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/spdy/server/SpdyServerProvider.java b/example/src/main/java/io/netty/example/spdy/server/SpdyServerProvider.java
deleted file mode 100644
index d6292093a5d7..000000000000
--- a/example/src/main/java/io/netty/example/spdy/server/SpdyServerProvider.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2014 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.example.spdy.server;
-
-import io.netty.handler.codec.spdy.SpdyOrHttpChooser;
-import org.eclipse.jetty.npn.NextProtoNego.ServerProvider;
-
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * The Jetty project provides an implementation of the Transport Layer Security (TLS) extension for Next
- * Protocol Negotiation (NPN) for OpenJDK 7 or greater. NPN allows the application layer to negotiate which
- * protocol to use over the secure connection.
- * <p>
- * This NPN service provider negotiates using SPDY.
- * <p>
- * To enable NPN support, start the JVM with: {@code java -Xbootclasspath/p:<path_to_npn_boot_jar> ...}. The
- * "path_to_npn_boot_jar" is the path on the file system for the NPN Boot Jar file which can be downloaded from
- * Maven at coordinates org.mortbay.jetty.npn:npn-boot. Different versions applies to different OpenJDK versions.
- *
- * @see <a href="http://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty documentation</a>
- */
-public class SpdyServerProvider implements ServerProvider {
-
-    private String selectedProtocol;
-
-    @Override
-    public void unsupported() {
-        // if unsupported, default to http/1.1
-        selectedProtocol = "http/1.1";
-    }
-
-    @Override
-    public List<String> protocols() {
-        return Arrays.asList("spdy/3.1", "spdy/3", "http/1.1");
-    }
-
-    @Override
-    public void protocolSelected(String protocol) {
-        selectedProtocol = protocol;
-    }
-
-    public SpdyOrHttpChooser.SelectedProtocol getSelectedProtocol() {
-        if (selectedProtocol == null) {
-            return SpdyOrHttpChooser.SelectedProtocol.UNKNOWN;
-        }
-        return SpdyOrHttpChooser.SelectedProtocol.protocol(selectedProtocol);
-    }
-}
diff --git a/example/src/main/java/io/netty/example/spdy/server/package-info.java b/example/src/main/java/io/netty/example/spdy/server/package-info.java
index ece1e7c9c7f9..1a61e7a58be6 100644
--- a/example/src/main/java/io/netty/example/spdy/server/package-info.java
+++ b/example/src/main/java/io/netty/example/spdy/server/package-info.java
@@ -28,9 +28,9 @@
  * See <a href="http://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty docs</a> for more
  * information.
  * <p>
- * You may also use maven to start the server from the command line:
+ * You may also use the {@code run-example.sh} script to start the server from the command line:
  * <pre>
- *     mvn exec:exec -Pspdy-server
+ *     ./run-example spdy-server
  * </pre>
  * <p>
  * Once started, you can test the server with your
diff --git a/example/src/main/java/io/netty/example/stomp/StompClient.java b/example/src/main/java/io/netty/example/stomp/StompClient.java
new file mode 100644
index 000000000000..5527316f2648
--- /dev/null
+++ b/example/src/main/java/io/netty/example/stomp/StompClient.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.example.stomp;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.stomp.StompSubframeAggregator;
+import io.netty.handler.codec.stomp.StompSubframeDecoder;
+import io.netty.handler.codec.stomp.StompSubframeEncoder;
+
+
+/**
+ * very simple stomp client implementation example, requires running stomp server to actually work
+ * uses default username/password and destination values from hornetq message broker
+ */
+public final class StompClient {
+
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "61613"));
+    static final String LOGIN = System.getProperty("login", "guest");
+    static final String PASSCODE = System.getProperty("passcode", "guest");
+    static final String TOPIC = System.getProperty("topic", "jms.topic.exampleTopic");
+
+    public static void main(String[] args) throws Exception {
+        EventLoopGroup group = new NioEventLoopGroup();
+        try {
+            Bootstrap b = new Bootstrap();
+            b.group(group).channel(NioSocketChannel.class);
+            b.handler(new ChannelInitializer<SocketChannel>() {
+                @Override
+                protected void initChannel(SocketChannel ch) throws Exception {
+                    ChannelPipeline pipeline = ch.pipeline();
+                    pipeline.addLast("decoder", new StompSubframeDecoder());
+                    pipeline.addLast("encoder", new StompSubframeEncoder());
+                    pipeline.addLast("aggregator", new StompSubframeAggregator(1048576));
+                    pipeline.addLast("handler", new StompClientHandler());
+                }
+            });
+
+            b.connect(HOST, PORT).sync().channel().closeFuture().sync();
+        } finally {
+            group.shutdownGracefully();
+        }
+    }
+}
diff --git a/example/src/main/java/io/netty/example/stomp/StompClientHandler.java b/example/src/main/java/io/netty/example/stomp/StompClientHandler.java
new file mode 100644
index 000000000000..db447c1d7786
--- /dev/null
+++ b/example/src/main/java/io/netty/example/stomp/StompClientHandler.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.example.stomp;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.handler.codec.stomp.DefaultStompFrame;
+import io.netty.handler.codec.stomp.StompCommand;
+import io.netty.handler.codec.stomp.StompFrame;
+import io.netty.handler.codec.stomp.StompHeaders;
+
+/**
+ * STOMP client inbound handler implementation, which just passes received messages to listener
+ */
+public class StompClientHandler extends SimpleChannelInboundHandler<StompFrame> {
+
+    private enum ClientState {
+        AUTHENTICATING,
+        AUTHENTICATED,
+        SUBSCRIBED,
+        DISCONNECTING
+    }
+
+    private ClientState state;
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        state = ClientState.AUTHENTICATING;
+        StompFrame connFrame = new DefaultStompFrame(StompCommand.CONNECT);
+        connFrame.headers().set(StompHeaders.ACCEPT_VERSION, "1.2");
+        connFrame.headers().set(StompHeaders.HOST, StompClient.HOST);
+        connFrame.headers().set(StompHeaders.LOGIN, StompClient.LOGIN);
+        connFrame.headers().set(StompHeaders.PASSCODE, StompClient.PASSCODE);
+        ctx.writeAndFlush(connFrame);
+    }
+
+    @Override
+    protected void channelRead0(ChannelHandlerContext ctx, StompFrame frame) throws Exception {
+        String subscrReceiptId = "001";
+        String disconReceiptId = "002";
+        switch (frame.command()) {
+            case CONNECTED:
+                StompFrame subscribeFrame = new DefaultStompFrame(StompCommand.SUBSCRIBE);
+                subscribeFrame.headers().set(StompHeaders.DESTINATION, StompClient.TOPIC);
+                subscribeFrame.headers().set(StompHeaders.RECEIPT, subscrReceiptId);
+                subscribeFrame.headers().set(StompHeaders.ID, "1");
+                System.out.println("connected, sending subscribe frame: " + subscribeFrame);
+                state = ClientState.AUTHENTICATED;
+                ctx.writeAndFlush(subscribeFrame);
+                break;
+            case RECEIPT:
+                String receiptHeader = frame.headers().get(StompHeaders.RECEIPT_ID);
+                if (state == ClientState.AUTHENTICATED && receiptHeader.equals(subscrReceiptId)) {
+                    StompFrame msgFrame = new DefaultStompFrame(StompCommand.SEND);
+                    msgFrame.headers().set(StompHeaders.DESTINATION, StompClient.TOPIC);
+                    msgFrame.content().writeBytes("some payload".getBytes());
+                    System.out.println("subscribed, sending message frame: " + msgFrame);
+                    state = ClientState.SUBSCRIBED;
+                    ctx.writeAndFlush(msgFrame);
+                } else if (state == ClientState.DISCONNECTING && receiptHeader.equals(disconReceiptId)) {
+                    System.out.println("disconnected");
+                    ctx.close();
+                } else {
+                    throw new IllegalStateException("received: " + frame + ", while internal state is " + state);
+                }
+                break;
+            case MESSAGE:
+                if (state == ClientState.SUBSCRIBED) {
+                    System.out.println("received frame: " + frame);
+                    StompFrame disconnFrame = new DefaultStompFrame(StompCommand.DISCONNECT);
+                    disconnFrame.headers().set(StompHeaders.RECEIPT, disconReceiptId);
+                    System.out.println("sending disconnect frame: " + disconnFrame);
+                    state = ClientState.DISCONNECTING;
+                    ctx.writeAndFlush(disconnFrame);
+                }
+                break;
+            default:
+                break;
+        }
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+        cause.printStackTrace();
+        ctx.close();
+    }
+}
diff --git a/example/src/main/java/io/netty/example/telnet/TelnetClient.java b/example/src/main/java/io/netty/example/telnet/TelnetClient.java
index 5beee1b6e132..87923419c6d3 100644
--- a/example/src/main/java/io/netty/example/telnet/TelnetClient.java
+++ b/example/src/main/java/io/netty/example/telnet/TelnetClient.java
@@ -21,6 +21,8 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
@@ -28,26 +30,30 @@
 /**
  * Simplistic telnet client.
  */
-public class TelnetClient {
+public final class TelnetClient {
 
-    private final String host;
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8992" : "8023"));
 
-    public TelnetClient(String host, int port) {
-        this.host = host;
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
             b.group(group)
              .channel(NioSocketChannel.class)
-             .handler(new TelnetClientInitializer());
+             .handler(new TelnetClientInitializer(sslCtx));
 
             // Start the connection attempt.
-            Channel ch = b.connect(host, port).sync().channel();
+            Channel ch = b.connect(HOST, PORT).sync().channel();
 
             // Read commands from the stdin.
             ChannelFuture lastWriteFuture = null;
@@ -77,20 +83,4 @@ public void run() throws Exception {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length != 2) {
-            System.err.println(
-                    "Usage: " + TelnetClient.class.getSimpleName() +
-                    " <host> <port>");
-            return;
-        }
-
-        // Parse options.
-        String host = args[0];
-        int port = Integer.parseInt(args[1]);
-
-        new TelnetClient(host, port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java b/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java
index 671abc276d70..508a309149a7 100644
--- a/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java
+++ b/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java
@@ -19,27 +19,20 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handles a client-side channel.
  */
 @Sharable
 public class TelnetClientHandler extends SimpleChannelInboundHandler<String> {
 
-    private static final Logger logger = Logger.getLogger(TelnetClientHandler.class.getName());
-
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
         System.err.println(msg);
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java b/example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java
index 1d5db6eee356..06b32e8d7b3d 100644
--- a/example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java
+++ b/example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java
@@ -22,25 +22,38 @@
 import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
+import io.netty.handler.ssl.SslContext;
 
 /**
  * Creates a newly configured {@link ChannelPipeline} for a new channel.
  */
 public class TelnetClientInitializer extends ChannelInitializer<SocketChannel> {
+
     private static final StringDecoder DECODER = new StringDecoder();
     private static final StringEncoder ENCODER = new StringEncoder();
-    private static final TelnetClientHandler CLIENTHANDLER = new TelnetClientHandler();
+
+    private static final TelnetClientHandler CLIENT_HANDLER = new TelnetClientHandler();
+
+    private final SslContext sslCtx;
+
+    public TelnetClientInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
+
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline pipeline = ch.pipeline();
 
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc(), TelnetClient.HOST, TelnetClient.PORT));
+        }
+
         // Add the text line codec combination first,
-        pipeline.addLast("framer", new DelimiterBasedFrameDecoder(
-                8192, Delimiters.lineDelimiter()));
-        pipeline.addLast("decoder", DECODER);
-        pipeline.addLast("encoder", ENCODER);
+        pipeline.addLast(new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()));
+        pipeline.addLast(DECODER);
+        pipeline.addLast(ENCODER);
 
         // and then business logic.
-        pipeline.addLast("handler", CLIENTHANDLER);
+        pipeline.addLast(CLIENT_HANDLER);
     }
 }
diff --git a/example/src/main/java/io/netty/example/telnet/TelnetServer.java b/example/src/main/java/io/netty/example/telnet/TelnetServer.java
index eddc9f4d4f26..751add87946b 100644
--- a/example/src/main/java/io/netty/example/telnet/TelnetServer.java
+++ b/example/src/main/java/io/netty/example/telnet/TelnetServer.java
@@ -19,41 +19,42 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * Simplistic telnet server.
  */
-public class TelnetServer {
+public final class TelnetServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", SSL? "8992" : "8023"));
 
-    public TelnetServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new TelnetServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new TelnetServerInitializer(sslCtx));
 
-            b.bind(port).sync().channel().closeFuture().sync();
+            b.bind(PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new TelnetServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java b/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java
index 1a0b566e57e1..bb788101d46a 100644
--- a/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java
+++ b/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java
@@ -23,8 +23,6 @@
 
 import java.net.InetAddress;
 import java.util.Date;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * Handles a server-side channel.
@@ -32,20 +30,16 @@
 @Sharable
 public class TelnetServerHandler extends SimpleChannelInboundHandler<String> {
 
-    private static final Logger logger = Logger.getLogger(TelnetServerHandler.class.getName());
-
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
         // Send greeting for a new connection.
-        ctx.write(
-                "Welcome to " + InetAddress.getLocalHost().getHostName() + "!\r\n");
+        ctx.write("Welcome to " + InetAddress.getLocalHost().getHostName() + "!\r\n");
         ctx.write("It is " + new Date() + " now.\r\n");
         ctx.flush();
     }
 
     @Override
     public void channelRead0(ChannelHandlerContext ctx, String request) throws Exception {
-
         // Generate and write a response.
         String response;
         boolean close = false;
@@ -70,15 +64,13 @@ public void channelRead0(ChannelHandlerContext ctx, String request) throws Excep
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/telnet/TelnetServerInitializer.java b/example/src/main/java/io/netty/example/telnet/TelnetServerInitializer.java
index ff5d3526c675..cc2396471ed9 100644
--- a/example/src/main/java/io/netty/example/telnet/TelnetServerInitializer.java
+++ b/example/src/main/java/io/netty/example/telnet/TelnetServerInitializer.java
@@ -22,27 +22,39 @@
 import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
+import io.netty.handler.ssl.SslContext;
 
 /**
  * Creates a newly configured {@link ChannelPipeline} for a new channel.
  */
 public class TelnetServerInitializer extends ChannelInitializer<SocketChannel> {
+
     private static final StringDecoder DECODER = new StringDecoder();
     private static final StringEncoder ENCODER = new StringEncoder();
-    private static final TelnetServerHandler SERVERHANDLER = new TelnetServerHandler();
+
+    private static final TelnetServerHandler SERVER_HANDLER = new TelnetServerHandler();
+
+    private final SslContext sslCtx;
+
+    public TelnetServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
 
     @Override
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline pipeline = ch.pipeline();
 
+        if (sslCtx != null) {
+            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
+        }
+
         // Add the text line codec combination first,
-        pipeline.addLast("framer", new DelimiterBasedFrameDecoder(
-                8192, Delimiters.lineDelimiter()));
+        pipeline.addLast(new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()));
         // the encoder and decoder are static as these are sharable
-        pipeline.addLast("decoder", DECODER);
-        pipeline.addLast("encoder", ENCODER);
+        pipeline.addLast(DECODER);
+        pipeline.addLast(ENCODER);
 
         // and then business logic.
-        pipeline.addLast("handler", SERVERHANDLER);
+        pipeline.addLast(SERVER_HANDLER);
     }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java
index f2ac3a0164ff..aa95a3544e30 100644
--- a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java
+++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java
@@ -21,14 +21,11 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.UdtChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
-import io.netty.example.udt.util.UtilConsoleReporter;
-import io.netty.example.udt.util.UtilThreadFactory;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Logger;
 
 /**
  * UDT Byte Stream Client
@@ -38,24 +35,15 @@
  * between the echo client and server by sending the first message to the
  * server.
  */
-public class ByteEchoClient {
+public final class ByteEchoClient {
 
-    private static final Logger log = Logger.getLogger(ByteEchoClient.class.getName());
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
+    static final int SIZE = Integer.parseInt(System.getProperty("size", "256"));
 
-    private final String host;
-    private final int port;
-    private final int messageSize;
-
-    public ByteEchoClient(final String host, final int port,
-            final int messageSize) {
-        this.host = host;
-        this.port = port;
-        this.messageSize = messageSize;
-    }
-
-    public void run() throws Exception {
+    public static void main(String[] args) throws Exception {
         // Configure the client.
-        final ThreadFactory connectFactory = new UtilThreadFactory("connect");
+        final ThreadFactory connectFactory = new DefaultThreadFactory("connect");
         final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
                 connectFactory, NioUdtProvider.BYTE_PROVIDER);
         try {
@@ -68,11 +56,11 @@ public void initChannel(final UdtChannel ch)
                                 throws Exception {
                             ch.pipeline().addLast(
                                     new LoggingHandler(LogLevel.INFO),
-                                    new ByteEchoClientHandler(messageSize));
+                                    new ByteEchoClientHandler());
                         }
                     });
             // Start the client.
-            final ChannelFuture f = boot.connect(host, port).sync();
+            final ChannelFuture f = boot.connect(HOST, PORT).sync();
             // Wait until the connection is closed.
             f.channel().closeFuture().sync();
         } finally {
@@ -80,21 +68,4 @@ public void initChannel(final UdtChannel ch)
             connectGroup.shutdownGracefully();
         }
     }
-
-    public static void main(final String[] args) throws Exception {
-        log.info("init");
-
-        // client is reporting metrics
-        UtilConsoleReporter.enable(3, TimeUnit.SECONDS);
-
-        final String host = "localhost";
-        final int port = 1234;
-
-        final int messageSize = 64 * 1024;
-
-        new ByteEchoClient(host, port, messageSize).run();
-
-        log.info("done");
-    }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java
index 6264400a7807..d1825f91c651 100644
--- a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java
@@ -15,18 +15,12 @@
  */
 package io.netty.example.udt.echo.bytes;
 
-import com.yammer.metrics.Metrics;
-import com.yammer.metrics.core.Meter;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the echo client. It initiates the ping-pong
  * traffic between the echo client and server by sending the first message to
@@ -34,45 +28,36 @@
  */
 public class ByteEchoClientHandler extends SimpleChannelInboundHandler<ByteBuf> {
 
-    private static final Logger log = Logger.getLogger(ByteEchoClientHandler.class.getName());
-
     private final ByteBuf message;
 
-    final Meter meter = Metrics.newMeter(ByteEchoClientHandler.class, "rate",
-            "bytes", TimeUnit.SECONDS);
-
-    public ByteEchoClientHandler(final int messageSize) {
+    public ByteEchoClientHandler() {
         super(false);
 
-        message = Unpooled.buffer(messageSize);
-
+        message = Unpooled.buffer(ByteEchoClient.SIZE);
         for (int i = 0; i < message.capacity(); i++) {
             message.writeByte((byte) i);
         }
     }
 
     @Override
-    public void channelActive(final ChannelHandlerContext ctx) throws Exception {
-        log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
+    public void channelActive(final ChannelHandlerContext ctx) {
+        System.err.println("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
         ctx.writeAndFlush(message);
     }
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
-        meter.mark(msg.readableBytes());
-
+    public void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {
         ctx.write(msg);
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(final ChannelHandlerContext ctx,
-            final Throwable cause) {
-        log.log(Level.WARNING, "close the connection when an exception is raised", cause);
+    public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 
diff --git a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServer.java b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServer.java
index 6261e1e12291..e5c43224f4c6 100644
--- a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServer.java
+++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServer.java
@@ -22,35 +22,27 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.UdtChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
-import io.netty.example.udt.util.UtilThreadFactory;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.util.concurrent.ThreadFactory;
-import java.util.logging.Logger;
 
 /**
  * UDT Byte Stream Server
  * <p>
  * Echoes back any received data from a client.
  */
-public class ByteEchoServer {
+public final class ByteEchoServer {
 
-    private static final Logger log = Logger.getLogger(ByteEchoServer.class.getName());
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
 
-    private final int port;
+    public static void main(String[] args) throws Exception {
+        final ThreadFactory acceptFactory = new DefaultThreadFactory("accept");
+        final ThreadFactory connectFactory = new DefaultThreadFactory("connect");
+        final NioEventLoopGroup acceptGroup = new NioEventLoopGroup(1, acceptFactory, NioUdtProvider.BYTE_PROVIDER);
+        final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1, connectFactory, NioUdtProvider.BYTE_PROVIDER);
 
-    public ByteEchoServer(final int port) {
-        this.port = port;
-    }
-
-    public void run() throws Exception {
-        final ThreadFactory acceptFactory = new UtilThreadFactory("accept");
-        final ThreadFactory connectFactory = new UtilThreadFactory("connect");
-        final NioEventLoopGroup acceptGroup = new NioEventLoopGroup(1,
-                acceptFactory, NioUdtProvider.BYTE_PROVIDER);
-        final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
-                connectFactory, NioUdtProvider.BYTE_PROVIDER);
         // Configure the server.
         try {
             final ServerBootstrap boot = new ServerBootstrap();
@@ -68,7 +60,7 @@ public void initChannel(final UdtChannel ch)
                         }
                     });
             // Start the server.
-            final ChannelFuture future = boot.bind(port).sync();
+            final ChannelFuture future = boot.bind(PORT).sync();
             // Wait until the server socket is closed.
             future.channel().closeFuture().sync();
         } finally {
@@ -77,15 +69,4 @@ public void initChannel(final UdtChannel ch)
             connectGroup.shutdownGracefully();
         }
     }
-
-    public static void main(final String[] args) throws Exception {
-        log.info("init");
-
-        final int port = 1234;
-
-        new ByteEchoServer(port).run();
-
-        log.info("done");
-    }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java
index 9dac3cf4ec1d..4769796c4fa7 100644
--- a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java
@@ -20,16 +20,16 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the echo server.
  */
 @Sharable
 public class ByteEchoServerHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger log = Logger.getLogger(ByteEchoServerHandler.class.getName());
+    @Override
+    public void channelActive(final ChannelHandlerContext ctx) {
+        System.err.println("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
+    }
 
     @Override
     public void channelRead(final ChannelHandlerContext ctx, Object msg) {
@@ -37,20 +37,13 @@ public void channelRead(final ChannelHandlerContext ctx, Object msg) {
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(final ChannelHandlerContext ctx,
-            final Throwable cause) {
-        log.log(Level.WARNING, "close the connection when an exception is raised", cause);
+    public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
-
-    @Override
-    public void channelActive(final ChannelHandlerContext ctx) throws Exception {
-        log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
-    }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java
index 0f5fb9c29029..349f11ce8639 100644
--- a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java
+++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java
@@ -21,13 +21,11 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.UdtChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
-import io.netty.example.udt.util.UtilConsoleReporter;
-import io.netty.example.udt.util.UtilThreadFactory;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
 import java.util.logging.Logger;
 
 /**
@@ -38,24 +36,18 @@
  * between the echo client and server by sending the first message to the
  * server.
  */
-public class MsgEchoClient {
+public final class MsgEchoClient {
 
     private static final Logger log = Logger.getLogger(MsgEchoClient.class.getName());
 
-    private final String host;
-    private final int port;
-    private final int messageSize;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
+    static final int SIZE = Integer.parseInt(System.getProperty("size", "256"));
 
-    public MsgEchoClient(final String host, final int port,
-            final int messageSize) {
-        this.host = host;
-        this.port = port;
-        this.messageSize = messageSize;
-    }
+    public static void main(String[] args) throws Exception {
 
-    public void run() throws Exception {
         // Configure the client.
-        final ThreadFactory connectFactory = new UtilThreadFactory("connect");
+        final ThreadFactory connectFactory = new DefaultThreadFactory("connect");
         final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
                 connectFactory, NioUdtProvider.MESSAGE_PROVIDER);
         try {
@@ -68,11 +60,11 @@ public void initChannel(final UdtChannel ch)
                                 throws Exception {
                             ch.pipeline().addLast(
                                     new LoggingHandler(LogLevel.INFO),
-                                    new MsgEchoClientHandler(messageSize));
+                                    new MsgEchoClientHandler());
                         }
                     });
             // Start the client.
-            final ChannelFuture f = boot.connect(host, port).sync();
+            final ChannelFuture f = boot.connect(HOST, PORT).sync();
             // Wait until the connection is closed.
             f.channel().closeFuture().sync();
         } finally {
@@ -80,21 +72,4 @@ public void initChannel(final UdtChannel ch)
             connectGroup.shutdownGracefully();
         }
     }
-
-    public static void main(final String[] args) throws Exception {
-        log.info("init");
-
-        // client is reporting metrics
-        UtilConsoleReporter.enable(3, TimeUnit.SECONDS);
-
-        final String host = "localhost";
-
-        final int port = 1234;
-        final int messageSize = 64 * 1024;
-
-        new MsgEchoClient(host, port, messageSize).run();
-
-        log.info("done");
-    }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
index 20e305e2e014..722a19418b8e 100644
--- a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
@@ -15,8 +15,6 @@
  */
 package io.netty.example.udt.echo.message;
 
-import com.yammer.metrics.Metrics;
-import com.yammer.metrics.core.Meter;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
@@ -24,10 +22,6 @@
 import io.netty.channel.udt.UdtMessage;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the echo client. It initiates the ping-pong
  * traffic between the echo client and server by sending the first message to
@@ -35,44 +29,36 @@
  */
 public class MsgEchoClientHandler extends SimpleChannelInboundHandler<UdtMessage> {
 
-    private static final Logger log = Logger.getLogger(MsgEchoClientHandler.class.getName());
-
     private final UdtMessage message;
 
-    public MsgEchoClientHandler(final int messageSize) {
+    public MsgEchoClientHandler() {
         super(false);
-        final ByteBuf byteBuf = Unpooled.buffer(messageSize);
+        final ByteBuf byteBuf = Unpooled.buffer(MsgEchoClient.SIZE);
         for (int i = 0; i < byteBuf.capacity(); i++) {
             byteBuf.writeByte((byte) i);
         }
         message = new UdtMessage(byteBuf);
     }
 
-    final Meter meter = Metrics.newMeter(MsgEchoClientHandler.class, "rate",
-            "bytes", TimeUnit.SECONDS);
-
     @Override
-    public void channelActive(final ChannelHandlerContext ctx) throws Exception {
-        log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
+    public void channelActive(final ChannelHandlerContext ctx) {
+        System.err.println("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
         ctx.writeAndFlush(message);
     }
 
     @Override
-    public void exceptionCaught(final ChannelHandlerContext ctx,
-            final Throwable cause) {
-        log.log(Level.WARNING, "close the connection when an exception is raised", cause);
-        ctx.close();
+    public void channelRead0(ChannelHandlerContext ctx, UdtMessage msg) {
+        ctx.write(msg);
     }
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, UdtMessage msg) throws Exception {
-        meter.mark(msg.content().readableBytes());
-
-        ctx.write(msg);
+    public void channelReadComplete(ChannelHandlerContext ctx) {
+        ctx.flush();
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        ctx.flush();
+    public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {
+        cause.printStackTrace();
+        ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServer.java b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServer.java
index 950f02a88de2..6a18a291f996 100644
--- a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServer.java
+++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServer.java
@@ -22,35 +22,29 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.UdtChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
-import io.netty.example.udt.util.UtilThreadFactory;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.util.concurrent.ThreadFactory;
-import java.util.logging.Logger;
 
 /**
  * UDT Message Flow Server
  * <p>
  * Echoes back any received data from a client.
  */
-public class MsgEchoServer {
+public final class MsgEchoServer {
 
-    private static final Logger log = Logger.getLogger(MsgEchoServer.class.getName());
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));
 
-    private final int port;
+    public static void main(String[] args) throws Exception {
+        final ThreadFactory acceptFactory = new DefaultThreadFactory("accept");
+        final ThreadFactory connectFactory = new DefaultThreadFactory("connect");
+        final NioEventLoopGroup acceptGroup =
+                new NioEventLoopGroup(1, acceptFactory, NioUdtProvider.MESSAGE_PROVIDER);
+        final NioEventLoopGroup connectGroup =
+                new NioEventLoopGroup(1, connectFactory, NioUdtProvider.MESSAGE_PROVIDER);
 
-    public MsgEchoServer(final int port) {
-        this.port = port;
-    }
-
-    public void run() throws Exception {
-        final ThreadFactory acceptFactory = new UtilThreadFactory("accept");
-        final ThreadFactory connectFactory = new UtilThreadFactory("connect");
-        final NioEventLoopGroup acceptGroup = new NioEventLoopGroup(1,
-                acceptFactory, NioUdtProvider.MESSAGE_PROVIDER);
-        final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
-                connectFactory, NioUdtProvider.MESSAGE_PROVIDER);
         // Configure the server.
         try {
             final ServerBootstrap boot = new ServerBootstrap();
@@ -68,7 +62,7 @@ public void initChannel(final UdtChannel ch)
                         }
                     });
             // Start the server.
-            final ChannelFuture future = boot.bind(port).sync();
+            final ChannelFuture future = boot.bind(PORT).sync();
             // Wait until the server socket is closed.
             future.channel().closeFuture().sync();
         } finally {
@@ -77,15 +71,4 @@ public void initChannel(final UdtChannel ch)
             connectGroup.shutdownGracefully();
         }
     }
-
-    public static void main(final String[] args) throws Exception {
-        log.info("init");
-
-        final int port = 1234;
-
-        new MsgEchoServer(port).run();
-
-        log.info("done");
-    }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
index bcde8192244c..03aacd23e350 100644
--- a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
@@ -20,36 +20,30 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the echo server.
  */
 @Sharable
 public class MsgEchoServerHandler extends ChannelInboundHandlerAdapter {
 
-    private static final Logger log = Logger.getLogger(MsgEchoServerHandler.class.getName());
-
     @Override
-    public void exceptionCaught(final ChannelHandlerContext ctx,
-            final Throwable cause) {
-        log.log(Level.WARNING, "close the connection when an exception is raised", cause);
-        ctx.close();
+    public void channelActive(final ChannelHandlerContext ctx) {
+        System.err.println("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
     }
 
     @Override
-    public void channelActive(final ChannelHandlerContext ctx) throws Exception {
-        log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
+        ctx.write(msg);
     }
 
     @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        ctx.write(msg);
+    public void channelReadComplete(ChannelHandlerContext ctx) {
+        ctx.flush();
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        ctx.flush();
+    public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {
+        cause.printStackTrace();
+        ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerBase.java b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerBase.java
index cb2984b01a2e..2efe568b2b00 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerBase.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerBase.java
@@ -21,9 +21,9 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.UdtChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
-import io.netty.example.udt.util.UtilThreadFactory;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.ThreadFactory;
@@ -48,7 +48,7 @@ protected MsgEchoPeerBase(final InetSocketAddress self, final InetSocketAddress
 
     public void run() throws Exception {
         // Configure the peer.
-        final ThreadFactory connectFactory = new UtilThreadFactory("rendezvous");
+        final ThreadFactory connectFactory = new DefaultThreadFactory("rendezvous");
         final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
                 connectFactory, NioUdtProvider.MESSAGE_PROVIDER);
         try {
@@ -73,5 +73,4 @@ public void initChannel(final UdtChannel ch)
             connectGroup.shutdownGracefully();
         }
     }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java
index 4f3d3644a600..7b056f30a4eb 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java
@@ -15,8 +15,6 @@
  */
 package io.netty.example.udt.echo.rendezvous;
 
-import com.yammer.metrics.Metrics;
-import com.yammer.metrics.core.Meter;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
@@ -24,19 +22,12 @@
 import io.netty.channel.udt.UdtMessage;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the echo peer. It initiates the ping-pong traffic
  * between the echo peers by sending the first message to the other peer on
  * activation.
  */
-public class MsgEchoPeerHandler extends
-        SimpleChannelInboundHandler<UdtMessage> {
-
-    private static final Logger log = Logger.getLogger(MsgEchoPeerHandler.class.getName());
+public class MsgEchoPeerHandler extends SimpleChannelInboundHandler<UdtMessage> {
 
     private final UdtMessage message;
 
@@ -49,31 +40,25 @@ public MsgEchoPeerHandler(final int messageSize) {
         message = new UdtMessage(byteBuf);
     }
 
-    final Meter meter = Metrics.newMeter(MsgEchoPeerHandler.class, "rate",
-            "bytes", TimeUnit.SECONDS);
-
     @Override
-    public void channelActive(final ChannelHandlerContext ctx) throws Exception {
-        log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
+    public void channelActive(final ChannelHandlerContext ctx) {
+        System.err.println("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
         ctx.writeAndFlush(message);
     }
 
     @Override
-    public void exceptionCaught(final ChannelHandlerContext ctx,
-            final Throwable cause) {
-        log.log(Level.WARNING, "close the connection when an exception is raised", cause);
-        ctx.close();
+    public void channelRead0(ChannelHandlerContext ctx, UdtMessage message) {
+        ctx.write(message);
     }
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, UdtMessage message) throws Exception {
-        meter.mark(message.content().readableBytes());
-
-        ctx.write(message);
+    public void channelReadComplete(ChannelHandlerContext ctx) {
+        ctx.flush();
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        ctx.flush();
+    public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {
+        cause.printStackTrace();
+        ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerOne.java b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerOne.java
index 6fb12781c0b8..846f9e128c01 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerOne.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerOne.java
@@ -16,7 +16,6 @@
 package io.netty.example.udt.echo.rendezvous;
 
 import java.net.InetSocketAddress;
-import java.util.logging.Logger;
 
 /**
  * UDT Message Flow Peer
@@ -26,30 +25,14 @@
  */
 public class MsgEchoPeerOne extends MsgEchoPeerBase {
 
-    private static final Logger log = Logger.getLogger(MsgEchoPeerOne.class.getName());
-
-    public MsgEchoPeerOne(final InetSocketAddress self,
-            final InetSocketAddress peer, final int messageSize) {
+    public MsgEchoPeerOne(final InetSocketAddress self, final InetSocketAddress peer, final int messageSize) {
         super(self, peer, messageSize);
     }
 
     public static void main(final String[] args) throws Exception {
-        log.info("init");
-
-        // peer one is not reporting metrics
-        // ConsoleReporterUDT.enable(3, TimeUnit.SECONDS);
-
         final int messageSize = 64 * 1024;
-
-        final InetSocketAddress self = new InetSocketAddress(Config.hostOne,
-                Config.portOne);
-
-        final InetSocketAddress peer = new InetSocketAddress(Config.hostTwo,
-                Config.portTwo);
-
+        final InetSocketAddress self = new InetSocketAddress(Config.hostOne, Config.portOne);
+        final InetSocketAddress peer = new InetSocketAddress(Config.hostTwo, Config.portTwo);
         new MsgEchoPeerOne(self, peer, messageSize).run();
-
-        log.info("done");
     }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerTwo.java b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerTwo.java
index 394d0652320c..2dc9b895775d 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerTwo.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerTwo.java
@@ -15,11 +15,7 @@
  */
 package io.netty.example.udt.echo.rendezvous;
 
-import io.netty.example.udt.util.UtilConsoleReporter;
-
 import java.net.InetSocketAddress;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Logger;
 
 /**
  * UDT Message Flow Peer
@@ -29,30 +25,14 @@
  */
 public class MsgEchoPeerTwo extends MsgEchoPeerBase {
 
-    private static final Logger log = Logger.getLogger(MsgEchoPeerTwo.class.getName());
-
-    public MsgEchoPeerTwo(final InetSocketAddress self,
-            final InetSocketAddress peer, final int messageSize) {
+    public MsgEchoPeerTwo(final InetSocketAddress self, final InetSocketAddress peer, final int messageSize) {
         super(self, peer, messageSize);
     }
 
     public static void main(final String[] args) throws Exception {
-        log.info("init");
-
-        // peer two is reporting metrics
-        UtilConsoleReporter.enable(3, TimeUnit.SECONDS);
-
         final int messageSize = 64 * 1024;
-
-        final InetSocketAddress self = new InetSocketAddress(Config.hostTwo,
-                Config.portTwo);
-
-        final InetSocketAddress peer = new InetSocketAddress(Config.hostOne,
-                Config.portOne);
-
+        final InetSocketAddress self = new InetSocketAddress(Config.hostTwo, Config.portTwo);
+        final InetSocketAddress peer = new InetSocketAddress(Config.hostOne, Config.portOne);
         new MsgEchoPeerTwo(self, peer, messageSize).run();
-
-        log.info("done");
     }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerBase.java b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerBase.java
index d1d973f24399..55d857d9b5fb 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerBase.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerBase.java
@@ -21,9 +21,9 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.UdtChannel;
 import io.netty.channel.udt.nio.NioUdtProvider;
-import io.netty.example.udt.util.UtilThreadFactory;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.net.SocketAddress;
 import java.util.concurrent.ThreadFactory;
@@ -38,9 +38,10 @@
  * <p/>
  */
 public class ByteEchoPeerBase {
+
     protected final int messageSize;
-    protected SocketAddress myAddress;
-    protected SocketAddress peerAddress;
+    protected final SocketAddress myAddress;
+    protected final SocketAddress peerAddress;
 
     public ByteEchoPeerBase(int messageSize, SocketAddress myAddress, SocketAddress peerAddress) {
         this.messageSize = messageSize;
@@ -49,7 +50,7 @@ public ByteEchoPeerBase(int messageSize, SocketAddress myAddress, SocketAddress
     }
 
     public void run() throws Exception {
-        final ThreadFactory connectFactory = new UtilThreadFactory("rendezvous");
+        final ThreadFactory connectFactory = new DefaultThreadFactory("rendezvous");
         final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
                 connectFactory, NioUdtProvider.BYTE_PROVIDER);
         try {
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java
index 80100a620e19..fee82cc462fc 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java
@@ -15,29 +15,20 @@
  */
 package io.netty.example.udt.echo.rendezvousBytes;
 
-import com.yammer.metrics.Metrics;
-import com.yammer.metrics.core.Meter;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 /**
  * Handler implementation for the echo client. It initiates the ping-pong
  * traffic between the echo client and server by sending the first message to
  * the server on activation.
  */
 public class ByteEchoPeerHandler extends SimpleChannelInboundHandler<ByteBuf> {
-    private static final Logger log = Logger.getLogger(ByteEchoPeerHandler.class.getName());
-    private final ByteBuf message;
 
-    final Meter meter = Metrics.newMeter(ByteEchoPeerHandler.class, "rate",
-            "bytes", TimeUnit.SECONDS);
+    private final ByteBuf message;
 
     public ByteEchoPeerHandler(final int messageSize) {
         super(false);
@@ -48,26 +39,24 @@ public ByteEchoPeerHandler(final int messageSize) {
     }
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
-        log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
+    public void channelActive(ChannelHandlerContext ctx) {
+        System.err.println("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
         ctx.writeAndFlush(message);
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        log.log(Level.WARNING, "close the connection when an exception is raised", cause);
-        ctx.close();
+    public void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) {
+        ctx.write(buf);
     }
 
     @Override
-    public void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception {
-        meter.mark(buf.readableBytes());
-
-        ctx.write(buf);
+    public void channelReadComplete(ChannelHandlerContext ctx) {
+        ctx.flush();
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        ctx.flush();
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
+        ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerOne.java b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerOne.java
index a8cc43a8a4ed..71bda7419066 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerOne.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerOne.java
@@ -19,7 +19,6 @@
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
-import java.util.logging.Logger;
 
 /**
  * UDT Byte Stream Peer
@@ -31,19 +30,15 @@
  * <p/>
  */
 public class ByteEchoPeerOne extends ByteEchoPeerBase {
-    private static final Logger log = Logger.getLogger(ByteEchoPeerOne.class.getName());
 
     public ByteEchoPeerOne(int messageSize, SocketAddress myAddress, SocketAddress peerAddress) {
         super(messageSize, myAddress, peerAddress);
     }
 
     public static void main(String[] args) throws Exception {
-        log.info("init");
         final int messageSize = 64 * 1024;
-        final InetSocketAddress myAddress = new InetSocketAddress(
-                Config.hostOne, Config.portOne);
-        final InetSocketAddress peerAddress = new InetSocketAddress(
-                Config.hostTwo, Config.portTwo);
+        final InetSocketAddress myAddress = new InetSocketAddress(Config.hostOne, Config.portOne);
+        final InetSocketAddress peerAddress = new InetSocketAddress(Config.hostTwo, Config.portTwo);
         new ByteEchoPeerOne(messageSize, myAddress, peerAddress).run();
     }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerTwo.java b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerTwo.java
index a92796e18a16..a28c5829b229 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerTwo.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerTwo.java
@@ -16,12 +16,9 @@
 package io.netty.example.udt.echo.rendezvousBytes;
 
 import io.netty.example.udt.echo.rendezvous.Config;
-import io.netty.example.udt.util.UtilConsoleReporter;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Logger;
 
 /**
  * UDT Byte Stream Peer
@@ -33,22 +30,15 @@
  * <p/>
  */
 public class ByteEchoPeerTwo extends ByteEchoPeerBase {
-    private static final Logger log = Logger.getLogger(ByteEchoPeerTwo.class.getName());
 
     public ByteEchoPeerTwo(int messageSize, SocketAddress myAddress, SocketAddress peerAddress) {
         super(messageSize, myAddress, peerAddress);
     }
 
     public static void main(String[] args) throws Exception {
-        log.info("init");
-        // peer two is reporting metrics
-        UtilConsoleReporter.enable(3, TimeUnit.SECONDS);
         final int messageSize = 64 * 1024;
-        final InetSocketAddress myAddress = new InetSocketAddress(
-                Config.hostTwo, Config.portTwo);
-        final InetSocketAddress peerAddress = new InetSocketAddress(
-                Config.hostOne, Config.portOne);
-
+        final InetSocketAddress myAddress = new InetSocketAddress(Config.hostTwo, Config.portTwo);
+        final InetSocketAddress peerAddress = new InetSocketAddress(Config.hostOne, Config.portOne);
         new ByteEchoPeerTwo(messageSize, myAddress, peerAddress).run();
     }
 }
diff --git a/example/src/main/java/io/netty/example/udt/util/UtilConsoleReporter.java b/example/src/main/java/io/netty/example/udt/util/UtilConsoleReporter.java
deleted file mode 100644
index 755519d63b14..000000000000
--- a/example/src/main/java/io/netty/example/udt/util/UtilConsoleReporter.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.example.udt.util;
-
-import com.yammer.metrics.Metrics;
-import com.yammer.metrics.core.Clock;
-import com.yammer.metrics.core.Counter;
-import com.yammer.metrics.core.Gauge;
-import com.yammer.metrics.core.Histogram;
-import com.yammer.metrics.core.Metered;
-import com.yammer.metrics.core.Metric;
-import com.yammer.metrics.core.MetricName;
-import com.yammer.metrics.core.MetricPredicate;
-import com.yammer.metrics.core.MetricProcessor;
-import com.yammer.metrics.core.MetricsRegistry;
-import com.yammer.metrics.core.Timer;
-import com.yammer.metrics.reporting.AbstractPollingReporter;
-import com.yammer.metrics.stats.Snapshot;
-
-import java.io.PrintStream;
-import java.text.DateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.Map.Entry;
-import java.util.SortedMap;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-
-/**
- * A simple reporters which prints out application metrics to a
- * {@link PrintStream} periodically.
- */
-public class UtilConsoleReporter extends AbstractPollingReporter implements
-        MetricProcessor<PrintStream> {
-    private static final int CONSOLE_WIDTH = 80;
-
-    /**
-     * Enables the console reporter for the default metrics registry, and causes
-     * it to print to STDOUT with the specified period.
-     */
-    public static void enable(final long period, final TimeUnit unit) {
-        enable(Metrics.defaultRegistry(), period, unit);
-    }
-
-    /**
-     * Enables the console reporter for the given metrics registry, and causes
-     * it to print to STDOUT with the specified period and unrestricted output.
-     */
-    public static void enable(final MetricsRegistry metricsRegistry,
-            final long period, final TimeUnit unit) {
-        final UtilConsoleReporter reporter = new UtilConsoleReporter(
-                metricsRegistry, System.out, MetricPredicate.ALL);
-        reporter.start(period, unit);
-    }
-
-    private final PrintStream out;
-    private final MetricPredicate predicate;
-    private final Clock clock;
-    private final TimeZone timeZone;
-    private final Locale locale;
-
-    /**
-     * Creates a new {@link UtilConsoleReporter} for the default metrics
-     * registry, with unrestricted output.
-     */
-    public UtilConsoleReporter(final PrintStream out) {
-        this(Metrics.defaultRegistry(), out, MetricPredicate.ALL);
-    }
-
-    /**
-     * Creates a new {@link UtilConsoleReporter} for a given metrics registry.
-     */
-    public UtilConsoleReporter(final MetricsRegistry metricsRegistry,
-            final PrintStream out, final MetricPredicate predicate) {
-        this(metricsRegistry, out, predicate, Clock.defaultClock(), TimeZone
-                .getDefault());
-    }
-
-    /**
-     * Creates a new {@link UtilConsoleReporter} for a given metrics registry.
-     */
-    public UtilConsoleReporter(final MetricsRegistry metricsRegistry,
-            final PrintStream out, final MetricPredicate predicate,
-            final Clock clock, final TimeZone timeZone) {
-        this(metricsRegistry, out, predicate, clock, timeZone, Locale
-                .getDefault());
-    }
-
-    /**
-     * Creates a new {@link UtilConsoleReporter} for a given metrics registry.
-     */
-    public UtilConsoleReporter(final MetricsRegistry metricsRegistry,
-            final PrintStream out, final MetricPredicate predicate,
-            final Clock clock, final TimeZone timeZone, final Locale locale) {
-        super(metricsRegistry, "console-reporter");
-        this.out = out;
-        this.predicate = predicate;
-        this.clock = clock;
-        this.timeZone = timeZone;
-        this.locale = locale;
-    }
-
-    @Override
-    public void run() {
-        try {
-            final DateFormat format = DateFormat.getDateTimeInstance(
-                    DateFormat.SHORT, DateFormat.MEDIUM, locale);
-            format.setTimeZone(timeZone);
-            final String dateTime = format.format(new Date(clock.time()));
-            out.print(dateTime);
-            out.print(' ');
-            for (int i = 0; i < CONSOLE_WIDTH - dateTime.length() - 1; i++) {
-                out.print('=');
-            }
-            out.println();
-            for (final Entry<String, SortedMap<MetricName, Metric>> entry : getMetricsRegistry()
-                    .groupedMetrics(predicate).entrySet()) {
-                out.print(entry.getKey());
-                out.println(':');
-                for (final Entry<MetricName, Metric> subEntry : entry
-                        .getValue().entrySet()) {
-                    out.print("  ");
-                    out.print(subEntry.getKey().getName());
-                    out.println(':');
-                    subEntry.getValue().processWith(this, subEntry.getKey(),
-                            out);
-                    out.println();
-                }
-                out.println();
-            }
-            out.println();
-            out.flush();
-        } catch (final Exception e) {
-            e.printStackTrace(out);
-        }
-    }
-
-    @Override
-    public void processGauge(final MetricName name, final Gauge<?> gauge,
-            final PrintStream stream) {
-        stream.printf(locale, "    value = %s\n", gauge.value());
-    }
-
-    @Override
-    public void processCounter(final MetricName name, final Counter counter,
-            final PrintStream stream) {
-        stream.printf(locale, "    count = %,d\n", counter.count());
-    }
-
-    @Override
-    public void processMeter(final MetricName name, final Metered meter,
-            final PrintStream stream) {
-        final String unit = abbrev(meter.rateUnit());
-        stream.printf(locale, "             count = %,d\n", meter.count());
-        stream.printf(locale, "         mean rate = %,2.2f %s/%s\n",
-                meter.meanRate(), meter.eventType(), unit);
-        stream.printf(locale, "     1-minute rate = %,2.2f %s/%s\n",
-                meter.oneMinuteRate(), meter.eventType(), unit);
-        stream.printf(locale, "     5-minute rate = %,2.2f %s/%s\n",
-                meter.fiveMinuteRate(), meter.eventType(), unit);
-        stream.printf(locale, "    15-minute rate = %,2.2f %s/%s\n",
-                meter.fifteenMinuteRate(), meter.eventType(), unit);
-    }
-
-    @Override
-    public void processHistogram(final MetricName name,
-            final Histogram histogram, final PrintStream stream) {
-        final Snapshot snapshot = histogram.getSnapshot();
-        stream.printf(locale, "               min = %,2.2f\n", histogram.min());
-        stream.printf(locale, "               max = %,2.2f\n", histogram.max());
-        stream.printf(locale, "              mean = %,2.2f\n", histogram.mean());
-        stream.printf(locale, "            stddev = %,2.2f\n",
-                histogram.stdDev());
-        stream.printf(locale, "            median = %,2.2f\n",
-                snapshot.getMedian());
-        stream.printf(locale, "              75%% <= %,2.2f\n",
-                snapshot.get75thPercentile());
-        stream.printf(locale, "              95%% <= %,2.2f\n",
-                snapshot.get95thPercentile());
-        stream.printf(locale, "              98%% <= %,2.2f\n",
-                snapshot.get98thPercentile());
-        stream.printf(locale, "              99%% <= %,2.2f\n",
-                snapshot.get99thPercentile());
-        stream.printf(locale, "            99.9%% <= %,2.2f\n",
-                snapshot.get999thPercentile());
-    }
-
-    @Override
-    public void processTimer(final MetricName name, final Timer timer,
-            final PrintStream stream) {
-        processMeter(name, timer, stream);
-        final String durationUnit = abbrev(timer.durationUnit());
-        final Snapshot snapshot = timer.getSnapshot();
-        stream.printf(locale, "               min = %,2.2f %s\n", timer.min(),
-                durationUnit);
-        stream.printf(locale, "               max = %,2.2f %s\n", timer.max(),
-                durationUnit);
-        stream.printf(locale, "              mean = %,2.2f %s\n", timer.mean(),
-                durationUnit);
-        stream.printf(locale, "            stddev = %,2.2f %s\n",
-                timer.stdDev(), durationUnit);
-        stream.printf(locale, "            median = %,2.2f %s\n",
-                snapshot.getMedian(), durationUnit);
-        stream.printf(locale, "              75%% <= %,2.2f %s\n",
-                snapshot.get75thPercentile(), durationUnit);
-        stream.printf(locale, "              95%% <= %,2.2f %s\n",
-                snapshot.get95thPercentile(), durationUnit);
-        stream.printf(locale, "              98%% <= %,2.2f %s\n",
-                snapshot.get98thPercentile(), durationUnit);
-        stream.printf(locale, "              99%% <= %,2.2f %s\n",
-                snapshot.get99thPercentile(), durationUnit);
-        stream.printf(locale, "            99.9%% <= %,2.2f %s\n",
-                snapshot.get999thPercentile(), durationUnit);
-    }
-
-    private static String abbrev(final TimeUnit unit) {
-        switch (unit) {
-        case NANOSECONDS:
-            return "ns";
-        case MICROSECONDS:
-            return "us";
-        case MILLISECONDS:
-            return "ms";
-        case SECONDS:
-            return "s";
-        case MINUTES:
-            return "m";
-        case HOURS:
-            return "h";
-        case DAYS:
-            return "d";
-        default:
-            throw new IllegalArgumentException("Unrecognized TimeUnit: " + unit);
-        }
-    }
-}
diff --git a/example/src/main/java/io/netty/example/uptime/UptimeClient.java b/example/src/main/java/io/netty/example/uptime/UptimeClient.java
index ffc943bdbe60..81ff7c767ff5 100644
--- a/example/src/main/java/io/netty/example/uptime/UptimeClient.java
+++ b/example/src/main/java/io/netty/example/uptime/UptimeClient.java
@@ -16,10 +16,12 @@
 package io.netty.example.uptime;
 
 import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.EventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.timeout.IdleStateHandler;
 
@@ -29,61 +31,48 @@
  * server.  This example demonstrates how to implement reliable reconnection
  * mechanism in Netty.
  */
-public class UptimeClient {
+public final class UptimeClient {
 
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8080"));
     // Sleep 5 seconds before a reconnection attempt.
-    static final int RECONNECT_DELAY = 5;
-
+    static final int RECONNECT_DELAY = Integer.parseInt(System.getProperty("reconnectDelay", "5"));
     // Reconnect when the server sends nothing for 10 seconds.
-    private static final int READ_TIMEOUT = 10;
-
-    private final String host;
-    private final int port;
+    static final int READ_TIMEOUT = Integer.parseInt(System.getProperty("readTimeout", "10"));
 
-    // A single handler will be reused across multiple connection attempts to keep when the last
-    // successful connection attempt was.
-    private final UptimeClientHandler handler = new UptimeClientHandler(this);
+    private static final UptimeClientHandler handler = new UptimeClientHandler();
 
-    public UptimeClient(String host, int port) {
-        this.host = host;
-        this.port = port;
-    }
-
-    public void run() {
+    public static void main(String[] args) throws Exception {
         configureBootstrap(new Bootstrap()).connect();
     }
 
-    private Bootstrap configureBootstrap(Bootstrap b) {
+    private static Bootstrap configureBootstrap(Bootstrap b) {
         return configureBootstrap(b, new NioEventLoopGroup());
     }
 
-    Bootstrap configureBootstrap(Bootstrap b, EventLoopGroup g) {
+    static Bootstrap configureBootstrap(Bootstrap b, EventLoopGroup g) {
         b.group(g)
          .channel(NioSocketChannel.class)
-         .remoteAddress(host, port)
+         .remoteAddress(HOST, PORT)
          .handler(new ChannelInitializer<SocketChannel>() {
-            @Override
-            public void initChannel(SocketChannel ch) throws Exception {
-                ch.pipeline().addLast(new IdleStateHandler(READ_TIMEOUT, 0, 0), handler);
-            }
+             @Override
+             public void initChannel(SocketChannel ch) throws Exception {
+                 ch.pipeline().addLast(new IdleStateHandler(READ_TIMEOUT, 0, 0), handler);
+             }
          });
 
         return b;
     }
 
-    public static void main(String[] args) throws Exception {
-        // Print usage if no argument is specified.
-        if (args.length != 2) {
-            System.err.println(
-                    "Usage: " + UptimeClient.class.getSimpleName() +
-                    " <host> <port>");
-            return;
-        }
-
-        // Parse options.
-        String host = args[0];
-        int port = Integer.parseInt(args[1]);
-
-        new UptimeClient(host, port).run();
+    static void connect(Bootstrap b) {
+        b.connect().addListener(new ChannelFutureListener() {
+            @Override
+            public void operationComplete(ChannelFuture future) throws Exception {
+                if (future.cause() != null) {
+                    handler.startTime = -1;
+                    handler.println("Failed to connect: " + future.cause());
+                }
+            }
+        });
     }
 }
diff --git a/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java b/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
index 88444ac7ccd1..493465d90fa0 100644
--- a/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
+++ b/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
@@ -23,7 +23,6 @@
 import io.netty.handler.timeout.IdleState;
 import io.netty.handler.timeout.IdleStateEvent;
 
-import java.net.ConnectException;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -33,15 +32,10 @@
 @Sharable
 public class UptimeClientHandler extends SimpleChannelInboundHandler<Object> {
 
-    private final UptimeClient client;
-    private long startTime = -1;
-
-    public UptimeClientHandler(UptimeClient client) {
-        this.client = client;
-    }
+    long startTime = -1;
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+    public void channelActive(ChannelHandlerContext ctx) {
         if (startTime < 0) {
             startTime = System.currentTimeMillis();
         }
@@ -54,7 +48,7 @@ public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception
     }
 
     @Override
-    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
         if (!(evt instanceof IdleStateEvent)) {
             return;
         }
@@ -68,31 +62,26 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+    public void channelInactive(final ChannelHandlerContext ctx) {
         println("Disconnected from: " + ctx.channel().remoteAddress());
     }
 
     @Override
-    public void channelUnregistered(final ChannelHandlerContext ctx)
-            throws Exception {
+    public void channelUnregistered(final ChannelHandlerContext ctx) throws Exception {
         println("Sleeping for: " + UptimeClient.RECONNECT_DELAY + 's');
 
         final EventLoop loop = ctx.channel().eventLoop();
         loop.schedule(new Runnable() {
             @Override
             public void run() {
-                println("Reconnecting to: " + ctx.channel().remoteAddress());
-                client.configureBootstrap(new Bootstrap(), loop).connect();
+                println("Reconnecting to: " + UptimeClient.HOST + ':' + UptimeClient.PORT);
+                UptimeClient.connect(UptimeClient.configureBootstrap(new Bootstrap(), loop));
             }
         }, UptimeClient.RECONNECT_DELAY, TimeUnit.SECONDS);
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        if (cause instanceof ConnectException) {
-            startTime = -1;
-            println("Failed to connect: " + cause.getMessage());
-        }
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
         cause.printStackTrace();
         ctx.close();
     }
diff --git a/example/src/main/java/io/netty/example/worldclock/WorldClockClient.java b/example/src/main/java/io/netty/example/worldclock/WorldClockClient.java
index 48d1d7116d1b..4b2ca5424f19 100644
--- a/example/src/main/java/io/netty/example/worldclock/WorldClockClient.java
+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockClient.java
@@ -20,101 +20,58 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
+import java.util.Arrays;
 import java.util.List;
-import java.util.regex.Pattern;
 
 /**
  * Sends a list of continent/city pairs to a {@link WorldClockServer} to
  * get the local times of the specified cities.
  */
-public class WorldClockClient {
+public final class WorldClockClient {
 
-    private final String host;
-    private final int port;
-    private final Collection<String> cities;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final String HOST = System.getProperty("host", "127.0.0.1");
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8463"));
+    static final List<String> CITIES = Arrays.asList(System.getProperty(
+            "cities", "Asia/Seoul,Europe/Berlin,America/Los_Angeles").split(","));
 
-    public WorldClockClient(String host, int port, Collection<String> cities) {
-        this.host = host;
-        this.port = port;
-        this.cities = new ArrayList<String>();
-        this.cities.addAll(cities);
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
             b.group(group)
              .channel(NioSocketChannel.class)
-             .handler(new WorldClockClientInitializer());
+             .handler(new WorldClockClientInitializer(sslCtx));
 
             // Make a new connection.
-            Channel ch = b.connect(host, port).sync().channel();
+            Channel ch = b.connect(HOST, PORT).sync().channel();
 
             // Get the handler instance to initiate the request.
-            WorldClockClientHandler handler =
-                ch.pipeline().get(WorldClockClientHandler.class);
+            WorldClockClientHandler handler = ch.pipeline().get(WorldClockClientHandler.class);
 
             // Request and get the response.
-            List<String> response = handler.getLocalTimes(cities);
+            List<String> response = handler.getLocalTimes(CITIES);
 
             // Close the connection.
             ch.close();
 
             // Print the response at last but not least.
-            Iterator<String> i1 = cities.iterator();
-            Iterator<String> i2 = response.iterator();
-            while (i1.hasNext()) {
-                System.out.format("%28s: %s%n", i1.next(), i2.next());
+            for (int i = 0; i < CITIES.size(); i ++) {
+                System.out.format("%28s: %s%n", CITIES.get(i), response.get(i));
             }
         } finally {
             group.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        // Print usage if necessary.
-        if (args.length < 3) {
-            printUsage();
-            return;
-        }
-
-        // Parse options.
-        String host = args[0];
-        int port = Integer.parseInt(args[1]);
-        Collection<String> cities = parseCities(args, 2);
-        if (cities == null) {
-            return;
-        }
-
-        new WorldClockClient(host, port, cities).run();
-    }
-
-    private static void printUsage() {
-        System.err.println(
-                "Usage: " + WorldClockClient.class.getSimpleName() +
-                " <host> <port> <continent/city_name> ...");
-        System.err.println(
-                "Example: " + WorldClockClient.class.getSimpleName() +
-                " localhost 8080 America/New_York Asia/Seoul");
-    }
-
-    private static final Pattern CITY_PATTERN = Pattern.compile("^[_A-Za-z]+/[_A-Za-z]+$");
-
-    private static List<String> parseCities(String[] args, int offset) {
-        List<String> cities = new ArrayList<String>();
-        for (int i = offset; i < args.length; i ++) {
-            if (!CITY_PATTERN.matcher(args[i]).matches()) {
-                System.err.println("Syntax error: '" + args[i] + '\'');
-                printUsage();
-                return null;
-            }
-            cities.add(args[i].trim());
-        }
-        return cities;
-    }
 }
diff --git a/example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java b/example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java
index 1bf321340c3e..3909624980dc 100644
--- a/example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java
+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java
@@ -30,15 +30,10 @@
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import java.util.regex.Pattern;
 
 public class WorldClockClientHandler extends SimpleChannelInboundHandler<LocalTimes> {
 
-    private static final Logger logger = Logger.getLogger(
-            WorldClockClientHandler.class.getName());
-
     private static final Pattern DELIM = Pattern.compile("/");
 
     // Stateful properties
@@ -67,7 +62,7 @@ public List<String> getLocalTimes(Collection<String> cities) {
             try {
                 localTimes = answer.take();
                 break;
-            } catch (InterruptedException e) {
+            } catch (InterruptedException ignore) {
                 interrupted = true;
             }
         }
@@ -94,7 +89,7 @@ public List<String> getLocalTimes(Collection<String> cities) {
     }
 
     @Override
-    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
+    public void channelRegistered(ChannelHandlerContext ctx) {
         channel = ctx.channel();
     }
 
@@ -104,10 +99,8 @@ public void channelRead0(ChannelHandlerContext ctx, LocalTimes times) throws Exc
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/worldclock/WorldClockClientInitializer.java b/example/src/main/java/io/netty/example/worldclock/WorldClockClientInitializer.java
index bfe67bb82726..1169ea281c3b 100644
--- a/example/src/main/java/io/netty/example/worldclock/WorldClockClientInitializer.java
+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockClientInitializer.java
@@ -22,18 +22,29 @@
 import io.netty.handler.codec.protobuf.ProtobufEncoder;
 import io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;
 import io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;
+import io.netty.handler.ssl.SslContext;
 
 public class WorldClockClientInitializer extends ChannelInitializer<SocketChannel> {
 
+    private final SslContext sslCtx;
+
+    public WorldClockClientInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
+
     @Override
-    public void initChannel(SocketChannel ch) throws Exception {
+    public void initChannel(SocketChannel ch) {
         ChannelPipeline p = ch.pipeline();
-        p.addLast("frameDecoder", new ProtobufVarint32FrameDecoder());
-        p.addLast("protobufDecoder", new ProtobufDecoder(WorldClockProtocol.LocalTimes.getDefaultInstance()));
+        if (sslCtx != null) {
+            p.addLast(sslCtx.newHandler(ch.alloc(), WorldClockClient.HOST, WorldClockClient.PORT));
+        }
+
+        p.addLast(new ProtobufVarint32FrameDecoder());
+        p.addLast(new ProtobufDecoder(WorldClockProtocol.LocalTimes.getDefaultInstance()));
 
-        p.addLast("frameEncoder", new ProtobufVarint32LengthFieldPrepender());
-        p.addLast("protobufEncoder", new ProtobufEncoder());
+        p.addLast(new ProtobufVarint32LengthFieldPrepender());
+        p.addLast(new ProtobufEncoder());
 
-        p.addLast("handler", new WorldClockClientHandler());
+        p.addLast(new WorldClockClientHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/worldclock/WorldClockServer.java b/example/src/main/java/io/netty/example/worldclock/WorldClockServer.java
index af47fd55f267..1900f3c37c57 100644
--- a/example/src/main/java/io/netty/example/worldclock/WorldClockServer.java
+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockServer.java
@@ -19,42 +19,43 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 
 /**
  * Receives a list of continent/city pairs from a {@link WorldClockClient} to
  * get the local times of the specified cities.
  */
-public class WorldClockServer {
+public final class WorldClockServer {
 
-    private final int port;
+    static final boolean SSL = System.getProperty("ssl") != null;
+    static final int PORT = Integer.parseInt(System.getProperty("port", "8463"));
 
-    public WorldClockServer(int port) {
-        this.port = port;
-    }
+    public static void main(String[] args) throws Exception {
+        // Configure SSL.
+        final SslContext sslCtx;
+        if (SSL) {
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            sslCtx = SslContext.newServerContext(ssc.certificate(), ssc.privateKey());
+        } else {
+            sslCtx = null;
+        }
 
-    public void run() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
         EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
             b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
-             .childHandler(new WorldClockServerInitializer());
+             .handler(new LoggingHandler(LogLevel.INFO))
+             .childHandler(new WorldClockServerInitializer(sslCtx));
 
-            b.bind(port).sync().channel().closeFuture().sync();
+            b.bind(PORT).sync().channel().closeFuture().sync();
         } finally {
             bossGroup.shutdownGracefully();
             workerGroup.shutdownGracefully();
         }
     }
-
-    public static void main(String[] args) throws Exception {
-        int port;
-        if (args.length > 0) {
-            port = Integer.parseInt(args[0]);
-        } else {
-            port = 8080;
-        }
-        new WorldClockServer(port).run();
-    }
 }
diff --git a/example/src/main/java/io/netty/example/worldclock/WorldClockServerHandler.java b/example/src/main/java/io/netty/example/worldclock/WorldClockServerHandler.java
index 239713edb5e9..b30eef4095d1 100644
--- a/example/src/main/java/io/netty/example/worldclock/WorldClockServerHandler.java
+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockServerHandler.java
@@ -26,16 +26,11 @@
 
 import java.util.Calendar;
 import java.util.TimeZone;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import static java.util.Calendar.*;
 
 public class WorldClockServerHandler extends SimpleChannelInboundHandler<Locations> {
 
-    private static final Logger logger = Logger.getLogger(
-            WorldClockServerHandler.class.getName());
-
     @Override
     public void channelRead0(ChannelHandlerContext ctx, Locations locations) throws Exception {
         long currentTime = System.currentTimeMillis();
@@ -61,15 +56,13 @@ public void channelRead0(ChannelHandlerContext ctx, Locations locations) throws
     }
 
     @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+    public void channelReadComplete(ChannelHandlerContext ctx) {
         ctx.flush();
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        logger.log(
-                Level.WARNING,
-                "Unexpected exception from downstream.", cause);
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        cause.printStackTrace();
         ctx.close();
     }
 
diff --git a/example/src/main/java/io/netty/example/worldclock/WorldClockServerInitializer.java b/example/src/main/java/io/netty/example/worldclock/WorldClockServerInitializer.java
index 13fe454ad99e..cc0d63555962 100644
--- a/example/src/main/java/io/netty/example/worldclock/WorldClockServerInitializer.java
+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockServerInitializer.java
@@ -22,17 +22,29 @@
 import io.netty.handler.codec.protobuf.ProtobufEncoder;
 import io.netty.handler.codec.protobuf.ProtobufVarint32FrameDecoder;
 import io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;
+import io.netty.handler.ssl.SslContext;
 
 public class WorldClockServerInitializer extends ChannelInitializer<SocketChannel> {
+
+    private final SslContext sslCtx;
+
+    public WorldClockServerInitializer(SslContext sslCtx) {
+        this.sslCtx = sslCtx;
+    }
+
     @Override
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline p = ch.pipeline();
-        p.addLast("frameDecoder", new ProtobufVarint32FrameDecoder());
-        p.addLast("protobufDecoder", new ProtobufDecoder(WorldClockProtocol.Locations.getDefaultInstance()));
+        if (sslCtx != null) {
+            p.addLast(sslCtx.newHandler(ch.alloc()));
+        }
+
+        p.addLast(new ProtobufVarint32FrameDecoder());
+        p.addLast(new ProtobufDecoder(WorldClockProtocol.Locations.getDefaultInstance()));
 
-        p.addLast("frameEncoder", new ProtobufVarint32LengthFieldPrepender());
-        p.addLast("protobufEncoder", new ProtobufEncoder());
+        p.addLast(new ProtobufVarint32LengthFieldPrepender());
+        p.addLast(new ProtobufEncoder());
 
-        p.addLast("handler", new WorldClockServerHandler());
+        p.addLast(new WorldClockServerHandler());
     }
 }
diff --git a/example/src/main/resources/cors/cors.html b/example/src/main/resources/cors/cors.html
index ad5a75b69933..f443a641dd1c 100644
--- a/example/src/main/resources/cors/cors.html
+++ b/example/src/main/resources/cors/cors.html
@@ -10,7 +10,7 @@ <h1>Repsonse from Server</h1>
         <textarea id="responseText"></textarea>
         <script>
             function simpleGetRequest() {
-                var xhr = new XMLHttpRequest()
+                var xhr = new XMLHttpRequest();
                 xhr.open('GET', 'http://localhost:8080/cors');
 
                 // Uncomment to force a CORS preflight request.
@@ -18,13 +18,13 @@ <h1>Repsonse from Server</h1>
 
                 xhr.onerror = function() {
                     getTextAreaElement().value = 'CORS is NOT working';
-                }
+                };
 
                 xhr.onload = function() {
                     getTextAreaElement().value = 'CORS is working';
                     //var header = xhr.getResponseHeader("custom-response-header");
                     //appendTextArea('custom-response-header=' + header);
-                }
+                };
 
                 function getTextAreaElement() {
                     return document.getElementById('responseText');
diff --git a/example/src/main/resources/websocketx/html5/css/socket.css b/example/src/main/resources/websocketx/html5/css/socket.css
deleted file mode 100644
index c50fdef00efa..000000000000
--- a/example/src/main/resources/websocketx/html5/css/socket.css
+++ /dev/null
@@ -1,4 +0,0 @@
-textarea {
-    width: 500px;
-    height: 300px;
-}
\ No newline at end of file
diff --git a/example/src/main/resources/websocketx/html5/js/socket.js b/example/src/main/resources/websocketx/html5/js/socket.js
deleted file mode 100644
index 70c99a631554..000000000000
--- a/example/src/main/resources/websocketx/html5/js/socket.js
+++ /dev/null
@@ -1,50 +0,0 @@
-(function() {
-    var Sock = function() {
-        var socket;
-        if (!window.WebSocket) {
-            window.WebSocket = window.MozWebSocket;
-        }
-
-        if (window.WebSocket) {
-            socket = new WebSocket("ws://localhost:8080/websocket");
-            socket.onopen = onopen;
-            socket.onmessage = onmessage;
-            socket.onclose = onclose;
-        } else {
-            alert("Your browser does not support Web Socket.");
-        }
-
-        function onopen(event) {
-            getTextAreaElement().value = "Web Socket opened!";
-        }
-
-        function onmessage(event) {
-            appendTextArea(event.data);
-        }
-        function onclose(event) {
-            appendTextArea("Web Socket closed");
-        }
-
-        function appendTextArea(newData) {
-            var el = getTextAreaElement();
-            el.value = el.value + '\n' + newData;
-        }
-
-        function getTextAreaElement() {
-            return document.getElementById('responseText');
-        }
-
-        function send(event) {
-            event.preventDefault();
-            if (window.WebSocket) {
-                if (socket.readyState == WebSocket.OPEN) {
-                    socket.send(event.target.message.value);
-                } else {
-                    alert("The socket is not open.");
-                }
-            }
-        }
-        document.forms.inputform.addEventListener('submit', send, false);
-    }
-    window.addEventListener('load', function() { new Sock(); }, false);
-})();
diff --git a/example/src/main/resources/websocketx/html5/websocket.html b/example/src/main/resources/websocketx/html5/websocket.html
deleted file mode 100644
index f80d25a22cb1..000000000000
--- a/example/src/main/resources/websocketx/html5/websocket.html
+++ /dev/null
@@ -1,18 +0,0 @@
-<!DOCTYPE html>
-<html lang="en">
-    <head>
-        <meta charset="utf-8">
-        <title>Web Socket Example</title>
-        <link rel="stylesheet" href="css/socket.css">
-        <script src="js/socket.js"></script>
-    </head>
-    <body>
-        <h1>Enter a message</h1>
-        <form name="inputform">
-            <input type="text" name="message" id="message" placeholder="Enter text to be sent" autofocus>
-            <input type="submit" value="Send Web Socket Data">
-        </form>
-        <h2>Repsonse from Server</h2>
-        <textarea id="responseText"></textarea>
-    </body>
-</html>
diff --git a/handler/pom.xml b/handler/pom.xml
index 1186635c8be6..8ecd8ef3a20f 100644
--- a/handler/pom.xml
+++ b/handler/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-handler</artifactId>
@@ -44,6 +44,28 @@
       <artifactId>netty-codec</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-tcnative</artifactId>
+      <classifier>${os.detected.classifier}</classifier>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcpkix-jdk15on</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.jetty.npn</groupId>
+      <artifactId>npn-api</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty.npn</groupId>
+      <artifactId>npn-boot</artifactId>
+      <scope>provided</scope>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
 </project>
 
diff --git a/handler/src/main/java/io/netty/handler/ipfilter/AbstractRemoteAddressFilter.java b/handler/src/main/java/io/netty/handler/ipfilter/AbstractRemoteAddressFilter.java
new file mode 100644
index 000000000000..a0a2c1e12ddd
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ipfilter/AbstractRemoteAddressFilter.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ipfilter;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+
+import java.net.SocketAddress;
+
+/**
+ * This class provides the functionality to either accept or reject new {@link Channel}s
+ * based on their IP address.
+ * <p>
+ * You should inherit from this class if you would like to implement your own IP-based filter. Basically you have to
+ * implement {@link #accept(ChannelHandlerContext, SocketAddress)} to decided whether you want to accept or reject
+ * a connection from the remote address.
+ * <p>
+ * Furthermore overriding {@link #channelRejected(ChannelHandlerContext, SocketAddress)} gives you the
+ * flexibility to respond to rejected (denied) connections. If you do not want to send a response, just have it return
+ * null.  Take a look at {@link RuleBasedIpFilter} for details.
+ */
+public abstract class AbstractRemoteAddressFilter<T extends SocketAddress> extends ChannelInboundHandlerAdapter {
+
+    @Override
+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
+        handleNewChannel(ctx);
+        ctx.fireChannelRegistered();
+    }
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        if (!handleNewChannel(ctx)) {
+            throw new IllegalStateException("cannot determine to accept or reject a channel: " + ctx.channel());
+        } else {
+            ctx.fireChannelActive();
+        }
+    }
+
+    private boolean handleNewChannel(ChannelHandlerContext ctx) throws Exception {
+        @SuppressWarnings("unchecked")
+        T remoteAddress = (T) ctx.channel().remoteAddress();
+
+        // If the remote address is not available yet, defer the decision.
+        if (remoteAddress == null) {
+            return false;
+        }
+
+        // No need to keep this handler in the pipeline anymore because the decision is going to be made now.
+        // Also, this will prevent the subsequent events from being handled by this handler.
+        ctx.pipeline().remove(this);
+
+        if (accept(ctx, remoteAddress)) {
+            channelAccepted(ctx, remoteAddress);
+        } else {
+            ChannelFuture rejectedFuture = channelRejected(ctx, remoteAddress);
+            if (rejectedFuture != null) {
+                rejectedFuture.addListener(ChannelFutureListener.CLOSE);
+            } else {
+                ctx.close();
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * This method is called immediately after a {@link io.netty.channel.Channel} gets registered.
+     *
+     * @return Return true if connections from this IP address and port should be accepted. False otherwise.
+     */
+    protected abstract boolean accept(ChannelHandlerContext ctx, T remoteAddress) throws Exception;
+
+    /**
+     * This method is called if {@code remoteAddress} gets accepted by
+     * {@link #accept(ChannelHandlerContext, SocketAddress)}.  You should override it if you would like to handle
+     * (e.g. respond to) accepted addresses.
+     */
+    @SuppressWarnings("UnusedParameters")
+    protected void channelAccepted(ChannelHandlerContext ctx, T remoteAddress) { }
+
+    /**
+     * This method is called if {@code remoteAddress} gets rejected by
+     * {@link #accept(ChannelHandlerContext, SocketAddress)}.  You should override it if you would like to handle
+     * (e.g. respond to) rejected addresses.
+     *
+     * @return A {@link ChannelFuture} if you perform I/O operations, so that
+     *         the {@link Channel} can be closed once it completes. Null otherwise.
+     */
+    @SuppressWarnings("UnusedParameters")
+    protected ChannelFuture channelRejected(ChannelHandlerContext ctx, T remoteAddress) {
+        return null;
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java
new file mode 100644
index 000000000000..2883734a20b3
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ipfilter;
+
+import java.net.InetSocketAddress;
+
+/**
+ * Implement this interface to create new rules.
+ */
+public interface IpFilterRule {
+    /**
+     * @return This method should return true if remoteAddress is valid according to your criteria. False otherwise.
+     */
+    boolean matches(InetSocketAddress remoteAddress);
+
+    /**
+     * @return This method should return {@link IpFilterRuleType#ACCEPT} if all
+     * {@link IpFilterRule#matches(InetSocketAddress)} for which {@link #matches(InetSocketAddress)}
+     * returns true should the accepted. If you want to exclude all of those IP addresses then
+     * {@link IpFilterRuleType#REJECT} should be returned.
+     */
+    IpFilterRuleType ruleType();
+}
diff --git a/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleType.java b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleType.java
new file mode 100644
index 000000000000..7c2deedc9a79
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleType.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ipfilter;
+
+/**
+ * Used in {@link IpFilterRule} to decide if a matching IP Address should be allowed or denied to connect.
+ */
+public enum IpFilterRuleType {
+    ACCEPT,
+    REJECT
+}
diff --git a/handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java b/handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java
new file mode 100644
index 000000000000..2e6545012b40
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ipfilter;
+
+import java.math.BigInteger;
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+
+/**
+ * Use this class to create rules for {@link RuleBasedIpFilter} that group IP addresses into subnets.
+ * Supports both, IPv4 and IPv6.
+ */
+public final class IpSubnetFilterRule implements IpFilterRule {
+
+    private final IpFilterRule filterRule;
+
+    public IpSubnetFilterRule(String ipAddress, int cidrPrefix, IpFilterRuleType ruleType) {
+        try {
+            filterRule = selectFilterRule(InetAddress.getByName(ipAddress), cidrPrefix, ruleType);
+        } catch (UnknownHostException e) {
+            throw new IllegalArgumentException("ipAddress", e);
+        }
+    }
+
+    public IpSubnetFilterRule(InetAddress ipAddress, int cidrPrefix, IpFilterRuleType ruleType) {
+        filterRule = selectFilterRule(ipAddress, cidrPrefix, ruleType);
+    }
+
+    private static IpFilterRule selectFilterRule(InetAddress ipAddress, int cidrPrefix, IpFilterRuleType ruleType) {
+        if (ipAddress == null) {
+            throw new NullPointerException("ipAddress");
+        }
+
+        if (ruleType == null) {
+            throw new NullPointerException("ruleType");
+        }
+
+        if (ipAddress instanceof Inet4Address) {
+            return new Ip4SubnetFilterRule((Inet4Address) ipAddress, cidrPrefix, ruleType);
+        } else if (ipAddress instanceof Inet6Address) {
+            return new Ip6SubnetFilterRule((Inet6Address) ipAddress, cidrPrefix, ruleType);
+        } else {
+            throw new IllegalArgumentException("Only IPv4 and IPv6 addresses are supported");
+        }
+    }
+
+    @Override
+    public boolean matches(InetSocketAddress remoteAddress) {
+        return filterRule.matches(remoteAddress);
+    }
+
+    @Override
+    public IpFilterRuleType ruleType() {
+        return filterRule.ruleType();
+    }
+
+    private static final class Ip4SubnetFilterRule implements IpFilterRule {
+
+        private final int networkAddress;
+        private final int subnetMask;
+        private final IpFilterRuleType ruleType;
+
+        private Ip4SubnetFilterRule(Inet4Address ipAddress, int cidrPrefix, IpFilterRuleType ruleType) {
+            if (cidrPrefix < 0 || cidrPrefix > 32) {
+                throw new IllegalArgumentException(String.format("IPv4 requires the subnet prefix to be in range of " +
+                                                                    "[0,32]. The prefix was: %d", cidrPrefix));
+            }
+
+            subnetMask = prefixToSubnetMask(cidrPrefix);
+            networkAddress = ipToInt(ipAddress) & subnetMask;
+            this.ruleType = ruleType;
+        }
+
+        @Override
+        public boolean matches(InetSocketAddress remoteAddress) {
+            int ipAddress = ipToInt((Inet4Address) remoteAddress.getAddress());
+
+            return (ipAddress & subnetMask) == networkAddress;
+        }
+
+        @Override
+        public IpFilterRuleType ruleType() {
+            return ruleType;
+        }
+
+        private static int ipToInt(Inet4Address ipAddress) {
+            byte[] octets = ipAddress.getAddress();
+            assert octets.length == 4;
+
+            return (octets[0] & 0xff) << 24 |
+                   (octets[1] & 0xff) << 16 |
+                   (octets[2] & 0xff) << 8 |
+                    octets[3] & 0xff;
+        }
+
+        private static int prefixToSubnetMask(int cidrPrefix) {
+            return -1 << 32 - cidrPrefix;
+        }
+    }
+
+    private static final class Ip6SubnetFilterRule implements IpFilterRule {
+
+        private static final BigInteger MINUS_ONE = BigInteger.valueOf(-1);
+
+        private final BigInteger networkAddress;
+        private final BigInteger subnetMask;
+        private final IpFilterRuleType ruleType;
+
+        private Ip6SubnetFilterRule(Inet6Address ipAddress, int cidrPrefix, IpFilterRuleType ruleType) {
+            if (cidrPrefix < 0 || cidrPrefix > 128) {
+                throw new IllegalArgumentException(String.format("IPv6 requires the subnet prefix to be in range of " +
+                                                                    "[0,128]. The prefix was: %d", cidrPrefix));
+            }
+
+            subnetMask = prefixToSubnetMask(cidrPrefix);
+            networkAddress = ipToInt(ipAddress).and(subnetMask);
+            this.ruleType = ruleType;
+        }
+
+        @Override
+        public boolean matches(InetSocketAddress remoteAddress) {
+            BigInteger ipAddress = ipToInt((Inet6Address) remoteAddress.getAddress());
+
+            return ipAddress.and(subnetMask).equals(networkAddress);
+        }
+
+        @Override
+        public IpFilterRuleType ruleType() {
+            return ruleType;
+        }
+
+        private static BigInteger ipToInt(Inet6Address ipAddress) {
+            byte[] octets = ipAddress.getAddress();
+            assert octets.length == 16;
+
+            return new BigInteger(octets);
+        }
+
+        private static BigInteger prefixToSubnetMask(int cidrPrefix) {
+            return MINUS_ONE.shiftLeft(128 - cidrPrefix);
+        }
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java b/handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java
new file mode 100644
index 000000000000..66ffa4545fa6
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ipfilter;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandler.Sharable;
+import io.netty.channel.ChannelHandlerContext;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+
+/**
+ * This class allows one to filter new {@link Channel}s based on the
+ * {@link IpFilterRule}s passed to its constructor. If no rules are provided, all connections
+ * will be accepted.
+ *
+ * If you would like to explicitly take action on rejected {@link Channel}s, you should override
+ * {@link #channelRejected(ChannelHandlerContext, SocketAddress)}.
+ */
+@Sharable
+public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {
+
+    private final IpFilterRule[] rules;
+
+    public RuleBasedIpFilter(IpFilterRule... rules) {
+        if (rules == null) {
+            throw new NullPointerException("rules");
+        }
+
+        this.rules = rules;
+    }
+
+    @Override
+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {
+        for (IpFilterRule rule : rules) {
+            if (rule == null) {
+                break;
+            }
+
+            if (rule.matches(remoteAddress)) {
+                return rule.ruleType() == IpFilterRuleType.ACCEPT;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ipfilter/UniqueIpFilter.java b/handler/src/main/java/io/netty/handler/ipfilter/UniqueIpFilter.java
new file mode 100644
index 000000000000..ac346481d734
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ipfilter/UniqueIpFilter.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ipfilter;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.ConcurrentSet;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.util.Set;
+
+/**
+ * This class allows one to ensure that at all times for every IP address there is at most one
+ * {@link Channel} connected to the server.
+ */
+@ChannelHandler.Sharable
+public class UniqueIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {
+
+    private final Set<InetAddress> connected = new ConcurrentSet<InetAddress>();
+
+    @Override
+    protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {
+        final InetAddress remoteIp = remoteAddress.getAddress();
+        if (connected.contains(remoteIp)) {
+            return false;
+        } else {
+            connected.add(remoteIp);
+            ctx.channel().closeFuture().addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    connected.remove(remoteIp);
+                }
+            });
+            return true;
+        }
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ipfilter/package-info.java b/handler/src/main/java/io/netty/handler/ipfilter/package-info.java
new file mode 100644
index 000000000000..c97c430f5849
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ipfilter/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Package to filter IP addresses (allow/deny).
+ */
+package io.netty.handler.ipfilter;
diff --git a/handler/src/main/java/io/netty/handler/logging/LogLevel.java b/handler/src/main/java/io/netty/handler/logging/LogLevel.java
index c6a643c25bf1..688c21264c46 100644
--- a/handler/src/main/java/io/netty/handler/logging/LogLevel.java
+++ b/handler/src/main/java/io/netty/handler/logging/LogLevel.java
@@ -17,6 +17,9 @@
 
 import io.netty.util.internal.logging.InternalLogLevel;
 
+/**
+ * Maps the regular {@link LogLevel}s with the {@link InternalLogLevel} ones.
+ */
 public enum LogLevel {
     TRACE(InternalLogLevel.TRACE),
     DEBUG(InternalLogLevel.DEBUG),
@@ -30,6 +33,11 @@ public enum LogLevel {
         this.internalLevel = internalLevel;
     }
 
+    /**
+     * Converts the specified {@link LogLevel} to its {@link InternalLogLevel} variant.
+     *
+     * @return the converted level.
+     */
     InternalLogLevel toInternalLevel() {
         return internalLevel;
     }
diff --git a/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
index c35aa8ae3388..b84243bf84b3 100644
--- a/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
@@ -21,6 +21,7 @@
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.channel.ChannelPromise;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogLevel;
@@ -34,16 +35,18 @@
  * By default, all events are logged at <tt>DEBUG</tt> level.
  */
 @Sharable
+@SuppressWarnings({ "StringConcatenationInsideStringBufferAppend", "StringBufferReplaceableByString" })
 public class LoggingHandler extends ChannelDuplexHandler {
 
     private static final LogLevel DEFAULT_LEVEL = LogLevel.DEBUG;
 
-    private static final String NEWLINE = String.format("%n");
+    private static final String NEWLINE = StringUtil.NEWLINE;
 
     private static final String[] BYTE2HEX = new String[256];
     private static final String[] HEXPADDING = new String[16];
     private static final String[] BYTEPADDING = new String[16];
     private static final char[] BYTE2CHAR = new char[256];
+    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];
 
     static {
         int i;
@@ -81,6 +84,16 @@ public class LoggingHandler extends ChannelDuplexHandler {
                 BYTE2CHAR[i] = (char) i;
             }
         }
+
+        // Generate the lookup table for the start-offset header in each row (up to 64KiB).
+        for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i ++) {
+            StringBuilder buf = new StringBuilder(12);
+            buf.append(NEWLINE);
+            buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));
+            buf.setCharAt(buf.length() - 9, '|');
+            buf.append('|');
+            HEXDUMP_ROWPREFIXES[i] = buf.toString();
+        }
     }
 
     protected final InternalLogger logger;
@@ -100,7 +113,7 @@ public LoggingHandler() {
      * Creates a new instance whose logger name is the fully qualified class
      * name of the instance.
      *
-     * @param level   the log level
+     * @param level the log level
      */
     public LoggingHandler(LogLevel level) {
         if (level == null) {
@@ -115,6 +128,8 @@ public LoggingHandler(LogLevel level) {
     /**
      * Creates a new instance with the specified logger name and with hex dump
      * enabled.
+     *
+     * @param clazz the class type to generate the logger for
      */
     public LoggingHandler(Class<?> clazz) {
         this(clazz, DEFAULT_LEVEL);
@@ -123,7 +138,8 @@ public LoggingHandler(Class<?> clazz) {
     /**
      * Creates a new instance with the specified logger name.
      *
-     * @param level   the log level
+     * @param clazz the class type to generate the logger for
+     * @param level the log level
      */
     public LoggingHandler(Class<?> clazz, LogLevel level) {
         if (clazz == null) {
@@ -132,13 +148,16 @@ public LoggingHandler(Class<?> clazz, LogLevel level) {
         if (level == null) {
             throw new NullPointerException("level");
         }
+
         logger = InternalLoggerFactory.getInstance(clazz);
         this.level = level;
         internalLevel = level.toInternalLevel();
     }
 
     /**
-     * Creates a new instance with the specified logger name.
+     * Creates a new instance with the specified logger name using the default log level.
+     *
+     * @param name the name of the class to use for the logger
      */
     public LoggingHandler(String name) {
         this(name, DEFAULT_LEVEL);
@@ -147,7 +166,8 @@ public LoggingHandler(String name) {
     /**
      * Creates a new instance with the specified logger name.
      *
-     * @param level   the log level
+     * @param name the name of the class to use for the logger
+     * @param level the log level
      */
     public LoggingHandler(String name, LogLevel level) {
         if (name == null) {
@@ -156,6 +176,7 @@ public LoggingHandler(String name, LogLevel level) {
         if (level == null) {
             throw new NullPointerException("level");
         }
+
         logger = InternalLoggerFactory.getInstance(name);
         this.level = level;
         internalLevel = level.toInternalLevel();
@@ -168,124 +189,109 @@ public LogLevel level() {
         return level;
     }
 
-    protected String format(ChannelHandlerContext ctx, String message) {
-        String chStr = ctx.channel().toString();
-        StringBuilder buf = new StringBuilder(chStr.length() + message.length() + 1);
-        buf.append(chStr);
-        buf.append(' ');
-        buf.append(message);
-        return buf.toString();
-    }
-
     @Override
-    public void channelRegistered(ChannelHandlerContext ctx)
-            throws Exception {
+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
         if (logger.isEnabled(internalLevel)) {
             logger.log(internalLevel, format(ctx, "REGISTERED"));
         }
-        super.channelRegistered(ctx);
+        ctx.fireChannelRegistered();
     }
 
     @Override
-    public void channelUnregistered(ChannelHandlerContext ctx)
-            throws Exception {
+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
         if (logger.isEnabled(internalLevel)) {
             logger.log(internalLevel, format(ctx, "UNREGISTERED"));
         }
-        super.channelUnregistered(ctx);
+        ctx.fireChannelUnregistered();
     }
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx)
-            throws Exception {
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
         if (logger.isEnabled(internalLevel)) {
             logger.log(internalLevel, format(ctx, "ACTIVE"));
         }
-        super.channelActive(ctx);
+        ctx.fireChannelActive();
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx)
-            throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         if (logger.isEnabled(internalLevel)) {
             logger.log(internalLevel, format(ctx, "INACTIVE"));
         }
-        super.channelInactive(ctx);
+        ctx.fireChannelInactive();
     }
 
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx,
-            Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, "EXCEPTION: " + cause), cause);
+            logger.log(internalLevel, format(ctx, "EXCEPTION", cause), cause);
         }
-        super.exceptionCaught(ctx, cause);
+        ctx.fireExceptionCaught(cause);
     }
 
     @Override
-    public void userEventTriggered(ChannelHandlerContext ctx,
-            Object evt) throws Exception {
+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, "USER_EVENT: " + evt));
+            logger.log(internalLevel, format(ctx, "USER_EVENT", evt));
         }
-        super.userEventTriggered(ctx, evt);
+        ctx.fireUserEventTriggered(evt);
     }
 
     @Override
-    public void bind(ChannelHandlerContext ctx,
-            SocketAddress localAddress, ChannelPromise promise) throws Exception {
+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, "BIND(" + localAddress + ')'));
+            logger.log(internalLevel, format(ctx, "BIND", localAddress));
         }
-        super.bind(ctx, localAddress, promise);
+        ctx.bind(localAddress, promise);
     }
 
     @Override
-    public void connect(ChannelHandlerContext ctx,
-            SocketAddress remoteAddress, SocketAddress localAddress,
-            ChannelPromise promise) throws Exception {
+    public void connect(
+            ChannelHandlerContext ctx,
+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) throws Exception {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, "CONNECT(" + remoteAddress + ", " + localAddress + ')'));
+            logger.log(internalLevel, format(ctx, "CONNECT", remoteAddress, localAddress));
         }
-        super.connect(ctx, remoteAddress, localAddress, promise);
+        ctx.connect(remoteAddress, localAddress, promise);
     }
 
     @Override
-    public void disconnect(ChannelHandlerContext ctx,
-            ChannelPromise promise) throws Exception {
+    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, "DISCONNECT()"));
+            logger.log(internalLevel, format(ctx, "DISCONNECT"));
         }
-        super.disconnect(ctx, promise);
+        ctx.disconnect(promise);
     }
 
     @Override
-    public void close(ChannelHandlerContext ctx,
-            ChannelPromise promise) throws Exception {
+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, "CLOSE()"));
+            logger.log(internalLevel, format(ctx, "CLOSE"));
         }
-        super.close(ctx, promise);
+        ctx.close(promise);
     }
 
     @Override
-    public void deregister(ChannelHandlerContext ctx,
-             ChannelPromise promise) throws Exception {
+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, "DEREGISTER()"));
+            logger.log(internalLevel, format(ctx, "DEREGISTER"));
         }
-        super.deregister(ctx, promise);
+        ctx.deregister(promise);
     }
 
     @Override
     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        logMessage(ctx, "RECEIVED", msg);
+        if (logger.isEnabled(internalLevel)) {
+            logger.log(internalLevel, format(ctx, "RECEIVED", msg));
+        }
         ctx.fireChannelRead(msg);
     }
 
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
-        logMessage(ctx, "WRITE", msg);
+        if (logger.isEnabled(internalLevel)) {
+            logger.log(internalLevel, format(ctx, "WRITE", msg));
+        }
         ctx.write(msg, promise);
     }
 
@@ -297,90 +303,186 @@ public void flush(ChannelHandlerContext ctx) throws Exception {
         ctx.flush();
     }
 
-    private void logMessage(ChannelHandlerContext ctx, String eventName, Object msg) {
-        if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, formatMessage(eventName, msg)));
+    /**
+     * Formats an event and returns the formatted message.
+     *
+     * @param eventName the name of the event
+     */
+    protected String format(ChannelHandlerContext ctx, String eventName) {
+        String chStr = ctx.channel().toString();
+        StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName.length());
+        buf.append(chStr);
+        buf.append(' ');
+        buf.append(eventName);
+        return buf.toString();
+    }
+
+    /**
+     * Formats an event and returns the formatted message.
+     *
+     * @param eventName the name of the event
+     * @param arg       the argument of the event
+     */
+    protected String format(ChannelHandlerContext ctx, String eventName, Object arg) {
+        if (arg instanceof ByteBuf) {
+            return formatByteBuf(ctx, eventName, (ByteBuf) arg);
+        } else if (arg instanceof ByteBufHolder) {
+            return formatByteBufHolder(ctx, eventName, (ByteBufHolder) arg);
+        } else {
+            return formatSimple(ctx, eventName, arg);
+        }
+    }
+
+    /**
+     * Formats an event and returns the formatted message.  This method is currently only used for formatting
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}.
+     *
+     * @param eventName the name of the event
+     * @param firstArg  the first argument of the event
+     * @param secondArg the second argument of the event
+     */
+    protected String format(ChannelHandlerContext ctx, String eventName, Object firstArg, Object secondArg) {
+        if (secondArg == null) {
+            return formatSimple(ctx, eventName, firstArg);
         }
+
+        String chStr = ctx.channel().toString();
+        String arg1Str = String.valueOf(firstArg);
+        String arg2Str = secondArg.toString();
+        StringBuilder buf = new StringBuilder(
+                chStr.length() + 1 + eventName + 2 + arg1Str.length() + 2 + arg2Str.length());
+        buf.append(chStr).append(' ').append(eventName).append(": ").append(arg1Str).append(", ").append(arg2Str);
+        return buf.toString();
     }
 
-    protected String formatMessage(String eventName, Object msg) {
-        if (msg instanceof ByteBuf) {
-            return formatByteBuf(eventName, (ByteBuf) msg);
-        } else if (msg instanceof ByteBufHolder) {
-            return formatByteBufHolder(eventName, (ByteBufHolder) msg);
+    /**
+     * Generates the default log message of the specified event whose argument is a {@link ByteBuf}.
+     */
+    private static String formatByteBuf(ChannelHandlerContext ctx, String eventName, ByteBuf msg) {
+        String chStr = ctx.channel().toString();
+        int length = msg.readableBytes();
+        if (length == 0) {
+            StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName.length() + 4);
+            buf.append(chStr).append(' ').append(eventName).append(": 0B");
+            return buf.toString();
         } else {
-            return formatNonByteBuf(eventName, msg);
+            int rows = length / 16 + (length % 15 == 0? 0 : 1) + 4;
+            StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName.length() + 2 + 10 + 1 + 2 + rows * 80);
+
+            buf.append(chStr).append(' ').append(eventName).append(": ").append(length).append('B');
+            appendHexDump(buf, msg);
+
+            return buf.toString();
         }
     }
 
     /**
-     * Returns a String which contains all details to log the {@link ByteBuf}
+     * Generates the default log message of the specified event whose argument is a {@link ByteBufHolder}.
      */
-    protected String formatByteBuf(String eventName, ByteBuf buf) {
-        int length = buf.readableBytes();
-        int rows = length / 16 + (length % 15 == 0? 0 : 1) + 4;
-        StringBuilder dump = new StringBuilder(rows * 80 + eventName.length() + 16);
+    private static String formatByteBufHolder(ChannelHandlerContext ctx, String eventName, ByteBufHolder msg) {
+        String chStr = ctx.channel().toString();
+        String msgStr = msg.toString();
+        ByteBuf content = msg.content();
+        int length = content.readableBytes();
+        if (length == 0) {
+            StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName.length() + 2 + msgStr.length() + 4);
+            buf.append(chStr).append(' ').append(eventName).append(", ").append(msgStr).append(", 0B");
+            return buf.toString();
+        } else {
+            int rows = length / 16 + (length % 15 == 0? 0 : 1) + 4;
+            StringBuilder buf = new StringBuilder(
+                    chStr.length() + 1 + eventName.length() + 2 + msgStr.length() + 2 + 10 + 1 + 2 + rows * 80);
+
+            buf.append(chStr).append(' ').append(eventName).append(": ");
+            buf.append(msgStr).append(", ").append(length).append('B');
+            appendHexDump(buf, content);
 
-        dump.append(eventName).append('(').append(length).append('B').append(')');
+            return buf.toString();
+        }
+    }
+
+    /**
+     * Appends the prettifies multi-line hexadecimal dump of the specified {@link ByteBuf} to the specified
+     * {@link StringBuilder}.
+     */
+    protected static void appendHexDump(StringBuilder dump, ByteBuf buf) {
         dump.append(
                 NEWLINE + "         +-------------------------------------------------+" +
-                        NEWLINE + "         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |" +
-                        NEWLINE + "+--------+-------------------------------------------------+----------------+");
+                NEWLINE + "         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |" +
+                NEWLINE + "+--------+-------------------------------------------------+----------------+");
 
         final int startIndex = buf.readerIndex();
         final int endIndex = buf.writerIndex();
+        final int length = endIndex - startIndex;
+        final int fullRows = length >>> 4;
+        final int remainder = length & 0xF;
 
-        int i;
-        for (i = startIndex; i < endIndex; i ++) {
-            int relIdx = i - startIndex;
-            int relIdxMod16 = relIdx & 15;
-            if (relIdxMod16 == 0) {
-                dump.append(NEWLINE);
-                dump.append(Long.toHexString(relIdx & 0xFFFFFFFFL | 0x100000000L));
-                dump.setCharAt(dump.length() - 9, '|');
-                dump.append('|');
+        // Dump the rows which have 16 bytes.
+        for (int row = 0; row < fullRows; row ++) {
+            int rowStartIndex = row << 4;
+
+            // Per-row prefix.
+            appendHexDumpRowPrefix(dump, row, rowStartIndex);
+
+            // Hex dump
+            int rowEndIndex = rowStartIndex + 16;
+            for (int j = rowStartIndex; j < rowEndIndex; j ++) {
+                dump.append(BYTE2HEX[buf.getUnsignedByte(j)]);
             }
-            dump.append(BYTE2HEX[buf.getUnsignedByte(i)]);
-            if (relIdxMod16 == 15) {
-                dump.append(" |");
-                for (int j = i - 15; j <= i; j ++) {
-                    dump.append(BYTE2CHAR[buf.getUnsignedByte(j)]);
-                }
-                dump.append('|');
+            dump.append(" |");
+
+            // ASCII dump
+            for (int j = rowStartIndex; j < rowEndIndex; j ++) {
+                dump.append(BYTE2CHAR[buf.getUnsignedByte(j)]);
             }
+            dump.append('|');
         }
 
-        if ((i - startIndex & 15) != 0) {
-            int remainder = length & 15;
+        // Dump the last row which has less than 16 bytes.
+        if (remainder != 0) {
+            int rowStartIndex = fullRows << 4;
+            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);
+
+            // Hex dump
+            int rowEndIndex = rowStartIndex + remainder;
+            for (int j = rowStartIndex; j < rowEndIndex; j ++) {
+                dump.append(BYTE2HEX[buf.getUnsignedByte(j)]);
+            }
             dump.append(HEXPADDING[remainder]);
             dump.append(" |");
-            for (int j = i - remainder; j < i; j ++) {
+
+            // Ascii dump
+            for (int j = rowStartIndex; j < rowEndIndex; j ++) {
                 dump.append(BYTE2CHAR[buf.getUnsignedByte(j)]);
             }
             dump.append(BYTEPADDING[remainder]);
             dump.append('|');
         }
 
-        dump.append(
-                NEWLINE + "+--------+-------------------------------------------------+----------------+");
-
-        return dump.toString();
+        dump.append(NEWLINE + "+--------+-------------------------------------------------+----------------+");
     }
 
     /**
-     * Returns a String which contains all details to log the {@link Object}
+     * Appends the prefix of each hex dump row.  Uses the look-up table for the buffer <= 64 KiB.
      */
-    protected String formatNonByteBuf(String eventName, Object msg) {
-        return eventName + ": " + msg;
+    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) {
+        if (row < HEXDUMP_ROWPREFIXES.length) {
+            dump.append(HEXDUMP_ROWPREFIXES[row]);
+        } else {
+            dump.append(NEWLINE);
+            dump.append(Long.toHexString(rowStartIndex & 0xFFFFFFFFL | 0x100000000L));
+            dump.setCharAt(dump.length() - 9, '|');
+            dump.append('|');
+        }
     }
 
     /**
-     * Returns a String which contains all details to log the {@link ByteBufHolder}.
-     *
-     * By default this method just delegates to {@link #formatByteBuf(String, ByteBuf)},
-     * using the content of the {@link ByteBufHolder}. Sub-classes may override this.
+     * Generates the default log message of the specified event whose argument is an arbitrary object.
      */
-    protected String formatByteBufHolder(String eventName, ByteBufHolder msg) {
-        return formatByteBuf(eventName, msg.content());
+    private static String formatSimple(ChannelHandlerContext ctx, String eventName, Object msg) {
+        String chStr = ctx.channel().toString();
+        String msgStr = String.valueOf(msg);
+        StringBuilder buf = new StringBuilder(chStr.length() + 1 + eventName.length() + 2 + msgStr.length());
+        return buf.append(chStr).append(' ').append(eventName).append(": ").append(msgStr).toString();
     }
 }
diff --git a/handler/src/main/java/io/netty/handler/logging/package-info.java b/handler/src/main/java/io/netty/handler/logging/package-info.java
index 3ce2be45ccd3..257ca4610ad9 100644
--- a/handler/src/main/java/io/netty/handler/logging/package-info.java
+++ b/handler/src/main/java/io/netty/handler/logging/package-info.java
@@ -15,6 +15,6 @@
  */
 
 /**
- * Logs a {@link io.netty.channel.ChannelEvent} for debugging purpose.
+ * Logs the I/O events for debugging purpose.
  */
 package io.netty.handler.logging;
diff --git a/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java
new file mode 100644
index 000000000000..07a0d1db98e4
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSessionContext;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.security.auth.x500.X500Principal;
+import java.io.File;
+import java.security.KeyStore;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A client-side {@link SslContext} which uses JDK's SSL/TLS implementation.
+ */
+public final class JdkSslClientContext extends JdkSslContext {
+
+    private final SSLContext ctx;
+    private final List<String> nextProtocols;
+
+    /**
+     * Creates a new instance.
+     */
+    public JdkSslClientContext() throws SSLException {
+        this(null, null, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format.
+     *                      {@code null} to use the system default
+     */
+    public JdkSslClientContext(File certChainFile) throws SSLException {
+        this(certChainFile, null);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     */
+    public JdkSslClientContext(TrustManagerFactory trustManagerFactory) throws SSLException {
+        this(null, trustManagerFactory);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format.
+     *                      {@code null} to use the system default
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     */
+    public JdkSslClientContext(File certChainFile, TrustManagerFactory trustManagerFactory) throws SSLException {
+        this(certChainFile, trustManagerFactory, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format.
+     *                      {@code null} to use the system default
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     * @param ciphers the cipher suites to enable, in the order of preference.
+     *                {@code null} to use the default cipher suites.
+     * @param nextProtocols the application layer protocols to accept, in the order of preference.
+     *                      {@code null} to disable TLS NPN/ALPN extension.
+     * @param sessionCacheSize the size of the cache used for storing SSL session objects.
+     *                         {@code 0} to use the default value.
+     * @param sessionTimeout the timeout for the cached SSL session objects, in seconds.
+     *                       {@code 0} to use the default value.
+     */
+    public JdkSslClientContext(
+            File certChainFile, TrustManagerFactory trustManagerFactory,
+            Iterable<String> ciphers, Iterable<String> nextProtocols,
+            long sessionCacheSize, long sessionTimeout) throws SSLException {
+
+        super(ciphers);
+
+        if (nextProtocols != null && nextProtocols.iterator().hasNext()) {
+            if (!JettyNpnSslEngine.isAvailable()) {
+                throw new SSLException("NPN/ALPN unsupported: " + nextProtocols);
+            }
+
+            List<String> nextProtoList = new ArrayList<String>();
+            for (String p: nextProtocols) {
+                if (p == null) {
+                    break;
+                }
+                nextProtoList.add(p);
+            }
+            this.nextProtocols = Collections.unmodifiableList(nextProtoList);
+        } else {
+            this.nextProtocols = Collections.emptyList();
+        }
+
+        try {
+            if (certChainFile == null) {
+                ctx = SSLContext.getInstance(PROTOCOL);
+                if (trustManagerFactory == null) {
+                    ctx.init(null, null, null);
+                } else {
+                    trustManagerFactory.init((KeyStore) null);
+                    ctx.init(null, trustManagerFactory.getTrustManagers(), null);
+                }
+            } else {
+                KeyStore ks = KeyStore.getInstance("JKS");
+                ks.load(null, null);
+                CertificateFactory cf = CertificateFactory.getInstance("X.509");
+
+                ByteBuf[] certs = PemReader.readCertificates(certChainFile);
+                try {
+                    for (ByteBuf buf: certs) {
+                        X509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteBufInputStream(buf));
+                        X500Principal principal = cert.getSubjectX500Principal();
+                        ks.setCertificateEntry(principal.getName("RFC2253"), cert);
+                    }
+                } finally {
+                    for (ByteBuf buf: certs) {
+                        buf.release();
+                    }
+                }
+
+                // Set up trust manager factory to use our key store.
+                if (trustManagerFactory == null) {
+                    trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+                }
+                trustManagerFactory.init(ks);
+
+                // Initialize the SSLContext to work with the trust managers.
+                ctx = SSLContext.getInstance(PROTOCOL);
+                ctx.init(null, trustManagerFactory.getTrustManagers(), null);
+            }
+
+            SSLSessionContext sessCtx = ctx.getClientSessionContext();
+            if (sessionCacheSize > 0) {
+                sessCtx.setSessionCacheSize((int) Math.min(sessionCacheSize, Integer.MAX_VALUE));
+            }
+            if (sessionTimeout > 0) {
+                sessCtx.setSessionTimeout((int) Math.min(sessionTimeout, Integer.MAX_VALUE));
+            }
+        } catch (Exception e) {
+            throw new SSLException("failed to initialize the server-side SSL context", e);
+        }
+    }
+
+    @Override
+    public boolean isClient() {
+        return true;
+    }
+
+    @Override
+    public List<String> nextProtocols() {
+        return nextProtocols;
+    }
+
+    @Override
+    public SSLContext context() {
+        return ctx;
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
new file mode 100644
index 000000000000..15402a8c2f68
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLSessionContext;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * An {@link SslContext} which uses JDK's SSL/TLS implementation.
+ */
+public abstract class JdkSslContext extends SslContext {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(JdkSslContext.class);
+
+    static final String PROTOCOL = "TLS";
+    static final String[] PROTOCOLS;
+    static final List<String> DEFAULT_CIPHERS;
+
+    static {
+        SSLContext context;
+        try {
+            context = SSLContext.getInstance(PROTOCOL);
+            context.init(null, null, null);
+        } catch (Exception e) {
+            throw new Error("failed to initialize the default SSL context", e);
+        }
+
+        SSLEngine engine = context.createSSLEngine();
+
+        // Choose the sensible default list of protocols.
+        String[] supportedProtocols = engine.getSupportedProtocols();
+        List<String> protocols = new ArrayList<String>();
+        addIfSupported(
+                supportedProtocols, protocols,
+                "TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3");
+
+        if (!protocols.isEmpty()) {
+            PROTOCOLS = protocols.toArray(new String[protocols.size()]);
+        } else {
+            PROTOCOLS = engine.getEnabledProtocols();
+        }
+
+        // Choose the sensible default list of cipher suites.
+        String[] supportedCiphers = engine.getSupportedCipherSuites();
+        List<String> ciphers = new ArrayList<String>();
+        addIfSupported(
+                supportedCiphers, ciphers,
+                // XXX: Make sure to sync this list with OpenSslEngineFactory.
+                // GCM (Galois/Counter Mode) requires JDK 8.
+                "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
+                "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
+                "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
+                // AES256 requires JCE unlimited strength jurisdiction policy files.
+                "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
+                // GCM (Galois/Counter Mode) requires JDK 8.
+                "TLS_RSA_WITH_AES_128_GCM_SHA256",
+                "SSL_RSA_WITH_RC4_128_SHA",
+                "SSL_RSA_WITH_RC4_128_MD5",
+                "TLS_RSA_WITH_AES_128_CBC_SHA",
+                // AES256 requires JCE unlimited strength jurisdiction policy files.
+                "TLS_RSA_WITH_AES_256_CBC_SHA",
+                "SSL_RSA_WITH_DES_CBC_SHA");
+
+        if (!ciphers.isEmpty()) {
+            DEFAULT_CIPHERS = Collections.unmodifiableList(ciphers);
+        } else {
+            // Use the default from JDK as fallback.
+            DEFAULT_CIPHERS = Collections.unmodifiableList(Arrays.asList(engine.getEnabledCipherSuites()));
+        }
+
+        if (logger.isDebugEnabled()) {
+            logger.debug("Default protocols (JDK): {} ", Arrays.asList(PROTOCOLS));
+            logger.debug("Default cipher suites (JDK): {}", DEFAULT_CIPHERS);
+        }
+    }
+
+    private static void addIfSupported(String[] supported, List<String> enabled, String... names) {
+        for (String n: names) {
+            for (String s: supported) {
+                if (n.equals(s)) {
+                    enabled.add(s);
+                    break;
+                }
+            }
+        }
+    }
+
+    private final String[] cipherSuites;
+    private final List<String> unmodifiableCipherSuites;
+
+    JdkSslContext(Iterable<String> ciphers) {
+        cipherSuites = toCipherSuiteArray(ciphers);
+        unmodifiableCipherSuites = Collections.unmodifiableList(Arrays.asList(cipherSuites));
+    }
+
+    /**
+     * Returns the JDK {@link SSLContext} object held by this context.
+     */
+    public abstract SSLContext context();
+
+    /**
+     * Returns the JDK {@link SSLSessionContext} object held by this context.
+     */
+    public final SSLSessionContext sessionContext() {
+        if (isServer()) {
+            return context().getServerSessionContext();
+        } else {
+            return context().getClientSessionContext();
+        }
+    }
+
+    @Override
+    public final List<String> cipherSuites() {
+        return unmodifiableCipherSuites;
+    }
+
+    @Override
+    public final long sessionCacheSize() {
+        return sessionContext().getSessionCacheSize();
+    }
+
+    @Override
+    public final long sessionTimeout() {
+        return sessionContext().getSessionTimeout();
+    }
+
+    @Override
+    public final SSLEngine newEngine(ByteBufAllocator alloc) {
+        SSLEngine engine = context().createSSLEngine();
+        engine.setEnabledCipherSuites(cipherSuites);
+        engine.setEnabledProtocols(PROTOCOLS);
+        engine.setUseClientMode(isClient());
+        return wrapEngine(engine);
+    }
+
+    @Override
+    public final SSLEngine newEngine(ByteBufAllocator alloc, String peerHost, int peerPort) {
+        SSLEngine engine = context().createSSLEngine(peerHost, peerPort);
+        engine.setEnabledCipherSuites(cipherSuites);
+        engine.setEnabledProtocols(PROTOCOLS);
+        engine.setUseClientMode(isClient());
+        return wrapEngine(engine);
+    }
+
+    private SSLEngine wrapEngine(SSLEngine engine) {
+        if (nextProtocols().isEmpty()) {
+            return engine;
+        } else {
+            return new JettyNpnSslEngine(engine, nextProtocols(), isServer());
+        }
+    }
+
+    private static String[] toCipherSuiteArray(Iterable<String> ciphers) {
+        if (ciphers == null) {
+            return DEFAULT_CIPHERS.toArray(new String[DEFAULT_CIPHERS.size()]);
+        } else {
+            List<String> newCiphers = new ArrayList<String>();
+            for (String c: ciphers) {
+                if (c == null) {
+                    break;
+                }
+                newCiphers.add(c);
+            }
+            return newCiphers.toArray(new String[newCiphers.size()]);
+        }
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java
new file mode 100644
index 000000000000..6fcd24452154
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSessionContext;
+import java.io.File;
+import java.security.KeyFactory;
+import java.security.KeyStore;
+import java.security.PrivateKey;
+import java.security.Security;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateFactory;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A server-side {@link SslContext} which uses JDK's SSL/TLS implementation.
+ */
+public final class JdkSslServerContext extends JdkSslContext {
+
+    private final SSLContext ctx;
+    private final List<String> nextProtocols;
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     */
+    public JdkSslServerContext(File certChainFile, File keyFile) throws SSLException {
+        this(certChainFile, keyFile, null);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @param keyPassword the password of the {@code keyFile}.
+     *                    {@code null} if it's not password-protected.
+     */
+    public JdkSslServerContext(File certChainFile, File keyFile, String keyPassword) throws SSLException {
+        this(certChainFile, keyFile, keyPassword, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @param keyPassword the password of the {@code keyFile}.
+     *                    {@code null} if it's not password-protected.
+     * @param ciphers the cipher suites to enable, in the order of preference.
+     *                {@code null} to use the default cipher suites.
+     * @param nextProtocols the application layer protocols to accept, in the order of preference.
+     *                      {@code null} to disable TLS NPN/ALPN extension.
+     * @param sessionCacheSize the size of the cache used for storing SSL session objects.
+     *                         {@code 0} to use the default value.
+     * @param sessionTimeout the timeout for the cached SSL session objects, in seconds.
+     *                       {@code 0} to use the default value.
+     */
+    public JdkSslServerContext(
+            File certChainFile, File keyFile, String keyPassword,
+            Iterable<String> ciphers, Iterable<String> nextProtocols,
+            long sessionCacheSize, long sessionTimeout) throws SSLException {
+
+        super(ciphers);
+
+        if (certChainFile == null) {
+            throw new NullPointerException("certChainFile");
+        }
+        if (keyFile == null) {
+            throw new NullPointerException("keyFile");
+        }
+
+        if (keyPassword == null) {
+            keyPassword = "";
+        }
+
+        if (nextProtocols != null && nextProtocols.iterator().hasNext()) {
+            if (!JettyNpnSslEngine.isAvailable()) {
+                throw new SSLException("NPN/ALPN unsupported: " + nextProtocols);
+            }
+
+            List<String> list = new ArrayList<String>();
+            for (String p: nextProtocols) {
+                if (p == null) {
+                    break;
+                }
+                list.add(p);
+            }
+
+            this.nextProtocols = Collections.unmodifiableList(list);
+        } else {
+            this.nextProtocols = Collections.emptyList();
+        }
+
+        String algorithm = Security.getProperty("ssl.KeyManagerFactory.algorithm");
+        if (algorithm == null) {
+            algorithm = "SunX509";
+        }
+
+        try {
+            KeyStore ks = KeyStore.getInstance("JKS");
+            ks.load(null, null);
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            KeyFactory rsaKF = KeyFactory.getInstance("RSA");
+            KeyFactory dsaKF = KeyFactory.getInstance("DSA");
+
+            ByteBuf encodedKeyBuf = PemReader.readPrivateKey(keyFile);
+            byte[] encodedKey = new byte[encodedKeyBuf.readableBytes()];
+            encodedKeyBuf.readBytes(encodedKey).release();
+            PKCS8EncodedKeySpec encodedKeySpec = new PKCS8EncodedKeySpec(encodedKey);
+
+            PrivateKey key;
+            try {
+                key = rsaKF.generatePrivate(encodedKeySpec);
+            } catch (InvalidKeySpecException ignore) {
+                key = dsaKF.generatePrivate(encodedKeySpec);
+            }
+
+            List<Certificate> certChain = new ArrayList<Certificate>();
+            ByteBuf[] certs = PemReader.readCertificates(certChainFile);
+            try {
+                for (ByteBuf buf: certs) {
+                    certChain.add(cf.generateCertificate(new ByteBufInputStream(buf)));
+                }
+            } finally {
+                for (ByteBuf buf: certs) {
+                    buf.release();
+                }
+            }
+
+            ks.setKeyEntry("key", key, keyPassword.toCharArray(), certChain.toArray(new Certificate[certChain.size()]));
+
+            // Set up key manager factory to use our key store
+            KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
+            kmf.init(ks, keyPassword.toCharArray());
+
+            // Initialize the SSLContext to work with our key managers.
+            ctx = SSLContext.getInstance(PROTOCOL);
+            ctx.init(kmf.getKeyManagers(), null, null);
+
+            SSLSessionContext sessCtx = ctx.getServerSessionContext();
+            if (sessionCacheSize > 0) {
+                sessCtx.setSessionCacheSize((int) Math.min(sessionCacheSize, Integer.MAX_VALUE));
+            }
+            if (sessionTimeout > 0) {
+                sessCtx.setSessionTimeout((int) Math.min(sessionTimeout, Integer.MAX_VALUE));
+            }
+        } catch (Exception e) {
+            throw new SSLException("failed to initialize the server-side SSL context", e);
+        }
+    }
+
+    @Override
+    public boolean isClient() {
+        return false;
+    }
+
+    @Override
+    public List<String> nextProtocols() {
+        return nextProtocols;
+    }
+
+    @Override
+    public SSLContext context() {
+        return ctx;
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslEngine.java b/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslEngine.java
new file mode 100644
index 000000000000..49e9c3dc2d19
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslEngine.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import org.eclipse.jetty.npn.NextProtoNego;
+import org.eclipse.jetty.npn.NextProtoNego.ClientProvider;
+import org.eclipse.jetty.npn.NextProtoNego.ServerProvider;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLEngineResult;
+import javax.net.ssl.SSLEngineResult.HandshakeStatus;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLParameters;
+import javax.net.ssl.SSLSession;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+final class JettyNpnSslEngine extends SSLEngine {
+
+    private static boolean available;
+
+    static boolean isAvailable() {
+        updateAvailability();
+        return available;
+    }
+
+    private static void updateAvailability() {
+        if (available) {
+            return;
+        }
+        try {
+            // Try to get the bootstrap class loader.
+            ClassLoader bootloader = ClassLoader.getSystemClassLoader().getParent();
+            if (bootloader == null) {
+                // If failed, use the system class loader,
+                // although it's not perfect to tell if NPN extension has been loaded.
+                bootloader = ClassLoader.getSystemClassLoader();
+            }
+            Class.forName("sun.security.ssl.NextProtoNegoExtension", true, bootloader);
+            available = true;
+        } catch (Exception ignore) {
+            // npn-boot was not loaded.
+        }
+    }
+
+    private final SSLEngine engine;
+    private final JettyNpnSslSession session;
+
+    JettyNpnSslEngine(SSLEngine engine, final List<String> nextProtocols, boolean server) {
+        assert !nextProtocols.isEmpty();
+
+        this.engine = engine;
+        session = new JettyNpnSslSession(engine);
+
+        if (server) {
+            NextProtoNego.put(engine, new ServerProvider() {
+                @Override
+                public void unsupported() {
+                    getSession().setApplicationProtocol(nextProtocols.get(nextProtocols.size() - 1));
+                }
+
+                @Override
+                public List<String> protocols() {
+                    return nextProtocols;
+                }
+
+                @Override
+                public void protocolSelected(String protocol) {
+                    getSession().setApplicationProtocol(protocol);
+                }
+            });
+        } else {
+            final String[] list = nextProtocols.toArray(new String[nextProtocols.size()]);
+            final String fallback = list[list.length - 1];
+
+            NextProtoNego.put(engine, new ClientProvider() {
+                @Override
+                public boolean supports() {
+                    return true;
+                }
+
+                @Override
+                public void unsupported() {
+                    session.setApplicationProtocol(null);
+                }
+
+                @Override
+                public String selectProtocol(List<String> protocols) {
+                    for (String p: list) {
+                        if (protocols.contains(p)) {
+                            return p;
+                        }
+                    }
+                    return fallback;
+                }
+            });
+        }
+    }
+
+    @Override
+    public JettyNpnSslSession getSession() {
+        return session;
+    }
+
+    @Override
+    public void closeInbound() throws SSLException {
+        NextProtoNego.remove(engine);
+        engine.closeInbound();
+    }
+
+    @Override
+    public void closeOutbound() {
+        NextProtoNego.remove(engine);
+        engine.closeOutbound();
+    }
+
+    @Override
+    public String getPeerHost() {
+        return engine.getPeerHost();
+    }
+
+    @Override
+    public int getPeerPort() {
+        return engine.getPeerPort();
+    }
+
+    @Override
+    public SSLEngineResult wrap(ByteBuffer byteBuffer, ByteBuffer byteBuffer2) throws SSLException {
+        return engine.wrap(byteBuffer, byteBuffer2);
+    }
+
+    @Override
+    public SSLEngineResult wrap(ByteBuffer[] byteBuffers, ByteBuffer byteBuffer) throws SSLException {
+        return engine.wrap(byteBuffers, byteBuffer);
+    }
+
+    @Override
+    public SSLEngineResult wrap(ByteBuffer[] byteBuffers, int i, int i2, ByteBuffer byteBuffer) throws SSLException {
+        return engine.wrap(byteBuffers, i, i2, byteBuffer);
+    }
+
+    @Override
+    public SSLEngineResult unwrap(ByteBuffer byteBuffer, ByteBuffer byteBuffer2) throws SSLException {
+        return engine.unwrap(byteBuffer, byteBuffer2);
+    }
+
+    @Override
+    public SSLEngineResult unwrap(ByteBuffer byteBuffer, ByteBuffer[] byteBuffers) throws SSLException {
+        return engine.unwrap(byteBuffer, byteBuffers);
+    }
+
+    @Override
+    public SSLEngineResult unwrap(ByteBuffer byteBuffer, ByteBuffer[] byteBuffers, int i, int i2) throws SSLException {
+        return engine.unwrap(byteBuffer, byteBuffers, i, i2);
+    }
+
+    @Override
+    public Runnable getDelegatedTask() {
+        return engine.getDelegatedTask();
+    }
+
+    @Override
+    public boolean isInboundDone() {
+        return engine.isInboundDone();
+    }
+
+    @Override
+    public boolean isOutboundDone() {
+        return engine.isOutboundDone();
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        return engine.getSupportedCipherSuites();
+    }
+
+    @Override
+    public String[] getEnabledCipherSuites() {
+        return engine.getEnabledCipherSuites();
+    }
+
+    @Override
+    public void setEnabledCipherSuites(String[] strings) {
+        engine.setEnabledCipherSuites(strings);
+    }
+
+    @Override
+    public String[] getSupportedProtocols() {
+        return engine.getSupportedProtocols();
+    }
+
+    @Override
+    public String[] getEnabledProtocols() {
+        return engine.getEnabledProtocols();
+    }
+
+    @Override
+    public void setEnabledProtocols(String[] strings) {
+        engine.setEnabledProtocols(strings);
+    }
+
+    @Override
+    public SSLSession getHandshakeSession() {
+        return engine.getHandshakeSession();
+    }
+
+    @Override
+    public void beginHandshake() throws SSLException {
+        engine.beginHandshake();
+    }
+
+    @Override
+    public HandshakeStatus getHandshakeStatus() {
+        return engine.getHandshakeStatus();
+    }
+
+    @Override
+    public void setUseClientMode(boolean b) {
+        engine.setUseClientMode(b);
+    }
+
+    @Override
+    public boolean getUseClientMode() {
+        return engine.getUseClientMode();
+    }
+
+    @Override
+    public void setNeedClientAuth(boolean b) {
+        engine.setNeedClientAuth(b);
+    }
+
+    @Override
+    public boolean getNeedClientAuth() {
+        return engine.getNeedClientAuth();
+    }
+
+    @Override
+    public void setWantClientAuth(boolean b) {
+        engine.setWantClientAuth(b);
+    }
+
+    @Override
+    public boolean getWantClientAuth() {
+        return engine.getWantClientAuth();
+    }
+
+    @Override
+    public void setEnableSessionCreation(boolean b) {
+        engine.setEnableSessionCreation(b);
+    }
+
+    @Override
+    public boolean getEnableSessionCreation() {
+        return engine.getEnableSessionCreation();
+    }
+
+    @Override
+    public SSLParameters getSSLParameters() {
+        return engine.getSSLParameters();
+    }
+
+    @Override
+    public void setSSLParameters(SSLParameters sslParameters) {
+        engine.setSSLParameters(sslParameters);
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslSession.java b/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslSession.java
new file mode 100644
index 000000000000..f4da3da1d565
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslSession.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSessionContext;
+import javax.security.cert.X509Certificate;
+import java.security.Principal;
+import java.security.cert.Certificate;
+
+final class JettyNpnSslSession implements SSLSession {
+
+    private final SSLEngine engine;
+    private volatile String applicationProtocol;
+
+    JettyNpnSslSession(SSLEngine engine) {
+        this.engine = engine;
+    }
+
+    void setApplicationProtocol(String applicationProtocol) {
+        if (applicationProtocol != null) {
+            applicationProtocol = applicationProtocol.replace(':', '_');
+        }
+        this.applicationProtocol = applicationProtocol;
+    }
+
+    @Override
+    public String getProtocol() {
+        final String protocol = unwrap().getProtocol();
+        final String applicationProtocol = this.applicationProtocol;
+
+        if (applicationProtocol == null) {
+            if (protocol != null) {
+                return protocol.replace(':', '_');
+            } else {
+                return null;
+            }
+        }
+
+        final StringBuilder buf = new StringBuilder(32);
+        if (protocol != null) {
+            buf.append(protocol.replace(':', '_'));
+            buf.append(':');
+        } else {
+            buf.append("null:");
+        }
+        buf.append(applicationProtocol);
+        return buf.toString();
+    }
+
+    private SSLSession unwrap() {
+        return engine.getSession();
+    }
+
+    @Override
+    public byte[] getId() {
+        return unwrap().getId();
+    }
+
+    @Override
+    public SSLSessionContext getSessionContext() {
+        return unwrap().getSessionContext();
+    }
+
+    @Override
+    public long getCreationTime() {
+        return unwrap().getCreationTime();
+    }
+
+    @Override
+    public long getLastAccessedTime() {
+        return unwrap().getLastAccessedTime();
+    }
+
+    @Override
+    public void invalidate() {
+        unwrap().invalidate();
+    }
+
+    @Override
+    public boolean isValid() {
+        return unwrap().isValid();
+    }
+
+    @Override
+    public void putValue(String s, Object o) {
+        unwrap().putValue(s, o);
+    }
+
+    @Override
+    public Object getValue(String s) {
+        return unwrap().getValue(s);
+    }
+
+    @Override
+    public void removeValue(String s) {
+        unwrap().removeValue(s);
+    }
+
+    @Override
+    public String[] getValueNames() {
+        return unwrap().getValueNames();
+    }
+
+    @Override
+    public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
+        return unwrap().getPeerCertificates();
+    }
+
+    @Override
+    public Certificate[] getLocalCertificates() {
+        return unwrap().getLocalCertificates();
+    }
+
+    @Override
+    public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
+        return unwrap().getPeerCertificateChain();
+    }
+
+    @Override
+    public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+        return unwrap().getPeerPrincipal();
+    }
+
+    @Override
+    public Principal getLocalPrincipal() {
+        return unwrap().getLocalPrincipal();
+    }
+
+    @Override
+    public String getCipherSuite() {
+        return unwrap().getCipherSuite();
+    }
+
+    @Override
+    public String getPeerHost() {
+        return unwrap().getPeerHost();
+    }
+
+    @Override
+    public int getPeerPort() {
+        return unwrap().getPeerPort();
+    }
+
+    @Override
+    public int getPacketBufferSize() {
+        return unwrap().getPacketBufferSize();
+    }
+
+    @Override
+    public int getApplicationBufferSize() {
+        return unwrap().getApplicationBufferSize();
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
new file mode 100644
index 000000000000..206c27a38fac
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import io.netty.util.internal.NativeLibraryLoader;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+import org.apache.tomcat.jni.Library;
+import org.apache.tomcat.jni.SSL;
+
+/**
+ * Tells if <a href="http://netty.io/wiki/forked-tomcat-native.html">{@code netty-tcnative}</a> and its OpenSSL support
+ * are available.
+ */
+public final class OpenSsl {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(OpenSsl.class);
+    private static final Throwable UNAVAILABILITY_CAUSE;
+
+    static final String IGNORABLE_ERROR_PREFIX = "error:00000000:";
+
+    static {
+        Throwable cause = null;
+        try {
+            NativeLibraryLoader.load("netty-tcnative", SSL.class.getClassLoader());
+            Library.initialize("provided");
+            SSL.initialize(null);
+        } catch (Throwable t) {
+            cause = t;
+            logger.debug(
+                    "Failed to load netty-tcnative; " +
+                            OpenSslEngine.class.getSimpleName() + " will be unavailable.", t);
+        }
+        UNAVAILABILITY_CAUSE = cause;
+    }
+
+    /**
+     * Returns {@code true} if and only if
+     * <a href="http://netty.io/wiki/forked-tomcat-native.html">{@code netty-tcnative}</a> and its OpenSSL support
+     * are available.
+     */
+    public static boolean isAvailable() {
+        return UNAVAILABILITY_CAUSE == null;
+    }
+
+    /**
+     * Ensure that <a href="http://netty.io/wiki/forked-tomcat-native.html">{@code netty-tcnative}</a> and
+     * its OpenSSL support are available.
+     *
+     * @throws UnsatisfiedLinkError if unavailable
+     */
+    public static void ensureAvailability() {
+        if (UNAVAILABILITY_CAUSE != null) {
+            throw (Error) new UnsatisfiedLinkError(
+                    "failed to load the required native library").initCause(UNAVAILABILITY_CAUSE);
+        }
+    }
+
+    /**
+     * Returns the cause of unavailability of
+     * <a href="http://netty.io/wiki/forked-tomcat-native.html">{@code netty-tcnative}</a> and its OpenSSL support.
+     *
+     * @return the cause if unavailable. {@code null} if available.
+     */
+    public static Throwable unavailabilityCause() {
+        return UNAVAILABILITY_CAUSE;
+    }
+
+    private OpenSsl() { }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java
new file mode 100644
index 000000000000..a753c0ba6b74
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java
@@ -0,0 +1,885 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ssl;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+import org.apache.tomcat.jni.Buffer;
+import org.apache.tomcat.jni.SSL;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLEngineResult;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSessionContext;
+import javax.security.cert.X509Certificate;
+import java.nio.ByteBuffer;
+import java.nio.ReadOnlyBufferException;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+import static javax.net.ssl.SSLEngineResult.HandshakeStatus.*;
+import static javax.net.ssl.SSLEngineResult.Status.*;
+
+/**
+ * Implements a {@link SSLEngine} using
+ * <a href="https://www.openssl.org/docs/crypto/BIO_s_bio.html#EXAMPLE">OpenSSL BIO abstractions</a>.
+ */
+public final class OpenSslEngine extends SSLEngine {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(OpenSslEngine.class);
+
+    private static final Certificate[] EMPTY_CERTIFICATES = new Certificate[0];
+    private static final X509Certificate[] EMPTY_X509_CERTIFICATES = new X509Certificate[0];
+
+    private static final SSLException ENGINE_CLOSED = new SSLException("engine closed");
+    private static final SSLException RENEGOTIATION_UNSUPPORTED = new SSLException("renegotiation unsupported");
+    private static final SSLException ENCRYPTED_PACKET_OVERSIZED = new SSLException("encrypted packet oversized");
+
+    static {
+        ENGINE_CLOSED.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+        RENEGOTIATION_UNSUPPORTED.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+        ENCRYPTED_PACKET_OVERSIZED.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+    }
+
+    private static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14
+    private static final int MAX_COMPRESSED_LENGTH = MAX_PLAINTEXT_LENGTH + 1024;
+    private static final int MAX_CIPHERTEXT_LENGTH = MAX_COMPRESSED_LENGTH + 1024;
+
+    // Header (5) + Data (2^14) + Compression (1024) + Encryption (1024) + MAC (20) + Padding (256)
+    static final int MAX_ENCRYPTED_PACKET_LENGTH = MAX_CIPHERTEXT_LENGTH + 5 + 20 + 256;
+
+    static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = MAX_ENCRYPTED_PACKET_LENGTH - MAX_PLAINTEXT_LENGTH;
+
+    private static final AtomicIntegerFieldUpdater<OpenSslEngine> DESTROYED_UPDATER =
+            AtomicIntegerFieldUpdater.newUpdater(OpenSslEngine.class, "destroyed");
+
+    // OpenSSL state
+    private long ssl;
+    private long networkBIO;
+
+    /**
+     * 0 - not accepted, 1 - accepted implicitly via wrap()/unwrap(), 2 - accepted explicitly via beginHandshake() call
+     */
+    private int accepted;
+    private boolean handshakeFinished;
+    private boolean receivedShutdown;
+    @SuppressWarnings("UnusedDeclaration")
+    private volatile int destroyed;
+
+    private String cipher;
+    private volatile String applicationProtocol;
+
+    // SSL Engine status variables
+    private boolean isInboundDone;
+    private boolean isOutboundDone;
+    private boolean engineClosed;
+
+    private int lastPrimingReadResult;
+
+    private final ByteBufAllocator alloc;
+    private final String fallbackApplicationProtocol;
+    private SSLSession session;
+
+    /**
+     * Creates a new instance
+     *
+     * @param sslCtx an OpenSSL {@code SSL_CTX} object
+     * @param alloc the {@link ByteBufAllocator} that will be used by this engine
+     */
+    public OpenSslEngine(long sslCtx, ByteBufAllocator alloc, String fallbackApplicationProtocol) {
+        OpenSsl.ensureAvailability();
+        if (sslCtx == 0) {
+            throw new NullPointerException("sslContext");
+        }
+        if (alloc == null) {
+            throw new NullPointerException("alloc");
+        }
+
+        this.alloc = alloc;
+        ssl = SSL.newSSL(sslCtx, true);
+        networkBIO = SSL.makeNetworkBIO(ssl);
+        this.fallbackApplicationProtocol = fallbackApplicationProtocol;
+    }
+
+    /**
+     * Destroys this engine.
+     */
+    public synchronized void shutdown() {
+        if (DESTROYED_UPDATER.compareAndSet(this, 0, 1)) {
+            SSL.freeSSL(ssl);
+            SSL.freeBIO(networkBIO);
+            ssl = networkBIO = 0;
+
+            // internal errors can cause shutdown without marking the engine closed
+            isInboundDone = isOutboundDone = engineClosed = true;
+        }
+    }
+
+    /**
+     * Write plaintext data to the OpenSSL internal BIO
+     *
+     * Calling this function with src.remaining == 0 is undefined.
+     */
+    private int writePlaintextData(final ByteBuffer src) {
+        final int pos = src.position();
+        final int limit = src.limit();
+        final int len = Math.min(limit - pos, MAX_PLAINTEXT_LENGTH);
+        final int sslWrote;
+
+        if (src.isDirect()) {
+            final long addr = Buffer.address(src) + pos;
+            sslWrote = SSL.writeToSSL(ssl, addr, len);
+            if (sslWrote > 0) {
+                src.position(pos + sslWrote);
+                return sslWrote;
+            }
+        } else {
+            ByteBuf buf = alloc.directBuffer(len);
+            try {
+                final long addr;
+                if (buf.hasMemoryAddress()) {
+                    addr = buf.memoryAddress();
+                } else {
+                    addr = Buffer.address(buf.nioBuffer());
+                }
+
+                src.limit(pos + len);
+
+                buf.setBytes(0, src);
+                src.limit(limit);
+
+                sslWrote = SSL.writeToSSL(ssl, addr, len);
+                if (sslWrote > 0) {
+                    src.position(pos + sslWrote);
+                    return sslWrote;
+                } else {
+                    src.position(pos);
+                }
+            } finally {
+                buf.release();
+            }
+        }
+
+        throw new IllegalStateException("SSL.writeToSSL() returned a non-positive value: " + sslWrote);
+    }
+
+    /**
+     * Write encrypted data to the OpenSSL network BIO
+     */
+    private int writeEncryptedData(final ByteBuffer src) {
+        final int pos = src.position();
+        final int len = src.remaining();
+        if (src.isDirect()) {
+            final long addr = Buffer.address(src) + pos;
+            final int netWrote = SSL.writeToBIO(networkBIO, addr, len);
+            if (netWrote >= 0) {
+                src.position(pos + netWrote);
+                lastPrimingReadResult = SSL.readFromSSL(ssl, addr, 0); // priming read
+                return netWrote;
+            }
+        } else {
+            final ByteBuf buf = alloc.directBuffer(len);
+            try {
+                final long addr;
+                if (buf.hasMemoryAddress()) {
+                    addr = buf.memoryAddress();
+                } else {
+                    addr = Buffer.address(buf.nioBuffer());
+                }
+
+                buf.setBytes(0, src);
+
+                final int netWrote = SSL.writeToBIO(networkBIO, addr, len);
+                if (netWrote >= 0) {
+                    src.position(pos + netWrote);
+                    lastPrimingReadResult = SSL.readFromSSL(ssl, addr, 0); // priming read
+                    return netWrote;
+                } else {
+                    src.position(pos);
+                }
+            } finally {
+                buf.release();
+            }
+        }
+
+        return 0;
+    }
+
+    /**
+     * Read plaintext data from the OpenSSL internal BIO
+     */
+    private int readPlaintextData(final ByteBuffer dst) {
+        if (dst.isDirect()) {
+            final int pos = dst.position();
+            final long addr = Buffer.address(dst) + pos;
+            final int len = dst.limit() - pos;
+            final int sslRead = SSL.readFromSSL(ssl, addr, len);
+            if (sslRead > 0) {
+                dst.position(pos + sslRead);
+                return sslRead;
+            }
+        } else {
+            final int pos = dst.position();
+            final int limit = dst.limit();
+            final int len = Math.min(MAX_ENCRYPTED_PACKET_LENGTH, limit - pos);
+            final ByteBuf buf = alloc.directBuffer(len);
+            try {
+                final long addr;
+                if (buf.hasMemoryAddress()) {
+                    addr = buf.memoryAddress();
+                } else {
+                    addr = Buffer.address(buf.nioBuffer());
+                }
+
+                final int sslRead = SSL.readFromSSL(ssl, addr, len);
+                if (sslRead > 0) {
+                    dst.limit(pos + sslRead);
+                    buf.getBytes(0, dst);
+                    dst.limit(limit);
+                    return sslRead;
+                }
+            } finally {
+                buf.release();
+            }
+        }
+
+        return 0;
+    }
+
+    /**
+     * Read encrypted data from the OpenSSL network BIO
+     */
+    private int readEncryptedData(final ByteBuffer dst, final int pending) {
+        if (dst.isDirect() && dst.remaining() >= pending) {
+            final int pos = dst.position();
+            final long addr = Buffer.address(dst) + pos;
+            final int bioRead = SSL.readFromBIO(networkBIO, addr, pending);
+            if (bioRead > 0) {
+                dst.position(pos + bioRead);
+                return bioRead;
+            }
+        } else {
+            final ByteBuf buf = alloc.directBuffer(pending);
+            try {
+                final long addr;
+                if (buf.hasMemoryAddress()) {
+                    addr = buf.memoryAddress();
+                } else {
+                    addr = Buffer.address(buf.nioBuffer());
+                }
+
+                final int bioRead = SSL.readFromBIO(networkBIO, addr, pending);
+                if (bioRead > 0) {
+                    int oldLimit = dst.limit();
+                    dst.limit(dst.position() + bioRead);
+                    buf.getBytes(0, dst);
+                    dst.limit(oldLimit);
+                    return bioRead;
+                }
+            } finally {
+                buf.release();
+            }
+        }
+
+        return 0;
+    }
+
+    @Override
+    public synchronized SSLEngineResult wrap(
+            final ByteBuffer[] srcs, final int offset, final int length, final ByteBuffer dst) throws SSLException {
+
+        // Check to make sure the engine has not been closed
+        if (destroyed != 0) {
+            return new SSLEngineResult(CLOSED, NOT_HANDSHAKING, 0, 0);
+        }
+
+        // Throw required runtime exceptions
+        if (srcs == null) {
+            throw new NullPointerException("srcs");
+        }
+        if (dst == null) {
+            throw new NullPointerException("dst");
+        }
+
+        if (offset >= srcs.length || offset + length > srcs.length) {
+            throw new IndexOutOfBoundsException(
+                    "offset: " + offset + ", length: " + length +
+                            " (expected: offset <= offset + length <= srcs.length (" + srcs.length + "))");
+        }
+
+        if (dst.isReadOnly()) {
+            throw new ReadOnlyBufferException();
+        }
+
+        // Prepare OpenSSL to work in server mode and receive handshake
+        if (accepted == 0) {
+            beginHandshakeImplicitly();
+        }
+
+        // In handshake or close_notify stages, check if call to wrap was made
+        // without regard to the handshake status.
+        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
+        if ((!handshakeFinished || engineClosed) && handshakeStatus == NEED_UNWRAP) {
+            return new SSLEngineResult(getEngineStatus(), NEED_UNWRAP, 0, 0);
+        }
+
+        int bytesProduced = 0;
+        int pendingNet;
+
+        // Check for pending data in the network BIO
+        pendingNet = SSL.pendingWrittenBytesInBIO(networkBIO);
+        if (pendingNet > 0) {
+            // Do we have enough room in dst to write encrypted data?
+            int capacity = dst.remaining();
+            if (capacity < pendingNet) {
+                return new SSLEngineResult(BUFFER_OVERFLOW, handshakeStatus, 0, bytesProduced);
+            }
+
+            // Write the pending data from the network BIO into the dst buffer
+            try {
+                bytesProduced += readEncryptedData(dst, pendingNet);
+            } catch (Exception e) {
+                throw new SSLException(e);
+            }
+
+            // If isOuboundDone is set, then the data from the network BIO
+            // was the close_notify message -- we are not required to wait
+            // for the receipt the peer's close_notify message -- shutdown.
+            if (isOutboundDone) {
+                shutdown();
+            }
+
+            return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), 0, bytesProduced);
+        }
+
+        // There was no pending data in the network BIO -- encrypt any application data
+        int bytesConsumed = 0;
+        for (int i = offset; i < length; ++ i) {
+            final ByteBuffer src = srcs[i];
+            while (src.hasRemaining()) {
+
+                // Write plaintext application data to the SSL engine
+                try {
+                    bytesConsumed += writePlaintextData(src);
+                } catch (Exception e) {
+                    throw new SSLException(e);
+                }
+
+                // Check to see if the engine wrote data into the network BIO
+                pendingNet = SSL.pendingWrittenBytesInBIO(networkBIO);
+                if (pendingNet > 0) {
+                    // Do we have enough room in dst to write encrypted data?
+                    int capacity = dst.remaining();
+                    if (capacity < pendingNet) {
+                        return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), bytesConsumed, bytesProduced);
+                    }
+
+                    // Write the pending data from the network BIO into the dst buffer
+                    try {
+                        bytesProduced += readEncryptedData(dst, pendingNet);
+                    } catch (Exception e) {
+                        throw new SSLException(e);
+                    }
+
+                    return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);
+                }
+            }
+        }
+
+        return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);
+    }
+
+    @Override
+    public synchronized SSLEngineResult unwrap(
+            final ByteBuffer src, final ByteBuffer[] dsts, final int offset, final int length) throws SSLException {
+
+        // Check to make sure the engine has not been closed
+        if (destroyed != 0) {
+            return new SSLEngineResult(CLOSED, NOT_HANDSHAKING, 0, 0);
+        }
+
+        // Throw requried runtime exceptions
+        if (src == null) {
+            throw new NullPointerException("src");
+        }
+        if (dsts == null) {
+            throw new NullPointerException("dsts");
+        }
+        if (offset >= dsts.length || offset + length > dsts.length) {
+            throw new IndexOutOfBoundsException(
+                    "offset: " + offset + ", length: " + length +
+                            " (expected: offset <= offset + length <= dsts.length (" + dsts.length + "))");
+        }
+
+        int capacity = 0;
+        final int endOffset = offset + length;
+        for (int i = offset; i < endOffset; i ++) {
+            ByteBuffer dst = dsts[i];
+            if (dst == null) {
+                throw new IllegalArgumentException();
+            }
+            if (dst.isReadOnly()) {
+                throw new ReadOnlyBufferException();
+            }
+            capacity += dst.remaining();
+        }
+
+        // Prepare OpenSSL to work in server mode and receive handshake
+        if (accepted == 0) {
+            beginHandshakeImplicitly();
+        }
+
+        // In handshake or close_notify stages, check if call to unwrap was made
+        // without regard to the handshake status.
+        SSLEngineResult.HandshakeStatus handshakeStatus = getHandshakeStatus();
+        if ((!handshakeFinished || engineClosed) && handshakeStatus == NEED_WRAP) {
+            return new SSLEngineResult(getEngineStatus(), NEED_WRAP, 0, 0);
+        }
+
+        // protect against protocol overflow attack vector
+        if (src.remaining() > MAX_ENCRYPTED_PACKET_LENGTH) {
+            isInboundDone = true;
+            isOutboundDone = true;
+            engineClosed = true;
+            shutdown();
+            throw ENCRYPTED_PACKET_OVERSIZED;
+        }
+
+        // Write encrypted data to network BIO
+        int bytesConsumed = 0;
+        lastPrimingReadResult = 0;
+        try {
+            bytesConsumed += writeEncryptedData(src);
+        } catch (Exception e) {
+            throw new SSLException(e);
+        }
+
+        // Check for OpenSSL errors caused by the priming read
+        String error = SSL.getLastError();
+        if (error != null && !error.startsWith(OpenSsl.IGNORABLE_ERROR_PREFIX)) {
+            if (logger.isInfoEnabled()) {
+                logger.info(
+                        "SSL_read failed: primingReadResult: " + lastPrimingReadResult +
+                                "; OpenSSL error: '" + error + '\'');
+            }
+
+            // There was an internal error -- shutdown
+            shutdown();
+            throw new SSLException(error);
+        }
+
+        // There won't be any application data until we're done handshaking
+        int pendingApp = SSL.isInInit(ssl) == 0 ? SSL.pendingReadableBytesInSSL(ssl) : 0;
+
+        // Do we have enough room in dsts to write decrypted data?
+        if (capacity < pendingApp) {
+            return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), bytesConsumed, 0);
+        }
+
+        // Write decrypted data to dsts buffers
+        int bytesProduced = 0;
+        int idx = offset;
+        while (idx < endOffset) {
+            ByteBuffer dst = dsts[idx];
+            if (!dst.hasRemaining()) {
+                idx ++;
+                continue;
+            }
+
+            if (pendingApp <= 0) {
+                break;
+            }
+
+            int bytesRead;
+            try {
+                bytesRead = readPlaintextData(dst);
+            } catch (Exception e) {
+                throw new SSLException(e);
+            }
+
+            if (bytesRead == 0) {
+                break;
+            }
+
+            bytesProduced += bytesRead;
+            pendingApp -= bytesRead;
+
+            if (!dst.hasRemaining()) {
+                idx ++;
+            }
+        }
+
+        // Check to see if we received a close_notify message from the peer
+        if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {
+            receivedShutdown = true;
+            closeOutbound();
+            closeInbound();
+        }
+
+        return new SSLEngineResult(getEngineStatus(), getHandshakeStatus(), bytesConsumed, bytesProduced);
+    }
+
+    @Override
+    public Runnable getDelegatedTask() {
+        // Currently, we do not delegate SSL computation tasks
+        // TODO: in the future, possibly create tasks to do encrypt / decrypt async
+
+        return null;
+    }
+
+    @Override
+    public synchronized void closeInbound() throws SSLException {
+        if (isInboundDone) {
+            return;
+        }
+
+        isInboundDone = true;
+        engineClosed = true;
+
+        if (accepted != 0) {
+            if (!receivedShutdown) {
+                shutdown();
+                throw new SSLException(
+                        "Inbound closed before receiving peer's close_notify: possible truncation attack?");
+            }
+        } else {
+            // engine closing before initial handshake
+            shutdown();
+        }
+    }
+
+    @Override
+    public synchronized boolean isInboundDone() {
+        return isInboundDone || engineClosed;
+    }
+
+    @Override
+    public synchronized void closeOutbound() {
+        if (isOutboundDone) {
+            return;
+        }
+
+        isOutboundDone = true;
+        engineClosed = true;
+
+        if (accepted != 0 && destroyed == 0) {
+            int mode = SSL.getShutdown(ssl);
+            if ((mode & SSL.SSL_SENT_SHUTDOWN) != SSL.SSL_SENT_SHUTDOWN) {
+                SSL.shutdownSSL(ssl);
+            }
+        } else {
+            // engine closing before initial handshake
+            shutdown();
+        }
+    }
+
+    @Override
+    public synchronized boolean isOutboundDone() {
+        return isOutboundDone;
+    }
+
+    @Override
+    public String[] getSupportedCipherSuites() {
+        return EmptyArrays.EMPTY_STRINGS;
+    }
+
+    @Override
+    public String[] getEnabledCipherSuites() {
+        return EmptyArrays.EMPTY_STRINGS;
+    }
+
+    @Override
+    public void setEnabledCipherSuites(String[] strings) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String[] getSupportedProtocols() {
+        return EmptyArrays.EMPTY_STRINGS;
+    }
+
+    @Override
+    public String[] getEnabledProtocols() {
+        return EmptyArrays.EMPTY_STRINGS;
+    }
+
+    @Override
+    public void setEnabledProtocols(String[] strings) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public SSLSession getSession() {
+        SSLSession session = this.session;
+        if (session == null) {
+            this.session = session = new SSLSession() {
+                @Override
+                public byte[] getId() {
+                    return String.valueOf(ssl).getBytes();
+                }
+
+                @Override
+                public SSLSessionContext getSessionContext() {
+                    return null;
+                }
+
+                @Override
+                public long getCreationTime() {
+                    return 0;
+                }
+
+                @Override
+                public long getLastAccessedTime() {
+                    return 0;
+                }
+
+                @Override
+                public void invalidate() {
+                }
+
+                @Override
+                public boolean isValid() {
+                    return false;
+                }
+
+                @Override
+                public void putValue(String s, Object o) {
+                }
+
+                @Override
+                public Object getValue(String s) {
+                    return null;
+                }
+
+                @Override
+                public void removeValue(String s) {
+                }
+
+                @Override
+                public String[] getValueNames() {
+                    return EmptyArrays.EMPTY_STRINGS;
+                }
+
+                @Override
+                public Certificate[] getPeerCertificates() {
+                    return EMPTY_CERTIFICATES;
+                }
+
+                @Override
+                public Certificate[] getLocalCertificates() {
+                    return EMPTY_CERTIFICATES;
+                }
+
+                @Override
+                public X509Certificate[] getPeerCertificateChain() {
+                    return EMPTY_X509_CERTIFICATES;
+                }
+
+                @Override
+                public Principal getPeerPrincipal() {
+                    return null;
+                }
+
+                @Override
+                public Principal getLocalPrincipal() {
+                    return null;
+                }
+
+                @Override
+                public String getCipherSuite() {
+                    return cipher;
+                }
+
+                @Override
+                public String getProtocol() {
+                    // TODO: Figure out how to get the current protocol.
+                    String applicationProtocol = OpenSslEngine.this.applicationProtocol;
+                    if (applicationProtocol == null) {
+                        return "unknown";
+                    } else {
+                        return "unknown:" + applicationProtocol;
+                    }
+                }
+
+                @Override
+                public String getPeerHost() {
+                    return null;
+                }
+
+                @Override
+                public int getPeerPort() {
+                    return 0;
+                }
+
+                @Override
+                public int getPacketBufferSize() {
+                    return MAX_ENCRYPTED_PACKET_LENGTH;
+                }
+
+                @Override
+                public int getApplicationBufferSize() {
+                    return MAX_PLAINTEXT_LENGTH;
+                }
+            };
+        }
+
+        return session;
+    }
+
+    @Override
+    public synchronized void beginHandshake() throws SSLException {
+        if (engineClosed) {
+            throw ENGINE_CLOSED;
+        }
+
+        switch (accepted) {
+            case 0:
+                SSL.doHandshake(ssl);
+                accepted = 2;
+                break;
+            case 1:
+                // A user did not start handshake by calling this method by him/herself,
+                // but handshake has been started already by wrap() or unwrap() implicitly.
+                // Because it's the user's first time to call this method, it is unfair to
+                // raise an exception.  From the user's standpoint, he or she never asked
+                // for renegotiation.
+
+                accepted = 2; // Next time this method is invoked by the user, we should raise an exception.
+                break;
+            case 2:
+                throw RENEGOTIATION_UNSUPPORTED;
+            default:
+                throw new Error();
+        }
+    }
+
+    private synchronized void beginHandshakeImplicitly() throws SSLException {
+        if (engineClosed) {
+            throw ENGINE_CLOSED;
+        }
+
+        if (accepted == 0) {
+            SSL.doHandshake(ssl);
+            accepted = 1;
+        }
+    }
+
+    private SSLEngineResult.Status getEngineStatus() {
+        return engineClosed? CLOSED : OK;
+    }
+
+    @Override
+    public synchronized SSLEngineResult.HandshakeStatus getHandshakeStatus() {
+        if (accepted == 0 || destroyed != 0) {
+            return NOT_HANDSHAKING;
+        }
+
+        // Check if we are in the initial handshake phase
+        if (!handshakeFinished) {
+            // There is pending data in the network BIO -- call wrap
+            if (SSL.pendingWrittenBytesInBIO(networkBIO) != 0) {
+                return NEED_WRAP;
+            }
+
+            // No pending data to be sent to the peer
+            // Check to see if we have finished handshaking
+            if (SSL.isInInit(ssl) == 0) {
+                handshakeFinished = true;
+                cipher = SSL.getCipherForSSL(ssl);
+                String applicationProtocol = SSL.getNextProtoNegotiated(ssl);
+                if (applicationProtocol == null) {
+                    applicationProtocol = fallbackApplicationProtocol;
+                }
+                if (applicationProtocol != null) {
+                    this.applicationProtocol = applicationProtocol.replace(':', '_');
+                } else {
+                    this.applicationProtocol = null;
+                }
+                return FINISHED;
+            }
+
+            // No pending data and still handshaking
+            // Must be waiting on the peer to send more data
+            return NEED_UNWRAP;
+        }
+
+        // Check if we are in the shutdown phase
+        if (engineClosed) {
+            // Waiting to send the close_notify message
+            if (SSL.pendingWrittenBytesInBIO(networkBIO) != 0) {
+                return NEED_WRAP;
+            }
+
+            // Must be waiting to receive the close_notify message
+            return NEED_UNWRAP;
+        }
+
+        return NOT_HANDSHAKING;
+    }
+
+    @Override
+    public void setUseClientMode(boolean clientMode) {
+        if (clientMode) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    @Override
+    public boolean getUseClientMode() {
+        return false;
+    }
+
+    @Override
+    public void setNeedClientAuth(boolean b) {
+        if (b) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    @Override
+    public boolean getNeedClientAuth() {
+        return false;
+    }
+
+    @Override
+    public void setWantClientAuth(boolean b) {
+        if (b) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    @Override
+    public boolean getWantClientAuth() {
+        return false;
+    }
+
+    @Override
+    public void setEnableSessionCreation(boolean b) {
+        if (b) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    @Override
+    public boolean getEnableSessionCreation() {
+        return false;
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java
new file mode 100644
index 000000000000..b1a0257a1507
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java
@@ -0,0 +1,349 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ssl;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+import org.apache.tomcat.jni.Pool;
+import org.apache.tomcat.jni.SSL;
+import org.apache.tomcat.jni.SSLContext;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A server-side {@link SslContext} which uses OpenSSL's SSL/TLS implementation.
+ */
+public final class OpenSslServerContext extends SslContext {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(OpenSslServerContext.class);
+    private static final List<String> DEFAULT_CIPHERS;
+
+    static {
+        List<String> ciphers = new ArrayList<String>();
+        // XXX: Make sure to sync this list with JdkSslEngineFactory.
+        Collections.addAll(
+                ciphers,
+                "ECDHE-RSA-AES128-GCM-SHA256",
+                "ECDHE-RSA-RC4-SHA",
+                "ECDHE-RSA-AES128-SHA",
+                "ECDHE-RSA-AES256-SHA",
+                "AES128-GCM-SHA256",
+                "RC4-SHA",
+                "RC4-MD5",
+                "AES128-SHA",
+                "AES256-SHA",
+                "DES-CBC3-SHA");
+        DEFAULT_CIPHERS = Collections.unmodifiableList(ciphers);
+
+        if (logger.isDebugEnabled()) {
+            logger.debug("Default cipher suite (OpenSSL): " + ciphers);
+        }
+    }
+
+    private final long aprPool;
+
+    private final List<String> ciphers = new ArrayList<String>();
+    private final List<String> unmodifiableCiphers = Collections.unmodifiableList(ciphers);
+    private final long sessionCacheSize;
+    private final long sessionTimeout;
+    private final List<String> nextProtocols;
+
+    /** The OpenSSL SSL_CTX object */
+    private final long ctx;
+    private final OpenSslSessionStats stats;
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     */
+    public OpenSslServerContext(File certChainFile, File keyFile) throws SSLException {
+        this(certChainFile, keyFile, null);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @param keyPassword the password of the {@code keyFile}.
+     *                    {@code null} if it's not password-protected.
+     */
+    public OpenSslServerContext(File certChainFile, File keyFile, String keyPassword) throws SSLException {
+        this(certChainFile, keyFile, keyPassword, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @param keyPassword the password of the {@code keyFile}.
+     *                    {@code null} if it's not password-protected.
+     * @param ciphers the cipher suites to enable, in the order of preference.
+     *                {@code null} to use the default cipher suites.
+     * @param nextProtocols the application layer protocols to accept, in the order of preference.
+     *                      {@code null} to disable TLS NPN/ALPN extension.
+     * @param sessionCacheSize the size of the cache used for storing SSL session objects.
+     *                         {@code 0} to use the default value.
+     * @param sessionTimeout the timeout for the cached SSL session objects, in seconds.
+     *                       {@code 0} to use the default value.
+     */
+    public OpenSslServerContext(
+            File certChainFile, File keyFile, String keyPassword,
+            Iterable<String> ciphers, Iterable<String> nextProtocols,
+            long sessionCacheSize, long sessionTimeout) throws SSLException {
+
+        OpenSsl.ensureAvailability();
+
+        if (certChainFile == null) {
+            throw new NullPointerException("certChainFile");
+        }
+        if (!certChainFile.isFile()) {
+            throw new IllegalArgumentException("certChainFile is not a file: " + certChainFile);
+        }
+        if (keyFile == null) {
+            throw new NullPointerException("keyPath");
+        }
+        if (!keyFile.isFile()) {
+            throw new IllegalArgumentException("keyPath is not a file: " + keyFile);
+        }
+        if (ciphers == null) {
+            ciphers = DEFAULT_CIPHERS;
+        }
+
+        if (keyPassword == null) {
+            keyPassword = "";
+        }
+        if (nextProtocols == null) {
+            nextProtocols = Collections.emptyList();
+        }
+
+        for (String c: ciphers) {
+            if (c == null) {
+                break;
+            }
+            this.ciphers.add(c);
+        }
+
+        List<String> nextProtoList = new ArrayList<String>();
+        for (String p: nextProtocols) {
+            if (p == null) {
+                break;
+            }
+            nextProtoList.add(p);
+        }
+        this.nextProtocols = Collections.unmodifiableList(nextProtoList);
+
+        // Allocate a new APR pool.
+        aprPool = Pool.create(0);
+
+        // Create a new SSL_CTX and configure it.
+        boolean success = false;
+        try {
+            synchronized (OpenSslServerContext.class) {
+                try {
+                    ctx = SSLContext.make(aprPool, SSL.SSL_PROTOCOL_ALL, SSL.SSL_MODE_SERVER);
+                } catch (Exception e) {
+                    throw new SSLException("failed to create an SSL_CTX", e);
+                }
+
+                SSLContext.setOptions(ctx, SSL.SSL_OP_ALL);
+                SSLContext.setOptions(ctx, SSL.SSL_OP_NO_SSLv2);
+                SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);
+                SSLContext.setOptions(ctx, SSL.SSL_OP_SINGLE_ECDH_USE);
+                SSLContext.setOptions(ctx, SSL.SSL_OP_SINGLE_DH_USE);
+                SSLContext.setOptions(ctx, SSL.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
+
+                /* List the ciphers that the client is permitted to negotiate. */
+                try {
+                    // Convert the cipher list into a colon-separated string.
+                    StringBuilder cipherBuf = new StringBuilder();
+                    for (String c: this.ciphers) {
+                        cipherBuf.append(c);
+                        cipherBuf.append(':');
+                    }
+                    cipherBuf.setLength(cipherBuf.length() - 1);
+
+                    SSLContext.setCipherSuite(ctx, cipherBuf.toString());
+                } catch (SSLException e) {
+                    throw e;
+                } catch (Exception e) {
+                    throw new SSLException("failed to set cipher suite: " + this.ciphers, e);
+                }
+
+                /* Set certificate verification policy. */
+                SSLContext.setVerify(ctx, SSL.SSL_CVERIFY_NONE, 10);
+
+                /* Load the certificate file and private key. */
+                try {
+                    if (!SSLContext.setCertificate(
+                            ctx, certChainFile.getPath(), keyFile.getPath(), keyPassword, SSL.SSL_AIDX_RSA)) {
+                        throw new SSLException("failed to set certificate: " +
+                                certChainFile + " and " + keyFile + " (" + SSL.getLastError() + ')');
+                    }
+                } catch (SSLException e) {
+                    throw e;
+                } catch (Exception e) {
+                    throw new SSLException("failed to set certificate: " + certChainFile + " and " + keyFile, e);
+                }
+
+                /* Load the certificate chain. We must skip the first cert since it was loaded above. */
+                if (!SSLContext.setCertificateChainFile(ctx, certChainFile.getPath(), true)) {
+                    String error = SSL.getLastError();
+                    if (!error.startsWith(OpenSsl.IGNORABLE_ERROR_PREFIX)) {
+                        throw new SSLException(
+                                "failed to set certificate chain: " + certChainFile + " (" + SSL.getLastError() + ')');
+                    }
+                }
+
+                /* Set next protocols for next protocol negotiation extension, if specified */
+                if (!nextProtoList.isEmpty()) {
+                    // Convert the protocol list into a comma-separated string.
+                    StringBuilder nextProtocolBuf = new StringBuilder();
+                    for (String p: nextProtoList) {
+                        nextProtocolBuf.append(p);
+                        nextProtocolBuf.append(',');
+                    }
+                    nextProtocolBuf.setLength(nextProtocolBuf.length() - 1);
+
+                    SSLContext.setNextProtos(ctx, nextProtocolBuf.toString());
+                }
+
+                /* Set session cache size, if specified */
+                if (sessionCacheSize > 0) {
+                    this.sessionCacheSize = sessionCacheSize;
+                    SSLContext.setSessionCacheSize(ctx, sessionCacheSize);
+                } else {
+                    // Get the default session cache size using SSLContext.setSessionCacheSize()
+                    this.sessionCacheSize = sessionCacheSize = SSLContext.setSessionCacheSize(ctx, 20480);
+                    // Revert the session cache size to the default value.
+                    SSLContext.setSessionCacheSize(ctx, sessionCacheSize);
+                }
+
+                /* Set session timeout, if specified */
+                if (sessionTimeout > 0) {
+                    this.sessionTimeout = sessionTimeout;
+                    SSLContext.setSessionCacheTimeout(ctx, sessionTimeout);
+                } else {
+                    // Get the default session timeout using SSLContext.setSessionCacheTimeout()
+                    this.sessionTimeout = sessionTimeout = SSLContext.setSessionCacheTimeout(ctx, 300);
+                    // Revert the session timeout to the default value.
+                    SSLContext.setSessionCacheTimeout(ctx, sessionTimeout);
+                }
+            }
+            success = true;
+        } finally {
+            if (!success) {
+                destroyPools();
+            }
+        }
+
+        stats = new OpenSslSessionStats(ctx);
+    }
+
+    @Override
+    public boolean isClient() {
+        return false;
+    }
+
+    @Override
+    public List<String> cipherSuites() {
+        return unmodifiableCiphers;
+    }
+
+    @Override
+    public long sessionCacheSize() {
+        return sessionCacheSize;
+    }
+
+    @Override
+    public long sessionTimeout() {
+        return sessionTimeout;
+    }
+
+    @Override
+    public List<String> nextProtocols() {
+        return nextProtocols;
+    }
+
+    /**
+     * Returns the {@code SSL_CTX} object of this context.
+     */
+    public long context() {
+        return ctx;
+    }
+
+    /**
+     * Returns the stats of this context.
+     */
+    public OpenSslSessionStats stats() {
+        return stats;
+    }
+
+    /**
+     * Returns a new server-side {@link javax.net.ssl.SSLEngine} with the current configuration.
+     */
+    @Override
+    public SSLEngine newEngine(ByteBufAllocator alloc) {
+        if (nextProtocols.isEmpty()) {
+            return new OpenSslEngine(ctx, alloc, null);
+        } else {
+            return new OpenSslEngine(ctx, alloc, nextProtocols.get(nextProtocols.size() - 1));
+        }
+    }
+
+    @Override
+    public SSLEngine newEngine(ByteBufAllocator alloc, String peerHost, int peerPort) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Sets the SSL session ticket keys of this context.
+     */
+    public void setTicketKeys(byte[] keys) {
+        if (keys != null) {
+            throw new NullPointerException("keys");
+        }
+        SSLContext.setSessionTicketKeys(ctx, keys);
+    }
+
+    @Override
+    @SuppressWarnings("FinalizeDeclaration")
+    protected void finalize() throws Throwable {
+        super.finalize();
+        synchronized (OpenSslServerContext.class) {
+            if (ctx != 0) {
+                SSLContext.free(ctx);
+            }
+        }
+
+        destroyPools();
+    }
+
+    private void destroyPools() {
+        if (aprPool != 0) {
+            Pool.destroy(aprPool);
+        }
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionStats.java b/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionStats.java
new file mode 100644
index 000000000000..2ec514681d74
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionStats.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import org.apache.tomcat.jni.SSLContext;
+
+/**
+ * Stats exposed by an OpenSSL session context.
+ *
+ * @see <a href="https://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html"><code>SSL_CTX_sess_number</code></a>
+ */
+public final class OpenSslSessionStats {
+
+    private final long context;
+
+    OpenSslSessionStats(long context) {
+        this.context = context;
+    }
+
+    /**
+     * Returns the current number of sessions in the internal session cache.
+     */
+    public long number() {
+        return SSLContext.sessionNumber(context);
+    }
+
+    /**
+     * Returns the number of started SSL/TLS handshakes in client mode.
+     */
+    public long connect() {
+        return SSLContext.sessionConnect(context);
+    }
+
+    /**
+     * Returns the number of successfully established SSL/TLS sessions in client mode.
+     */
+    public long connectGood() {
+        return SSLContext.sessionConnectGood(context);
+    }
+
+    /**
+     * Returns the number of start renegotiations in client mode.
+     */
+    public long connectRenegotiate() {
+        return SSLContext.sessionConnectRenegotiate(context);
+    }
+
+    /**
+     * Returns the number of started SSL/TLS handshakes in server mode.
+     */
+    public long accept() {
+        return SSLContext.sessionAccept(context);
+    }
+
+    /**
+     * Returns the number of successfully established SSL/TLS sessions in server mode.
+     */
+    public long acceptGood() {
+        return SSLContext.sessionAcceptGood(context);
+    }
+
+    /**
+     * Returns the number of start renegotiations in server mode.
+     */
+    public long acceptRenegotiate() {
+        return SSLContext.sessionAcceptRenegotiate(context);
+    }
+
+    /**
+     * Returns the number of successfully reused sessions. In client mode, a session set with {@code SSL_set_session}
+     * successfully reused is counted as a hit. In server mode, a session successfully retrieved from internal or
+     * external cache is counted as a hit.
+     */
+    public long hits() {
+        return SSLContext.sessionHits(context);
+    }
+
+    /**
+     * Returns the number of successfully retrieved sessions from the external session cache in server mode.
+     */
+    public long cbHits() {
+        return SSLContext.sessionCbHits(context);
+    }
+
+    /**
+     * Returns the number of sessions proposed by clients that were not found in the internal session cache
+     * in server mode.
+     */
+    public long misses() {
+        return SSLContext.sessionMisses(context);
+    }
+
+    /**
+     * Returns the number of sessions proposed by clients and either found in the internal or external session cache
+     * in server mode, but that were invalid due to timeout. These sessions are not included in the {@link #hits()}
+     * count.
+     */
+    public long timeouts() {
+        return SSLContext.sessionTimeouts(context);
+    }
+
+    /**
+     * Returns the number of sessions that were removed because the maximum session cache size was exceeded.
+     */
+    public long cacheFull() {
+        return SSLContext.sessionCacheFull(context);
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/PemReader.java b/handler/src/main/java/io/netty/handler/ssl/PemReader.java
new file mode 100644
index 000000000000..ee606000bf22
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/PemReader.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.base64.Base64;
+import io.netty.util.CharsetUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.KeyException;
+import java.security.KeyStore;
+import java.security.cert.CertificateException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Reads a PEM file and converts it into a list of DERs so that they are imported into a {@link KeyStore} easily.
+ */
+final class PemReader {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PemReader.class);
+
+    private static final Pattern CERT_PATTERN = Pattern.compile(
+            "-+BEGIN\\s+.*CERTIFICATE[^-]*-+(?:\\s|\\r|\\n)+" + // Header
+                    "([a-z0-9+/=\\r\\n]+)" +                    // Base64 text
+                    "-+END\\s+.*CERTIFICATE[^-]*-+",            // Footer
+            Pattern.CASE_INSENSITIVE);
+    private static final Pattern KEY_PATTERN = Pattern.compile(
+            "-+BEGIN\\s+.*PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+" + // Header
+                    "([a-z0-9+/=\\r\\n]+)" +                       // Base64 text
+                    "-+END\\s+.*PRIVATE\\s+KEY[^-]*-+",            // Footer
+            Pattern.CASE_INSENSITIVE);
+
+    static ByteBuf[] readCertificates(File file) throws CertificateException {
+        String content;
+        try {
+            content = readContent(file);
+        } catch (IOException e) {
+            throw new CertificateException("failed to read a file: " + file, e);
+        }
+
+        List<ByteBuf> certs = new ArrayList<ByteBuf>();
+        Matcher m = CERT_PATTERN.matcher(content);
+        int start = 0;
+        for (;;) {
+            if (!m.find(start)) {
+                break;
+            }
+
+            ByteBuf base64 = Unpooled.copiedBuffer(m.group(1), CharsetUtil.US_ASCII);
+            ByteBuf der = Base64.decode(base64);
+            base64.release();
+            certs.add(der);
+
+            start = m.end();
+        }
+
+        if (certs.isEmpty()) {
+            throw new CertificateException("found no certificates: " + file);
+        }
+
+        return certs.toArray(new ByteBuf[certs.size()]);
+    }
+
+    static ByteBuf readPrivateKey(File file) throws KeyException {
+        String content;
+        try {
+            content = readContent(file);
+        } catch (IOException e) {
+            throw new KeyException("failed to read a file: " + file, e);
+        }
+
+        Matcher m = KEY_PATTERN.matcher(content);
+        if (!m.find()) {
+            throw new KeyException("found no private key: " + file);
+        }
+
+        ByteBuf base64 = Unpooled.copiedBuffer(m.group(1), CharsetUtil.US_ASCII);
+        ByteBuf der = Base64.decode(base64);
+        base64.release();
+        return der;
+    }
+
+    private static String readContent(File file) throws IOException {
+        InputStream in = new FileInputStream(file);
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        try {
+            byte[] buf = new byte[8192];
+            for (;;) {
+                int ret = in.read(buf);
+                if (ret < 0) {
+                    break;
+                }
+                out.write(buf, 0, ret);
+            }
+            return out.toString(CharsetUtil.US_ASCII.name());
+        } finally {
+            safeClose(in);
+            safeClose(out);
+        }
+    }
+
+    private static void safeClose(InputStream in) {
+        try {
+            in.close();
+        } catch (IOException e) {
+            logger.warn("Failed to close a stream.", e);
+        }
+    }
+
+    private static void safeClose(OutputStream out) {
+        try {
+            out.close();
+        } catch (IOException e) {
+            logger.warn("Failed to close a stream.", e);
+        }
+    }
+
+    private PemReader() { }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/SslContext.java b/handler/src/main/java/io/netty/handler/ssl/SslContext.java
new file mode 100644
index 000000000000..fde09e8d8db4
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java
@@ -0,0 +1,452 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import java.io.File;
+import java.util.List;
+
+/**
+ * A secure socket protocol implementation which acts as a factory for {@link SSLEngine} and {@link SslHandler}.
+ * Internally, it is implemented via JDK's {@link SSLContext} or OpenSSL's {@code SSL_CTX}.
+ *
+ * <h3>Making your server support SSL/TLS</h3>
+ * <pre>
+ * // In your {@link ChannelInitializer}:
+ * {@link ChannelPipeline} p = channel.pipeline();
+ * {@link SslContext} sslCtx = {@link #newServerContext(File, File) SslContext.newServerContext(...)};
+ * p.addLast("ssl", {@link #newEngine(ByteBufAllocator) sslCtx.newEngine(channel.alloc())});
+ * ...
+ * </pre>
+ *
+ * <h3>Making your client support SSL/TLS</h3>
+ * <pre>
+ * // In your {@link ChannelInitializer}:
+ * {@link ChannelPipeline} p = channel.pipeline();
+ * {@link SslContext} sslCtx = {@link #newClientContext(File) SslContext.newClientContext(...)};
+ * p.addLast("ssl", {@link #newEngine(ByteBufAllocator, String, int) sslCtx.newEngine(channel.alloc(), host, port)});
+ * ...
+ * </pre>
+ */
+public abstract class SslContext {
+
+    /**
+     * Returns the default server-side implementation provider currently in use.
+     *
+     * @return {@link SslProvider#OPENSSL} if OpenSSL is available. {@link SslProvider#JDK} otherwise.
+     */
+    public static SslProvider defaultServerProvider() {
+        if (OpenSsl.isAvailable()) {
+            return SslProvider.OPENSSL;
+        } else {
+            return SslProvider.JDK;
+        }
+    }
+
+    /**
+     * Returns the default client-side implementation provider currently in use.
+     *
+     * @return {@link SslProvider#JDK}, because it is the only implementation at the moment
+     */
+    public static SslProvider defaultClientProvider() {
+        return SslProvider.JDK;
+    }
+
+    /**
+     * Creates a new server-side {@link SslContext}.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @return a new server-side {@link SslContext}
+     */
+    public static SslContext newServerContext(File certChainFile, File keyFile) throws SSLException {
+        return newServerContext(null, certChainFile, keyFile, null, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new server-side {@link SslContext}.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @param keyPassword the password of the {@code keyFile}.
+     *                    {@code null} if it's not password-protected.
+     * @return a new server-side {@link SslContext}
+     */
+    public static SslContext newServerContext(
+            File certChainFile, File keyFile, String keyPassword) throws SSLException {
+        return newServerContext(null, certChainFile, keyFile, keyPassword, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new server-side {@link SslContext}.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @param keyPassword the password of the {@code keyFile}.
+     *                    {@code null} if it's not password-protected.
+     * @param ciphers the cipher suites to enable, in the order of preference.
+     *                {@code null} to use the default cipher suites.
+     * @param nextProtocols the application layer protocols to accept, in the order of preference.
+     *                      {@code null} to disable TLS NPN/ALPN extension.
+     * @param sessionCacheSize the size of the cache used for storing SSL session objects.
+     *                         {@code 0} to use the default value.
+     * @param sessionTimeout the timeout for the cached SSL session objects, in seconds.
+     *                       {@code 0} to use the default value.
+     * @return a new server-side {@link SslContext}
+     */
+    public static SslContext newServerContext(
+            File certChainFile, File keyFile, String keyPassword,
+            Iterable<String> ciphers, Iterable<String> nextProtocols,
+            long sessionCacheSize, long sessionTimeout) throws SSLException {
+        return newServerContext(
+                null, certChainFile, keyFile, keyPassword,
+                ciphers, nextProtocols, sessionCacheSize, sessionTimeout);
+    }
+
+    /**
+     * Creates a new server-side {@link SslContext}.
+     *
+     * @param provider the {@link SslContext} implementation to use.
+     *                 {@code null} to use the current default one.
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @return a new server-side {@link SslContext}
+     */
+    public static SslContext newServerContext(
+            SslProvider provider, File certChainFile, File keyFile) throws SSLException {
+        return newServerContext(provider, certChainFile, keyFile, null, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new server-side {@link SslContext}.
+     *
+     * @param provider the {@link SslContext} implementation to use.
+     *                 {@code null} to use the current default one.
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @param keyPassword the password of the {@code keyFile}.
+     *                    {@code null} if it's not password-protected.
+     * @return a new server-side {@link SslContext}
+     */
+    public static SslContext newServerContext(
+            SslProvider provider, File certChainFile, File keyFile, String keyPassword) throws SSLException {
+        return newServerContext(provider, certChainFile, keyFile, keyPassword, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new server-side {@link SslContext}.
+     *
+     * @param provider the {@link SslContext} implementation to use.
+     *                 {@code null} to use the current default one.
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     * @param keyFile a PKCS#8 private key file in PEM format
+     * @param keyPassword the password of the {@code keyFile}.
+     *                    {@code null} if it's not password-protected.
+     * @param ciphers the cipher suites to enable, in the order of preference.
+     *                {@code null} to use the default cipher suites.
+     * @param nextProtocols the application layer protocols to accept, in the order of preference.
+     *                      {@code null} to disable TLS NPN/ALPN extension.
+     * @param sessionCacheSize the size of the cache used for storing SSL session objects.
+     *                         {@code 0} to use the default value.
+     * @param sessionTimeout the timeout for the cached SSL session objects, in seconds.
+     *                       {@code 0} to use the default value.
+     * @return a new server-side {@link SslContext}
+     */
+    public static SslContext newServerContext(
+            SslProvider provider,
+            File certChainFile, File keyFile, String keyPassword,
+            Iterable<String> ciphers, Iterable<String> nextProtocols,
+            long sessionCacheSize, long sessionTimeout) throws SSLException {
+
+        if (provider == null) {
+            provider = OpenSsl.isAvailable()? SslProvider.OPENSSL : SslProvider.JDK;
+        }
+
+        switch (provider) {
+            case JDK:
+                return new JdkSslServerContext(
+                        certChainFile, keyFile, keyPassword,
+                        ciphers, nextProtocols, sessionCacheSize, sessionTimeout);
+            case OPENSSL:
+                return new OpenSslServerContext(
+                        certChainFile, keyFile, keyPassword,
+                        ciphers, nextProtocols, sessionCacheSize, sessionTimeout);
+            default:
+                throw new Error(provider.toString());
+        }
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext() throws SSLException {
+        return newClientContext(null, null, null, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(File certChainFile) throws SSLException {
+        return newClientContext(null, certChainFile, null, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(TrustManagerFactory trustManagerFactory) throws SSLException {
+        return newClientContext(null, null, trustManagerFactory, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format.
+     *                      {@code null} to use the system default
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(
+            File certChainFile, TrustManagerFactory trustManagerFactory) throws SSLException {
+        return newClientContext(null, certChainFile, trustManagerFactory, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param certChainFile an X.509 certificate chain file in PEM format.
+     *                      {@code null} to use the system default
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     * @param ciphers the cipher suites to enable, in the order of preference.
+     *                {@code null} to use the default cipher suites.
+     * @param nextProtocols the application layer protocols to accept, in the order of preference.
+     *                      {@code null} to disable TLS NPN/ALPN extension.
+     * @param sessionCacheSize the size of the cache used for storing SSL session objects.
+     *                         {@code 0} to use the default value.
+     * @param sessionTimeout the timeout for the cached SSL session objects, in seconds.
+     *                       {@code 0} to use the default value.
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(
+            File certChainFile, TrustManagerFactory trustManagerFactory,
+            Iterable<String> ciphers, Iterable<String> nextProtocols,
+            long sessionCacheSize, long sessionTimeout) throws SSLException {
+        return newClientContext(
+                null, certChainFile, trustManagerFactory,
+                ciphers, nextProtocols, sessionCacheSize, sessionTimeout);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param provider the {@link SslContext} implementation to use.
+     *                 {@code null} to use the current default one.
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(SslProvider provider) throws SSLException {
+        return newClientContext(provider, null, null, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param provider the {@link SslContext} implementation to use.
+     *                 {@code null} to use the current default one.
+     * @param certChainFile an X.509 certificate chain file in PEM format.
+     *                      {@code null} to use the system default
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(SslProvider provider, File certChainFile) throws SSLException {
+        return newClientContext(provider, certChainFile, null, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param provider the {@link SslContext} implementation to use.
+     *                 {@code null} to use the current default one.
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(
+            SslProvider provider, TrustManagerFactory trustManagerFactory) throws SSLException {
+        return newClientContext(provider, null, trustManagerFactory, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param provider the {@link SslContext} implementation to use.
+     *                 {@code null} to use the current default one.
+     * @param certChainFile an X.509 certificate chain file in PEM format.
+     *                      {@code null} to use the system default
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(
+            SslProvider provider, File certChainFile, TrustManagerFactory trustManagerFactory) throws SSLException {
+        return newClientContext(provider, certChainFile, trustManagerFactory, null, null, 0, 0);
+    }
+
+    /**
+     * Creates a new client-side {@link SslContext}.
+     *
+     * @param provider the {@link SslContext} implementation to use.
+     *                 {@code null} to use the current default one.
+     * @param certChainFile an X.509 certificate chain file in PEM format.
+     *                      {@code null} to use the system default
+     * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s
+     *                            that verifies the certificates sent from servers.
+     *                            {@code null} to use the default.
+     * @param ciphers the cipher suites to enable, in the order of preference.
+     *                {@code null} to use the default cipher suites.
+     * @param nextProtocols the application layer protocols to accept, in the order of preference.
+     *                      {@code null} to disable TLS NPN/ALPN extension.
+     * @param sessionCacheSize the size of the cache used for storing SSL session objects.
+     *                         {@code 0} to use the default value.
+     * @param sessionTimeout the timeout for the cached SSL session objects, in seconds.
+     *                       {@code 0} to use the default value.
+     *
+     * @return a new client-side {@link SslContext}
+     */
+    public static SslContext newClientContext(
+            SslProvider provider,
+            File certChainFile, TrustManagerFactory trustManagerFactory,
+            Iterable<String> ciphers, Iterable<String> nextProtocols,
+            long sessionCacheSize, long sessionTimeout) throws SSLException {
+
+        if (provider != null && provider != SslProvider.JDK) {
+            throw new SSLException("client context unsupported for: " + provider);
+        }
+
+        return new JdkSslClientContext(
+                certChainFile, trustManagerFactory,
+                ciphers, nextProtocols, sessionCacheSize, sessionTimeout);
+    }
+
+    SslContext() { }
+
+    /**
+     * Returns {@code true} if and only if this context is for server-side.
+     */
+    public final boolean isServer() {
+        return !isClient();
+    }
+
+    /**
+     * Returns the {@code true} if and only if this context is for client-side.
+     */
+    public abstract boolean isClient();
+
+    /**
+     * Returns the list of enabled cipher suites, in the order of preference.
+     */
+    public abstract List<String> cipherSuites();
+
+    /**
+     * Returns the size of the cache used for storing SSL session objects.
+     */
+    public abstract long sessionCacheSize();
+
+    /**
+     * Returns the timeout for the cached SSL session objects, in seconds.
+     */
+    public abstract long sessionTimeout();
+
+    /**
+     * Returns the list of application layer protocols for the TLS NPN/ALPN extension, in the order of preference.
+     *
+     * @return the list of application layer protocols.
+     *         {@code null} if NPN/ALPN extension has been disabled.
+     */
+    public abstract List<String> nextProtocols();
+
+    /**
+     * Creates a new {@link SSLEngine}.
+     *
+     * @return a new {@link SSLEngine}
+     */
+    public abstract SSLEngine newEngine(ByteBufAllocator alloc);
+
+    /**
+     * Creates a new {@link SSLEngine} using advisory peer information.
+     *
+     * @param peerHost the non-authoritative name of the host
+     * @param peerPort the non-authoritative port
+     *
+     * @return a new {@link SSLEngine}
+     */
+    public abstract SSLEngine newEngine(ByteBufAllocator alloc, String peerHost, int peerPort);
+
+    /**
+     * Creates a new {@link SslHandler}.
+     *
+     * @return a new {@link SslHandler}
+     */
+    public final SslHandler newHandler(ByteBufAllocator alloc) {
+        return newHandler(newEngine(alloc));
+    }
+
+    /**
+     * Creates a new {@link SslHandler} with advisory peer information.
+     *
+     * @param peerHost the non-authoritative name of the host
+     * @param peerPort the non-authoritative port
+     *
+     * @return a new {@link SslHandler}
+     */
+    public final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort) {
+        return newHandler(newEngine(alloc, peerHost, peerPort));
+    }
+
+    private static SslHandler newHandler(SSLEngine engine) {
+        return new SslHandler(engine);
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/SslHandler.java b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
index 57b71be4b842..7a380266de3d 100644
--- a/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
@@ -16,6 +16,7 @@
 package io.netty.handler.ssl;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
@@ -36,7 +37,6 @@
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PendingWrite;
 import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.RecyclableArrayList;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -181,9 +181,32 @@ public class SslHandler extends ByteToMessageDecoder implements ChannelOutboundH
     private final int maxPacketBufferSize;
     private final Executor delegatedTaskExecutor;
 
+    // BEGIN Platform-dependent flags
+
+    /**
+     * {@code trus} if and only if {@link SSLEngine} expects a direct buffer.
+     */
+    private final boolean wantsDirectBuffer;
+    /**
+     * {@code true} if and only if {@link SSLEngine#wrap(ByteBuffer, ByteBuffer)} requires the output buffer
+     * to be always as large as {@link #maxPacketBufferSize} even if the input buffer contains small amount of data.
+     * <p>
+     * If this flag is {@code false}, we allocate a smaller output buffer.
+     * </p>
+     */
+    private final boolean wantsLargeOutboundNetworkBuffer;
+    /**
+     * {@code true} if and only if {@link SSLEngine#unwrap(ByteBuffer, ByteBuffer)} expects a heap buffer rather than
+     * a direct buffer.  For an unknown reason, JDK8 SSLEngine causes JVM to crash when its cipher suite uses Galois
+     * Counter Mode (GCM).
+     */
+    private boolean wantsInboundHeapBuffer;
+
+    // END Platform-dependent flags
+
     private final boolean startTls;
     private boolean sentFirstMessage;
-
+    private boolean flushedBeforeHandshakeDone;
     private final LazyChannelPromise handshakePromise = new LazyChannelPromise();
     private final LazyChannelPromise sslCloseFuture = new LazyChannelPromise();
     private final Deque<PendingWrite> pendingUnencryptedWrites = new ArrayDeque<PendingWrite>();
@@ -195,7 +218,6 @@ public class SslHandler extends ByteToMessageDecoder implements ChannelOutboundH
     private boolean needsFlush;
 
     private int packetLength;
-    private ByteBuf decodeOut;
 
     private volatile long handshakeTimeoutMillis = 10000;
     private volatile long closeNotifyTimeoutMillis = 3000;
@@ -244,6 +266,9 @@ public SslHandler(SSLEngine engine, boolean startTls, Executor delegatedTaskExec
         this.delegatedTaskExecutor = delegatedTaskExecutor;
         this.startTls = startTls;
         maxPacketBufferSize = engine.getSession().getPacketBufferSize();
+
+        wantsDirectBuffer = engine instanceof OpenSslEngine;
+        wantsLargeOutboundNetworkBuffer = !(engine instanceof OpenSslEngine);
     }
 
     public long getHandshakeTimeoutMillis() {
@@ -345,10 +370,6 @@ public Future<Channel> sslCloseFuture() {
 
     @Override
     public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {
-        if (decodeOut != null) {
-            decodeOut.release();
-            decodeOut = null;
-        }
         for (;;) {
             PendingWrite write = pendingUnencryptedWrites.poll();
             if (write == null) {
@@ -370,7 +391,6 @@ public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, Sock
     }
 
     @Override
-    @Deprecated
     public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
         ctx.deregister(promise);
     }
@@ -416,6 +436,9 @@ public void flush(ChannelHandlerContext ctx) throws Exception {
         if (pendingUnencryptedWrites.isEmpty()) {
             pendingUnencryptedWrites.add(PendingWrite.newInstance(Unpooled.EMPTY_BUFFER, null));
         }
+        if (!handshakePromise.isDone()) {
+            flushedBeforeHandshakeDone = true;
+        }
         wrap(ctx, false);
         ctx.flush();
     }
@@ -429,9 +452,6 @@ private void wrap(ChannelHandlerContext ctx, boolean inUnwrap) throws SSLExcepti
                 if (pending == null) {
                     break;
                 }
-                if (out == null) {
-                    out = ctx.alloc().buffer(maxPacketBufferSize);
-                }
 
                 if (!(pending.msg() instanceof ByteBuf)) {
                     ctx.write(pending.msg(), (ChannelPromise) pending.recycleAndGet());
@@ -440,6 +460,10 @@ private void wrap(ChannelHandlerContext ctx, boolean inUnwrap) throws SSLExcepti
                 }
 
                 ByteBuf buf = (ByteBuf) pending.msg();
+                if (out == null) {
+                    out = allocateOutNetBuf(ctx, buf.readableBytes());
+                }
+
                 SSLEngineResult result = wrap(engine, buf, out);
 
                 if (!buf.isReadable()) {
@@ -470,6 +494,8 @@ private void wrap(ChannelHandlerContext ctx, boolean inUnwrap) throws SSLExcepti
                             setHandshakeSuccess();
                             // deliberate fall-through
                         case NOT_HANDSHAKING:
+                            setHandshakeSuccessIfStillHandshaking();
+                            // deliberate fall-through
                         case NEED_WRAP:
                             finishWrap(ctx, out, promise, inUnwrap);
                             promise = null;
@@ -478,7 +504,8 @@ private void wrap(ChannelHandlerContext ctx, boolean inUnwrap) throws SSLExcepti
                         case NEED_UNWRAP:
                             return;
                         default:
-                            throw new IllegalStateException("Unknown handshake status: " + result.getHandshakeStatus());
+                            throw new IllegalStateException(
+                                    "Unknown handshake status: " + result.getHandshakeStatus());
                     }
                 }
             }
@@ -514,7 +541,7 @@ private void wrapNonAppData(ChannelHandlerContext ctx, boolean inUnwrap) throws
         try {
             for (;;) {
                 if (out == null) {
-                    out = ctx.alloc().buffer(maxPacketBufferSize);
+                    out = allocateOutNetBuf(ctx, 0);
                 }
                 SSLEngineResult result = wrap(engine, Unpooled.EMPTY_BUFFER, out);
 
@@ -535,16 +562,17 @@ private void wrapNonAppData(ChannelHandlerContext ctx, boolean inUnwrap) throws
                         break;
                     case NEED_UNWRAP:
                         if (!inUnwrap) {
-                            unwrap(ctx);
+                            unwrapNonAppData(ctx);
                         }
                         break;
                     case NEED_WRAP:
                         break;
                     case NOT_HANDSHAKING:
+                        setHandshakeSuccessIfStillHandshaking();
                         // Workaround for TLS False Start problem reported at:
                         // https://github.com/netty/netty/issues/1108#issuecomment-14266970
                         if (!inUnwrap) {
-                            unwrap(ctx);
+                            unwrapNonAppData(ctx);
                         }
                         break;
                     default:
@@ -567,6 +595,12 @@ private void wrapNonAppData(ChannelHandlerContext ctx, boolean inUnwrap) throws
 
     private SSLEngineResult wrap(SSLEngine engine, ByteBuf in, ByteBuf out) throws SSLException {
         ByteBuffer in0 = in.nioBuffer();
+        if (!in0.isDirect()) {
+            ByteBuffer newIn0 = ByteBuffer.allocateDirect(in0.remaining());
+            newIn0.put(in0).flip();
+            in0 = newIn0;
+        }
+
         for (;;) {
             ByteBuffer out0 = out.nioBuffer(out.writerIndex(), out.writableBytes());
             SSLEngineResult result = engine.wrap(in0, out0);
@@ -657,7 +691,7 @@ private boolean ignoreException(Throwable t) {
                     // No match by now.. Try to load the class via classloader and inspect it.
                     // This is mainly done as other JDK implementations may differ in name of
                     // the impl.
-                    Class<?> clazz = getClass().getClassLoader().loadClass(classname);
+                    Class<?> clazz = PlatformDependent.getClassLoader(getClass()).loadClass(classname);
 
                     if (SocketChannel.class.isAssignableFrom(clazz)
                             || DatagramChannel.class.isAssignableFrom(clazz)) {
@@ -771,9 +805,11 @@ private static int getEncryptedPacketLength(ByteBuf buffer, int offset) {
 
     @Override
     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws SSLException {
+
         final int startOffset = in.readerIndex();
         final int endOffset = in.writerIndex();
         int offset = startOffset;
+        int totalLength = 0;
 
         // If we calculated the length of the current SSL record before, use that information.
         if (packetLength > 0) {
@@ -781,13 +817,14 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 return;
             } else {
                 offset += packetLength;
+                totalLength = packetLength;
                 packetLength = 0;
             }
         }
 
         boolean nonSslRecord = false;
 
-        for (;;) {
+        while (totalLength < OpenSslEngine.MAX_ENCRYPTED_PACKET_LENGTH) {
             final int readableBytes = endOffset - offset;
             if (readableBytes < 5) {
                 break;
@@ -807,11 +844,19 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                 break;
             }
 
+            int newTotalLength = totalLength + packetLength;
+            if (newTotalLength > OpenSslEngine.MAX_ENCRYPTED_PACKET_LENGTH) {
+                // Don't read too much.
+                break;
+            }
+
+            // We have a whole packet.
+            // Increment the offset to handle the next packet.
             offset += packetLength;
+            totalLength = newTotalLength;
         }
 
-        final int length = offset - startOffset;
-        if (length > 0) {
+        if (totalLength > 0) {
             // The buffer contains one or more full SSL records.
             // Slice out the whole packet so unwrap will only be called with complete packets.
             // Also directly reset the packetLength. This is needed as unwrap(..) may trigger
@@ -822,9 +867,11 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             // 4) unwrapLater(...) calls decode(...)
             //
             // See https://github.com/netty/netty/issues/1534
-            in.skipBytes(length);
-            ByteBuffer buffer = in.nioBuffer(startOffset, length);
-            unwrap(ctx, buffer, out);
+
+            in.skipBytes(totalLength);
+            final ByteBuffer inNetBuf = in.nioBuffer(startOffset, totalLength);
+            unwrap(ctx, inNetBuf, totalLength);
+            assert !inNetBuf.hasRemaining() || engine.isInboundDone();
         }
 
         if (nonSslRecord) {
@@ -846,35 +893,43 @@ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
         super.channelReadComplete(ctx);
     }
 
-    private void unwrap(ChannelHandlerContext ctx) throws SSLException {
-        RecyclableArrayList out = RecyclableArrayList.newInstance();
-        try {
-            unwrap(ctx, Unpooled.EMPTY_BUFFER.nioBuffer(), out);
-            final int size = out.size();
-            for (int i = 0; i < size; i++) {
-                ctx.fireChannelRead(out.get(i));
-            }
-        } finally {
-            out.recycle();
-        }
+    /**
+     * Calls {@link SSLEngine#unwrap(ByteBuffer, ByteBuffer)} with an empty buffer to handle handshakes, etc.
+     */
+    private void unwrapNonAppData(ChannelHandlerContext ctx) throws SSLException {
+        unwrap(ctx, Unpooled.EMPTY_BUFFER.nioBuffer(), 0);
     }
 
-    private void unwrap(ChannelHandlerContext ctx, ByteBuffer packet, List<Object> out) throws SSLException {
+    /**
+     * Unwraps inbound SSL records.
+     */
+    private void unwrap(
+            ChannelHandlerContext ctx, ByteBuffer packet, int initialOutAppBufCapacity) throws SSLException {
+
+        // If SSLEngine expects a heap buffer for unwrapping, do the conversion.
+        final ByteBuffer oldPacket;
+        final ByteBuf newPacket;
+        final int oldPos = packet.position();
+        if (wantsInboundHeapBuffer && packet.isDirect()) {
+            newPacket = ctx.alloc().heapBuffer(packet.limit() - oldPos);
+            newPacket.writeBytes(packet);
+            oldPacket = packet;
+            packet = newPacket.nioBuffer();
+        } else {
+            oldPacket = null;
+            newPacket = null;
+        }
+
         boolean wrapLater = false;
-        int totalProduced = 0;
+        ByteBuf decodeOut = allocate(ctx, initialOutAppBufCapacity);
         try {
             for (;;) {
-                if (decodeOut == null) {
-                    decodeOut = ctx.alloc().buffer(packet.remaining());
-                }
-
                 final SSLEngineResult result = unwrap(engine, packet, decodeOut);
                 final Status status = result.getStatus();
                 final HandshakeStatus handshakeStatus = result.getHandshakeStatus();
                 final int produced = result.bytesProduced();
                 final int consumed = result.bytesConsumed();
 
-                totalProduced += produced;
                 if (status == Status.CLOSED) {
                     // notify about the CLOSED state of the SSLEngine. See #137
                     sslCloseFuture.trySuccess(ctx.channel());
@@ -895,6 +950,18 @@ private void unwrap(ChannelHandlerContext ctx, ByteBuffer packet, List<Object> o
                         wrapLater = true;
                         continue;
                     case NOT_HANDSHAKING:
+                        if (setHandshakeSuccessIfStillHandshaking()) {
+                            wrapLater = true;
+                            continue;
+                        }
+                        if (flushedBeforeHandshakeDone) {
+                            // We need to call wrap(...) in case there was a flush done before the handshake completed.
+                            //
+                            // See https://github.com/netty/netty/pull/2437
+                            flushedBeforeHandshakeDone = false;
+                            wrapLater = true;
+                        }
+
                         break;
                     default:
                         throw new IllegalStateException("Unknown handshake status: " + handshakeStatus);
@@ -912,10 +979,17 @@ private void unwrap(ChannelHandlerContext ctx, ByteBuffer packet, List<Object> o
             setHandshakeFailure(e);
             throw e;
         } finally {
-            if (totalProduced > 0) {
-                ByteBuf decodeOut = this.decodeOut;
-                this.decodeOut = null;
-                out.add(decodeOut);
+            // If we converted packet into a heap buffer at the beginning of this method,
+            // we should synchronize the position of the original buffer.
+            if (newPacket != null) {
+                oldPacket.position(oldPos + packet.position());
+                newPacket.release();
+            }
+
+            if (decodeOut.isReadable()) {
+                ctx.fireChannelRead(decodeOut);
+            } else {
+                decodeOut.release();
             }
         }
     }
@@ -1006,11 +1080,35 @@ public void run() {
         }
     }
 
+    /**
+     * Works around some Android {@link SSLEngine} implementations that skip {@link HandshakeStatus#FINISHED} and
+     * go straight into {@link HandshakeStatus#NOT_HANDSHAKING} when handshake is finished.
+     *
+     * @return {@code true} if and only if the workaround has been applied and thus {@link #handshakeFuture} has been
+     *         marked as success by this method
+     */
+    private boolean setHandshakeSuccessIfStillHandshaking() {
+        if (!handshakePromise.isDone()) {
+            setHandshakeSuccess();
+            return true;
+        }
+        return false;
+    }
+
     /**
      * Notify all the handshake futures about the successfully handshake
      */
     private void setHandshakeSuccess() {
+        // Work around the JVM crash which occurs when a cipher suite with GCM enabled.
+        final String cipherSuite = String.valueOf(engine.getSession().getCipherSuite());
+        if (!wantsDirectBuffer && (cipherSuite.contains("_GCM_") || cipherSuite.contains("-GCM-"))) {
+            wantsInboundHeapBuffer = true;
+        }
+
         if (handshakePromise.trySuccess(ctx.channel())) {
+            if (logger.isDebugEnabled()) {
+                logger.debug(ctx.channel() + " HANDSHAKEN: " + engine.getSession().getCipherSuite());
+            }
             ctx.fireUserEventTriggered(SslHandshakeCompletionEvent.SUCCESS);
         }
     }
@@ -1075,7 +1173,7 @@ private void closeOutboundAndChannel(
     public void handlerAdded(final ChannelHandlerContext ctx) throws Exception {
         this.ctx = ctx;
 
-        if (ctx.channel().isActive()) {
+        if (ctx.channel().isActive() && engine.getUseClientMode()) {
             // channelActive() event has been fired already, which means this.channelActive() will
             // not be invoked. We have to initialize here instead.
             handshake();
@@ -1139,6 +1237,7 @@ public void operationComplete(Future<Channel> future) throws Exception {
         }
         ctx.fireChannelActive();
     }
+
     private void safeClose(
             final ChannelHandlerContext ctx, ChannelFuture flushFuture,
             final ChannelPromise promise) {
@@ -1171,13 +1270,40 @@ public void operationComplete(ChannelFuture f)
                 if (timeoutFuture != null) {
                     timeoutFuture.cancel(false);
                 }
-                if (ctx.channel().isActive()) {
-                    ctx.close(promise);
-                }
+                // Trigger the close in all cases to make sure the promise is notified
+                // See https://github.com/netty/netty/issues/2358
+                ctx.close(promise);
             }
         });
     }
 
+    /**
+     * Always prefer a direct buffer when it's pooled, so that we reduce the number of memory copies
+     * in {@link OpenSslEngine}.
+     */
+    private ByteBuf allocate(ChannelHandlerContext ctx, int capacity) {
+        ByteBufAllocator alloc = ctx.alloc();
+        if (wantsDirectBuffer) {
+            return alloc.directBuffer(capacity);
+        } else {
+            return alloc.buffer(capacity);
+        }
+    }
+
+    /**
+     * Allocates an outbound network buffer for {@link SSLEngine#wrap(ByteBuffer, ByteBuffer)} which can encrypt
+     * the specified amount of pending bytes.
+     */
+    private ByteBuf allocateOutNetBuf(ChannelHandlerContext ctx, int pendingBytes) {
+        if (wantsLargeOutboundNetworkBuffer) {
+            return allocate(ctx, maxPacketBufferSize);
+        } else {
+            return allocate(ctx, Math.min(
+                    pendingBytes + OpenSslEngine.MAX_ENCRYPTION_OVERHEAD_LENGTH,
+                    maxPacketBufferSize));
+        }
+    }
+
     private final class LazyChannelPromise extends DefaultPromise<Channel> {
 
         @Override
diff --git a/handler/src/main/java/io/netty/handler/ssl/SslProvider.java b/handler/src/main/java/io/netty/handler/ssl/SslProvider.java
new file mode 100644
index 000000000000..3d4f08bfa9ed
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/SslProvider.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl;
+
+/**
+ * An enumeration of SSL/TLS protocol providers.
+ */
+public enum SslProvider {
+    /**
+     * JDK's default implementation.
+     */
+    JDK,
+    /**
+     * OpenSSL-based implementation.
+     */
+    OPENSSL
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleSelfSignedCertGenerator.java b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleSelfSignedCertGenerator.java
new file mode 100644
index 000000000000..88a7c9dbabde
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleSelfSignedCertGenerator.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl.util;
+
+import org.bouncycastle.asn1.x500.X500Name;
+import org.bouncycastle.cert.X509CertificateHolder;
+import org.bouncycastle.cert.X509v3CertificateBuilder;
+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
+import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.operator.ContentSigner;
+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
+
+import java.math.BigInteger;
+import java.security.KeyPair;
+import java.security.PrivateKey;
+import java.security.Provider;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+
+import static io.netty.handler.ssl.util.SelfSignedCertificate.*;
+
+/**
+ * Generates a self-signed certificate using <a href="http://www.bouncycastle.org/">Bouncy Castle</a>.
+ */
+final class BouncyCastleSelfSignedCertGenerator {
+
+    private static final Provider PROVIDER = new BouncyCastleProvider();
+
+    static String[] generate(String fqdn, KeyPair keypair, SecureRandom random) throws Exception {
+        PrivateKey key = keypair.getPrivate();
+
+        // Prepare the information required for generating an X.509 certificate.
+        X500Name owner = new X500Name("CN=" + fqdn);
+        X509v3CertificateBuilder builder = new JcaX509v3CertificateBuilder(
+                owner, new BigInteger(64, random), NOT_BEFORE, NOT_AFTER, owner, keypair.getPublic());
+
+        ContentSigner signer = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(key);
+        X509CertificateHolder certHolder = builder.build(signer);
+        X509Certificate cert = new JcaX509CertificateConverter().setProvider(PROVIDER).getCertificate(certHolder);
+        cert.verify(keypair.getPublic());
+
+        return newSelfSignedCertificate(fqdn, key, cert);
+    }
+
+    private BouncyCastleSelfSignedCertGenerator() { }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java b/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
new file mode 100644
index 000000000000..6439528ebe9f
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl.util;
+
+import io.netty.buffer.ByteBufUtil;
+import io.netty.buffer.Unpooled;
+import io.netty.util.internal.EmptyArrays;
+import io.netty.util.concurrent.FastThreadLocal;
+
+import javax.net.ssl.ManagerFactoryParameters;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import java.security.KeyStore;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.regex.Pattern;
+
+/**
+ * An {@link TrustManagerFactory} that trusts an X.509 certificate whose SHA1 checksum matches.
+ * <p>
+ * <strong>NOTE:</strong>
+ * Never use this {@link TrustManagerFactory} in production unless you are not sure what you are exactly doing with it.
+ * </p><p>
+ * The SHA1 checksum of an X.509 certificate is calculated from its DER encoded format.  You can get the fingerprint of
+ * an X.509 certificate using the {@code openssl} command.  For example:
+ * <pre>
+ * $ openssl x509 -fingerprint -sha1 -in my_certificate.crt
+ * SHA1 Fingerprint=4E:85:10:55:BC:7B:12:08:D1:EA:0A:12:C9:72:EE:F3:AA:B2:C7:CB
+ * -----BEGIN CERTIFICATE-----
+ * MIIBqjCCAROgAwIBAgIJALiT3Nvp0kvmMA0GCSqGSIb3DQEBBQUAMBYxFDASBgNV
+ * BAMTC2V4YW1wbGUuY29tMCAXDTcwMDEwMTAwMDAwMFoYDzk5OTkxMjMxMjM1OTU5
+ * WjAWMRQwEgYDVQQDEwtleGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAw
+ * gYkCgYEAnadvODG0QCiHhaFZlLHtr5gLIkDQS8ErZ//KfqeCHTC/KJsl3xYFk0zG
+ * aCv2FcmkOlokm77qV8qOW2DZdND7WuYzX6nLVuLb+GYxZ7b45iMAbAajvGh8jc9U
+ * o07fUIahGqTDAIAGCWsoLUOQ9nMzO/8GRHcXJAeQ2MGY2VpCcv0CAwEAATANBgkq
+ * hkiG9w0BAQUFAAOBgQBpRCnmjmNM0D7yrpkUJpBTNiqinhKLbeOvPWm+YmdInUUs
+ * LoMu0mZ1IANemLwqbwJJ76fknngeB+YuVAj46SurvVCV6ekwHcbgpW1u063IRwKk
+ * tQhOBO0HQxldUS4+4MYv/kuvnKkbjfgh5qfWw89Kx4kD+cycpP4yPtgDGk8ZMA==
+ * -----END CERTIFICATE-----
+ * </pre>
+ * </p>
+ */
+public final class FingerprintTrustManagerFactory extends SimpleTrustManagerFactory {
+
+    private static final Pattern FINGERPRINT_PATTERN = Pattern.compile("^[0-9a-fA-F:]+$");
+    private static final Pattern FINGERPRINT_STRIP_PATTERN = Pattern.compile(":");
+    private static final int SHA1_BYTE_LEN = 20;
+    private static final int SHA1_HEX_LEN = SHA1_BYTE_LEN * 2;
+
+    private static final FastThreadLocal<MessageDigest> tlmd = new FastThreadLocal<MessageDigest>() {
+        @Override
+        protected MessageDigest initialValue() {
+            try {
+                return MessageDigest.getInstance("SHA1");
+            } catch (NoSuchAlgorithmException e) {
+                // All Java implementation must have SHA1 digest algorithm.
+                throw new Error(e);
+            }
+        }
+    };
+
+    private final TrustManager tm = new X509TrustManager() {
+
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String s) throws CertificateException {
+            checkTrusted("client", chain);
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String s) throws CertificateException {
+            checkTrusted("server", chain);
+        }
+
+        private void checkTrusted(String type, X509Certificate[] chain) throws CertificateException {
+            X509Certificate cert = chain[0];
+            byte[] fingerprint = fingerprint(cert);
+            boolean found = false;
+            for (byte[] allowedFingerprint: fingerprints) {
+                if (Arrays.equals(fingerprint, allowedFingerprint)) {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found) {
+                throw new CertificateException(
+                        type + " certificate with unknown fingerprint: " + cert.getSubjectDN());
+            }
+        }
+
+        private byte[] fingerprint(X509Certificate cert) throws CertificateEncodingException {
+            MessageDigest md = tlmd.get();
+            md.reset();
+            return md.digest(cert.getEncoded());
+        }
+
+        @Override
+        public X509Certificate[] getAcceptedIssuers() {
+            return EmptyArrays.EMPTY_X509_CERTIFICATES;
+        }
+    };
+
+    private final byte[][] fingerprints;
+
+    /**
+     * Creates a new instance.
+     *
+     * @param fingerprints a list of SHA1 fingerprints in heaxdecimal form
+     */
+    public FingerprintTrustManagerFactory(Iterable<String> fingerprints) {
+        this(toFingerprintArray(fingerprints));
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param fingerprints a list of SHA1 fingerprints in heaxdecimal form
+     */
+    public FingerprintTrustManagerFactory(String... fingerprints) {
+        this(toFingerprintArray(Arrays.asList(fingerprints)));
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param fingerprints a list of SHA1 fingerprints
+     */
+    public FingerprintTrustManagerFactory(byte[]... fingerprints) {
+        if (fingerprints == null) {
+            throw new NullPointerException("fingerprints");
+        }
+
+        List<byte[]> list = new ArrayList<byte[]>();
+        for (byte[] f: fingerprints) {
+            if (f == null) {
+                break;
+            }
+            if (f.length != SHA1_BYTE_LEN) {
+                throw new IllegalArgumentException("malformed fingerprint: " +
+                        ByteBufUtil.hexDump(Unpooled.wrappedBuffer(f)) + " (expected: SHA1)");
+            }
+            list.add(f.clone());
+        }
+
+        this.fingerprints = list.toArray(new byte[list.size()][]);
+    }
+
+    private static byte[][] toFingerprintArray(Iterable<String> fingerprints) {
+        if (fingerprints == null) {
+            throw new NullPointerException("fingerprints");
+        }
+
+        List<byte[]> list = new ArrayList<byte[]>();
+        for (String f: fingerprints) {
+            if (f == null) {
+                break;
+            }
+
+            if (!FINGERPRINT_PATTERN.matcher(f).matches()) {
+                throw new IllegalArgumentException("malformed fingerprint: " + f);
+            }
+            f = FINGERPRINT_STRIP_PATTERN.matcher(f).replaceAll("");
+            if (f.length() != SHA1_HEX_LEN) {
+                throw new IllegalArgumentException("malformed fingerprint: " + f + " (expected: SHA1)");
+            }
+
+            byte[] farr = new byte[SHA1_BYTE_LEN];
+            for (int i = 0; i < farr.length; i ++) {
+                int strIdx = i << 1;
+                farr[i] = (byte) Integer.parseInt(f.substring(strIdx, strIdx + 2), 16);
+            }
+        }
+
+        return list.toArray(new byte[list.size()][]);
+    }
+
+    @Override
+    protected void engineInit(KeyStore keyStore) throws Exception { }
+
+    @Override
+    protected void engineInit(ManagerFactoryParameters managerFactoryParameters) throws Exception { }
+
+    @Override
+    protected TrustManager[] engineGetTrustManagers() {
+        return new TrustManager[] { tm };
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/InsecureTrustManagerFactory.java b/handler/src/main/java/io/netty/handler/ssl/util/InsecureTrustManagerFactory.java
new file mode 100644
index 000000000000..04799758fd78
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/util/InsecureTrustManagerFactory.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl.util;
+
+import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import javax.net.ssl.ManagerFactoryParameters;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import java.security.KeyStore;
+import java.security.cert.X509Certificate;
+
+/**
+ * An insecure {@link javax.net.ssl.TrustManagerFactory} that trusts all X.509 certificates without any verification.
+ * <p>
+ * <strong>NOTE:</strong>
+ * Never use this {@link javax.net.ssl.TrustManagerFactory} in production.
+ * It is purely for testing purposes, and thus it is very insecure.
+ * </p>
+ */
+public final class InsecureTrustManagerFactory extends SimpleTrustManagerFactory {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(InsecureTrustManagerFactory.class);
+
+    public static final TrustManagerFactory INSTANCE = new InsecureTrustManagerFactory();
+
+    private static final TrustManager tm = new X509TrustManager() {
+        @Override
+        public void checkClientTrusted(X509Certificate[] chain, String s) {
+            logger.debug("Accepting a client certificate: " + chain[0].getSubjectDN());
+        }
+
+        @Override
+        public void checkServerTrusted(X509Certificate[] chain, String s) {
+            logger.debug("Accepting a server certificate: " + chain[0].getSubjectDN());
+        }
+
+        @Override
+        public X509Certificate[] getAcceptedIssuers() {
+            return EmptyArrays.EMPTY_X509_CERTIFICATES;
+        }
+    };
+
+    private InsecureTrustManagerFactory() { }
+
+    @Override
+    protected void engineInit(KeyStore keyStore) throws Exception { }
+
+    @Override
+    protected void engineInit(ManagerFactoryParameters managerFactoryParameters) throws Exception { }
+
+    @Override
+    protected TrustManager[] engineGetTrustManagers() {
+        return new TrustManager[] { tm };
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java
new file mode 100644
index 000000000000..d1559eb70d89
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl.util;
+
+import sun.security.x509.AlgorithmId;
+import sun.security.x509.CertificateAlgorithmId;
+import sun.security.x509.CertificateIssuerName;
+import sun.security.x509.CertificateSerialNumber;
+import sun.security.x509.CertificateSubjectName;
+import sun.security.x509.CertificateValidity;
+import sun.security.x509.CertificateVersion;
+import sun.security.x509.CertificateX509Key;
+import sun.security.x509.X500Name;
+import sun.security.x509.X509CertImpl;
+import sun.security.x509.X509CertInfo;
+
+import java.math.BigInteger;
+import java.security.KeyPair;
+import java.security.PrivateKey;
+import java.security.SecureRandom;
+import java.security.cert.CertificateException;
+
+import static io.netty.handler.ssl.util.SelfSignedCertificate.*;
+
+/**
+ * Generates a self-signed certificate using {@code sun.security.x509} package provided by OpenJDK.
+ */
+final class OpenJdkSelfSignedCertGenerator {
+
+    static String[] generate(String fqdn, KeyPair keypair, SecureRandom random) throws Exception {
+        PrivateKey key = keypair.getPrivate();
+
+        // Prepare the information required for generating an X.509 certificate.
+        X509CertInfo info = new X509CertInfo();
+        X500Name owner = new X500Name("CN=" + fqdn);
+        info.set(X509CertInfo.VERSION, new CertificateVersion(CertificateVersion.V3));
+        info.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(new BigInteger(64, random)));
+        try {
+            info.set(X509CertInfo.SUBJECT, new CertificateSubjectName(owner));
+        } catch (CertificateException ignore) {
+            info.set(X509CertInfo.SUBJECT, owner);
+        }
+        try {
+            info.set(X509CertInfo.ISSUER, new CertificateIssuerName(owner));
+        } catch (CertificateException ignore) {
+            info.set(X509CertInfo.ISSUER, owner);
+        }
+        info.set(X509CertInfo.VALIDITY, new CertificateValidity(NOT_BEFORE, NOT_AFTER));
+        info.set(X509CertInfo.KEY, new CertificateX509Key(keypair.getPublic()));
+        info.set(X509CertInfo.ALGORITHM_ID,
+                new CertificateAlgorithmId(new AlgorithmId(AlgorithmId.sha1WithRSAEncryption_oid)));
+
+        // Sign the cert to identify the algorithm that's used.
+        X509CertImpl cert = new X509CertImpl(info);
+        cert.sign(key, "SHA1withRSA");
+
+        // Update the algorithm and sign again.
+        info.set(CertificateAlgorithmId.NAME + '.' + CertificateAlgorithmId.ALGORITHM, cert.get(X509CertImpl.SIG_ALG));
+        cert = new X509CertImpl(info);
+        cert.sign(key, "SHA1withRSA");
+        cert.verify(keypair.getPublic());
+
+        return newSelfSignedCertificate(fqdn, key, cert);
+    }
+
+    private OpenJdkSelfSignedCertGenerator() { }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java b/handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java
new file mode 100644
index 000000000000..54257a76970b
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl.util;
+
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.base64.Base64;
+import io.netty.util.CharsetUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import java.security.PrivateKey;
+import java.security.SecureRandom;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+
+/**
+ * Generates a temporary self-signed certificate for testing purposes.
+ * <p>
+ * <strong>NOTE:</strong>
+ * Never use the certificate and private key generated by this class in production.
+ * It is purely for testing purposes, and thus it is very insecure.
+ * It even uses an insecure pseudo-random generator for faster generation internally.
+ * </p><p>
+ * A X.509 certificate file and a RSA private key file are generated in a system's temporary directory using
+ * {@link java.io.File#createTempFile(String, String)}, and they are deleted when the JVM exits using
+ * {@link java.io.File#deleteOnExit()}.
+ * </p><p>
+ * At first, this method tries to use OpenJDK's X.509 implementation (the {@code sun.security.x509} package).
+ * If it fails, it tries to use <a href="http://www.bouncycastle.org/">Bouncy Castle</a> as a fallback.
+ * </p>
+ */
+public final class SelfSignedCertificate {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(SelfSignedCertificate.class);
+
+    /** Current time minus 1 year, just in case software clock goes back due to time synchronization */
+    static final Date NOT_BEFORE = new Date(System.currentTimeMillis() - 86400000L * 365);
+    /** The maximum possible value in X.509 specification: 9999-12-31 23:59:59 */
+    static final Date NOT_AFTER = new Date(253402300799000L);
+
+    private final File certificate;
+    private final File privateKey;
+
+    /**
+     * Creates a new instance.
+     */
+    public SelfSignedCertificate() throws CertificateException {
+        this("example.com");
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param fqdn a fully qualified domain name
+     */
+    public SelfSignedCertificate(String fqdn) throws CertificateException {
+        // Bypass entrophy collection by using insecure random generator.
+        // We just want to generate it without any delay because it's for testing purposes only.
+        this(fqdn, ThreadLocalInsecureRandom.current(), 1024);
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param fqdn a fully qualified domain name
+     * @param random the {@link java.security.SecureRandom} to use
+     * @param bits the number of bits of the generated private key
+     */
+    public SelfSignedCertificate(String fqdn, SecureRandom random, int bits) throws CertificateException {
+        // Generate an RSA key pair.
+        final KeyPair keypair;
+        try {
+            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
+            keyGen.initialize(bits, random);
+            keypair = keyGen.generateKeyPair();
+        } catch (NoSuchAlgorithmException e) {
+            // Should not reach here because every Java implementation must have RSA key pair generator.
+            throw new Error(e);
+        }
+
+        String[] paths;
+        try {
+            // Try the OpenJDK's proprietary implementation.
+            paths = OpenJdkSelfSignedCertGenerator.generate(fqdn, keypair, random);
+        } catch (Throwable t) {
+            logger.debug("Failed to generate a self-signed X.509 certificate using sun.security.x509:", t);
+            try {
+                // Try Bouncy Castle if the current JVM didn't have sun.security.x509.
+                paths = BouncyCastleSelfSignedCertGenerator.generate(fqdn, keypair, random);
+            } catch (Throwable t2) {
+                logger.debug("Failed to generate a self-signed X.509 certificate using Bouncy Castle:", t2);
+                throw new CertificateException(
+                        "No provider succeeded to generate a self-signed certificate. " +
+                                "See debug log for the root cause.");
+            }
+        }
+
+        certificate = new File(paths[0]);
+        privateKey = new File(paths[1]);
+    }
+
+    /**
+     * Returns the generated X.509 certificate file in PEM format.
+     */
+    public File certificate() {
+        return certificate;
+    }
+
+    /**
+     * Returns the generated RSA private key file in PEM format.
+     */
+    public File privateKey() {
+        return privateKey;
+    }
+
+    /**
+     * Deletes the generated X.509 certificate file and RSA private key file.
+     */
+    public void delete() {
+        safeDelete(certificate);
+        safeDelete(privateKey);
+    }
+
+    static String[] newSelfSignedCertificate(
+            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {
+
+        // Encode the private key into a file.
+        String keyText = "-----BEGIN PRIVATE KEY-----\n" +
+                Base64.encode(Unpooled.wrappedBuffer(key.getEncoded()), true).toString(CharsetUtil.US_ASCII) +
+                "\n-----END PRIVATE KEY-----\n";
+
+        File keyFile = File.createTempFile("keyutil_" + fqdn + '_', ".key");
+        keyFile.deleteOnExit();
+
+        OutputStream keyOut = new FileOutputStream(keyFile);
+        try {
+            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));
+            keyOut.close();
+            keyOut = null;
+        } finally {
+            if (keyOut != null) {
+                safeClose(keyFile, keyOut);
+                safeDelete(keyFile);
+            }
+        }
+
+        // Encode the certificate into a CRT file.
+        String certText = "-----BEGIN CERTIFICATE-----\n" +
+                Base64.encode(Unpooled.wrappedBuffer(cert.getEncoded()), true).toString(CharsetUtil.US_ASCII) +
+                "\n-----END CERTIFICATE-----\n";
+
+        File certFile = File.createTempFile("keyutil_" + fqdn + '_', ".crt");
+        certFile.deleteOnExit();
+
+        OutputStream certOut = new FileOutputStream(certFile);
+        try {
+            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));
+            certOut.close();
+            certOut = null;
+        } finally {
+            if (certOut != null) {
+                safeClose(certFile, certOut);
+                safeDelete(certFile);
+                safeDelete(keyFile);
+            }
+        }
+
+        return new String[] { certFile.getPath(), keyFile.getPath() };
+    }
+
+    private static void safeDelete(File certFile) {
+        if (!certFile.delete()) {
+            logger.warn("Failed to delete a file: " + certFile);
+        }
+    }
+
+    private static void safeClose(File keyFile, OutputStream keyOut) {
+        try {
+            keyOut.close();
+        } catch (IOException e) {
+            logger.warn("Failed to close a file: " + keyFile, e);
+        }
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/SimpleTrustManagerFactory.java b/handler/src/main/java/io/netty/handler/ssl/util/SimpleTrustManagerFactory.java
new file mode 100644
index 000000000000..05fbc461513a
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/util/SimpleTrustManagerFactory.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl.util;
+
+import io.netty.util.concurrent.FastThreadLocal;
+
+import javax.net.ssl.ManagerFactoryParameters;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.TrustManagerFactorySpi;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.Provider;
+
+/**
+ * Helps to implement a custom {@link TrustManagerFactory}.
+ */
+public abstract class SimpleTrustManagerFactory extends TrustManagerFactory {
+
+    private static final Provider PROVIDER = new Provider("", 0.0, "") {
+        private static final long serialVersionUID = -2680540247105807895L;
+    };
+
+    /**
+     * {@link SimpleTrustManagerFactorySpi} must have a reference to {@link SimpleTrustManagerFactory}
+     * to delegate its callbacks back to {@link SimpleTrustManagerFactory}.  However, it is impossible to do so,
+     * because {@link TrustManagerFactory} requires {@link TrustManagerFactorySpi} at construction time and
+     * does not provide a way to access it later.
+     *
+     * To work around this issue, we use an ugly hack which uses a {@link ThreadLocal}.
+     */
+    private static final FastThreadLocal<SimpleTrustManagerFactorySpi> CURRENT_SPI =
+            new FastThreadLocal<SimpleTrustManagerFactorySpi>() {
+                @Override
+                protected SimpleTrustManagerFactorySpi initialValue() {
+                    return new SimpleTrustManagerFactorySpi();
+                }
+            };
+
+    /**
+     * Creates a new instance.
+     */
+    protected SimpleTrustManagerFactory() {
+        this("");
+    }
+
+    /**
+     * Creates a new instance.
+     *
+     * @param name the name of this {@link TrustManagerFactory}
+     */
+    protected SimpleTrustManagerFactory(String name) {
+        super(CURRENT_SPI.get(), PROVIDER, name);
+        CURRENT_SPI.get().init(this);
+        CURRENT_SPI.remove();
+
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+    }
+
+    /**
+     * Initializes this factory with a source of certificate authorities and related trust material.
+     *
+     * @see TrustManagerFactorySpi#engineInit(KeyStore)
+     */
+    protected abstract void engineInit(KeyStore keyStore) throws Exception;
+
+    /**
+     * Initializes this factory with a source of provider-specific key material.
+     *
+     * @see TrustManagerFactorySpi#engineInit(ManagerFactoryParameters)
+     */
+    protected abstract void engineInit(ManagerFactoryParameters managerFactoryParameters) throws Exception;
+
+    /**
+     * Returns one trust manager for each type of trust material.
+     *
+     * @see TrustManagerFactorySpi#engineGetTrustManagers()
+     */
+    protected abstract TrustManager[] engineGetTrustManagers();
+
+    static final class SimpleTrustManagerFactorySpi extends TrustManagerFactorySpi {
+
+        private SimpleTrustManagerFactory parent;
+
+        void init(SimpleTrustManagerFactory parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        protected void engineInit(KeyStore keyStore) throws KeyStoreException {
+            try {
+                parent.engineInit(keyStore);
+            } catch (KeyStoreException e) {
+                throw e;
+            } catch (Exception e) {
+                throw new KeyStoreException(e);
+            }
+        }
+
+        @Override
+        protected void engineInit(
+                ManagerFactoryParameters managerFactoryParameters) throws InvalidAlgorithmParameterException {
+            try {
+                parent.engineInit(managerFactoryParameters);
+            } catch (InvalidAlgorithmParameterException e) {
+                throw e;
+            } catch (Exception e) {
+                throw new InvalidAlgorithmParameterException(e);
+            }
+        }
+
+        @Override
+        protected TrustManager[] engineGetTrustManagers() {
+            return parent.engineGetTrustManagers();
+        }
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/ThreadLocalInsecureRandom.java b/handler/src/main/java/io/netty/handler/ssl/util/ThreadLocalInsecureRandom.java
new file mode 100644
index 000000000000..c69f886cd506
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/util/ThreadLocalInsecureRandom.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.ssl.util;
+
+import io.netty.util.internal.ThreadLocalRandom;
+
+import java.security.SecureRandom;
+import java.util.Random;
+
+/**
+ * Insecure {@link java.security.SecureRandom} which relies on {@link ThreadLocalRandom} for random number generation.
+ */
+final class ThreadLocalInsecureRandom extends SecureRandom {
+
+    private static final long serialVersionUID = -8209473337192526191L;
+
+    private static final SecureRandom INSTANCE = new ThreadLocalInsecureRandom();
+
+    static SecureRandom current() {
+        return INSTANCE;
+    }
+
+    private ThreadLocalInsecureRandom() { }
+
+    @Override
+    public String getAlgorithm() {
+        return "insecure";
+    }
+
+    @Override
+    public void setSeed(byte[] seed) { }
+
+    @Override
+    public void setSeed(long seed) { }
+
+    @Override
+    public void nextBytes(byte[] bytes) {
+        random().nextBytes(bytes);
+    }
+
+    @Override
+    public byte[] generateSeed(int numBytes) {
+        byte[] seed = new byte[numBytes];
+        random().nextBytes(seed);
+        return seed;
+    }
+
+    @Override
+    public int nextInt() {
+        return random().nextInt();
+    }
+
+    @Override
+    public int nextInt(int n) {
+        return random().nextInt(n);
+    }
+
+    @Override
+    public boolean nextBoolean() {
+        return random().nextBoolean();
+    }
+
+    @Override
+    public long nextLong() {
+        return random().nextLong();
+    }
+
+    @Override
+    public float nextFloat() {
+        return random().nextFloat();
+    }
+
+    @Override
+    public double nextDouble() {
+        return random().nextDouble();
+    }
+
+    @Override
+    public double nextGaussian() {
+        return random().nextGaussian();
+    }
+
+    private static Random random() {
+        return ThreadLocalRandom.current();
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/package-info.java b/handler/src/main/java/io/netty/handler/ssl/util/package-info.java
new file mode 100644
index 000000000000..fbdf16d7d288
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/ssl/util/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Utility classes that helps easier development of TLS/SSL applications.
+ */
+package io.netty.handler.ssl.util;
diff --git a/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java
index 582ad1fc3b75..fa6fd85322cb 100644
--- a/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java
+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java
@@ -37,7 +37,7 @@ public interface ChunkedInput<B> {
     /**
      * Fetches a chunked data from the stream. Once this method returns the last chunk
      * and thus the stream has reached at its end, any subsequent {@link #isEndOfInput()}
-     * call must return {@code false}.
+     * call must return {@code true}.
      *
      * @return the fetched chunk.
      *         {@code null} if there is no data left in the stream.
diff --git a/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
index 7c53d859f74e..9f8ba6b17684 100644
--- a/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
@@ -66,8 +66,7 @@
  * transfer.  To resume the transfer when a new chunk is available, you have to
  * call {@link #resumeTransfer()}.
  */
-public class ChunkedWriteHandler
-        extends ChannelDuplexHandler {
+public class ChunkedWriteHandler extends ChannelDuplexHandler {
 
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(ChunkedWriteHandler.class);
@@ -203,7 +202,6 @@ private void doFlush(final ChannelHandlerContext ctx) throws Exception {
             discard(null);
             return;
         }
-        boolean needsFlush;
         while (channel.isWritable()) {
             if (currentWrite == null) {
                 currentWrite = queue.poll();
@@ -212,7 +210,6 @@ private void doFlush(final ChannelHandlerContext ctx) throws Exception {
             if (currentWrite == null) {
                 break;
             }
-            needsFlush = true;
             final PendingWrite currentWrite = this.currentWrite;
             final Object pendingMessage = currentWrite.msg;
 
@@ -307,9 +304,9 @@ public void operationComplete(ChannelFuture future) throws Exception {
                 this.currentWrite = null;
             }
 
-            if (needsFlush) {
-                ctx.flush();
-            }
+            // Always need to flush
+            ctx.flush();
+
             if (!channel.isActive()) {
                 discard(new ClosedChannelException());
                 return;
@@ -339,17 +336,21 @@ private static final class PendingWrite {
 
         void fail(Throwable cause) {
             ReferenceCountUtil.release(msg);
-            if (promise != null) {
-                promise.tryFailure(cause);
-            }
+            promise.tryFailure(cause);
         }
 
         void success() {
+            if (promise.isDone()) {
+                // No need to notify the progress or fulfill the promise because it's done already.
+                return;
+            }
+
             if (promise instanceof ChannelProgressivePromise) {
                 // Now we know what the total is.
                 ((ChannelProgressivePromise) promise).tryProgress(progress, progress);
             }
-            promise.setSuccess();
+
+            promise.trySuccess();
         }
 
         void progress(int amount) {
diff --git a/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
index 725c453efa5d..80a511585b63 100644
--- a/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
@@ -95,10 +95,11 @@
  * @see WriteTimeoutHandler
  */
 public class IdleStateHandler extends ChannelDuplexHandler {
+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);
 
-    private final long readerIdleTimeMillis;
-    private final long writerIdleTimeMillis;
-    private final long allIdleTimeMillis;
+    private final long readerIdleTimeNanos;
+    private final long writerIdleTimeNanos;
+    private final long allIdleTimeNanos;
 
     volatile ScheduledFuture<?> readerIdleTimeout;
     volatile long lastReadTime;
@@ -165,19 +166,19 @@ public IdleStateHandler(
         }
 
         if (readerIdleTime <= 0) {
-            readerIdleTimeMillis = 0;
+            readerIdleTimeNanos = 0;
         } else {
-            readerIdleTimeMillis = Math.max(unit.toMillis(readerIdleTime), 1);
+            readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS);
         }
         if (writerIdleTime <= 0) {
-            writerIdleTimeMillis = 0;
+            writerIdleTimeNanos = 0;
         } else {
-            writerIdleTimeMillis = Math.max(unit.toMillis(writerIdleTime), 1);
+            writerIdleTimeNanos = Math.max(unit.toNanos(writerIdleTime), MIN_TIMEOUT_NANOS);
         }
         if (allIdleTime <= 0) {
-            allIdleTimeMillis = 0;
+            allIdleTimeNanos = 0;
         } else {
-            allIdleTimeMillis = Math.max(unit.toMillis(allIdleTime), 1);
+            allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS);
         }
     }
 
@@ -186,7 +187,7 @@ public IdleStateHandler(
      *
      */
     public long getReaderIdleTimeInMillis() {
-        return readerIdleTimeMillis;
+        return TimeUnit.NANOSECONDS.toMillis(readerIdleTimeNanos);
     }
 
     /**
@@ -194,7 +195,7 @@ public long getReaderIdleTimeInMillis() {
      *
      */
     public long getWriterIdleTimeInMillis() {
-        return writerIdleTimeMillis;
+        return TimeUnit.NANOSECONDS.toMillis(writerIdleTimeNanos);
     }
 
     /**
@@ -202,7 +203,7 @@ public long getWriterIdleTimeInMillis() {
      *
      */
     public long getAllIdleTimeInMillis() {
-        return allIdleTimeMillis;
+        return TimeUnit.NANOSECONDS.toMillis(allIdleTimeNanos);
     }
 
     @Override
@@ -248,21 +249,22 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        lastReadTime = System.currentTimeMillis();
+        lastReadTime = System.nanoTime();
         firstReaderIdleEvent = firstAllIdleEvent = true;
         ctx.fireChannelRead(msg);
     }
 
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
-        promise.addListener(new ChannelFutureListener() {
+        ChannelPromise unvoid = promise.unvoid();
+        unvoid.addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future) throws Exception {
-                lastWriteTime = System.currentTimeMillis();
+                lastWriteTime = System.nanoTime();
                 firstWriterIdleEvent = firstAllIdleEvent = true;
             }
         });
-        ctx.write(msg, promise);
+        ctx.write(msg, unvoid);
     }
 
     private void initialize(ChannelHandlerContext ctx) {
@@ -278,21 +280,21 @@ private void initialize(ChannelHandlerContext ctx) {
 
         EventExecutor loop = ctx.executor();
 
-        lastReadTime = lastWriteTime = System.currentTimeMillis();
-        if (readerIdleTimeMillis > 0) {
+        lastReadTime = lastWriteTime = System.nanoTime();
+        if (readerIdleTimeNanos > 0) {
             readerIdleTimeout = loop.schedule(
                     new ReaderIdleTimeoutTask(ctx),
-                    readerIdleTimeMillis, TimeUnit.MILLISECONDS);
+                    readerIdleTimeNanos, TimeUnit.NANOSECONDS);
         }
-        if (writerIdleTimeMillis > 0) {
+        if (writerIdleTimeNanos > 0) {
             writerIdleTimeout = loop.schedule(
                     new WriterIdleTimeoutTask(ctx),
-                    writerIdleTimeMillis, TimeUnit.MILLISECONDS);
+                    writerIdleTimeNanos, TimeUnit.NANOSECONDS);
         }
-        if (allIdleTimeMillis > 0) {
+        if (allIdleTimeNanos > 0) {
             allIdleTimeout = loop.schedule(
                     new AllIdleTimeoutTask(ctx),
-                    allIdleTimeMillis, TimeUnit.MILLISECONDS);
+                    allIdleTimeNanos, TimeUnit.NANOSECONDS);
         }
     }
 
@@ -335,13 +337,13 @@ public void run() {
                 return;
             }
 
-            long currentTime = System.currentTimeMillis();
+            long currentTime = System.nanoTime();
             long lastReadTime = IdleStateHandler.this.lastReadTime;
-            long nextDelay = readerIdleTimeMillis - (currentTime - lastReadTime);
+            long nextDelay = readerIdleTimeNanos - (currentTime - lastReadTime);
             if (nextDelay <= 0) {
                 // Reader is idle - set a new timeout and notify the callback.
                 readerIdleTimeout =
-                    ctx.executor().schedule(this, readerIdleTimeMillis, TimeUnit.MILLISECONDS);
+                    ctx.executor().schedule(this, readerIdleTimeNanos, TimeUnit.NANOSECONDS);
                 try {
                     IdleStateEvent event;
                     if (firstReaderIdleEvent) {
@@ -356,7 +358,7 @@ public void run() {
                 }
             } else {
                 // Read occurred before the timeout - set a new timeout with shorter delay.
-                readerIdleTimeout = ctx.executor().schedule(this, nextDelay, TimeUnit.MILLISECONDS);
+                readerIdleTimeout = ctx.executor().schedule(this, nextDelay, TimeUnit.NANOSECONDS);
             }
         }
     }
@@ -375,13 +377,13 @@ public void run() {
                 return;
             }
 
-            long currentTime = System.currentTimeMillis();
+            long currentTime = System.nanoTime();
             long lastWriteTime = IdleStateHandler.this.lastWriteTime;
-            long nextDelay = writerIdleTimeMillis - (currentTime - lastWriteTime);
+            long nextDelay = writerIdleTimeNanos - (currentTime - lastWriteTime);
             if (nextDelay <= 0) {
                 // Writer is idle - set a new timeout and notify the callback.
                 writerIdleTimeout = ctx.executor().schedule(
-                        this, writerIdleTimeMillis, TimeUnit.MILLISECONDS);
+                        this, writerIdleTimeNanos, TimeUnit.NANOSECONDS);
                 try {
                     IdleStateEvent event;
                     if (firstWriterIdleEvent) {
@@ -396,7 +398,7 @@ public void run() {
                 }
             } else {
                 // Write occurred before the timeout - set a new timeout with shorter delay.
-                writerIdleTimeout = ctx.executor().schedule(this, nextDelay, TimeUnit.MILLISECONDS);
+                writerIdleTimeout = ctx.executor().schedule(this, nextDelay, TimeUnit.NANOSECONDS);
             }
         }
     }
@@ -415,14 +417,14 @@ public void run() {
                 return;
             }
 
-            long currentTime = System.currentTimeMillis();
+            long currentTime = System.nanoTime();
             long lastIoTime = Math.max(lastReadTime, lastWriteTime);
-            long nextDelay = allIdleTimeMillis - (currentTime - lastIoTime);
+            long nextDelay = allIdleTimeNanos - (currentTime - lastIoTime);
             if (nextDelay <= 0) {
                 // Both reader and writer are idle - set a new timeout and
                 // notify the callback.
                 allIdleTimeout = ctx.executor().schedule(
-                        this, allIdleTimeMillis, TimeUnit.MILLISECONDS);
+                        this, allIdleTimeNanos, TimeUnit.NANOSECONDS);
                 try {
                     IdleStateEvent event;
                     if (firstAllIdleEvent) {
@@ -438,7 +440,7 @@ public void run() {
             } else {
                 // Either read or write occurred before the timeout - set a new
                 // timeout with shorter delay.
-                allIdleTimeout = ctx.executor().schedule(this, nextDelay, TimeUnit.MILLISECONDS);
+                allIdleTimeout = ctx.executor().schedule(this, nextDelay, TimeUnit.NANOSECONDS);
             }
         }
     }
diff --git a/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
index 3065c6dae52b..b52946d08df2 100644
--- a/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
@@ -62,8 +62,9 @@
  * @see IdleStateHandler
  */
 public class ReadTimeoutHandler extends ChannelInboundHandlerAdapter {
+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);
 
-    private final long timeoutMillis;
+    private final long timeoutNanos;
 
     private volatile ScheduledFuture<?> timeout;
     private volatile long lastReadTime;
@@ -96,9 +97,9 @@ public ReadTimeoutHandler(long timeout, TimeUnit unit) {
         }
 
         if (timeout <= 0) {
-            timeoutMillis = 0;
+            timeoutNanos = 0;
         } else {
-            timeoutMillis = Math.max(unit.toMillis(timeout), 1);
+            timeoutNanos = Math.max(unit.toNanos(timeout), MIN_TIMEOUT_NANOS);
         }
     }
 
@@ -145,7 +146,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        lastReadTime = System.currentTimeMillis();
+        lastReadTime = System.nanoTime();
         ctx.fireChannelRead(msg);
     }
 
@@ -160,11 +161,11 @@ private void initialize(ChannelHandlerContext ctx) {
 
         state = 1;
 
-        lastReadTime = System.currentTimeMillis();
-        if (timeoutMillis > 0) {
+        lastReadTime = System.nanoTime();
+        if (timeoutNanos > 0) {
             timeout = ctx.executor().schedule(
                     new ReadTimeoutTask(ctx),
-                    timeoutMillis, TimeUnit.MILLISECONDS);
+                    timeoutNanos, TimeUnit.NANOSECONDS);
         }
     }
 
@@ -202,11 +203,11 @@ public void run() {
                 return;
             }
 
-            long currentTime = System.currentTimeMillis();
-            long nextDelay = timeoutMillis - (currentTime - lastReadTime);
+            long currentTime = System.nanoTime();
+            long nextDelay = timeoutNanos - (currentTime - lastReadTime);
             if (nextDelay <= 0) {
                 // Read timed out - set a new timeout and notify the callback.
-                timeout = ctx.executor().schedule(this, timeoutMillis, TimeUnit.MILLISECONDS);
+                timeout = ctx.executor().schedule(this, timeoutNanos, TimeUnit.NANOSECONDS);
                 try {
                     readTimedOut(ctx);
                 } catch (Throwable t) {
@@ -214,7 +215,7 @@ public void run() {
                 }
             } else {
                 // Read occurred before the timeout - set a new timeout with shorter delay.
-                timeout = ctx.executor().schedule(this, nextDelay, TimeUnit.MILLISECONDS);
+                timeout = ctx.executor().schedule(this, nextDelay, TimeUnit.NANOSECONDS);
             }
         }
     }
diff --git a/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
index b7ef4dd277c2..b93864eb93f8 100644
--- a/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
+++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
@@ -65,8 +65,9 @@
  * @see IdleStateHandler
  */
 public class WriteTimeoutHandler extends ChannelOutboundHandlerAdapter {
+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);
 
-    private final long timeoutMillis;
+    private final long timeoutNanos;
 
     private boolean closed;
 
@@ -94,45 +95,46 @@ public WriteTimeoutHandler(long timeout, TimeUnit unit) {
         }
 
         if (timeout <= 0) {
-            timeoutMillis = 0;
+            timeoutNanos = 0;
         } else {
-            timeoutMillis = Math.max(unit.toMillis(timeout), 1);
+            timeoutNanos = Math.max(unit.toNanos(timeout), MIN_TIMEOUT_NANOS);
         }
     }
 
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
-        scheduleTimeout(ctx, promise);
+        if (timeoutNanos > 0) {
+            promise = promise.unvoid();
+            scheduleTimeout(ctx, promise);
+        }
         ctx.write(msg, promise);
     }
 
     private void scheduleTimeout(final ChannelHandlerContext ctx, final ChannelPromise future) {
-        if (timeoutMillis > 0) {
-            // Schedule a timeout.
-            final ScheduledFuture<?> sf = ctx.executor().schedule(new Runnable() {
-                @Override
-                public void run() {
-                    // Was not written yet so issue a write timeout
-                    // The future itself will be failed with a ClosedChannelException once the close() was issued
-                    // See https://github.com/netty/netty/issues/2159
-                    if (!future.isDone()) {
-                        try {
-                            writeTimedOut(ctx);
-                        } catch (Throwable t) {
-                            ctx.fireExceptionCaught(t);
-                        }
+        // Schedule a timeout.
+        final ScheduledFuture<?> sf = ctx.executor().schedule(new Runnable() {
+            @Override
+            public void run() {
+                // Was not written yet so issue a write timeout
+                // The future itself will be failed with a ClosedChannelException once the close() was issued
+                // See https://github.com/netty/netty/issues/2159
+                if (!future.isDone()) {
+                    try {
+                        writeTimedOut(ctx);
+                    } catch (Throwable t) {
+                        ctx.fireExceptionCaught(t);
                     }
                 }
-            }, timeoutMillis, TimeUnit.MILLISECONDS);
+            }
+        }, timeoutNanos, TimeUnit.NANOSECONDS);
 
-            // Cancel the scheduled timeout if the flush future is complete.
-            future.addListener(new ChannelFutureListener() {
-                @Override
-                public void operationComplete(ChannelFuture future) throws Exception {
-                    sf.cancel(false);
-                }
-            });
-        }
+        // Cancel the scheduled timeout if the flush future is complete.
+        future.addListener(new ChannelFutureListener() {
+            @Override
+            public void operationComplete(ChannelFuture future) throws Exception {
+                sf.cancel(false);
+            }
+        });
     }
 
     /**
diff --git a/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
index 743a51527c4c..c1e9e75451d3 100644
--- a/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
+++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
@@ -73,10 +73,10 @@ public abstract class AbstractTrafficShapingHandler extends ChannelDuplexHandler
      */
     protected long checkInterval = DEFAULT_CHECK_INTERVAL; // default 1 s
 
-    private static final AttributeKey<Boolean> READ_SUSPENDED = AttributeKey.valueOf(
-            AbstractTrafficShapingHandler.class.getName() + ".READ_SUSPENDED");
-    private static final AttributeKey<Runnable> REOPEN_TASK = AttributeKey.valueOf(
-            AbstractTrafficShapingHandler.class.getName() + ".REOPEN_TASK");
+    private static final AttributeKey<Boolean> READ_SUSPENDED =
+            AttributeKey.valueOf(AbstractTrafficShapingHandler.class, "READ_SUSPENDED");
+    private static final AttributeKey<Runnable> REOPEN_TASK =
+            AttributeKey.valueOf(AbstractTrafficShapingHandler.class, "REOPEN_TASK");
 
     /**
      *
@@ -245,17 +245,6 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) throw
                     }
                     ctx.executor().schedule(reopenTask, wait,
                             TimeUnit.MILLISECONDS);
-                } else {
-                    // Create a Runnable to update the next handler in the chain. If one was create before it will
-                    // just be reused to limit object creation
-                    Runnable bufferUpdateTask = new Runnable() {
-                        @Override
-                        public void run() {
-                            ctx.fireChannelRead(msg);
-                        }
-                    };
-                    ctx.executor().schedule(bufferUpdateTask, wait, TimeUnit.MILLISECONDS);
-                    return;
                 }
             }
         }
@@ -271,10 +260,7 @@ public void read(ChannelHandlerContext ctx) {
 
     private static boolean isSuspended(ChannelHandlerContext ctx) {
         Boolean suspended = ctx.attr(READ_SUSPENDED).get();
-        if (suspended == null || Boolean.FALSE.equals(suspended)) {
-            return false;
-        }
-        return true;
+        return !(suspended == null || Boolean.FALSE.equals(suspended));
     }
 
     @Override
diff --git a/handler/src/main/java/io/netty/handler/traffic/package-info.java b/handler/src/main/java/io/netty/handler/traffic/package-info.java
index f682a7051d3e..86bac786dd7b 100644
--- a/handler/src/main/java/io/netty/handler/traffic/package-info.java
+++ b/handler/src/main/java/io/netty/handler/traffic/package-info.java
@@ -23,20 +23,21 @@
  *
  * <p>Two classes implement this behavior:
  * <ul>
- * <li> <tt>{@link TrafficCounter}</tt>: this class implements the counters needed by the handlers.
- * It can be accessed to get some extra information like the read or write bytes since last check, the read and write
- * bandwidth from last check...</li>
- *
- * <li> <tt>{@link AbstractTrafficShapingHandler}</tt>: this abstract class implements the kernel
- * of traffic shaping. It could be extended to fit your needs. Two classes are proposed as default
- * implementations: see {@link ChannelTrafficShapingHandler} and see {@link GlobalTrafficShapingHandler}
- * respectively for Channel traffic shaping and Global traffic shaping.</li>
+ * <li> <tt>{@link io.netty.handler.traffic.TrafficCounter}</tt>: this class implements the counters needed by the
+ * handlers.  It can be accessed to get some extra information like the read or write bytes since last check,
+ * the read and write bandwidth from last check...</li>
+ *
+ * <li> <tt>{@link io.netty.handler.traffic.AbstractTrafficShapingHandler}</tt>: this abstract class implements
+ * the kernel of traffic shaping. It could be extended to fit your needs. Two classes are proposed as default
+ * implementations: see {@link io.netty.handler.traffic.ChannelTrafficShapingHandler} and
+ * {@link io.netty.handler.traffic.GlobalTrafficShapingHandler} respectively for Channel traffic shaping and
+ * global traffic shaping.</li>
  * </ul></p>
  *
  * <p>Both inbound and outbound traffic can be shaped independently.  This is done by either passing in
  * the desired limiting values to the constructors of both the Channel and Global traffic shaping handlers,
- * or by calling the <tt>configure</tt> method on the {@link AbstractTrafficShapingHandler}.  A value of
- * 0 for either parameter indicates that there should be no limitation.  This allows you to monitor the
+ * or by calling the <tt>configure</tt> method on the {@link io.netty.handler.traffic.AbstractTrafficShapingHandler}.
+ * A value of 0 for either parameter indicates that there should be no limitation.  This allows you to monitor the
  * incoming and outgoing traffic without shaping.</p>
  *
  * <p>To activate or deactivate the statistics, you can adjust the delay to a low (suggested not less than 200ms
@@ -44,11 +45,13 @@
  * or even using <tt>0</tt> which means no computation will be done.</p>
  *
  * <p>If you want to do anything with these statistics, just override the <tt>doAccounting</tt> method.<br>
- * This interval can be changed either from the method <tt>configure</tt> in {@link AbstractTrafficShapingHandler}
- * or directly using the method <tt>configure</tt> of {@link TrafficCounter}.</p>
+ * This interval can be changed either from the method <tt>configure</tt>
+ * in {@link io.netty.handler.traffic.AbstractTrafficShapingHandler} or directly using the method <tt>configure</tt>
+ * of {@link io.netty.handler.traffic.TrafficCounter}.</p>
  *
- * <p>Note that a new {@link ChannelTrafficShapingHandler} must be created for each new channel,
- * but only one {@link GlobalTrafficShapingHandler} must be created for all channels.</p>
+ * <p>Note that a new {@link io.netty.handler.traffic.ChannelTrafficShapingHandler} must be created
+ * for each new channel, but only one {@link io.netty.handler.traffic.GlobalTrafficShapingHandler} must be created
+ * for all channels.</p>
  *
  * <p>Note also that you can create different GlobalTrafficShapingHandler if you want to separate classes of
  * channels (for instance either from business point of view or from bind address point of view).</p>
diff --git a/handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java b/handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java
new file mode 100644
index 000000000000..6c3caf6ce1c8
--- /dev/null
+++ b/handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.ipfilter;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.embedded.EmbeddedChannel;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+
+public class IpSubnetFilterTest {
+
+    @Test
+    public void testIp4SubnetFilterRule() throws Exception {
+        IpSubnetFilterRule rule = new IpSubnetFilterRule("192.168.56.1", 24, IpFilterRuleType.ACCEPT);
+        for (int i = 0; i <= 255; i++) {
+            Assert.assertTrue(rule.matches(newSockAddress(String.format("192.168.56.%d", i))));
+        }
+        Assert.assertFalse(rule.matches(newSockAddress("192.168.57.1")));
+
+        rule = new IpSubnetFilterRule("91.114.240.1", 23, IpFilterRuleType.ACCEPT);
+        Assert.assertTrue(rule.matches(newSockAddress("91.114.240.43")));
+        Assert.assertTrue(rule.matches(newSockAddress("91.114.240.255")));
+        Assert.assertTrue(rule.matches(newSockAddress("91.114.241.193")));
+        Assert.assertTrue(rule.matches(newSockAddress("91.114.241.254")));
+        Assert.assertFalse(rule.matches(newSockAddress("91.115.241.2")));
+    }
+
+    @Test
+    public void testIp6SubnetFilterRule() {
+        IpSubnetFilterRule rule;
+
+        rule = new IpSubnetFilterRule("2001:db8:abcd:0000::", 52, IpFilterRuleType.ACCEPT);
+        Assert.assertTrue(rule.matches(newSockAddress("2001:db8:abcd:0000::1")));
+        Assert.assertTrue(rule.matches(newSockAddress("2001:db8:abcd:0fff:ffff:ffff:ffff:ffff")));
+        Assert.assertFalse(rule.matches(newSockAddress("2001:db8:abcd:1000::")));
+    }
+
+    @Test
+    public void testIpFilterRuleHandler() throws Exception {
+        IpFilterRule filter0 = new IpFilterRule() {
+            @Override
+            public boolean matches(InetSocketAddress remoteAddress) {
+                return "192.168.57.1".equals(remoteAddress.getHostName());
+            }
+
+            @Override
+            public IpFilterRuleType ruleType() {
+                return IpFilterRuleType.REJECT;
+            }
+        };
+
+        RuleBasedIpFilter denyHandler = new RuleBasedIpFilter(filter0) {
+            private final byte[] message = {1, 2, 3, 4, 5, 6, 7};
+
+            @Override
+            protected ChannelFuture channelRejected(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {
+                Assert.assertTrue(ctx.channel().isActive());
+                Assert.assertTrue(ctx.channel().isWritable());
+                Assert.assertEquals("192.168.57.1", remoteAddress.getHostName());
+
+                return ctx.writeAndFlush(Unpooled.wrappedBuffer(message));
+            }
+        };
+        EmbeddedChannel chDeny = newEmbeddedInetChannel("192.168.57.1", denyHandler);
+        ByteBuf out = chDeny.readOutbound();
+        Assert.assertEquals(7, out.readableBytes());
+        for (byte i = 1; i <= 7; i++) {
+            Assert.assertEquals(i, out.readByte());
+        }
+        Assert.assertFalse(chDeny.isActive());
+        Assert.assertFalse(chDeny.isOpen());
+
+        RuleBasedIpFilter allowHandler = new RuleBasedIpFilter(filter0) {
+            @Override
+            protected ChannelFuture channelRejected(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) {
+                Assert.fail();
+                return null;
+            }
+        };
+        EmbeddedChannel chAllow = newEmbeddedInetChannel("192.168.57.2", allowHandler);
+        Assert.assertTrue(chAllow.isActive());
+        Assert.assertTrue(chAllow.isOpen());
+    }
+
+    @Test
+    public void testUniqueIpFilterHandler() {
+        UniqueIpFilter handler = new UniqueIpFilter();
+
+        EmbeddedChannel ch1 = newEmbeddedInetChannel("91.92.93.1", handler);
+        Assert.assertTrue(ch1.isActive());
+        EmbeddedChannel ch2 = newEmbeddedInetChannel("91.92.93.2", handler);
+        Assert.assertTrue(ch2.isActive());
+        EmbeddedChannel ch3 = newEmbeddedInetChannel("91.92.93.1", handler);
+        Assert.assertFalse(ch3.isActive());
+
+        // false means that no data is left to read/write
+        Assert.assertFalse(ch1.finish());
+
+        EmbeddedChannel ch4 = newEmbeddedInetChannel("91.92.93.1", handler);
+        Assert.assertTrue(ch4.isActive());
+    }
+
+    private static EmbeddedChannel newEmbeddedInetChannel(final String ipAddress, ChannelHandler... handlers) {
+        return new EmbeddedChannel(handlers) {
+            @Override
+            protected SocketAddress remoteAddress0() {
+                return isActive()? new InetSocketAddress(ipAddress, 5421) : null;
+            }
+        };
+    }
+
+    private static InetSocketAddress newSockAddress(String ipAddress) {
+        return new InetSocketAddress(ipAddress, 1234);
+    }
+}
diff --git a/handler/src/test/java/io/netty/handler/logging/LoggingHandlerTest.java b/handler/src/test/java/io/netty/handler/logging/LoggingHandlerTest.java
new file mode 100644
index 000000000000..78e7fd5f353b
--- /dev/null
+++ b/handler/src/test/java/io/netty/handler/logging/LoggingHandlerTest.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.logging;
+
+import ch.qos.logback.classic.Logger;
+import ch.qos.logback.classic.spi.ILoggingEvent;
+import ch.qos.logback.core.Appender;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufHolder;
+import io.netty.buffer.DefaultByteBufHolder;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelMetadata;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.CharsetUtil;
+import org.easymock.IArgumentMatcher;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.slf4j.LoggerFactory;
+
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import static org.easymock.EasyMock.*;
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+/**
+ * Verifies the correct functionality of the {@link LoggingHandler}.
+ */
+public class LoggingHandlerTest {
+
+    private static final Logger root = (Logger) LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);
+    private static final List<Appender<ILoggingEvent>> oldAppenders = new ArrayList<Appender<ILoggingEvent>>();
+    /**
+     * Custom logback appender which gets used to match on log messages.
+     */
+    private Appender<ILoggingEvent> appender;
+
+    @BeforeClass
+    public static void beforeClass() {
+        for (Iterator<Appender<ILoggingEvent>> i = root.iteratorForAppenders(); i.hasNext();) {
+            Appender<ILoggingEvent> a = i.next();
+            oldAppenders.add(a);
+            root.detachAppender(a);
+        }
+
+        Unpooled.buffer();
+    }
+
+    @AfterClass
+    public static void afterClass() {
+        for (Appender<ILoggingEvent> a: oldAppenders) {
+            root.addAppender(a);
+        }
+    }
+
+    @Before
+    @SuppressWarnings("unchecked")
+    public void setup() {
+        appender = createNiceMock(Appender.class);
+        root.addAppender(appender);
+    }
+
+    @After
+    public void teardown() {
+        root.detachAppender(appender);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void shouldNotAcceptNullLogLevel() {
+        LogLevel level = null;
+        new LoggingHandler(level);
+    }
+
+    @Test
+    public void shouldApplyCustomLogLevel() {
+        LoggingHandler handler = new LoggingHandler("LoggingHandlerTest", LogLevel.INFO);
+        assertEquals(LogLevel.INFO, handler.level());
+    }
+
+    @Test
+    public void shouldLogChannelActive() {
+        appender.doAppend(matchesLog(".+ACTIVE$"));
+        replay(appender);
+        new EmbeddedChannel(new LoggingHandler());
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogChannelRegistered() {
+        appender.doAppend(matchesLog(".+REGISTERED$"));
+        replay(appender);
+        new EmbeddedChannel(new LoggingHandler());
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogChannelClose() throws Exception {
+        appender.doAppend(matchesLog(".+CLOSE$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.close().await();
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogChannelConnect() throws Exception {
+        appender.doAppend(matchesLog(".+CONNECT: 0.0.0.0/0.0.0.0:80$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.connect(new InetSocketAddress(80)).await();
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogChannelConnectWithLocalAddress() throws Exception {
+        appender.doAppend(matchesLog(".+CONNECT: 0.0.0.0/0.0.0.0:80, 0.0.0.0/0.0.0.0:81$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.connect(new InetSocketAddress(80), new InetSocketAddress(81)).await();
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogChannelDisconnect() throws Exception {
+        appender.doAppend(matchesLog(".+DISCONNECT$"));
+        replay(appender);
+        EmbeddedChannel channel = new DisconnectingEmbeddedChannel(new LoggingHandler());
+        channel.connect(new InetSocketAddress(80)).await();
+        channel.disconnect().await();
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogChannelInactive() throws Exception {
+        appender.doAppend(matchesLog(".+INACTIVE$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.pipeline().fireChannelInactive();
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogChannelBind() throws Exception {
+        appender.doAppend(matchesLog(".+BIND: 0.0.0.0/0.0.0.0:80$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.bind(new InetSocketAddress(80));
+        verify(appender);
+    }
+
+    @Test
+    @SuppressWarnings("RedundantStringConstructorCall")
+    public void shouldLogChannelUserEvent() throws Exception {
+        String userTriggered = "iAmCustom!";
+        appender.doAppend(matchesLog(".+USER_EVENT: " + userTriggered + '$'));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.pipeline().fireUserEventTriggered(new String(userTriggered));
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogChannelException() throws Exception {
+        String msg = "illegalState";
+        Throwable cause = new IllegalStateException(msg);
+        appender.doAppend(matchesLog(".+EXCEPTION: " + cause.getClass().getCanonicalName() + ": " + msg + '$'));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.pipeline().fireExceptionCaught(cause);
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogDataWritten() throws Exception {
+        String msg = "hello";
+        appender.doAppend(matchesLog(".+WRITE: " + msg + '$'));
+        appender.doAppend(matchesLog(".+FLUSH$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.writeOutbound(msg);
+        verify(appender);
+    }
+
+    @Test
+    public void shouldLogNonByteBufDataRead() throws Exception {
+        String msg = "hello";
+        appender.doAppend(matchesLog(".+RECEIVED: " + msg + '$'));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.writeInbound(msg);
+        verify(appender);
+
+        String handledMsg = channel.readInbound();
+        assertThat(msg, is(sameInstance(handledMsg)));
+        assertThat(channel.readInbound(), is(nullValue()));
+    }
+
+    @Test
+    public void shouldLogByteBufDataRead() throws Exception {
+        ByteBuf msg = Unpooled.copiedBuffer("hello", CharsetUtil.UTF_8);
+        appender.doAppend(matchesLog(".+RECEIVED: " + msg.readableBytes() + "B$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.writeInbound(msg);
+        verify(appender);
+
+        ByteBuf handledMsg = channel.readInbound();
+        assertThat(msg, is(sameInstance(handledMsg)));
+        handledMsg.release();
+        assertThat(channel.readInbound(), is(nullValue()));
+    }
+
+    @Test
+    public void shouldLogEmptyByteBufDataRead() throws Exception {
+        ByteBuf msg = Unpooled.EMPTY_BUFFER;
+        appender.doAppend(matchesLog(".+RECEIVED: 0B$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.writeInbound(msg);
+        verify(appender);
+
+        ByteBuf handledMsg = channel.readInbound();
+        assertThat(msg, is(sameInstance(handledMsg)));
+        assertThat(channel.readInbound(), is(nullValue()));
+    }
+
+    @Test
+    public void shouldLogByteBufHolderDataRead() throws Exception {
+        ByteBufHolder msg = new DefaultByteBufHolder(Unpooled.copiedBuffer("hello", CharsetUtil.UTF_8)) {
+            @Override
+            public String toString() {
+                return "foobar";
+            }
+        };
+
+        appender.doAppend(matchesLog(".+RECEIVED: foobar, 5B$"));
+        replay(appender);
+        EmbeddedChannel channel = new EmbeddedChannel(new LoggingHandler());
+        channel.writeInbound(msg);
+        verify(appender);
+
+        ByteBufHolder handledMsg = channel.readInbound();
+        assertThat(msg, is(sameInstance(handledMsg)));
+        handledMsg.release();
+        assertThat(channel.readInbound(), is(nullValue()));
+    }
+
+    /**
+     * Static helper method for matching Logback messages.
+     *
+     * @param toMatch the regex to match.
+     * @return a mocked event to pass into the {@link Appender#doAppend(Object)} method.
+     */
+    private static ILoggingEvent matchesLog(String toMatch) {
+        reportMatcher(new RegexLogMatcher(toMatch));
+        return null;
+    }
+
+    /**
+     * A custom EasyMock matcher that matches on Logback messages.
+     */
+    private static final class RegexLogMatcher implements IArgumentMatcher {
+
+        private final String expected;
+        private String actualMsg;
+
+        RegexLogMatcher(String expected) {
+            this.expected = expected;
+        }
+
+        @Override
+        @SuppressWarnings("DynamicRegexReplaceableByCompiledPattern")
+        public boolean matches(Object actual) {
+            if (!(actual instanceof ILoggingEvent)) {
+                return false;
+            }
+
+            // Match only the first line to skip the validation of hex-dump format.
+            actualMsg = ((ILoggingEvent) actual).getMessage().split("(?s)[\\r\\n]+")[0];
+            return actualMsg.matches(expected);
+        }
+
+        @Override
+        public void appendTo(StringBuffer buffer) {
+            buffer.append("matchesLog(");
+            buffer.append("expected: \"" + expected);
+            buffer.append("\", got: \"" + actualMsg);
+            buffer.append("\")");
+        }
+    }
+
+    private static final class DisconnectingEmbeddedChannel extends EmbeddedChannel {
+
+        private DisconnectingEmbeddedChannel(ChannelHandler... handlers) {
+            super(handlers);
+        }
+
+        @Override
+        public ChannelMetadata metadata() {
+            return new ChannelMetadata(true);
+        }
+    }
+}
diff --git a/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
index f17d83e8e5dd..548799293845 100644
--- a/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
+++ b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
@@ -23,6 +23,7 @@
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
+
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -30,7 +31,7 @@
 import java.nio.channels.Channels;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static io.netty.util.ReferenceCountUtil.releaseLater;
+import static io.netty.util.ReferenceCountUtil.*;
 import static org.junit.Assert.*;
 
 public class ChunkedWriteHandlerTest {
@@ -193,7 +194,7 @@ private static void check(ChunkedInput<?>... inputs) {
         int i = 0;
         int read = 0;
         for (;;) {
-            ByteBuf buffer = (ByteBuf) ch.readOutbound();
+            ByteBuf buffer = ch.readOutbound();
             if (buffer == null) {
                 break;
             }
diff --git a/license/LICENSE.abstractnodequeue.txt b/license/LICENSE.abstractnodequeue.txt
new file mode 100644
index 000000000000..b3fdc8f507e5
--- /dev/null
+++ b/license/LICENSE.abstractnodequeue.txt
@@ -0,0 +1,15 @@
+This software is licensed under the Apache 2 license, quoted below.
+
+Copyright 2009-2013 Typesafe Inc. [http://www.typesafe.com]
+
+Licensed under the Apache License, Version 2.0 (the "License"); you may not
+use this file except in compliance with the License. You may obtain a copy of
+the License at
+
+    [http://www.apache.org/licenses/LICENSE-2.0]
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+License for the specific language governing permissions and limitations under
+the License.
\ No newline at end of file
diff --git a/license/LICENSE.bouncycastle.txt b/license/LICENSE.bouncycastle.txt
new file mode 100644
index 000000000000..dbba1dd7829c
--- /dev/null
+++ b/license/LICENSE.bouncycastle.txt
@@ -0,0 +1,23 @@
+The MIT License (MIT)
+
+Copyright (c) 2000 - 2013 The Legion of the Bouncy Castle Inc.
+                          (http://www.bouncycastle.org) 
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
diff --git a/license/LICENSE.harmony.txt b/license/LICENSE.harmony.txt
new file mode 100644
index 000000000000..66a27ec5ff94
--- /dev/null
+++ b/license/LICENSE.harmony.txt
@@ -0,0 +1,177 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/license/LICENSE.jbzip2.txt b/license/LICENSE.jbzip2.txt
new file mode 100644
index 000000000000..6d6f1d40c068
--- /dev/null
+++ b/license/LICENSE.jbzip2.txt
@@ -0,0 +1,19 @@
+Copyright (c) 2010-2011 Matthew J. Francis and Contributors of the jbzip2 Project
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/microbench/README.md b/microbench/README.md
index acdf51cf817e..b109a14f8865 100644
--- a/microbench/README.md
+++ b/microbench/README.md
@@ -1,4 +1,4 @@
 ## Microbenchmark tests
 
-See [our wiki page](http://netty.io/wiki/microbench-module.html).
+See [our wiki page](http://netty.io/wiki/microbenchmarks.html).
 
diff --git a/microbench/pom.xml b/microbench/pom.xml
index 250e347d9229..d0c0a6964d51 100644
--- a/microbench/pom.xml
+++ b/microbench/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-microbench</artifactId>
@@ -47,7 +47,13 @@
     <dependency>
       <groupId>org.openjdk.jmh</groupId>
       <artifactId>jmh-core</artifactId>
-      <version>0.2.1</version>
+      <version>0.9</version>
+    </dependency>
+    <dependency>
+      <groupId>org.openjdk.jmh</groupId>
+      <artifactId>jmh-generator-annprocess</artifactId>
+      <version>0.9</version>
+      <scope>provided</scope>
     </dependency>
   </dependencies>
 
diff --git a/microbench/src/test/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java b/microbench/src/test/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java
index a5ecf6d6b00e..252d0d3b30dc 100644
--- a/microbench/src/test/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java
+++ b/microbench/src/test/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java
@@ -20,159 +20,89 @@
 import io.netty.buffer.PooledByteBufAllocator;
 import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.microbench.util.AbstractMicrobenchmark;
-import org.openjdk.jmh.annotations.GenerateMicroBenchmark;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.Param;
+
+import java.util.Random;
 
 /**
  * This class benchmarks different allocators with different allocation sizes.
  */
 public class ByteBufAllocatorBenchmark extends AbstractMicrobenchmark {
 
-    private final ByteBufAllocator unpooledHeapAllocator = new UnpooledByteBufAllocator(false);
-    private final ByteBufAllocator unpooledDirectAllocator = new UnpooledByteBufAllocator(true);
-    private final ByteBufAllocator pooledHeapAllocator = new PooledByteBufAllocator(false);
-    private final ByteBufAllocator pooledDirectAllocator = new PooledByteBufAllocator(true);
-
-    @GenerateMicroBenchmark
-    public void unpooledHeapAllocAndFree_1_0() {
-        ByteBuf buffer = unpooledHeapAllocator.buffer(0);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledHeapAllocAndFree_2_256() {
-        ByteBuf buffer = unpooledHeapAllocator.buffer(256);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledHeapAllocAndFree_3_1024() {
-        ByteBuf buffer = unpooledHeapAllocator.buffer(1024);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledHeapAllocAndFree_4_4096() {
-        ByteBuf buffer = unpooledHeapAllocator.buffer(4096);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledHeapAllocAndFree_5_16384() {
-        ByteBuf buffer = unpooledHeapAllocator.buffer(16384);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledHeapAllocAndFree_6_65536() {
-        ByteBuf buffer = unpooledHeapAllocator.buffer(65536);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledDirectAllocAndFree_1_0() {
-        ByteBuf buffer = unpooledDirectAllocator.buffer(0);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledDirectAllocAndFree_2_256() {
-        ByteBuf buffer = unpooledDirectAllocator.buffer(256);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledDirectAllocAndFree_3_1024() {
-        ByteBuf buffer = unpooledDirectAllocator.buffer(1024);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledDirectAllocAndFree_4_4096() {
-        ByteBuf buffer = unpooledDirectAllocator.buffer(4096);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledDirectAllocAndFree_5_16384() {
-        ByteBuf buffer = unpooledDirectAllocator.buffer(16384);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void unpooledDirectAllocAndFree_6_65536() {
-        ByteBuf buffer = unpooledDirectAllocator.buffer(65536);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledHeapAllocAndFree_1_0() {
-        ByteBuf buffer = pooledHeapAllocator.buffer(0);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledHeapAllocAndFree_2_256() {
-        ByteBuf buffer = pooledHeapAllocator.buffer(256);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledHeapAllocAndFree_3_1024() {
-        ByteBuf buffer = pooledHeapAllocator.buffer(1024);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledHeapAllocAndFree_4_4096() {
-        ByteBuf buffer = pooledHeapAllocator.buffer(4096);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledHeapAllocAndFree_5_16384() {
-        ByteBuf buffer = pooledHeapAllocator.buffer(16384);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledHeapAllocAndFree_6_65536() {
-        ByteBuf buffer = pooledHeapAllocator.buffer(65536);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledDirectAllocAndFree_1_0() {
-        ByteBuf buffer = pooledDirectAllocator.buffer(0);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledDirectAllocAndFree_2_256() {
-        ByteBuf buffer = pooledDirectAllocator.buffer(256);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledDirectAllocAndFree_3_1024() {
-        ByteBuf buffer = pooledDirectAllocator.buffer(1024);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledDirectAllocAndFree_4_4096() {
-        ByteBuf buffer = pooledDirectAllocator.buffer(4096);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledDirectAllocAndFree_5_16384() {
-        ByteBuf buffer = pooledDirectAllocator.buffer(16384);
-        buffer.release();
-    }
-
-    @GenerateMicroBenchmark
-    public void pooledDirectAllocAndFree_6_65536() {
-        ByteBuf buffer = pooledDirectAllocator.buffer(65536);
-        buffer.release();
+    private static final ByteBufAllocator unpooledAllocator = new UnpooledByteBufAllocator(true);
+    private static final ByteBufAllocator pooledAllocator =
+            new PooledByteBufAllocator(true, 4, 4, 8192, 11, 0, 0, 0); // Disable thread-local cache
+
+    private static final int MAX_LIVE_BUFFERS = 8192;
+    private static final Random rand = new Random();
+    private static final ByteBuf[] unpooledHeapBuffers = new ByteBuf[MAX_LIVE_BUFFERS];
+    private static final ByteBuf[] unpooledDirectBuffers = new ByteBuf[MAX_LIVE_BUFFERS];
+    private static final ByteBuf[] pooledHeapBuffers = new ByteBuf[MAX_LIVE_BUFFERS];
+    private static final ByteBuf[] pooledDirectBuffers = new ByteBuf[MAX_LIVE_BUFFERS];
+    private static final ByteBuf[] defaultPooledHeapBuffers = new ByteBuf[MAX_LIVE_BUFFERS];
+    private static final ByteBuf[] defaultPooledDirectBuffers = new ByteBuf[MAX_LIVE_BUFFERS];
+
+    @Param({ "00000", "00256", "01024", "04096", "16384", "65536" })
+    public int size;
+
+    @Benchmark
+    public void unpooledHeapAllocAndFree() {
+        int idx = rand.nextInt(unpooledHeapBuffers.length);
+        ByteBuf oldBuf = unpooledHeapBuffers[idx];
+        if (oldBuf != null) {
+            oldBuf.release();
+        }
+        unpooledHeapBuffers[idx] = unpooledAllocator.heapBuffer(size);
+    }
+
+    @Benchmark
+    public void unpooledDirectAllocAndFree() {
+        int idx = rand.nextInt(unpooledDirectBuffers.length);
+        ByteBuf oldBuf = unpooledDirectBuffers[idx];
+        if (oldBuf != null) {
+            oldBuf.release();
+        }
+        unpooledDirectBuffers[idx] = unpooledAllocator.directBuffer(size);
+    }
+
+    @Benchmark
+    public void pooledHeapAllocAndFree() {
+        int idx = rand.nextInt(pooledHeapBuffers.length);
+        ByteBuf oldBuf = pooledHeapBuffers[idx];
+        if (oldBuf != null) {
+            oldBuf.release();
+        }
+        pooledHeapBuffers[idx] = pooledAllocator.heapBuffer(size);
+    }
+
+    @Benchmark
+    public void pooledDirectAllocAndFree() {
+        int idx = rand.nextInt(pooledDirectBuffers.length);
+        ByteBuf oldBuf = pooledDirectBuffers[idx];
+        if (oldBuf != null) {
+            oldBuf.release();
+        }
+        pooledDirectBuffers[idx] = pooledAllocator.directBuffer(size);
+    }
+
+    @Benchmark
+    public void defaultPooledHeapAllocAndFree() {
+        int idx = rand.nextInt(defaultPooledHeapBuffers.length);
+        ByteBuf oldBuf = defaultPooledHeapBuffers[idx];
+        if (oldBuf != null) {
+            oldBuf.release();
+        }
+        defaultPooledHeapBuffers[idx] = PooledByteBufAllocator.DEFAULT.heapBuffer(size);
+    }
+
+    @Benchmark
+    public void defaultPooledDirectAllocAndFree() {
+        int idx = rand.nextInt(defaultPooledDirectBuffers.length);
+        ByteBuf oldBuf = defaultPooledDirectBuffers[idx];
+        if (oldBuf != null) {
+            oldBuf.release();
+        }
+        defaultPooledDirectBuffers[idx] = PooledByteBufAllocator.DEFAULT.directBuffer(size);
     }
 }
diff --git a/microbench/src/test/java/io/netty/microbench/buffer/SwappedByteBufBenchmark.java b/microbench/src/test/java/io/netty/microbench/buffer/SwappedByteBufBenchmark.java
new file mode 100644
index 000000000000..587f8021c538
--- /dev/null
+++ b/microbench/src/test/java/io/netty/microbench/buffer/SwappedByteBufBenchmark.java
@@ -0,0 +1,80 @@
+/*
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+package io.netty.microbench.buffer;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.SwappedByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.microbench.util.AbstractMicrobenchmark;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Param;
+import org.openjdk.jmh.annotations.Scope;
+import org.openjdk.jmh.annotations.Setup;
+import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.annotations.Warmup;
+
+import java.nio.ByteOrder;
+
+@State(Scope.Benchmark)
+@Warmup(iterations = 10)
+@Measurement(iterations = 25)
+public class SwappedByteBufBenchmark extends AbstractMicrobenchmark {
+    private ByteBuf swappedByteBuf;
+    private ByteBuf unsafeSwappedByteBuf;
+
+    @Setup
+    public void setup() {
+        swappedByteBuf = new SwappedByteBuf(Unpooled.directBuffer(8));
+        unsafeSwappedByteBuf = Unpooled.directBuffer(8).order(ByteOrder.LITTLE_ENDIAN);
+        if (unsafeSwappedByteBuf.getClass().equals(SwappedByteBuf.class)) {
+            throw new IllegalStateException("Should not use " + SwappedByteBuf.class.getSimpleName());
+        }
+    }
+
+    @Param("16384")
+    public int size;
+
+    @Benchmark
+    public void swappedByteBufSetInt() {
+        swappedByteBuf.setLong(0, size);
+    }
+
+    @Benchmark
+    public void swappedByteBufSetShort() {
+        swappedByteBuf.setShort(0, size);
+    }
+
+    @Benchmark
+    public void swappedByteBufSetLong() {
+        swappedByteBuf.setLong(0, size);
+    }
+
+    @Benchmark
+    public void unsafeSwappedByteBufSetInt() {
+        unsafeSwappedByteBuf.setInt(0, size);
+    }
+
+    @Benchmark
+    public void unsafeSwappedByteBufSetShort() {
+        unsafeSwappedByteBuf.setShort(0, size);
+    }
+
+    @Benchmark
+    public void unsafeSwappedByteBufSetLong() {
+        unsafeSwappedByteBuf.setLong(0, size);
+    }
+}
diff --git a/microbench/src/test/java/io/netty/microbench/concurrent/FastThreadLocalBenchmark.java b/microbench/src/test/java/io/netty/microbench/concurrent/FastThreadLocalBenchmark.java
new file mode 100644
index 000000000000..2993a08be5f9
--- /dev/null
+++ b/microbench/src/test/java/io/netty/microbench/concurrent/FastThreadLocalBenchmark.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.microbench.concurrent;
+
+import io.netty.microbench.util.AbstractMicrobenchmark;
+import io.netty.util.concurrent.FastThreadLocal;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Threads;
+
+import java.util.Random;
+
+/**
+ * This class benchmarks different allocators with different allocation sizes.
+ */
+@Threads(4)
+@Measurement(iterations = 10, batchSize = 100)
+public class FastThreadLocalBenchmark extends AbstractMicrobenchmark {
+
+    private static final Random rand = new Random();
+
+    @SuppressWarnings("unchecked")
+    private static final ThreadLocal<Integer>[] jdkThreadLocals = new ThreadLocal[128];
+    @SuppressWarnings("unchecked")
+    private static final FastThreadLocal<Integer>[] fastThreadLocals = new FastThreadLocal[jdkThreadLocals.length];
+
+    static {
+        for (int i = 0; i < jdkThreadLocals.length; i ++) {
+            jdkThreadLocals[i] = new ThreadLocal<Integer>() {
+                @Override
+                protected Integer initialValue() {
+                    return rand.nextInt();
+                }
+            };
+        }
+
+        for (int i = 0; i < fastThreadLocals.length; i ++) {
+            fastThreadLocals[i] = new FastThreadLocal<Integer>() {
+                @Override
+                protected Integer initialValue() {
+                    return rand.nextInt();
+                }
+            };
+        }
+    }
+
+    @Benchmark
+    public int jdkThreadLocalGet() {
+        int result = 0;
+        for (ThreadLocal<Integer> i: jdkThreadLocals) {
+            result += i.get();
+        }
+        return result;
+    }
+
+    @Benchmark
+    public int fastThreadLocal() {
+        int result = 0;
+        for (FastThreadLocal<Integer> i: fastThreadLocals) {
+            result += i.get();
+        }
+        return result;
+    }
+}
diff --git a/microbench/src/test/java/io/netty/microbench/internal/RecyclableArrayListBenchmark.java b/microbench/src/test/java/io/netty/microbench/internal/RecyclableArrayListBenchmark.java
new file mode 100644
index 000000000000..b6be233c5d77
--- /dev/null
+++ b/microbench/src/test/java/io/netty/microbench/internal/RecyclableArrayListBenchmark.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.microbench.internal;
+
+import io.netty.microbench.util.AbstractMicrobenchmark;
+import io.netty.util.internal.RecyclableArrayList;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Param;
+import org.openjdk.jmh.annotations.Threads;
+
+/**
+ * This class benchmarks different allocators with different allocation sizes.
+ */
+@Threads(4)
+@Measurement(iterations = 10, batchSize = 100)
+public class RecyclableArrayListBenchmark extends AbstractMicrobenchmark {
+
+    @Param({ "00000", "00256", "01024", "04096", "16384", "65536" })
+    public int size;
+
+    @Benchmark
+    public void recycleSameThread() {
+        RecyclableArrayList list = RecyclableArrayList.newInstance(size);
+        list.recycle();
+    }
+}
diff --git a/microbench/src/test/java/io/netty/microbench/util/AbstractMicrobenchmark.java b/microbench/src/test/java/io/netty/microbench/util/AbstractMicrobenchmark.java
index efb315d4122d..ec8e989c790b 100644
--- a/microbench/src/test/java/io/netty/microbench/util/AbstractMicrobenchmark.java
+++ b/microbench/src/test/java/io/netty/microbench/util/AbstractMicrobenchmark.java
@@ -16,6 +16,7 @@
 package io.netty.microbench.util;
 
 import io.netty.util.ResourceLeakDetector;
+import io.netty.util.concurrent.DefaultThreadFactory;
 import io.netty.util.internal.SystemPropertyUtil;
 import org.junit.Test;
 import org.openjdk.jmh.annotations.Fork;
@@ -23,12 +24,15 @@
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.Warmup;
-import org.openjdk.jmh.output.results.ResultFormatType;
+import org.openjdk.jmh.results.format.ResultFormatType;
 import org.openjdk.jmh.runner.Runner;
 import org.openjdk.jmh.runner.options.ChainedOptionsBuilder;
 import org.openjdk.jmh.runner.options.OptionsBuilder;
 
 import java.io.File;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 
 /**
  * Base class for all JMH benchmarks.
@@ -40,13 +44,25 @@
 public class AbstractMicrobenchmark {
 
     protected static final int DEFAULT_WARMUP_ITERATIONS = 10;
-    protected static final int DEFAULT_MEASURE_ITERATIONS = 1;
+    protected static final int DEFAULT_MEASURE_ITERATIONS = 10;
     protected static final int DEFAULT_FORKS = 2;
 
-    protected static final String JVM_ARGS = "-server -dsa -da -ea:io.netty... -Xms768m" +
-        " -Xmx768m -XX:MaxDirectMemorySize=768m -XX:+AggressiveOpts -XX:+UseBiasedLocking" +
-        " -XX:+UseFastAccessorMethods -XX:+UseStringCache -XX:+OptimizeStringConcat" +
-        " -XX:+HeapDumpOnOutOfMemoryError -Dio.netty.noResourceLeakDetection";
+    public static final class HarnessExecutor extends ThreadPoolExecutor {
+        public HarnessExecutor(int maxThreads, String prefix) {
+            super(0, maxThreads, 1L, TimeUnit.DAYS, new SynchronousQueue<Runnable>(),
+                  new DefaultThreadFactory(prefix));
+            System.out.println("Using harness executor");
+        }
+    }
+
+    protected static final String[] JVM_ARGS = {
+        "-server", "-dsa", "-da", "-ea:io.netty...", "-Xms768m", "-Xmx768m",
+        "-XX:MaxDirectMemorySize=768m", "-XX:+AggressiveOpts", "-XX:+UseBiasedLocking",
+        "-XX:+UseFastAccessorMethods", "-XX:+UseStringCache", "-XX:+OptimizeStringConcat",
+        "-XX:+HeapDumpOnOutOfMemoryError", "-Dio.netty.noResourceLeakDetection",
+        "-Dharness.executor=CUSTOM",
+        "-Dharness.executor.class=io.netty.microbench.util.AbstractMicrobenchmark$HarnessExecutor"
+    };
 
     static {
         ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.DISABLED);
diff --git a/pom.xml b/pom.xml
index 5db3ebe132b7..b9239275d1ba 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,13 +20,13 @@
   <parent>
     <groupId>org.sonatype.oss</groupId>
     <artifactId>oss-parent</artifactId>
-    <version>7</version>
+    <version>9</version>
   </parent>
 
   <groupId>io.netty</groupId>
   <artifactId>netty-parent</artifactId>
   <packaging>pom</packaging>
-  <version>4.0.16.Final-SNAPSHOT</version>
+  <version>4.1.0.Beta1</version>
 
   <name>Netty</name>
   <url>http://netty.io/</url>
@@ -53,7 +53,7 @@
     <url>https://github.com/netty/netty</url>
     <connection>scm:git:git://github.com/netty/netty.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/netty/netty.git</developerConnection>
-    <tag>HEAD</tag>
+    <tag>netty-4.1.0.Beta1</tag>
   </scm>
 
   <developers>
@@ -71,30 +71,20 @@
     <profile>
       <id>leak</id>
       <properties>
-        <test.jvm.argLine>
-          -server 
-          -dsa -da -ea:io.netty...
-          -XX:+AggressiveOpts
-          -XX:+TieredCompilation
-          -XX:+UseBiasedLocking
-          -XX:+UseFastAccessorMethods
-          -XX:+OptimizeStringConcat
-          -XX:+HeapDumpOnOutOfMemoryError
-          -Dio.netty.leakDetectionLevel=3
-        </test.jvm.argLine>
+        <argLine.leak>-Dio.netty.leakDetectionLevel=paranoid</argLine.leak>
       </properties>
     </profile>
     <profile>
       <id>coverage</id>
       <properties>
-        <test.jvm.argLine.coverage>${jacoco.argLine}</test.jvm.argLine.coverage>
+        <argLine.coverage>${jacoco.argLine}</argLine.coverage>
       </properties>
       <build>
         <plugins>
           <plugin>
             <groupId>org.jacoco</groupId>
             <artifactId>jacoco-maven-plugin</artifactId>
-            <version>0.6.4.201312101107</version>
+            <version>0.7.1.201405082137</version>
             <executions>
               <execution>
                 <id>jacoco-prepare-agent</id>
@@ -110,14 +100,211 @@
         </plugins>
       </build>
     </profile>
-    <!-- Our Javadoc has poor enough quality to fail the build thanks to JDK8 javadoc which got more strict. -->
     <profile>
       <id>jdk8</id>
       <activation>
         <jdk>[1.8,)</jdk>
       </activation>
       <properties>
+        <!-- Our Javadoc has poor enough quality to fail the build thanks to JDK8 javadoc which got more strict. -->
         <maven.javadoc.failOnError>false</maven.javadoc.failOnError>
+        <!-- npn-boot does not work with JDK 8 -->
+        <argLine.bootcp>-D_</argLine.bootcp>
+      </properties>
+    </profile>
+    <profile>
+      <id>linux</id>
+      <activation>
+        <os>
+          <family>linux</family>
+        </os>
+      </activation>
+      <modules>
+        <module>transport-native-epoll</module>
+      </modules>
+    </profile>
+    <!--
+      Netty must be released from RHEL 6.5 x86_64 or compatible so that:
+
+        1) we ship x86_64 version of epoll transport officially, and
+        2) we ensure the ABI compatibility with older GLIBC versions.
+
+           The shared library built on a distribution with newer GLIBC
+           will not run on older distributions.
+    -->
+    <profile>
+      <id>restricted-release</id>
+      <build>
+        <plugins>
+          <plugin>
+            <artifactId>maven-enforcer-plugin</artifactId>
+            <executions>
+              <execution>
+                <id>enforce-release-environment</id>
+                <goals>
+                  <goal>enforce</goal>
+                </goals>
+                <configuration>
+                  <rules>
+                    <requireProperty>
+                      <regexMessage>
+                        Release process must be performed on linux-x86_64.
+                      </regexMessage>
+                      <property>os.detected.classifier</property>
+                      <regex>^linux-x86_64$</regex>
+                    </requireProperty>
+                    <requireFilesContent>
+                      <message>
+                        Release process must be performed on RHEL 6.5 or its derivatives.
+                      </message>
+                      <files>
+                        <file>/etc/redhat-release</file>
+                      </files>
+                      <content>release 6.5</content>
+                    </requireFilesContent>
+                  </rules>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+
+    <!--
+      Profiles that assigns proper Jetty npn-boot version.
+      See: http://www.eclipse.org/jetty/documentation/current/npn-chapter.html#npn-versions
+    -->
+    <profile>
+      <id>npn-7u9</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_9</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.3.v20130313</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u10</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_10</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.3.v20130313</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u11</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_11</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.3.v20130313</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u13</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_13</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.4.v20130313</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u15</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_15</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.5.v20130313</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u17</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_17</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.5.v20130313</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u21</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_21</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.5.v20130313</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u25</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_25</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.5.v20130313</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u40</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_40</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.6.v20130911</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u45</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_45</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.6.v20130911</jetty.npn.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>npn-7u51</id>
+      <activation>
+        <property>
+          <name>java.version</name>
+          <value>1.7.0_51</value>
+        </property>
+      </activation>
+      <properties>
+        <jetty.npn.version>1.1.6.v20130911</jetty.npn.version>
       </properties>
     </profile>
   </profiles>
@@ -126,9 +313,10 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
     <jboss.marshalling.version>1.3.18.GA</jboss.marshalling.version>
-    <test.jvm.argLine.coverage></test.jvm.argLine.coverage> <!-- Set when 'coverage' profile is active -->
-    <test.jvm.argLine>
-      -server 
+    <jetty.npn.version>1.1.7.v20140316</jetty.npn.version>
+    <jetty.npn.path>${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${jetty.npn.version}/npn-boot-${jetty.npn.version}.jar</jetty.npn.path>
+    <argLine.common>
+      -server
       -dsa -da -ea:io.netty...
       -XX:+AggressiveOpts
       -XX:+TieredCompilation
@@ -136,15 +324,23 @@
       -XX:+UseFastAccessorMethods
       -XX:+OptimizeStringConcat
       -XX:+HeapDumpOnOutOfMemoryError
-    </test.jvm.argLine>
+    </argLine.common>
+    <argLine.bootcp>-Xbootclasspath/p:${jetty.npn.path}</argLine.bootcp>
+    <argLine.leak>-verbose:gc</argLine.leak> <!-- Overridden when 'leak' profile is active -->
+    <argLine.coverage>-D_</argLine.coverage> <!-- Overridden when 'coverage' profile is active -->
   </properties>
 
   <modules>
     <module>common</module>
     <module>buffer</module>
     <module>codec</module>
+    <module>codec-dns</module>
+    <module>codec-haproxy</module>
     <module>codec-http</module>
+    <module>codec-memcache</module>
+    <module>codec-mqtt</module>
     <module>codec-socks</module>
+    <module>codec-stomp</module>
     <module>transport</module>
     <module>transport-rxtx</module>
     <module>transport-sctp</module>
@@ -176,19 +372,49 @@
         <scope>compile</scope>
         <optional>true</optional>
       </dependency>
-    
-      <!-- SPDY Example - completely optional -->
+
+      <!-- SPDY and HTTP/2 - completely optional -->
       <dependency>
         <groupId>org.eclipse.jetty.npn</groupId>
         <artifactId>npn-api</artifactId>
         <version>1.1.0.v20120525</version>
       </dependency>
-        
+      <dependency>
+        <groupId>org.mortbay.jetty.npn</groupId>
+        <artifactId>npn-boot</artifactId>
+        <version>${jetty.npn.version}</version>
+      </dependency>
+
+      <!-- Google Protocol Buffers - completely optional -->
       <dependency>
         <groupId>com.google.protobuf</groupId>
         <artifactId>protobuf-java</artifactId>
         <version>2.5.0</version>
       </dependency>
+
+      <!-- Our own Tomcat Native fork - completely optional, used for acclerating SSL with OpenSSL. -->
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>netty-tcnative</artifactId>
+        <version>1.1.30.Fork2</version>
+        <classifier>${os.detected.classifier}</classifier>
+        <scope>compile</scope>
+        <optional>true</optional>
+      </dependency>
+
+      <!--
+        Bouncy Castle - completely optional, only needed when:
+        - you generate a temporary self-signed certificate using SelfSignedCertificate, and
+        - you don't use the JDK which doesn't provide sun.security.x509 package.
+      -->
+      <dependency>
+        <groupId>org.bouncycastle</groupId>
+        <artifactId>bcpkix-jdk15on</artifactId>
+        <version>1.50</version>
+        <scope>compile</scope>
+        <optional>true</optional>
+      </dependency>
+
       <dependency>
         <groupId>com.jcraft</groupId>
         <artifactId>jzlib</artifactId>
@@ -280,6 +506,12 @@
         <version>2.6.0</version>
         <scope>test</scope>
       </dependency>
+      <dependency>
+        <groupId>org.mockito</groupId>
+        <artifactId>mockito-all</artifactId>
+        <version>1.9.5</version>
+        <scope>test</scope>
+      </dependency>
       <dependency>
         <groupId>ch.qos.logback</groupId>
         <artifactId>logback-classic</artifactId>
@@ -308,6 +540,14 @@
         <version>0.5-rc1</version>
         <scope>test</scope>
       </dependency>
+
+      <!-- Test dependency for Bzip2Decoder -->
+      <dependency>
+        <groupId>org.apache.commons</groupId>
+        <artifactId>commons-compress</artifactId>
+        <version>1.8.1</version>
+        <scope>test</scope>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -348,10 +588,17 @@
   </dependencies>
 
   <build>
+    <extensions>
+      <extension>
+        <groupId>kr.motd.maven</groupId>
+        <artifactId>os-maven-plugin</artifactId>
+        <version>1.2.3.Final</version>
+      </extension>
+    </extensions>
+
     <plugins>
       <plugin>
         <artifactId>maven-enforcer-plugin</artifactId>
-        <version>1.3</version>
         <executions>
           <execution>
             <id>enforce-tools</id>
@@ -366,7 +613,7 @@
                   <version>[1.7.0,)</version>
                 </requireJavaVersion>
                 <requireMavenVersion>
-                  <version>[3.0.5,)</version>
+                  <version>[3.1.1,)</version>
                 </requireMavenVersion>
               </rules>
             </configuration>
@@ -396,6 +643,9 @@
           -->
           <meminitial>256m</meminitial>
           <maxmem>1024m</maxmem>
+          <excludes>
+            <exclude>**/package-info.java</exclude>
+          </excludes>
         </configuration>
       </plugin>
       <plugin>
@@ -421,16 +671,23 @@
             <ignore>java.nio.channels.DatagramChannel</ignore>
             <ignore>java.nio.channels.MembershipKey</ignore>
             <ignore>java.net.StandardProtocolFamily</ignore>
+            <ignore>java.nio.channels.spi.SelectorProvider</ignore>
 
-            <!-- Used for NIO. 2 -->
-            <ignore>java.nio.channels.AsynchronousChannel</ignore>
-            <ignore>java.nio.channels.AsynchronousSocketChannel</ignore>
-            <ignore>java.nio.channels.AsynchronousServerSocketChannel</ignore>
-            <ignore>java.nio.channels.AsynchronousChannelGroup</ignore>
-            <ignore>java.nio.channels.NetworkChannel</ignore>
-            <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>
-            <ignore>java.net.StandardSocketOptions</ignore>
-            <ignore>java.net.SocketOption</ignore>
+            <!-- Self-signed certificate generation -->
+            <ignore>sun.security.x509.AlgorithmId</ignore>
+            <ignore>sun.security.x509.CertificateAlgorithmId</ignore>
+            <ignore>sun.security.x509.CertificateIssuerName</ignore>
+            <ignore>sun.security.x509.CertificateSerialNumber</ignore>
+            <ignore>sun.security.x509.CertificateSubjectName</ignore>
+            <ignore>sun.security.x509.CertificateValidity</ignore>
+            <ignore>sun.security.x509.CertificateVersion</ignore>
+            <ignore>sun.security.x509.CertificateX509Key</ignore>
+            <ignore>sun.security.x509.X500Name</ignore>
+            <ignore>sun.security.x509.X509CertInfo</ignore>
+            <ignore>sun.security.x509.X509CertImpl</ignore>
+
+            <!-- SSLSession implelementation -->
+            <ignore>javax.net.ssl.SSLEngine</ignore>
           </ignores>
         </configuration>
         <executions>
@@ -466,10 +723,28 @@
           <dependency>
             <groupId>${project.groupId}</groupId>
             <artifactId>netty-build</artifactId>
-            <version>19</version>
+            <version>21</version>
           </dependency>
         </dependencies>
       </plugin>
+      <!-- Download the npn-boot.jar in advance to add it to the boot classpath. -->
+      <plugin>
+        <artifactId>maven-dependency-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>get-npn-boot</id>
+            <phase>validate</phase>
+            <goals>
+              <goal>get</goal>
+            </goals>
+            <configuration>
+              <groupId>org.mortbay.jetty.npn</groupId>
+              <artifactId>npn-boot</artifactId>
+              <version>${jetty.npn.version}</version>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
       <plugin>
         <artifactId>maven-surefire-plugin</artifactId>
         <configuration>
@@ -482,7 +757,7 @@
             <exclude>**/TestUtil*</exclude>
           </excludes>
           <runOrder>random</runOrder>
-          <argLine>${test.jvm.argLine.coverage} ${test.jvm.argLine}</argLine>
+          <argLine>${argLine.common} ${argLine.bootcp} ${argLine.leak} ${argLine.coverage}</argLine>
         </configuration>
       </plugin>
       <!-- always produce osgi bundles -->
@@ -498,10 +773,14 @@
               <goal>manifest</goal>
             </goals>
             <configuration>
+              <supportedProjectTypes>
+                <supportedProjectType>jar</supportedProjectType>
+                <supportedProjectType>bundle</supportedProjectType>
+              </supportedProjectTypes>
               <instructions>
                 <Export-Package>${project.groupId}.*</Export-Package>
                 <!-- enforce JVM vendor package as optional -->
-                <Import-Package>sun.misc.*;resolution:=optional,*</Import-Package>
+                <Import-Package>sun.misc.*;resolution:=optional,sun.nio.ch;resolution:=optional,sun.security.*;resolution:=optional,*</Import-Package>
                 <!-- override "internal" private package convention -->
                 <Private-Package>!*</Private-Package>
               </instructions>
@@ -564,7 +843,7 @@
         <version>2.4.2</version>
         <configuration>
           <useReleaseProfile>false</useReleaseProfile>
-          <arguments>-P release,sonatype-oss-release,full,no-osgi</arguments>
+          <arguments>-P restricted-release,sonatype-oss-release,full</arguments>
           <autoVersionSubmodules>true</autoVersionSubmodules>
           <allowTimestampedSnapshots>false</allowTimestampedSnapshots>
           <tagNameFormat>netty-@{project.version}</tagNameFormat>
@@ -720,6 +999,18 @@
 
     <pluginManagement>
       <plugins>
+        <plugin>
+          <artifactId>maven-enforcer-plugin</artifactId>
+          <version>1.3.1</version>
+          <dependencies>
+            <!-- Provides the 'requireFilesContent' enforcer rule. -->
+            <dependency>
+              <groupId>com.ceilfors.maven.plugin</groupId>
+              <artifactId>enforcer-rules</artifactId>
+              <version>1.1.0</version>
+            </dependency>
+          </dependencies>
+        </plugin>
         <!-- keep surefire and failsafe in sync -->
         <plugin>
           <artifactId>maven-surefire-plugin</artifactId>
@@ -792,9 +1083,14 @@
           <version>1.8</version>
         </plugin>               
         <plugin>
-          <groupId>org.codehaus.mojo</groupId>
+          <groupId>org.fusesource.hawtjni</groupId>
+          <artifactId>maven-hawtjni-plugin</artifactId>
+          <version>1.10</version>
+        </plugin>
+        <plugin>
+          <groupId>kr.motd.maven</groupId>
           <artifactId>exec-maven-plugin</artifactId>
-          <version>1.2.1</version>
+          <version>1.0.0.Final</version>
         </plugin>
 
         <!-- Workaround for the 'M2E plugin execution not covered' problem.
@@ -877,6 +1173,34 @@
                     <ignore />
                   </action>
                 </pluginExecution>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>org.fusesource.hawtjni</groupId>
+                    <artifactId>maven-hawtjni-plugin</artifactId>
+                    <versionRange>[1.10,)</versionRange>
+                    <goals>
+                      <goal>generate</goal>
+                      <goal>build</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <ignore />
+                  </action>
+                </pluginExecution>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-dependency-plugin</artifactId>
+                    <versionRange>[2.8,)</versionRange>
+                    <goals>
+                      <goal>properties</goal>
+                      <goal>copy</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <ignore />
+                  </action>
+                </pluginExecution>
               </pluginExecutions>
             </lifecycleMappingMetadata>
           </configuration>
diff --git a/run-example.sh b/run-example.sh
new file mode 100755
index 000000000000..b931bab17b1d
--- /dev/null
+++ b/run-example.sh
@@ -0,0 +1,96 @@
+#!/bin/bash -e
+EXAMPLE_MAP=(
+  'discard-client:io.netty.example.discard.DiscardClient'
+  'discard-server:io.netty.example.discard.DiscardServer'
+  'echo-client:io.netty.example.echo.EchoClient'
+  'echo-server:io.netty.example.echo.EchoServer'
+  'factorial-client:io.netty.example.factorial.FactorialClient'
+  'factorial-server:io.netty.example.factorial.FactorialServer'
+  'file-server:io.netty.example.file.FileServer'
+  'http-cors-server:io.netty.example.http.cors.HttpCorsServer'
+  'http-file-server:io.netty.example.http.file.HttpStaticFileServer'
+  'http-helloworld-server:io.netty.example.http.helloworld.HttpHelloWorldServer'
+  'http-snoop-client:io.netty.example.http.snoop.HttpSnoopClient'
+  'http-snoop-server:io.netty.example.http.snoop.HttpSnoopServer'
+  'http-upload-client:io.netty.example.http.upload.HttpUploadClient'
+  'http-upload-server:io.netty.example.http.upload.HttpUploadServer'
+  'websocket-client:io.netty.example.http.websocketx.client.WebSocketClient'
+  'websocket-server:io.netty.example.http.websocketx.server.WebSocketServer'
+  'spdy-client:io.netty.example.spdy.client.SpdyClient'
+  'spdy-server:io.netty.example.spdy.server.SpdyServer'
+  'worldclock-client:io.netty.example.worldclock.WorldClockClient'
+  'worldclock-server:io.netty.example.worldclock.WorldClockServer'
+  'objectecho-client:io.netty.example.objectecho.ObjectEchoClient'
+  'objectecho-server:io.netty.example.objectecho.ObjectEchoServer'
+  'quote-client:org.jboss.netty.example.qotm.QuoteOfTheMomentClient'
+  'quote-server:org.jboss.netty.example.qotm.QuoteOfTheMomentServer'
+  'securechat-client:io.netty.example.securechat.SecureChatClient'
+  'securechat-server:io.netty.example.securechat.SecureChatServer'
+  'telnet-client:io.netty.example.telnet.TelnetClient'
+  'telnet-server:io.netty.example.telnet.TelnetServer'
+  'proxy-server:io.netty.example.proxy.HexDumpProxy'
+  'socksproxy-server:io.netty.example.socksproxy.SocksServer'
+  'memcache-binary-client:io.netty.example.memcache.binary.MemcacheClient'
+  'stomp-client:io.netty.example.stomp.StompClient'
+  'uptime-client:io.netty.example.uptime.UptimeClient'
+  'sctpecho-client:io.netty.example.sctp.SctpEchoClient'
+  'sctpecho-server:io.netty.example.sctp.SctpEchoServer'
+  'localecho:io.netty.example.localecho.LocalEcho'
+)
+
+EXAMPLE=''
+EXAMPLE_CLASS=''
+EXAMPLE_ARGS='-D_'
+I=0
+
+while [[ $# -gt 0 ]]; do
+  ARG="$1"
+  shift
+  if [[ "$ARG" =~ (^-.+) ]]; then
+    EXAMPLE_ARGS="$EXAMPLE_ARGS $ARG"
+  else
+    EXAMPLE="$ARG"
+    for E in "${EXAMPLE_MAP[@]}"; do
+      KEY="${E%%:*}"
+      VAL="${E##*:}"
+      if [[ "$EXAMPLE" == "$KEY" ]]; then
+        EXAMPLE_CLASS="$VAL"
+        break
+      fi
+    done
+    break
+  fi
+done
+
+if [[ -z "$EXAMPLE" ]] || [[ -z "$EXAMPLE_CLASS" ]] || [[ $# -ne 0 ]]; then
+  echo "  Usage: $0 [-D<name>[=<value>] ...] <example-name>" >&2
+  echo "Example: $0 -Dport=8443 -Dssl http-server" >&2
+  echo "         $0 -Dhost=127.0.0.1 -Dport=8009 echo-client" >&2
+  echo >&2
+  echo "Available examples:" >&2
+  echo >&2
+  I=0
+  for E in "${EXAMPLE_MAP[@]}"; do
+    if [[ $I -eq 0 ]]; then
+      echo -n '  '
+    fi
+
+    printf '%-24s' "${E%%:*}"
+    ((I++)) || true
+
+    if [[ $I -eq 2 ]]; then
+      I=0
+      echo
+    fi
+  done >&2
+  if [[ $I -ne 0 ]]; then
+    echo >&2
+  fi
+  echo >&2
+  exit 1
+fi
+
+cd "`dirname "$0"`"/example
+echo "[INFO] Running: $EXAMPLE ($EXAMPLE_CLASS $EXAMPLE_ARGS)"
+exec mvn -q -nsu compile exec:exec -Dcheckstyle.skip=true -DargLine.example="$EXAMPLE_ARGS" -DexampleClass="$EXAMPLE_CLASS"
+
diff --git a/tarball/pom.xml b/tarball/pom.xml
index 72d8e5e6e2de..3de0afec5ae9 100644
--- a/tarball/pom.xml
+++ b/tarball/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-tarball</artifactId>
diff --git a/testsuite/pom.xml b/testsuite/pom.xml
index 79821cfcd75e..958ad5aeba39 100644
--- a/testsuite/pom.xml
+++ b/testsuite/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-testsuite</artifactId>
@@ -69,6 +69,12 @@
       <artifactId>netty-transport-udt</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-tcnative</artifactId>
+      <classifier>${os.detected.classifier}</classifier>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
 
   <properties>
@@ -111,7 +117,7 @@
           <cases>
             <case>*</case>
           </cases>
-          <excludeCases/>
+          <excludeCases />
           <failOnNonStrict>false</failOnNonStrict>
           <skip>${skipAutobahnTestsuite}</skip>
         </configuration>
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java
index f6fde17047e6..dabcf5492c35 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java
@@ -36,7 +36,7 @@ protected AbstractClientSocketTest() {
 
     @Override
     protected List<TestsuitePermutation.BootstrapFactory<Bootstrap>> newFactories() {
-        return SocketTestPermutation.clientSocket();
+        return SocketTestPermutation.INSTANCE.clientSocket();
     }
 
     @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java
index e8b1b9a638d7..353f614f2bce 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java
@@ -36,7 +36,7 @@ protected AbstractDatagramTest() {
 
     @Override
     protected List<TestsuitePermutation.BootstrapComboFactory<Bootstrap, Bootstrap>> newFactories() {
-        return SocketTestPermutation.datagram();
+        return SocketTestPermutation.INSTANCE.datagram();
     }
 
     @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java
index fb634556dea9..8a4d17748e4f 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java
@@ -36,7 +36,7 @@ protected AbstractServerSocketTest() {
 
     @Override
     protected List<TestsuitePermutation.BootstrapFactory<ServerBootstrap>> newFactories() {
-        return SocketTestPermutation.serverSocket();
+        return SocketTestPermutation.INSTANCE.serverSocket();
     }
 
     @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketTest.java
index 10e7321a544d..a73d2d545e9d 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketTest.java
@@ -37,7 +37,7 @@ protected AbstractSocketTest() {
 
     @Override
     protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
-        return SocketTestPermutation.socket();
+        return SocketTestPermutation.INSTANCE.socket();
     }
 
     @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketAutoReadTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketAutoReadTest.java
new file mode 100644
index 000000000000..2ec708e4b41d
--- /dev/null
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketAutoReadTest.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.testsuite.transport.socket;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.util.ReferenceCountUtil;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.Assert.*;
+
+public class SocketAutoReadTest extends AbstractSocketTest {
+    private static final Random random = new Random();
+    static final byte[] data = new byte[1024];
+
+    static {
+        random.nextBytes(data);
+    }
+
+    // See https://github.com/netty/netty/pull/2375
+    @Test(timeout = 30000)
+    public void testAutoReadDisableOutsideChannelRead() throws Throwable {
+        run();
+    }
+
+    public void testAutoReadDisableOutsideChannelRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        TestHandler sh = new TestHandler() {
+            private boolean allBytesReceived;
+            @Override
+            public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
+                assertFalse(allBytesReceived);
+                ctx.writeAndFlush(msg);
+                ctx.channel().eventLoop().execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        ctx.channel().config().setAutoRead(false);
+                        allBytesReceived = true;
+                    }
+                });
+            }
+        };
+        sb.childHandler(sh);
+
+        TestHandler ch = new TestHandler();
+        cb.handler(ch);
+        Channel sc = sb.bind().sync().channel();
+        Channel cc = cb.connect().sync().channel();
+        cc.writeAndFlush(Unpooled.wrappedBuffer(data)).sync();
+        Thread.sleep(500);
+        cc.writeAndFlush(Unpooled.wrappedBuffer(data)).sync();
+        Thread.sleep(500);
+        cc.writeAndFlush(Unpooled.wrappedBuffer(data)).sync();
+        Thread.sleep(500);
+
+        cc.close().sync();
+        sc.close().sync();
+
+        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
+            throw sh.exception.get();
+        }
+        if (ch.exception.get() != null && !(ch.exception.get() instanceof IOException)) {
+            throw ch.exception.get();
+        }
+        if (sh.exception.get() != null) {
+            throw sh.exception.get();
+        }
+        if (ch.exception.get() != null) {
+            throw ch.exception.get();
+        }
+    }
+
+    // See https://github.com/netty/netty/pull/2375
+    @Test(timeout = 30000)
+    public void testAutoReadDisableOutsideChannelReadManualRead() throws Throwable {
+        run();
+    }
+
+    public void testAutoReadDisableOutsideChannelReadManualRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+
+        ServerTestHandler sh = new ServerTestHandler();
+        sb.childHandler(sh);
+
+        TestHandler ch = new TestHandler();
+        cb.handler(ch);
+        Channel sc = sb.bind().sync().channel();
+        Channel cc = cb.connect().sync().channel();
+        cc.writeAndFlush(Unpooled.wrappedBuffer(data)).sync();
+        Thread.sleep(500);
+        cc.writeAndFlush(Unpooled.wrappedBuffer(data)).sync();
+        Thread.sleep(500);
+        cc.writeAndFlush(Unpooled.wrappedBuffer(data)).sync();
+        Thread.sleep(500);
+        sh.await();
+        cc.close().sync();
+        sc.close().sync();
+
+        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
+            throw sh.exception.get();
+        }
+        if (ch.exception.get() != null && !(ch.exception.get() instanceof IOException)) {
+            throw ch.exception.get();
+        }
+        if (sh.exception.get() != null) {
+            throw sh.exception.get();
+        }
+        if (ch.exception.get() != null) {
+            throw ch.exception.get();
+        }
+    }
+
+    public static class ServerTestHandler extends TestHandler {
+        enum State {
+            AUTO_READ,
+            SCHEDULED,
+            BYTES_RECEIVED,
+            READ_SCHEDULED
+        }
+        private final CountDownLatch latch = new CountDownLatch(1);
+
+        private State state = State.AUTO_READ;
+
+        @Override
+        public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {
+            ctx.writeAndFlush(msg);
+            switch (state) {
+                case READ_SCHEDULED:
+                    latch.countDown();
+                    break;
+                case AUTO_READ:
+                    state = State.SCHEDULED;
+                    ctx.channel().eventLoop().execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            ctx.channel().config().setAutoRead(false);
+                            state = State.BYTES_RECEIVED;
+                            ctx.channel().eventLoop().schedule(new Runnable() {
+                                @Override
+                                public void run() {
+                                    state = State.READ_SCHEDULED;
+                                    ctx.channel().read();
+                                }
+                            }, 2, TimeUnit.SECONDS);
+                        }
+                    });
+                    break;
+                case BYTES_RECEIVED:
+                    // Once the state is BYTES_RECEIVED we should not receive anymore data.
+                    fail();
+                    break;
+                case SCHEDULED:
+                    // nothing to do
+                    break;
+            }
+        }
+
+        public void await() throws InterruptedException {
+            latch.await();
+        }
+    }
+
+    private static class TestHandler extends ChannelInboundHandlerAdapter {
+        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
+
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx,
+                Throwable cause) throws Exception {
+            if (exception.compareAndSet(null, cause)) {
+                cause.printStackTrace();
+                ctx.close();
+            }
+        }
+
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            ReferenceCountUtil.release(msg);
+        }
+    }
+}
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
index c00fa24b9fc8..3f0e7bc40120 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
@@ -64,7 +64,16 @@ public void testSimpleEcho() throws Throwable {
     }
 
     public void testSimpleEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, false, false);
+        testSimpleEcho0(sb, cb, false, false, true);
+    }
+
+    @Test(timeout = 30000)
+    public void testSimpleEchoNotAutoRead() throws Throwable {
+        run();
+    }
+
+    public void testSimpleEchoNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testSimpleEcho0(sb, cb, false, false, false);
     }
 
     @Test//(timeout = 30000)
@@ -73,7 +82,16 @@ public void testSimpleEchoWithAdditionalExecutor() throws Throwable {
     }
 
     public void testSimpleEchoWithAdditionalExecutor(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, true, false);
+        testSimpleEcho0(sb, cb, true, false, true);
+    }
+
+    @Test//(timeout = 30000)
+    public void testSimpleEchoWithAdditionalExecutorNotAutoRead() throws Throwable {
+        run();
+    }
+
+    public void testSimpleEchoWithAdditionalExecutorNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testSimpleEcho0(sb, cb, true, false, false);
     }
 
     @Test//(timeout = 30000)
@@ -82,7 +100,16 @@ public void testSimpleEchoWithVoidPromise() throws Throwable {
     }
 
     public void testSimpleEchoWithVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, false, true);
+        testSimpleEcho0(sb, cb, false, true, true);
+    }
+
+    @Test//(timeout = 30000)
+    public void testSimpleEchoWithVoidPromiseNotAutoRead() throws Throwable {
+        run();
+    }
+
+    public void testSimpleEchoWithVoidPromiseNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testSimpleEcho0(sb, cb, false, true, false);
     }
 
     @Test(timeout = 30000)
@@ -91,15 +118,15 @@ public void testSimpleEchoWithAdditionalExecutorAndVoidPromise() throws Throwabl
     }
 
     public void testSimpleEchoWithAdditionalExecutorAndVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, true, true);
+        testSimpleEcho0(sb, cb, true, true, true);
     }
 
     private static void testSimpleEcho0(
-            ServerBootstrap sb, Bootstrap cb, boolean additionalExecutor, boolean voidPromise)
+            ServerBootstrap sb, Bootstrap cb, boolean additionalExecutor, boolean voidPromise, boolean autoRead)
             throws Throwable {
 
-        final EchoHandler sh = new EchoHandler();
-        final EchoHandler ch = new EchoHandler();
+        final EchoHandler sh = new EchoHandler(autoRead);
+        final EchoHandler ch = new EchoHandler(autoRead);
 
         if (additionalExecutor) {
             sb.childHandler(new ChannelInitializer<SocketChannel>() {
@@ -188,10 +215,15 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     }
 
     private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
+        private final boolean autoRead;
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
 
+        EchoHandler(boolean autoRead) {
+            this.autoRead = autoRead;
+        }
+
         @Override
         public void channelActive(ChannelHandlerContext ctx)
                 throws Exception {
@@ -217,7 +249,13 @@ public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception
 
         @Override
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-            ctx.flush();
+            try {
+                ctx.flush();
+            } finally {
+                if (!autoRead) {
+                    ctx.read();
+                }
+            }
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
index aaf3708787bb..b3a0e187f67d 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
@@ -49,20 +49,39 @@ public void testFileRegion() throws Throwable {
         run();
     }
 
+    @Test
+    public void testFileRegionNotAutoRead() throws Throwable {
+        run();
+    }
+
     @Test
     public void testFileRegionVoidPromise() throws Throwable {
         run();
     }
 
+    @Test
+    public void testFileRegionVoidPromiseNotAutoRead() throws Throwable {
+        run();
+    }
+
     public void testFileRegion(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testFileRegion0(sb, cb, false);
+        testFileRegion0(sb, cb, false, true);
     }
 
     public void testFileRegionVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testFileRegion0(sb, cb, true);
+        testFileRegion0(sb, cb, true, true);
     }
 
-    private static void testFileRegion0(ServerBootstrap sb, Bootstrap cb, boolean voidPromise) throws Throwable {
+    public void testFileRegionNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testFileRegion0(sb, cb, false, false);
+    }
+
+    public void testFileRegionVoidPromiseNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testFileRegion0(sb, cb, true, false);
+    }
+
+    private static void testFileRegion0(
+            ServerBootstrap sb, Bootstrap cb, boolean voidPromise, final boolean autoRead) throws Throwable {
         File file = File.createTempFile("netty-", ".tmp");
         file.deleteOnExit();
 
@@ -75,12 +94,19 @@ private static void testFileRegion0(ServerBootstrap sb, Bootstrap cb, boolean vo
             public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
             }
 
+            @Override
+            public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+                if (!autoRead) {
+                    ctx.read();
+                }
+            }
+
             @Override
             public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
                 ctx.close();
             }
         };
-        TestHandler sh = new TestHandler();
+        TestHandler sh = new TestHandler(autoRead);
 
         sb.childHandler(sh);
         cb.handler(ch);
@@ -120,10 +146,15 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     }
 
     private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {
+        private final boolean autoRead;
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
 
+        TestHandler(boolean autoRead) {
+            this.autoRead = autoRead;
+        }
+
         @Override
         public void channelActive(ChannelHandlerContext ctx)
                 throws Exception {
@@ -142,6 +173,13 @@ public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception
             counter += actual.length;
         }
 
+        @Override
+        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+            if (!autoRead) {
+                ctx.read();
+            }
+        }
+
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx,
                 Throwable cause) throws Exception {
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
index 38ca0bca50e6..2ff82c7f7b8d 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
@@ -47,9 +47,22 @@ public void testFixedLengthEcho() throws Throwable {
         run();
     }
 
+    @Test
+    public void testFixedLengthEchoNotAutoRead() throws Throwable {
+        run();
+    }
+
     public void testFixedLengthEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        final EchoHandler sh = new EchoHandler();
-        final EchoHandler ch = new EchoHandler();
+        testFixedLengthEcho(sb, cb, true);
+    }
+
+    public void testFixedLengthEchoNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testFixedLengthEcho(sb, cb, false);
+    }
+
+    private static void testFixedLengthEcho(ServerBootstrap sb, Bootstrap cb, boolean autoRead) throws Throwable {
+        final EchoHandler sh = new EchoHandler(autoRead);
+        final EchoHandler ch = new EchoHandler(autoRead);
 
         sb.childHandler(new ChannelInitializer<SocketChannel>() {
             @Override
@@ -124,10 +137,15 @@ public void initChannel(SocketChannel sch) throws Exception {
     }
 
     private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
+        private final boolean autoRead;
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
 
+        EchoHandler(boolean autoRead) {
+            this.autoRead = autoRead;
+        }
+
         @Override
         public void channelActive(ChannelHandlerContext ctx) throws Exception {
             channel = ctx.channel();
@@ -154,7 +172,13 @@ public void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exceptio
 
         @Override
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-            ctx.flush();
+            try {
+                ctx.flush();
+            } finally {
+                if (!autoRead) {
+                    ctx.read();
+                }
+            }
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
index 59135f502197..89c21ef37157 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
@@ -46,7 +46,16 @@ public void testGatheringWrite() throws Throwable {
     }
 
     public void testGatheringWrite(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testGatheringWrite0(sb, cb, false);
+        testGatheringWrite0(sb, cb, false, true);
+    }
+
+    @Test(timeout = 30000)
+    public void testGatheringWriteNotAutoRead() throws Throwable {
+        run();
+    }
+
+    public void testGatheringWriteNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testGatheringWrite0(sb, cb, false, false);
     }
 
     @Test(timeout = 30000)
@@ -54,13 +63,23 @@ public void testGatheringWriteWithComposite() throws Throwable {
         run();
     }
 
+    public void testGatheringWriteWithCompositeNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testGatheringWrite0(sb, cb, true, false);
+    }
+
+    @Test(timeout = 30000)
+    public void testGatheringWriteWithCompositeNotAutoRead() throws Throwable {
+        run();
+    }
+
     public void testGatheringWriteWithComposite(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testGatheringWrite0(sb, cb, true);
+        testGatheringWrite0(sb, cb, true, true);
     }
 
-    private static void testGatheringWrite0(ServerBootstrap sb, Bootstrap cb, boolean composite) throws Throwable {
-        final TestHandler sh = new TestHandler();
-        final TestHandler ch = new TestHandler();
+    private static void testGatheringWrite0(
+            ServerBootstrap sb, Bootstrap cb, boolean composite, boolean autoRead) throws Throwable {
+        final TestHandler sh = new TestHandler(autoRead);
+        final TestHandler ch = new TestHandler(autoRead);
 
         cb.handler(ch);
         sb.childHandler(sh);
@@ -121,10 +140,16 @@ private static void testGatheringWrite0(ServerBootstrap sb, Bootstrap cb, boolea
     }
 
     private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {
+        private final boolean autoRead;
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
         final ByteBuf received = Unpooled.buffer();
+
+        TestHandler(boolean autoRead) {
+            this.autoRead = autoRead;
+        }
+
         @Override
         public void channelActive(ChannelHandlerContext ctx)
                 throws Exception {
@@ -137,6 +162,13 @@ public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception
             received.writeBytes(in);
         }
 
+        @Override
+        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+            if (!autoRead) {
+                ctx.read();
+            }
+        }
+
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx,
                 Throwable cause) throws Exception {
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java
index 750ce8422b98..d1af7462b3ae 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java
@@ -56,8 +56,21 @@ public void testObjectEcho() throws Throwable {
     }
 
     public void testObjectEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        final EchoHandler sh = new EchoHandler();
-        final EchoHandler ch = new EchoHandler();
+        testObjectEcho(sb, cb, true);
+    }
+
+    @Test
+    public void testObjectEchoNotAutoRead() throws Throwable {
+        run();
+    }
+
+    public void testObjectEchoNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testObjectEcho(sb, cb, false);
+    }
+
+    private static void testObjectEcho(ServerBootstrap sb, Bootstrap cb, boolean autoRead) throws Throwable {
+        final EchoHandler sh = new EchoHandler(autoRead);
+        final EchoHandler ch = new EchoHandler(autoRead);
 
         sb.childHandler(new ChannelInitializer<SocketChannel>() {
             @Override
@@ -134,10 +147,15 @@ public void initChannel(SocketChannel sch) throws Exception {
     }
 
     private static class EchoHandler extends ChannelInboundHandlerAdapter {
+        private final boolean autoRead;
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
 
+        EchoHandler(boolean autoRead) {
+            this.autoRead = autoRead;
+        }
+
         @Override
         public void channelActive(ChannelHandlerContext ctx)
                 throws Exception {
@@ -157,7 +175,13 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
         @Override
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-            ctx.flush();
+            try {
+                ctx.flush();
+            } finally {
+                if (!autoRead) {
+                    ctx.read();
+                }
+            }
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
index 1780ad66e094..8e5ef76739ca 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
@@ -25,8 +25,7 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
-import io.netty.handler.codec.spdy.SpdyFrameDecoder;
-import io.netty.handler.codec.spdy.SpdyFrameEncoder;
+import io.netty.handler.codec.spdy.SpdyFrameCodec;
 import io.netty.handler.codec.spdy.SpdyVersion;
 import io.netty.util.NetUtil;
 import org.junit.Test;
@@ -145,24 +144,31 @@ private static ByteBuf createFrames(int version) {
         return frames;
     }
 
-    private SpdyVersion version;
-
     @Test(timeout = 15000)
     public void testSpdyEcho() throws Throwable {
-        version = SpdyVersion.SPDY_3;
-        logger.info("Testing against SPDY v3");
         run();
+    }
 
-        version = SpdyVersion.SPDY_3_1;
+    public void testSpdyEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
         logger.info("Testing against SPDY v3.1");
+        testSpdyEcho(sb, cb, SpdyVersion.SPDY_3_1, true);
+    }
+
+    @Test(timeout = 15000)
+    public void testSpdyEchoNotAutoRead() throws Throwable {
         run();
     }
 
-    public void testSpdyEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+    public void testSpdyEchoNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        logger.info("Testing against SPDY v3.1");
+        testSpdyEcho(sb, cb, SpdyVersion.SPDY_3_1, false);
+    }
+
+    private static void testSpdyEcho(
+            ServerBootstrap sb, Bootstrap cb, final SpdyVersion version, boolean autoRead) throws Throwable {
 
         ByteBuf frames;
         switch (version) {
-        case SPDY_3:
         case SPDY_3_1:
             frames = createFrames(3);
             break;
@@ -170,15 +176,14 @@ public void testSpdyEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
             throw new IllegalArgumentException("unknown version");
         }
 
-        final SpdyEchoTestServerHandler sh = new SpdyEchoTestServerHandler();
-        final SpdyEchoTestClientHandler ch = new SpdyEchoTestClientHandler(frames.copy());
+        final SpdyEchoTestServerHandler sh = new SpdyEchoTestServerHandler(autoRead);
+        final SpdyEchoTestClientHandler ch = new SpdyEchoTestClientHandler(frames.copy(), autoRead);
 
         sb.childHandler(new ChannelInitializer<SocketChannel>() {
             @Override
             public void initChannel(SocketChannel channel) throws Exception {
                 channel.pipeline().addLast(
-                        new SpdyFrameDecoder(version),
-                        new SpdyFrameEncoder(version),
+                        new SpdyFrameCodec(version),
                         sh);
             }
         });
@@ -221,8 +226,13 @@ public void initChannel(SocketChannel channel) throws Exception {
     }
 
     private static class SpdyEchoTestServerHandler extends ChannelInboundHandlerAdapter {
+        private final boolean autoRead;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
 
+        SpdyEchoTestServerHandler(boolean autoRead) {
+            this.autoRead = autoRead;
+        }
+
         @Override
         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
             ctx.write(msg);
@@ -230,7 +240,13 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
 
         @Override
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-            ctx.flush();
+            try {
+                ctx.flush();
+            } finally {
+                if (!autoRead) {
+                    ctx.read();
+                }
+            }
         }
 
         @Override
@@ -242,12 +258,14 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     }
 
     private static class SpdyEchoTestClientHandler extends SimpleChannelInboundHandler<ByteBuf> {
+        private final boolean autoRead;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         final ByteBuf frames;
         volatile int counter;
 
-        SpdyEchoTestClientHandler(ByteBuf frames) {
+        SpdyEchoTestClientHandler(ByteBuf frames, boolean autoRead) {
             this.frames = frames;
+            this.autoRead = autoRead;
         }
 
         @Override
@@ -269,5 +287,12 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
                 ctx.close();
             }
         }
+
+        @Override
+        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+            if (!autoRead) {
+                ctx.read();
+            }
+        }
     }
 }
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
index f7b631714767..d377e4996e3d 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
@@ -25,17 +25,26 @@
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.SocketChannel;
+import io.netty.handler.ssl.JdkSslClientContext;
+import io.netty.handler.ssl.JdkSslServerContext;
+import io.netty.handler.ssl.OpenSsl;
+import io.netty.handler.ssl.OpenSslServerContext;
+import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslHandler;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 import io.netty.handler.stream.ChunkedWriteHandler;
-import io.netty.testsuite.util.BogusSslContextFactory;
 import io.netty.util.concurrent.Future;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
 import javax.net.ssl.SSLEngine;
+import java.io.File;
 import java.io.IOException;
+import java.security.cert.CertificateException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
@@ -50,64 +59,111 @@
 @RunWith(Parameterized.class)
 public class SocketSslEchoTest extends AbstractSocketTest {
 
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocketSslEchoTest.class);
+
     private static final int FIRST_MESSAGE_SIZE = 16384;
     private static final Random random = new Random();
+    private static final File CERT_FILE;
+    private static final File KEY_FILE;
     static final byte[] data = new byte[1048576];
 
     static {
         random.nextBytes(data);
+
+        SelfSignedCertificate ssc;
+        try {
+            ssc = new SelfSignedCertificate();
+        } catch (CertificateException e) {
+            throw new Error(e);
+        }
+        CERT_FILE = ssc.certificate();
+        KEY_FILE = ssc.privateKey();
     }
 
     @Parameters(name = "{index}: " +
-            "serverUsesDelegatedTaskExecutor = {0}, clientUsesDelegatedTaskExecutor = {1}, " +
-            "useChunkedWriteHandler = {2}, useCompositeByteBuf = {3}")
-    public static Collection<Object[]> data() {
+            "serverEngine = {0}, clientEngine = {1}, " +
+            "serverUsesDelegatedTaskExecutor = {2}, clientUsesDelegatedTaskExecutor = {3}, " +
+            "useChunkedWriteHandler = {4}, useCompositeByteBuf = {5}")
+    public static Collection<Object[]> data() throws Exception {
+        List<SslContext> serverContexts = new ArrayList<SslContext>();
+        serverContexts.add(new JdkSslServerContext(CERT_FILE, KEY_FILE));
+
+        List<SslContext> clientContexts = new ArrayList<SslContext>();
+        clientContexts.add(new JdkSslClientContext(CERT_FILE));
+
+        boolean hasOpenSsl = OpenSsl.isAvailable();
+        if (hasOpenSsl) {
+            serverContexts.add(new OpenSslServerContext(CERT_FILE, KEY_FILE));
+
+            // TODO: Client mode is not supported yet.
+            // clientContexts.add(new OpenSslContext(CERT_FILE));
+        } else {
+            logger.warn("OpenSSL is unavailable and thus will not be tested.", OpenSsl.unavailabilityCause());
+        }
+
         List<Object[]> params = new ArrayList<Object[]>();
-        for (int i = 0; i < 16; i ++) {
-            params.add(new Object[] {
-                    (i & 8) != 0, (i & 4) != 0, (i & 2) != 0, (i & 1) != 0
-            });
+        for (SslContext sc: serverContexts) {
+            for (SslContext cc: clientContexts) {
+                for (int i = 0; i < 16; i ++) {
+                    params.add(new Object[] { sc, cc, (i & 8) != 0, (i & 4) != 0, (i & 2) != 0, (i & 1) != 0 });
+                }
+            }
         }
+
         return params;
     }
 
+    private final SslContext serverCtx;
+    private final SslContext clientCtx;
     private final boolean serverUsesDelegatedTaskExecutor;
     private final boolean clientUsesDelegatedTaskExecutor;
     private final boolean useChunkedWriteHandler;
     private final boolean useCompositeByteBuf;
 
     public SocketSslEchoTest(
+            SslContext serverCtx, SslContext clientCtx,
             boolean serverUsesDelegatedTaskExecutor, boolean clientUsesDelegatedTaskExecutor,
             boolean useChunkedWriteHandler, boolean useCompositeByteBuf) {
+        this.serverCtx = serverCtx;
+        this.clientCtx = clientCtx;
         this.serverUsesDelegatedTaskExecutor = serverUsesDelegatedTaskExecutor;
         this.clientUsesDelegatedTaskExecutor = clientUsesDelegatedTaskExecutor;
         this.useChunkedWriteHandler = useChunkedWriteHandler;
         this.useCompositeByteBuf = useCompositeByteBuf;
     }
 
-    @Test
+    @Test(timeout = 30000)
     public void testSslEcho() throws Throwable {
         run();
     }
 
     public void testSslEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        final ExecutorService delegatedTaskExecutor = Executors.newCachedThreadPool();
-        final EchoHandler sh = new EchoHandler(true, useCompositeByteBuf);
-        final EchoHandler ch = new EchoHandler(false, useCompositeByteBuf);
+        testSslEcho(sb, cb, true);
+    }
 
-        final SSLEngine sse = BogusSslContextFactory.getServerContext().createSSLEngine();
-        final SSLEngine cse = BogusSslContextFactory.getClientContext().createSSLEngine();
-        sse.setUseClientMode(false);
-        cse.setUseClientMode(true);
+    @Test(timeout = 30000)
+    public void testSslEchoNotAutoRead() throws Throwable {
+        run();
+    }
+
+    public void testSslEchoNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testSslEcho(sb, cb, false);
+    }
+
+    private void testSslEcho(ServerBootstrap sb, Bootstrap cb, boolean autoRead) throws Throwable {
+        final ExecutorService delegatedTaskExecutor = Executors.newCachedThreadPool();
+        final EchoHandler sh = new EchoHandler(true, useCompositeByteBuf, autoRead);
+        final EchoHandler ch = new EchoHandler(false, useCompositeByteBuf, autoRead);
 
         sb.childHandler(new ChannelInitializer<SocketChannel>() {
             @Override
             @SuppressWarnings("deprecation")
             public void initChannel(SocketChannel sch) throws Exception {
                 if (serverUsesDelegatedTaskExecutor) {
+                    SSLEngine sse = serverCtx.newEngine(sch.alloc());
                     sch.pipeline().addFirst("ssl", new SslHandler(sse, delegatedTaskExecutor));
                 } else {
-                    sch.pipeline().addFirst("ssl", new SslHandler(sse));
+                    sch.pipeline().addFirst("ssl", serverCtx.newHandler(sch.alloc()));
                 }
                 if (useChunkedWriteHandler) {
                     sch.pipeline().addLast(new ChunkedWriteHandler());
@@ -121,9 +177,10 @@ public void initChannel(SocketChannel sch) throws Exception {
             @SuppressWarnings("deprecation")
             public void initChannel(SocketChannel sch) throws Exception {
                 if (clientUsesDelegatedTaskExecutor) {
+                    SSLEngine cse = clientCtx.newEngine(sch.alloc());
                     sch.pipeline().addFirst("ssl", new SslHandler(cse, delegatedTaskExecutor));
                 } else {
-                    sch.pipeline().addFirst("ssl", new SslHandler(cse));
+                    sch.pipeline().addFirst("ssl", clientCtx.newHandler(sch.alloc()));
                 }
                 if (useChunkedWriteHandler) {
                     sch.pipeline().addLast(new ChunkedWriteHandler());
@@ -202,16 +259,18 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    private class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
+    private static class EchoHandler extends SimpleChannelInboundHandler<ByteBuf> {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
         private final boolean server;
         private final boolean composite;
+        private final boolean autoRead;
 
-        EchoHandler(boolean server, boolean composite) {
+        EchoHandler(boolean server, boolean composite, boolean autoRead) {
             this.server = server;
             this.composite = composite;
+            this.autoRead = autoRead;
         }
 
         @Override
@@ -243,7 +302,13 @@ public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception
 
         @Override
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-            ctx.flush();
+            try {
+                ctx.flush();
+            } finally {
+                if (!autoRead) {
+                    ctx.read();
+                }
+            }
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java
new file mode 100644
index 000000000000..b4d529d6e3ce
--- /dev/null
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java
@@ -0,0 +1,215 @@
+/*
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+package io.netty.testsuite.transport.socket;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.handler.logging.LogLevel;
+import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.JdkSslClientContext;
+import io.netty.handler.ssl.JdkSslServerContext;
+import io.netty.handler.ssl.OpenSsl;
+import io.netty.handler.ssl.OpenSslServerContext;
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import java.io.File;
+import java.io.IOException;
+import java.security.cert.CertificateException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.Assert.*;
+
+@RunWith(Parameterized.class)
+public class SocketSslGreetingTest extends AbstractSocketTest {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocketSslGreetingTest.class);
+
+    private static final LogLevel LOG_LEVEL = LogLevel.TRACE;
+    private static final File CERT_FILE;
+    private static final File KEY_FILE;
+    private final ByteBuf greeting = ReferenceCountUtil.releaseLater(Unpooled.buffer().writeByte('a'));
+
+    static {
+        SelfSignedCertificate ssc;
+        try {
+            ssc = new SelfSignedCertificate();
+        } catch (CertificateException e) {
+            throw new Error(e);
+        }
+        CERT_FILE = ssc.certificate();
+        KEY_FILE = ssc.privateKey();
+    }
+
+    @Parameters(name = "{index}: serverEngine = {0}, clientEngine = {1}")
+    public static Collection<Object[]> data() throws Exception {
+        List<SslContext> serverContexts = new ArrayList<SslContext>();
+        serverContexts.add(new JdkSslServerContext(CERT_FILE, KEY_FILE));
+
+        List<SslContext> clientContexts = new ArrayList<SslContext>();
+        clientContexts.add(new JdkSslClientContext(CERT_FILE));
+
+        boolean hasOpenSsl = OpenSsl.isAvailable();
+        if (hasOpenSsl) {
+            serverContexts.add(new OpenSslServerContext(CERT_FILE, KEY_FILE));
+
+            // TODO: Client mode is not supported yet.
+            // clientContexts.add(new OpenSslContext(CERT_FILE));
+        } else {
+            logger.warn("OpenSSL is unavailable and thus will not be tested.", OpenSsl.unavailabilityCause());
+        }
+
+        List<Object[]> params = new ArrayList<Object[]>();
+        for (SslContext sc: serverContexts) {
+            for (SslContext cc: clientContexts) {
+                params.add(new Object[] { sc, cc });
+            }
+        }
+        return params;
+    }
+
+    private final SslContext serverCtx;
+    private final SslContext clientCtx;
+
+    public SocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx) {
+        this.serverCtx = serverCtx;
+        this.clientCtx = clientCtx;
+    }
+
+    // Test for https://github.com/netty/netty/pull/2437
+    @Test(timeout = 30000)
+    public void testSslGreeting() throws Throwable {
+        run();
+    }
+
+    public void testSslGreeting(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        final ServerHandler sh = new ServerHandler();
+        final ClientHandler ch = new ClientHandler();
+
+        sb.childHandler(new ChannelInitializer<SocketChannel>() {
+            @Override
+            public void initChannel(SocketChannel sch) throws Exception {
+                ChannelPipeline p = sch.pipeline();
+                p.addLast(serverCtx.newHandler(sch.alloc()));
+                p.addLast(new LoggingHandler(LOG_LEVEL));
+                p.addLast(sh);
+            }
+        });
+
+        cb.handler(new ChannelInitializer<SocketChannel>() {
+            @Override
+            public void initChannel(SocketChannel sch) throws Exception {
+                ChannelPipeline p = sch.pipeline();
+                p.addLast(clientCtx.newHandler(sch.alloc()));
+                p.addLast(new LoggingHandler(LOG_LEVEL));
+                p.addLast(ch);
+            }
+        });
+
+        Channel sc = sb.bind().sync().channel();
+        Channel cc = cb.connect().sync().channel();
+
+        ch.latch.await();
+
+        sh.channel.close().awaitUninterruptibly();
+        cc.close().awaitUninterruptibly();
+        sc.close().awaitUninterruptibly();
+
+        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
+            throw sh.exception.get();
+        }
+        if (ch.exception.get() != null && !(ch.exception.get() instanceof IOException)) {
+            throw ch.exception.get();
+        }
+        if (sh.exception.get() != null) {
+            throw sh.exception.get();
+        }
+        if (ch.exception.get() != null) {
+            throw ch.exception.get();
+        }
+    }
+
+    private class ClientHandler extends SimpleChannelInboundHandler<ByteBuf> {
+
+        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        @Override
+        public void channelRead0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception {
+            assertEquals(greeting, buf);
+            latch.countDown();
+            ctx.close();
+        }
+
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx,
+                                    Throwable cause) throws Exception {
+            if (logger.isWarnEnabled()) {
+                logger.warn("Unexpected exception from the client side", cause);
+            }
+
+            exception.compareAndSet(null, cause);
+            ctx.close();
+        }
+    }
+
+    private class ServerHandler extends SimpleChannelInboundHandler<String> {
+        volatile Channel channel;
+        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
+
+        @Override
+        protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
+            // discard
+        }
+
+        @Override
+        public void channelActive(ChannelHandlerContext ctx)
+                throws Exception {
+            channel = ctx.channel();
+            channel.writeAndFlush(greeting.duplicate().retain());
+        }
+
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx,
+                                    Throwable cause) throws Exception {
+            if (logger.isWarnEnabled()) {
+                logger.warn("Unexpected exception from the server side", cause);
+            }
+
+            exception.compareAndSet(null, cause);
+            ctx.close();
+        }
+    }
+}
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
index b42a49fd645c..c4eae5d0a392 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
@@ -17,6 +17,7 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.PooledByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
@@ -28,26 +29,84 @@
 import io.netty.handler.codec.string.StringEncoder;
 import io.netty.handler.logging.LogLevel;
 import io.netty.handler.logging.LoggingHandler;
+import io.netty.handler.ssl.JdkSslClientContext;
+import io.netty.handler.ssl.JdkSslServerContext;
+import io.netty.handler.ssl.OpenSsl;
+import io.netty.handler.ssl.OpenSslServerContext;
+import io.netty.handler.ssl.SslContext;
 import io.netty.handler.ssl.SslHandler;
-import io.netty.testsuite.util.BogusSslContextFactory;
+import io.netty.handler.ssl.util.SelfSignedCertificate;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
 import io.netty.util.concurrent.EventExecutorGroup;
 import io.netty.util.concurrent.Future;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 import javax.net.ssl.SSLEngine;
+import java.io.File;
 import java.io.IOException;
+import java.security.cert.CertificateException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static org.junit.Assert.*;
 
+@RunWith(Parameterized.class)
 public class SocketStartTlsTest extends AbstractSocketTest {
 
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocketStartTlsTest.class);
+
     private static final LogLevel LOG_LEVEL = LogLevel.TRACE;
+    private static final File CERT_FILE;
+    private static final File KEY_FILE;
     private static EventExecutorGroup executor;
 
+    static {
+        SelfSignedCertificate ssc;
+        try {
+            ssc = new SelfSignedCertificate();
+        } catch (CertificateException e) {
+            throw new Error(e);
+        }
+        CERT_FILE = ssc.certificate();
+        KEY_FILE = ssc.privateKey();
+    }
+
+    @Parameters(name = "{index}: serverEngine = {0}, clientEngine = {1}")
+    public static Collection<Object[]> data() throws Exception {
+        List<SslContext> serverContexts = new ArrayList<SslContext>();
+        serverContexts.add(new JdkSslServerContext(CERT_FILE, KEY_FILE));
+
+        List<SslContext> clientContexts = new ArrayList<SslContext>();
+        clientContexts.add(new JdkSslClientContext(CERT_FILE));
+
+        boolean hasOpenSsl = OpenSsl.isAvailable();
+        if (hasOpenSsl) {
+            serverContexts.add(new OpenSslServerContext(CERT_FILE, KEY_FILE));
+
+            // TODO: Client mode is not supported yet.
+            // clientContexts.add(new OpenSslContext(CERT_FILE));
+        } else {
+            logger.warn("OpenSSL is unavailable and thus will not be tested.", OpenSsl.unavailabilityCause());
+        }
+
+        List<Object[]> params = new ArrayList<Object[]>();
+        for (SslContext sc: serverContexts) {
+            for (SslContext cc: clientContexts) {
+                params.add(new Object[] { sc, cc });
+            }
+        }
+        return params;
+    }
+
     @BeforeClass
     public static void createExecutor() {
         executor = new DefaultEventExecutorGroup(2);
@@ -58,18 +117,39 @@ public static void shutdownExecutor() throws Exception {
         executor.shutdownGracefully().sync();
     }
 
+    private final SslContext serverCtx;
+    private final SslContext clientCtx;
+
+    public SocketStartTlsTest(SslContext serverCtx, SslContext clientCtx) {
+        this.serverCtx = serverCtx;
+        this.clientCtx = clientCtx;
+    }
+
     @Test(timeout = 30000)
     public void testStartTls() throws Throwable {
         run();
     }
 
     public void testStartTls(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testStartTls(sb, cb, true);
+    }
+
+    @Test(timeout = 30000)
+    public void testStartTlsNotAutoRead() throws Throwable {
+        run();
+    }
+
+    public void testStartTlsNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testStartTls(sb, cb, false);
+    }
+
+    private void testStartTls(ServerBootstrap sb, Bootstrap cb, boolean autoRead) throws Throwable {
         final EventExecutorGroup executor = SocketStartTlsTest.executor;
-        final SSLEngine sse = BogusSslContextFactory.getServerContext().createSSLEngine();
-        final SSLEngine cse = BogusSslContextFactory.getClientContext().createSSLEngine();
+        SSLEngine sse = serverCtx.newEngine(PooledByteBufAllocator.DEFAULT);
+        SSLEngine cse = clientCtx.newEngine(PooledByteBufAllocator.DEFAULT);
 
-        final StartTlsServerHandler sh = new StartTlsServerHandler(sse);
-        final StartTlsClientHandler ch = new StartTlsClientHandler(cse);
+        final StartTlsServerHandler sh = new StartTlsServerHandler(sse, autoRead);
+        final StartTlsClientHandler ch = new StartTlsClientHandler(cse, autoRead);
 
         sb.childHandler(new ChannelInitializer<SocketChannel>() {
             @Override
@@ -142,14 +222,16 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    private class StartTlsClientHandler extends SimpleChannelInboundHandler<String> {
+    private static class StartTlsClientHandler extends SimpleChannelInboundHandler<String> {
         private final SslHandler sslHandler;
+        private final boolean autoRead;
         private Future<Channel> handshakeFuture;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
 
-        StartTlsClientHandler(SSLEngine engine) {
+        StartTlsClientHandler(SSLEngine engine, boolean autoRead) {
             engine.setUseClientMode(true);
             sslHandler = new SslHandler(engine);
+            this.autoRead = autoRead;
         }
 
         @Override
@@ -173,6 +255,13 @@ public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception
             ctx.close();
         }
 
+        @Override
+        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+            if (!autoRead) {
+                ctx.read();
+            }
+        }
+
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx,
                 Throwable cause) throws Exception {
@@ -185,14 +274,16 @@ public void exceptionCaught(ChannelHandlerContext ctx,
         }
     }
 
-    private class StartTlsServerHandler extends SimpleChannelInboundHandler<String> {
+    private static class StartTlsServerHandler extends SimpleChannelInboundHandler<String> {
         private final SslHandler sslHandler;
+        private final boolean autoRead;
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
 
-        StartTlsServerHandler(SSLEngine engine) {
+        StartTlsServerHandler(SSLEngine engine, boolean autoRead) {
             engine.setUseClientMode(false);
             sslHandler = new SslHandler(engine, true);
+            this.autoRead = autoRead;
         }
 
         @Override
@@ -212,6 +303,13 @@ public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception
             ctx.writeAndFlush("EncryptedResponse\n");
         }
 
+        @Override
+        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+            if (!autoRead) {
+                ctx.read();
+            }
+        }
+
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx,
                                     Throwable cause) throws Exception {
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
index 960930ae20e8..38123532e553 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
@@ -58,8 +58,21 @@ public void testStringEcho() throws Throwable {
     }
 
     public void testStringEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        final StringEchoHandler sh = new StringEchoHandler();
-        final StringEchoHandler ch = new StringEchoHandler();
+        testStringEcho(sb, cb, true);
+    }
+
+    @Test
+    public void testStringEchoNotAutoRead() throws Throwable {
+        run();
+    }
+
+    public void testStringEchoNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testStringEcho(sb, cb, false);
+    }
+
+    private static void testStringEcho(ServerBootstrap sb, Bootstrap cb, boolean autoRead) throws Throwable {
+        final StringEchoHandler sh = new StringEchoHandler(autoRead);
+        final StringEchoHandler ch = new StringEchoHandler(autoRead);
 
         sb.childHandler(new ChannelInitializer<SocketChannel>() {
             @Override
@@ -136,10 +149,15 @@ public void initChannel(SocketChannel sch) throws Exception {
     }
 
     static class StringEchoHandler extends SimpleChannelInboundHandler<String> {
+        private final boolean autoRead;
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
 
+        StringEchoHandler(boolean autoRead) {
+            this.autoRead = autoRead;
+        }
+
         @Override
         public void channelActive(ChannelHandlerContext ctx) throws Exception {
             channel = ctx.channel();
@@ -159,7 +177,13 @@ public void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception
 
         @Override
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-            ctx.flush();
+            try {
+                ctx.flush();
+            } finally {
+                if (!autoRead) {
+                    ctx.read();
+                }
+            }
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
index 05dd6d4008a9..740c69753d47 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
@@ -15,10 +15,12 @@
  */
 package io.netty.testsuite.transport.socket;
 
+import io.netty.bootstrap.AbstractBootstrap;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ChannelFactory;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.oio.OioEventLoopGroup;
@@ -34,148 +36,136 @@
 import io.netty.util.concurrent.DefaultThreadFactory;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
-public final class SocketTestPermutation {
-    private SocketTestPermutation() {
-        // utility
-    }
+public class SocketTestPermutation {
+
+    static final SocketTestPermutation INSTANCE = new SocketTestPermutation();
+
+    protected static final int BOSSES = 2;
+    protected static final int WORKERS = 3;
+
+    protected static final int OIO_SO_TIMEOUT = 10;  // Use short timeout for faster runs.
 
-    private static final int BOSSES = 2;
-    private static final int WORKERS = 3;
-    private static final EventLoopGroup nioBossGroup =
+    protected final EventLoopGroup nioBossGroup =
             new NioEventLoopGroup(BOSSES, new DefaultThreadFactory("testsuite-nio-boss", true));
-    private static final EventLoopGroup nioWorkerGroup =
+    protected final EventLoopGroup nioWorkerGroup =
             new NioEventLoopGroup(WORKERS, new DefaultThreadFactory("testsuite-nio-worker", true));
-    private static final EventLoopGroup oioBossGroup =
+    protected final EventLoopGroup oioBossGroup =
             new OioEventLoopGroup(Integer.MAX_VALUE, new DefaultThreadFactory("testsuite-oio-boss", true));
-    private static final EventLoopGroup oioWorkerGroup =
+    protected final EventLoopGroup oioWorkerGroup =
             new OioEventLoopGroup(Integer.MAX_VALUE, new DefaultThreadFactory("testsuite-oio-worker", true));
 
-    static List<BootstrapComboFactory<ServerBootstrap, Bootstrap>> socket() {
-        List<BootstrapComboFactory<ServerBootstrap, Bootstrap>> list =
-                new ArrayList<BootstrapComboFactory<ServerBootstrap, Bootstrap>>();
+    protected <A extends AbstractBootstrap<?, ?>, B extends AbstractBootstrap<?, ?>>
+    List<BootstrapComboFactory<A, B>> combo(List<BootstrapFactory<A>> sbfs, List<BootstrapFactory<B>> cbfs) {
 
-        // Make the list of ServerBootstrap factories.
-        List<BootstrapFactory<ServerBootstrap>> sbfs = serverSocket();
-
-        // Make the list of Bootstrap factories.
-        List<BootstrapFactory<Bootstrap>> cbfs = clientSocket();
+        List<BootstrapComboFactory<A, B>> list = new ArrayList<BootstrapComboFactory<A, B>>();
 
         // Populate the combinations
-        for (BootstrapFactory<ServerBootstrap> sbf: sbfs) {
-            for (BootstrapFactory<Bootstrap> cbf: cbfs) {
-                final BootstrapFactory<ServerBootstrap> sbf0 = sbf;
-                final BootstrapFactory<Bootstrap> cbf0 = cbf;
-                list.add(new BootstrapComboFactory<ServerBootstrap, Bootstrap>() {
+        for (BootstrapFactory<A> sbf: sbfs) {
+            for (BootstrapFactory<B> cbf: cbfs) {
+                final BootstrapFactory<A> sbf0 = sbf;
+                final BootstrapFactory<B> cbf0 = cbf;
+                list.add(new BootstrapComboFactory<A, B>() {
                     @Override
-                    public ServerBootstrap newServerInstance() {
+                    public A newServerInstance() {
                         return sbf0.newInstance();
                     }
 
                     @Override
-                    public Bootstrap newClientInstance() {
+                    public B newClientInstance() {
                         return cbf0.newInstance();
                     }
                 });
             }
         }
 
+        return list;
+    }
+
+    public List<BootstrapComboFactory<ServerBootstrap, Bootstrap>> socket() {
+        // Make the list of ServerBootstrap factories.
+        List<BootstrapFactory<ServerBootstrap>> sbfs = serverSocket();
+
+        // Make the list of Bootstrap factories.
+        List<BootstrapFactory<Bootstrap>> cbfs = clientSocket();
+
+        // Populate the combinations
+        List<BootstrapComboFactory<ServerBootstrap, Bootstrap>> list = combo(sbfs, cbfs);
+
         // Remove the OIO-OIO case which often leads to a dead lock by its nature.
         list.remove(list.size() - 1);
 
         return list;
     }
 
-    static List<BootstrapComboFactory<Bootstrap, Bootstrap>> datagram() {
-        List<BootstrapComboFactory<Bootstrap, Bootstrap>> list =
-                new ArrayList<BootstrapComboFactory<Bootstrap, Bootstrap>>();
-
+    public List<BootstrapComboFactory<Bootstrap, Bootstrap>> datagram() {
         // Make the list of Bootstrap factories.
-        List<BootstrapFactory<Bootstrap>> bfs =
-                new ArrayList<BootstrapFactory<Bootstrap>>();
-        bfs.add(new BootstrapFactory<Bootstrap>() {
-            @Override
-            public Bootstrap newInstance() {
-                return new Bootstrap().group(nioWorkerGroup).channelFactory(new ChannelFactory<Channel>() {
+        List<BootstrapFactory<Bootstrap>> bfs = Arrays.asList(
+                new BootstrapFactory<Bootstrap>() {
                     @Override
-                    public Channel newChannel() {
-                       return new NioDatagramChannel(InternetProtocolFamily.IPv4);
+                    public Bootstrap newInstance() {
+                        return new Bootstrap().group(nioWorkerGroup).channelFactory(new ChannelFactory<Channel>() {
+                            @Override
+                            public Channel newChannel() {
+                                return new NioDatagramChannel(InternetProtocolFamily.IPv4);
+                            }
+
+                            @Override
+                            public String toString() {
+                                return NioDatagramChannel.class.getSimpleName() + ".class";
+                            }
+                        });
                     }
-
+                },
+                new BootstrapFactory<Bootstrap>() {
                     @Override
-                    public String toString() {
-                        return NioDatagramChannel.class.getSimpleName() + ".class";
+                    public Bootstrap newInstance() {
+                        return new Bootstrap().group(oioWorkerGroup).channel(OioDatagramChannel.class);
                     }
-                });
-            }
-        });
-        bfs.add(new BootstrapFactory<Bootstrap>() {
-            @Override
-            public Bootstrap newInstance() {
-                return new Bootstrap().group(oioWorkerGroup).channel(OioDatagramChannel.class);
-            }
-        });
+                }
+        );
 
-        // Populate the combinations
-        for (BootstrapFactory<Bootstrap> sbf: bfs) {
-            for (BootstrapFactory<Bootstrap> cbf: bfs) {
-                final BootstrapFactory<Bootstrap> sbf0 = sbf;
-                final BootstrapFactory<Bootstrap> cbf0 = cbf;
-                list.add(new BootstrapComboFactory<Bootstrap, Bootstrap>() {
+        // Populare the combinations.
+        return combo(bfs, bfs);
+    }
+
+    public List<BootstrapFactory<ServerBootstrap>> serverSocket() {
+        return Arrays.asList(
+                new BootstrapFactory<ServerBootstrap>() {
                     @Override
-                    public Bootstrap newServerInstance() {
-                        return sbf0.newInstance();
+                    public ServerBootstrap newInstance() {
+                        return new ServerBootstrap().group(nioBossGroup, nioWorkerGroup)
+                                .channel(NioServerSocketChannel.class);
                     }
-
+                },
+                new BootstrapFactory<ServerBootstrap>() {
                     @Override
-                    public Bootstrap newClientInstance() {
-                        return cbf0.newInstance();
+                    public ServerBootstrap newInstance() {
+                        return new ServerBootstrap().group(oioBossGroup, oioWorkerGroup)
+                                .channel(OioServerSocketChannel.class)
+                                .option(ChannelOption.SO_TIMEOUT, OIO_SO_TIMEOUT);
                     }
-                });
-            }
-        }
-
-        return list;
-    }
-
-    static List<BootstrapFactory<ServerBootstrap>> serverSocket() {
-        List<BootstrapFactory<ServerBootstrap>> list = new ArrayList<BootstrapFactory<ServerBootstrap>>();
-
-        // Make the list of ServerBootstrap factories.
-        list.add(new BootstrapFactory<ServerBootstrap>() {
-            @Override
-            public ServerBootstrap newInstance() {
-                return new ServerBootstrap().group(nioBossGroup, nioWorkerGroup)
-                                            .channel(NioServerSocketChannel.class);
-            }
-        });
-        list.add(new BootstrapFactory<ServerBootstrap>() {
-            @Override
-            public ServerBootstrap newInstance() {
-                return new ServerBootstrap().group(oioBossGroup, oioWorkerGroup)
-                                            .channel(OioServerSocketChannel.class);
-            }
-        });
-
-        return list;
+                }
+        );
     }
 
-    static List<BootstrapFactory<Bootstrap>> clientSocket() {
-        List<BootstrapFactory<Bootstrap>> list = new ArrayList<BootstrapFactory<Bootstrap>>();
-        list.add(new BootstrapFactory<Bootstrap>() {
-            @Override
-            public Bootstrap newInstance() {
-                return new Bootstrap().group(nioWorkerGroup).channel(NioSocketChannel.class);
-            }
-        });
-        list.add(new BootstrapFactory<Bootstrap>() {
-            @Override
-            public Bootstrap newInstance() {
-                return new Bootstrap().group(oioWorkerGroup).channel(OioSocketChannel.class);
-            }
-        });
-        return list;
+    public List<BootstrapFactory<Bootstrap>> clientSocket() {
+        return Arrays.asList(
+                new BootstrapFactory<Bootstrap>() {
+                    @Override
+                    public Bootstrap newInstance() {
+                        return new Bootstrap().group(nioWorkerGroup).channel(NioSocketChannel.class);
+                    }
+                },
+                new BootstrapFactory<Bootstrap>() {
+                    @Override
+                    public Bootstrap newInstance() {
+                        return new Bootstrap().group(oioWorkerGroup).channel(OioSocketChannel.class)
+                                .option(ChannelOption.SO_TIMEOUT, OIO_SO_TIMEOUT);
+                    }
+                }
+        );
     }
-
 }
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java
index b902c91d7695..4ca1ac65be96 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java
@@ -43,7 +43,6 @@ public void testWriteBeforeConnect(Bootstrap cb) throws Throwable {
     }
 
     private static class TestHandler extends ChannelInboundHandlerAdapter {
-
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
             cause.printStackTrace();
diff --git a/testsuite/src/test/java/io/netty/testsuite/util/BogusKeyStore.java b/testsuite/src/test/java/io/netty/testsuite/util/BogusKeyStore.java
deleted file mode 100644
index c20bf56626af..000000000000
--- a/testsuite/src/test/java/io/netty/testsuite/util/BogusKeyStore.java
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.testsuite.util;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-
-/**
- * A bogus key store which provides all the required information to
- * create an example SSL connection.
- *
- * To generate a bogus key store:
- * <pre>
- * keytool  -genkey -alias bogus -keysize 2048 -validity 36500
- *          -keyalg RSA -dname "CN=bogus"
- *          -keypass secret -storepass secret
- *          -keystore cert.jks
- * </pre>
- */
-final class BogusKeyStore {
-    private static final short[] DATA = {
-        0xfe, 0xed, 0xfe, 0xed, 0x00, 0x00, 0x00, 0x02,
-        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
-        0x00, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c,
-        0x65, 0x00, 0x00, 0x01, 0x1a, 0x9f, 0x57, 0xa5,
-        0x27, 0x00, 0x00, 0x01, 0x9a, 0x30, 0x82, 0x01,
-        0x96, 0x30, 0x0e, 0x06, 0x0a, 0x2b, 0x06, 0x01,
-        0x04, 0x01, 0x2a, 0x02, 0x11, 0x01, 0x01, 0x05,
-        0x00, 0x04, 0x82, 0x01, 0x82, 0x48, 0x6d, 0xcf,
-        0x16, 0xb5, 0x50, 0x95, 0x36, 0xbf, 0x47, 0x27,
-        0x50, 0x58, 0x0d, 0xa2, 0x52, 0x7e, 0x25, 0xab,
-        0x14, 0x1a, 0x26, 0x5e, 0x2d, 0x8a, 0x23, 0x90,
-        0x60, 0x7f, 0x12, 0x20, 0x56, 0xd1, 0x43, 0xa2,
-        0x6b, 0x47, 0x5d, 0xed, 0x9d, 0xd4, 0xe5, 0x83,
-        0x28, 0x89, 0xc2, 0x16, 0x4c, 0x76, 0x06, 0xad,
-        0x8e, 0x8c, 0x29, 0x1a, 0x9b, 0x0f, 0xdd, 0x60,
-        0x4b, 0xb4, 0x62, 0x82, 0x9e, 0x4a, 0x63, 0x83,
-        0x2e, 0xd2, 0x43, 0x78, 0xc2, 0x32, 0x1f, 0x60,
-        0xa9, 0x8a, 0x7f, 0x0f, 0x7c, 0xa6, 0x1d, 0xe6,
-        0x92, 0x9e, 0x52, 0xc7, 0x7d, 0xbb, 0x35, 0x3b,
-        0xaa, 0x89, 0x73, 0x4c, 0xfb, 0x99, 0x54, 0x97,
-        0x99, 0x28, 0x6e, 0x66, 0x5b, 0xf7, 0x9b, 0x7e,
-        0x6d, 0x8a, 0x2f, 0xfa, 0xc3, 0x1e, 0x71, 0xb9,
-        0xbd, 0x8f, 0xc5, 0x63, 0x25, 0x31, 0x20, 0x02,
-        0xff, 0x02, 0xf0, 0xc9, 0x2c, 0xdd, 0x3a, 0x10,
-        0x30, 0xab, 0xe5, 0xad, 0x3d, 0x1a, 0x82, 0x77,
-        0x46, 0xed, 0x03, 0x38, 0xa4, 0x73, 0x6d, 0x36,
-        0x36, 0x33, 0x70, 0xb2, 0x63, 0x20, 0xca, 0x03,
-        0xbf, 0x5a, 0xf4, 0x7c, 0x35, 0xf0, 0x63, 0x1a,
-        0x12, 0x33, 0x12, 0x58, 0xd9, 0xa2, 0x63, 0x6b,
-        0x63, 0x82, 0x41, 0x65, 0x70, 0x37, 0x4b, 0x99,
-        0x04, 0x9f, 0xdd, 0x5e, 0x07, 0x01, 0x95, 0x9f,
-        0x36, 0xe8, 0xc3, 0x66, 0x2a, 0x21, 0x69, 0x68,
-        0x40, 0xe6, 0xbc, 0xbb, 0x85, 0x81, 0x21, 0x13,
-        0xe6, 0xa4, 0xcf, 0xd3, 0x67, 0xe3, 0xfd, 0x75,
-        0xf0, 0xdf, 0x83, 0xe0, 0xc5, 0x36, 0x09, 0xac,
-        0x1b, 0xd4, 0xf7, 0x2a, 0x23, 0x57, 0x1c, 0x5c,
-        0x0f, 0xf4, 0xcf, 0xa2, 0xcf, 0xf5, 0xbd, 0x9c,
-        0x69, 0x98, 0x78, 0x3a, 0x25, 0xe4, 0xfd, 0x85,
-        0x11, 0xcc, 0x7d, 0xef, 0xeb, 0x74, 0x60, 0xb1,
-        0xb7, 0xfb, 0x1f, 0x0e, 0x62, 0xff, 0xfe, 0x09,
-        0x0a, 0xc3, 0x80, 0x2f, 0x10, 0x49, 0x89, 0x78,
-        0xd2, 0x08, 0xfa, 0x89, 0x22, 0x45, 0x91, 0x21,
-        0xbc, 0x90, 0x3e, 0xad, 0xb3, 0x0a, 0xb4, 0x0e,
-        0x1c, 0xa1, 0x93, 0x92, 0xd8, 0x72, 0x07, 0x54,
-        0x60, 0xe7, 0x91, 0xfc, 0xd9, 0x3c, 0xe1, 0x6f,
-        0x08, 0xe4, 0x56, 0xf6, 0x0b, 0xb0, 0x3c, 0x39,
-        0x8a, 0x2d, 0x48, 0x44, 0x28, 0x13, 0xca, 0xe9,
-        0xf7, 0xa3, 0xb6, 0x8a, 0x5f, 0x31, 0xa9, 0x72,
-        0xf2, 0xde, 0x96, 0xf2, 0xb1, 0x53, 0xb1, 0x3e,
-        0x24, 0x57, 0xfd, 0x18, 0x45, 0x1f, 0xc5, 0x33,
-        0x1b, 0xa4, 0xe8, 0x21, 0xfa, 0x0e, 0xb2, 0xb9,
-        0xcb, 0xc7, 0x07, 0x41, 0xdd, 0x2f, 0xb6, 0x6a,
-        0x23, 0x18, 0xed, 0xc1, 0xef, 0xe2, 0x4b, 0xec,
-        0xc9, 0xba, 0xfb, 0x46, 0x43, 0x90, 0xd7, 0xb5,
-        0x68, 0x28, 0x31, 0x2b, 0x8d, 0xa8, 0x51, 0x63,
-        0xf7, 0x53, 0x99, 0x19, 0x68, 0x85, 0x66, 0x00,
-        0x00, 0x00, 0x01, 0x00, 0x05, 0x58, 0x2e, 0x35,
-        0x30, 0x39, 0x00, 0x00, 0x02, 0x3a, 0x30, 0x82,
-        0x02, 0x36, 0x30, 0x82, 0x01, 0xe0, 0xa0, 0x03,
-        0x02, 0x01, 0x02, 0x02, 0x04, 0x48, 0x59, 0xf1,
-        0x92, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
-        0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00,
-        0x30, 0x81, 0xa0, 0x31, 0x0b, 0x30, 0x09, 0x06,
-        0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4b, 0x52,
-        0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04,
-        0x08, 0x13, 0x0a, 0x4b, 0x79, 0x75, 0x6e, 0x67,
-        0x67, 0x69, 0x2d, 0x64, 0x6f, 0x31, 0x14, 0x30,
-        0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x0b,
-        0x53, 0x65, 0x6f, 0x6e, 0x67, 0x6e, 0x61, 0x6d,
-        0x2d, 0x73, 0x69, 0x31, 0x1a, 0x30, 0x18, 0x06,
-        0x03, 0x55, 0x04, 0x0a, 0x13, 0x11, 0x54, 0x68,
-        0x65, 0x20, 0x4e, 0x65, 0x74, 0x74, 0x79, 0x20,
-        0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x31,
-        0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x0b,
-        0x13, 0x0f, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c,
-        0x65, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72,
-        0x73, 0x31, 0x30, 0x30, 0x2e, 0x06, 0x03, 0x55,
-        0x04, 0x03, 0x13, 0x27, 0x73, 0x65, 0x63, 0x75,
-        0x72, 0x65, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x65,
-        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x6e,
-        0x65, 0x74, 0x74, 0x79, 0x2e, 0x67, 0x6c, 0x65,
-        0x61, 0x6d, 0x79, 0x6e, 0x6f, 0x64, 0x65, 0x2e,
-        0x6e, 0x65, 0x74, 0x30, 0x20, 0x17, 0x0d, 0x30,
-        0x38, 0x30, 0x36, 0x31, 0x39, 0x30, 0x35, 0x34,
-        0x31, 0x33, 0x38, 0x5a, 0x18, 0x0f, 0x32, 0x31,
-        0x38, 0x37, 0x31, 0x31, 0x32, 0x34, 0x30, 0x35,
-        0x34, 0x31, 0x33, 0x38, 0x5a, 0x30, 0x81, 0xa0,
-        0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
-        0x06, 0x13, 0x02, 0x4b, 0x52, 0x31, 0x13, 0x30,
-        0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a,
-        0x4b, 0x79, 0x75, 0x6e, 0x67, 0x67, 0x69, 0x2d,
-        0x64, 0x6f, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03,
-        0x55, 0x04, 0x07, 0x13, 0x0b, 0x53, 0x65, 0x6f,
-        0x6e, 0x67, 0x6e, 0x61, 0x6d, 0x2d, 0x73, 0x69,
-        0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04,
-        0x0a, 0x13, 0x11, 0x54, 0x68, 0x65, 0x20, 0x4e,
-        0x65, 0x74, 0x74, 0x79, 0x20, 0x50, 0x72, 0x6f,
-        0x6a, 0x65, 0x63, 0x74, 0x31, 0x18, 0x30, 0x16,
-        0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x0f, 0x45,
-        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x41,
-        0x75, 0x74, 0x68, 0x6f, 0x72, 0x73, 0x31, 0x30,
-        0x30, 0x2e, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
-        0x27, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x63,
-        0x68, 0x61, 0x74, 0x2e, 0x65, 0x78, 0x61, 0x6d,
-        0x70, 0x6c, 0x65, 0x2e, 0x6e, 0x65, 0x74, 0x74,
-        0x79, 0x2e, 0x67, 0x6c, 0x65, 0x61, 0x6d, 0x79,
-        0x6e, 0x6f, 0x64, 0x65, 0x2e, 0x6e, 0x65, 0x74,
-        0x30, 0x5c, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
-        0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,
-        0x00, 0x03, 0x4b, 0x00, 0x30, 0x48, 0x02, 0x41,
-        0x00, 0xc3, 0xe3, 0x5e, 0x41, 0xa7, 0x87, 0x11,
-        0x00, 0x42, 0x2a, 0xb0, 0x4b, 0xed, 0xb2, 0xe0,
-        0x23, 0xdb, 0xb1, 0x3d, 0x58, 0x97, 0x35, 0x60,
-        0x0b, 0x82, 0x59, 0xd3, 0x00, 0xea, 0xd4, 0x61,
-        0xb8, 0x79, 0x3f, 0xb6, 0x3c, 0x12, 0x05, 0x93,
-        0x2e, 0x9a, 0x59, 0x68, 0x14, 0x77, 0x3a, 0xc8,
-        0x50, 0x25, 0x57, 0xa4, 0x49, 0x18, 0x63, 0x41,
-        0xf0, 0x2d, 0x28, 0xec, 0x06, 0xfb, 0xb4, 0x9f,
-        0xbf, 0x02, 0x03, 0x01, 0x00, 0x01, 0x30, 0x0d,
-        0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
-        0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x41, 0x00,
-        0x65, 0x6c, 0x30, 0x01, 0xc2, 0x8e, 0x3e, 0xcb,
-        0xb3, 0x77, 0x48, 0xe9, 0x66, 0x61, 0x9a, 0x40,
-        0x86, 0xaf, 0xf6, 0x03, 0xeb, 0xba, 0x6a, 0xf2,
-        0xfd, 0xe2, 0xaf, 0x36, 0x5e, 0x7b, 0xaa, 0x22,
-        0x04, 0xdd, 0x2c, 0x20, 0xc4, 0xfc, 0xdd, 0xd0,
-        0x82, 0x20, 0x1c, 0x3d, 0xd7, 0x9e, 0x5e, 0x5c,
-        0x92, 0x5a, 0x76, 0x71, 0x28, 0xf5, 0x07, 0x7d,
-        0xa2, 0x81, 0xba, 0x77, 0x9f, 0x2a, 0xd9, 0x44,
-        0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x6d, 0x79,
-        0x6b, 0x65, 0x79, 0x00, 0x00, 0x01, 0x1a, 0x9f,
-        0x5b, 0x56, 0xa0, 0x00, 0x00, 0x01, 0x99, 0x30,
-        0x82, 0x01, 0x95, 0x30, 0x0e, 0x06, 0x0a, 0x2b,
-        0x06, 0x01, 0x04, 0x01, 0x2a, 0x02, 0x11, 0x01,
-        0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x81, 0x29,
-        0xa8, 0xb6, 0x08, 0x0c, 0x85, 0x75, 0x3e, 0xdd,
-        0xb5, 0xe5, 0x1a, 0x87, 0x68, 0xd1, 0x90, 0x4b,
-        0x29, 0x31, 0xee, 0x90, 0xbc, 0x9d, 0x73, 0xa0,
-        0x3f, 0xe9, 0x0b, 0xa4, 0xef, 0x30, 0x9b, 0x36,
-        0x9a, 0xb2, 0x54, 0x77, 0x81, 0x07, 0x4b, 0xaa,
-        0xa5, 0x77, 0x98, 0xe1, 0xeb, 0xb5, 0x7c, 0x4e,
-        0x48, 0xd5, 0x08, 0xfc, 0x2c, 0x36, 0xe2, 0x65,
-        0x03, 0xac, 0xe5, 0xf3, 0x96, 0xb7, 0xd0, 0xb5,
-        0x3b, 0x92, 0xe4, 0x14, 0x05, 0x7a, 0x6a, 0x92,
-        0x56, 0xfe, 0x4e, 0xab, 0xd3, 0x0e, 0x32, 0x04,
-        0x22, 0x22, 0x74, 0x47, 0x7d, 0xec, 0x21, 0x99,
-        0x30, 0x31, 0x64, 0x46, 0x64, 0x9b, 0xc7, 0x13,
-        0xbf, 0xbe, 0xd0, 0x31, 0x49, 0xe7, 0x3c, 0xbf,
-        0xba, 0xb1, 0x20, 0xf9, 0x42, 0xf4, 0xa9, 0xa9,
-        0xe5, 0x13, 0x65, 0x32, 0xbf, 0x7c, 0xcc, 0x91,
-        0xd3, 0xfd, 0x24, 0x47, 0x0b, 0xe5, 0x53, 0xad,
-        0x50, 0x30, 0x56, 0xd1, 0xfa, 0x9c, 0x37, 0xa8,
-        0xc1, 0xce, 0xf6, 0x0b, 0x18, 0xaa, 0x7c, 0xab,
-        0xbd, 0x1f, 0xdf, 0xe4, 0x80, 0xb8, 0xa7, 0xe0,
-        0xad, 0x7d, 0x50, 0x74, 0xf1, 0x98, 0x78, 0xbc,
-        0x58, 0xb9, 0xc2, 0x52, 0xbe, 0xd2, 0x5b, 0x81,
-        0x94, 0x83, 0x8f, 0xb9, 0x4c, 0xee, 0x01, 0x2b,
-        0x5e, 0xc9, 0x6e, 0x9b, 0xf5, 0x63, 0x69, 0xe4,
-        0xd8, 0x0b, 0x47, 0xd8, 0xfd, 0xd8, 0xe0, 0xed,
-        0xa8, 0x27, 0x03, 0x74, 0x1e, 0x5d, 0x32, 0xe6,
-        0x5c, 0x63, 0xc2, 0xfb, 0x3f, 0xee, 0xb4, 0x13,
-        0xc6, 0x0e, 0x6e, 0x74, 0xe0, 0x22, 0xac, 0xce,
-        0x79, 0xf9, 0x43, 0x68, 0xc1, 0x03, 0x74, 0x2b,
-        0xe1, 0x18, 0xf8, 0x7f, 0x76, 0x9a, 0xea, 0x82,
-        0x3f, 0xc2, 0xa6, 0xa7, 0x4c, 0xfe, 0xae, 0x29,
-        0x3b, 0xc1, 0x10, 0x7c, 0xd5, 0x77, 0x17, 0x79,
-        0x5f, 0xcb, 0xad, 0x1f, 0xd8, 0xa1, 0xfd, 0x90,
-        0xe1, 0x6b, 0xb2, 0xef, 0xb9, 0x41, 0x26, 0xa4,
-        0x0b, 0x4f, 0xc6, 0x83, 0x05, 0x6f, 0xf0, 0x64,
-        0x40, 0xe1, 0x44, 0xc4, 0xf9, 0x40, 0x2b, 0x3b,
-        0x40, 0xdb, 0xaf, 0x35, 0xa4, 0x9b, 0x9f, 0xc4,
-        0x74, 0x07, 0xe5, 0x18, 0x60, 0xc5, 0xfe, 0x15,
-        0x0e, 0x3a, 0x25, 0x2a, 0x11, 0xee, 0x78, 0x2f,
-        0xb8, 0xd1, 0x6e, 0x4e, 0x3c, 0x0a, 0xb5, 0xb9,
-        0x40, 0x86, 0x27, 0x6d, 0x8f, 0x53, 0xb7, 0x77,
-        0x36, 0xec, 0x5d, 0xed, 0x32, 0x40, 0x43, 0x82,
-        0xc3, 0x52, 0x58, 0xc4, 0x26, 0x39, 0xf3, 0xb3,
-        0xad, 0x58, 0xab, 0xb7, 0xf7, 0x8e, 0x0e, 0xba,
-        0x8e, 0x78, 0x9d, 0xbf, 0x58, 0x34, 0xbd, 0x77,
-        0x73, 0xa6, 0x50, 0x55, 0x00, 0x60, 0x26, 0xbf,
-        0x6d, 0xb4, 0x98, 0x8a, 0x18, 0x83, 0x89, 0xf8,
-        0xcd, 0x0d, 0x49, 0x06, 0xae, 0x51, 0x6e, 0xaf,
-        0xbd, 0xe2, 0x07, 0x13, 0xd8, 0x64, 0xcc, 0xbf,
-        0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x58, 0x2e,
-        0x35, 0x30, 0x39, 0x00, 0x00, 0x02, 0x34, 0x30,
-        0x82, 0x02, 0x30, 0x30, 0x82, 0x01, 0xda, 0xa0,
-        0x03, 0x02, 0x01, 0x02, 0x02, 0x04, 0x48, 0x59,
-        0xf2, 0x84, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
-        0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05,
-        0x00, 0x30, 0x81, 0x9d, 0x31, 0x0b, 0x30, 0x09,
-        0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x4b,
-        0x52, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55,
-        0x04, 0x08, 0x13, 0x0a, 0x4b, 0x79, 0x75, 0x6e,
-        0x67, 0x67, 0x69, 0x2d, 0x64, 0x6f, 0x31, 0x14,
-        0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13,
-        0x0b, 0x53, 0x65, 0x6f, 0x6e, 0x67, 0x6e, 0x61,
-        0x6d, 0x2d, 0x73, 0x69, 0x31, 0x1a, 0x30, 0x18,
-        0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x11, 0x54,
-        0x68, 0x65, 0x20, 0x4e, 0x65, 0x74, 0x74, 0x79,
-        0x20, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74,
-        0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04,
-        0x0b, 0x13, 0x0c, 0x43, 0x6f, 0x6e, 0x74, 0x72,
-        0x69, 0x62, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x31,
-        0x30, 0x30, 0x2e, 0x06, 0x03, 0x55, 0x04, 0x03,
-        0x13, 0x27, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65,
-        0x63, 0x68, 0x61, 0x74, 0x2e, 0x65, 0x78, 0x61,
-        0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x6e, 0x65, 0x74,
-        0x74, 0x79, 0x2e, 0x67, 0x6c, 0x65, 0x61, 0x6d,
-        0x79, 0x6e, 0x6f, 0x64, 0x65, 0x2e, 0x6e, 0x65,
-        0x74, 0x30, 0x20, 0x17, 0x0d, 0x30, 0x38, 0x30,
-        0x36, 0x31, 0x39, 0x30, 0x35, 0x34, 0x35, 0x34,
-        0x30, 0x5a, 0x18, 0x0f, 0x32, 0x31, 0x38, 0x37,
-        0x31, 0x31, 0x32, 0x33, 0x30, 0x35, 0x34, 0x35,
-        0x34, 0x30, 0x5a, 0x30, 0x81, 0x9d, 0x31, 0x0b,
-        0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
-        0x02, 0x4b, 0x52, 0x31, 0x13, 0x30, 0x11, 0x06,
-        0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x4b, 0x79,
-        0x75, 0x6e, 0x67, 0x67, 0x69, 0x2d, 0x64, 0x6f,
-        0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04,
-        0x07, 0x13, 0x0b, 0x53, 0x65, 0x6f, 0x6e, 0x67,
-        0x6e, 0x61, 0x6d, 0x2d, 0x73, 0x69, 0x31, 0x1a,
-        0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,
-        0x11, 0x54, 0x68, 0x65, 0x20, 0x4e, 0x65, 0x74,
-        0x74, 0x79, 0x20, 0x50, 0x72, 0x6f, 0x6a, 0x65,
-        0x63, 0x74, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03,
-        0x55, 0x04, 0x0b, 0x13, 0x0c, 0x43, 0x6f, 0x6e,
-        0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x6f, 0x72,
-        0x73, 0x31, 0x30, 0x30, 0x2e, 0x06, 0x03, 0x55,
-        0x04, 0x03, 0x13, 0x27, 0x73, 0x65, 0x63, 0x75,
-        0x72, 0x65, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x65,
-        0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x6e,
-        0x65, 0x74, 0x74, 0x79, 0x2e, 0x67, 0x6c, 0x65,
-        0x61, 0x6d, 0x79, 0x6e, 0x6f, 0x64, 0x65, 0x2e,
-        0x6e, 0x65, 0x74, 0x30, 0x5c, 0x30, 0x0d, 0x06,
-        0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
-        0x01, 0x01, 0x05, 0x00, 0x03, 0x4b, 0x00, 0x30,
-        0x48, 0x02, 0x41, 0x00, 0x95, 0xb3, 0x47, 0x17,
-        0x95, 0x0f, 0x57, 0xcf, 0x66, 0x72, 0x0a, 0x7e,
-        0x5b, 0x54, 0xea, 0x8c, 0x6f, 0x79, 0xde, 0x94,
-        0xac, 0x0b, 0x5a, 0xd4, 0xd6, 0x1b, 0x58, 0x12,
-        0x1a, 0x16, 0x3d, 0xfe, 0xdf, 0xa5, 0x2b, 0x86,
-        0xbc, 0x64, 0xd4, 0x80, 0x1e, 0x3f, 0xf9, 0xe2,
-        0x04, 0x03, 0x79, 0x9b, 0xc1, 0x5c, 0xf0, 0xf1,
-        0xf3, 0xf1, 0xe3, 0xbf, 0x3f, 0xc0, 0x1f, 0xdd,
-        0xdb, 0xc0, 0x5b, 0x21, 0x02, 0x03, 0x01, 0x00,
-        0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
-        0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00,
-        0x03, 0x41, 0x00, 0x02, 0xd7, 0xdd, 0xbd, 0x0c,
-        0x8e, 0x21, 0x20, 0xef, 0x9e, 0x4f, 0x1f, 0xf5,
-        0x49, 0xf1, 0xae, 0x58, 0x9b, 0x94, 0x3a, 0x1f,
-        0x70, 0x33, 0xf0, 0x9b, 0xbb, 0xe9, 0xc0, 0xf3,
-        0x72, 0xcb, 0xde, 0xb6, 0x56, 0x72, 0xcc, 0x1c,
-        0xf0, 0xd6, 0x5a, 0x2a, 0xbc, 0xa1, 0x7e, 0x23,
-        0x83, 0xe9, 0xe7, 0xcf, 0x9e, 0xa5, 0xf9, 0xcc,
-        0xc2, 0x61, 0xf4, 0xdb, 0x40, 0x93, 0x1d, 0x63,
-        0x8a, 0x50, 0x4c, 0x11, 0x39, 0xb1, 0x91, 0xc1,
-        0xe6, 0x9d, 0xd9, 0x1a, 0x62, 0x1b, 0xb8, 0xd3,
-        0xd6, 0x9a, 0x6d, 0xb9, 0x8e, 0x15, 0x51 };
-
-    public static InputStream asInputStream() {
-        byte[] data = new byte[DATA.length];
-        for (int i = 0; i < data.length; i ++) {
-            data[i] = (byte) DATA[i];
-        }
-        return new ByteArrayInputStream(data);
-    }
-
-    public static char[] getCertificatePassword() {
-        return "secret".toCharArray();
-    }
-
-    public static char[] getKeyStorePassword() {
-        return "secret".toCharArray();
-    }
-
-    private BogusKeyStore() { }
-}
diff --git a/testsuite/src/test/java/io/netty/testsuite/util/BogusSslContextFactory.java b/testsuite/src/test/java/io/netty/testsuite/util/BogusSslContextFactory.java
deleted file mode 100644
index c7bc6f1551b2..000000000000
--- a/testsuite/src/test/java/io/netty/testsuite/util/BogusSslContextFactory.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.testsuite.util;
-
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import java.security.KeyStore;
-import java.security.Security;
-
-public final class BogusSslContextFactory {
-
-    private static final String PROTOCOL = "TLS";
-    private static final SSLContext SERVER_CONTEXT;
-    private static final SSLContext CLIENT_CONTEXT;
-
-    static {
-        String algorithm = Security.getProperty("ssl.KeyManagerFactory.algorithm");
-        if (algorithm == null) {
-            algorithm = "SunX509";
-        }
-
-        SSLContext serverContext;
-        SSLContext clientContext;
-        try {
-            KeyStore ks = KeyStore.getInstance("JKS");
-            ks.load(BogusKeyStore.asInputStream(),
-                    BogusKeyStore.getKeyStorePassword());
-
-            // Set up key manager factory to use our key store
-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
-            kmf.init(ks, BogusKeyStore.getCertificatePassword());
-
-            // Initialize the SSLContext to work with our key managers.
-            serverContext = SSLContext.getInstance(PROTOCOL);
-            serverContext.init(kmf.getKeyManagers(), null, null);
-        } catch (Exception e) {
-            throw new Error(
-                    "Failed to initialize the server-side SSLContext", e);
-        }
-
-        try {
-            clientContext = SSLContext.getInstance(PROTOCOL);
-            clientContext.init(null, BogusTrustManagerFactory.getTrustManagers(), null);
-        } catch (Exception e) {
-            throw new Error(
-                    "Failed to initialize the client-side SSLContext", e);
-        }
-
-        SERVER_CONTEXT = serverContext;
-        CLIENT_CONTEXT = clientContext;
-    }
-
-    public static SSLContext getServerContext() {
-        return SERVER_CONTEXT;
-    }
-
-    public static SSLContext getClientContext() {
-        return CLIENT_CONTEXT;
-    }
-
-    private BogusSslContextFactory() { }
-}
diff --git a/testsuite/src/test/java/io/netty/testsuite/util/BogusTrustManagerFactory.java b/testsuite/src/test/java/io/netty/testsuite/util/BogusTrustManagerFactory.java
deleted file mode 100644
index 8d5629f11881..000000000000
--- a/testsuite/src/test/java/io/netty/testsuite/util/BogusTrustManagerFactory.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.testsuite.util;
-
-import javax.net.ssl.ManagerFactoryParameters;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactorySpi;
-import javax.net.ssl.X509TrustManager;
-import java.security.KeyStore;
-import java.security.cert.X509Certificate;
-
-/**
- * Bogus {@link TrustManagerFactorySpi} which accepts any certificate
- * even if it is invalid.
- */
-final class BogusTrustManagerFactory extends TrustManagerFactorySpi {
-
-    private static final TrustManager DUMMY_TRUST_MANAGER = new X509TrustManager() {
-        @Override
-        public X509Certificate[] getAcceptedIssuers() {
-            return new X509Certificate[0];
-        }
-
-        @Override
-        public void checkClientTrusted(X509Certificate[] chain, String authType) {
-            // NOOP
-        }
-
-        @Override
-        public void checkServerTrusted(X509Certificate[] chain, String authType) {
-            // NOOP
-        }
-    };
-
-    public static TrustManager[] getTrustManagers() {
-        return new TrustManager[] { DUMMY_TRUST_MANAGER };
-    }
-
-    @Override
-    protected TrustManager[] engineGetTrustManagers() {
-        return getTrustManagers();
-    }
-
-    @Override
-    protected void engineInit(KeyStore keystore) {
-        // Unused
-    }
-
-    @Override
-    protected void engineInit(ManagerFactoryParameters managerFactoryParameters) {
-        // Unused
-    }
-
-    private BogusTrustManagerFactory() { }
-}
diff --git a/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServer.java b/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServer.java
index a5b9125255b6..3a8624872200 100644
--- a/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServer.java
+++ b/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServer.java
@@ -36,20 +36,21 @@ public AutobahnServer(int port) {
     }
 
     public void run() throws Exception {
-        EventLoopGroup group = new NioEventLoopGroup();
+        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
+        EventLoopGroup workerGroup = new NioEventLoopGroup();
         try {
             ServerBootstrap b = new ServerBootstrap();
-            b.group(group)
+            b.group(bossGroup, workerGroup)
              .channel(NioServerSocketChannel.class)
              .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
-             .option(ChannelOption.SO_BACKLOG, 1024)
              .childHandler(new AutobahnServerInitializer());
 
             ChannelFuture f = b.bind(port).sync();
             System.out.println("Web Socket Server started at port " + port);
             f.channel().closeFuture().sync();
         } finally {
-            group.shutdownGracefully();
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
         }
     }
 
diff --git a/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerHandler.java b/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerHandler.java
index 8af797ecbb10..09dc4e994204 100644
--- a/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerHandler.java
+++ b/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerHandler.java
@@ -24,7 +24,6 @@
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.ContinuationWebSocketFrame;
@@ -35,7 +34,6 @@
 import io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;
 import io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;
 import io.netty.util.CharsetUtil;
-import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.StringUtil;
 
 import java.util.logging.Level;
@@ -61,7 +59,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         } else if (msg instanceof WebSocketFrame) {
             handleWebSocketFrame(ctx, (WebSocketFrame) msg);
         } else {
-            ReferenceCountUtil.release(msg);
+            throw new IllegalStateException("unknown message: " + msg);
         }
     }
 
@@ -73,14 +71,14 @@ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
     private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req)
             throws Exception {
         // Handle a bad request.
-        if (!req.getDecoderResult().isSuccess()) {
+        if (!req.decoderResult().isSuccess()) {
             sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
             req.release();
             return;
         }
 
         // Allow only GET methods.
-        if (req.getMethod() != GET) {
+        if (req.method() != GET) {
             sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
             req.release();
             return;
@@ -107,13 +105,11 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
         if (frame instanceof CloseWebSocketFrame) {
             handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame);
         } else if (frame instanceof PingWebSocketFrame) {
-            ctx.write(new PongWebSocketFrame(frame.isFinalFragment(), frame.rsv(), frame.content()), ctx.voidPromise());
-        } else if (frame instanceof TextWebSocketFrame) {
-            ctx.write(frame, ctx.voidPromise());
-        } else if (frame instanceof BinaryWebSocketFrame) {
-            ctx.write(frame, ctx.voidPromise());
-        } else if (frame instanceof ContinuationWebSocketFrame) {
-            ctx.write(frame, ctx.voidPromise());
+            ctx.write(new PongWebSocketFrame(frame.isFinalFragment(), frame.rsv(), frame.content()));
+        } else if (frame instanceof TextWebSocketFrame ||
+                frame instanceof BinaryWebSocketFrame ||
+                frame instanceof ContinuationWebSocketFrame) {
+            ctx.write(frame);
         } else if (frame instanceof PongWebSocketFrame) {
             frame.release();
             // Ignore
@@ -125,9 +121,9 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
 
     private static void sendHttpResponse(
             ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {
-        // Generate an error page if response getStatus code is not OK (200).
-        if (res.getStatus().code() != 200) {
-            ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8);
+        // Generate an error page if response status code is not OK (200).
+        if (res.status().code() != 200) {
+            ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8);
             res.content().writeBytes(buf);
             buf.release();
             setContentLength(res, res.content().readableBytes());
@@ -135,7 +131,7 @@ private static void sendHttpResponse(
 
         // Send the response and close the connection if necessary.
         ChannelFuture f = ctx.channel().writeAndFlush(res);
-        if (!isKeepAlive(req) || res.getStatus().code() != 200) {
+        if (!isKeepAlive(req) || res.status().code() != 200) {
             f.addListener(ChannelFutureListener.CLOSE);
         }
     }
@@ -146,6 +142,6 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     }
 
     private static String getWebSocketLocation(FullHttpRequest req) {
-        return "ws://" + req.headers().get(HttpHeaders.Names.HOST);
+        return "ws://" + req.headers().get(Names.HOST);
     }
 }
diff --git a/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerInitializer.java b/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerInitializer.java
index dd04b8769f8c..fef9c1c0d4ba 100644
--- a/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerInitializer.java
+++ b/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerInitializer.java
@@ -26,9 +26,9 @@ public class AutobahnServerInitializer extends ChannelInitializer<SocketChannel>
     @Override
     public void initChannel(SocketChannel ch) throws Exception {
         ChannelPipeline pipeline = ch.pipeline();
+        pipeline.addLast("encoder", new HttpResponseEncoder());
         pipeline.addLast("decoder", new HttpRequestDecoder());
         pipeline.addLast("aggregator", new HttpObjectAggregator(65536));
-        pipeline.addLast("encoder", new HttpResponseEncoder());
         pipeline.addLast("handler", new AutobahnServerHandler());
     }
 }
diff --git a/transport-native-epoll/README.md b/transport-native-epoll/README.md
new file mode 100644
index 000000000000..43f97ee93335
--- /dev/null
+++ b/transport-native-epoll/README.md
@@ -0,0 +1,3 @@
+# Native transport for Linux
+
+See [our wiki page](http://netty.io/wiki/native-transports.html).
diff --git a/transport-native-epoll/pom.xml b/transport-native-epoll/pom.xml
new file mode 100644
index 000000000000..cd7b4ed89730
--- /dev/null
+++ b/transport-native-epoll/pom.xml
@@ -0,0 +1,118 @@
+<?xml version="1.0" encoding="ISO-8859-15"?>
+<!--
+  ~ Copyright 2014 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>io.netty</groupId>
+    <artifactId>netty-parent</artifactId>
+    <version>4.1.0.Beta1</version>
+  </parent>
+  <artifactId>netty-transport-native-epoll</artifactId>
+
+  <name>Netty/Transport/Native/Epoll</name>
+  <packaging>jar</packaging>
+
+  <dependencies>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-common</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-buffer</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-transport</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-testsuite</artifactId>
+      <version>${project.version}</version>
+      <type>test-jar</type>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-tcnative</artifactId>
+      <classifier>${os.detected.classifier}</classifier>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.fusesource.hawtjni</groupId>
+        <artifactId>maven-hawtjni-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>build-native-lib</id>
+            <configuration>
+              <nativeSourceDirectory>${project.basedir}/src/main/c</nativeSourceDirectory>
+              <libDirectory>${project.build.outputDirectory}</libDirectory>
+              <!-- We use Maven's artifact classifier instead.
+                   This hack will make the hawtjni plugin to put the native library
+                   under 'META-INF/native' rather than 'META-INF/native/${platform}'. -->
+              <platform>.</platform>
+              <forceConfigure>true</forceConfigure>
+              <forceAutogen>true</forceAutogen>
+            </configuration>
+            <goals>
+              <goal>generate</goal>
+              <goal>build</goal>
+            </goals>
+            <phase>compile</phase>
+          </execution>
+        </executions>
+      </plugin>
+
+      <plugin>
+        <artifactId>maven-jar-plugin</artifactId>
+        <executions>
+          <!-- Generate the fallback JAR that does not contain the native library. -->
+          <execution>
+            <id>default-jar</id>
+            <configuration>
+              <excludes>
+                <exclude>META-INF/native/**</exclude>
+              </excludes>
+            </configuration>
+          </execution>
+          <!-- Generate the JAR that contains the native library in it. -->
+          <execution>
+            <id>native-jar</id>
+            <goals>
+              <goal>jar</goal>
+            </goals>
+            <configuration>
+              <classifier>${os.detected.classifier}</classifier>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
+
diff --git a/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c
new file mode 100644
index 000000000000..c61183c23a5b
--- /dev/null
+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c
@@ -0,0 +1,1221 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+#include <jni.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/epoll.h>
+#include <sys/eventfd.h>
+#include <sys/sendfile.h>
+#include <netinet/tcp.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <sys/utsname.h>
+#include "io_netty_channel_epoll_Native.h"
+
+
+// optional
+extern int accept4(int sockFd, struct sockaddr *addr, socklen_t *addrlen, int flags) __attribute__((weak));
+extern int epoll_create1(int flags) __attribute__((weak));
+
+// Those are initialized in the init(...) method and cached for performance reasons
+jmethodID updatePosId = NULL;
+jmethodID posId = NULL;
+jmethodID limitId = NULL;
+jfieldID posFieldId = NULL;
+jfieldID limitFieldId = NULL;
+jfieldID fileChannelFieldId = NULL;
+jfieldID transferedFieldId = NULL;
+jfieldID fdFieldId = NULL;
+jfieldID fileDescriptorFieldId = NULL;
+jfieldID readerIndexFieldId = NULL;
+jfieldID writerIndexFieldId = NULL;
+jfieldID memoryAddressFieldId = NULL;
+jmethodID inetSocketAddrMethodId = NULL;
+jmethodID datagramSocketAddrMethodId = NULL;
+jclass runtimeExceptionClass = NULL;
+jclass ioExceptionClass = NULL;
+jclass closedChannelExceptionClass = NULL;
+jmethodID closedChannelExceptionMethodId = NULL;
+jclass inetSocketAddressClass = NULL;
+jclass datagramSocketAddressClass = NULL;
+
+static int socketType;
+
+// util methods
+void throwRuntimeException(JNIEnv *env, char *message) {
+    (*env)->ThrowNew(env, runtimeExceptionClass, message);
+}
+
+void throwIOException(JNIEnv *env, char *message) {
+    (*env)->ThrowNew(env, ioExceptionClass, message);
+}
+
+void throwClosedChannelException(JNIEnv *env) {
+    jobject exception = (*env)->NewObject(env, closedChannelExceptionClass, closedChannelExceptionMethodId);
+    (*env)->Throw(env, exception);
+}
+
+void throwOutOfMemoryError( JNIEnv *env, char *message) {
+    jclass exceptionClass = (*env)->FindClass(env, "java/lang/OutOfMemoryError");
+    (*env)->ThrowNew(env, exceptionClass, message);
+}
+
+char *exceptionMessage(char *msg, int error) {
+    char *err = strerror(error);
+    char *result = malloc(strlen(msg) + strlen(err) + 1);
+    strcpy(result, msg);
+    strcat(result, err);
+    return result;
+}
+
+jint epollCtl(JNIEnv * env, jint efd, int op, jint fd, jint flags, jint id) {
+    uint32_t events = EPOLLET;
+
+    if (flags & EPOLL_ACCEPT) {
+        events |= EPOLLIN;
+    }
+    if (flags & EPOLL_READ) {
+        events |= EPOLLIN | EPOLLRDHUP;
+    }
+    if (flags & EPOLL_WRITE) {
+        events |= EPOLLOUT;
+    }
+
+    struct epoll_event ev = {
+        .events = events,
+        // encode the id into the events
+        .data.u64 = (((uint64_t) id) << 32L)
+    };
+
+    return epoll_ctl(efd, op, fd, &ev);
+}
+
+jint getOption(JNIEnv *env, jint fd, int level, int optname, const void *optval, socklen_t optlen) {
+    int code;
+    code = getsockopt(fd, level, optname, optval, &optlen);
+    if (code == 0) {
+        return 0;
+    }
+    int err = errno;
+    throwRuntimeException(env, exceptionMessage("Error during getsockopt(...): ", err));
+    return code;
+}
+
+int setOption(JNIEnv *env, jint fd, int level, int optname, const void *optval, socklen_t len) {
+    int rc = setsockopt(fd, level, optname, optval, len);
+    if (rc < 0) {
+        int err = errno;
+        throwRuntimeException(env, exceptionMessage("Error during setsockopt(...): ", err));
+    }
+    return rc;
+}
+
+jobject createInetSocketAddress(JNIEnv * env, struct sockaddr_storage addr) {
+    char ipstr[INET6_ADDRSTRLEN];
+    int port;
+    if (addr.ss_family == AF_INET) {
+        struct sockaddr_in *s = (struct sockaddr_in *)&addr;
+        port = ntohs(s->sin_port);
+        inet_ntop(AF_INET, &s->sin_addr, ipstr, sizeof ipstr);
+    } else {
+        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&addr;
+        port = ntohs(s->sin6_port);
+        inet_ntop(AF_INET6, &s->sin6_addr, ipstr, sizeof ipstr);
+    }
+    jstring ipString = (*env)->NewStringUTF(env, ipstr);
+    jobject socketAddr = (*env)->NewObject(env, inetSocketAddressClass, inetSocketAddrMethodId, ipString, port);
+    return socketAddr;
+}
+
+jobject createDatagramSocketAddress(JNIEnv * env, struct sockaddr_storage addr, int len) {
+    char ipstr[INET6_ADDRSTRLEN];
+    int port;
+    if (addr.ss_family == AF_INET) {
+        struct sockaddr_in *s = (struct sockaddr_in *)&addr;
+        port = ntohs(s->sin_port);
+        inet_ntop(AF_INET, &s->sin_addr, ipstr, sizeof ipstr);
+    } else {
+        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&addr;
+        port = ntohs(s->sin6_port);
+        inet_ntop(AF_INET6, &s->sin6_addr, ipstr, sizeof ipstr);
+    }
+    jstring ipString = (*env)->NewStringUTF(env, ipstr);
+    jobject socketAddr = (*env)->NewObject(env, datagramSocketAddressClass, datagramSocketAddrMethodId, ipString, port, len);
+    return socketAddr;
+}
+
+void init_sockaddr(JNIEnv * env, jbyteArray address, jint scopeId, jint jport, struct sockaddr_storage * addr) {
+    uint16_t port = htons((uint16_t) jport);
+    jbyte* addressBytes = (*env)->GetByteArrayElements(env, address, 0);
+    if (socketType == AF_INET6) {
+        struct sockaddr_in6* ip6addr = (struct sockaddr_in6 *) addr;
+        ip6addr->sin6_family = AF_INET6;
+        ip6addr->sin6_port = port;
+
+        if (scopeId != 0) {
+           ip6addr->sin6_scope_id = (uint32_t) scopeId;
+        }
+        memcpy( &(ip6addr->sin6_addr.s6_addr), addressBytes, 16);
+    } else {
+        struct sockaddr_in* ipaddr = (struct sockaddr_in *) addr;
+        ipaddr->sin_family = AF_INET;
+        ipaddr->sin_port = port;
+        memcpy( &(ipaddr->sin_addr.s_addr), addressBytes + 12, 4);
+    }
+
+    (*env)->ReleaseByteArrayElements(env, address, addressBytes, JNI_ABORT);
+}
+
+static int socket_type() {
+    int fd = socket(AF_INET6, SOCK_STREAM | SOCK_NONBLOCK, 0);
+    if (fd == -1) {
+        if (errno == EAFNOSUPPORT) {
+            return AF_INET;
+        }
+        return AF_INET6;
+    } else {
+        close(fd);
+        return AF_INET6;
+    }
+}
+
+void init_in_addr(JNIEnv * env, jbyteArray address, struct in_addr * addr) {
+    jbyte* addressBytes = (*env)->GetByteArrayElements(env, address, 0);
+    if (socketType == AF_INET6) {
+        memcpy(addr, addressBytes, 16);
+    } else {
+        memcpy(addr, addressBytes + 12, 4);
+    }
+    (*env)->ReleaseByteArrayElements(env, address, addressBytes, JNI_ABORT);
+}
+// util methods end
+
+jint JNI_OnLoad(JavaVM* vm, void* reserved) {
+    JNIEnv* env;
+    if ((*vm)->GetEnv(vm, (void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        return JNI_ERR;
+    } else {
+        // cache classes that are used within other jni methods for performance reasons
+        jclass localClosedChannelExceptionClass = (*env)->FindClass(env, "java/nio/channels/ClosedChannelException");
+        if (localClosedChannelExceptionClass == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        closedChannelExceptionClass = (jclass) (*env)->NewGlobalRef(env, localClosedChannelExceptionClass);
+        if (closedChannelExceptionClass == NULL) {
+            // out-of-memory!
+            throwOutOfMemoryError(env, "Error allocating memory");
+            return JNI_ERR;
+        }
+        closedChannelExceptionMethodId = (*env)->GetMethodID(env, closedChannelExceptionClass, "<init>", "()V");
+        if (closedChannelExceptionMethodId == NULL) {
+            throwRuntimeException(env, "Unable to obtain constructor of ClosedChannelException");
+            return JNI_ERR;
+        }
+        jclass localRuntimeExceptionClass = (*env)->FindClass(env, "java/lang/RuntimeException");
+        if (localRuntimeExceptionClass == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        runtimeExceptionClass = (jclass) (*env)->NewGlobalRef(env, localRuntimeExceptionClass);
+        if (runtimeExceptionClass == NULL) {
+            // out-of-memory!
+            throwOutOfMemoryError(env, "Error allocating memory");
+            return JNI_ERR;
+        }
+
+        jclass localIoExceptionClass = (*env)->FindClass(env, "java/io/IOException");
+        if (localIoExceptionClass == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        ioExceptionClass = (jclass) (*env)->NewGlobalRef(env, localIoExceptionClass);
+        if (ioExceptionClass == NULL) {
+            // out-of-memory!
+            throwOutOfMemoryError(env, "Error allocating memory");
+            return JNI_ERR;
+        }
+
+        jclass localInetSocketAddressClass = (*env)->FindClass(env, "java/net/InetSocketAddress");
+        if (localIoExceptionClass == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        inetSocketAddressClass = (jclass) (*env)->NewGlobalRef(env, localInetSocketAddressClass);
+        if (inetSocketAddressClass == NULL) {
+            // out-of-memory!
+            throwOutOfMemoryError(env, "Error allocating memory");
+            return JNI_ERR;
+        }
+
+        jclass localDatagramSocketAddressClass = (*env)->FindClass(env, "io/netty/channel/epoll/EpollDatagramChannel$DatagramSocketAddress");
+        if (localDatagramSocketAddressClass == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        datagramSocketAddressClass = (jclass) (*env)->NewGlobalRef(env, localDatagramSocketAddressClass);
+        if (datagramSocketAddressClass == NULL) {
+            // out-of-memory!
+            throwOutOfMemoryError(env, "Error allocating memory");
+            return JNI_ERR;
+        }
+
+        void *mem = malloc(1);
+        if (mem == NULL) {
+            throwOutOfMemoryError(env, "Error allocating native buffer");
+            return JNI_ERR;
+        }
+        jobject directBuffer = (*env)->NewDirectByteBuffer(env, mem, 1);
+        if (directBuffer == NULL) {
+            throwOutOfMemoryError(env, "Error allocating native buffer");
+            return JNI_ERR;
+        }
+
+        jclass cls = (*env)->GetObjectClass(env, directBuffer);
+
+        // Get the method id for Buffer.position() and Buffer.limit(). These are used as fallback if
+        // it is not possible to obtain the position and limit using the fields directly.
+        posId = (*env)->GetMethodID(env, cls, "position", "()I");
+        if (posId == NULL) {
+            // position method was not found.. something is wrong so bail out
+            throwRuntimeException(env, "Unable to find method ByteBuffer.position()");
+            return JNI_ERR;
+        }
+
+        limitId = (*env)->GetMethodID(env, cls, "limit", "()I");
+        if (limitId == NULL) {
+            // limit method was not found.. something is wrong so bail out
+            throwRuntimeException(env, "Unable to find method ByteBuffer.limit()");
+            return JNI_ERR;
+        }
+        updatePosId = (*env)->GetMethodID(env, cls, "position", "(I)Ljava/nio/Buffer;");
+        if (updatePosId == NULL) {
+            // position method was not found.. something is wrong so bail out
+            throwRuntimeException(env, "Unable to find method ByteBuffer.position(int)");
+            return JNI_ERR;
+        }
+        // Try to get the ids of the position and limit fields. We later then check if we was able
+        // to find them and if so use them get the position and limit of the buffer. This is
+        // much faster then call back into java via (*env)->CallIntMethod(...).
+        posFieldId = (*env)->GetFieldID(env, cls, "position", "I");
+        if (posFieldId == NULL) {
+            // this is ok as we can still use the method so just clear the exception
+            (*env)->ExceptionClear(env);
+        }
+        limitFieldId = (*env)->GetFieldID(env, cls, "limit", "I");
+        if (limitFieldId == NULL) {
+            // this is ok as we can still use the method so just clear the exception
+            (*env)->ExceptionClear(env);
+        }
+        jclass fileRegionCls = (*env)->FindClass(env, "io/netty/channel/DefaultFileRegion");
+        if (fileRegionCls == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        fileChannelFieldId = (*env)->GetFieldID(env, fileRegionCls, "file", "Ljava/nio/channels/FileChannel;");
+        if (fileChannelFieldId == NULL) {
+            throwRuntimeException(env, "Unable to obtain FileChannel field for DefaultFileRegion");
+            return JNI_ERR;
+        }
+        transferedFieldId = (*env)->GetFieldID(env, fileRegionCls, "transfered", "J");
+        if (transferedFieldId == NULL) {
+            throwRuntimeException(env, "Unable to obtain transfered field for DefaultFileRegion");
+            return JNI_ERR;
+        }
+
+        jclass fileChannelCls = (*env)->FindClass(env, "sun/nio/ch/FileChannelImpl");
+        if (fileChannelCls == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        fileDescriptorFieldId = (*env)->GetFieldID(env, fileChannelCls, "fd", "Ljava/io/FileDescriptor;");
+        if (fileDescriptorFieldId == NULL) {
+            throwRuntimeException(env, "Unable to obtain fd field for FileChannelImpl");
+            return JNI_ERR;
+        }
+
+        jclass fileDescriptorCls = (*env)->FindClass(env, "java/io/FileDescriptor");
+        if (fileDescriptorCls == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        fdFieldId = (*env)->GetFieldID(env, fileDescriptorCls, "fd", "I");
+        if (fdFieldId == NULL) {
+            throwRuntimeException(env, "Unable to obtain fd field for FileDescriptor");
+            return JNI_ERR;
+        }
+
+        inetSocketAddrMethodId = (*env)->GetMethodID(env, inetSocketAddressClass, "<init>", "(Ljava/lang/String;I)V");
+        if (inetSocketAddrMethodId == NULL) {
+            throwRuntimeException(env, "Unable to obtain constructor of InetSocketAddress");
+            return JNI_ERR;
+        }
+        socketType = socket_type();
+
+        datagramSocketAddrMethodId = (*env)->GetMethodID(env, datagramSocketAddressClass, "<init>", "(Ljava/lang/String;II)V");
+        if (datagramSocketAddrMethodId == NULL) {
+            throwRuntimeException(env, "Unable to obtain constructor of DatagramSocketAddress");
+            return JNI_ERR;
+        }
+
+        jclass addressEntryClass = (*env)->FindClass(env, "io/netty/channel/epoll/EpollChannelOutboundBuffer$AddressEntry");
+        if (addressEntryClass == NULL) {
+             // pending exception...
+            return JNI_ERR;
+        }
+        readerIndexFieldId = (*env)->GetFieldID(env, addressEntryClass, "readerIndex", "I");
+        if (readerIndexFieldId == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        writerIndexFieldId = (*env)->GetFieldID(env, addressEntryClass, "writerIndex", "I");
+        if (writerIndexFieldId == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        memoryAddressFieldId = (*env)->GetFieldID(env, addressEntryClass, "memoryAddress", "J");
+        if (memoryAddressFieldId == NULL) {
+            // pending exception...
+            return JNI_ERR;
+        }
+        return JNI_VERSION_1_6;
+    }
+}
+
+void JNI_OnUnload(JavaVM *vm, void *reserved) {
+    JNIEnv* env;
+    if ((*vm)->GetEnv(vm, (void **) &env, JNI_VERSION_1_6) != JNI_OK) {
+        // Something is wrong but nothing we can do about this :(
+        return;
+    } else {
+        // delete global references so the GC can collect them
+        if (runtimeExceptionClass != NULL) {
+            (*env)->DeleteGlobalRef(env, runtimeExceptionClass);
+        }
+        if (ioExceptionClass != NULL) {
+            (*env)->DeleteGlobalRef(env, ioExceptionClass);
+        }
+        if (closedChannelExceptionClass != NULL) {
+            (*env)->DeleteGlobalRef(env, closedChannelExceptionClass);
+        }
+        if (inetSocketAddressClass != NULL) {
+            (*env)->DeleteGlobalRef(env, inetSocketAddressClass);
+        }
+        if (datagramSocketAddressClass != NULL) {
+            (*env)->DeleteGlobalRef(env, datagramSocketAddressClass);
+        }
+    }
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_eventFd(JNIEnv * env, jclass clazz) {
+    jint eventFD =  eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+
+    if (eventFD < 0) {
+        int err = errno;
+        throwRuntimeException(env, exceptionMessage("Error creating eventFD(...): ", err));
+    }
+    return eventFD;
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_eventFdWrite(JNIEnv * env, jclass clazz, jint fd, jlong value) {
+    jint eventFD = eventfd_write(fd, (eventfd_t)value);
+
+    if (eventFD < 0) {
+        int err = errno;
+        throwRuntimeException(env, exceptionMessage("Error calling eventfd_write(...): ", err));
+    }
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_eventFdRead(JNIEnv * env, jclass clazz, jint fd) {
+    uint64_t eventfd_t;
+
+    if (eventfd_read(fd, &eventfd_t) != 0) {
+        // something is serious wrong
+        throwRuntimeException(env, "Error calling eventfd_read(...)");
+    }
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollCreate(JNIEnv * env, jclass clazz) {
+    jint efd;
+    if (epoll_create1) {
+        efd = epoll_create1(EPOLL_CLOEXEC);
+    } else {
+        // size will be ignored anyway but must be positive
+        efd = epoll_create(126);
+    }
+    if (efd < 0) {
+        int err = errno;
+        throwRuntimeException(env, exceptionMessage("Error during epoll_create(...): ", err));
+    }
+    if (!epoll_create1) {
+        if (fcntl(efd, F_SETFD, FD_CLOEXEC) < 0) {
+            int err = errno;
+            close(efd);
+            throwRuntimeException(env, exceptionMessage("Error during fcntl(...): ", err));
+            return err;
+        }
+    }
+    return efd;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollWait(JNIEnv * env, jclass clazz, jint efd, jlongArray events, jint timeout) {
+    int len = (*env)->GetArrayLength(env, events);
+    struct epoll_event ev[len];
+    int ready;
+    int err;
+    do {
+       ready = epoll_wait(efd, ev, len, timeout);
+       // was interrupted try again.
+    } while (ready == -1 && (( err = errno) == EINTR));
+
+    if (ready < 0) {
+         throwIOException(env, exceptionMessage("Error during epoll_wait(...): ", err));
+         return -1;
+    }
+    if (ready == 0) {
+        // nothing ready for process
+        return 0;
+    }
+
+    jboolean isCopy;
+    jlong *elements = (*env)->GetLongArrayElements(env, events, &isCopy);
+    if (elements == NULL) {
+        // No memory left ?!?!?
+        throwOutOfMemoryError(env, "Can't allocate memory");
+        return -1;
+    }
+    int i;
+    for (i = 0; i < ready; i++) {
+        // store the ready ops and id
+        elements[i] = (jlong) ev[i].data.u64;
+        if (ev[i].events & EPOLLIN) {
+            elements[i] |= EPOLL_READ;
+        }
+        if (ev[i].events & EPOLLRDHUP) {
+            elements[i] |= EPOLL_RDHUP;
+        }
+        if (ev[i].events & EPOLLOUT) {
+            elements[i] |= EPOLL_WRITE;
+        }
+    }
+    jint mode;
+    // release again to prevent memory leak
+    if (isCopy) {
+        mode = 0;
+    } else {
+        // was just pinned so use JNI_ABORT to eliminate not needed copy.
+        mode = JNI_ABORT;
+    }
+    (*env)->ReleaseLongArrayElements(env, events, elements, mode);
+
+    return ready;
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_epollCtlAdd(JNIEnv * env, jclass clazz, jint efd, jint fd, jint flags, jint id) {
+    if (epollCtl(env, efd, EPOLL_CTL_ADD, fd, flags, id) < 0) {
+        int err = errno;
+        throwRuntimeException(env, exceptionMessage("Error during calling epoll_ctl(...): ", err));
+    }
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_epollCtlMod(JNIEnv * env, jclass clazz, jint efd, jint fd, jint flags, jint id) {
+    if (epollCtl(env, efd, EPOLL_CTL_MOD, fd, flags, id) < 0) {
+        int err = errno;
+        throwRuntimeException(env, exceptionMessage("Error during calling epoll_ctl(...): ", err));
+    }
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_epollCtlDel(JNIEnv * env, jclass clazz, jint efd, jint fd) {
+    // Create an empty event to workaround a bug in older kernels which can not handle NULL.
+    struct epoll_event event = { 0 };
+    if (epoll_ctl(efd, EPOLL_CTL_DEL, fd, &event) < 0) {
+        int err = errno;
+        throwRuntimeException(env, exceptionMessage("Error during calling epoll_ctl(...): ", err));
+    }
+}
+
+jint write0(JNIEnv * env, jclass clazz, jint fd, void *buffer, jint pos, jint limit) {
+    ssize_t res;
+    int err;
+    do {
+       res = write(fd, buffer + pos, (size_t) (limit - pos));
+       // keep on writing if it was interrupted
+    } while(res == -1 && ((err = errno) == EINTR));
+
+    if (res < 0) {
+        // network stack saturated... try again later
+        if (err == EAGAIN || err == EWOULDBLOCK) {
+            return 0;
+        }
+        if (err == EBADF) {
+            throwClosedChannelException(env);
+            return -1;
+        }
+        throwIOException(env, exceptionMessage("Error while write(...): ", err));
+        return -1;
+    }
+    return (jint) res;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_write(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit) {
+    void *buffer = (*env)->GetDirectBufferAddress(env, jbuffer);
+    if (buffer == NULL) {
+        throwRuntimeException(env, "Unable to access address of buffer");
+        return -1;
+    }
+    jint res = write0(env, clazz, fd, buffer, pos, limit);
+    if (res > 0) {
+        // Increment the pos of the ByteBuffer as it may be only partial written to prevent data-corruption later once we
+        // try to write the remaining data.
+        // See https://github.com/netty/netty/issues/2371
+        incrementPosition(env, jbuffer, res);
+    }
+    return res;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_writeAddress(JNIEnv * env, jclass clazz, jint fd, jlong address, jint pos, jint limit) {
+    return write0(env, clazz, fd, (void *) address, pos, limit);
+}
+
+jint sendTo0(JNIEnv * env, jint fd, void* buffer, jint pos, jint limit ,jbyteArray address, jint scopeId, jint port) {
+    struct sockaddr_storage addr;
+    init_sockaddr(env, address, scopeId, port, &addr);
+
+    ssize_t res;
+    int err;
+    do {
+       res = sendto(fd, buffer + pos, (size_t) (limit - pos), 0, (struct sockaddr *)&addr, sizeof(struct sockaddr_storage));
+       // keep on writing if it was interrupted
+    } while(res == -1 && ((err = errno) == EINTR));
+
+    if (res < 0) {
+        // network stack saturated... try again later
+        if (err == EAGAIN || err == EWOULDBLOCK) {
+            return 0;
+        }
+        if (err == EBADF) {
+            throwClosedChannelException(env);
+            return -1;
+        }
+        throwIOException(env, exceptionMessage("Error while sendto(...): ", err));
+        return -1;
+    }
+    return (jint) res;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_sendTo(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit, jbyteArray address, jint scopeId, jint port) {
+    void *buffer = (*env)->GetDirectBufferAddress(env, jbuffer);
+    if (buffer == NULL) {
+        throwRuntimeException(env, "Unable to access address of buffer");
+        return -1;
+    }
+    return sendTo0(env, fd, buffer, pos, limit, address, scopeId, port);
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_sendToAddress(JNIEnv * env, jclass clazz, jint fd, jlong memoryAddress, jint pos, jint limit ,jbyteArray address, jint scopeId, jint port) {
+    return sendTo0(env, fd, (void*) memoryAddress, pos, limit, address, scopeId, port);
+}
+
+jobject recvFrom0(JNIEnv * env, jint fd, void* buffer, jint pos, jint limit) {
+    struct sockaddr_storage addr;
+    socklen_t addrlen = sizeof(addr);
+    ssize_t res;
+    int err;
+
+    do {
+        res = recvfrom(fd, buffer + pos, (size_t) (limit - pos), 0, (struct sockaddr *)&addr, &addrlen);
+        // Keep on reading if we was interrupted
+    } while (res == -1 && ((err = errno) == EINTR));
+
+    if (res < 0) {
+        if (err == EAGAIN || err == EWOULDBLOCK) {
+            // Nothing left to read
+            return NULL;
+        }
+        if (err == EBADF) {
+            throwClosedChannelException(env);
+            return NULL;
+        }
+        throwIOException(env, exceptionMessage("Error while recvFrom(...): ", err));
+        return NULL;
+    }
+
+    return createDatagramSocketAddress(env, addr, res);
+}
+
+JNIEXPORT jobject JNICALL Java_io_netty_channel_epoll_Native_recvFrom(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit) {
+    void *buffer = (*env)->GetDirectBufferAddress(env, jbuffer);
+    if (buffer == NULL) {
+        throwRuntimeException(env, "Unable to access address of buffer");
+        return NULL;
+    }
+
+    return recvFrom0(env, fd, buffer, pos, limit);
+}
+
+JNIEXPORT jobject JNICALL Java_io_netty_channel_epoll_Native_recvFromAddress(JNIEnv * env, jclass clazz, jint fd, jlong address, jint pos, jint limit) {
+    return recvFrom0(env, fd, (void*) address, pos, limit);
+}
+
+void incrementPosition(JNIEnv * env, jobject bufObj, int written) {
+    // Get the current position using the (*env)->GetIntField if possible and fallback
+    // to slower (*env)->CallIntMethod(...) if needed
+    if (posFieldId == NULL) {
+        jint pos = (*env)->CallIntMethod(env, bufObj, posId, NULL);
+        (*env)->CallObjectMethod(env, bufObj, updatePosId, pos + written);
+    } else {
+        jint pos = (*env)->GetIntField(env, bufObj, posFieldId);
+        (*env)->SetIntField(env, bufObj, posFieldId, pos + written);
+    }
+}
+
+jlong writev0(JNIEnv * env, jclass clazz, jint fd, struct iovec iov[], jint length) {
+    ssize_t res;
+    int err;
+    do {
+        res = writev(fd, iov, length);
+        // keep on writing if it was interrupted
+    } while(res == -1 && ((err = errno) == EINTR));
+
+    if (res < 0) {
+        if (err == EAGAIN || err == EWOULDBLOCK) {
+            // network stack is saturated we will try again later
+            return 0;
+        }
+        if (err == EBADF) {
+            throwClosedChannelException(env);
+            return -1;
+        }
+        throwIOException(env, exceptionMessage("Error while writev(...): ", err));
+        return -1;
+    }
+    return (jlong) res;
+}
+
+JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_writev(JNIEnv * env, jclass clazz, jint fd, jobjectArray buffers, jint offset, jint length) {
+    struct iovec iov[length];
+    int i;
+    int iovidx = 0;
+    for (i = offset; i < length; i++) {
+        jobject bufObj = (*env)->GetObjectArrayElement(env, buffers, i);
+        jint pos;
+        // Get the current position using the (*env)->GetIntField if possible and fallback
+        // to slower (*env)->CallIntMethod(...) if needed
+        if (posFieldId == NULL) {
+            pos = (*env)->CallIntMethod(env, bufObj, posId, NULL);
+        } else {
+            pos = (*env)->GetIntField(env, bufObj, posFieldId);
+        }
+        jint limit;
+        // Get the current limit using the (*env)->GetIntField if possible and fallback
+        // to slower (*env)->CallIntMethod(...) if needed
+        if (limitFieldId == NULL) {
+            limit = (*env)->CallIntMethod(env, bufObj, limitId, NULL);
+        } else {
+            limit = (*env)->GetIntField(env, bufObj, limitFieldId);
+        }
+        void *buffer = (*env)->GetDirectBufferAddress(env, bufObj);
+        if (buffer == NULL) {
+            throwRuntimeException(env, "Unable to access address of buffer");
+            return -1;
+        }
+        iov[iovidx].iov_base = buffer + pos;
+        iov[iovidx].iov_len = (size_t) (limit - pos);
+        iovidx++;
+
+        // Explicit delete local reference as otherwise the local references will only be released once the native method returns.
+        // Also there may be a lot of these and JNI specification only specify that 16 must be able to be created.
+        //
+        // See https://github.com/netty/netty/issues/2623
+        (*env)->DeleteLocalRef(env, bufObj);
+    }
+    jlong res = writev0(env, clazz, fd, iov, length);
+    if (res <= 0) {
+        return res;
+    }
+
+    // update the position of the written buffers
+    int written = res;
+    int a;
+    for (a = 0; a < length; a++) {
+        int len = iov[a].iov_len;
+        jobject bufObj = (*env)->GetObjectArrayElement(env, buffers, a + offset);
+        if (len >= written) {
+            incrementPosition(env, bufObj, written);
+            break;
+        } else {
+            incrementPosition(env, bufObj, len);
+            written -= len;
+        }
+        // Explicit delete local reference as otherwise the local references will only be released once the native method returns.
+        // Also there may be a lot of these and JNI specification only specify that 16 must be able to be created.
+        //
+        // See https://github.com/netty/netty/issues/2623
+        (*env)->DeleteLocalRef(env, bufObj);
+    }
+    return res;
+}
+
+JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_writevAddresses(JNIEnv * env, jclass clazz, jint fd, jobjectArray addresses, jint offset, jint length) {
+    struct iovec iov[length];
+    int i;
+    int iovidx = 0;
+    for (i = offset; i < length; i++) {
+        jobject addressEntry = (*env)->GetObjectArrayElement(env, addresses, i);
+        jint readerIndex = (*env)->GetIntField(env, addressEntry, readerIndexFieldId);
+        jint writerIndex = (*env)->GetIntField(env, addressEntry, writerIndexFieldId);
+        void* memoryAddress = (void*) (*env)->GetLongField(env, addressEntry, memoryAddressFieldId);
+
+        iov[iovidx].iov_base = memoryAddress + readerIndex;
+        iov[iovidx].iov_len = (size_t) (writerIndex - readerIndex);
+        iovidx++;
+
+        // Explicit delete local reference as otherwise the local references will only be released once the native method returns.
+        // Also there may be a lot of these and JNI specification only specify that 16 must be able to be created.
+        //
+        // See https://github.com/netty/netty/issues/2623
+        (*env)->DeleteLocalRef(env, addressEntry);
+    }
+
+    jlong res = writev0(env, clazz, fd, iov, length);
+    if (res <= 0) {
+        return res;
+    }
+}
+
+jint read0(JNIEnv * env, jclass clazz, jint fd, void *buffer, jint pos, jint limit) {
+    ssize_t res;
+    int err;
+    do {
+        res = read(fd, buffer + pos, (size_t) (limit - pos));
+        // Keep on reading if we was interrupted
+    } while (res == -1 && ((err = errno) == EINTR));
+
+    if (res < 0) {
+        if (err == EAGAIN || err == EWOULDBLOCK) {
+            // Nothing left to read
+            return 0;
+        }
+        if (err == EBADF) {
+            throwClosedChannelException(env);
+            return -1;
+        }
+        throwIOException(env, exceptionMessage("Error while read(...): ", err));
+        return -1;
+    }
+
+    if (res == 0) {
+        // end-of-stream
+        return -1;
+    }
+    return (jint) res;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_read(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit) {
+    void *buffer = (*env)->GetDirectBufferAddress(env, jbuffer);
+    if (buffer == NULL) {
+        throwRuntimeException(env, "Unable to access address of buffer");
+        return -1;
+    }
+    return read0(env, clazz, fd, buffer, pos, limit);
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_readAddress(JNIEnv * env, jclass clazz, jint fd, jlong address, jint pos, jint limit) {
+    return read0(env, clazz, fd, (void*) address, pos, limit);
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_close(JNIEnv * env, jclass clazz, jint fd) {
+   if (close(fd) < 0) {
+      throwIOException(env, "Error closing file descriptor");
+   }
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_shutdown(JNIEnv * env, jclass clazz, jint fd, jboolean read, jboolean write) {
+    int mode;
+    if (read && write) {
+        mode = SHUT_RDWR;
+    } else if (read) {
+        mode = SHUT_RD;
+    } else if (write) {
+        mode = SHUT_WR;
+    }
+    if (shutdown(fd, mode) < 0) {
+        throwIOException(env, "Error shutdown socket file descriptor");
+    }
+}
+
+jint socket0(JNIEnv * env, jclass clazz, int type) {
+    // TODO: Maybe also respect -Djava.net.preferIPv4Stack=true
+    int fd = socket(socketType, type | SOCK_NONBLOCK, 0);
+    if (fd == -1) {
+        int err = errno;
+        throwIOException(env, exceptionMessage("Error creating socket: ", err));
+        return -1;
+    } else if (socketType == AF_INET6){
+        // Allow to listen /connect ipv4 and ipv6
+        int optval = 0;
+        if (setOption(env, fd, IPPROTO_IPV6, IPV6_V6ONLY, &optval, sizeof(optval)) < 0) {
+            // Something went wrong so close the fd and return here. setOption(...) itself throws the exception already.
+            close(fd);
+            return -1;
+        }
+    }
+    return fd;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_socketDgram(JNIEnv * env, jclass clazz) {
+    return socket0(env, clazz, SOCK_DGRAM);
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_socketStream(JNIEnv * env, jclass clazz) {
+    return socket0(env, clazz, SOCK_STREAM);
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_bind(JNIEnv * env, jclass clazz, jint fd, jbyteArray address, jint scopeId, jint port) {
+    struct sockaddr_storage addr;
+    init_sockaddr(env, address, scopeId, port, &addr);
+
+    if(bind(fd, (struct sockaddr *) &addr, sizeof(addr)) == -1){
+        int err = errno;
+        throwIOException(env, exceptionMessage("Error during bind(...): ", err));
+    }
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_listen(JNIEnv * env, jclass clazz, jint fd, jint backlog) {
+    if(listen(fd, backlog) == -1) {
+        int err = errno;
+        throwIOException(env, exceptionMessage("Error during listen(...): ", err));
+    }
+}
+
+JNIEXPORT jboolean JNICALL Java_io_netty_channel_epoll_Native_connect(JNIEnv * env, jclass clazz, jint fd, jbyteArray address, jint scopeId, jint port) {
+    struct sockaddr_storage addr;
+    init_sockaddr(env, address, scopeId, port, &addr);
+
+    int res;
+    int err;
+    do {
+        res = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
+    } while (res == -1 && ((err = errno) == EINTR));
+
+    if (res < 0) {
+        if (err == EINPROGRESS) {
+            // connect not complete yet need to wait for EPOLLOUT event
+            return JNI_FALSE;
+        }
+        throwIOException(env, exceptionMessage("Unable to connect to remote host: ", err));
+
+        return JNI_FALSE;
+    }
+    return JNI_TRUE;
+}
+
+JNIEXPORT jboolean JNICALL Java_io_netty_channel_epoll_Native_finishConnect(JNIEnv * env, jclass clazz, jint fd) {
+    // connect may be done
+    // return true if connection finished successfully
+    // return false if connection is still in progress
+    // throw exception if connection failed
+    int optval;
+    int res = getOption(env, fd, SOL_SOCKET, SO_ERROR, &optval, sizeof(optval));
+    if (res != 0) {
+        // getOption failed
+        throwIOException(env, exceptionMessage("finishConnect getOption failed: ", res));
+        return JNI_FALSE;
+    } else if (optval == EINPROGRESS) {
+        // connect still in progress
+        return JNI_FALSE;
+    } else if (optval == 0) {
+        // connect succeeded
+        return JNI_TRUE;
+    } else {
+        // connect failed
+        throwIOException(env, exceptionMessage("Unable to connect to remote host: ", optval));
+        return JNI_FALSE;
+    }
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_accept(JNIEnv * env, jclass clazz, jint fd) {
+    jint socketFd;
+    int err;
+
+    do {
+        if (accept4) {
+            socketFd = accept4(fd, NULL, 0, SOCK_NONBLOCK | SOCK_CLOEXEC);
+        } else  {
+            socketFd = accept(fd, NULL, 0);
+        }
+    } while (socketFd == -1 && ((err = errno) == EINTR));
+
+    if (socketFd == -1) {
+        if (err == EAGAIN || err == EWOULDBLOCK) {
+            // Everything consumed so just return -1 here.
+            return -1;
+        } else {
+            throwIOException(env, exceptionMessage("Error during accept(...): ", err));
+            return -1;
+        }
+    }
+    if (accept4)  {
+        return socketFd;
+    } else  {
+        // accept4 was not present so need two more sys-calls ...
+        if (fcntl(socketFd, F_SETFD, FD_CLOEXEC) == -1) {
+            throwIOException(env, exceptionMessage("Error during accept(...): ", err));
+            return -1;
+        }
+        if (fcntl(socketFd, F_SETFL, O_NONBLOCK) == -1) {
+            throwIOException(env, exceptionMessage("Error during accept(...): ", err));
+            return -1;
+        }
+    }
+    return socketFd;
+}
+
+JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_sendfile(JNIEnv *env, jclass clazz, jint fd, jobject fileRegion, jlong off, jlong len) {
+    jobject fileChannel = (*env)->GetObjectField(env, fileRegion, fileChannelFieldId);
+    if (fileChannel == NULL) {
+        throwRuntimeException(env, "Unable to obtain FileChannel from FileRegion");
+        return -1;
+    }
+    jobject fileDescriptor = (*env)->GetObjectField(env, fileChannel, fileDescriptorFieldId);
+    if (fileDescriptor == NULL) {
+        throwRuntimeException(env, "Unable to obtain FileDescriptor from FileChannel");
+        return -1;
+    }
+    jint srcFd = (*env)->GetIntField(env, fileDescriptor, fdFieldId);
+    if (srcFd == -1) {
+        throwRuntimeException(env, "Unable to obtain the fd from the FileDescriptor");
+        return -1;
+    }
+    ssize_t res;
+    off_t offset = off;
+    int err;
+    do {
+      res = sendfile(fd, srcFd, &offset, (size_t) len);
+    } while (res == -1 && ((err = errno) == EINTR));
+    if (res < 0) {
+        if (err == EAGAIN) {
+            return 0;
+        }
+        throwIOException(env, exceptionMessage("Error during accept(...): ", err));
+        return -1;
+    }
+    if (res > 0) {
+        // update the transfered field in DefaultFileRegion
+        (*env)->SetLongField(env, fileRegion, transferedFieldId, off + res);
+    }
+
+    return res;
+}
+
+JNIEXPORT jobject JNICALL Java_io_netty_channel_epoll_Native_remoteAddress(JNIEnv * env, jclass clazz, jint fd) {
+    socklen_t len;
+    struct sockaddr_storage addr;
+
+    len = sizeof addr;
+    if (getpeername(fd, (struct sockaddr*)&addr, &len) == -1) {
+        return NULL;
+    }
+    return createInetSocketAddress(env, addr);
+}
+
+JNIEXPORT jobject JNICALL Java_io_netty_channel_epoll_Native_localAddress(JNIEnv * env, jclass clazz, jint fd) {
+    socklen_t len;
+    struct sockaddr_storage addr;
+
+    len = sizeof addr;
+    if (getsockname(fd, (struct sockaddr*)&addr, &len) == -1) {
+        return NULL;
+    }
+    return createInetSocketAddress(env, addr);
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setReuseAddress(JNIEnv * env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setReusePort(JNIEnv * env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTcpNoDelay(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setReceiveBufferSize(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_SOCKET, SO_RCVBUF, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setSendBufferSize(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_SOCKET, SO_SNDBUF, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setKeepAlive(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTcpCork(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_TCP, TCP_CORK, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setSoLinger(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, IPPROTO_IP, IP_TOS, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTrafficClass(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    struct linger solinger;
+    if (optval < 0) {
+        solinger.l_onoff = 0;
+        solinger.l_linger = 0;
+    } else {
+        solinger.l_onoff = 1;
+        solinger.l_linger = optval;
+    }
+    setOption(env, fd, SOL_SOCKET, SO_LINGER, &solinger, sizeof(solinger));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setBroadcast(JNIEnv * env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTcpKeepIdle(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_TCP, TCP_KEEPIDLE, &optval, sizeof(optval));
+}
+
+JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTcpKeepIntvl(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_TCP, TCP_KEEPINTVL, &optval, sizeof(optval));
+}
+
+JNIEXPORT void Java_io_netty_channel_epoll_Native_setTcpKeepCnt(JNIEnv *env, jclass clazz, jint fd, jint optval) {
+    setOption(env, fd, SOL_TCP, TCP_KEEPCNT, &optval, sizeof(optval));
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_isReuseAddresss(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_isReusePort(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_isTcpNoDelay(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getReceiveBufferSize(JNIEnv * env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, SOL_SOCKET, SO_RCVBUF, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getSendBufferSize(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, SOL_SOCKET, SO_SNDBUF, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_isTcpCork(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, SOL_TCP, TCP_CORK, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getSoLinger(JNIEnv *env, jclass clazz, jint fd) {
+    struct linger optval;
+    if (getOption(env, fd, SOL_SOCKET, SO_LINGER, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    if (optval.l_onoff == 0) {
+        return -1;
+    } else {
+        return optval.l_linger;
+    }
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getTrafficClass(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, IPPROTO_IP, IP_TOS, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_isBroadcast(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, SOL_SOCKET, SO_BROADCAST, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getTcpKeepIdle(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, SOL_TCP, TCP_KEEPIDLE, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getTcpKeepIntvl(JNIEnv *env, jclass clazz, jint fd) {
+    int optval;
+    if (getOption(env, fd, SOL_TCP, TCP_KEEPINTVL, &optval, sizeof(optval)) == -1) {
+        return -1;
+    }
+    return optval;
+}
+
+JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getTcpKeepCnt(JNIEnv *env, jclass clazz, jint fd) {
+     int optval;
+     if (getOption(env, fd, SOL_TCP, TCP_KEEPCNT, &optval, sizeof(optval)) == -1) {
+         return -1;
+     }
+     return optval;
+}
+
+JNIEXPORT jstring JNICALL Java_io_netty_channel_epoll_Native_kernelVersion(JNIEnv *env, jclass clazz) {
+    struct utsname name;
+
+    int res = uname(&name);
+    if (res == 0) {
+        return (*env)->NewStringUTF(env, name.release);
+    }
+    int err = errno;
+    throwRuntimeException(env, exceptionMessage("Error during uname(...): ", err));
+    return NULL;
+}
diff --git a/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h
new file mode 100644
index 000000000000..558b1c555178
--- /dev/null
+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+#include <jni.h>
+
+
+#define EPOLL_READ 0x01
+#define EPOLL_WRITE 0x02
+#define EPOLL_ACCEPT 0x04
+#define EPOLL_RDHUP 0x08
+
+// Define SO_REUSEPORT if not found to fix build issues.
+// See https://github.com/netty/netty/issues/2558
+#ifndef SO_REUSEPORT
+#define SO_REUSEPORT 15
+#endif /* SO_REUSEPORT */
+
+jint Java_io_netty_channel_epoll_Native_eventFd(JNIEnv * env, jclass clazz);
+void Java_io_netty_channel_epoll_Native_eventFdWrite(JNIEnv * env, jclass clazz, jint fd, jlong value);
+void Java_io_netty_channel_epoll_Native_eventFdRead(JNIEnv * env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_epollCreate(JNIEnv * env, jclass clazz);
+jint Java_io_netty_channel_epoll_Native_epollWait(JNIEnv * env, jclass clazz, jint efd, jlongArray events, jint timeout);
+void Java_io_netty_channel_epoll_Native_epollCtlAdd(JNIEnv * env, jclass clazz, jint efd, jint fd, jint flags, jint id);
+void Java_io_netty_channel_epoll_Native_epollCtlMod(JNIEnv * env, jclass clazz, jint efd, jint fd, jint flags, jint id);
+void  Java_io_netty_channel_epoll_Native_epollCtlDel(JNIEnv * env, jclass clazz, jint efd, jint fd);
+jint Java_io_netty_channel_epoll_Native_write(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit);
+jint Java_io_netty_channel_epoll_Native_writeAddress(JNIEnv * env, jclass clazz, jint fd, jlong address, jint pos, jint limit);
+jlong Java_io_netty_channel_epoll_Native_writev(JNIEnv * env, jclass clazz, jint fd, jobjectArray buffers, jint offset, jint length);
+jlong Java_io_netty_channel_epoll_Native_writevAddresses(JNIEnv * env, jclass clazz, jint fd, jobjectArray addresses, jint offset, jint length);
+jint Java_io_netty_channel_epoll_Native_sendTo(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit, jbyteArray address, jint scopeId, jint port);
+jint Java_io_netty_channel_epoll_Native_sendToAddress(JNIEnv * env, jclass clazz, jint fd, jlong memoryAddress, jint pos, jint limit, jbyteArray address, jint scopeId, jint port);
+
+jint Java_io_netty_channel_epoll_Native_read(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit);
+jint Java_io_netty_channel_epoll_Native_readAddress(JNIEnv * env, jclass clazz, jint fd, jlong address, jint pos, jint limit);
+jobject Java_io_netty_channel_epoll_Native_recvFrom(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit);
+jobject Java_io_netty_channel_epoll_Native_recvFromAddress(JNIEnv * env, jclass clazz, jint fd, jlong address, jint pos, jint limit);
+void JNICALL Java_io_netty_channel_epoll_Native_close(JNIEnv * env, jclass clazz, jint fd);
+void Java_io_netty_channel_epoll_Native_shutdown(JNIEnv * env, jclass clazz, jint fd, jboolean read, jboolean write);
+jint Java_io_netty_channel_epoll_Native_socketStream(JNIEnv * env, jclass clazz);
+jint Java_io_netty_channel_epoll_Native_socketDgram(JNIEnv * env, jclass clazz);
+
+void Java_io_netty_channel_epoll_Native_bind(JNIEnv * env, jclass clazz, jint fd, jbyteArray address, jint scopeId, jint port);
+void Java_io_netty_channel_epoll_Native_listen(JNIEnv * env, jclass clazz, jint fd, jint backlog);
+jboolean Java_io_netty_channel_epoll_Native_connect(JNIEnv * env, jclass clazz, jint fd, jbyteArray address, jint scopeId, jint port);
+jboolean Java_io_netty_channel_epoll_Native_finishConnect(JNIEnv * env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_accept(JNIEnv * env, jclass clazz, jint fd);
+jlong Java_io_netty_channel_epoll_Native_sendfile(JNIEnv *env, jclass clazz, jint fd, jobject fileRegion, jlong off, jlong len);
+jobject Java_io_netty_channel_epoll_Native_remoteAddress(JNIEnv * env, jclass clazz, jint fd);
+jobject Java_io_netty_channel_epoll_Native_localAddress(JNIEnv * env, jclass clazz, jint fd);
+void Java_io_netty_channel_epoll_Native_setReuseAddress(JNIEnv * env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setReusePort(JNIEnv * env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setTcpNoDelay(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setReceiveBufferSize(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setSendBufferSize(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setKeepAlive(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setTcpCork(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setSoLinger(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setTrafficClass(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setBroadcast(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setTcpKeepIdle(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setTcpKeepIntvl(JNIEnv *env, jclass clazz, jint fd, jint optval);
+void Java_io_netty_channel_epoll_Native_setTcpKeepCnt(JNIEnv *env, jclass clazz, jint fd, jint optval);
+
+jint Java_io_netty_channel_epoll_Native_isReuseAddresss(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_isReusePort(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_isTcpNoDelay(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_getReceiveBufferSize(JNIEnv * env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_getSendBufferSize(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_isTcpCork(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_getSoLinger(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_getTrafficClass(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_isBroadcast(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_getTcpKeepIdle(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_getTcpKeepIntvl(JNIEnv *env, jclass clazz, jint fd);
+jint Java_io_netty_channel_epoll_Native_getTcpKeepCnt(JNIEnv *env, jclass clazz, jint fd);
+
+jstring Java_io_netty_channel_epoll_Native_kernelVersion(JNIEnv *env, jclass clazz);
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
new file mode 100644
index 000000000000..35c8aecf0031
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.channel.AbstractChannel;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelMetadata;
+import io.netty.channel.EventLoop;
+import io.netty.util.internal.OneTimeTask;
+
+import java.net.InetSocketAddress;
+import java.nio.channels.UnresolvedAddressException;
+
+abstract class AbstractEpollChannel extends AbstractChannel {
+    private static final ChannelMetadata DATA = new ChannelMetadata(false);
+    private final int readFlag;
+    protected int flags;
+    protected volatile boolean active;
+    volatile int fd;
+    int id;
+
+    AbstractEpollChannel(int fd, int flag) {
+        this(null, fd, flag, false);
+    }
+
+    AbstractEpollChannel(Channel parent, int fd, int flag, boolean active) {
+        super(parent);
+        this.fd = fd;
+        readFlag = flag;
+        flags |= flag;
+        this.active = active;
+    }
+
+    @Override
+    public boolean isActive() {
+        return active;
+    }
+
+    @Override
+    public ChannelMetadata metadata() {
+        return DATA;
+    }
+
+    @Override
+    protected void doClose() throws Exception {
+        active = false;
+
+        // deregister from epoll now
+        doDeregister();
+
+        int fd = this.fd;
+        this.fd = -1;
+        Native.close(fd);
+    }
+
+    @Override
+    public InetSocketAddress remoteAddress() {
+        return (InetSocketAddress) super.remoteAddress();
+    }
+
+    @Override
+    public InetSocketAddress localAddress() {
+        return (InetSocketAddress) super.localAddress();
+    }
+
+    @Override
+    protected void doDisconnect() throws Exception {
+        doClose();
+    }
+
+    @Override
+    protected boolean isCompatible(EventLoop loop) {
+        return loop instanceof EpollEventLoop;
+    }
+
+    @Override
+    public boolean isOpen() {
+        return fd != -1;
+    }
+
+    @Override
+    protected void doDeregister() throws Exception {
+        ((EpollEventLoop) eventLoop()).remove(this);
+    }
+
+    @Override
+    protected void doBeginRead() throws Exception {
+        if ((flags & readFlag) == 0) {
+            flags |= readFlag;
+            modifyEvents();
+        }
+    }
+
+    final void clearEpollIn() {
+        // Only clear if registered with an EventLoop as otherwise
+        if (isRegistered()) {
+            final EventLoop loop = eventLoop();
+            final AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();
+            if (loop.inEventLoop()) {
+                unsafe.clearEpollIn0();
+            } else {
+                // schedule a task to clear the EPOLLIN as it is not safe to modify it directly
+                loop.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        if (!config().isAutoRead() && !unsafe.readPending) {
+                            // Still no read triggered so clear it now
+                            unsafe.clearEpollIn0();
+                        }
+                    }
+                });
+            }
+        } else  {
+            // The EventLoop is not registered atm so just update the flags so the correct value
+            // will be used once the channel is registered
+            flags &= ~readFlag;
+        }
+    }
+
+    protected final void setEpollOut() {
+        if ((flags & Native.EPOLLOUT) == 0) {
+            flags |= Native.EPOLLOUT;
+            modifyEvents();
+        }
+    }
+
+    protected final void clearEpollOut() {
+        if ((flags & Native.EPOLLOUT) != 0) {
+            flags &= ~Native.EPOLLOUT;
+            modifyEvents();
+        }
+    }
+
+    private void modifyEvents() {
+        if (isOpen()) {
+            ((EpollEventLoop) eventLoop()).modify(this);
+        }
+    }
+
+    @Override
+    protected void doRegister() throws Exception {
+        EpollEventLoop loop = (EpollEventLoop) eventLoop();
+        loop.add(this);
+    }
+
+    @Override
+    protected abstract AbstractEpollUnsafe newUnsafe();
+
+    protected static void checkResolvable(InetSocketAddress addr) {
+        if (addr.isUnresolved()) {
+            throw new UnresolvedAddressException();
+        }
+    }
+
+    protected abstract class AbstractEpollUnsafe extends AbstractUnsafe {
+        protected boolean readPending;
+
+        /**
+         * Called once EPOLLIN event is ready to be processed
+         */
+        abstract void epollInReady();
+
+        /**
+         * Called once EPOLLRDHUP event is ready to be processed
+         */
+        void epollRdHupReady() {
+            // NOOP
+        }
+
+        @Override
+        public void beginRead() {
+            // Channel.read() or ChannelHandlerContext.read() was called
+            readPending = true;
+            super.beginRead();
+        }
+
+        @Override
+        protected void flush0() {
+            // Flush immediately only when there's no pending flush.
+            // If there's a pending flush operation, event loop will call forceFlush() later,
+            // and thus there's no need to call it now.
+            if (isFlushPending()) {
+                return;
+            }
+            super.flush0();
+        }
+
+        /**
+         * Called once a EPOLLOUT event is ready to be processed
+         */
+        void epollOutReady() {
+            // directly call super.flush0() to force a flush now
+            super.flush0();
+        }
+
+        private boolean isFlushPending() {
+            return (flags & Native.EPOLLOUT) != 0;
+        }
+
+        protected final void clearEpollIn0() {
+            if ((flags & readFlag) != 0) {
+                flags &= ~readFlag;
+                modifyEvents();
+            }
+        }
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/Epoll.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Epoll.java
new file mode 100644
index 000000000000..dd10b74b918e
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Epoll.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+/**
+ * Tells if <a href="http://netty.io/wiki/native-transports.html">{@code netty-transport-native-epoll}</a> is supported.
+ */
+public final class Epoll {
+
+    private static final boolean IS_AVAILABLE;
+
+    static  {
+        boolean available;
+        int epollFd = -1;
+        int eventFd = -1;
+        try {
+            epollFd = Native.epollCreate();
+            eventFd = Native.eventFd();
+            available = true;
+        } catch (Throwable cause) {
+            // ignore
+            available = false;
+        } finally {
+            if (epollFd != -1) {
+                try {
+                    Native.close(epollFd);
+                } catch (Exception ignore) {
+                    // ignore
+                }
+            }
+            if (eventFd != -1) {
+                try {
+                    Native.close(eventFd);
+                } catch (Exception ignore) {
+                    // ignore
+                }
+            }
+        }
+        IS_AVAILABLE = available;
+    }
+
+    /**
+     * Returns {@code true} if and only if the
+     * <a href="http://netty.io/wiki/native-transports.html">{@code netty-transport-native-epoll}</a> can be used.
+     */
+    public static boolean isAvailable() {
+        return IS_AVAILABLE;
+    }
+
+    private Epoll() { }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java
new file mode 100644
index 000000000000..fbad95c7403e
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.channel.ChannelOption;
+
+public final class EpollChannelOption {
+    private static final Class<EpollChannelOption> T = EpollChannelOption.class;
+
+    public static final ChannelOption<Boolean> TCP_CORK = ChannelOption.valueOf(T, "TCP_CORK");
+    public static final ChannelOption<Boolean> SO_REUSEPORT = ChannelOption.valueOf(T, "SO_REUSEPORT");
+    public static final ChannelOption<Integer> TCP_KEEPIDLE = ChannelOption.valueOf(T, "TCP_KEEPIDLE");
+    public static final ChannelOption<Integer> TCP_KEEPINTVL = ChannelOption.valueOf(T, "TCP_KEEPINTVL");
+    public static final ChannelOption<Integer> TCP_KEEPCNT = ChannelOption.valueOf(T, "TCP_KEEPCNT");
+
+    private EpollChannelOption() { }
+
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOutboundBuffer.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOutboundBuffer.java
new file mode 100644
index 000000000000..f15ec3c38181
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOutboundBuffer.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.util.Recycler;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Special {@link ChannelOutboundBuffer} implementation which allows to obtain an array of {@link AddressEntry}
+ * and so doing gathering writes without the need to create a {@link ByteBuffer} internally. This reduce
+ * GC pressure a lot.
+ */
+final class EpollChannelOutboundBuffer extends ChannelOutboundBuffer {
+    private AddressEntry[] addresses;
+    private int addressCount;
+    private long addressSize;
+    private static final Recycler<EpollChannelOutboundBuffer> RECYCLER = new Recycler<EpollChannelOutboundBuffer>() {
+        @Override
+        protected EpollChannelOutboundBuffer newObject(Handle<EpollChannelOutboundBuffer> handle) {
+            return new EpollChannelOutboundBuffer(handle);
+        }
+    };
+
+    /**
+     * Get a new instance of this {@link EpollChannelOutboundBuffer} and attach it the given {@link EpollSocketChannel}
+     */
+    static EpollChannelOutboundBuffer newInstance(EpollSocketChannel channel) {
+        EpollChannelOutboundBuffer buffer = RECYCLER.get();
+        buffer.channel = channel;
+        return buffer;
+    }
+
+    private EpollChannelOutboundBuffer(Recycler.Handle<? extends ChannelOutboundBuffer> handle) {
+        super(handle);
+        addresses = new AddressEntry[INITIAL_CAPACITY];
+    }
+
+    /**
+     * Check if the message is a {@link ByteBuf} and if so if it has a memoryAddress. If not it will convert this
+     * {@link ByteBuf} to be able to operate on the memoryAddress directly for maximal performance.
+     */
+    @Override
+    protected Object beforeAdd(Object msg) {
+        if (msg instanceof ByteBuf) {
+            ByteBuf buf = (ByteBuf) msg;
+            if (!buf.hasMemoryAddress()) {
+                return copyToDirectByteBuf(buf);
+            }
+        }
+        return msg;
+    }
+
+    /**
+     * Returns an array of {@link AddressEntry}'s if the currently pending messages are made of {@link ByteBuf} only.
+     * {@code null} is returned otherwise.  If this method returns a non-null array, {@link #addressCount()} and
+     * {@link #addressSize()} ()} will return the number of {@link AddressEntry}'s in the returned array and the total
+     * number of readable bytes of the NIO buffers respectively.
+     * <p>
+     * Note that the returned array is reused and thus should not escape
+     * {@link io.netty.channel.AbstractChannel#doWrite(ChannelOutboundBuffer)}.
+     * Refer to {@link EpollSocketChannel#doWrite(ChannelOutboundBuffer)} for an example.
+     * </p>
+     */
+    AddressEntry[] memoryAddresses() {
+        long addressSize = 0;
+        int addressCount = 0;
+        final Entry[] buffer = entries();
+        final int mask = buffer.length - 1;
+        AddressEntry[] addresses = this.addresses;
+        Object m;
+        int unflushed = unflushed();
+        int flushed = flushed();
+        while (flushed != unflushed && (m = buffer[flushed].msg()) != null) {
+            if (!(m instanceof ByteBuf)) {
+                this.addressCount = 0;
+                this.addressSize = 0;
+                return null;
+            }
+
+            AddressEntry entry = (AddressEntry) buffer[flushed];
+
+            // Check if the entry was cancelled. if so we just skip it.
+            if (!entry.isCancelled()) {
+                ByteBuf buf = (ByteBuf) m;
+                final int readerIndex = buf.readerIndex();
+                final int readableBytes = buf.writerIndex() - readerIndex;
+
+                if (readableBytes > 0) {
+                    addressSize += readableBytes;
+                    // See if there is enough space to at least store one more entry.
+                    int neededSpace = addressCount + 1;
+                    if (neededSpace > addresses.length) {
+                        this.addresses = addresses =
+                                expandAddressesArray(addresses, neededSpace, addressCount);
+                    }
+                    entry.memoryAddress = buf.memoryAddress();
+                    entry.readerIndex = buf.readerIndex();
+                    entry.writerIndex = buf.writerIndex();
+
+                    addresses[addressCount ++] = entry;
+                }
+            }
+
+            flushed = flushed + 1 & mask;
+        }
+        this.addressCount = addressCount;
+        this.addressSize = addressSize;
+
+        return addresses;
+    }
+
+    private static AddressEntry[] expandAddressesArray(AddressEntry[] array, int neededSpace, int size) {
+        int newCapacity = array.length;
+        do {
+            // double capacity until it is big enough
+            // See https://github.com/netty/netty/issues/1890
+            newCapacity <<= 1;
+
+            if (newCapacity < 0) {
+                throw new IllegalStateException();
+            }
+
+        } while (neededSpace > newCapacity);
+
+        AddressEntry[] newArray = new AddressEntry[newCapacity];
+        System.arraycopy(array, 0, newArray, 0, size);
+
+        return newArray;
+    }
+
+    /**
+     * Return the number of {@link AddressEntry}'s which can be written.
+     */
+    int addressCount() {
+        return addressCount;
+    }
+
+    /**
+     * Return the number of bytes that can be written via gathering writes.
+     */
+    long addressSize() {
+        return addressSize;
+    }
+
+    @Override
+    public void recycle() {
+        if (addresses.length > INITIAL_CAPACITY) {
+            addresses = new AddressEntry[INITIAL_CAPACITY];
+        } else {
+            // null out the nio buffers array so the can be GC'ed
+            // https://github.com/netty/netty/issues/1763
+            Arrays.fill(addresses, null);
+        }
+        super.recycle();
+    }
+
+    @Override
+    protected AddressEntry newEntry() {
+        return new AddressEntry();
+    }
+
+    static final class AddressEntry extends Entry {
+        // These fields will be accessed via JNI directly so be carefully when touch them!
+        long memoryAddress;
+        int readerIndex;
+        int writerIndex;
+
+        @Override
+        public void clear() {
+            memoryAddress = -1;
+            readerIndex = 0;
+            writerIndex = 0;
+            super.clear();
+        }
+
+        @Override
+        public int cancel() {
+            memoryAddress = -1;
+            readerIndex = 0;
+            writerIndex = 0;
+            return super.cancel();
+        }
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
new file mode 100644
index 000000000000..b733ce4edb6a
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java
@@ -0,0 +1,447 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufHolder;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelMetadata;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.socket.DatagramChannel;
+import io.netty.channel.socket.DatagramChannelConfig;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.util.internal.StringUtil;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.NetworkInterface;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.nio.channels.NotYetConnectedException;
+
+/**
+ * {@link DatagramChannel} implementation that uses linux EPOLL Edge-Triggered Mode for
+ * maximal performance.
+ */
+public final class EpollDatagramChannel extends AbstractEpollChannel implements DatagramChannel {
+    private static final ChannelMetadata METADATA = new ChannelMetadata(true);
+
+    private volatile InetSocketAddress local;
+    private volatile InetSocketAddress remote;
+    private volatile boolean connected;
+    private final EpollDatagramChannelConfig config;
+
+    public EpollDatagramChannel() {
+        super(Native.socketDgramFd(), Native.EPOLLIN);
+        config = new EpollDatagramChannelConfig(this);
+    }
+
+    @Override
+    public ChannelMetadata metadata() {
+        return METADATA;
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public boolean isActive() {
+        return fd != -1 &&
+                (config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered()
+                        || active);
+    }
+
+    @Override
+    public boolean isConnected() {
+        return connected;
+    }
+
+    @Override
+    public ChannelFuture joinGroup(InetAddress multicastAddress) {
+        return joinGroup(multicastAddress, newPromise());
+    }
+
+    @Override
+    public ChannelFuture joinGroup(InetAddress multicastAddress, ChannelPromise promise) {
+        try {
+            return joinGroup(
+                    multicastAddress,
+                    NetworkInterface.getByInetAddress(localAddress().getAddress()),
+                    null, promise);
+        } catch (SocketException e) {
+            promise.setFailure(e);
+        }
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture joinGroup(
+            InetSocketAddress multicastAddress, NetworkInterface networkInterface) {
+        return joinGroup(multicastAddress, networkInterface, newPromise());
+    }
+
+    @Override
+    public ChannelFuture joinGroup(
+            InetSocketAddress multicastAddress, NetworkInterface networkInterface,
+            ChannelPromise promise) {
+        return joinGroup(multicastAddress.getAddress(), networkInterface, null, promise);
+    }
+
+    @Override
+    public ChannelFuture joinGroup(
+            InetAddress multicastAddress, NetworkInterface networkInterface, InetAddress source) {
+        return joinGroup(multicastAddress, networkInterface, source, newPromise());
+    }
+
+    @Override
+    public ChannelFuture joinGroup(
+            final InetAddress multicastAddress, final NetworkInterface networkInterface,
+            final InetAddress source, final ChannelPromise promise) {
+
+        if (multicastAddress == null) {
+            throw new NullPointerException("multicastAddress");
+        }
+
+        if (networkInterface == null) {
+            throw new NullPointerException("networkInterface");
+        }
+
+        promise.setFailure(new UnsupportedOperationException("Multicast not supported"));
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture leaveGroup(InetAddress multicastAddress) {
+        return leaveGroup(multicastAddress, newPromise());
+    }
+
+    @Override
+    public ChannelFuture leaveGroup(InetAddress multicastAddress, ChannelPromise promise) {
+        try {
+            return leaveGroup(
+                    multicastAddress, NetworkInterface.getByInetAddress(localAddress().getAddress()), null, promise);
+        } catch (SocketException e) {
+            promise.setFailure(e);
+        }
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture leaveGroup(
+            InetSocketAddress multicastAddress, NetworkInterface networkInterface) {
+        return leaveGroup(multicastAddress, networkInterface, newPromise());
+    }
+
+    @Override
+    public ChannelFuture leaveGroup(
+            InetSocketAddress multicastAddress,
+            NetworkInterface networkInterface, ChannelPromise promise) {
+        return leaveGroup(multicastAddress.getAddress(), networkInterface, null, promise);
+    }
+
+    @Override
+    public ChannelFuture leaveGroup(
+            InetAddress multicastAddress, NetworkInterface networkInterface, InetAddress source) {
+        return leaveGroup(multicastAddress, networkInterface, source, newPromise());
+    }
+
+    @Override
+    public ChannelFuture leaveGroup(
+            final InetAddress multicastAddress, final NetworkInterface networkInterface, final InetAddress source,
+            final ChannelPromise promise) {
+        if (multicastAddress == null) {
+            throw new NullPointerException("multicastAddress");
+        }
+        if (networkInterface == null) {
+            throw new NullPointerException("networkInterface");
+        }
+
+        promise.setFailure(new UnsupportedOperationException("Multicast not supported"));
+
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture block(
+            InetAddress multicastAddress, NetworkInterface networkInterface,
+            InetAddress sourceToBlock) {
+        return block(multicastAddress, networkInterface, sourceToBlock, newPromise());
+    }
+
+    @Override
+    public ChannelFuture block(
+            final InetAddress multicastAddress, final NetworkInterface networkInterface,
+            final InetAddress sourceToBlock, final ChannelPromise promise) {
+        if (multicastAddress == null) {
+            throw new NullPointerException("multicastAddress");
+        }
+        if (sourceToBlock == null) {
+            throw new NullPointerException("sourceToBlock");
+        }
+
+        if (networkInterface == null) {
+            throw new NullPointerException("networkInterface");
+        }
+        promise.setFailure(new UnsupportedOperationException("Multicast not supported"));
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture block(InetAddress multicastAddress, InetAddress sourceToBlock) {
+        return block(multicastAddress, sourceToBlock, newPromise());
+    }
+
+    @Override
+    public ChannelFuture block(
+            InetAddress multicastAddress, InetAddress sourceToBlock, ChannelPromise promise) {
+        try {
+            return block(
+                    multicastAddress,
+                    NetworkInterface.getByInetAddress(localAddress().getAddress()),
+                    sourceToBlock, promise);
+        } catch (Throwable e) {
+            promise.setFailure(e);
+        }
+        return promise;
+    }
+
+    @Override
+    protected AbstractEpollUnsafe newUnsafe() {
+        return new EpollDatagramChannelUnsafe();
+    }
+
+    @Override
+    protected InetSocketAddress localAddress0() {
+        return local;
+    }
+
+    @Override
+    protected InetSocketAddress remoteAddress0() {
+        return remote;
+    }
+
+    @Override
+    protected void doBind(SocketAddress localAddress) throws Exception {
+        InetSocketAddress addr = (InetSocketAddress) localAddress;
+        checkResolvable(addr);
+        Native.bind(fd, addr.getAddress(), addr.getPort());
+        local = Native.localAddress(fd);
+        active = true;
+    }
+
+    @Override
+    protected void doWrite(ChannelOutboundBuffer in) throws Exception {
+        for (;;) {
+            Object msg = in.current();
+            if (msg == null) {
+                // Wrote all messages.
+                clearEpollOut();
+                break;
+            }
+
+            boolean done = false;
+            for (int i = config().getWriteSpinCount() - 1; i >= 0; i--) {
+                if (doWriteMessage(msg)) {
+                    done = true;
+                    break;
+                }
+            }
+
+            if (done) {
+                in.remove();
+            } else {
+                // Did not write all messages.
+                setEpollOut();
+                break;
+            }
+        }
+    }
+
+    private boolean doWriteMessage(Object msg) throws IOException {
+        final Object m;
+        InetSocketAddress remoteAddress;
+        ByteBuf data;
+        if (msg instanceof DatagramPacket) {
+            DatagramPacket packet = (DatagramPacket) msg;
+            remoteAddress = packet.recipient();
+            m = packet.content();
+        } else {
+            m = msg;
+            remoteAddress = null;
+        }
+
+        if (m instanceof ByteBufHolder) {
+            data = ((ByteBufHolder) m).content();
+        } else if (m instanceof ByteBuf) {
+            data = (ByteBuf) m;
+        } else {
+            throw new UnsupportedOperationException("unsupported message type: " + StringUtil.simpleClassName(msg));
+        }
+
+        int dataLen = data.readableBytes();
+        if (dataLen == 0) {
+            return true;
+        }
+
+        if (remoteAddress == null) {
+            remoteAddress = remote;
+            if (remoteAddress == null) {
+                throw new NotYetConnectedException();
+            }
+        }
+
+        final int writtenBytes;
+        if (data.hasMemoryAddress()) {
+            long memoryAddress = data.memoryAddress();
+            writtenBytes = Native.sendToAddress(fd, memoryAddress, data.readerIndex(), data.writerIndex(),
+                    remoteAddress.getAddress(), remoteAddress.getPort());
+        } else  {
+            ByteBuffer nioData = data.internalNioBuffer(data.readerIndex(), data.readableBytes());
+            writtenBytes = Native.sendTo(fd, nioData, nioData.position(), nioData.limit(),
+                    remoteAddress.getAddress(), remoteAddress.getPort());
+        }
+        return writtenBytes > 0;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig config() {
+        return config;
+    }
+
+    @Override
+    protected ChannelOutboundBuffer newOutboundBuffer() {
+        return EpollDatagramChannelOutboundBuffer.newInstance(this);
+    }
+
+    @Override
+    protected void doDisconnect() throws Exception {
+        connected = false;
+    }
+
+    final class EpollDatagramChannelUnsafe extends AbstractEpollUnsafe {
+        private RecvByteBufAllocator.Handle allocHandle;
+
+        @Override
+        public void connect(SocketAddress remote, SocketAddress local, ChannelPromise channelPromise) {
+            boolean success = false;
+            try {
+                try {
+                    InetSocketAddress remoteAddress = (InetSocketAddress) remote;
+                    if (local != null) {
+                        InetSocketAddress localAddress = (InetSocketAddress) local;
+                        doBind(localAddress);
+                    }
+
+                    checkResolvable(remoteAddress);
+                    EpollDatagramChannel.this.remote = remoteAddress;
+                    EpollDatagramChannel.this.local = Native.localAddress(fd);
+                    success = true;
+                } finally {
+                    if (!success) {
+                        doClose();
+                    } else {
+                        channelPromise.setSuccess();
+                        connected = true;
+                    }
+                }
+            } catch (Throwable cause) {
+                channelPromise.setFailure(cause);
+            }
+        }
+
+        @Override
+        void epollInReady() {
+            DatagramChannelConfig config = config();
+            RecvByteBufAllocator.Handle allocHandle = this.allocHandle;
+            if (allocHandle == null) {
+                this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();
+            }
+
+            assert eventLoop().inEventLoop();
+            final ChannelPipeline pipeline = pipeline();
+            try {
+                for (;;) {
+                    ByteBuf data = null;
+                    try {
+                        data = allocHandle.allocate(config.getAllocator());
+                        int writerIndex = data.writerIndex();
+                        DatagramSocketAddress remoteAddress;
+                        if (data.hasMemoryAddress()) {
+                            // has a memory address so use optimized call
+                            remoteAddress = Native.recvFromAddress(
+                                    fd, data.memoryAddress(), writerIndex, data.capacity());
+                        } else {
+                            ByteBuffer nioData = data.internalNioBuffer(writerIndex, data.writableBytes());
+                            remoteAddress = Native.recvFrom(
+                                    fd, nioData, nioData.position(), nioData.limit());
+                        }
+
+                        if (remoteAddress == null) {
+                            break;
+                        }
+
+                        int readBytes = remoteAddress.receivedAmount;
+                        data.writerIndex(data.writerIndex() + readBytes);
+                        allocHandle.record(readBytes);
+                        readPending = false;
+                        pipeline.fireChannelRead(
+                                new DatagramPacket(data, (InetSocketAddress) localAddress(), remoteAddress));
+                        data = null;
+                    } catch (Throwable t) {
+                        // keep on reading as we use epoll ET and need to consume everything from the socket
+                        pipeline.fireChannelReadComplete();
+                        pipeline.fireExceptionCaught(t);
+                    } finally {
+                        if (data != null) {
+                            data.release();
+                        }
+                    }
+                }
+            } finally {
+                // Check if there is a readPending which was not processed yet.
+                // This could be for two reasons:
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
+                //
+                // See https://github.com/netty/netty/issues/2254
+                if (!config().isAutoRead() && !readPending) {
+                    clearEpollIn();
+                }
+            }
+        }
+    }
+
+    /**
+     * Act as special {@link InetSocketAddress} to be able to easily pass all needed data from JNI without the need
+     * to create more objects then needed.
+     */
+    static final class DatagramSocketAddress extends InetSocketAddress {
+
+        private static final long serialVersionUID = 1348596211215015739L;
+
+        // holds the amount of received bytes
+        final int receivedAmount;
+
+        DatagramSocketAddress(String addr, int port, int receivedAmount) {
+            super(addr, port);
+            this.receivedAmount = receivedAmount;
+        }
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java
new file mode 100644
index 000000000000..d1e73142ecc4
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java
@@ -0,0 +1,311 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.FixedRecvByteBufAllocator;
+import io.netty.channel.MessageSizeEstimator;
+import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.socket.DatagramChannelConfig;
+
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.util.Map;
+
+public final class EpollDatagramChannelConfig extends DefaultChannelConfig implements DatagramChannelConfig {
+    private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = new FixedRecvByteBufAllocator(2048);
+    private final EpollDatagramChannel datagramChannel;
+    private boolean activeOnOpen;
+
+    EpollDatagramChannelConfig(EpollDatagramChannel channel) {
+        super(channel);
+        datagramChannel = channel;
+        setRecvByteBufAllocator(DEFAULT_RCVBUF_ALLOCATOR);
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public Map<ChannelOption<?>, Object> getOptions() {
+        return getOptions(
+                super.getOptions(),
+                ChannelOption.SO_BROADCAST, ChannelOption.SO_RCVBUF, ChannelOption.SO_SNDBUF,
+                ChannelOption.SO_REUSEADDR, ChannelOption.IP_MULTICAST_LOOP_DISABLED,
+                ChannelOption.IP_MULTICAST_ADDR, ChannelOption.IP_MULTICAST_IF, ChannelOption.IP_MULTICAST_TTL,
+                ChannelOption.IP_TOS, ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION,
+                EpollChannelOption.SO_REUSEPORT);
+    }
+
+    @SuppressWarnings({ "unchecked", "deprecation" })
+    @Override
+    public <T> T getOption(ChannelOption<T> option) {
+        if (option == ChannelOption.SO_BROADCAST) {
+            return (T) Boolean.valueOf(isBroadcast());
+        }
+        if (option == ChannelOption.SO_RCVBUF) {
+            return (T) Integer.valueOf(getReceiveBufferSize());
+        }
+        if (option == ChannelOption.SO_SNDBUF) {
+            return (T) Integer.valueOf(getSendBufferSize());
+        }
+        if (option == ChannelOption.SO_REUSEADDR) {
+            return (T) Boolean.valueOf(isReuseAddress());
+        }
+        if (option == ChannelOption.IP_MULTICAST_LOOP_DISABLED) {
+            return (T) Boolean.valueOf(isLoopbackModeDisabled());
+        }
+        if (option == ChannelOption.IP_MULTICAST_ADDR) {
+            return (T) getInterface();
+        }
+        if (option == ChannelOption.IP_MULTICAST_IF) {
+            return (T) getNetworkInterface();
+        }
+        if (option == ChannelOption.IP_MULTICAST_TTL) {
+            return (T) Integer.valueOf(getTimeToLive());
+        }
+        if (option == ChannelOption.IP_TOS) {
+            return (T) Integer.valueOf(getTrafficClass());
+        }
+        if (option == ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) {
+            return (T) Boolean.valueOf(activeOnOpen);
+        }
+        if (option == EpollChannelOption.SO_REUSEPORT) {
+            return (T) Boolean.valueOf(isReusePort());
+        }
+        return super.getOption(option);
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public <T> boolean setOption(ChannelOption<T> option, T value) {
+        validate(option, value);
+
+        if (option == ChannelOption.SO_BROADCAST) {
+            setBroadcast((Boolean) value);
+        } else if (option == ChannelOption.SO_RCVBUF) {
+            setReceiveBufferSize((Integer) value);
+        } else if (option == ChannelOption.SO_SNDBUF) {
+            setSendBufferSize((Integer) value);
+        } else if (option == ChannelOption.SO_REUSEADDR) {
+            setReuseAddress((Boolean) value);
+        } else if (option == ChannelOption.IP_MULTICAST_LOOP_DISABLED) {
+            setLoopbackModeDisabled((Boolean) value);
+        } else if (option == ChannelOption.IP_MULTICAST_ADDR) {
+            setInterface((InetAddress) value);
+        } else if (option == ChannelOption.IP_MULTICAST_IF) {
+            setNetworkInterface((NetworkInterface) value);
+        } else if (option == ChannelOption.IP_MULTICAST_TTL) {
+            setTimeToLive((Integer) value);
+        } else if (option == ChannelOption.IP_TOS) {
+            setTrafficClass((Integer) value);
+        } else if (option == ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) {
+            setActiveOnOpen((Boolean) value);
+        } else if (option == EpollChannelOption.SO_REUSEPORT) {
+            setReusePort((Boolean) value);
+        } else {
+            return super.setOption(option, value);
+        }
+
+        return true;
+    }
+
+    private void setActiveOnOpen(boolean activeOnOpen) {
+        if (channel.isRegistered()) {
+            throw new IllegalStateException("Can only changed before channel was registered");
+        }
+        this.activeOnOpen = activeOnOpen;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator) {
+        super.setMessageSizeEstimator(estimator);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setAutoClose(boolean autoClose) {
+        super.setAutoClose(autoClose);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setAutoRead(boolean autoRead) {
+        super.setAutoRead(autoRead);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setWriteSpinCount(int writeSpinCount) {
+        super.setWriteSpinCount(writeSpinCount);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setAllocator(ByteBufAllocator allocator) {
+        super.setAllocator(allocator);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
+        super.setConnectTimeoutMillis(connectTimeoutMillis);
+        return this;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
+        super.setMaxMessagesPerRead(maxMessagesPerRead);
+        return this;
+    }
+
+    @Override
+    public int getSendBufferSize() {
+        return Native.getSendBufferSize(datagramChannel.fd);
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setSendBufferSize(int sendBufferSize) {
+        Native.setSendBufferSize(datagramChannel.fd, sendBufferSize);
+        return this;
+    }
+
+    @Override
+    public int getReceiveBufferSize() {
+        return Native.getReceiveBufferSize(datagramChannel.fd);
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setReceiveBufferSize(int receiveBufferSize) {
+        Native.setReceiveBufferSize(datagramChannel.fd, receiveBufferSize);
+        return this;
+    }
+
+    @Override
+    public int getTrafficClass() {
+        return Native.getTrafficClass(datagramChannel.fd);
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setTrafficClass(int trafficClass) {
+        Native.setTrafficClass(datagramChannel.fd, trafficClass);
+        return this;
+    }
+
+    @Override
+    public boolean isReuseAddress() {
+        return Native.isReuseAddress(datagramChannel.fd) == 1;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setReuseAddress(boolean reuseAddress) {
+        Native.setReuseAddress(datagramChannel.fd, reuseAddress ? 1 : 0);
+        return this;
+    }
+
+    @Override
+    public boolean isBroadcast() {
+        return Native.isBroadcast(datagramChannel.fd) == 1;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setBroadcast(boolean broadcast) {
+        Native.setBroadcast(datagramChannel.fd, broadcast ? 1 : 0);
+        return this;
+    }
+
+    @Override
+    public boolean isLoopbackModeDisabled() {
+        return false;
+    }
+
+    @Override
+    public DatagramChannelConfig setLoopbackModeDisabled(boolean loopbackModeDisabled) {
+        throw new UnsupportedOperationException("Multicast not supported");
+    }
+
+    @Override
+    public int getTimeToLive() {
+        return -1;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setTimeToLive(int ttl) {
+        throw new UnsupportedOperationException("Multicast not supported");
+    }
+
+    @Override
+    public InetAddress getInterface() {
+        return null;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setInterface(InetAddress interfaceAddress) {
+        throw new UnsupportedOperationException("Multicast not supported");
+    }
+
+    @Override
+    public NetworkInterface getNetworkInterface() {
+        return null;
+    }
+
+    @Override
+    public EpollDatagramChannelConfig setNetworkInterface(NetworkInterface networkInterface) {
+        throw new UnsupportedOperationException("Multicast not supported");
+    }
+
+    /**
+     * Returns {@code true} if the SO_REUSEPORT option is set.
+     */
+    public boolean isReusePort() {
+        return Native.isReusePort(datagramChannel.fd) == 1;
+    }
+
+    /**
+     * Set the SO_REUSEPORT option on the underlying Channel. This will allow to bind multiple
+     * {@link EpollSocketChannel}s to the same port and so accept connections with multiple threads.
+     *
+     * Be aware this method needs be called before {@link EpollDatagramChannel#bind(java.net.SocketAddress)} to have
+     * any affect.
+     */
+    public EpollDatagramChannelConfig setReusePort(boolean reusePort) {
+        Native.setReusePort(datagramChannel.fd, reusePort ? 1 : 0);
+        return this;
+    }
+
+    @Override
+    protected void autoReadCleared() {
+        datagramChannel.clearEpollIn();
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelOutboundBuffer.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelOutboundBuffer.java
new file mode 100644
index 000000000000..494ef41274f6
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelOutboundBuffer.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.util.Recycler;
+
+final class EpollDatagramChannelOutboundBuffer extends ChannelOutboundBuffer {
+    private static final Recycler<EpollDatagramChannelOutboundBuffer> RECYCLER =
+            new Recycler<EpollDatagramChannelOutboundBuffer>() {
+        @Override
+        protected EpollDatagramChannelOutboundBuffer newObject(Handle<EpollDatagramChannelOutboundBuffer> handle) {
+            return new EpollDatagramChannelOutboundBuffer(handle);
+        }
+    };
+
+    static EpollDatagramChannelOutboundBuffer newInstance(EpollDatagramChannel channel) {
+        EpollDatagramChannelOutboundBuffer buffer = RECYCLER.get();
+        buffer.channel = channel;
+        return buffer;
+    }
+
+    private EpollDatagramChannelOutboundBuffer(Recycler.Handle<EpollDatagramChannelOutboundBuffer> handle) {
+        super(handle);
+    }
+
+    @Override
+    protected Object beforeAdd(Object msg) {
+        if (msg instanceof DatagramPacket) {
+            DatagramPacket packet = (DatagramPacket) msg;
+            ByteBuf content = packet.content();
+            if (isCopyNeeded(content)) {
+                ByteBuf direct = copyToDirectByteBuf(content);
+                return new DatagramPacket(direct, packet.recipient(), packet.sender());
+            }
+        } else if (msg instanceof ByteBuf) {
+            ByteBuf buf = (ByteBuf) msg;
+            if (isCopyNeeded(buf)) {
+                msg = copyToDirectByteBuf((ByteBuf) msg);
+            }
+        }
+        return msg;
+    }
+
+    private static boolean isCopyNeeded(ByteBuf content) {
+        return !content.hasMemoryAddress() || content.nioBufferCount() != 1;
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
new file mode 100644
index 000000000000..62a64cee4401
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
@@ -0,0 +1,349 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.channel.EventLoop;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.SingleThreadEventLoop;
+import io.netty.channel.epoll.AbstractEpollChannel.AbstractEpollUnsafe;
+import io.netty.util.collection.IntObjectHashMap;
+import io.netty.util.collection.IntObjectMap;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Queue;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+/**
+ * {@link EventLoop} which uses epoll under the covers. Only works on Linux!
+ */
+final class EpollEventLoop extends SingleThreadEventLoop {
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(EpollEventLoop.class);
+    private static final AtomicIntegerFieldUpdater<EpollEventLoop> WAKEN_UP_UPDATER;
+
+    static {
+        AtomicIntegerFieldUpdater<EpollEventLoop> updater =
+                PlatformDependent.newAtomicIntegerFieldUpdater(EpollEventLoop.class, "wakenUp");
+        if (updater == null) {
+            updater = AtomicIntegerFieldUpdater.newUpdater(EpollEventLoop.class, "wakenUp");
+        }
+        WAKEN_UP_UPDATER = updater;
+    }
+
+    private final int epollFd;
+    private final int eventFd;
+    private final IntObjectMap<AbstractEpollChannel> ids = new IntObjectHashMap<AbstractEpollChannel>();
+    private final long[] events;
+
+    private int id;
+    private boolean overflown;
+
+    @SuppressWarnings("unused")
+    private volatile int wakenUp;
+    private volatile int ioRatio = 50;
+
+    EpollEventLoop(EventLoopGroup parent, Executor executor, int maxEvents) {
+        super(parent, executor, false);
+        events = new long[maxEvents];
+        boolean success = false;
+        int epollFd = -1;
+        int eventFd = -1;
+        try {
+            this.epollFd = epollFd = Native.epollCreate();
+            this.eventFd = eventFd = Native.eventFd();
+            Native.epollCtlAdd(epollFd, eventFd, Native.EPOLLIN, 0);
+            success = true;
+        } finally {
+            if (!success) {
+                if (epollFd != -1) {
+                    try {
+                        Native.close(epollFd);
+                    } catch (Exception e) {
+                        // ignore
+                    }
+                }
+                if (eventFd != -1) {
+                    try {
+                        Native.close(eventFd);
+                    } catch (Exception e) {
+                        // ignore
+                    }
+                }
+            }
+        }
+    }
+
+    private int nextId() {
+        int id = this.id;
+        if (id == Integer.MAX_VALUE) {
+            overflown = true;
+            id = 0;
+        }
+        if (overflown) {
+            // the ids had an overflow before so we need to make sure the id is not in use atm before assign
+            // it.
+            for (;;) {
+                if (!ids.containsKey(++id)) {
+                    this.id = id;
+                    break;
+                }
+            }
+        } else {
+            this.id = ++id;
+        }
+        return id;
+    }
+
+    @Override
+    protected void wakeup(boolean inEventLoop) {
+        if (!inEventLoop && WAKEN_UP_UPDATER.compareAndSet(this, 0, 1)) {
+            // write to the evfd which will then wake-up epoll_wait(...)
+            Native.eventFdWrite(eventFd, 1L);
+        }
+    }
+
+    /**
+     * Register the given epoll with this {@link io.netty.channel.EventLoop}.
+     */
+    void add(AbstractEpollChannel ch) {
+        assert inEventLoop();
+        int id = nextId();
+        Native.epollCtlAdd(epollFd, ch.fd, ch.flags, id);
+        ch.id = id;
+        ids.put(id, ch);
+    }
+
+    /**
+     * The flags of the given epoll was modified so update the registration
+     */
+    void modify(AbstractEpollChannel ch) {
+        assert inEventLoop();
+        Native.epollCtlMod(epollFd, ch.fd, ch.flags, ch.id);
+    }
+
+    /**
+     * Deregister the given epoll from this {@link io.netty.channel.EventLoop}.
+     */
+    void remove(AbstractEpollChannel ch) {
+        assert inEventLoop();
+        if (ids.remove(ch.id) != null && ch.isOpen()) {
+            // Remove the epoll. This is only needed if it's still open as otherwise it will be automatically
+            // removed once the file-descriptor is closed.
+            Native.epollCtlDel(epollFd, ch.fd);
+        }
+    }
+
+    @Override
+    protected Queue<Runnable> newTaskQueue() {
+        // This event loop never calls takeTask()
+        return PlatformDependent.newMpscQueue();
+    }
+
+    /**
+     * Returns the percentage of the desired amount of time spent for I/O in the event loop.
+     */
+    public int getIoRatio() {
+        return ioRatio;
+    }
+
+    /**
+     * Sets the percentage of the desired amount of time spent for I/O in the event loop.  The default value is
+     * {@code 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.
+     */
+    public void setIoRatio(int ioRatio) {
+        if (ioRatio <= 0 || ioRatio > 100) {
+            throw new IllegalArgumentException("ioRatio: " + ioRatio + " (expected: 0 < ioRatio <= 100)");
+        }
+        this.ioRatio = ioRatio;
+    }
+
+    private int epollWait(boolean oldWakenUp) {
+        int selectCnt = 0;
+        long currentTimeNanos = System.nanoTime();
+        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);
+        for (;;) {
+            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;
+            if (timeoutMillis <= 0) {
+                if (selectCnt == 0) {
+                    int ready = Native.epollWait(epollFd, events, 0);
+                    if (ready > 0) {
+                        return ready;
+                    }
+                }
+                break;
+            }
+
+            int selectedKeys = Native.epollWait(epollFd, events, (int) timeoutMillis);
+            selectCnt ++;
+
+            if (selectedKeys != 0 || oldWakenUp || wakenUp == 1 || hasTasks() || hasScheduledTasks()) {
+                // - Selected something,
+                // - waken up by user, or
+                // - the task queue has a pending task.
+                // - a scheduled task is ready for processing
+                return selectedKeys;
+            }
+            currentTimeNanos = System.nanoTime();
+        }
+        return 0;
+    }
+
+    @Override
+    protected void run() {
+        for (;;) {
+            boolean oldWakenUp = WAKEN_UP_UPDATER.getAndSet(this, 0) == 1;
+            try {
+                int ready;
+                if (hasTasks()) {
+                    // Non blocking just return what is ready directly without block
+                    ready = Native.epollWait(epollFd, events, 0);
+                } else {
+                    ready = epollWait(oldWakenUp);
+
+                    // 'wakenUp.compareAndSet(false, true)' is always evaluated
+                    // before calling 'selector.wakeup()' to reduce the wake-up
+                    // overhead. (Selector.wakeup() is an expensive operation.)
+                    //
+                    // However, there is a race condition in this approach.
+                    // The race condition is triggered when 'wakenUp' is set to
+                    // true too early.
+                    //
+                    // 'wakenUp' is set to true too early if:
+                    // 1) Selector is waken up between 'wakenUp.set(false)' and
+                    //    'selector.select(...)'. (BAD)
+                    // 2) Selector is waken up between 'selector.select(...)' and
+                    //    'if (wakenUp.get()) { ... }'. (OK)
+                    //
+                    // In the first case, 'wakenUp' is set to true and the
+                    // following 'selector.select(...)' will wake up immediately.
+                    // Until 'wakenUp' is set to false again in the next round,
+                    // 'wakenUp.compareAndSet(false, true)' will fail, and therefore
+                    // any attempt to wake up the Selector will fail, too, causing
+                    // the following 'selector.select(...)' call to block
+                    // unnecessarily.
+                    //
+                    // To fix this problem, we wake up the selector again if wakenUp
+                    // is true immediately after selector.select(...).
+                    // It is inefficient in that it wakes up the selector for both
+                    // the first case (BAD - wake-up required) and the second case
+                    // (OK - no wake-up required).
+
+                    if (wakenUp == 1) {
+                        Native.eventFdWrite(eventFd, 1L);
+                    }
+                }
+
+                final int ioRatio = this.ioRatio;
+                if (ioRatio == 100) {
+                    if (ready > 0) {
+                        processReady(events, ready);
+                    }
+                    runAllTasks();
+                } else {
+                    final long ioStartTime = System.nanoTime();
+
+                    if (ready > 0) {
+                        processReady(events, ready);
+                    }
+
+                    final long ioTime = System.nanoTime() - ioStartTime;
+                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
+                }
+
+                if (isShuttingDown()) {
+                    closeAll();
+                    if (confirmShutdown()) {
+                        break;
+                    }
+                }
+            } catch (Throwable t) {
+                logger.warn("Unexpected exception in the selector loop.", t);
+
+                // Prevent possible consecutive immediate failures that lead to
+                // excessive CPU consumption.
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {
+                    // Ignore.
+                }
+            }
+        }
+    }
+
+    private void closeAll() {
+        Native.epollWait(epollFd, events, 0);
+        Collection<AbstractEpollChannel> channels = new ArrayList<AbstractEpollChannel>(ids.size());
+
+        for (IntObjectMap.Entry<AbstractEpollChannel> entry: ids.entries()) {
+            channels.add(entry.value());
+        }
+
+        for (AbstractEpollChannel ch: channels) {
+            ch.unsafe().close(ch.unsafe().voidPromise());
+        }
+    }
+
+    private void processReady(long[] events, int ready) {
+        for (int i = 0; i < ready; i ++) {
+            final long ev = events[i];
+
+            int id = (int) (ev >> 32L);
+            if (id == 0) {
+                // consume wakeup event
+                Native.eventFdRead(eventFd);
+            } else {
+                boolean read = (ev & Native.EPOLLIN) != 0;
+                boolean write = (ev & Native.EPOLLOUT) != 0;
+                boolean close = (ev & Native.EPOLLRDHUP) != 0;
+
+                AbstractEpollChannel ch = ids.get(id);
+                if (ch != null) {
+                    AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) ch.unsafe();
+                    if (write && ch.isOpen()) {
+                        // force flush of data as the epoll is writable again
+                        unsafe.epollOutReady();
+                    }
+                    if (read && ch.isOpen()) {
+                        // Something is ready to read, so consume it now
+                        unsafe.epollInReady();
+                    }
+                    if (close && ch.isOpen()) {
+                        unsafe.epollRdHupReady();
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void cleanup() {
+        try {
+            Native.close(epollFd);
+        } catch (IOException e) {
+            logger.warn("Failed to close the epoll fd.", e);
+        }
+        try {
+            Native.close(eventFd);
+        } catch (IOException e) {
+            logger.warn("Failed to close the event fd.", e);
+        }
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java
new file mode 100644
index 000000000000..101312c611b7
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.channel.EventLoop;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.MultithreadEventLoopGroup;
+import io.netty.util.concurrent.EventExecutor;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * {@link EventLoopGroup} which uses epoll under the covers. Because of this
+ * it only works on linux.
+ */
+public final class EpollEventLoopGroup extends MultithreadEventLoopGroup {
+
+    /**
+     * Create a new instance using the default number of threads and the default {@link ThreadFactory}.
+     */
+    public EpollEventLoopGroup() {
+        this(0);
+    }
+
+    /**
+     * Create a new instance using the specified number of threads and the default {@link ThreadFactory}.
+     */
+    public EpollEventLoopGroup(int nThreads) {
+        this(nThreads, null);
+    }
+
+    /**
+     * Create a new instance using the specified number of threads and the given {@link ThreadFactory}.
+     */
+    public EpollEventLoopGroup(int nThreads, ThreadFactory threadFactory) {
+        this(nThreads, threadFactory, 128);
+    }
+
+    /**
+     * Create a new instance using the specified number of threads, the given {@link ThreadFactory} and the given
+     * maximal amount of epoll events to handle per epollWait(...).
+     */
+    public EpollEventLoopGroup(int nThreads, ThreadFactory threadFactory, int maxEventsAtOnce) {
+        super(nThreads, threadFactory, maxEventsAtOnce);
+    }
+
+    /**
+     * Sets the percentage of the desired amount of time spent for I/O in the child event loops.  The default value is
+     * {@code 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.
+     */
+    public void setIoRatio(int ioRatio) {
+        for (EventExecutor e: children()) {
+            ((EpollEventLoop) e).setIoRatio(ioRatio);
+        }
+    }
+
+    @Override
+    protected EventLoop newChild(Executor executor, Object... args) throws Exception {
+        return new EpollEventLoop(this, executor, (Integer) args[0]);
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java
new file mode 100644
index 000000000000..3ed89eca289d
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.EventLoop;
+import io.netty.channel.socket.ServerSocketChannel;
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+
+/**
+ * {@link ServerSocketChannel} implementation that uses linux EPOLL Edge-Triggered Mode for
+ * maximal performance.
+ */
+public final class EpollServerSocketChannel extends AbstractEpollChannel implements ServerSocketChannel {
+
+    private final EpollServerSocketChannelConfig config;
+    private volatile InetSocketAddress local;
+
+    public EpollServerSocketChannel() {
+        super(Native.socketStreamFd(), Native.EPOLLACCEPT);
+        config = new EpollServerSocketChannelConfig(this);
+    }
+
+    @Override
+    protected boolean isCompatible(EventLoop loop) {
+        return loop instanceof EpollEventLoop;
+    }
+
+    @Override
+    protected void doBind(SocketAddress localAddress) throws Exception {
+        InetSocketAddress addr = (InetSocketAddress) localAddress;
+        checkResolvable(addr);
+        Native.bind(fd, addr.getAddress(), addr.getPort());
+        local = Native.localAddress(fd);
+        Native.listen(fd, config.getBacklog());
+        active = true;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig config() {
+        return config;
+    }
+
+    @Override
+    protected InetSocketAddress localAddress0() {
+        return local;
+    }
+
+    @Override
+    protected InetSocketAddress remoteAddress0() {
+        return null;
+    }
+
+    @Override
+    protected AbstractEpollUnsafe newUnsafe() {
+        return new EpollServerSocketUnsafe();
+    }
+
+    @Override
+    protected void doWrite(ChannelOutboundBuffer in) {
+        throw new UnsupportedOperationException();
+    }
+
+    final class EpollServerSocketUnsafe extends AbstractEpollUnsafe {
+
+        @Override
+        public void connect(SocketAddress socketAddress, SocketAddress socketAddress2, ChannelPromise channelPromise) {
+            // Connect not supported by ServerChannel implementations
+            channelPromise.setFailure(new UnsupportedOperationException());
+        }
+
+        @Override
+        void epollInReady() {
+            assert eventLoop().inEventLoop();
+            final ChannelPipeline pipeline = pipeline();
+            Throwable exception = null;
+            try {
+                try {
+                    for (;;) {
+                        int socketFd = Native.accept(fd);
+                        if (socketFd == -1) {
+                            // this means everything was handled for now
+                            break;
+                        }
+                        try {
+                            readPending = false;
+                            pipeline.fireChannelRead(new EpollSocketChannel(EpollServerSocketChannel.this, socketFd));
+                        } catch (Throwable t) {
+                            // keep on reading as we use epoll ET and need to consume everything from the socket
+                            pipeline.fireChannelReadComplete();
+                            pipeline.fireExceptionCaught(t);
+                        }
+                    }
+                } catch (Throwable t) {
+                    exception = t;
+                }
+                pipeline.fireChannelReadComplete();
+
+                if (exception != null) {
+                    pipeline.fireExceptionCaught(exception);
+                }
+            } finally {
+                // Check if there is a readPending which was not processed yet.
+                // This could be for two reasons:
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
+                //
+                // See https://github.com/netty/netty/issues/2254
+                if (!config.isAutoRead() && !readPending) {
+                    clearEpollIn0();
+                }
+            }
+        }
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannelConfig.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannelConfig.java
new file mode 100644
index 000000000000..38c5f53c7f1d
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannelConfig.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.MessageSizeEstimator;
+import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.socket.ServerSocketChannelConfig;
+import io.netty.util.NetUtil;
+
+import java.util.Map;
+
+import static io.netty.channel.ChannelOption.SO_BACKLOG;
+import static io.netty.channel.ChannelOption.SO_RCVBUF;
+import static io.netty.channel.ChannelOption.SO_REUSEADDR;
+
+public final class EpollServerSocketChannelConfig extends DefaultChannelConfig
+        implements ServerSocketChannelConfig {
+
+    private final EpollServerSocketChannel channel;
+    private volatile int backlog = NetUtil.SOMAXCONN;
+
+    EpollServerSocketChannelConfig(EpollServerSocketChannel channel) {
+        super(channel);
+        this.channel = channel;
+
+        // Use SO_REUSEADDR by default as java.nio does the same.
+        //
+        // See https://github.com/netty/netty/issues/2605
+        setReuseAddress(true);
+    }
+
+    @Override
+    public Map<ChannelOption<?>, Object> getOptions() {
+        return getOptions(super.getOptions(), SO_RCVBUF, SO_REUSEADDR, SO_BACKLOG, EpollChannelOption.SO_REUSEPORT);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> T getOption(ChannelOption<T> option) {
+        if (option == SO_RCVBUF) {
+            return (T) Integer.valueOf(getReceiveBufferSize());
+        }
+        if (option == SO_REUSEADDR) {
+            return (T) Boolean.valueOf(isReuseAddress());
+        }
+        if (option == SO_BACKLOG) {
+            return (T) Integer.valueOf(getBacklog());
+        }
+        if (option == EpollChannelOption.SO_REUSEPORT) {
+            return (T) Boolean.valueOf(isReusePort());
+        }
+        return super.getOption(option);
+    }
+
+    @Override
+    public <T> boolean setOption(ChannelOption<T> option, T value) {
+        validate(option, value);
+
+        if (option == SO_RCVBUF) {
+            setReceiveBufferSize((Integer) value);
+        } else if (option == SO_REUSEADDR) {
+            setReuseAddress((Boolean) value);
+        } else if (option == SO_BACKLOG) {
+            setBacklog((Integer) value);
+        } else if (option == EpollChannelOption.SO_REUSEPORT) {
+            setReusePort((Boolean) value);
+        } else {
+            return super.setOption(option, value);
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean isReuseAddress() {
+        return Native.isReuseAddress(channel.fd) == 1;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setReuseAddress(boolean reuseAddress) {
+        Native.setReuseAddress(channel.fd, reuseAddress ? 1 : 0);
+        return this;
+    }
+
+    @Override
+    public int getReceiveBufferSize() {
+        return Native.getReceiveBufferSize(channel.fd);
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setReceiveBufferSize(int receiveBufferSize) {
+        Native.setReceiveBufferSize(channel.fd, receiveBufferSize);
+
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
+        return this;
+    }
+
+    @Override
+    public int getBacklog() {
+        return backlog;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setBacklog(int backlog) {
+        if (backlog < 0) {
+            throw new IllegalArgumentException("backlog: " + backlog);
+        }
+        this.backlog = backlog;
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
+        super.setConnectTimeoutMillis(connectTimeoutMillis);
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
+        super.setMaxMessagesPerRead(maxMessagesPerRead);
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setWriteSpinCount(int writeSpinCount) {
+        super.setWriteSpinCount(writeSpinCount);
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setAllocator(ByteBufAllocator allocator) {
+        super.setAllocator(allocator);
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setAutoRead(boolean autoRead) {
+        super.setAutoRead(autoRead);
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
+        return this;
+    }
+
+    @Override
+    public EpollServerSocketChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator) {
+        super.setMessageSizeEstimator(estimator);
+        return this;
+    }
+
+    /**
+     * Returns {@code true} if the SO_REUSEPORT option is set.
+     */
+    public boolean isReusePort() {
+        return Native.isReusePort(channel.fd) == 1;
+    }
+
+    /**
+     * Set the SO_REUSEPORT option on the underlying Channel. This will allow to bind multiple
+     * {@link EpollSocketChannel}s to the same port and so accept connections with multiple threads.
+     *
+     * Be aware this method needs be called before {@link EpollSocketChannel#bind(java.net.SocketAddress)} to have
+     * any affect.
+     */
+    public EpollServerSocketChannelConfig setReusePort(boolean reusePort) {
+        Native.setReusePort(channel.fd, reusePort ? 1 : 0);
+        return this;
+    }
+
+    @Override
+    protected void autoReadCleared() {
+        channel.clearEpollIn();
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
new file mode 100644
index 000000000000..11f8af80b06c
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java
@@ -0,0 +1,676 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelConfig;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.ConnectTimeoutException;
+import io.netty.channel.DefaultFileRegion;
+import io.netty.channel.EventLoop;
+import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.epoll.EpollChannelOutboundBuffer.AddressEntry;
+import io.netty.channel.socket.ChannelInputShutdownEvent;
+import io.netty.channel.socket.ServerSocketChannel;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannelOutboundBuffer;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.StringUtil;
+
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.nio.ByteBuffer;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * {@link SocketChannel} implementation that uses linux EPOLL Edge-Triggered Mode for
+ * maximal performance.
+ */
+public final class EpollSocketChannel extends AbstractEpollChannel implements SocketChannel {
+
+    private final EpollSocketChannelConfig config;
+
+    /**
+     * The future of the current connection attempt.  If not null, subsequent
+     * connection attempts will fail.
+     */
+    private ChannelPromise connectPromise;
+    private ScheduledFuture<?> connectTimeoutFuture;
+    private SocketAddress requestedRemoteAddress;
+
+    private volatile InetSocketAddress local;
+    private volatile InetSocketAddress remote;
+    private volatile boolean inputShutdown;
+    private volatile boolean outputShutdown;
+
+    EpollSocketChannel(Channel parent, int fd) {
+        super(parent, fd, Native.EPOLLIN, true);
+        config = new EpollSocketChannelConfig(this);
+        // Directly cache the remote and local addresses
+        // See https://github.com/netty/netty/issues/2359
+        remote = Native.remoteAddress(fd);
+        local = Native.localAddress(fd);
+    }
+
+    public EpollSocketChannel() {
+        super(Native.socketStreamFd(), Native.EPOLLIN);
+        config = new EpollSocketChannelConfig(this);
+    }
+
+    @Override
+    protected AbstractEpollUnsafe newUnsafe() {
+        return new EpollSocketUnsafe();
+    }
+
+    @Override
+    protected SocketAddress localAddress0() {
+        return local;
+    }
+
+    @Override
+    protected SocketAddress remoteAddress0() {
+        return remote;
+    }
+
+    @Override
+    protected void doBind(SocketAddress local) throws Exception {
+        InetSocketAddress localAddress = (InetSocketAddress) local;
+        Native.bind(fd, localAddress.getAddress(), localAddress.getPort());
+        this.local = Native.localAddress(fd);
+    }
+
+    /**
+     * Write bytes form the given {@link ByteBuf} to the underlying {@link java.nio.channels.Channel}.
+     * @param buf           the {@link ByteBuf} from which the bytes should be written
+     * @return amount       the amount of written bytes
+     */
+    private int doWriteBytes(ByteBuf buf, int readable) throws Exception {
+        int readerIndex = buf.readerIndex();
+        int localFlushedAmount;
+        if (buf.nioBufferCount() == 1) {
+            if (buf.hasMemoryAddress()) {
+                localFlushedAmount = Native.writeAddress(fd, buf.memoryAddress(), readerIndex, buf.writerIndex());
+            } else {
+                ByteBuffer nioBuf = buf.internalNioBuffer(readerIndex, readable);
+                localFlushedAmount = Native.write(fd, nioBuf, nioBuf.position(), nioBuf.limit());
+            }
+        } else {
+            // backed by more then one buffer, do a gathering write...
+            ByteBuffer[] nioBufs = buf.nioBuffers();
+            localFlushedAmount = (int) Native.writev(fd, nioBufs, 0, nioBufs.length);
+        }
+        if (localFlushedAmount > 0) {
+            buf.readerIndex(readerIndex + localFlushedAmount);
+        }
+        return localFlushedAmount;
+    }
+
+    private void writeBytesMultiple(
+            EpollChannelOutboundBuffer in, int msgCount, AddressEntry[] nioBuffers) throws IOException {
+
+        int nioBufferCnt = in.addressCount();
+        long expectedWrittenBytes = in.addressSize();
+
+        long localWrittenBytes = Native.writevAddresses(fd, nioBuffers, 0, nioBufferCnt);
+
+        if (localWrittenBytes < expectedWrittenBytes) {
+            setEpollOut();
+
+            // Did not write all buffers completely.
+            // Release the fully written buffers and update the indexes of the partially written buffer.
+            for (int i = msgCount; i > 0; i --) {
+                final ByteBuf buf = (ByteBuf) in.current();
+                final int readerIndex = buf.readerIndex();
+                final int readableBytes = buf.writerIndex() - readerIndex;
+
+                if (readableBytes < localWrittenBytes) {
+                    in.remove();
+                    localWrittenBytes -= readableBytes;
+                } else if (readableBytes > localWrittenBytes) {
+
+                    buf.readerIndex(readerIndex + (int) localWrittenBytes);
+                    in.progress(localWrittenBytes);
+                    break;
+                } else { // readable == writtenBytes
+                    in.remove();
+                    break;
+                }
+            }
+        } else {
+            // Release all buffers
+            for (int i = msgCount; i > 0; i --) {
+                in.remove();
+            }
+        }
+    }
+
+    private void writeBytesMultiple(
+            NioSocketChannelOutboundBuffer in, int msgCount, ByteBuffer[] nioBuffers) throws IOException {
+
+        int nioBufferCnt = in.nioBufferCount();
+        long expectedWrittenBytes = in.nioBufferSize();
+
+        long localWrittenBytes = Native.writev(fd, nioBuffers, 0, nioBufferCnt);
+
+        if (localWrittenBytes < expectedWrittenBytes) {
+            setEpollOut();
+
+            // Did not write all buffers completely.
+            // Release the fully written buffers and update the indexes of the partially written buffer.
+            for (int i = msgCount; i > 0; i --) {
+                final ByteBuf buf = (ByteBuf) in.current();
+                final int readerIndex = buf.readerIndex();
+                final int readableBytes = buf.writerIndex() - readerIndex;
+
+                if (readableBytes < localWrittenBytes) {
+                    in.remove();
+                    localWrittenBytes -= readableBytes;
+                } else if (readableBytes > localWrittenBytes) {
+
+                    buf.readerIndex(readerIndex + (int) localWrittenBytes);
+                    in.progress(localWrittenBytes);
+                    break;
+                } else { // readable == writtenBytes
+                    in.remove();
+                    break;
+                }
+            }
+        } else {
+            // Release all buffers
+            for (int i = msgCount; i > 0; i --) {
+                in.remove();
+            }
+        }
+    }
+
+    /**
+     * Write a {@link DefaultFileRegion}
+     *
+     * @param region        the {@link DefaultFileRegion} from which the bytes should be written
+     * @return amount       the amount of written bytes
+     */
+    private long doWriteFileRegion(DefaultFileRegion region, long count) throws Exception {
+        return Native.sendfile(fd, region, region.transfered(), count);
+    }
+
+    @Override
+    protected void doWrite(ChannelOutboundBuffer in) throws Exception {
+        for (;;) {
+            final int msgCount = in.size();
+
+            if (msgCount == 0) {
+                // Wrote all messages.
+                clearEpollOut();
+                break;
+            }
+
+            // Do gathering write if:
+            // * the outbound buffer contains more than one messages and
+            // * they are all buffers rather than a file region.
+            if (msgCount > 1) {
+                if (PlatformDependent.hasUnsafe()) {
+                    // this means we can cast to EpollChannelOutboundBuffer and write the AdressEntry directly.
+                    EpollChannelOutboundBuffer epollIn = (EpollChannelOutboundBuffer) in;
+                    // Ensure the pending writes are made of memoryaddresses only.
+                    AddressEntry[] addresses = epollIn.memoryAddresses();
+                    if (addresses != null) {
+                        writeBytesMultiple(epollIn, msgCount, addresses);
+
+                        // We do not break the loop here even if the outbound buffer was flushed completely,
+                        // because a user might have triggered another write and flush when we notify his or her
+                        // listeners.
+                        continue;
+                    }
+                } else {
+                    NioSocketChannelOutboundBuffer nioIn = (NioSocketChannelOutboundBuffer) in;
+                    // Ensure the pending writes are made of memoryaddresses only.
+                    ByteBuffer[] buffers = nioIn.nioBuffers();
+                    if (buffers != null) {
+                        writeBytesMultiple(nioIn, msgCount, buffers);
+
+                        // We do not break the loop here even if the outbound buffer was flushed completely,
+                        // because a user might have triggered another write and flush when we notify his or her
+                        // listeners.
+                        continue;
+                    }
+                }
+            }
+
+            // The outbound buffer contains only one message or it contains a file region.
+            Object msg = in.current();
+            if (msg instanceof ByteBuf) {
+                ByteBuf buf = (ByteBuf) msg;
+                int readableBytes = buf.readableBytes();
+                if (readableBytes == 0) {
+                    in.remove();
+                    continue;
+                }
+
+                int expected = buf.readableBytes();
+                int localFlushedAmount = doWriteBytes(buf, expected);
+                in.progress(localFlushedAmount);
+                if (localFlushedAmount < expected) {
+                    setEpollOut();
+                    break;
+                }
+                if (!buf.isReadable()) {
+                    in.remove();
+                }
+
+            } else if (msg instanceof DefaultFileRegion) {
+                DefaultFileRegion region = (DefaultFileRegion) msg;
+
+                long expected = region.count() - region.position();
+                long localFlushedAmount = doWriteFileRegion(region, expected);
+                in.progress(localFlushedAmount);
+
+                if (localFlushedAmount < expected) {
+                    setEpollOut();
+                    break;
+                }
+
+                if (region.transfered() >= region.count()) {
+                    in.remove();
+                }
+            } else {
+                throw new UnsupportedOperationException("unsupported message type: " + StringUtil.simpleClassName(msg));
+            }
+        }
+    }
+
+    @Override
+    public EpollSocketChannelConfig config() {
+        return config;
+    }
+
+    @Override
+    public boolean isInputShutdown() {
+        return inputShutdown;
+    }
+
+    @Override
+    public boolean isOutputShutdown() {
+        return outputShutdown || !isActive();
+    }
+
+    @Override
+    public ChannelFuture shutdownOutput() {
+        return shutdownOutput(newPromise());
+    }
+
+    @Override
+    public ChannelFuture shutdownOutput(final ChannelPromise promise) {
+        EventLoop loop = eventLoop();
+        if (loop.inEventLoop()) {
+            try {
+                Native.shutdown(fd, false, true);
+                outputShutdown = true;
+                promise.setSuccess();
+            } catch (Throwable t) {
+                promise.setFailure(t);
+            }
+        } else {
+            loop.execute(new Runnable() {
+                @Override
+                public void run() {
+                    shutdownOutput(promise);
+                }
+            });
+        }
+        return promise;
+    }
+
+    @Override
+    public ServerSocketChannel parent() {
+        return (ServerSocketChannel) super.parent();
+    }
+
+    final class EpollSocketUnsafe extends AbstractEpollUnsafe {
+        private RecvByteBufAllocator.Handle allocHandle;
+
+        private void closeOnRead(ChannelPipeline pipeline) {
+            inputShutdown = true;
+            if (isOpen()) {
+                if (Boolean.TRUE.equals(config().getOption(ChannelOption.ALLOW_HALF_CLOSURE))) {
+                    clearEpollIn0();
+                    pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
+                } else {
+                    close(voidPromise());
+                }
+            }
+        }
+
+        private boolean handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Throwable cause, boolean close) {
+            if (byteBuf != null) {
+                if (byteBuf.isReadable()) {
+                    readPending = false;
+                    pipeline.fireChannelRead(byteBuf);
+                } else {
+                    byteBuf.release();
+                }
+            }
+            pipeline.fireChannelReadComplete();
+            pipeline.fireExceptionCaught(cause);
+            if (close || cause instanceof IOException) {
+                closeOnRead(pipeline);
+                return true;
+            }
+            return false;
+        }
+
+        @Override
+        public void connect(
+                final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
+            if (!promise.setUncancellable() || !ensureOpen(promise)) {
+                return;
+            }
+
+            try {
+                if (connectPromise != null) {
+                    throw new IllegalStateException("connection attempt already made");
+                }
+
+                boolean wasActive = isActive();
+                if (doConnect((InetSocketAddress) remoteAddress, (InetSocketAddress) localAddress)) {
+                    fulfillConnectPromise(promise, wasActive);
+                } else {
+                    connectPromise = promise;
+                    requestedRemoteAddress = remoteAddress;
+
+                    // Schedule connect timeout.
+                    int connectTimeoutMillis = config().getConnectTimeoutMillis();
+                    if (connectTimeoutMillis > 0) {
+                        connectTimeoutFuture = eventLoop().schedule(new Runnable() {
+                            @Override
+                            public void run() {
+                                ChannelPromise connectPromise = EpollSocketChannel.this.connectPromise;
+                                ConnectTimeoutException cause =
+                                        new ConnectTimeoutException("connection timed out: " + remoteAddress);
+                                if (connectPromise != null && connectPromise.tryFailure(cause)) {
+                                    close(voidPromise());
+                                }
+                            }
+                        }, connectTimeoutMillis, TimeUnit.MILLISECONDS);
+                    }
+
+                    promise.addListener(new ChannelFutureListener() {
+                        @Override
+                        public void operationComplete(ChannelFuture future) throws Exception {
+                            if (future.isCancelled()) {
+                                if (connectTimeoutFuture != null) {
+                                    connectTimeoutFuture.cancel(false);
+                                }
+                                connectPromise = null;
+                                close(voidPromise());
+                            }
+                        }
+                    });
+                }
+            } catch (Throwable t) {
+                if (t instanceof ConnectException) {
+                    Throwable newT = new ConnectException(t.getMessage() + ": " + remoteAddress);
+                    newT.setStackTrace(t.getStackTrace());
+                    t = newT;
+                }
+                closeIfClosed();
+                promise.tryFailure(t);
+            }
+        }
+
+        private void fulfillConnectPromise(ChannelPromise promise, boolean wasActive) {
+            if (promise == null) {
+                // Closed via cancellation and the promise has been notified already.
+                return;
+            }
+            active = true;
+
+            // trySuccess() will return false if a user cancelled the connection attempt.
+            boolean promiseSet = promise.trySuccess();
+
+            // Regardless if the connection attempt was cancelled, channelActive() event should be triggered,
+            // because what happened is what happened.
+            if (!wasActive && isActive()) {
+                pipeline().fireChannelActive();
+            }
+
+            // If a user cancelled the connection attempt, close the channel, which is followed by channelInactive().
+            if (!promiseSet) {
+                close(voidPromise());
+            }
+        }
+
+        private void fulfillConnectPromise(ChannelPromise promise, Throwable cause) {
+            if (promise == null) {
+                // Closed via cancellation and the promise has been notified already.
+            }
+
+            // Use tryFailure() instead of setFailure() to avoid the race against cancel().
+            promise.tryFailure(cause);
+            closeIfClosed();
+        }
+
+        private void finishConnect() {
+            // Note this method is invoked by the event loop only if the connection attempt was
+            // neither cancelled nor timed out.
+
+            assert eventLoop().inEventLoop();
+
+            boolean connectStillInProgress = false;
+            try {
+                boolean wasActive = isActive();
+                if (!doFinishConnect()) {
+                    connectStillInProgress = true;
+                    return;
+                }
+                fulfillConnectPromise(connectPromise, wasActive);
+            } catch (Throwable t) {
+                if (t instanceof ConnectException) {
+                    Throwable newT = new ConnectException(t.getMessage() + ": " + requestedRemoteAddress);
+                    newT.setStackTrace(t.getStackTrace());
+                    t = newT;
+                }
+
+                fulfillConnectPromise(connectPromise, t);
+            } finally {
+                if (!connectStillInProgress) {
+                    // Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis > 0 is used
+                    // See https://github.com/netty/netty/issues/1770
+                    if (connectTimeoutFuture != null) {
+                        connectTimeoutFuture.cancel(false);
+                    }
+                    connectPromise = null;
+                }
+            }
+        }
+
+        @Override
+        void epollOutReady() {
+            if (connectPromise != null) {
+                // pending connect which is now complete so handle it.
+                finishConnect();
+            } else {
+                super.epollOutReady();
+            }
+        }
+
+        /**
+         * Connect to the remote peer
+         */
+        private boolean doConnect(InetSocketAddress remoteAddress, InetSocketAddress localAddress) throws Exception {
+            if (localAddress != null) {
+                checkResolvable(localAddress);
+                Native.bind(fd, localAddress.getAddress(), localAddress.getPort());
+            }
+
+            boolean success = false;
+            try {
+                checkResolvable(remoteAddress);
+                boolean connected = Native.connect(fd, remoteAddress.getAddress(),
+                        remoteAddress.getPort());
+                remote = remoteAddress;
+                local = Native.localAddress(fd);
+                if (!connected) {
+                    setEpollOut();
+                }
+                success = true;
+                return connected;
+            } finally {
+                if (!success) {
+                    doClose();
+                }
+            }
+        }
+
+        /**
+         * Finish the connect
+         */
+        private boolean doFinishConnect() throws Exception {
+            if (Native.finishConnect(fd)) {
+                clearEpollOut();
+                return true;
+            } else {
+                setEpollOut();
+                return false;
+            }
+        }
+
+        /**
+         * Read bytes into the given {@link ByteBuf} and return the amount.
+         */
+        private int doReadBytes(ByteBuf byteBuf) throws Exception {
+            int writerIndex = byteBuf.writerIndex();
+            int localReadAmount;
+            if (byteBuf.hasMemoryAddress()) {
+                localReadAmount = Native.readAddress(fd, byteBuf.memoryAddress(), writerIndex, byteBuf.capacity());
+            } else {
+                ByteBuffer buf = byteBuf.internalNioBuffer(writerIndex, byteBuf.writableBytes());
+                localReadAmount = Native.read(fd, buf, buf.position(), buf.limit());
+            }
+            if (localReadAmount > 0) {
+                byteBuf.writerIndex(writerIndex + localReadAmount);
+            }
+            return localReadAmount;
+        }
+
+        @Override
+        void epollRdHupReady() {
+            if (isActive()) {
+                epollInReady();
+            } else {
+                closeOnRead(pipeline());
+            }
+        }
+
+        @Override
+        void epollInReady() {
+            final ChannelConfig config = config();
+            final ChannelPipeline pipeline = pipeline();
+            final ByteBufAllocator allocator = config.getAllocator();
+            RecvByteBufAllocator.Handle allocHandle = this.allocHandle;
+            if (allocHandle == null) {
+                this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();
+            }
+
+            ByteBuf byteBuf = null;
+            boolean close = false;
+            try {
+                int totalReadAmount = 0;
+                for (;;) {
+                    // we use a direct buffer here as the native implementations only be able
+                    // to handle direct buffers.
+                    byteBuf = allocHandle.allocate(allocator);
+                    int writable = byteBuf.writableBytes();
+                    int localReadAmount = doReadBytes(byteBuf);
+                    if (localReadAmount <= 0) {
+                        // not was read release the buffer
+                        byteBuf.release();
+                        close = localReadAmount < 0;
+                        break;
+                    }
+                    readPending = false;
+                    pipeline.fireChannelRead(byteBuf);
+                    byteBuf = null;
+
+                    if (totalReadAmount >= Integer.MAX_VALUE - localReadAmount) {
+                        allocHandle.record(totalReadAmount);
+
+                        // Avoid overflow.
+                        totalReadAmount = localReadAmount;
+                    } else {
+                        totalReadAmount += localReadAmount;
+                    }
+
+                    if (localReadAmount < writable) {
+                        // Read less than what the buffer can hold,
+                        // which might mean we drained the recv buffer completely.
+                        break;
+                    }
+                }
+                pipeline.fireChannelReadComplete();
+                allocHandle.record(totalReadAmount);
+
+                if (close) {
+                    closeOnRead(pipeline);
+                    close = false;
+                }
+            } catch (Throwable t) {
+                boolean closed = handleReadException(pipeline, byteBuf, t, close);
+                if (!closed) {
+                    // trigger a read again as there may be something left to read and because of epoll ET we
+                    // will not get notified again until we read everything from the socket
+                    eventLoop().execute(new Runnable() {
+                        @Override
+                        public void run() {
+                            epollInReady();
+                        }
+                    });
+                }
+            } finally {
+                // Check if there is a readPending which was not processed yet.
+                // This could be for two reasons:
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
+                //
+                // See https://github.com/netty/netty/issues/2254
+                if (!config.isAutoRead() && !readPending) {
+                    clearEpollIn0();
+                }
+            }
+        }
+    }
+
+    @Override
+    protected ChannelOutboundBuffer newOutboundBuffer() {
+        if (PlatformDependent.hasUnsafe()) {
+            // This means we will be able to access the memory addresses directly and so be able to do
+            // gathering writes with the AddressEntry.
+            return EpollChannelOutboundBuffer.newInstance(this);
+        } else {
+            // No access to the memoryAddres, so fallback to use ByteBuffer[] for gathering writes.
+            return NioSocketChannelOutboundBuffer.newInstance(this);
+        }
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannelConfig.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannelConfig.java
new file mode 100644
index 000000000000..011529258fd8
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannelConfig.java
@@ -0,0 +1,351 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.MessageSizeEstimator;
+import io.netty.channel.RecvByteBufAllocator;
+import io.netty.channel.socket.SocketChannelConfig;
+import io.netty.util.internal.PlatformDependent;
+
+import java.util.Map;
+
+import static io.netty.channel.ChannelOption.*;
+
+public final class EpollSocketChannelConfig extends DefaultChannelConfig implements SocketChannelConfig {
+
+    private final EpollSocketChannel channel;
+    private volatile boolean allowHalfClosure;
+
+    /**
+     * Creates a new instance.
+     */
+    EpollSocketChannelConfig(EpollSocketChannel channel) {
+        super(channel);
+
+        this.channel = channel;
+        if (PlatformDependent.canEnableTcpNoDelayByDefault()) {
+            setTcpNoDelay(true);
+        }
+    }
+
+    @Override
+    public Map<ChannelOption<?>, Object> getOptions() {
+        return getOptions(
+                super.getOptions(),
+                SO_RCVBUF, SO_SNDBUF, TCP_NODELAY, SO_KEEPALIVE, SO_REUSEADDR, SO_LINGER, IP_TOS,
+                ALLOW_HALF_CLOSURE, EpollChannelOption.TCP_CORK, EpollChannelOption.TCP_KEEPCNT,
+                EpollChannelOption.TCP_KEEPIDLE, EpollChannelOption.TCP_KEEPINTVL);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> T getOption(ChannelOption<T> option) {
+        if (option == SO_RCVBUF) {
+            return (T) Integer.valueOf(getReceiveBufferSize());
+        }
+        if (option == SO_SNDBUF) {
+            return (T) Integer.valueOf(getSendBufferSize());
+        }
+        if (option == TCP_NODELAY) {
+            return (T) Boolean.valueOf(isTcpNoDelay());
+        }
+        if (option == SO_KEEPALIVE) {
+            return (T) Boolean.valueOf(isKeepAlive());
+        }
+        if (option == SO_REUSEADDR) {
+            return (T) Boolean.valueOf(isReuseAddress());
+        }
+        if (option == SO_LINGER) {
+            return (T) Integer.valueOf(getSoLinger());
+        }
+        if (option == IP_TOS) {
+            return (T) Integer.valueOf(getTrafficClass());
+        }
+        if (option == ALLOW_HALF_CLOSURE) {
+            return (T) Boolean.valueOf(isAllowHalfClosure());
+        }
+        if (option == EpollChannelOption.TCP_CORK) {
+            return (T) Boolean.valueOf(isTcpCork());
+        }
+        if (option == EpollChannelOption.TCP_KEEPIDLE) {
+            return (T) Integer.valueOf(getTcpKeepIdle());
+        }
+        if (option == EpollChannelOption.TCP_KEEPINTVL) {
+            return (T) Integer.valueOf(getTcpKeepIntvl());
+        }
+        if (option == EpollChannelOption.TCP_KEEPCNT) {
+            return (T) Integer.valueOf(getTcpKeepCnt());
+        }
+        return super.getOption(option);
+    }
+
+    @Override
+    public <T> boolean setOption(ChannelOption<T> option, T value) {
+        validate(option, value);
+
+        if (option == SO_RCVBUF) {
+            setReceiveBufferSize((Integer) value);
+        } else if (option == SO_SNDBUF) {
+            setSendBufferSize((Integer) value);
+        } else if (option == TCP_NODELAY) {
+            setTcpNoDelay((Boolean) value);
+        } else if (option == SO_KEEPALIVE) {
+            setKeepAlive((Boolean) value);
+        } else if (option == SO_REUSEADDR) {
+            setReuseAddress((Boolean) value);
+        } else if (option == SO_LINGER) {
+            setSoLinger((Integer) value);
+        } else if (option == IP_TOS) {
+            setTrafficClass((Integer) value);
+        } else if (option == ALLOW_HALF_CLOSURE) {
+            setAllowHalfClosure((Boolean) value);
+        } else if (option == EpollChannelOption.TCP_CORK) {
+            setTcpCork((Boolean) value);
+        } else if (option == EpollChannelOption.TCP_KEEPIDLE) {
+            setTcpKeepIdle((Integer) value);
+        } else if (option == EpollChannelOption.TCP_KEEPCNT) {
+            setTcpKeepCntl((Integer) value);
+        } else if (option == EpollChannelOption.TCP_KEEPINTVL) {
+            setTcpKeepIntvl((Integer) value);
+        } else {
+            return super.setOption(option, value);
+        }
+
+        return true;
+    }
+
+    @Override
+    public int getReceiveBufferSize() {
+        return Native.getReceiveBufferSize(channel.fd);
+    }
+
+    @Override
+    public int getSendBufferSize() {
+        return Native.getSendBufferSize(channel.fd);
+    }
+
+    @Override
+    public int getSoLinger() {
+        return Native.getSoLinger(channel.fd);
+    }
+
+    @Override
+    public int getTrafficClass() {
+        return Native.getTrafficClass(channel.fd);
+    }
+
+    @Override
+    public boolean isKeepAlive() {
+        return Native.isKeepAlive(channel.fd) == 1;
+    }
+
+    @Override
+    public boolean isReuseAddress() {
+        return Native.isReuseAddress(channel.fd) == 1;
+    }
+
+    @Override
+    public boolean isTcpNoDelay() {
+        return Native.isTcpNoDelay(channel.fd) == 1;
+    }
+
+    /**
+     * Get the {@code TCP_CORK} option on the socket. See {@code man 7 tcp} for more details.
+     */
+    public boolean isTcpCork() {
+        return Native.isTcpCork(channel.fd) == 1;
+    }
+
+    /**
+     * Get the {@code TCP_KEEPIDLE} option on the socket. See {@code man 7 tcp} for more details.
+     */
+    public int getTcpKeepIdle() {
+        return Native.getTcpKeepIdle(channel.fd);
+    }
+
+    /**
+     * Get the {@code TCP_KEEPINTVL} option on the socket. See {@code man 7 tcp} for more details.
+     */
+    public int getTcpKeepIntvl() {
+        return Native.getTcpKeepIntvl(channel.fd);
+    }
+
+    /**
+     * Get the {@code TCP_KEEPCNT} option on the socket. See {@code man 7 tcp} for more details.
+     */
+    public int getTcpKeepCnt() {
+        return Native.getTcpKeepCnt(channel.fd);
+    }
+
+    @Override
+    public EpollSocketChannelConfig setKeepAlive(boolean keepAlive) {
+        Native.setKeepAlive(channel.fd, keepAlive ? 1 : 0);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setPerformancePreferences(
+            int connectionTime, int latency, int bandwidth) {
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setReceiveBufferSize(int receiveBufferSize) {
+        Native.setReceiveBufferSize(channel.fd, receiveBufferSize);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setReuseAddress(boolean reuseAddress) {
+        Native.setReuseAddress(channel.fd, reuseAddress ? 1 : 0);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setSendBufferSize(int sendBufferSize) {
+        Native.setSendBufferSize(channel.fd, sendBufferSize);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setSoLinger(int soLinger) {
+        Native.setSoLinger(channel.fd, soLinger);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setTcpNoDelay(boolean tcpNoDelay) {
+        Native.setTcpNoDelay(channel.fd, tcpNoDelay ? 1 : 0);
+        return this;
+    }
+
+    /**
+     * Set the {@code TCP_CORK} option on the socket. See {@code man 7 tcp} for more details.
+     */
+    public EpollSocketChannelConfig setTcpCork(boolean tcpCork) {
+        Native.setTcpCork(channel.fd, tcpCork ? 1 : 0);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setTrafficClass(int trafficClass) {
+        Native.setTrafficClass(channel.fd, trafficClass);
+        return this;
+    }
+
+    /**
+     * Set the {@code TCP_KEEPIDLE} option on the socket. See {@code man 7 tcp} for more details.
+     */
+    public EpollSocketChannelConfig setTcpKeepIdle(int seconds) {
+        Native.setTcpKeepIdle(channel.fd, seconds);
+        return this;
+    }
+
+    /**
+     * Set the {@code TCP_KEEPINTVL} option on the socket. See {@code man 7 tcp} for more details.
+     */
+    public EpollSocketChannelConfig setTcpKeepIntvl(int seconds) {
+        Native.setTcpKeepIntvl(channel.fd, seconds);
+        return this;
+    }
+
+    /**
+     * Set the {@code TCP_KEEPCNT} option on the socket. See {@code man 7 tcp} for more details.
+     */
+    public EpollSocketChannelConfig setTcpKeepCntl(int probes) {
+        Native.setTcpKeepCnt(channel.fd, probes);
+        return this;
+    }
+
+    @Override
+    public boolean isAllowHalfClosure() {
+        return allowHalfClosure;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setAllowHalfClosure(boolean allowHalfClosure) {
+        this.allowHalfClosure = allowHalfClosure;
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
+        super.setConnectTimeoutMillis(connectTimeoutMillis);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {
+        super.setMaxMessagesPerRead(maxMessagesPerRead);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setWriteSpinCount(int writeSpinCount) {
+        super.setWriteSpinCount(writeSpinCount);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setAllocator(ByteBufAllocator allocator) {
+        super.setAllocator(allocator);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setAutoRead(boolean autoRead) {
+        super.setAutoRead(autoRead);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setAutoClose(boolean autoClose) {
+        super.setAutoClose(autoClose);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
+        return this;
+    }
+
+    @Override
+    public EpollSocketChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator) {
+        super.setMessageSizeEstimator(estimator);
+        return this;
+    }
+
+    @Override
+    protected void autoReadCleared() {
+        channel.clearEpollIn();
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
new file mode 100644
index 000000000000..2e9cb439e54b
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+
+import io.netty.channel.ChannelException;
+import io.netty.channel.DefaultFileRegion;
+import io.netty.channel.epoll.EpollChannelOutboundBuffer.AddressEntry;
+import io.netty.util.internal.NativeLibraryLoader;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SystemPropertyUtil;
+
+import java.io.IOException;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.util.Locale;
+
+/**
+ * Native helper methods
+ *
+ * <strong>Internal usage only!</strong>
+ */
+final class Native {
+    private static final byte[] IPV4_MAPPED_IPV6_PREFIX = {
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xff, (byte) 0xff };
+
+    static {
+        String name = SystemPropertyUtil.get("os.name").toLowerCase(Locale.UK).trim();
+        if (!name.startsWith("linux")) {
+            throw new IllegalStateException("Only supported on Linux");
+        }
+        NativeLibraryLoader.load("netty-transport-native-epoll", PlatformDependent.getClassLoader(Native.class));
+    }
+
+    // EventLoop operations and constants
+    public static final int EPOLLIN = 0x01;
+    public static final int EPOLLOUT = 0x02;
+    public static final int EPOLLACCEPT = 0x04;
+    public static final int EPOLLRDHUP = 0x08;
+
+    public static native int eventFd();
+    public static native void eventFdWrite(int fd, long value);
+    public static native void eventFdRead(int fd);
+    public static native int epollCreate();
+    public static native int epollWait(int efd, long[] events, int timeout);
+    public static native void epollCtlAdd(int efd, final int fd, final int flags, final int id);
+    public static native void epollCtlMod(int efd, final int fd, final int flags, final int id);
+    public static native void epollCtlDel(int efd, final int fd);
+
+    // File-descriptor operations
+    public static native void close(int fd) throws IOException;
+
+    public static native int write(int fd, ByteBuffer buf, int pos, int limit) throws IOException;
+    public static native int writeAddress(int fd, long address, int pos, int limit) throws IOException;
+
+    public static native long writev(int fd, ByteBuffer[] buffers, int offset, int length) throws IOException;
+    public static native long writevAddresses(int fd, AddressEntry[] addresses, int offset, int length)
+            throws IOException;
+
+    public static native int read(int fd, ByteBuffer buf, int pos, int limit) throws IOException;
+    public static native int readAddress(int fd, long address, int pos, int limit) throws IOException;
+
+    public static native long sendfile(int dest, DefaultFileRegion src, long offset, long length) throws IOException;
+
+    public static int sendTo(
+            int fd, ByteBuffer buf, int pos, int limit, InetAddress addr, int port) throws IOException {
+        // just duplicate the toNativeInetAddress code here to minimize object creation as this method is expected
+        // to be called frequently
+        byte[] address;
+        int scopeId;
+        if (addr instanceof Inet6Address) {
+            address = addr.getAddress();
+            scopeId = ((Inet6Address) addr).getScopeId();
+        } else {
+            // convert to ipv4 mapped ipv6 address;
+            scopeId = 0;
+            address = ipv4MappedIpv6Address(addr.getAddress());
+        }
+        return sendTo(fd, buf, pos, limit, address, scopeId, port);
+    }
+
+    private static native int sendTo(
+            int fd, ByteBuffer buf, int pos, int limit, byte[] address, int scopeId, int port) throws IOException;
+
+    public static int sendToAddress(
+            int fd, long memoryAddress, int pos, int limit, InetAddress addr, int port) throws IOException {
+        // just duplicate the toNativeInetAddress code here to minimize object creation as this method is expected
+        // to be called frequently
+        byte[] address;
+        int scopeId;
+        if (addr instanceof Inet6Address) {
+            address = addr.getAddress();
+            scopeId = ((Inet6Address) addr).getScopeId();
+        } else {
+            // convert to ipv4 mapped ipv6 address;
+            scopeId = 0;
+            address = ipv4MappedIpv6Address(addr.getAddress());
+        }
+        return sendToAddress(fd, memoryAddress, pos, limit, address, scopeId, port);
+    }
+
+    private static native int sendToAddress(
+            int fd, long memoryAddress, int pos, int limit, byte[] address, int scopeId, int port) throws IOException;
+
+    public static native EpollDatagramChannel.DatagramSocketAddress recvFrom(
+            int fd, ByteBuffer buf, int pos, int limit) throws IOException;
+
+    public static native EpollDatagramChannel.DatagramSocketAddress recvFromAddress(
+            int fd, long memoryAddress, int pos, int limit) throws IOException;
+
+    // socket operations
+    public static int socketStreamFd() {
+        try {
+            return socketStream();
+        } catch (IOException e) {
+            throw new ChannelException(e);
+        }
+    }
+
+    public static int socketDgramFd() {
+        try {
+            return socketDgram();
+        } catch (IOException e) {
+            throw new ChannelException(e);
+        }
+    }
+    private static native int socketStream() throws IOException;
+    private static native int socketDgram() throws IOException;
+
+    public static void bind(int fd, InetAddress addr, int port) throws IOException {
+        NativeInetAddress address = toNativeInetAddress(addr);
+        bind(fd, address.address, address.scopeId, port);
+    }
+
+    private static byte[] ipv4MappedIpv6Address(byte[] ipv4) {
+        byte[] address = new byte[16];
+        System.arraycopy(IPV4_MAPPED_IPV6_PREFIX, 0, address, 0, IPV4_MAPPED_IPV6_PREFIX.length);
+        System.arraycopy(ipv4, 0, address, 12, ipv4.length);
+        return address;
+    }
+
+    public static native void bind(int fd, byte[] address, int scopeId, int port) throws IOException;
+    public static native void listen(int fd, int backlog) throws IOException;
+    public static boolean connect(int fd, InetAddress addr, int port) throws IOException {
+        NativeInetAddress address = toNativeInetAddress(addr);
+        return connect(fd, address.address, address.scopeId, port);
+    }
+    public static native boolean connect(int fd, byte[] address, int scopeId, int port) throws IOException;
+    public static native boolean finishConnect(int fd) throws IOException;
+
+    public static native InetSocketAddress remoteAddress(int fd);
+    public static native InetSocketAddress localAddress(int fd);
+    public static native int accept(int fd) throws IOException;
+    public static native void shutdown(int fd, boolean read, boolean write) throws IOException;
+
+    // Socket option operations
+    public static native int getReceiveBufferSize(int fd);
+    public static native int getSendBufferSize(int fd);
+    public static native int isKeepAlive(int fd);
+    public static native int isReuseAddress(int fd);
+    public static native int isReusePort(int fd);
+    public static native int isTcpNoDelay(int fd);
+    public static native int isTcpCork(int fd);
+    public static native int getSoLinger(int fd);
+    public static native int getTrafficClass(int fd);
+    public static native int isBroadcast(int fd);
+    public static native int getTcpKeepIdle(int fd);
+    public static native int getTcpKeepIntvl(int fd);
+    public static native int getTcpKeepCnt(int fd);
+
+    public static native void setKeepAlive(int fd, int keepAlive);
+    public static native void setReceiveBufferSize(int fd, int receiveBufferSize);
+    public static native void setReuseAddress(int fd, int reuseAddress);
+    public static native void setReusePort(int fd, int reuseAddress);
+    public static native void setSendBufferSize(int fd, int sendBufferSize);
+    public static native void setTcpNoDelay(int fd, int tcpNoDelay);
+    public static native void setTcpCork(int fd, int tcpCork);
+    public static native void setSoLinger(int fd, int soLinger);
+    public static native void setTrafficClass(int fd, int tcpNoDelay);
+    public static native void setBroadcast(int fd, int broadcast);
+    public static native void setTcpKeepIdle(int fd, int seconds);
+    public static native void setTcpKeepIntvl(int fd, int seconds);
+    public static native void setTcpKeepCnt(int fd, int probes);
+
+    private static NativeInetAddress toNativeInetAddress(InetAddress addr) {
+        byte[] bytes = addr.getAddress();
+        if (addr instanceof Inet6Address) {
+            return new NativeInetAddress(bytes, ((Inet6Address) addr).getScopeId());
+        } else {
+            // convert to ipv4 mapped ipv6 address;
+            return new NativeInetAddress(ipv4MappedIpv6Address(bytes));
+        }
+    }
+
+    private static class NativeInetAddress {
+        final byte[] address;
+        final int scopeId;
+
+        NativeInetAddress(byte[] address, int scopeId) {
+            this.address = address;
+            this.scopeId = scopeId;
+        }
+
+        NativeInetAddress(byte[] address) {
+            this(address, 0);
+        }
+    }
+
+    public static native String kernelVersion();
+    private Native() {
+        // utility
+    }
+}
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/package-info.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/package-info.java
new file mode 100644
index 000000000000..338a666c5300
--- /dev/null
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/package-info.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Optimized transport for linux which uses <a href="http://en.wikipedia.org/wiki/Epoll">EPOLL Edge-Triggered Mode</a>
+ * for maximal performance.
+ */
+package io.netty.channel.epoll;
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDatagramUnicastTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDatagramUnicastTest.java
new file mode 100644
index 000000000000..610cfb5d851f
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDatagramUnicastTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.DatagramUnicastTest;
+
+import java.util.List;
+
+public class EpollDatagramUnicastTest extends DatagramUnicastTest {
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<Bootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.datagram();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollReuseAddrTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollReuseAddrTest.java
new file mode 100644
index 000000000000..21d835e234e9
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollReuseAddrTest.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.AbstractBootstrap;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerAdapter;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.testsuite.util.TestUtils;
+import io.netty.util.NetUtil;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.ResourceLeakDetector;
+import io.netty.util.internal.StringUtil;
+import org.junit.Assert;
+import org.junit.Assume;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public class EpollReuseAddrTest {
+    private static final int MAJOR;
+    private static final int MINOR;
+    private static final int BUGFIX;
+    static {
+        String kernelVersion = Native.kernelVersion();
+        int index = kernelVersion.indexOf('-');
+        if (index > -1) {
+            kernelVersion = kernelVersion.substring(0, index);
+        }
+        String[] versionParts = StringUtil.split(kernelVersion, '.');
+        if (versionParts.length <= 3) {
+            MAJOR = Integer.parseInt(versionParts[0]);
+            MINOR = Integer.parseInt(versionParts[1]);
+            if (versionParts.length == 3) {
+                BUGFIX = Integer.parseInt(versionParts[2]);
+            } else {
+                BUGFIX = 0;
+            }
+        } else {
+            throw new IllegalStateException("Can not parse kernel version " + kernelVersion);
+        }
+    }
+
+    @Test
+    public void testMultipleBindSocketChannelWithoutReusePortFails() {
+        Assume.assumeTrue(versionEqOrGt(3, 9, 0));
+        testMultipleBindDatagramChannelWithoutReusePortFails0(createServerBootstrap());
+    }
+
+    @Test
+    public void testMultipleBindDatagramChannelWithoutReusePortFails() {
+        Assume.assumeTrue(versionEqOrGt(3, 9, 0));
+        testMultipleBindDatagramChannelWithoutReusePortFails0(createBootstrap());
+    }
+
+    private static void testMultipleBindDatagramChannelWithoutReusePortFails0(AbstractBootstrap<?, ?> bootstrap) {
+        bootstrap.handler(new DummyHandler());
+        ChannelFuture future = bootstrap.bind().syncUninterruptibly();
+        try {
+            bootstrap.bind().syncUninterruptibly();
+            Assert.fail();
+        } catch (Exception e) {
+            Assert.assertTrue(e instanceof IOException);
+        }
+        future.channel().close().syncUninterruptibly();
+    }
+
+    @Test(timeout = 10000)
+    public void testMultipleBindSocketChannel() throws Exception {
+        Assume.assumeTrue(versionEqOrGt(3, 9, 0));
+        ServerBootstrap bootstrap = createServerBootstrap();
+        bootstrap.option(EpollChannelOption.SO_REUSEPORT, true);
+        final AtomicBoolean accepted1 = new AtomicBoolean();
+        bootstrap.childHandler(new ServerSocketTestHandler(accepted1));
+        ChannelFuture future = bootstrap.bind().syncUninterruptibly();
+        InetSocketAddress address1 = (InetSocketAddress) future.channel().localAddress();
+
+        final AtomicBoolean accepted2 = new AtomicBoolean();
+        bootstrap.childHandler(new ServerSocketTestHandler(accepted2));
+        ChannelFuture future2 = bootstrap.bind().syncUninterruptibly();
+        InetSocketAddress address2 = (InetSocketAddress) future2.channel().localAddress();
+
+        Assert.assertEquals(address1, address2);
+        while (!accepted1.get() || !accepted2.get()) {
+            Socket socket = new Socket(address1.getAddress(), address1.getPort());
+            socket.setReuseAddress(true);
+            socket.close();
+        }
+        future.channel().close().syncUninterruptibly();
+        future2.channel().close().syncUninterruptibly();
+    }
+
+    @Test(timeout = 10000)
+    public void testMultipleBindDatagramChannel() throws Exception {
+        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.ADVANCED);
+        Assume.assumeTrue(versionEqOrGt(3, 9, 0));
+        Bootstrap bootstrap = createBootstrap();
+        bootstrap.option(EpollChannelOption.SO_REUSEPORT, true);
+        final AtomicBoolean received1 = new AtomicBoolean();
+        bootstrap.handler(new DatagramSocketTestHandler(received1));
+        ChannelFuture future = bootstrap.bind().syncUninterruptibly();
+        final InetSocketAddress address1 = (InetSocketAddress) future.channel().localAddress();
+
+        final AtomicBoolean received2 = new AtomicBoolean();
+        bootstrap.handler(new DatagramSocketTestHandler(received2));
+        ChannelFuture future2 = bootstrap.bind().syncUninterruptibly();
+        final InetSocketAddress address2 = (InetSocketAddress) future2.channel().localAddress();
+
+        Assert.assertEquals(address1, address2);
+        final byte[] bytes = "data".getBytes();
+
+        // fire up 16 Threads and send DatagramPackets to make sure we stress it enough to see DatagramPackets received
+        // on both sockets.
+        int count = 16;
+        final CountDownLatch latch = new CountDownLatch(count);
+        Runnable r = new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    DatagramSocket socket = new DatagramSocket();
+                    while (!received1.get() || !received2.get()) {
+                        socket.send(new DatagramPacket(
+                                bytes, 0, bytes.length, address1.getAddress(), address1.getPort()));
+                    }
+                    socket.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+                latch.countDown();
+            }
+        };
+
+        ExecutorService executor = Executors.newFixedThreadPool(count);
+        for (int i = 0 ; i < count; i++) {
+            executor.execute(r);
+        }
+        latch.await();
+        executor.shutdown();
+        future.channel().close().syncUninterruptibly();
+        future2.channel().close().syncUninterruptibly();
+        Assert.assertTrue(received1.get());
+        Assert.assertTrue(received2.get());
+    }
+
+    private static ServerBootstrap createServerBootstrap() {
+        ServerBootstrap bootstrap = new ServerBootstrap();
+        bootstrap.group(EpollSocketTestPermutation.EPOLL_BOSS_GROUP, EpollSocketTestPermutation.EPOLL_WORKER_GROUP);
+        bootstrap.channel(EpollServerSocketChannel.class);
+        bootstrap.childHandler(new DummyHandler());
+        InetSocketAddress address = new InetSocketAddress(NetUtil.LOCALHOST, TestUtils.getFreePort());
+        bootstrap.localAddress(address);
+        return bootstrap;
+    }
+
+    private static Bootstrap createBootstrap() {
+        Bootstrap bootstrap = new Bootstrap();
+        bootstrap.group(EpollSocketTestPermutation.EPOLL_WORKER_GROUP);
+        bootstrap.channel(EpollDatagramChannel.class);
+        InetSocketAddress address = new InetSocketAddress(NetUtil.LOCALHOST, TestUtils.getFreePort());
+        bootstrap.localAddress(address);
+        return bootstrap;
+    }
+
+    private static boolean versionEqOrGt(int major, int minor, int bugfix)  {
+        if (MAJOR > major) {
+            return true;
+        }
+        if (MAJOR == major) {
+            if (MINOR > minor) {
+                return true;
+            } else if (MINOR == minor) {
+                if (BUGFIX >= bugfix) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    @ChannelHandler.Sharable
+    private static class ServerSocketTestHandler extends ChannelInboundHandlerAdapter {
+        private final AtomicBoolean accepted;
+
+        ServerSocketTestHandler(AtomicBoolean accepted) {
+            this.accepted = accepted;
+        }
+
+        @Override
+        public void channelActive(ChannelHandlerContext ctx) throws Exception {
+            accepted.set(true);
+            ctx.close();
+        }
+    }
+
+    @ChannelHandler.Sharable
+    private static class DatagramSocketTestHandler extends ChannelInboundHandlerAdapter {
+        private final AtomicBoolean received;
+
+        DatagramSocketTestHandler(AtomicBoolean received) {
+            this.received = received;
+        }
+
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            ReferenceCountUtil.release(msg);
+            received.set(true);
+        }
+    }
+
+    @ChannelHandler.Sharable
+    private static final class DummyHandler extends ChannelHandlerAdapter { }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketEchoTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketEchoTest.java
new file mode 100644
index 000000000000..e193aad087f3
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketEchoTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketEchoTest;
+
+import java.util.List;
+
+public class EpollSocketEchoTest extends SocketEchoTest {
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketFileRegionTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketFileRegionTest.java
new file mode 100644
index 000000000000..c46fce3f47e4
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketFileRegionTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketFileRegionTest;
+
+import java.util.List;
+
+public class EpollSocketFileRegionTest extends SocketFileRegionTest {
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketFixedLengthEchoTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketFixedLengthEchoTest.java
new file mode 100644
index 000000000000..fc93dcb908e7
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketFixedLengthEchoTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketFixedLengthEchoTest;
+
+import java.util.List;
+
+public class EpollSocketFixedLengthEchoTest extends SocketFixedLengthEchoTest {
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketGatheringWriteTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketGatheringWriteTest.java
new file mode 100644
index 000000000000..311efcaf75b0
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketGatheringWriteTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketGatheringWriteTest;
+
+import java.util.List;
+
+public class EpollSocketGatheringWriteTest extends SocketGatheringWriteTest {
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketObjectEchoTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketObjectEchoTest.java
new file mode 100644
index 000000000000..bf1fd0a5d33c
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketObjectEchoTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketObjectEchoTest;
+
+import java.util.List;
+
+public class EpollSocketObjectEchoTest extends SocketObjectEchoTest {
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketSslEchoTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketSslEchoTest.java
new file mode 100644
index 000000000000..06e01f922929
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketSslEchoTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.handler.ssl.SslContext;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketSslEchoTest;
+
+import java.util.List;
+
+public class EpollSocketSslEchoTest extends SocketSslEchoTest {
+
+    public EpollSocketSslEchoTest(
+            SslContext serverCtx, SslContext clientCtx,
+            boolean serverUsesDelegatedTaskExecutor, boolean clientUsesDelegatedTaskExecutor,
+            boolean useChunkedWriteHandler, boolean useCompositeByteBuf) {
+        super(
+                serverCtx, clientCtx,
+                serverUsesDelegatedTaskExecutor, clientUsesDelegatedTaskExecutor,
+                useChunkedWriteHandler, useCompositeByteBuf);
+    }
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketSslGreetingTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketSslGreetingTest.java
new file mode 100644
index 000000000000..21d86b4fc7fb
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketSslGreetingTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.handler.ssl.SslContext;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketSslGreetingTest;
+
+import java.util.List;
+
+public class EpollSocketSslGreetingTest extends SocketSslGreetingTest {
+
+    public EpollSocketSslGreetingTest(SslContext serverCtx, SslContext clientCtx) {
+        super(serverCtx, clientCtx);
+    }
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketStartTlsTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketStartTlsTest.java
new file mode 100644
index 000000000000..8d92e870e4a4
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketStartTlsTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.handler.ssl.SslContext;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketStartTlsTest;
+
+import java.util.List;
+
+public class EpollSocketStartTlsTest extends SocketStartTlsTest {
+
+    public EpollSocketStartTlsTest(SslContext serverCtx, SslContext clientCtx) {
+        super(serverCtx, clientCtx);
+    }
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketStringEchoTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketStringEchoTest.java
new file mode 100644
index 000000000000..d01346c1629f
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketStringEchoTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketStringEchoTest;
+
+import java.util.List;
+
+public class EpollSocketStringEchoTest extends SocketStringEchoTest {
+
+    @Override
+    protected List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.socket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTestPermutation.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTestPermutation.java
new file mode 100644
index 000000000000..6d56c6b89196
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTestPermutation.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ChannelFactory;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.socket.InternetProtocolFamily;
+import io.netty.channel.socket.nio.NioDatagramChannel;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.TestsuitePermutation.BootstrapFactory;
+import io.netty.testsuite.transport.socket.SocketTestPermutation;
+import io.netty.util.concurrent.DefaultThreadFactory;
+
+import java.util.Arrays;
+import java.util.List;
+
+class EpollSocketTestPermutation extends SocketTestPermutation {
+
+    static final SocketTestPermutation INSTANCE = new EpollSocketTestPermutation();
+
+    static final EventLoopGroup EPOLL_BOSS_GROUP =
+            new EpollEventLoopGroup(BOSSES, new DefaultThreadFactory("testsuite-epoll-boss", true));
+    static final EventLoopGroup EPOLL_WORKER_GROUP =
+            new EpollEventLoopGroup(WORKERS, new DefaultThreadFactory("testsuite-epoll-worker", true));
+
+    @Override
+    public List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> socket() {
+
+        List<TestsuitePermutation.BootstrapComboFactory<ServerBootstrap, Bootstrap>> list =
+                combo(serverSocket(), clientSocket());
+
+        list.remove(list.size() - 1); // Exclude NIO x NIO test
+
+        return list;
+    }
+
+    @Override
+    public List<BootstrapFactory<ServerBootstrap>> serverSocket() {
+        return Arrays.asList(
+                new BootstrapFactory<ServerBootstrap>() {
+                    @Override
+                    public ServerBootstrap newInstance() {
+                        return new ServerBootstrap().group(EPOLL_BOSS_GROUP, EPOLL_WORKER_GROUP)
+                                .channel(EpollServerSocketChannel.class);
+                    }
+                },
+                new BootstrapFactory<ServerBootstrap>() {
+                    @Override
+                    public ServerBootstrap newInstance() {
+                        return new ServerBootstrap().group(nioBossGroup, nioWorkerGroup)
+                                .channel(NioServerSocketChannel.class);
+                    }
+                }
+        );
+    }
+
+    @Override
+    public List<BootstrapFactory<Bootstrap>> clientSocket() {
+        return Arrays.asList(
+                new BootstrapFactory<Bootstrap>() {
+                    @Override
+                    public Bootstrap newInstance() {
+                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollSocketChannel.class);
+                    }
+                },
+                new BootstrapFactory<Bootstrap>() {
+                    @Override
+                    public Bootstrap newInstance() {
+                        return new Bootstrap().group(nioWorkerGroup).channel(NioSocketChannel.class);
+                    }
+                }
+        );
+    }
+
+    @Override
+    public List<TestsuitePermutation.BootstrapComboFactory<Bootstrap, Bootstrap>> datagram() {
+        // Make the list of Bootstrap factories.
+        List<BootstrapFactory<Bootstrap>> bfs = Arrays.asList(
+                new BootstrapFactory<Bootstrap>() {
+                    @Override
+                    public Bootstrap newInstance() {
+                        return new Bootstrap().group(nioWorkerGroup).channelFactory(new ChannelFactory<Channel>() {
+                            @Override
+                            public Channel newChannel() {
+                                return new NioDatagramChannel(InternetProtocolFamily.IPv4);
+                            }
+
+                            @Override
+                            public String toString() {
+                                return NioDatagramChannel.class.getSimpleName() + ".class";
+                            }
+                        });
+                    }
+                },
+                new BootstrapFactory<Bootstrap>() {
+                    @Override
+                    public Bootstrap newInstance() {
+                        return new Bootstrap().group(EPOLL_WORKER_GROUP).channel(EpollDatagramChannel.class);
+                    }
+                }
+        );
+        return combo(bfs, bfs);
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollTest.java
new file mode 100644
index 000000000000..a2d4fb2d407a
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollTest.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class EpollTest {
+
+    @Test
+    public void testIsAvailable() {
+        Assert.assertTrue(Epoll.isAvailable());
+    }
+}
diff --git a/transport-rxtx/pom.xml b/transport-rxtx/pom.xml
index 2179bea85308..076e23a26beb 100644
--- a/transport-rxtx/pom.xml
+++ b/transport-rxtx/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-transport-rxtx</artifactId>
diff --git a/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java
index a635505b9ade..3d784e3e8f05 100644
--- a/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java
+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java
@@ -39,7 +39,7 @@ final class DefaultRxtxChannelConfig extends DefaultChannelConfig implements Rxt
     private volatile int waitTime;
     private volatile int readTimeout = 1000;
 
-    public DefaultRxtxChannelConfig(RxtxChannel channel) {
+    DefaultRxtxChannelConfig(RxtxChannel channel) {
         super(channel);
     }
 
diff --git a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java
index f8371a0a32fc..8df3d10cc8c5 100644
--- a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java
+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java
@@ -65,7 +65,7 @@ protected void doConnect(SocketAddress remoteAddress, SocketAddress localAddress
         RxtxDeviceAddress remote = (RxtxDeviceAddress) remoteAddress;
         final CommPortIdentifier cpi = CommPortIdentifier.getPortIdentifier(remote.value());
         final CommPort commPort = cpi.open(getClass().getName(), 1000);
-
+        commPort.enableReceiveTimeout(config().getOption(READ_TIMEOUT));
         deviceAddress = remote;
 
         serialPort = (SerialPort) commPort;
diff --git a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java
index adf6f042c701..3d51f13fed63 100644
--- a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java
+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java
@@ -20,36 +20,23 @@
 import io.netty.channel.rxtx.RxtxChannelConfig.Paritybit;
 import io.netty.channel.rxtx.RxtxChannelConfig.Stopbits;
 
+import static io.netty.channel.ChannelOption.*;
+
 /**
  * Option for configuring a serial port connection
  */
-public final class RxtxChannelOption<T> extends ChannelOption<T> {
-    public static final RxtxChannelOption<Integer> BAUD_RATE =
-            new RxtxChannelOption<Integer>("BAUD_RATE");
-
-    public static final RxtxChannelOption<Boolean> DTR =
-            new RxtxChannelOption<Boolean>("DTR");
-
-    public static final RxtxChannelOption<Boolean> RTS =
-            new RxtxChannelOption<Boolean>("RTS");
-
-    public static final RxtxChannelOption<Stopbits> STOP_BITS =
-            new RxtxChannelOption<Stopbits>("STOP_BITS");
-
-    public static final RxtxChannelOption<Databits> DATA_BITS =
-            new RxtxChannelOption<Databits>("DATA_BITS");
-
-    public static final RxtxChannelOption<Paritybit> PARITY_BIT =
-            new RxtxChannelOption<Paritybit>("PARITY_BIT");
+public final class RxtxChannelOption {
 
-    public static final RxtxChannelOption<Integer> WAIT_TIME =
-            new RxtxChannelOption<Integer>("WAIT_TIME");
+    private static final Class<RxtxChannelOption> T = RxtxChannelOption.class;
 
-    public static final RxtxChannelOption<Integer> READ_TIMEOUT =
-            new RxtxChannelOption<Integer>("READ_TIMEOUT");
+    public static final ChannelOption<Integer> BAUD_RATE = valueOf(T, "BAUD_RATE");
+    public static final ChannelOption<Boolean> DTR = valueOf(T, "DTR");
+    public static final ChannelOption<Boolean> RTS = valueOf(T, "RTS");
+    public static final ChannelOption<Stopbits> STOP_BITS = valueOf(T, "STOP_BITS");
+    public static final ChannelOption<Databits> DATA_BITS = valueOf(T, "DATA_BITS");
+    public static final ChannelOption<Paritybit> PARITY_BIT = valueOf(T, "PARITY_BIT");
+    public static final ChannelOption<Integer> WAIT_TIME = valueOf(T, "WAIT_TIME");
+    public static final ChannelOption<Integer> READ_TIMEOUT = valueOf(T, "READ_TIMEOUT");
 
-    @SuppressWarnings("deprecation")
-    private RxtxChannelOption(String name) {
-        super(name);
-    }
+    private RxtxChannelOption() { }
 }
diff --git a/transport-sctp/pom.xml b/transport-sctp/pom.xml
index d48ebd7500b7..5616c201e58c 100644
--- a/transport-sctp/pom.xml
+++ b/transport-sctp/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-transport-sctp</artifactId>
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
index 932e09ca3a95..9bf6e54c6ab0 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
@@ -29,6 +29,7 @@
 import java.io.IOException;
 import java.util.Map;
 
+import static io.netty.channel.ChannelOption.*;
 import static io.netty.channel.sctp.SctpChannelOption.*;
 
 /**
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java
index efad6eb722aa..aadef72d2d1d 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java
@@ -16,6 +16,8 @@
 package io.netty.channel.sctp;
 
 import com.sun.nio.sctp.SctpServerChannel;
+import com.sun.nio.sctp.SctpStandardSocketOptions;
+import com.sun.nio.sctp.SctpStandardSocketOptions.InitMaxStreams;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
@@ -27,8 +29,6 @@
 import java.io.IOException;
 import java.util.Map;
 
-import static com.sun.nio.sctp.SctpStandardSocketOptions.*;
-
 /**
  * The default {@link SctpServerChannelConfig} implementation for SCTP.
  */
@@ -76,7 +76,7 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
             setReceiveBufferSize((Integer) value);
         } else if (option == ChannelOption.SO_SNDBUF) {
             setSendBufferSize((Integer) value);
-        } else if (option == SCTP_INIT_MAXSTREAMS) {
+        } else if (option == SctpChannelOption.SCTP_INIT_MAXSTREAMS) {
             setInitMaxStreams((InitMaxStreams) value);
         } else {
             return super.setOption(option, value);
@@ -88,7 +88,7 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
     @Override
     public int getSendBufferSize() {
         try {
-            return javaChannel.getOption(SO_SNDBUF);
+            return javaChannel.getOption(SctpStandardSocketOptions.SO_SNDBUF);
         } catch (IOException e) {
             throw new ChannelException(e);
         }
@@ -97,7 +97,7 @@ public int getSendBufferSize() {
     @Override
     public SctpServerChannelConfig setSendBufferSize(int sendBufferSize) {
         try {
-            javaChannel.setOption(SO_SNDBUF, sendBufferSize);
+            javaChannel.setOption(SctpStandardSocketOptions.SO_SNDBUF, sendBufferSize);
         } catch (IOException e) {
             throw new ChannelException(e);
         }
@@ -107,7 +107,7 @@ public SctpServerChannelConfig setSendBufferSize(int sendBufferSize) {
     @Override
     public int getReceiveBufferSize() {
         try {
-            return javaChannel.getOption(SO_RCVBUF);
+            return javaChannel.getOption(SctpStandardSocketOptions.SO_RCVBUF);
         } catch (IOException e) {
             throw new ChannelException(e);
         }
@@ -116,7 +116,7 @@ public int getReceiveBufferSize() {
     @Override
     public SctpServerChannelConfig setReceiveBufferSize(int receiveBufferSize) {
         try {
-            javaChannel.setOption(SO_RCVBUF, receiveBufferSize);
+            javaChannel.setOption(SctpStandardSocketOptions.SO_RCVBUF, receiveBufferSize);
         } catch (IOException e) {
             throw new ChannelException(e);
         }
@@ -126,7 +126,7 @@ public SctpServerChannelConfig setReceiveBufferSize(int receiveBufferSize) {
     @Override
     public InitMaxStreams getInitMaxStreams() {
         try {
-            return javaChannel.getOption(SCTP_INIT_MAXSTREAMS);
+            return javaChannel.getOption(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS);
         } catch (IOException e) {
             throw new ChannelException(e);
         }
@@ -135,7 +135,7 @@ public InitMaxStreams getInitMaxStreams() {
     @Override
     public SctpServerChannelConfig setInitMaxStreams(InitMaxStreams initMaxStreams) {
         try {
-            javaChannel.setOption(SCTP_INIT_MAXSTREAMS, initMaxStreams);
+            javaChannel.setOption(SctpStandardSocketOptions.SCTP_INIT_MAXSTREAMS, initMaxStreams);
         } catch (IOException e) {
             throw new ChannelException(e);
         }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
index 5056bfb3f854..206f1cdc04c2 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
@@ -18,6 +18,7 @@
 import com.sun.nio.sctp.SctpStandardSocketOptions.InitMaxStreams;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
+import io.netty.channel.ChannelOption;
 import io.netty.channel.MessageSizeEstimator;
 import io.netty.channel.RecvByteBufAllocator;
 
@@ -33,11 +34,11 @@
  * <tr>
  * <th>Name</th><th>Associated setter method</th>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SCTP_NODELAY}</td><td>{@link #setSctpNoDelay(boolean)}}</td>
+ * <td>{@link ChannelOption#SO_RCVBUF}</td><td>{@link #setReceiveBufferSize(int)}</td>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SO_RCVBUF}</td><td>{@link #setReceiveBufferSize(int)}</td>
+ * <td>{@link ChannelOption#SO_SNDBUF}</td><td>{@link #setSendBufferSize(int)}</td>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SO_SNDBUF}</td><td>{@link #setSendBufferSize(int)}</td>
+ * <td>{@link SctpChannelOption#SCTP_NODELAY}</td><td>{@link #setSctpNoDelay(boolean)}}</td>
  * </tr><tr>
  * <td>{@link SctpChannelOption#SCTP_INIT_MAXSTREAMS}</td><td>{@link #setInitMaxStreams(InitMaxStreams)}</td>
  * </tr>
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java
index 88700d180417..7e171e72caa2 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java
@@ -15,37 +15,29 @@
  */
 package io.netty.channel.sctp;
 
-import com.sun.nio.sctp.SctpStandardSocketOptions;
+import com.sun.nio.sctp.SctpStandardSocketOptions.InitMaxStreams;
 import io.netty.channel.ChannelOption;
 
 import java.net.SocketAddress;
 
+import static io.netty.channel.ChannelOption.*;
+
 /**
  * Option for configuring the SCTP transport
  */
-@SuppressWarnings("deprecation")
-public class SctpChannelOption<T> extends ChannelOption<T> {
-    public static final SctpChannelOption<Boolean> SCTP_DISABLE_FRAGMENTS =
-            new SctpChannelOption<Boolean>("SCTP_DISABLE_FRAGMENTS");
-    public static final SctpChannelOption<Boolean> SCTP_EXPLICIT_COMPLETE =
-            new SctpChannelOption<Boolean>("SCTP_EXPLICIT_COMPLETE");
-    public static final SctpChannelOption<Integer> SCTP_FRAGMENT_INTERLEAVE =
-            new SctpChannelOption<Integer>("SCTP_FRAGMENT_INTERLEAVE");
-    public static final SctpChannelOption<SctpStandardSocketOptions.InitMaxStreams> SCTP_INIT_MAXSTREAMS =
-            new SctpChannelOption<SctpStandardSocketOptions.InitMaxStreams>("SCTP_INIT_MAXSTREAMS");
-
-    public static final SctpChannelOption<Boolean> SCTP_NODELAY =
-            new SctpChannelOption<Boolean>("SCTP_NODELAY");
-    public static final SctpChannelOption<SocketAddress> SCTP_PRIMARY_ADDR =
-            new SctpChannelOption<SocketAddress>("SCTP_PRIMARY_ADDR");
-    public static final SctpChannelOption<SocketAddress> SCTP_SET_PEER_PRIMARY_ADDR =
-            new SctpChannelOption<SocketAddress>("SCTP_SET_PEER_PRIMARY_ADDR");
-
-    /**
-     * @deprecated Will be removed in the future release.
-     */
-    @Deprecated
-    protected SctpChannelOption(String name) {
-        super(name);
-    }
+public final class SctpChannelOption {
+
+    private static final Class<SctpChannelOption> T = SctpChannelOption.class;
+
+    public static final ChannelOption<Boolean> SCTP_DISABLE_FRAGMENTS = valueOf(T, "SCTP_DISABLE_FRAGMENTS");
+    public static final ChannelOption<Boolean> SCTP_EXPLICIT_COMPLETE = valueOf(T, "SCTP_EXPLICIT_COMPLETE");
+    public static final ChannelOption<Integer> SCTP_FRAGMENT_INTERLEAVE = valueOf(T, "SCTP_FRAGMENT_INTERLEAVE");
+    public static final ChannelOption<InitMaxStreams> SCTP_INIT_MAXSTREAMS = valueOf(T, "SCTP_INIT_MAXSTREAMS");
+
+    public static final ChannelOption<Boolean> SCTP_NODELAY = valueOf(T, "SCTP_NODELAY");
+    public static final ChannelOption<SocketAddress> SCTP_PRIMARY_ADDR = valueOf(T, "SCTP_PRIMARY_ADDR");
+    public static final ChannelOption<SocketAddress> SCTP_SET_PEER_PRIMARY_ADDR =
+            valueOf(T, "SCTP_SET_PEER_PRIMARY_ADDR");
+
+    private SctpChannelOption() { }
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
index 6938f3bb3dde..221a159e3827 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
@@ -111,11 +111,7 @@ public boolean equals(Object o) {
             return false;
         }
 
-        if (!content().equals(sctpFrame.content())) {
-            return false;
-        }
-
-        return true;
+        return content().equals(sctpFrame.content());
     }
 
     @Override
@@ -156,6 +152,18 @@ public SctpMessage retain(int increment) {
         return this;
     }
 
+    @Override
+    public SctpMessage touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public SctpMessage touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+
     @Override
     public String toString() {
         if (refCnt() == 0) {
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
index 3120ad3a5653..e29f351c6b44 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
@@ -18,6 +18,7 @@
 import com.sun.nio.sctp.SctpStandardSocketOptions.InitMaxStreams;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
+import io.netty.channel.ChannelOption;
 import io.netty.channel.MessageSizeEstimator;
 import io.netty.channel.RecvByteBufAllocator;
 
@@ -34,11 +35,11 @@
  * <tr>
  * <th>Name</th><th>Associated setter method</th>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SO_BACKLOG}</td><td>{@link #setBacklog(int)}</td>
+ * <td>{@link ChannelOption#SO_BACKLOG}</td><td>{@link #setBacklog(int)}</td>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SO_RCVBUF}</td><td>{@link #setReceiveBufferSize(int)}</td>
+ * <td>{@link ChannelOption#SO_RCVBUF}</td><td>{@link #setReceiveBufferSize(int)}</td>
  * </tr><tr>
- * <td>{@link SctpChannelOption#SO_SNDBUF}</td><td>{@link #setSendBufferSize(int)}</td>
+ * <td>{@link ChannelOption#SO_SNDBUF}</td><td>{@link #setSendBufferSize(int)}</td>
  * </tr><tr>
  * <td>{@link SctpChannelOption#SCTP_INIT_MAXSTREAMS}</td><td>{@link #setInitMaxStreams(InitMaxStreams)}</td>
  * </tr>
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
index b0ef61007f7e..cdf93de001be 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
@@ -20,7 +20,7 @@
 import com.sun.nio.sctp.NotificationHandler;
 import com.sun.nio.sctp.SctpChannel;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.AbstractChannel;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
@@ -34,6 +34,7 @@
 import io.netty.channel.sctp.SctpMessage;
 import io.netty.channel.sctp.SctpNotificationHandler;
 import io.netty.channel.sctp.SctpServerChannel;
+import io.netty.util.Recycler;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -102,7 +103,7 @@ public NioSctpChannel(Channel parent, SctpChannel sctpChannel) {
         super(parent, sctpChannel, SelectionKey.OP_READ);
         try {
             sctpChannel.configureBlocking(false);
-            config = new DefaultSctpChannelConfig(this, sctpChannel);
+            config = new NioSctpChannelConfig(this, sctpChannel);
             notificationHandler = new SctpNotificationHandler(this);
         } catch (IOException e) {
             try {
@@ -142,7 +143,7 @@ public ChannelMetadata metadata() {
     public Association association() {
         try {
             return javaChannel().association();
-        } catch (IOException e) {
+        } catch (IOException ignored) {
             return null;
         }
     }
@@ -156,7 +157,7 @@ public Set<InetSocketAddress> allLocalAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }
@@ -175,7 +176,7 @@ public Set<InetSocketAddress> allRemoteAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }
@@ -278,7 +279,7 @@ protected int doReadMessages(List<Object> buf) throws Exception {
             if (messageInfo == null) {
                 return 0;
             }
-            buf.add(new SctpMessage(messageInfo, buffer.writerIndex(buffer.writerIndex() + (data.position() - pos))));
+            buf.add(new SctpMessage(messageInfo, buffer.writerIndex(buffer.writerIndex() + data.position() - pos)));
             free = false;
             return 1;
         } catch (Throwable cause) {
@@ -302,20 +303,7 @@ protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Ex
             return true;
         }
 
-        ByteBufAllocator alloc = alloc();
-        boolean needsCopy = data.nioBufferCount() != 1;
-        if (!needsCopy) {
-            if (!data.isDirect() && alloc.isDirectBufferPooled()) {
-                needsCopy = true;
-            }
-        }
-        ByteBuffer nioData;
-        if (!needsCopy) {
-            nioData = data.nioBuffer();
-        } else {
-            data = alloc.directBuffer(dataLen).writeBytes(data);
-            nioData = data.nioBuffer();
-        }
+        ByteBuffer nioData = data.nioBuffer();
 
         final MessageInfo mi = MessageInfo.createOutgoing(association(), null, packet.streamIdentifier());
         mi.payloadProtocolID(packet.protocolIdentifier());
@@ -323,15 +311,7 @@ protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Ex
 
         final int writtenBytes = javaChannel().send(nioData, mi);
 
-        boolean done = writtenBytes > 0;
-        if (needsCopy) {
-            if (!done) {
-                in.current(new SctpMessage(mi, data));
-            } else {
-                in.current(data);
-            }
-        }
-        return done;
+        return writtenBytes > 0;
     }
 
     @Override
@@ -383,4 +363,53 @@ public void run() {
         }
         return promise;
     }
+
+    @Override
+    protected ChannelOutboundBuffer newOutboundBuffer() {
+        return NioSctpChannelOutboundBuffer.newInstance(this);
+    }
+
+    static final class NioSctpChannelOutboundBuffer extends ChannelOutboundBuffer {
+        private static final Recycler<NioSctpChannelOutboundBuffer> RECYCLER =
+                new Recycler<NioSctpChannelOutboundBuffer>() {
+                    @Override
+                    protected NioSctpChannelOutboundBuffer newObject(Handle<NioSctpChannelOutboundBuffer> handle) {
+                        return new NioSctpChannelOutboundBuffer(handle);
+                    }
+                };
+
+        static NioSctpChannelOutboundBuffer newInstance(AbstractChannel channel) {
+            NioSctpChannelOutboundBuffer buffer = RECYCLER.get();
+            buffer.channel = channel;
+            return buffer;
+        }
+
+        private NioSctpChannelOutboundBuffer(Recycler.Handle<NioSctpChannelOutboundBuffer> handle) {
+            super(handle);
+        }
+
+        @Override
+        protected Object beforeAdd(Object msg) {
+            if (msg instanceof SctpMessage) {
+                SctpMessage message = (SctpMessage) msg;
+                ByteBuf content = message.content();
+                if (!content.isDirect() || content.nioBufferCount() != 1) {
+                    ByteBuf direct = copyToDirectByteBuf(content);
+                    return new SctpMessage(message.protocolIdentifier(), message.streamIdentifier(), direct);
+                }
+            }
+            return msg;
+        }
+    }
+
+    private final class NioSctpChannelConfig extends DefaultSctpChannelConfig {
+        private NioSctpChannelConfig(NioSctpChannel channel, SctpChannel javaChannel) {
+            super(channel, javaChannel);
+        }
+
+        @Override
+        protected void autoReadCleared() {
+            setReadPending(false);
+        }
+    }
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
index d5d578b8bf00..568a06ed723b 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
@@ -64,7 +64,7 @@ private static SctpServerChannel newSocket() {
      */
     public NioSctpServerChannel() {
         super(null, newSocket(), SelectionKey.OP_ACCEPT);
-        config = new DefaultSctpServerChannelConfig(this, javaChannel());
+        config = new NioSctpServerChannelConfig(this, javaChannel());
     }
 
     @Override
@@ -81,7 +81,7 @@ public Set<InetSocketAddress> allLocalAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }
@@ -220,4 +220,15 @@ protected void doDisconnect() throws Exception {
     protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Exception {
         throw new UnsupportedOperationException();
     }
+
+    private final class NioSctpServerChannelConfig extends DefaultSctpServerChannelConfig {
+        private NioSctpServerChannelConfig(NioSctpServerChannel channel, SctpServerChannel javaChannel) {
+            super(channel, javaChannel);
+        }
+
+        @Override
+        protected void autoReadCleared() {
+            setReadPending(false);
+        }
+    }
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
index 58c0f666aab6..227a3a126ad2 100755
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
@@ -121,7 +121,7 @@ public OioSctpChannel(Channel parent, SctpChannel ch) {
             ch.register(writeSelector, SelectionKey.OP_WRITE);
             ch.register(connectSelector, SelectionKey.OP_CONNECT);
 
-            config = new DefaultSctpChannelConfig(this, ch);
+            config = new OioSctpChannelConfig(this, ch);
             notificationHandler = new SctpNotificationHandler(this);
             success = true;
         } catch (Exception e) {
@@ -277,7 +277,7 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
     public Association association() {
         try {
             return ch.association();
-        } catch (IOException e) {
+        } catch (IOException ignored) {
             return null;
         }
     }
@@ -309,7 +309,7 @@ public Set<InetSocketAddress> allLocalAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }
@@ -336,7 +336,7 @@ public Set<InetSocketAddress> allRemoteAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }
@@ -448,4 +448,15 @@ public void run() {
         }
         return promise;
     }
+
+    private final class OioSctpChannelConfig extends DefaultSctpChannelConfig {
+        private OioSctpChannelConfig(OioSctpChannel channel, SctpChannel javaChannel) {
+            super(channel, javaChannel);
+        }
+
+        @Override
+        protected void autoReadCleared() {
+            setReadPending(false);
+        }
+    }
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
index f787e7304dbb..47af27adc430 100755
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
@@ -91,7 +91,7 @@ public OioSctpServerChannel(SctpServerChannel sch) {
             sch.configureBlocking(false);
             selector = Selector.open();
             sch.register(selector, SelectionKey.OP_ACCEPT);
-            config = new DefaultSctpServerChannelConfig(this, sch);
+            config = new OioSctpServerChannelConfig(this, sch);
             success = true;
         } catch (Exception e) {
             throw new ChannelException("failed to initialize a sctp server channel", e);
@@ -153,7 +153,7 @@ public Set<InetSocketAddress> allLocalAddresses() {
                 addresses.add((InetSocketAddress) socketAddress);
             }
             return addresses;
-        } catch (Throwable t) {
+        } catch (Throwable ignored) {
             return Collections.emptySet();
         }
     }
@@ -289,4 +289,15 @@ protected void doDisconnect() throws Exception {
     protected void doWrite(ChannelOutboundBuffer in) throws Exception {
         throw new UnsupportedOperationException();
     }
+
+    private final class OioSctpServerChannelConfig extends DefaultSctpServerChannelConfig {
+        private OioSctpServerChannelConfig(OioSctpServerChannel channel, SctpServerChannel javaChannel) {
+            super(channel, javaChannel);
+        }
+
+        @Override
+        protected void autoReadCleared() {
+            setReadPending(false);
+        }
+    }
 }
diff --git a/transport-udt/pom.xml b/transport-udt/pom.xml
index 8e93de580a29..485e9cf01910 100644
--- a/transport-udt/pom.xml
+++ b/transport-udt/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-transport-udt</artifactId>
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
index d488713a7994..05ca40cc6d87 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
@@ -27,6 +27,7 @@
 import java.io.IOException;
 import java.util.Map;
 
+import static io.netty.channel.ChannelOption.*;
 import static io.netty.channel.udt.UdtChannelOption.*;
 
 /**
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java b/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java
index 71d02296b09c..41a92a9c0f41 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java
@@ -18,37 +18,35 @@
 import com.barchart.udt.OptionUDT;
 import io.netty.channel.ChannelOption;
 
+import static io.netty.channel.ChannelOption.*;
+
 /**
  * Options for the UDT transport
  */
-public final class UdtChannelOption<T> extends ChannelOption<T> {
+public final class UdtChannelOption {
+
+    private static final Class<UdtChannelOption> T = UdtChannelOption.class;
 
     /**
      * See {@link OptionUDT#Protocol_Receive_Buffer_Size}.
      */
-    public static final UdtChannelOption<Integer> PROTOCOL_RECEIVE_BUFFER_SIZE = new UdtChannelOption<Integer>(
-            "PROTOCOL_RECEIVE_BUFFER_SIZE");
+    public static final ChannelOption<Integer> PROTOCOL_RECEIVE_BUFFER_SIZE =
+            valueOf(T, "PROTOCOL_RECEIVE_BUFFER_SIZE");
 
     /**
      * See {@link OptionUDT#Protocol_Send_Buffer_Size}.
      */
-    public static final UdtChannelOption<Integer> PROTOCOL_SEND_BUFFER_SIZE = new UdtChannelOption<Integer>(
-            "PROTOCOL_SEND_BUFFER_SIZE");
+    public static final ChannelOption<Integer> PROTOCOL_SEND_BUFFER_SIZE = valueOf(T, "PROTOCOL_SEND_BUFFER_SIZE");
 
     /**
      * See {@link OptionUDT#System_Receive_Buffer_Size}.
      */
-    public static final UdtChannelOption<Integer> SYSTEM_RECEIVE_BUFFER_SIZE = new UdtChannelOption<Integer>(
-            "SYSTEM_RECEIVE_BUFFER_SIZE");
+    public static final ChannelOption<Integer> SYSTEM_RECEIVE_BUFFER_SIZE = valueOf(T, "SYSTEM_RECEIVE_BUFFER_SIZE");
 
     /**
      * See {@link OptionUDT#System_Send_Buffer_Size}.
      */
-    public static final UdtChannelOption<Integer> SYSTEM_SEND_BUFFER_SIZE = new UdtChannelOption<Integer>(
-            "SYSTEM_SEND_BUFFER_SIZE");
+    public static final ChannelOption<Integer> SYSTEM_SEND_BUFFER_SIZE = valueOf(T, "SYSTEM_SEND_BUFFER_SIZE");
 
-    @SuppressWarnings("deprecation")
-    private UdtChannelOption(String name) {
-        super(name);
-    }
+    private UdtChannelOption() { }
 }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java b/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
index 6c3ff08fb329..d8662444beff 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
@@ -52,4 +52,16 @@ public UdtMessage retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public UdtMessage touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public UdtMessage touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
index fe17d789b8d3..de47a8b94ba5 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
@@ -142,8 +142,7 @@ protected int doReadBytes(final ByteBuf byteBuf) throws Exception {
     @Override
     protected int doWriteBytes(final ByteBuf byteBuf) throws Exception {
         final int expectedWrittenBytes = byteBuf.readableBytes();
-        final int writtenBytes = byteBuf.readBytes(javaChannel(), expectedWrittenBytes);
-        return writtenBytes;
+        return byteBuf.readBytes(javaChannel(), expectedWrittenBytes);
     }
 
     @Override
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageRendezvousChannel.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageRendezvousChannel.java
index b16e119b9f60..cade594f18da 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageRendezvousChannel.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageRendezvousChannel.java
@@ -23,11 +23,9 @@
  * <p>
  * Note: send/receive must use {@link UdtMessage} in the pipeline
  */
-public class NioUdtMessageRendezvousChannel extends
-        NioUdtMessageConnectorChannel {
+public class NioUdtMessageRendezvousChannel extends NioUdtMessageConnectorChannel {
 
     public NioUdtMessageRendezvousChannel() {
         super(NioUdtProvider.newRendezvousChannelUDT(TypeUDT.DATAGRAM));
     }
-
 }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java
index c2c8d001729c..095258f9c728 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java
@@ -128,35 +128,35 @@ public static ChannelUDT channelUDT(final Channel channel) {
     /**
      * Convenience factory for {@link KindUDT#ACCEPTOR} channels.
      */
-    protected static ServerSocketChannelUDT newAcceptorChannelUDT(
+    static ServerSocketChannelUDT newAcceptorChannelUDT(
             final TypeUDT type) {
         try {
             return SelectorProviderUDT.from(type).openServerSocketChannel();
         } catch (final IOException e) {
-            throw new ChannelException("Failed to open channel");
+            throw new ChannelException("failed to open a server socket channel", e);
         }
     }
 
     /**
      * Convenience factory for {@link KindUDT#CONNECTOR} channels.
      */
-    protected static SocketChannelUDT newConnectorChannelUDT(final TypeUDT type) {
+    static SocketChannelUDT newConnectorChannelUDT(final TypeUDT type) {
         try {
             return SelectorProviderUDT.from(type).openSocketChannel();
         } catch (final IOException e) {
-            throw new ChannelException("Failed to open channel");
+            throw new ChannelException("failed to open a socket channel", e);
         }
     }
 
     /**
      * Convenience factory for {@link KindUDT#RENDEZVOUS} channels.
      */
-    protected static RendezvousChannelUDT newRendezvousChannelUDT(
+    static RendezvousChannelUDT newRendezvousChannelUDT(
             final TypeUDT type) {
         try {
             return SelectorProviderUDT.from(type).openRendezvousChannel();
         } catch (final IOException e) {
-            throw new ChannelException("Failed to open channel");
+            throw new ChannelException("failed to open a rendezvous channel", e);
         }
     }
 
@@ -201,35 +201,35 @@ public KindUDT kind() {
     @Override
     public T newChannel() {
         switch (kind) {
-        case ACCEPTOR:
-            switch (type) {
-            case DATAGRAM:
-                return (T) new NioUdtMessageAcceptorChannel();
-            case STREAM:
-                return (T) new NioUdtByteAcceptorChannel();
+            case ACCEPTOR:
+                switch (type) {
+                    case DATAGRAM:
+                        return (T) new NioUdtMessageAcceptorChannel();
+                    case STREAM:
+                        return (T) new NioUdtByteAcceptorChannel();
+                    default:
+                        throw new IllegalStateException("wrong type=" + type);
+                }
+            case CONNECTOR:
+                switch (type) {
+                    case DATAGRAM:
+                        return (T) new NioUdtMessageConnectorChannel();
+                    case STREAM:
+                        return (T) new NioUdtByteConnectorChannel();
+                    default:
+                        throw new IllegalStateException("wrong type=" + type);
+                }
+            case RENDEZVOUS:
+                switch (type) {
+                    case DATAGRAM:
+                        return (T) new NioUdtMessageRendezvousChannel();
+                    case STREAM:
+                        return (T) new NioUdtByteRendezvousChannel();
+                    default:
+                        throw new IllegalStateException("wrong type=" + type);
+                }
             default:
-                throw new IllegalStateException("wrong type=" + type);
-            }
-        case CONNECTOR:
-            switch (type) {
-            case DATAGRAM:
-                return (T) new NioUdtMessageConnectorChannel();
-            case STREAM:
-                return (T) new NioUdtByteConnectorChannel();
-            default:
-                throw new IllegalStateException("wrong type=" + type);
-            }
-        case RENDEZVOUS:
-            switch (type) {
-            case DATAGRAM:
-                return (T) new NioUdtMessageRendezvousChannel();
-            case STREAM:
-                return (T) new NioUdtByteRendezvousChannel();
-            default:
-                throw new IllegalStateException("wrong type=" + type);
-            }
-        default:
-            throw new IllegalStateException("wrong kind=" + kind);
+                throw new IllegalStateException("wrong kind=" + kind);
         }
     }
 
@@ -239,5 +239,4 @@ public T newChannel() {
     public TypeUDT type() {
         return type;
     }
-
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
index 260187c5d1ef..2f4f4675a548 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
@@ -28,6 +28,6 @@ public class NioUdtByteAcceptorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(false, new NioUdtByteAcceptorChannel().metadata().hasDisconnect());
+        assertFalse(new NioUdtByteAcceptorChannel().metadata().hasDisconnect());
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
index 6426ca69ada7..f3ff6f50400e 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
@@ -19,7 +19,7 @@
 import io.netty.channel.udt.nio.NioUdtByteConnectorChannel;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 
 public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
 
@@ -28,6 +28,6 @@ public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(false, new NioUdtByteConnectorChannel().metadata().hasDisconnect());
+        assertFalse(new NioUdtByteConnectorChannel().metadata().hasDisconnect());
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
index a3099a8be194..165d92536d1d 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
@@ -28,6 +28,6 @@ public class NioUdtMessageAcceptorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(false, new NioUdtMessageAcceptorChannel().metadata().hasDisconnect());
+        assertFalse(new NioUdtMessageAcceptorChannel().metadata().hasDisconnect());
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
index 8c2e2df588f7..4e12eedec54e 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
@@ -28,6 +28,6 @@ public class NioUdtMessageConnectorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(false, new NioUdtMessageConnectorChannel().metadata().hasDisconnect());
+        assertFalse(new NioUdtMessageConnectorChannel().metadata().hasDisconnect());
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/util/CaliperMeasure.java b/transport-udt/src/test/java/io/netty/test/udt/util/CaliperMeasure.java
index dce20f1b592b..eb1a489f16a8 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/util/CaliperMeasure.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/util/CaliperMeasure.java
@@ -139,6 +139,7 @@ private static double filter(final double value) {
     /**
      * Perform measurement; convert from metrics into caliper.
      */
+    @SuppressWarnings("FloatingPointEquality")
     public void mark() {
         final double rateValue = filter(rate.oneMinuteRate());
         final double timeValue = filter(time.mean());
@@ -172,8 +173,7 @@ public Map<String, String> variables() {
 
     private static MeasurementSet measurementSet(final Map<Long, Measurement> map) {
         final Measurement[] array = map.values().toArray(new Measurement[map.size()]);
-        final MeasurementSet set = new MeasurementSet(array);
-        return set;
+        return new MeasurementSet(array);
     }
 
     /**
diff --git a/transport-udt/src/test/java/io/netty/test/udt/util/CaliperRunner.java b/transport-udt/src/test/java/io/netty/test/udt/util/CaliperRunner.java
index 970233f40197..819142f7ca57 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/util/CaliperRunner.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/util/CaliperRunner.java
@@ -202,18 +202,15 @@ public static void publish(final Result result) throws Exception {
     public static Run newRun(final String benchmarkName) {
         final Map<Scenario, ScenarioResult> measurements = new HashMap<Scenario, ScenarioResult>();
         final Date executedTimestamp = new Date();
-        final Run run = new Run(measurements, benchmarkName, executedTimestamp);
-        return run;
+        return new Run(measurements, benchmarkName, executedTimestamp);
     }
 
     /**
      * Make new result from run.
      */
     public static Result newResult(final Run run) {
-        final Environment env = new EnvironmentGetter()
-                .getEnvironmentSnapshot();
-        final Result result = new Result(run, env);
-        return result;
+        final Environment env = new EnvironmentGetter().getEnvironmentSnapshot();
+        return new Result(run, env);
     }
 
     /**
diff --git a/transport-udt/src/test/java/io/netty/test/udt/util/UnitHelp.java b/transport-udt/src/test/java/io/netty/test/udt/util/UnitHelp.java
index 7717168d3ff3..c4e79371f9cc 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/util/UnitHelp.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/util/UnitHelp.java
@@ -87,9 +87,7 @@ public static long ping(final String host) throws Exception {
 
         final long timeFinish = System.currentTimeMillis();
 
-        final long timeDiff = timeFinish - timeStart;
-
-        return timeDiff;
+        return timeFinish - timeStart;
     }
 
     /**
@@ -205,7 +203,7 @@ public static void logOsArch() {
      * Display contents of a set.
      */
     public static void logSet(final Set<?> set) {
-        @SuppressWarnings({ "rawtypes", "unchecked" })
+        @SuppressWarnings("unchecked")
         final TreeSet<?> treeSet = new TreeSet(set);
         for (final Object item : treeSet) {
             log.info("-> {}", item);
diff --git a/transport/pom.xml b/transport/pom.xml
index f12eae4e2e96..2777035ee9df 100644
--- a/transport/pom.xml
+++ b/transport/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.16.Final-SNAPSHOT</version>
+    <version>4.1.0.Beta1</version>
   </parent>
 
   <artifactId>netty-transport</artifactId>
diff --git a/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
index 4810d2f1a15b..411a86c0c8a0 100644
--- a/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
@@ -27,6 +27,7 @@
 import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.AttributeKey;
+import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.GlobalEventExecutor;
 import io.netty.util.internal.StringUtil;
 
@@ -281,7 +282,7 @@ private ChannelFuture doBind(final SocketAddress localAddress) {
             doBind0(regFuture, channel, localAddress, promise);
         } else {
             // Registration future is almost always fulfilled already, but just in case it's not.
-            promise = new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE);
+            promise = new PendingRegistrationPromise(channel);
             regFuture.addListener(new ChannelFutureListener() {
                 @Override
                 public void operationComplete(ChannelFuture future) throws Exception {
@@ -299,7 +300,8 @@ final ChannelFuture initAndRegister() {
             init(channel);
         } catch (Throwable t) {
             channel.unsafe().closeForcibly();
-            return channel.newFailedFuture(t);
+            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
+            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
         }
 
         ChannelFuture regFuture = group().register(channel);
@@ -313,7 +315,7 @@ final ChannelFuture initAndRegister() {
 
         // If we are here and the promise is not failed, it's one of the following cases:
         // 1) If we attempted registration from the event loop, the registration has been completed at this point.
-        //    i.e. It's safe to attempt bind() or connect() now beause the channel has been registered.
+        //    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.
         // 2) If we attempted registration from the other thread, the registration request has been successfully
         //    added to the event loop's task queue for later execution.
         //    i.e. It's safe to attempt bind() or connect() now:
@@ -451,4 +453,23 @@ public String toString() {
             return StringUtil.simpleClassName(clazz) + ".class";
         }
     }
+
+    private static final class PendingRegistrationPromise extends DefaultChannelPromise {
+        private PendingRegistrationPromise(Channel channel) {
+            super(channel);
+        }
+
+        @Override
+        protected EventExecutor executor() {
+            if (channel().isRegistered()) {
+                // If the registration was a success we can just call super.executor() which will return
+                // channel.eventLoop().
+                //
+                // See https://github.com/netty/netty/issues/2586
+                return super.executor();
+            }
+            // The registration failed so we can only use the GlobalEventExecutor as last resort to notify.
+            return GlobalEventExecutor.INSTANCE;
+        }
+    }
 }
diff --git a/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
index b1a9d1e64b7f..698fe63d84fa 100644
--- a/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
+++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
@@ -217,7 +217,6 @@ private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapte
         private final Entry<ChannelOption<?>, Object>[] childOptions;
         private final Entry<AttributeKey<?>, Object>[] childAttrs;
 
-        @SuppressWarnings("unchecked")
         ServerBootstrapAcceptor(
                 EventLoopGroup childGroup, ChannelHandler childHandler,
                 Entry<ChannelOption<?>, Object>[] childOptions, Entry<AttributeKey<?>, Object>[] childAttrs) {
@@ -277,7 +276,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
                 ctx.channel().eventLoop().schedule(new Runnable() {
                     @Override
                     public void run() {
-                       config.setAutoRead(true);
+                        config.setAutoRead(true);
                     }
                 }, 1, TimeUnit.SECONDS);
             }
diff --git a/transport/src/main/java/io/netty/channel/AbstractChannel.java b/transport/src/main/java/io/netty/channel/AbstractChannel.java
index deaf67a2a095..1845bfaca03c 100644
--- a/transport/src/main/java/io/netty/channel/AbstractChannel.java
+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java
@@ -19,8 +19,8 @@
 import io.netty.util.DefaultAttributeMap;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.OneTimeTask;
 import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.ThreadLocalRandom;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -50,7 +50,7 @@ public abstract class AbstractChannel extends DefaultAttributeMap implements Cha
     private MessageSizeEstimator.Handle estimatorHandle;
 
     private final Channel parent;
-    private final long hashCode = ThreadLocalRandom.current().nextLong();
+    private final ChannelId id;
     private final Unsafe unsafe;
     private final DefaultChannelPipeline pipeline;
     private final ChannelFuture succeededFuture = new SucceededChannelFuture(this, null);
@@ -75,10 +75,29 @@ public abstract class AbstractChannel extends DefaultAttributeMap implements Cha
      */
     protected AbstractChannel(Channel parent) {
         this.parent = parent;
+        id = DefaultChannelId.newInstance();
         unsafe = newUnsafe();
         pipeline = new DefaultChannelPipeline(this);
     }
 
+    /**
+     * Creates a new instance.
+     *
+     * @param parent
+     *        the parent of this channel. {@code null} if there's no parent.
+     */
+    protected AbstractChannel(Channel parent, ChannelId id) {
+        this.parent = parent;
+        this.id = id;
+        unsafe = newUnsafe();
+        pipeline = new DefaultChannelPipeline(this);
+    }
+
+    @Override
+    public final ChannelId id() {
+        return id;
+    }
+
     @Override
     public boolean isWritable() {
         ChannelOutboundBuffer buf = unsafe.outboundBuffer();
@@ -285,7 +304,7 @@ public Unsafe unsafe() {
      */
     @Override
     public final int hashCode() {
-        return (int) hashCode;
+        return id.hashCode();
     }
 
     /**
@@ -303,21 +322,7 @@ public final int compareTo(Channel o) {
             return 0;
         }
 
-        long ret = hashCode - o.hashCode();
-        if (ret > 0) {
-            return 1;
-        }
-        if (ret < 0) {
-            return -1;
-        }
-
-        ret = System.identityHashCode(this) - System.identityHashCode(o);
-        if (ret != 0) {
-            return (int) ret;
-        }
-
-        // Jackpot! - different objects with same hashes
-        throw new Error();
+        return id().compareTo(o.id());
     }
 
     /**
@@ -345,11 +350,30 @@ public String toString() {
                 srcAddr = remoteAddr;
                 dstAddr = localAddr;
             }
-            strVal = String.format("[id: 0x%08x, %s %s %s]", (int) hashCode, srcAddr, active? "=>" : ":>", dstAddr);
+
+            StringBuilder buf = new StringBuilder(96);
+            buf.append("[id: 0x");
+            buf.append(id.asShortText());
+            buf.append(", ");
+            buf.append(srcAddr);
+            buf.append(active? " => " : " :> ");
+            buf.append(dstAddr);
+            buf.append(']');
+            strVal = buf.toString();
         } else if (localAddr != null) {
-            strVal = String.format("[id: 0x%08x, %s]", (int) hashCode, localAddr);
+            StringBuilder buf = new StringBuilder(64);
+            buf.append("[id: 0x");
+            buf.append(id.asShortText());
+            buf.append(", ");
+            buf.append(localAddr);
+            buf.append(']');
+            strVal = buf.toString();
         } else {
-            strVal = String.format("[id: 0x%08x]", (int) hashCode);
+            StringBuilder buf = new StringBuilder(16);
+            buf.append("[id: 0x");
+            buf.append(id.asShortText());
+            buf.append(']');
+            strVal = buf.toString();
         }
 
         strValActive = active;
@@ -373,9 +397,15 @@ final MessageSizeEstimator.Handle estimatorHandle() {
      */
     protected abstract class AbstractUnsafe implements Unsafe {
 
-        private ChannelOutboundBuffer outboundBuffer = ChannelOutboundBuffer.newInstance(AbstractChannel.this);
+        private ChannelOutboundBuffer outboundBuffer = newOutboundBuffer();
+
         private boolean inFlush0;
 
+        @Override
+        public final ChannelHandlerInvoker invoker() {
+            return eventLoop().asInvoker();
+        }
+
         @Override
         public final ChannelOutboundBuffer outboundBuffer() {
             return outboundBuffer;
@@ -412,7 +442,7 @@ public final void register(EventLoop eventLoop, final ChannelPromise promise) {
                 register0(promise);
             } else {
                 try {
-                    eventLoop.execute(new Runnable() {
+                    eventLoop.execute(new OneTimeTask() {
                         @Override
                         public void run() {
                             register0(promise);
@@ -480,7 +510,7 @@ public final void bind(final SocketAddress localAddress, final ChannelPromise pr
             }
 
             if (!wasActive && isActive()) {
-                invokeLater(new Runnable() {
+                invokeLater(new OneTimeTask() {
                     @Override
                     public void run() {
                         pipeline.fireChannelActive();
@@ -507,7 +537,7 @@ public final void disconnect(final ChannelPromise promise) {
             }
 
             if (wasActive && !isActive()) {
-                invokeLater(new Runnable() {
+                invokeLater(new OneTimeTask() {
                     @Override
                     public void run() {
                         pipeline.fireChannelInactive();
@@ -526,7 +556,7 @@ public final void close(final ChannelPromise promise) {
             }
 
             if (inFlush0) {
-                invokeLater(new Runnable() {
+                invokeLater(new OneTimeTask() {
                     @Override
                     public void run() {
                         close(promise);
@@ -561,7 +591,7 @@ public void run() {
             } finally {
 
                 if (wasActive && !isActive()) {
-                    invokeLater(new Runnable() {
+                    invokeLater(new OneTimeTask() {
                         @Override
                         public void run() {
                             pipeline.fireChannelInactive();
@@ -600,7 +630,7 @@ public final void deregister(final ChannelPromise promise) {
             } finally {
                 if (registered) {
                     registered = false;
-                    invokeLater(new Runnable() {
+                    invokeLater(new OneTimeTask() {
                         @Override
                         public void run() {
                             pipeline.fireChannelUnregistered();
@@ -625,7 +655,7 @@ public void beginRead() {
             try {
                 doBeginRead();
             } catch (final Exception e) {
-                invokeLater(new Runnable() {
+                invokeLater(new OneTimeTask() {
                     @Override
                     public void run() {
                         pipeline.fireExceptionCaught(e);
@@ -637,18 +667,18 @@ public void run() {
 
         @Override
         public void write(Object msg, ChannelPromise promise) {
-            if (!isActive()) {
-                // Mark the write request as failure if the channel is inactive.
-                if (isOpen()) {
-                    safeSetFailure(promise, NOT_YET_CONNECTED_EXCEPTION);
-                } else {
-                    safeSetFailure(promise, CLOSED_CHANNEL_EXCEPTION);
-                }
+            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
+            if (outboundBuffer == null) {
+                // If the outboundBuffer is null we know the channel was closed and so
+                // need to fail the future right away. If it is not null the handling of the rest
+                // will be done in flush0()
+                // See https://github.com/netty/netty/issues/2362
+                safeSetFailure(promise, CLOSED_CHANNEL_EXCEPTION);
                 // release message now to prevent resource-leak
                 ReferenceCountUtil.release(msg);
-            } else {
-                outboundBuffer.addMessage(msg, promise);
+                return;
             }
+            outboundBuffer.addMessage(msg, promise);
         }
 
         @Override
@@ -662,6 +692,7 @@ public void flush() {
             flush0();
         }
 
+        @SuppressWarnings("deprecation")
         protected void flush0() {
             if (inFlush0) {
                 // Avoid re-entrance
@@ -760,6 +791,13 @@ private void invokeLater(Runnable task) {
         }
     }
 
+    /**
+     * Create a new {@link ChannelOutboundBuffer} which holds the pending messages for this {@link AbstractChannel}.
+     */
+    protected ChannelOutboundBuffer newOutboundBuffer() {
+        return ChannelOutboundBuffer.newInstance(this);
+    }
+
     /**
      * Return {@code true} if the given {@link EventLoop} is compatible with this instance.
      */
diff --git a/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
new file mode 100644
index 000000000000..0c57b7dea680
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
@@ -0,0 +1,379 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.util.Attribute;
+import io.netty.util.AttributeKey;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.ResourceLeakHint;
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.internal.StringUtil;
+
+import java.net.SocketAddress;
+
+abstract class AbstractChannelHandlerContext implements ChannelHandlerContext, ResourceLeakHint {
+
+    volatile AbstractChannelHandlerContext next;
+    volatile AbstractChannelHandlerContext prev;
+
+    private final boolean inbound;
+    private final boolean outbound;
+    private final AbstractChannel channel;
+    private final DefaultChannelPipeline pipeline;
+    private final String name;
+    private boolean removed;
+
+    final ChannelHandlerInvoker invoker;
+    private ChannelFuture succeededFuture;
+
+    // Lazily instantiated tasks used to trigger events to a handler with different executor.
+    // These needs to be volatile as otherwise an other Thread may see an half initialized instance.
+    // See the JMM for more details
+    volatile Runnable invokeChannelReadCompleteTask;
+    volatile Runnable invokeReadTask;
+    volatile Runnable invokeChannelWritableStateChangedTask;
+    volatile Runnable invokeFlushTask;
+
+    AbstractChannelHandlerContext(
+            DefaultChannelPipeline pipeline, ChannelHandlerInvoker invoker,
+            String name, boolean inbound, boolean outbound) {
+
+        if (name == null) {
+            throw new NullPointerException("name");
+        }
+
+        channel = pipeline.channel;
+        this.pipeline = pipeline;
+        this.name = name;
+        this.invoker = invoker;
+
+        this.inbound = inbound;
+        this.outbound = outbound;
+    }
+
+    /** Invocation initiated by {@link DefaultChannelPipeline#teardownAll()}}. */
+    void teardown() {
+        EventExecutor executor = executor();
+        if (executor.inEventLoop()) {
+            teardown0();
+        } else {
+            executor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    teardown0();
+                }
+            });
+        }
+    }
+
+    private void teardown0() {
+        AbstractChannelHandlerContext prev = this.prev;
+        if (prev != null) {
+            synchronized (pipeline) {
+                pipeline.remove0(this);
+            }
+            prev.teardown();
+        }
+    }
+
+    @Override
+    public Channel channel() {
+        return channel;
+    }
+
+    @Override
+    public ChannelPipeline pipeline() {
+        return pipeline;
+    }
+
+    @Override
+    public ByteBufAllocator alloc() {
+        return channel().config().getAllocator();
+    }
+
+    @Override
+    public EventExecutor executor() {
+        return invoker().executor();
+    }
+
+    public ChannelHandlerInvoker invoker() {
+        if (invoker == null) {
+            return channel.unsafe().invoker();
+        } else {
+            return invoker;
+        }
+    }
+
+    @Override
+    public String name() {
+        return name;
+    }
+
+    @Override
+    public <T> Attribute<T> attr(AttributeKey<T> key) {
+        return channel.attr(key);
+    }
+
+    @Override
+    public <T> boolean hasAttr(AttributeKey<T> key) {
+        return channel.hasAttr(key);
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelRegistered() {
+        AbstractChannelHandlerContext next = findContextInbound();
+        next.invoker().invokeChannelRegistered(next);
+        return this;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelUnregistered() {
+        AbstractChannelHandlerContext next = findContextInbound();
+        next.invoker().invokeChannelUnregistered(next);
+        return this;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelActive() {
+        AbstractChannelHandlerContext next = findContextInbound();
+        next.invoker().invokeChannelActive(next);
+        return this;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelInactive() {
+        AbstractChannelHandlerContext next = findContextInbound();
+        next.invoker().invokeChannelInactive(next);
+        return this;
+    }
+
+    @Override
+    public ChannelHandlerContext fireExceptionCaught(Throwable cause) {
+        AbstractChannelHandlerContext next = this.next;
+        next.invoker().invokeExceptionCaught(next, cause);
+        return this;
+    }
+
+    @Override
+    public ChannelHandlerContext fireUserEventTriggered(Object event) {
+        AbstractChannelHandlerContext next = findContextInbound();
+        next.invoker().invokeUserEventTriggered(next, event);
+        return this;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelRead(Object msg) {
+        AbstractChannelHandlerContext next = findContextInbound();
+        ReferenceCountUtil.touch(msg, next);
+        next.invoker().invokeChannelRead(next, msg);
+        return this;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelReadComplete() {
+        AbstractChannelHandlerContext next = findContextInbound();
+        next.invoker().invokeChannelReadComplete(next);
+        return this;
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelWritabilityChanged() {
+        AbstractChannelHandlerContext next = findContextInbound();
+        next.invoker().invokeChannelWritabilityChanged(next);
+        return this;
+    }
+
+    @Override
+    public ChannelFuture bind(SocketAddress localAddress) {
+        return bind(localAddress, newPromise());
+    }
+
+    @Override
+    public ChannelFuture connect(SocketAddress remoteAddress) {
+        return connect(remoteAddress, newPromise());
+    }
+
+    @Override
+    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {
+        return connect(remoteAddress, localAddress, newPromise());
+    }
+
+    @Override
+    public ChannelFuture disconnect() {
+        return disconnect(newPromise());
+    }
+
+    @Override
+    public ChannelFuture close() {
+        return close(newPromise());
+    }
+
+    @Override
+    public ChannelFuture deregister() {
+        return deregister(newPromise());
+    }
+
+    @Override
+    public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        next.invoker().invokeBind(next, localAddress, promise);
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
+        return connect(remoteAddress, null, promise);
+    }
+
+    @Override
+    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        next.invoker().invokeConnect(next, remoteAddress, localAddress, promise);
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture disconnect(ChannelPromise promise) {
+        if (!channel().metadata().hasDisconnect()) {
+            return close(promise);
+        }
+
+        AbstractChannelHandlerContext next = findContextOutbound();
+        next.invoker().invokeDisconnect(next, promise);
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture close(ChannelPromise promise) {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        next.invoker().invokeClose(next, promise);
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture deregister(ChannelPromise promise) {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        next.invoker().invokeDeregister(next, promise);
+        return promise;
+    }
+
+    @Override
+    public ChannelHandlerContext read() {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        next.invoker().invokeRead(next);
+        return this;
+    }
+
+    @Override
+    public ChannelFuture write(Object msg) {
+        return write(msg, newPromise());
+    }
+
+    @Override
+    public ChannelFuture write(Object msg, ChannelPromise promise) {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        ReferenceCountUtil.touch(msg, next);
+        next.invoker().invokeWrite(next, msg, promise);
+        return promise;
+    }
+
+    @Override
+    public ChannelHandlerContext flush() {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        next.invoker().invokeFlush(next);
+        return this;
+    }
+
+    @Override
+    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        ReferenceCountUtil.touch(msg, next);
+        ChannelHandlerInvoker invoker = next.invoker();
+        invoker.invokeWrite(next, msg, promise);
+        invoker.invokeFlush(next);
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture writeAndFlush(Object msg) {
+        return writeAndFlush(msg, newPromise());
+    }
+
+    @Override
+    public ChannelPromise newPromise() {
+        return new DefaultChannelPromise(channel(), executor());
+    }
+
+    @Override
+    public ChannelProgressivePromise newProgressivePromise() {
+        return new DefaultChannelProgressivePromise(channel(), executor());
+    }
+
+    @Override
+    public ChannelFuture newSucceededFuture() {
+        ChannelFuture succeededFuture = this.succeededFuture;
+        if (succeededFuture == null) {
+            this.succeededFuture = succeededFuture = new SucceededChannelFuture(channel(), executor());
+        }
+        return succeededFuture;
+    }
+
+    @Override
+    public ChannelFuture newFailedFuture(Throwable cause) {
+        return new FailedChannelFuture(channel(), executor(), cause);
+    }
+
+    private AbstractChannelHandlerContext findContextInbound() {
+        AbstractChannelHandlerContext ctx = this;
+        do {
+            ctx = ctx.next;
+        } while (!ctx.inbound);
+        return ctx;
+    }
+
+    private AbstractChannelHandlerContext findContextOutbound() {
+        AbstractChannelHandlerContext ctx = this;
+        do {
+            ctx = ctx.prev;
+        } while (!ctx.outbound);
+        return ctx;
+    }
+
+    @Override
+    public ChannelPromise voidPromise() {
+        return channel.voidPromise();
+    }
+
+    void setRemoved() {
+        removed = true;
+    }
+
+    @Override
+    public boolean isRemoved() {
+        return removed;
+    }
+
+    @Override
+    public String toHintString() {
+        return '\'' + name + "' will handle the message from this point.";
+    }
+
+    @Override
+    public String toString() {
+        return StringUtil.simpleClassName(ChannelHandlerContext.class) + '(' + name + ", " + channel + ')';
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/AbstractEventLoop.java b/transport/src/main/java/io/netty/channel/AbstractEventLoop.java
new file mode 100644
index 000000000000..7a39d7e9d97d
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/AbstractEventLoop.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.util.concurrent.AbstractEventExecutor;
+
+/**
+ * Skeletal implementation of {@link EventLoop}.
+ */
+public abstract class AbstractEventLoop extends AbstractEventExecutor implements EventLoop {
+
+    protected AbstractEventLoop() { }
+
+    protected AbstractEventLoop(EventLoopGroup parent) {
+        super(parent);
+    }
+
+    @Override
+    public EventLoopGroup parent() {
+        return (EventLoopGroup) super.parent();
+    }
+
+    @Override
+    public EventLoop next() {
+        return (EventLoop) super.next();
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/AbstractEventLoopGroup.java b/transport/src/main/java/io/netty/channel/AbstractEventLoopGroup.java
new file mode 100644
index 000000000000..f8889b991ccf
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/AbstractEventLoopGroup.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.util.concurrent.AbstractEventExecutorGroup;
+
+/**
+ * Skeletal implementation of {@link EventLoopGroup}.
+ */
+public abstract class AbstractEventLoopGroup extends AbstractEventExecutorGroup implements EventLoopGroup {
+    @Override
+    public abstract EventLoop next();
+}
diff --git a/transport/src/main/java/io/netty/channel/AddressedEnvelope.java b/transport/src/main/java/io/netty/channel/AddressedEnvelope.java
index ba159f9d1eb5..b5ce89f5497a 100644
--- a/transport/src/main/java/io/netty/channel/AddressedEnvelope.java
+++ b/transport/src/main/java/io/netty/channel/AddressedEnvelope.java
@@ -41,4 +41,16 @@ public interface AddressedEnvelope<M, A extends SocketAddress> extends Reference
      * Returns the address of the recipient of this message.
      */
     A recipient();
+
+    @Override
+    AddressedEnvelope<M, A> retain();
+
+    @Override
+    AddressedEnvelope<M, A> retain(int increment);
+
+    @Override
+    AddressedEnvelope<M, A> touch();
+
+    @Override
+    AddressedEnvelope<M, A> touch(Object hint);
 }
diff --git a/transport/src/main/java/io/netty/channel/Channel.java b/transport/src/main/java/io/netty/channel/Channel.java
index 1e397be57050..d3d2c486749d 100644
--- a/transport/src/main/java/io/netty/channel/Channel.java
+++ b/transport/src/main/java/io/netty/channel/Channel.java
@@ -70,9 +70,20 @@
  * transport.  Down-cast the {@link Channel} to sub-type to invoke such
  * operations.  For example, with the old I/O datagram transport, multicast
  * join / leave operations are provided by {@link DatagramChannel}.
+ *
+ * <h3>Release resources</h3>
+ * <p>
+ * It is important to call {@link #close()} or {@link #close(ChannelPromise)} to release all
+ * resources once you are done with the {@link Channel}. This ensures all resources are
+ * released in a proper way, i.e. filehandles.
  */
 public interface Channel extends AttributeMap, Comparable<Channel> {
 
+    /**
+     * Returns the globally unique identifier of this {@link Channel}.
+     */
+    ChannelId id();
+
     /**
      * Return the {@link EventLoop} this {@link Channel} was registered too.
      */
@@ -281,7 +292,6 @@ public interface Channel extends AttributeMap, Comparable<Channel> {
      * {@link Channel}.
      *
      */
-    @Deprecated
     ChannelFuture deregister();
 
     /**
@@ -369,7 +379,6 @@ public interface Channel extends AttributeMap, Comparable<Channel> {
      * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
-    @Deprecated
     ChannelFuture deregister(ChannelPromise promise);
 
     /**
@@ -420,14 +429,22 @@ public interface Channel extends AttributeMap, Comparable<Channel> {
      * are only provided to implement the actual transport, and must be invoked from an I/O thread except for the
      * following methods:
      * <ul>
+     *   <li>{@link #invoker()}</li>
      *   <li>{@link #localAddress()}</li>
      *   <li>{@link #remoteAddress()}</li>
      *   <li>{@link #closeForcibly()}</li>
      *   <li>{@link #register(EventLoop, ChannelPromise)}</li>
+     *   <li>{@link #deregister(ChannelPromise)}</li>
      *   <li>{@link #voidPromise()}</li>
      * </ul>
      */
     interface Unsafe {
+
+        /**
+         * Returns the {@link ChannelHandlerInvoker} which is used by default unless specified by a user.
+         */
+        ChannelHandlerInvoker invoker();
+
         /**
          * Return the {@link SocketAddress} to which is bound local or
          * {@code null} if none.
@@ -441,7 +458,7 @@ interface Unsafe {
         SocketAddress remoteAddress();
 
         /**
-         * Register the {@link Channel} of the {@link ChannelPromise} with the {@link EventLoop} and notify
+         * Register the {@link Channel} of the {@link ChannelPromise} and notify
          * the {@link ChannelFuture} once the registration was complete.
          */
         void register(EventLoop eventLoop, ChannelPromise promise);
@@ -483,7 +500,6 @@ interface Unsafe {
          * Deregister the {@link Channel} of the {@link ChannelPromise} from {@link EventLoop} and notify the
          * {@link ChannelPromise} once the operation was complete.
          */
-        @Deprecated
         void deregister(ChannelPromise promise);
 
         /**
diff --git a/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java
index 949806d48e67..74b2b62c03a4 100644
--- a/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java
+++ b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java
@@ -49,15 +49,23 @@ public ChannelFlushPromiseNotifier() {
     }
 
     /**
-     * Add a {@link ChannelPromise} to this {@link ChannelFlushPromiseNotifier} which will be notified after the given
-     * pendingDataSize was reached.
+     * @deprecated use {@link #add(ChannelPromise, long)}
      */
+    @Deprecated
     public ChannelFlushPromiseNotifier add(ChannelPromise promise, int pendingDataSize) {
+        return add(promise, (long) pendingDataSize);
+    }
+
+    /**
+     * Add a {@link ChannelPromise} to this {@link ChannelFlushPromiseNotifier} which will be notified after the given
+     * {@code pendingDataSize} was reached.
+     */
+    public ChannelFlushPromiseNotifier add(ChannelPromise promise, long pendingDataSize) {
         if (promise == null) {
             throw new NullPointerException("promise");
         }
         if (pendingDataSize < 0) {
-            throw new IllegalArgumentException("pendingDataSize must be >= 0 but was" + pendingDataSize);
+            throw new IllegalArgumentException("pendingDataSize must be >= 0 but was " + pendingDataSize);
         }
         long checkpoint = writeCounter + pendingDataSize;
         if (promise instanceof FlushCheckpoint) {
@@ -69,13 +77,12 @@ public ChannelFlushPromiseNotifier add(ChannelPromise promise, int pendingDataSi
         }
         return this;
     }
-
     /**
      * Increase the current write counter by the given delta
      */
     public ChannelFlushPromiseNotifier increaseWriteCounter(long delta) {
         if (delta < 0) {
-            throw new IllegalArgumentException("delta must be >= 0 but was" + delta);
+            throw new IllegalArgumentException("delta must be >= 0 but was " + delta);
         }
         writeCounter += delta;
         return this;
@@ -95,11 +102,19 @@ public long writeCounter() {
      * After a {@link ChannelFuture} was notified it will be removed from this {@link ChannelFlushPromiseNotifier} and
      * so not receive anymore notification.
      */
-    public ChannelFlushPromiseNotifier notifyFlushFutures() {
-        notifyFlushFutures0(null);
+    public ChannelFlushPromiseNotifier notifyPromises() {
+        notifyPromises0(null);
         return this;
     }
 
+    /**
+     * @deprecated use {@link #notifyPromises()}
+     */
+    @Deprecated
+    public ChannelFlushPromiseNotifier notifyFlushFutures() {
+        return notifyPromises();
+    }
+
     /**
      * Notify all {@link ChannelFuture}s that were registered with {@link #add(ChannelPromise, int)} and
      * their pendingDatasize isis smaller then the current writeCounter returned by {@link #writeCounter()}.
@@ -111,8 +126,8 @@ public ChannelFlushPromiseNotifier notifyFlushFutures() {
      *
      * So after this operation this {@link ChannelFutureListener} is empty.
      */
-    public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause) {
-        notifyFlushFutures();
+    public ChannelFlushPromiseNotifier notifyPromises(Throwable cause) {
+        notifyPromises();
         for (;;) {
             FlushCheckpoint cp = flushCheckpoints.poll();
             if (cp == null) {
@@ -127,6 +142,14 @@ public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause) {
         return this;
     }
 
+    /**
+     * @deprecated use {@link #notifyPromises(Throwable)}
+     */
+    @Deprecated
+    public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause) {
+        return notifyPromises(cause);
+    }
+
     /**
      * Notify all {@link ChannelFuture}s that were registered with {@link #add(ChannelPromise, int)} and
      * their pendingDatasize is smaller then the current writeCounter returned by {@link #writeCounter()} using
@@ -143,8 +166,8 @@ public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause) {
      *                  pendingDataSize is smaller then the current writeCounter returned by {@link #writeCounter()}
      * @param cause2    the {@link Throwable} which will be used to fail the remaining {@link ChannelFuture}s
      */
-    public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause1, Throwable cause2) {
-        notifyFlushFutures0(cause1);
+    public ChannelFlushPromiseNotifier notifyPromises(Throwable cause1, Throwable cause2) {
+        notifyPromises0(cause1);
         for (;;) {
             FlushCheckpoint cp = flushCheckpoints.poll();
             if (cp == null) {
@@ -159,7 +182,15 @@ public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause1, Throwabl
         return this;
     }
 
-    private void notifyFlushFutures0(Throwable cause) {
+    /**
+     * @deprecated use {@link #notifyPromises(Throwable, Throwable)}
+     */
+    @Deprecated
+    public ChannelFlushPromiseNotifier notifyFlushFutures(Throwable cause1, Throwable cause2) {
+        return notifyPromises(cause1, cause2);
+    }
+
+    private void notifyPromises0(Throwable cause) {
         if (flushCheckpoints.isEmpty()) {
             writeCounter = 0;
             return;
@@ -183,17 +214,18 @@ private void notifyFlushFutures0(Throwable cause) {
             }
 
             flushCheckpoints.remove();
+            ChannelPromise promise = cp.promise();
             if (cause == null) {
                 if (tryNotify) {
-                    cp.promise().trySuccess();
+                    promise.trySuccess();
                 } else {
-                    cp.promise().setSuccess();
+                    promise.setSuccess();
                 }
             } else {
                 if (tryNotify) {
-                    cp.promise().tryFailure(cause);
+                    promise.tryFailure(cause);
                 } else {
-                    cp.promise().setFailure(cause);
+                    promise.setFailure(cause);
                 }
             }
         }
diff --git a/transport/src/main/java/io/netty/channel/ChannelFuture.java b/transport/src/main/java/io/netty/channel/ChannelFuture.java
index 3834c7026dc2..dfb03cb4c2b2 100644
--- a/transport/src/main/java/io/netty/channel/ChannelFuture.java
+++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java
@@ -50,8 +50,8 @@
  * +--------------------------+    |    | Completed with failure    |
  * |      isDone() = <b>false</b>    |    |    +---------------------------+
  * |   isSuccess() = false    |----+---->   isDone() = <b>true</b>         |
- * | isCancelled() = false    |    |    | cause() = <b>non-null</b>     |
- * |    cause() = null     |    |    +===========================+
+ * | isCancelled() = false    |    |    |    cause() = <b>non-null</b>     |
+ * |       cause() = null     |    |    +===========================+
  * +--------------------------+    |    | Completed by cancellation |
  *                                 |    +---------------------------+
  *                                 +---->      isDone() = <b>true</b>      |
@@ -193,4 +193,20 @@ public interface ChannelFuture extends Future<Void> {
 
     @Override
     ChannelFuture awaitUninterruptibly();
+
+    /**
+     * Returns {@code true} if this {@link ChannelFuture} is a void future and so not allow to call any of the
+     * following methods:
+     * <ul>
+     *     <li>{@link #addListener(GenericFutureListener)}</li>
+     *     <li>{@link #addListeners(GenericFutureListener[])}</li>
+     *     <li>{@link #await()}</li>
+     *     <li>{@link #await(long, TimeUnit)} ()}</li>
+     *     <li>{@link #await(long)} ()}</li>
+     *     <li>{@link #awaitUninterruptibly()}</li>
+     *     <li>{@link #sync()}</li>
+     *     <li>{@link #syncUninterruptibly()}</li>
+     * </ul>
+     */
+    boolean isVoid();
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandler.java b/transport/src/main/java/io/netty/channel/ChannelHandler.java
index fd6191e69f27..47df8418dbb5 100644
--- a/transport/src/main/java/io/netty/channel/ChannelHandler.java
+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java
@@ -26,25 +26,28 @@
 import java.lang.annotation.Target;
 
 /**
- * Handles or intercepts a {@link ChannelInboundInvoker} or {@link ChannelOutboundInvoker} operation, and forwards it
- * to the next handler in a {@link ChannelPipeline}.
+ * Handles an I/O event or intercepts an I/O operation, and forwards it to its next handler in
+ * its {@link ChannelPipeline}.
  *
  * <h3>Sub-types</h3>
  * <p>
- * {@link ChannelHandler} itself does not provide many methods.  To handle a
- * a {@link ChannelInboundInvoker} or {@link ChannelOutboundInvoker} operation
- * you need to implement its sub-interfaces.  There are many different sub-interfaces
- * which handles inbound and outbound operations.
- *
- * But the most useful for developers may be:
+ * {@link ChannelHandler} itself does not provide many methods, but you usually have to implement one of its subtypes:
  * <ul>
- * <li>{@link ChannelInboundHandlerAdapter} handles and intercepts inbound operations</li>
- * <li>{@link ChannelOutboundHandlerAdapter} handles and intercepts outbound operations</li>
+ * <li>{@link ChannelInboundHandler} to handle inbound I/O events, and</li>
+ * <li>{@link ChannelOutboundHandler} to handle outbound I/O operations.</li>
  * </ul>
- *
- * You will also find more detailed explanation from the documentation of
- * each sub-interface on how an event is interpreted when it goes upstream and
- * downstream respectively.
+ * </p>
+ * <p>
+ * Alternatively, the following adapter classes are provided for your convenience:
+ * <ul>
+ * <li>{@link ChannelInboundHandlerAdapter} to handle inbound I/O events,</li>
+ * <li>{@link ChannelOutboundHandlerAdapter} to handle outbound I/O operations, and</li>
+ * <li>{@link ChannelDuplexHandler} to handle both inbound and outbound events</li>
+ * </ul>
+ * </p>
+ * <p>
+ * For more information, please refer to the documentation of each subtype.
+ * </p>
  *
  * <h3>The context object</h3>
  * <p>
@@ -53,7 +56,7 @@
  * {@link ChannelPipeline} it belongs to via a context object.  Using the
  * context object, the {@link ChannelHandler} can pass events upstream or
  * downstream, modify the pipeline dynamically, or store the information
- * (attachment) which is specific to the handler.
+ * (using {@link AttributeKey}s) which is specific to the handler.
  *
  * <h3>State management</h3>
  *
@@ -69,7 +72,7 @@
  *     <b>private boolean loggedIn;</b>
  *
  *     {@code @Override}
- *     public void channelRead({@link ChannelHandlerContext} ctx, Message message) {
+ *     public void channelRead0({@link ChannelHandlerContext} ctx, Message message) {
  *         {@link Channel} ch = e.getChannel();
  *         if (message instanceof LoginMessage) {
  *             authenticate((LoginMessage) message);
@@ -101,11 +104,11 @@
  *
  * </pre>
  *
- * <h4>Using an attachment</h4>
+ * <h4>Using {@link AttributeKey}s</h4>
  *
  * Although it's recommended to use member variables to store the state of a
  * handler, for some reason you might not want to create many handler instances.
- * In such a case, you can use an <em>attachment</em> which is provided by
+ * In such a case, you can use {@link AttributeKey}s which is provided by
  * {@link ChannelHandlerContext}:
  * <pre>
  * public interface Message {
@@ -114,17 +117,12 @@
  *
  * {@code @Sharable}
  * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {
- *   private final {@link AttributeKey}&lt{@link Boolean}&gt auth =
+ *     private final {@link AttributeKey}&lt{@link Boolean}&gt auth =
  *           {@link AttributeKey#valueOf(String) AttributeKey.valueOf("auth")};
  *
- *   // This handler will receive a sequence of increasing integers starting
- *   // from 1.
- *   {@code @Override}
- *   public void channelRead({@link ChannelHandlerContext} ctx, {@link Integer} integer) {
- *     {@link Attribute}&lt{@link Boolean}&gt attr = ctx.attr(auth);
- *
  *     {@code @Override}
  *     public void channelRead({@link ChannelHandlerContext} ctx, Message message) {
+ *         {@link Attribute}&lt{@link Boolean}&gt attr = ctx.attr(auth);
  *         {@link Channel} ch = ctx.channel();
  *         if (message instanceof LoginMessage) {
  *             authenticate((LoginMessage) o);
@@ -140,7 +138,7 @@
  *     ...
  * }
  * </pre>
- * Now that the state of the handler is stored as an attachment, you can add the
+ * Now that the state of the handler is attached to the {@link ChannelHandlerContext}, you can add the
  * same handler instance to different pipelines:
  * <pre>
  * public class DataServerInitializer extends {@link ChannelInitializer}&lt{@link Channel}&gt {
@@ -157,7 +155,7 @@
  *
  * <h4>The {@code @Sharable} annotation</h4>
  * <p>
- * In the examples above which used an attachment,
+ * In the example above which used an {@link AttributeKey},
  * you might have noticed the {@code @Sharable} annotation.
  * <p>
  * If a {@link ChannelHandler} is annotated with the {@code @Sharable}
@@ -194,12 +192,7 @@ public interface ChannelHandler {
 
     /**
      * Gets called if a {@link Throwable} was thrown.
-     *
-     * @deprecated  Will be removed in the future and only {@link ChannelInboundHandler} will receive
-     *              exceptionCaught events. For {@link ChannelOutboundHandler} the {@link ChannelPromise}
-     *              must be failed.
      */
-    @Deprecated
     void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
 
     /**
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java
index 8d315025ba00..9b665d551b9c 100644
--- a/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java
+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java
@@ -16,6 +16,11 @@
 
 package io.netty.channel;
 
+import io.netty.util.internal.InternalThreadLocalMap;
+
+import java.util.Map;
+import java.util.WeakHashMap;
+
 /**
  * Skelton implementation of a {@link ChannelHandler}.
  */
@@ -29,7 +34,22 @@ public abstract class ChannelHandlerAdapter implements ChannelHandler {
      * to different {@link ChannelPipeline}s.
      */
     public boolean isSharable() {
-        return getClass().isAnnotationPresent(Sharable.class);
+        /**
+         * Cache the result of {@link Sharable} annotation detection to workaround a condition. We use a
+         * {@link ThreadLocal} and {@link WeakHashMap} to eliminate the volatile write/reads. Using different
+         * {@link WeakHashMap} instances per {@link Thread} is good enough for us and the number of
+         * {@link Thread}s are quite limited anyway.
+         *
+         * See <a href="See https://github.com/netty/netty/issues/2289">#2289</a>.
+         */
+        Class<?> clazz = getClass();
+        Map<Class<?>, Boolean> cache = InternalThreadLocalMap.get().handlerSharableCache();
+        Boolean sharable = cache.get(clazz);
+        if (sharable == null) {
+            sharable = clazz.isAnnotationPresent(Sharable.class);
+            cache.put(clazz, sharable);
+        }
+        return sharable;
     }
 
     /**
@@ -54,10 +74,8 @@ public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
      *
      * Sub-classes may override this method to change behavior.
      */
-    @Deprecated
     @Override
-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
-            throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         ctx.fireExceptionCaught(cause);
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerAppender.java b/transport/src/main/java/io/netty/channel/ChannelHandlerAppender.java
new file mode 100644
index 000000000000..798a8c29f82e
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAppender.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A {@link ChannelHandler} that appends the specified {@link ChannelHandler}s right next to itself.
+ * By default, it removes itself from the {@link ChannelPipeline} once the specified {@link ChannelHandler}s
+ * are added. Optionally, you can keep it in the {@link ChannelPipeline} by specifying a {@code boolean}
+ * parameter at construction time.
+ */
+public class ChannelHandlerAppender extends ChannelInboundHandlerAdapter {
+
+    private static final class Entry {
+        final String name;
+        final ChannelHandler handler;
+
+        Entry(String name, ChannelHandler handler) {
+            this.name = name;
+            this.handler = handler;
+        }
+    }
+
+    private final boolean selfRemoval;
+    private final List<Entry> handlers = new ArrayList<Entry>();
+    private boolean added;
+
+    /**
+     * Creates a new uninitialized instance. A class that extends this handler must invoke
+     * {@link #add(ChannelHandler...)} before adding this handler into a {@link ChannelPipeline}.
+     */
+    protected ChannelHandlerAppender() {
+        this(true);
+    }
+
+    /**
+     * Creates a new uninitialized instance. A class that extends this handler must invoke
+     * {@link #add(ChannelHandler...)} before adding this handler into a {@link ChannelPipeline}.
+     *
+     * @param selfRemoval {@code true} to remove itself from the {@link ChannelPipeline} after appending
+     *                    the {@link ChannelHandler}s specified via {@link #add(ChannelHandler...)}.
+     */
+    protected ChannelHandlerAppender(boolean selfRemoval) {
+        this.selfRemoval = selfRemoval;
+    }
+
+    /**
+     * Creates a new instance that appends the specified {@link ChannelHandler}s right next to itself.
+     */
+    public ChannelHandlerAppender(Iterable<? extends ChannelHandler> handlers) {
+        this(true, handlers);
+    }
+
+    /**
+     * Creates a new instance that appends the specified {@link ChannelHandler}s right next to itself.
+     */
+    public ChannelHandlerAppender(ChannelHandler... handlers) {
+        this(true, handlers);
+    }
+
+    /**
+     * Creates a new instance that appends the specified {@link ChannelHandler}s right next to itself.
+     *
+     * @param selfRemoval {@code true} to remove itself from the {@link ChannelPipeline} after appending
+     *                    the specified {@link ChannelHandler}s
+     */
+    public ChannelHandlerAppender(boolean selfRemoval, Iterable<? extends ChannelHandler> handlers) {
+        this.selfRemoval = selfRemoval;
+        add(handlers);
+    }
+
+    /**
+     * Creates a new instance that appends the specified {@link ChannelHandler}s right next to itself.
+     *
+     * @param selfRemoval {@code true} to remove itself from the {@link ChannelPipeline} after appending
+     *                    the specified {@link ChannelHandler}s
+     */
+    public ChannelHandlerAppender(boolean selfRemoval, ChannelHandler... handlers) {
+        this.selfRemoval = selfRemoval;
+        add(handlers);
+    }
+
+    /**
+     * Adds the specified handler to the list of the appended handlers.
+     *
+     * @param name the name of the appended handler. {@code null} to auto-generate
+     * @param handler the handler to append
+     *
+     * @throws IllegalStateException if {@link ChannelHandlerAppender} has been added to the pipeline already
+     */
+    protected final ChannelHandlerAppender add(String name, ChannelHandler handler) {
+        if (handler == null) {
+            throw new NullPointerException("handler");
+        }
+
+        if (added) {
+            throw new IllegalStateException("added to the pipeline already");
+        }
+
+        handlers.add(new Entry(name, handler));
+        return this;
+    }
+
+    /**
+     * Adds the specified handler to the list of the appended handlers with the auto-generated handler name.
+     *
+     * @param handler the handler to append
+     *
+     * @throws IllegalStateException if {@link ChannelHandlerAppender} has been added to the pipeline already
+     */
+    protected final ChannelHandlerAppender add(ChannelHandler handler) {
+        return add(null, handler);
+    }
+
+    /**
+     * Adds the specified handlers to the list of the appended handlers. The handlers' names are auto-generated.
+     *
+     * @throws IllegalStateException if {@link ChannelHandlerAppender} has been added to the pipeline already
+     */
+    protected final ChannelHandlerAppender add(Iterable<? extends ChannelHandler> handlers) {
+        if (handlers == null) {
+            throw new NullPointerException("handlers");
+        }
+
+        for (ChannelHandler h: handlers) {
+            if (h == null) {
+                break;
+            }
+            add(h);
+        }
+
+        return this;
+    }
+
+    /**
+     * Adds the specified handlers to the list of the appended handlers. The handlers' names are auto-generated.
+     *
+     * @throws IllegalStateException if {@link ChannelHandlerAppender} has been added to the pipeline already
+     */
+    protected final ChannelHandlerAppender add(ChannelHandler... handlers) {
+        if (handlers == null) {
+            throw new NullPointerException("handlers");
+        }
+
+        for (ChannelHandler h: handlers) {
+            if (h == null) {
+                break;
+            }
+
+            add(h);
+        }
+
+        return this;
+    }
+
+    /**
+     * Returns the {@code index}-th appended handler.
+     */
+    @SuppressWarnings("unchecked")
+    protected final <T extends ChannelHandler> T handlerAt(int index) {
+        return (T) handlers.get(index).handler;
+    }
+
+    @Override
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+        added = true;
+
+        AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
+        DefaultChannelPipeline pipeline = (DefaultChannelPipeline) dctx.pipeline();
+        String name = dctx.name();
+        try {
+            for (Entry e: handlers) {
+                String oldName = name;
+                if (e.name == null) {
+                    name = pipeline.generateName(e.handler);
+                } else {
+                    name = e.name;
+                }
+
+                // Note that we do not use dctx.invoker() because it raises an IllegalStateExxception
+                // if the Channel is not registered yet.
+                pipeline.addAfter(dctx.invoker, oldName, name, e.handler);
+            }
+        } finally {
+            if (selfRemoval) {
+                pipeline.remove(this);
+            }
+        }
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
index 420f17b0e7ff..adb4fd4babdf 100644
--- a/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
@@ -30,20 +30,21 @@
 
 /**
  * Enables a {@link ChannelHandler} to interact with its {@link ChannelPipeline}
- * and other handlers.  A handler can notify the next {@link ChannelHandler} in the {@link ChannelPipeline},
- * modify the {@link ChannelPipeline} it belongs to dynamically.
+ * and other handlers. Among other things a handler can notify the next {@link ChannelHandler} in the
+ * {@link ChannelPipeline} as well as modify the {@link ChannelPipeline} it belongs to dynamically.
  *
  * <h3>Notify</h3>
  *
- * You can notify the closest handler in the
- * same {@link ChannelPipeline} by calling one of the various methods provided here.
+ * You can notify the closest handler in the same {@link ChannelPipeline} by calling one of the various methods
+ * provided here.
+ *
  * Please refer to {@link ChannelPipeline} to understand how an event flows.
  *
  * <h3>Modifying a pipeline</h3>
  *
  * You can get the {@link ChannelPipeline} your handler belongs to by calling
  * {@link #pipeline()}.  A non-trivial application could insert, remove, or
- * replace handlers in the pipeline dynamically in runtime.
+ * replace handlers in the pipeline dynamically at runtime.
  *
  * <h3>Retrieving for later use</h3>
  *
@@ -81,19 +82,18 @@
  * {@link ChannelHandlerContext}s if it is added to one or more
  * {@link ChannelPipeline}s more than once.
  * <p>
- * For example, the following handler will have as many independent attachments
+ * For example, the following handler will have as many independent {@link AttributeKey}s
  * as how many times it is added to pipelines, regardless if it is added to the
  * same pipeline multiple times or added to different pipelines multiple times:
  * <pre>
- * public class FactorialHandler extends {@link ChannelInboundHandlerAdapter}&lt{@link Integer}&gt {
+ * public class FactorialHandler extends {@link ChannelInboundHandlerAdapter} {
  *
- *   private final {@link AttributeKey}&lt{@link Integer}&gt counter =
- *           new {@link AttributeKey}&lt{@link Integer}&gt("counter");
+ *   private final {@link AttributeKey}&lt{@link Integer}&gt counter = {@link AttributeKey}.valueOf("counter");
  *
  *   // This handler will receive a sequence of increasing integers starting
  *   // from 1.
  *   {@code @Override}
- *   public void channelRead({@link ChannelHandlerContext} ctx, {@link Integer} integer) {
+ *   public void channelRead({@link ChannelHandlerContext} ctx, Object msg) {
  *     {@link Attribute}&lt{@link Integer}&gt attr = ctx.getAttr(counter);
  *     Integer a = ctx.getAttr(counter).get();
  *
@@ -101,13 +101,13 @@
  *       a = 1;
  *     }
  *
- *     attr.set(a * integer));
+ *     attr.set(a * (Integer) msg);
  *   }
  * }
  *
  * // Different context objects are given to "f1", "f2", "f3", and "f4" even if
  * // they refer to the same handler instance.  Because the FactorialHandler
- * // stores its state in a context object (as an attachment), the factorial is
+ * // stores its state in a context object (using an {@link AttributeKey}), the factorial is
  * // calculated correctly 4 times once the two pipelines (p1 and p2) are active.
  * FactorialHandler fh = new FactorialHandler();
  *
@@ -127,8 +127,7 @@
  * what fundamental differences they have, how they flow in a  pipeline,  and how to handle
  * the operation in your application.
  */
-public interface ChannelHandlerContext
-         extends AttributeMap {
+public interface ChannelHandlerContext extends AttributeMap {
 
     /**
      * Return the {@link Channel} which is bound to the {@link ChannelHandlerContext}.
@@ -136,9 +135,7 @@ public interface ChannelHandlerContext
     Channel channel();
 
     /**
-     * The {@link EventExecutor} that is used to dispatch the events. This can also be used to directly
-     * submit tasks that get executed in the event loop. For more information please refer to the
-     * {@link EventExecutor} javadoc.
+     * Returns the {@link EventExecutor} which is used to execute an arbitrary task.
      */
     EventExecutor executor();
 
@@ -164,8 +161,8 @@ public interface ChannelHandlerContext
     /**
      * A {@link Channel} was registered to its {@link EventLoop}.
      *
-     * This will result in having the  {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)} method
+     * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelHandlerContext fireChannelRegistered();
@@ -173,18 +170,17 @@ public interface ChannelHandlerContext
     /**
      * A {@link Channel} was unregistered from its {@link EventLoop}.
      *
-     * This will result in having the  {@link ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the {@link ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)} method
+     * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
-    @Deprecated
     ChannelHandlerContext fireChannelUnregistered();
 
     /**
      * A {@link Channel} is active now, which means it is connected.
      *
-     * This will result in having the  {@link ChannelInboundHandler#channelActive(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the {@link ChannelInboundHandler#channelActive(ChannelHandlerContext)} method
+     * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelHandlerContext fireChannelActive();
@@ -192,8 +188,8 @@ public interface ChannelHandlerContext
     /**
      * A {@link Channel} is inactive now, which means it is closed.
      *
-     * This will result in having the  {@link ChannelInboundHandler#channelInactive(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the {@link ChannelInboundHandler#channelInactive(ChannelHandlerContext)} method
+     * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelHandlerContext fireChannelInactive();
@@ -201,8 +197,8 @@ public interface ChannelHandlerContext
     /**
      * A {@link Channel} received an {@link Throwable} in one of its inbound operations.
      *
-     * This will result in having the  {@link ChannelInboundHandler#exceptionCaught(ChannelHandlerContext, Throwable)}
-     * method  called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the {@link ChannelInboundHandler#exceptionCaught(ChannelHandlerContext, Throwable)}
+     * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelHandlerContext fireExceptionCaught(Throwable cause);
@@ -210,8 +206,8 @@ public interface ChannelHandlerContext
     /**
      * A {@link Channel} received an user defined event.
      *
-     * This will result in having the  {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}
-     * method  called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}
+     * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelHandlerContext fireUserEventTriggered(Object event);
@@ -220,7 +216,7 @@ public interface ChannelHandlerContext
      * A {@link Channel} received a message.
      *
      * This will result in having the {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)}
-     * method  called of the next {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelHandlerContext fireChannelRead(Object msg);
@@ -243,7 +239,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture bind(SocketAddress localAddress);
@@ -258,7 +254,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture connect(SocketAddress remoteAddress);
@@ -270,7 +266,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);
@@ -281,7 +277,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture disconnect();
@@ -295,7 +291,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture close();
@@ -307,11 +303,10 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      *
      */
-    @Deprecated
     ChannelFuture deregister();
 
     /**
@@ -322,7 +317,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise);
@@ -340,7 +335,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise);
@@ -354,7 +349,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
@@ -367,7 +362,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture disconnect(ChannelPromise promise);
@@ -382,7 +377,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture close(ChannelPromise promise);
@@ -396,10 +391,9 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
-    @Deprecated
     ChannelFuture deregister(ChannelPromise promise);
 
     /**
@@ -411,7 +405,7 @@ public interface ChannelHandlerContext
      * <p>
      * This will result in having the
      * {@link ChannelOutboundHandler#read(ChannelHandlerContext)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelHandlerContext read();
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java
new file mode 100644
index 000000000000..8acdf6d2a284
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.util.concurrent.EventExecutor;
+
+import java.net.SocketAddress;
+
+/**
+ * Invokes the event handler methods of {@link ChannelInboundHandler} and {@link ChannelOutboundHandler}.
+ * A user can specify a {@link ChannelHandlerInvoker} to implement a custom thread model unsupported by the default
+ * implementation. Note that the methods in this interface are not intended to be called by a user.
+ */
+public interface ChannelHandlerInvoker {
+
+    /**
+     * Returns the {@link EventExecutor} which is used to execute an arbitrary task.
+     */
+    EventExecutor executor();
+
+    /**
+     * Invokes {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)}. This method is not for a user
+     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeChannelRegistered(ChannelHandlerContext ctx);
+
+    /**
+     * Invokes {@link ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)}. This method is not for a user
+     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeChannelUnregistered(ChannelHandlerContext ctx);
+
+    /**
+     * Invokes {@link ChannelInboundHandler#channelActive(ChannelHandlerContext)}. This method is not for a user
+     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeChannelActive(ChannelHandlerContext ctx);
+
+    /**
+     * Invokes {@link ChannelInboundHandler#channelInactive(ChannelHandlerContext)}. This method is not for a user
+     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeChannelInactive(ChannelHandlerContext ctx);
+
+    /**
+     * Invokes {@link ChannelHandler#exceptionCaught(ChannelHandlerContext, Throwable)}. This method is not for a user
+     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeExceptionCaught(ChannelHandlerContext ctx, Throwable cause);
+
+    /**
+     * Invokes {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}. This method is not for
+     * a user but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeUserEventTriggered(ChannelHandlerContext ctx, Object event);
+
+    /**
+     * Invokes {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)}. This method is not for a user
+     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeChannelRead(ChannelHandlerContext ctx, Object msg);
+
+    /**
+     * Invokes {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}. This method is not for a user
+     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeChannelReadComplete(ChannelHandlerContext ctx);
+
+    /**
+     * Invokes {@link ChannelInboundHandler#channelWritabilityChanged(ChannelHandlerContext)}. This method is not for
+     * a user but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
+     * {@link ChannelHandlerContext} instead.
+     */
+    void invokeChannelWritabilityChanged(ChannelHandlerContext ctx);
+
+    /**
+     * Invokes {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)}.
+     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
+     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
+     */
+    void invokeBind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise);
+
+    /**
+     * Invokes
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}.
+     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
+     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
+     */
+    void invokeConnect(
+            ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
+
+    /**
+     * Invokes {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}.
+     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
+     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
+     */
+    void invokeDisconnect(ChannelHandlerContext ctx, ChannelPromise promise);
+
+    /**
+     * Invokes {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}.
+     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
+     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
+     */
+    void invokeClose(ChannelHandlerContext ctx, ChannelPromise promise);
+
+    /**
+     * Invokes {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}.
+     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
+     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
+     */
+    void invokeDeregister(ChannelHandlerContext ctx, ChannelPromise promise);
+
+    /**
+     * Invokes {@link ChannelOutboundHandler#read(ChannelHandlerContext)}.
+     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
+     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
+     */
+    void invokeRead(ChannelHandlerContext ctx);
+
+    /**
+     * Invokes {@link ChannelOutboundHandler#write(ChannelHandlerContext, Object, ChannelPromise)}.
+     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
+     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
+     */
+    void invokeWrite(ChannelHandlerContext ctx, Object msg, ChannelPromise promise);
+
+    /**
+     * Invokes {@link ChannelOutboundHandler#flush(ChannelHandlerContext)}.
+     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
+     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
+     */
+    void invokeFlush(ChannelHandlerContext ctx);
+}
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java
new file mode 100644
index 000000000000..29db91a9504d
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java
@@ -0,0 +1,257 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.util.internal.StringUtil;
+
+import java.net.SocketAddress;
+
+import static io.netty.channel.DefaultChannelPipeline.*;
+
+/**
+ * A set of helper methods for easier implementation of custom {@link ChannelHandlerInvoker} implementation.
+ */
+public final class ChannelHandlerInvokerUtil {
+
+    public static void invokeChannelRegisteredNow(ChannelHandlerContext ctx) {
+        try {
+            ((ChannelInboundHandler) ctx.handler()).channelRegistered(ctx);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeChannelUnregisteredNow(ChannelHandlerContext ctx) {
+        try {
+            ((ChannelInboundHandler) ctx.handler()).channelUnregistered(ctx);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeChannelActiveNow(final ChannelHandlerContext ctx) {
+        try {
+            ((ChannelInboundHandler) ctx.handler()).channelActive(ctx);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeChannelInactiveNow(final ChannelHandlerContext ctx) {
+        try {
+            ((ChannelInboundHandler) ctx.handler()).channelInactive(ctx);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeExceptionCaughtNow(final ChannelHandlerContext ctx, final Throwable cause) {
+        try {
+            ctx.handler().exceptionCaught(ctx, cause);
+        } catch (Throwable t) {
+            if (logger.isWarnEnabled()) {
+                logger.warn("An exception was thrown by a user handler's exceptionCaught() method:", t);
+                logger.warn(".. and the cause of the exceptionCaught() was:", cause);
+            }
+        }
+    }
+
+    public static void invokeUserEventTriggeredNow(final ChannelHandlerContext ctx, final Object event) {
+        try {
+            ((ChannelInboundHandler) ctx.handler()).userEventTriggered(ctx, event);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeChannelReadNow(final ChannelHandlerContext ctx, final Object msg) {
+        try {
+            ((ChannelInboundHandler) ctx.handler()).channelRead(ctx, msg);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeChannelReadCompleteNow(final ChannelHandlerContext ctx) {
+        try {
+            ((ChannelInboundHandler) ctx.handler()).channelReadComplete(ctx);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeChannelWritabilityChangedNow(final ChannelHandlerContext ctx) {
+        try {
+            ((ChannelInboundHandler) ctx.handler()).channelWritabilityChanged(ctx);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeBindNow(
+            final ChannelHandlerContext ctx, final SocketAddress localAddress, final ChannelPromise promise) {
+        try {
+            ((ChannelOutboundHandler) ctx.handler()).bind(ctx, localAddress, promise);
+        } catch (Throwable t) {
+            notifyOutboundHandlerException(t, promise);
+        }
+    }
+    public static void invokeConnectNow(
+            final ChannelHandlerContext ctx,
+            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
+        try {
+            ((ChannelOutboundHandler) ctx.handler()).connect(ctx, remoteAddress, localAddress, promise);
+        } catch (Throwable t) {
+            notifyOutboundHandlerException(t, promise);
+        }
+    }
+
+    public static void invokeDisconnectNow(final ChannelHandlerContext ctx, final ChannelPromise promise) {
+        try {
+            ((ChannelOutboundHandler) ctx.handler()).disconnect(ctx, promise);
+        } catch (Throwable t) {
+            notifyOutboundHandlerException(t, promise);
+        }
+    }
+
+    public static void invokeCloseNow(final ChannelHandlerContext ctx, final ChannelPromise promise) {
+        try {
+            ((ChannelOutboundHandler) ctx.handler()).close(ctx, promise);
+        } catch (Throwable t) {
+            notifyOutboundHandlerException(t, promise);
+        }
+    }
+
+    public static void invokeDeregisterNow(final ChannelHandlerContext ctx, final ChannelPromise promise) {
+        try {
+            ((ChannelOutboundHandler) ctx.handler()).deregister(ctx, promise);
+        } catch (Throwable t) {
+            notifyOutboundHandlerException(t, promise);
+        }
+    }
+
+    public static void invokeReadNow(final ChannelHandlerContext ctx) {
+        try {
+            ((ChannelOutboundHandler) ctx.handler()).read(ctx);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static void invokeWriteNow(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+        try {
+            ((ChannelOutboundHandler) ctx.handler()).write(ctx, msg, promise);
+        } catch (Throwable t) {
+            notifyOutboundHandlerException(t, promise);
+        }
+    }
+
+    public static void invokeFlushNow(final ChannelHandlerContext ctx) {
+        try {
+            ((ChannelOutboundHandler) ctx.handler()).flush(ctx);
+        } catch (Throwable t) {
+            notifyHandlerException(ctx, t);
+        }
+    }
+
+    public static boolean validatePromise(
+            ChannelHandlerContext ctx, ChannelPromise promise, boolean allowVoidPromise) {
+        if (ctx == null) {
+            throw new NullPointerException("ctx");
+        }
+
+        if (promise == null) {
+            throw new NullPointerException("promise");
+        }
+
+        if (promise.isDone()) {
+            if (promise.isCancelled()) {
+                return false;
+            }
+            throw new IllegalArgumentException("promise already done: " + promise);
+        }
+
+        if (promise.channel() != ctx.channel()) {
+            throw new IllegalArgumentException(String.format(
+                    "promise.channel does not match: %s (expected: %s)", promise.channel(), ctx.channel()));
+        }
+
+        if (promise.getClass() == DefaultChannelPromise.class) {
+            return true;
+        }
+
+        if (!allowVoidPromise && promise instanceof VoidChannelPromise) {
+            throw new IllegalArgumentException(
+                    StringUtil.simpleClassName(VoidChannelPromise.class) + " not allowed for this operation");
+        }
+
+        if (promise instanceof AbstractChannel.CloseFuture) {
+            throw new IllegalArgumentException(
+                    StringUtil.simpleClassName(AbstractChannel.CloseFuture.class) + " not allowed in a pipeline");
+        }
+        return true;
+    }
+
+    private static void notifyHandlerException(ChannelHandlerContext ctx, Throwable cause) {
+        if (inExceptionCaught(cause)) {
+            if (logger.isWarnEnabled()) {
+                logger.warn(
+                        "An exception was thrown by a user handler " +
+                                "while handling an exceptionCaught event", cause);
+            }
+            return;
+        }
+
+        invokeExceptionCaughtNow(ctx, cause);
+    }
+
+    private static void notifyOutboundHandlerException(Throwable cause, ChannelPromise promise) {
+        // only try to fail the promise if its not a VoidChannelPromise, as
+        // the VoidChannelPromise would also fire the cause through the pipeline
+        if (promise instanceof VoidChannelPromise) {
+            return;
+        }
+
+        if (!promise.tryFailure(cause)) {
+            if (logger.isWarnEnabled()) {
+                logger.warn("Failed to fail the promise because it's done already: {}", promise, cause);
+            }
+        }
+    }
+
+    private static boolean inExceptionCaught(Throwable cause) {
+        do {
+            StackTraceElement[] trace = cause.getStackTrace();
+            if (trace != null) {
+                for (StackTraceElement t : trace) {
+                    if (t == null) {
+                        break;
+                    }
+                    if ("exceptionCaught".equals(t.getMethodName())) {
+                        return true;
+                    }
+                }
+            }
+
+            cause = cause.getCause();
+        } while (cause != null);
+
+        return false;
+    }
+
+    private ChannelHandlerInvokerUtil() { }
+}
diff --git a/transport/src/main/java/io/netty/channel/ChannelId.java b/transport/src/main/java/io/netty/channel/ChannelId.java
new file mode 100644
index 000000000000..b62fff88812c
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/ChannelId.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import java.io.Serializable;
+
+/**
+ * Represents the globally unique identifier of a {@link Channel}.
+ * <p>
+ * The identifier is generated from various sources listed in the following:
+ * <ul>
+ * <li>MAC address (EUI-48 or EUI-64) or the network adapter, preferrably a globally unique one,</li>
+ * <li>the current process ID,</li>
+ * <li>{@link System#currentTimeMillis()},</li>
+ * <li>{@link System#nanoTime()},</li>
+ * <li>a random 32-bit integer, and</li>
+ * <li>a sequentially incremented 32-bit integer.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * The global uniqueness of the generated identifier mostly depends on the MAC address and the current process ID,
+ * which are auto-detected at the class-loading time in best-effort manner.  If all attempts to acquire them fail,
+ * a warning message is logged, and random values will be used instead.  Alternatively, you can specify them manually
+ * via system properties:
+ * <ul>
+ * <li>{@code io.netty.machineId} - hexadecimal representation of 48 (or 64) bit integer,
+ *     optionally separated by colon or hyphen.</li>
+ * <li>{@code io.netty.processId} - an integer between 0 and 65535</li>
+ * </ul>
+ * </p>
+ */
+public interface ChannelId extends Serializable, Comparable<ChannelId> {
+    /**
+     * Returns the short but globally non-unique string representation of the {@link ChannelId}.
+     */
+    String asShortText();
+
+    /**
+     * Returns the long yet globally unique string representation of the {@link ChannelId}.
+     */
+    String asLongText();
+}
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
index dc5a428b98cc..56693593f597 100644
--- a/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
+++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
@@ -28,10 +28,7 @@ public interface ChannelInboundHandler extends ChannelHandler {
 
     /**
      * The {@link Channel} of the {@link ChannelHandlerContext} was unregistered from its {@link EventLoop}
-     *
-     * @deprecated use {@link #channelInactive(ChannelHandlerContext)}
      */
-    @Deprecated
     void channelUnregistered(ChannelHandlerContext ctx) throws Exception;
 
     /**
diff --git a/transport/src/main/java/io/netty/channel/ChannelOption.java b/transport/src/main/java/io/netty/channel/ChannelOption.java
index c6f87cf2cff3..acd4423051f6 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOption.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java
@@ -16,12 +16,11 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.util.UniqueName;
-import io.netty.util.internal.PlatformDependent;
+import io.netty.util.AbstractConstant;
+import io.netty.util.ConstantPool;
 
 import java.net.InetAddress;
 import java.net.NetworkInterface;
-import java.util.concurrent.ConcurrentMap;
 
 /**
  * A {@link ChannelOption} allows to configure a {@link ChannelConfig} in a type-safe
@@ -31,10 +30,30 @@
  *
  * @param <T>   the type of the value which is valid for the {@link ChannelOption}
  */
-@SuppressWarnings("deprecation")
-public class ChannelOption<T> extends UniqueName {
+public final class ChannelOption<T> extends AbstractConstant<ChannelOption<T>> {
 
-    private static final ConcurrentMap<String, Boolean> names = PlatformDependent.newConcurrentHashMap();
+    private static final ConstantPool<ChannelOption<Object>> pool = new ConstantPool<ChannelOption<Object>>() {
+        @Override
+        protected ChannelOption<Object> newConstant(int id, String name) {
+            return new ChannelOption<Object>(id, name);
+        }
+    };
+
+    /**
+     * Returns the {@link ChannelOption} of the specified name.
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> ChannelOption<T> valueOf(String name) {
+        return (ChannelOption<T>) pool.valueOf(name);
+    }
+
+    /**
+     * Shortcut of {@link #valueOf(String) valueOf(firstNameComponent.getName() + "#" + secondNameComponent)}.
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> ChannelOption<T> valueOf(Class<?> firstNameComponent, String secondNameComponent) {
+        return (ChannelOption<T>) pool.valueOf(firstNameComponent, secondNameComponent);
+    }
 
     public static final ChannelOption<ByteBufAllocator> ALLOCATOR = valueOf("ALLOCATOR");
     public static final ChannelOption<RecvByteBufAllocator> RCVBUF_ALLOCATOR = valueOf("RCVBUF_ALLOCATOR");
@@ -75,28 +94,15 @@ public class ChannelOption<T> extends UniqueName {
 
     public static final ChannelOption<Boolean> TCP_NODELAY = valueOf("TCP_NODELAY");
 
-    @Deprecated
-    public static final ChannelOption<Long> AIO_READ_TIMEOUT = valueOf("AIO_READ_TIMEOUT");
-    @Deprecated
-    public static final ChannelOption<Long> AIO_WRITE_TIMEOUT = valueOf("AIO_WRITE_TIMEOUT");
-
     @Deprecated
     public static final ChannelOption<Boolean> DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION =
             valueOf("DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION");
 
     /**
-     * Creates a new {@link ChannelOption} with the specified {@code name}.
+     * Creates a new {@link ChannelOption} with the specified unique {@code name}.
      */
-    public static <T> ChannelOption<T> valueOf(String name) {
-        return new ChannelOption<T>(name);
-    }
-
-    /**
-     * @deprecated Use {@link #valueOf(String)} instead.
-     */
-    @Deprecated
-    protected ChannelOption(String name) {
-        super(names, name);
+    private ChannelOption(int id, String name) {
+        super(id, name);
     }
 
     /**
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
index 1d874ac28d51..06cd3a3f5088 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
@@ -23,7 +23,6 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufHolder;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.util.Recycler;
 import io.netty.util.Recycler.Handle;
 import io.netty.util.ReferenceCountUtil;
@@ -31,9 +30,7 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException;
-import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 
@@ -41,30 +38,31 @@
  * (Transport implementors only) an internal data structure used by {@link AbstractChannel} to store its pending
  * outbound write requests.
  */
-public final class ChannelOutboundBuffer {
+public class ChannelOutboundBuffer {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(ChannelOutboundBuffer.class);
 
-    private static final int INITIAL_CAPACITY = 32;
+    protected static final int INITIAL_CAPACITY = 32;
 
     private static final Recycler<ChannelOutboundBuffer> RECYCLER = new Recycler<ChannelOutboundBuffer>() {
         @Override
-        protected ChannelOutboundBuffer newObject(Handle handle) {
+        protected ChannelOutboundBuffer newObject(Handle<ChannelOutboundBuffer> handle) {
             return new ChannelOutboundBuffer(handle);
         }
     };
 
+    /**
+     * Get a new instance of this {@link ChannelOutboundBuffer} and attach it the given {@link AbstractChannel}
+     */
     static ChannelOutboundBuffer newInstance(AbstractChannel channel) {
         ChannelOutboundBuffer buffer = RECYCLER.get();
         buffer.channel = channel;
-        buffer.totalPendingSize = 0;
-        buffer.writable = 1;
         return buffer;
     }
 
-    private final Handle handle;
+    private final Handle<? extends ChannelOutboundBuffer> handle;
 
-    private AbstractChannel channel;
+    protected AbstractChannel channel;
 
     // A circular buffer used to store messages.  The buffer is arranged such that:  flushed <= unflushed <= tail.  The
     // flushed messages are stored in the range [flushed, unflushed).  Unflushed messages are stored in the range
@@ -74,10 +72,6 @@ static ChannelOutboundBuffer newInstance(AbstractChannel channel) {
     private int unflushed;
     private int tail;
 
-    private ByteBuffer[] nioBuffers;
-    private int nioBufferCount;
-    private long nioBufferSize;
-
     private boolean inFail;
 
     private static final AtomicLongFieldUpdater<ChannelOutboundBuffer> TOTAL_PENDING_SIZE_UPDATER;
@@ -104,18 +98,29 @@ static ChannelOutboundBuffer newInstance(AbstractChannel channel) {
 
     private volatile int writable = 1;
 
-    private ChannelOutboundBuffer(Handle handle) {
+    protected ChannelOutboundBuffer(Handle<? extends ChannelOutboundBuffer> handle) {
         this.handle = handle;
 
         buffer = new Entry[INITIAL_CAPACITY];
         for (int i = 0; i < buffer.length; i++) {
-            buffer[i] = new Entry();
+            buffer[i] = newEntry();
         }
+    }
 
-        nioBuffers = new ByteBuffer[INITIAL_CAPACITY];
+    /**
+     * Return the array of {@link Entry}'s which hold the pending write requests in an circular array.
+     */
+    protected final Entry[] entries() {
+        return buffer;
     }
 
-    void addMessage(Object msg, ChannelPromise promise) {
+    /**
+     * Add the given message to this {@link ChannelOutboundBuffer} so it will be marked as flushed once
+     * {@link #addFlush()} was called. The {@link ChannelPromise} will be notified once the write operations
+     * completes.
+     */
+    public final void addMessage(Object msg, ChannelPromise promise) {
+        msg = beforeAdd(msg);
         int size = channel.estimatorHandle().size(msg);
         if (size < 0) {
             size = 0;
@@ -138,6 +143,17 @@ void addMessage(Object msg, ChannelPromise promise) {
         incrementPendingOutboundBytes(size);
     }
 
+    /**
+     * Is called before the message is actually added to the {@link ChannelOutboundBuffer} and so allow to
+     * convert it to a different format. Sub-classes may override this.
+     */
+    protected Object beforeAdd(Object msg) {
+        return msg;
+    }
+
+    /**
+     * Expand internal array which holds the {@link Entry}'s.
+     */
     private void addCapacity() {
         int p = flushed;
         int n = buffer.length;
@@ -153,7 +169,7 @@ private void addCapacity() {
         System.arraycopy(buffer, p, e, 0, r);
         System.arraycopy(buffer, 0, e, r, p);
         for (int i = n; i < e.length; i++) {
-            e[i] = new Entry();
+            e[i] = newEntry();
         }
 
         buffer = e;
@@ -162,15 +178,36 @@ private void addCapacity() {
         tail = n;
     }
 
-    void addFlush() {
-        unflushed = tail;
+    /**
+     * Mark all messages in this {@link ChannelOutboundBuffer} as flushed.
+     */
+    public final void addFlush() {
+        // There is no need to process all entries if there was already a flush before and no new messages
+        // where added in the meantime.
+        //
+        // See https://github.com/netty/netty/issues/2577
+        if (unflushed != tail) {
+            unflushed = tail;
+
+            final int mask = buffer.length - 1;
+            int i = flushed;
+            while (i != unflushed && buffer[i].msg != null) {
+                Entry entry = buffer[i];
+                if (!entry.promise.setUncancellable()) {
+                    // Was cancelled so make sure we free up memory and notify about the freed bytes
+                    int pending = entry.cancel();
+                    decrementPendingOutboundBytes(pending);
+                }
+                i = i + 1 & mask;
+            }
+        }
     }
 
     /**
      * Increment the pending bytes which will be written at some point.
      * This method is thread-safe!
      */
-    void incrementPendingOutboundBytes(int size) {
+    final void incrementPendingOutboundBytes(int size) {
         // Cache the channel and check for null to make sure we not produce a NPE in case of the Channel gets
         // recycled while process this method.
         Channel channel = this.channel;
@@ -178,16 +215,8 @@ void incrementPendingOutboundBytes(int size) {
             return;
         }
 
-        long oldValue = totalPendingSize;
-        long newWriteBufferSize = oldValue + size;
-        while (!TOTAL_PENDING_SIZE_UPDATER.compareAndSet(this, oldValue, newWriteBufferSize)) {
-            oldValue = totalPendingSize;
-            newWriteBufferSize = oldValue + size;
-        }
-
-        int highWaterMark = channel.config().getWriteBufferHighWaterMark();
-
-        if (newWriteBufferSize > highWaterMark) {
+        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);
+        if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {
             if (WRITABLE_UPDATER.compareAndSet(this, 1, 0)) {
                 channel.pipeline().fireChannelWritabilityChanged();
             }
@@ -198,7 +227,7 @@ void incrementPendingOutboundBytes(int size) {
      * Decrement the pending bytes which will be written at some point.
      * This method is thread-safe!
      */
-    void decrementPendingOutboundBytes(int size) {
+    final void decrementPendingOutboundBytes(int size) {
         // Cache the channel and check for null to make sure we not produce a NPE in case of the Channel gets
         // recycled while process this method.
         Channel channel = this.channel;
@@ -206,16 +235,8 @@ void decrementPendingOutboundBytes(int size) {
             return;
         }
 
-        long oldValue = totalPendingSize;
-        long newWriteBufferSize = oldValue - size;
-        while (!TOTAL_PENDING_SIZE_UPDATER.compareAndSet(this, oldValue, newWriteBufferSize)) {
-            oldValue = totalPendingSize;
-            newWriteBufferSize = oldValue - size;
-        }
-
-        int lowWaterMark = channel.config().getWriteBufferLowWaterMark();
-
-        if (newWriteBufferSize == 0 || newWriteBufferSize < lowWaterMark) {
+        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, -size);
+        if (newWriteBufferSize == 0 || newWriteBufferSize < channel.config().getWriteBufferLowWaterMark()) {
             if (WRITABLE_UPDATER.compareAndSet(this, 0, 1)) {
                 channel.pipeline().fireChannelWritabilityChanged();
             }
@@ -235,32 +256,20 @@ private static long total(Object msg) {
         return -1;
     }
 
-    public Object current() {
+    /**
+     * Return current message or {@code null} if no flushed message is left to process.
+     */
+    public final Object current() {
         if (isEmpty()) {
             return null;
         } else {
+            // TODO: Think of a smart way to handle ByteBufHolder messages
             Entry entry = buffer[flushed];
-            if (!entry.cancelled && !entry.promise.setUncancellable()) {
-                // Was cancelled so make sure we free up memory and notify about the freed bytes
-                int pending = entry.cancel();
-                decrementPendingOutboundBytes(pending);
-            }
-
             return entry.msg;
         }
     }
 
-    /**
-     * Replace the current msg with the given one.
-     * The replaced msg will automatically be released
-     */
-    public void current(Object msg) {
-        Entry entry =  buffer[flushed];
-        safeRelease(entry.msg);
-        entry.msg = msg;
-    }
-
-    public void progress(long amount) {
+    public final void progress(long amount) {
         Entry e = buffer[flushed];
         ChannelPromise p = e.promise;
         if (p instanceof ChannelProgressivePromise) {
@@ -270,7 +279,11 @@ public void progress(long amount) {
         }
     }
 
-    public boolean remove() {
+    /**
+     * Mark the current message as successful written and remove it from this {@link ChannelOutboundBuffer}.
+     * This method will return {@code true} if there are more messages left to process,  {@code false} otherwise.
+     */
+    public final boolean remove() {
         if (isEmpty()) {
             return false;
         }
@@ -298,7 +311,12 @@ public boolean remove() {
         return true;
     }
 
-    public boolean remove(Throwable cause) {
+    /**
+     * Mark the current message as failure with the given {@link java.lang.Throwable} and remove it from this
+     * {@link ChannelOutboundBuffer}. This method will return {@code true} if there are more messages left to process,
+     * {@code false} otherwise.
+     */
+    public final boolean remove(Throwable cause) {
         if (isEmpty()) {
             return false;
         }
@@ -327,151 +345,28 @@ public boolean remove(Throwable cause) {
         return true;
     }
 
-    /**
-     * Returns an array of direct NIO buffers if the currently pending messages are made of {@link ByteBuf} only.
-     * {@code null} is returned otherwise.  If this method returns a non-null array, {@link #nioBufferCount()} and
-     * {@link #nioBufferSize()} will return the number of NIO buffers in the returned array and the total number
-     * of readable bytes of the NIO buffers respectively.
-     * <p>
-     * Note that the returned array is reused and thus should not escape
-     * {@link AbstractChannel#doWrite(ChannelOutboundBuffer)}.
-     * Refer to {@link NioSocketChannel#doWrite(ChannelOutboundBuffer)} for an example.
-     * </p>
-     */
-    public ByteBuffer[] nioBuffers() {
-        long nioBufferSize = 0;
-        int nioBufferCount = 0;
-        final int mask = buffer.length - 1;
-        final ByteBufAllocator alloc = channel.alloc();
-        ByteBuffer[] nioBuffers = this.nioBuffers;
-        Object m;
-        int i = flushed;
-        while (i != unflushed && (m = buffer[i].msg) != null) {
-            if (!(m instanceof ByteBuf)) {
-                this.nioBufferCount = 0;
-                this.nioBufferSize = 0;
-                return null;
-            }
-
-            Entry entry = buffer[i];
-            if (!entry.cancelled) {
-                if (!entry.promise.setUncancellable()) {
-                    // Was cancelled so make sure we free up memory and notify about the freed bytes
-                    int pending = entry.cancel();
-                    decrementPendingOutboundBytes(pending);
-                } else {
-                    ByteBuf buf = (ByteBuf) m;
-                    final int readerIndex = buf.readerIndex();
-                    final int readableBytes = buf.writerIndex() - readerIndex;
-
-                    if (readableBytes > 0) {
-                        nioBufferSize += readableBytes;
-                        int count = entry.count;
-                        if (count == -1) {
-                            //noinspection ConstantValueVariableUse
-                            entry.count = count =  buf.nioBufferCount();
-                        }
-                        int neededSpace = nioBufferCount + count;
-                        if (neededSpace > nioBuffers.length) {
-                            this.nioBuffers = nioBuffers =
-                                    expandNioBufferArray(nioBuffers, neededSpace, nioBufferCount);
-                        }
-                        if (buf.isDirect() || !alloc.isDirectBufferPooled()) {
-                            if (count == 1) {
-                                ByteBuffer nioBuf = entry.buf;
-                                if (nioBuf == null) {
-                                    // cache ByteBuffer as it may need to create a new ByteBuffer instance if its a
-                                    // derived buffer
-                                    entry.buf = nioBuf = buf.internalNioBuffer(readerIndex, readableBytes);
-                                }
-                                nioBuffers[nioBufferCount ++] = nioBuf;
-                            } else {
-                                ByteBuffer[] nioBufs = entry.buffers;
-                                if (nioBufs == null) {
-                                    // cached ByteBuffers as they may be expensive to create in terms
-                                    // of Object allocation
-                                    entry.buffers = nioBufs = buf.nioBuffers();
-                                }
-                                nioBufferCount = fillBufferArray(nioBufs, nioBuffers, nioBufferCount);
-                            }
-                        } else {
-                            nioBufferCount = fillBufferArrayNonDirect(entry, buf, readerIndex,
-                                    readableBytes, alloc, nioBuffers, nioBufferCount);
-                        }
-                    }
-                }
-            }
-            i = i + 1 & mask;
-        }
-        this.nioBufferCount = nioBufferCount;
-        this.nioBufferSize = nioBufferSize;
-
-        return nioBuffers;
-    }
-
-    private static int fillBufferArray(ByteBuffer[] nioBufs, ByteBuffer[] nioBuffers, int nioBufferCount) {
-        for (ByteBuffer nioBuf: nioBufs) {
-            if (nioBuf == null) {
-                break;
-            }
-            nioBuffers[nioBufferCount ++] = nioBuf;
-        }
-        return nioBufferCount;
-    }
-
-    private static int fillBufferArrayNonDirect(Entry entry, ByteBuf buf, int readerIndex, int readableBytes,
-                                      ByteBufAllocator alloc, ByteBuffer[] nioBuffers, int nioBufferCount) {
-        ByteBuf directBuf = alloc.directBuffer(readableBytes);
-        directBuf.writeBytes(buf, readerIndex, readableBytes);
-        buf.release();
-        entry.msg = directBuf;
-        // cache ByteBuffer
-        ByteBuffer nioBuf = entry.buf = directBuf.internalNioBuffer(0, readableBytes);
-        entry.count = 1;
-        nioBuffers[nioBufferCount ++] = nioBuf;
-        return nioBufferCount;
-    }
-
-    private static ByteBuffer[] expandNioBufferArray(ByteBuffer[] array, int neededSpace, int size) {
-        int newCapacity = array.length;
-        do {
-            // double capacity until it is big enough
-            // See https://github.com/netty/netty/issues/1890
-            newCapacity <<= 1;
-
-            if (newCapacity < 0) {
-                throw new IllegalStateException();
-            }
-
-        } while (neededSpace > newCapacity);
-
-        ByteBuffer[] newArray = new ByteBuffer[newCapacity];
-        System.arraycopy(array, 0, newArray, 0, size);
-
-        return newArray;
-    }
-
-    public int nioBufferCount() {
-        return nioBufferCount;
-    }
-
-    public long nioBufferSize() {
-        return nioBufferSize;
-    }
-
-    boolean getWritable() {
+    final boolean getWritable() {
         return writable != 0;
     }
 
-    public int size() {
+    /**
+     * Return the number of messages that are ready to be written (flushed before).
+     */
+    public final int size() {
         return unflushed - flushed & buffer.length - 1;
     }
 
-    public boolean isEmpty() {
+    /**
+     * Return {@code true} if this {@link ChannelOutboundBuffer} contains no flushed messages
+     */
+    public final boolean isEmpty() {
         return unflushed == flushed;
     }
 
-    void failFlushed(Throwable cause) {
+    /**
+     * Fail all previous flushed messages with the given {@link Throwable}.
+     */
+    final void failFlushed(Throwable cause) {
         // Make sure that this method does not reenter.  A listener added to the current promise can be notified by the
         // current thread in the tryFailure() call of the loop below, and the listener can trigger another fail() call
         // indirectly (usually by closing the channel.)
@@ -493,7 +388,10 @@ void failFlushed(Throwable cause) {
         }
     }
 
-    void close(final ClosedChannelException cause) {
+    /**
+     * Fail all pending messages with the given {@link ClosedChannelException}.
+     */
+   final void close(final ClosedChannelException cause) {
         if (inFail) {
             channel.eventLoop().execute(new Runnable() {
                 @Override
@@ -522,12 +420,7 @@ public void run() {
 
                 // Just decrease; do not trigger any events via decrementPendingOutboundBytes()
                 int size = e.pendingSize;
-                long oldValue = totalPendingSize;
-                long newWriteBufferSize = oldValue - size;
-                while (!TOTAL_PENDING_SIZE_UPDATER.compareAndSet(this, oldValue, newWriteBufferSize)) {
-                    oldValue = totalPendingSize;
-                    newWriteBufferSize = oldValue - size;
-                }
+                TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, -size);
 
                 e.pendingSize = 0;
                 if (!e.cancelled) {
@@ -545,7 +438,10 @@ public void run() {
         recycle();
     }
 
-    private static void safeRelease(Object message) {
+    /**
+     * Release the message and log if any error happens during release.
+     */
+    protected static void safeRelease(Object message) {
         try {
             ReferenceCountUtil.release(message);
         } catch (Throwable t) {
@@ -553,18 +449,29 @@ private static void safeRelease(Object message) {
         }
     }
 
+    /**
+     * Try to mark the given {@link ChannelPromise} as success and log if this failed.
+     */
     private static void safeSuccess(ChannelPromise promise) {
         if (!(promise instanceof VoidChannelPromise) && !promise.trySuccess()) {
             logger.warn("Failed to mark a promise as success because it is done already: {}", promise);
         }
     }
 
+    /**
+     * Try to mark the given {@link ChannelPromise} as failued with the given {@link Throwable} and log if this failed.
+     */
     private static void safeFail(ChannelPromise promise, Throwable cause) {
         if (!(promise instanceof VoidChannelPromise) && !promise.tryFailure(cause)) {
             logger.warn("Failed to mark a promise as failure because it's done already: {}", promise, cause);
         }
     }
 
+    /**
+     * Recycle this {@link ChannelOutboundBuffer}. After this was called it is disallowed to use it with the previous
+     * assigned {@link AbstractChannel}.
+     */
+    @SuppressWarnings("unchecked")
     public void recycle() {
         if (buffer.length > INITIAL_CAPACITY) {
             Entry[] e = new Entry[INITIAL_CAPACITY];
@@ -572,14 +479,6 @@ public void recycle() {
             buffer = e;
         }
 
-        if (nioBuffers.length > INITIAL_CAPACITY) {
-            nioBuffers = new ByteBuffer[INITIAL_CAPACITY];
-        } else {
-            // null out the nio buffers array so the can be GC'ed
-            // https://github.com/netty/netty/issues/1763
-            Arrays.fill(nioBuffers, null);
-        }
-
         // reset flushed, unflushed and tail
         // See https://github.com/netty/netty/issues/1772
         flushed = 0;
@@ -589,17 +488,61 @@ public void recycle() {
         // Set the channel to null so it can be GC'ed ASAP
         channel = null;
 
-        RECYCLER.recycle(this, handle);
+        totalPendingSize = 0;
+        writable = 1;
+
+        RECYCLER.recycle(this, (Handle<ChannelOutboundBuffer>) handle);
     }
 
-    public long totalPendingWriteBytes() {
+    /**
+     * Return the total number of pending bytes.
+     */
+    public final long totalPendingWriteBytes() {
         return totalPendingSize;
     }
 
-    private static final class Entry {
+    /**
+     * Create a new {@link Entry} to use for the internal datastructure. Sub-classes may override this use a special
+     * sub-class.
+     */
+    protected Entry newEntry() {
+        return new Entry();
+    }
+
+    /**
+     * Return the index of the first flushed message.
+     */
+    protected final int flushed() {
+        return flushed;
+    }
+
+    /**
+     * Return the index of the first unflushed messages.
+     */
+    protected final int unflushed() {
+        return unflushed;
+    }
+
+    protected ByteBuf copyToDirectByteBuf(ByteBuf buf) {
+        int readableBytes = buf.readableBytes();
+        ByteBufAllocator alloc = channel.alloc();
+        if (alloc.isDirectBufferPooled()) {
+            ByteBuf directBuf = alloc.directBuffer(readableBytes);
+            directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);
+            safeRelease(buf);
+            return directBuf;
+        }
+        if (ThreadLocalPooledDirectByteBuf.threadLocalDirectBufferSize > 0) {
+            ByteBuf directBuf = ThreadLocalPooledDirectByteBuf.newInstance();
+            directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);
+            safeRelease(buf);
+            return directBuf;
+        }
+        return buf;
+    }
+
+    protected static class Entry {
         Object msg;
-        ByteBuffer[] buffers;
-        ByteBuffer buf;
         ChannelPromise promise;
         long progress;
         long total;
@@ -607,6 +550,22 @@ private static final class Entry {
         int count = -1;
         boolean cancelled;
 
+        public Object msg() {
+            return msg;
+        }
+
+        /**
+         * Return {@code true} if the {@link Entry} was cancelled via {@link #cancel()} before,
+         * {@code false} otherwise.
+         */
+        public boolean isCancelled() {
+            return cancelled;
+        }
+
+        /**
+         * Cancel this {@link Entry} and the message that was hold by this {@link Entry}. This method returns the
+         * number of pending bytes for the cancelled message.
+         */
         public int cancel() {
             if (!cancelled) {
                 cancelled = true;
@@ -619,16 +578,15 @@ public int cancel() {
                 pendingSize = 0;
                 total = 0;
                 progress = 0;
-                buffers = null;
-                buf = null;
                 return pSize;
             }
             return 0;
         }
 
+        /**
+         * Clear this {@link Entry} and so release all resources.
+         */
         public void clear() {
-            buffers = null;
-            buf = null;
             msg = null;
             promise = null;
             progress = 0;
@@ -638,5 +596,4 @@ public void clear() {
             cancelled = false;
         }
     }
-
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java b/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
index 0795198195d1..92a3943ad042 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
@@ -69,7 +69,6 @@ void connect(
      * @param promise           the {@link ChannelPromise} to notify once the operation completes
      * @throws Exception        thrown if an error accour
      */
-    @Deprecated
     void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
 
     /**
diff --git a/transport/src/main/java/io/netty/channel/ChannelPipeline.java b/transport/src/main/java/io/netty/channel/ChannelPipeline.java
index 2ac3e52c48be..0cb99989d0fa 100644
--- a/transport/src/main/java/io/netty/channel/ChannelPipeline.java
+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java
@@ -215,8 +215,7 @@
  * For example, you can insert an encryption handler when sensitive information is about to be exchanged, and remove it
  * after the exchange.
  */
-public interface ChannelPipeline
-         extends Iterable<Entry<String, ChannelHandler>> {
+public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>> {
 
     /**
      * Inserts a {@link ChannelHandler} at the first position of this pipeline.
@@ -246,6 +245,20 @@ public interface ChannelPipeline
      */
     ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler);
 
+    /**
+     * Inserts a {@link ChannelHandler} at the first position of this pipeline.
+     *
+     * @param invoker  the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
+     * @param name     the name of the handler to insert first
+     * @param handler  the handler to insert first
+     *
+     * @throws IllegalArgumentException
+     *         if there's an entry with the same name already in the pipeline
+     * @throws NullPointerException
+     *         if the specified name or handler is {@code null}
+     */
+    ChannelPipeline addFirst(ChannelHandlerInvoker invoker, String name, ChannelHandler handler);
+
     /**
      * Appends a {@link ChannelHandler} at the last position of this pipeline.
      *
@@ -274,6 +287,20 @@ public interface ChannelPipeline
      */
     ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler);
 
+    /**
+     * Appends a {@link ChannelHandler} at the last position of this pipeline.
+     *
+     * @param invoker  the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
+     * @param name     the name of the handler to append
+     * @param handler  the handler to append
+     *
+     * @throws IllegalArgumentException
+     *         if there's an entry with the same name already in the pipeline
+     * @throws NullPointerException
+     *         if the specified name or handler is {@code null}
+     */
+    ChannelPipeline addLast(ChannelHandlerInvoker invoker, String name, ChannelHandler handler);
+
     /**
      * Inserts a {@link ChannelHandler} before an existing handler of this
      * pipeline.
@@ -310,6 +337,24 @@ public interface ChannelPipeline
      */
     ChannelPipeline addBefore(EventExecutorGroup group, String baseName, String name, ChannelHandler handler);
 
+    /**
+     * Inserts a {@link ChannelHandler} before an existing handler of this
+     * pipeline.
+     *
+     * @param invoker   the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
+     * @param baseName  the name of the existing handler
+     * @param name      the name of the handler to insert before
+     * @param handler   the handler to insert before
+     *
+     * @throws NoSuchElementException
+     *         if there's no such entry with the specified {@code baseName}
+     * @throws IllegalArgumentException
+     *         if there's an entry with the same name already in the pipeline
+     * @throws NullPointerException
+     *         if the specified baseName, name, or handler is {@code null}
+     */
+    ChannelPipeline addBefore(ChannelHandlerInvoker invoker, String baseName, String name, ChannelHandler handler);
+
     /**
      * Inserts a {@link ChannelHandler} after an existing handler of this
      * pipeline.
@@ -346,6 +391,24 @@ public interface ChannelPipeline
      */
     ChannelPipeline addAfter(EventExecutorGroup group, String baseName, String name, ChannelHandler handler);
 
+    /**
+     * Inserts a {@link ChannelHandler} after an existing handler of this
+     * pipeline.
+     *
+     * @param invoker   the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
+     * @param baseName  the name of the existing handler
+     * @param name      the name of the handler to insert after
+     * @param handler   the handler to insert after
+     *
+     * @throws NoSuchElementException
+     *         if there's no such entry with the specified {@code baseName}
+     * @throws IllegalArgumentException
+     *         if there's an entry with the same name already in the pipeline
+     * @throws NullPointerException
+     *         if the specified baseName, name, or handler is {@code null}
+     */
+    ChannelPipeline addAfter(ChannelHandlerInvoker invoker, String baseName, String name, ChannelHandler handler);
+
     /**
      * Inserts a {@link ChannelHandler}s at the first position of this pipeline.
      *
@@ -364,6 +427,15 @@ public interface ChannelPipeline
      */
     ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler... handlers);
 
+    /**
+     * Inserts a {@link ChannelHandler}s at the first position of this pipeline.
+     *
+     * @param invoker   the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
+     * @param handlers  the handlers to insert first
+     *
+     */
+    ChannelPipeline addFirst(ChannelHandlerInvoker invoker, ChannelHandler... handlers);
+
     /**
      * Inserts a {@link ChannelHandler}s at the last position of this pipeline.
      *
@@ -382,6 +454,15 @@ public interface ChannelPipeline
      */
     ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers);
 
+    /**
+     * Inserts a {@link ChannelHandler}s at the last position of this pipeline.
+     *
+     * @param invoker   the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
+     * @param handlers  the handlers to insert last
+     *
+     */
+    ChannelPipeline addLast(ChannelHandlerInvoker invoker, ChannelHandler... handlers);
+
     /**
      * Removes the specified {@link ChannelHandler} from this pipeline.
      *
@@ -612,7 +693,6 @@ <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
      * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
-    @Deprecated
     ChannelPipeline fireChannelUnregistered();
 
     /**
@@ -746,7 +826,6 @@ <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
      * {@link Channel}.
      *
      */
-    @Deprecated
     ChannelFuture deregister();
 
     /**
@@ -834,7 +913,6 @@ <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
      * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
-    @Deprecated
     ChannelFuture deregister(ChannelPromise promise);
 
     /**
diff --git a/transport/src/main/java/io/netty/channel/ChannelProgressivePromise.java b/transport/src/main/java/io/netty/channel/ChannelProgressivePromise.java
index b665b7d4e390..b2f9b7c523b0 100644
--- a/transport/src/main/java/io/netty/channel/ChannelProgressivePromise.java
+++ b/transport/src/main/java/io/netty/channel/ChannelProgressivePromise.java
@@ -59,4 +59,7 @@ public interface ChannelProgressivePromise extends ProgressivePromise<Void>, Cha
 
     @Override
     ChannelProgressivePromise setProgress(long progress, long total);
+
+    @Override
+    ChannelProgressivePromise unvoid();
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelPromise.java b/transport/src/main/java/io/netty/channel/ChannelPromise.java
index b808c6395a3c..3c9dd2407df8 100644
--- a/transport/src/main/java/io/netty/channel/ChannelPromise.java
+++ b/transport/src/main/java/io/netty/channel/ChannelPromise.java
@@ -60,4 +60,9 @@ public interface ChannelPromise extends ChannelFuture, Promise<Void> {
 
     @Override
     ChannelPromise awaitUninterruptibly();
+
+    /**
+     * Returns a new {@link ChannelPromise} if {@link #isVoid()} returns {@code true} otherwise itself.
+     */
+    ChannelPromise unvoid();
 }
diff --git a/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java b/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
index 7ba94a1208f7..95ebac6dfcb2 100644
--- a/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
+++ b/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
@@ -18,9 +18,9 @@
 import java.net.SocketAddress;
 
 /**
- *  Combines a {@link ChannelInboundHandler} and a {@link ChannelOutboundHandler} into one {@link ChannelHandler}.
- *
+ * @deprecated Use {@link ChannelHandlerAppender} instead.
  */
+@Deprecated
 public class CombinedChannelDuplexHandler<I extends ChannelInboundHandler, O extends ChannelOutboundHandler>
         extends ChannelDuplexHandler {
 
@@ -55,7 +55,6 @@ protected final void init(I inboundHandler, O outboundHandler) {
         this.outboundHandler = outboundHandler;
     }
 
-    @SuppressWarnings("InstanceofIncompatibleInterface")
     private void validate(I inboundHandler, O outboundHandler) {
         if (this.inboundHandler != null) {
             throw new IllegalStateException(
diff --git a/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java
index 4557aa393875..67a86e5d97ce 100644
--- a/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java
+++ b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java
@@ -104,4 +104,9 @@ public Channel channel() {
     public Void getNow() {
         return null;
     }
+
+    @Override
+    public boolean isVoid() {
+        return false;
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java b/transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java
index 017164f9acb4..bc561399f42b 100644
--- a/transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java
+++ b/transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java
@@ -102,6 +102,18 @@ public boolean release(int decrement) {
         return ReferenceCountUtil.release(message, decrement);
     }
 
+    @Override
+    public AddressedEnvelope<M, A> touch() {
+        ReferenceCountUtil.touch(message);
+        return this;
+    }
+
+    @Override
+    public AddressedEnvelope<M, A> touch(Object hint) {
+        ReferenceCountUtil.touch(message, hint);
+        return this;
+    }
+
     @Override
     public String toString() {
         if (sender != null) {
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
index 2623183d1d3f..ccacd5a5f616 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
@@ -16,7 +16,6 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.channel.nio.AbstractNioByteChannel;
 import io.netty.channel.socket.SocketChannelConfig;
 
@@ -31,7 +30,6 @@
  */
 public class DefaultChannelConfig implements ChannelConfig {
 
-    private static final ByteBufAllocator DEFAULT_ALLOCATOR = UnpooledByteBufAllocator.DEFAULT;
     private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = AdaptiveRecvByteBufAllocator.DEFAULT;
     private static final MessageSizeEstimator DEFAULT_MSG_SIZE_ESTIMATOR = DefaultMessageSizeEstimator.DEFAULT;
 
@@ -39,7 +37,7 @@ public class DefaultChannelConfig implements ChannelConfig {
 
     protected final Channel channel;
 
-    private volatile ByteBufAllocator allocator = DEFAULT_ALLOCATOR;
+    private volatile ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;
     private volatile RecvByteBufAllocator rcvBufAllocator = DEFAULT_RCVBUF_ALLOCATOR;
     private volatile MessageSizeEstimator msgSizeEstimator = DEFAULT_MSG_SIZE_ESTIMATOR;
 
@@ -268,10 +266,18 @@ public ChannelConfig setAutoRead(boolean autoRead) {
         this.autoRead = autoRead;
         if (autoRead && !oldAutoRead) {
             channel.read();
+        } else if (!autoRead && oldAutoRead) {
+            autoReadCleared();
         }
         return this;
     }
 
+    /**
+     * Is called once {@link #setAutoRead(boolean)} is called with {@code false} and {@link #isAutoRead()} was
+     * {@code true} before.
+     */
+    protected void autoReadCleared() { }
+
     @Override
     public boolean isAutoClose() {
         return autoClose;
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
index 6bb3d282645b..8092cd55a14c 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
@@ -1,136 +1,31 @@
 /*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
+* Copyright 2014 The Netty Project
+*
+* The Netty Project licenses this file to you under the Apache License,
+* version 2.0 (the "License"); you may not use this file except in compliance
+* with the License. You may obtain a copy of the License at:
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
 package io.netty.channel;
 
-import static io.netty.channel.DefaultChannelPipeline.logger;
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.util.DefaultAttributeMap;
-import io.netty.util.Recycler;
-import io.netty.util.ReferenceCountUtil;
-import io.netty.util.concurrent.EventExecutor;
-import io.netty.util.concurrent.EventExecutorGroup;
-import io.netty.util.internal.StringUtil;
+final class DefaultChannelHandlerContext extends AbstractChannelHandlerContext {
 
-import java.net.SocketAddress;
-
-final class DefaultChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext {
-
-    volatile DefaultChannelHandlerContext next;
-    volatile DefaultChannelHandlerContext prev;
-
-    private final boolean inbound;
-    private final boolean outbound;
-    private final AbstractChannel channel;
-    private final DefaultChannelPipeline pipeline;
-    private final String name;
     private final ChannelHandler handler;
-    private boolean removed;
-
-    // Will be set to null if no child executor should be used, otherwise it will be set to the
-    // child executor.
-    final EventExecutor executor;
-    private ChannelFuture succeededFuture;
-
-    // Lazily instantiated tasks used to trigger events to a handler with different executor.
-    // These needs to be volatile as otherwise an other Thread may see an half initialized instance.
-    // See the JMM for more details
-    private volatile Runnable invokeChannelReadCompleteTask;
-    private volatile Runnable invokeReadTask;
-    private volatile Runnable invokeChannelWritableStateChangedTask;
-    private volatile Runnable invokeFlushTask;
 
-    DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutorGroup group, String name,
-            ChannelHandler handler) {
-
-        if (name == null) {
-            throw new NullPointerException("name");
-        }
+    DefaultChannelHandlerContext(
+            DefaultChannelPipeline pipeline, ChannelHandlerInvoker invoker, String name, ChannelHandler handler) {
+        super(pipeline, invoker, name, isInbound(handler), isOutbound(handler));
         if (handler == null) {
             throw new NullPointerException("handler");
         }
-
-        channel = pipeline.channel;
-        this.pipeline = pipeline;
-        this.name = name;
         this.handler = handler;
-
-        if (group != null) {
-            // Pin one of the child executors once and remember it so that the same child executor
-            // is used to fire events for the same channel.
-            EventExecutor childExecutor = pipeline.childExecutors.get(group);
-            if (childExecutor == null) {
-                childExecutor = group.next();
-                pipeline.childExecutors.put(group, childExecutor);
-            }
-            executor = childExecutor;
-        } else {
-            executor = null;
-        }
-
-        inbound = handler instanceof ChannelInboundHandler;
-        outbound = handler instanceof ChannelOutboundHandler;
-    }
-
-    /** Invocation initiated by {@link DefaultChannelPipeline#teardownAll()}}. */
-    void teardown() {
-        EventExecutor executor = executor();
-        if (executor.inEventLoop()) {
-            teardown0();
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    teardown0();
-                }
-            });
-        }
-    }
-
-    private void teardown0() {
-        DefaultChannelHandlerContext prev = this.prev;
-        if (prev != null) {
-            synchronized (pipeline) {
-                pipeline.remove0(this);
-            }
-            prev.teardown();
-        }
-    }
-
-    @Override
-    public Channel channel() {
-        return channel;
-    }
-
-    @Override
-    public ChannelPipeline pipeline() {
-        return pipeline;
-    }
-
-    @Override
-    public ByteBufAllocator alloc() {
-        return channel().config().getAllocator();
-    }
-
-    @Override
-    public EventExecutor executor() {
-        if (executor == null) {
-            return channel().eventLoop();
-        } else {
-            return executor;
-        }
     }
 
     @Override
@@ -138,840 +33,11 @@ public ChannelHandler handler() {
         return handler;
     }
 
-    @Override
-    public String name() {
-        return name;
-    }
-
-    @Override
-    public ChannelHandlerContext fireChannelRegistered() {
-        final DefaultChannelHandlerContext next = findContextInbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeChannelRegistered();
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeChannelRegistered();
-                }
-            });
-        }
-        return this;
-    }
-
-    private void invokeChannelRegistered() {
-        try {
-            ((ChannelInboundHandler) handler).channelRegistered(this);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext fireChannelUnregistered() {
-        final DefaultChannelHandlerContext next = findContextInbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeChannelUnregistered();
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeChannelUnregistered();
-                }
-            });
-        }
-        return this;
-    }
-
-    private void invokeChannelUnregistered() {
-        try {
-            ((ChannelInboundHandler) handler).channelUnregistered(this);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext fireChannelActive() {
-        final DefaultChannelHandlerContext next = findContextInbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeChannelActive();
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeChannelActive();
-                }
-            });
-        }
-        return this;
-    }
-
-    private void invokeChannelActive() {
-        try {
-            ((ChannelInboundHandler) handler).channelActive(this);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext fireChannelInactive() {
-        final DefaultChannelHandlerContext next = findContextInbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeChannelInactive();
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeChannelInactive();
-                }
-            });
-        }
-        return this;
-    }
-
-    private void invokeChannelInactive() {
-        try {
-            ((ChannelInboundHandler) handler).channelInactive(this);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext fireExceptionCaught(final Throwable cause) {
-        if (cause == null) {
-            throw new NullPointerException("cause");
-        }
-
-        final DefaultChannelHandlerContext next = this.next;
-
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeExceptionCaught(cause);
-        } else {
-            try {
-                executor.execute(new Runnable() {
-                    @Override
-                    public void run() {
-                        next.invokeExceptionCaught(cause);
-                    }
-                });
-            } catch (Throwable t) {
-                if (logger.isWarnEnabled()) {
-                    logger.warn("Failed to submit an exceptionCaught() event.", t);
-                    logger.warn("The exceptionCaught() event that was failed to submit was:", cause);
-                }
-            }
-        }
-
-        return this;
-    }
-
-    private void invokeExceptionCaught(final Throwable cause) {
-        try {
-            handler.exceptionCaught(this, cause);
-        } catch (Throwable t) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(
-                        "An exception was thrown by a user handler's " +
-                        "exceptionCaught() method while handling the following exception:", cause);
-            }
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext fireUserEventTriggered(final Object event) {
-        if (event == null) {
-            throw new NullPointerException("event");
-        }
-
-        final DefaultChannelHandlerContext next = findContextInbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeUserEventTriggered(event);
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeUserEventTriggered(event);
-                }
-            });
-        }
-        return this;
-    }
-
-    private void invokeUserEventTriggered(Object event) {
-        try {
-            ((ChannelInboundHandler) handler).userEventTriggered(this, event);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext fireChannelRead(final Object msg) {
-        if (msg == null) {
-            throw new NullPointerException("msg");
-        }
-
-        final DefaultChannelHandlerContext next = findContextInbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeChannelRead(msg);
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeChannelRead(msg);
-                }
-            });
-        }
-        return this;
-    }
-
-    private void invokeChannelRead(Object msg) {
-        try {
-            ((ChannelInboundHandler) handler).channelRead(this, msg);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext fireChannelReadComplete() {
-        final DefaultChannelHandlerContext next = findContextInbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeChannelReadComplete();
-        } else {
-            Runnable task = next.invokeChannelReadCompleteTask;
-            if (task == null) {
-                next.invokeChannelReadCompleteTask = task = new Runnable() {
-                    @Override
-                    public void run() {
-                        next.invokeChannelReadComplete();
-                    }
-                };
-            }
-            executor.execute(task);
-        }
-        return this;
-    }
-
-    private void invokeChannelReadComplete() {
-        try {
-            ((ChannelInboundHandler) handler).channelReadComplete(this);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext fireChannelWritabilityChanged() {
-        final DefaultChannelHandlerContext next = findContextInbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeChannelWritabilityChanged();
-        } else {
-            Runnable task = next.invokeChannelWritableStateChangedTask;
-            if (task == null) {
-                next.invokeChannelWritableStateChangedTask = task = new Runnable() {
-                    @Override
-                    public void run() {
-                        next.invokeChannelWritabilityChanged();
-                    }
-                };
-            }
-            executor.execute(task);
-        }
-        return this;
-    }
-
-    private void invokeChannelWritabilityChanged() {
-        try {
-            ((ChannelInboundHandler) handler).channelWritabilityChanged(this);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelFuture bind(SocketAddress localAddress) {
-        return bind(localAddress, newPromise());
-    }
-
-    @Override
-    public ChannelFuture connect(SocketAddress remoteAddress) {
-        return connect(remoteAddress, newPromise());
-    }
-
-    @Override
-    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {
-        return connect(remoteAddress, localAddress, newPromise());
-    }
-
-    @Override
-    public ChannelFuture disconnect() {
-        return disconnect(newPromise());
-    }
-
-    @Override
-    public ChannelFuture close() {
-        return close(newPromise());
-    }
-
-    @Override
-    public ChannelFuture deregister() {
-        return deregister(newPromise());
-    }
-
-    @Override
-    public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) {
-        if (localAddress == null) {
-            throw new NullPointerException("localAddress");
-        }
-        validatePromise(promise, false);
-
-        final DefaultChannelHandlerContext next = findContextOutbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeBind(localAddress, promise);
-        } else {
-            safeExecute(executor, new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeBind(localAddress, promise);
-                }
-            }, promise, null);
-        }
-
-        return promise;
-    }
-
-    private void invokeBind(SocketAddress localAddress, ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) handler).bind(this, localAddress, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    @Override
-    public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
-        return connect(remoteAddress, null, promise);
-    }
-
-    @Override
-    public ChannelFuture connect(
-            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
-
-        if (remoteAddress == null) {
-            throw new NullPointerException("remoteAddress");
-        }
-        validatePromise(promise, false);
-
-        final DefaultChannelHandlerContext next = findContextOutbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeConnect(remoteAddress, localAddress, promise);
-        } else {
-            safeExecute(executor, new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeConnect(remoteAddress, localAddress, promise);
-                }
-            }, promise, null);
-        }
-
-        return promise;
-    }
-
-    private void invokeConnect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) handler).connect(this, remoteAddress, localAddress, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    @Override
-    public ChannelFuture disconnect(final ChannelPromise promise) {
-        validatePromise(promise, false);
-
-        final DefaultChannelHandlerContext next = findContextOutbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            // Translate disconnect to close if the channel has no notion of disconnect-reconnect.
-            // So far, UDP/IP is the only transport that has such behavior.
-            if (!channel().metadata().hasDisconnect()) {
-                next.invokeClose(promise);
-            } else {
-                next.invokeDisconnect(promise);
-            }
-        } else {
-            safeExecute(executor, new Runnable() {
-                @Override
-                public void run() {
-                    if (!channel().metadata().hasDisconnect()) {
-                        next.invokeClose(promise);
-                    } else {
-                        next.invokeDisconnect(promise);
-                    }
-                }
-            }, promise, null);
-        }
-
-        return promise;
-    }
-
-    private void invokeDisconnect(ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) handler).disconnect(this, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    @Override
-    public ChannelFuture close(final ChannelPromise promise) {
-        validatePromise(promise, false);
-
-        final DefaultChannelHandlerContext next = findContextOutbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeClose(promise);
-        } else {
-            safeExecute(executor, new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeClose(promise);
-                }
-            }, promise, null);
-        }
-
-        return promise;
-    }
-
-    private void invokeClose(ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) handler).close(this, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    @Override
-    public ChannelFuture deregister(final ChannelPromise promise) {
-        validatePromise(promise, false);
-
-        final DefaultChannelHandlerContext next = findContextOutbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeDeregister(promise);
-        } else {
-            safeExecute(executor, new Runnable() {
-                @Override
-                public void run() {
-                    next.invokeDeregister(promise);
-                }
-            }, promise, null);
-        }
-
-        return promise;
-    }
-
-    private void invokeDeregister(ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) handler).deregister(this, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext read() {
-        final DefaultChannelHandlerContext next = findContextOutbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeRead();
-        } else {
-            Runnable task = next.invokeReadTask;
-            if (task == null) {
-                next.invokeReadTask = task = new Runnable() {
-                    @Override
-                    public void run() {
-                        next.invokeRead();
-                    }
-                };
-            }
-            executor.execute(task);
-        }
-
-        return this;
+    private static boolean isInbound(ChannelHandler handler) {
+        return handler instanceof ChannelInboundHandler;
     }
 
-    private void invokeRead() {
-        try {
-            ((ChannelOutboundHandler) handler).read(this);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelFuture write(Object msg) {
-        return write(msg, newPromise());
-    }
-
-    @Override
-    public ChannelFuture write(final Object msg, final ChannelPromise promise) {
-        if (msg == null) {
-            throw new NullPointerException("msg");
-        }
-
-        validatePromise(promise, true);
-
-        write(msg, false, promise);
-
-        return promise;
-    }
-
-    private void invokeWrite(Object msg, ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) handler).write(this, msg, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    @Override
-    public ChannelHandlerContext flush() {
-        final DefaultChannelHandlerContext next = findContextOutbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeFlush();
-        } else {
-            Runnable task = next.invokeFlushTask;
-            if (task == null) {
-                next.invokeFlushTask = task = new Runnable() {
-                    @Override
-                    public void run() {
-                        next.invokeFlush();
-                    }
-                };
-            }
-            safeExecute(executor, task, channel.voidPromise(), null);
-        }
-
-        return this;
-    }
-
-    private void invokeFlush() {
-        try {
-            ((ChannelOutboundHandler) handler).flush(this);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        }
-    }
-
-    @Override
-    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
-        if (msg == null) {
-            throw new NullPointerException("msg");
-        }
-
-        validatePromise(promise, true);
-
-        write(msg, true, promise);
-
-        return promise;
-    }
-
-    private void write(Object msg, boolean flush, ChannelPromise promise) {
-
-        DefaultChannelHandlerContext next = findContextOutbound();
-        EventExecutor executor = next.executor();
-        if (executor.inEventLoop()) {
-            next.invokeWrite(msg, promise);
-            if (flush) {
-                next.invokeFlush();
-            }
-        } else {
-            int size = channel.estimatorHandle().size(msg);
-            if (size > 0) {
-                ChannelOutboundBuffer buffer = channel.unsafe().outboundBuffer();
-                // Check for null as it may be set to null if the channel is closed already
-                if (buffer != null) {
-                    buffer.incrementPendingOutboundBytes(size);
-                }
-            }
-            Runnable task;
-            if (flush) {
-                task = WriteAndFlushTask.newInstance(next, msg, size, promise);
-            }  else {
-                task = WriteTask.newInstance(next, msg, size, promise);
-            }
-            safeExecute(executor, task, promise, msg);
-        }
-    }
-
-    @Override
-    public ChannelFuture writeAndFlush(Object msg) {
-        return writeAndFlush(msg, newPromise());
-    }
-
-    private static void notifyOutboundHandlerException(Throwable cause, ChannelPromise promise) {
-        // only try to fail the promise if its not a VoidChannelPromise, as
-        // the VoidChannelPromise would also fire the cause through the pipeline
-        if (promise instanceof VoidChannelPromise) {
-            return;
-        }
-
-        if (!promise.tryFailure(cause)) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("Failed to fail the promise because it's done already: {}", promise, cause);
-            }
-        }
-    }
-
-    private void notifyHandlerException(Throwable cause) {
-        if (inExceptionCaught(cause)) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(
-                        "An exception was thrown by a user handler " +
-                                "while handling an exceptionCaught event", cause);
-            }
-            return;
-        }
-
-        invokeExceptionCaught(cause);
-    }
-
-    private static boolean inExceptionCaught(Throwable cause) {
-        do {
-            StackTraceElement[] trace = cause.getStackTrace();
-            if (trace != null) {
-                for (StackTraceElement t : trace) {
-                    if (t == null) {
-                        break;
-                    }
-                    if ("exceptionCaught".equals(t.getMethodName())) {
-                        return true;
-                    }
-                }
-            }
-
-            cause = cause.getCause();
-        } while (cause != null);
-
-        return false;
-    }
-
-    @Override
-    public ChannelPromise newPromise() {
-        return new DefaultChannelPromise(channel(), executor());
-    }
-
-    @Override
-    public ChannelProgressivePromise newProgressivePromise() {
-        return new DefaultChannelProgressivePromise(channel(), executor());
-    }
-
-    @Override
-    public ChannelFuture newSucceededFuture() {
-        ChannelFuture succeededFuture = this.succeededFuture;
-        if (succeededFuture == null) {
-            this.succeededFuture = succeededFuture = new SucceededChannelFuture(channel(), executor());
-        }
-        return succeededFuture;
-    }
-
-    @Override
-    public ChannelFuture newFailedFuture(Throwable cause) {
-        return new FailedChannelFuture(channel(), executor(), cause);
-    }
-
-    private void validatePromise(ChannelPromise promise, boolean allowVoidPromise) {
-        if (promise == null) {
-            throw new NullPointerException("promise");
-        }
-
-        if (promise.isDone()) {
-            throw new IllegalArgumentException("promise already done: " + promise);
-        }
-
-        if (promise.channel() != channel()) {
-            throw new IllegalArgumentException(String.format(
-                    "promise.channel does not match: %s (expected: %s)", promise.channel(), channel()));
-        }
-
-        if (promise.getClass() == DefaultChannelPromise.class) {
-            return;
-        }
-
-        if (!allowVoidPromise && promise instanceof VoidChannelPromise) {
-            throw new IllegalArgumentException(
-                    StringUtil.simpleClassName(VoidChannelPromise.class) + " not allowed for this operation");
-        }
-
-        if (promise instanceof AbstractChannel.CloseFuture) {
-            throw new IllegalArgumentException(
-                    StringUtil.simpleClassName(AbstractChannel.CloseFuture.class) + " not allowed in a pipeline");
-        }
-    }
-
-    private DefaultChannelHandlerContext findContextInbound() {
-        DefaultChannelHandlerContext ctx = this;
-        do {
-            ctx = ctx.next;
-        } while (!ctx.inbound);
-        return ctx;
-    }
-
-    private DefaultChannelHandlerContext findContextOutbound() {
-        DefaultChannelHandlerContext ctx = this;
-        do {
-            ctx = ctx.prev;
-        } while (!ctx.outbound);
-        return ctx;
-    }
-
-    @Override
-    public ChannelPromise voidPromise() {
-        return channel.voidPromise();
-    }
-
-    void setRemoved() {
-        removed = true;
-    }
-
-    @Override
-    public boolean isRemoved() {
-        return removed;
-    }
-
-    private static void safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg) {
-        try {
-            executor.execute(runnable);
-        } catch (Throwable cause) {
-            try {
-                promise.setFailure(cause);
-            } finally {
-                if (msg != null) {
-                    ReferenceCountUtil.release(msg);
-                }
-            }
-        }
-    }
-
-    abstract static class AbstractWriteTask implements Runnable {
-        private final Recycler.Handle handle;
-
-        private DefaultChannelHandlerContext ctx;
-        private Object msg;
-        private ChannelPromise promise;
-        private int size;
-
-        private AbstractWriteTask(Recycler.Handle handle) {
-            this.handle = handle;
-        }
-
-        protected static void init(AbstractWriteTask task, DefaultChannelHandlerContext ctx,
-                                   Object msg, int size, ChannelPromise promise) {
-            task.ctx = ctx;
-            task.msg = msg;
-            task.promise = promise;
-            task.size = size;
-        }
-
-        @Override
-        public final void run() {
-            try {
-                if (size > 0) {
-                    ChannelOutboundBuffer buffer = ctx.channel.unsafe().outboundBuffer();
-                    // Check for null as it may be set to null if the channel is closed already
-                    if (buffer != null) {
-                        buffer.decrementPendingOutboundBytes(size);
-                    }
-                }
-                write(ctx, msg, promise);
-            } finally {
-                // Set to null so the GC can collect them directly
-                ctx = null;
-                msg = null;
-                promise = null;
-                recycle(handle);
-            }
-        }
-
-        protected void write(DefaultChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
-            ctx.invokeWrite(msg, promise);
-        }
-
-        protected abstract void recycle(Recycler.Handle handle);
-    }
-
-    static final class WriteTask extends AbstractWriteTask implements SingleThreadEventLoop.NonWakeupRunnable {
-
-        private static final Recycler<WriteTask> RECYCLER = new Recycler<WriteTask>() {
-            @Override
-            protected WriteTask newObject(Handle handle) {
-                return new WriteTask(handle);
-            }
-        };
-
-        private static WriteTask newInstance(
-                DefaultChannelHandlerContext ctx, Object msg, int size, ChannelPromise promise) {
-            WriteTask task = RECYCLER.get();
-            init(task, ctx, msg, size, promise);
-            return task;
-        }
-
-        private WriteTask(Recycler.Handle handle) {
-            super(handle);
-        }
-
-        @Override
-        protected void recycle(Recycler.Handle handle) {
-            RECYCLER.recycle(this, handle);
-        }
-    }
-
-    static final class WriteAndFlushTask extends AbstractWriteTask {
-
-        private static final Recycler<WriteAndFlushTask> RECYCLER = new Recycler<WriteAndFlushTask>() {
-            @Override
-            protected WriteAndFlushTask newObject(Handle handle) {
-                return new WriteAndFlushTask(handle);
-            }
-        };
-
-        private static WriteAndFlushTask newInstance(
-                DefaultChannelHandlerContext ctx, Object msg, int size, ChannelPromise promise) {
-            WriteAndFlushTask task = RECYCLER.get();
-            init(task, ctx, msg, size, promise);
-            return task;
-        }
-
-        private WriteAndFlushTask(Recycler.Handle handle) {
-            super(handle);
-        }
-
-        @Override
-        public void write(DefaultChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
-            super.write(ctx, msg, promise);
-            ctx.invokeFlush();
-        }
-
-        @Override
-        protected void recycle(Recycler.Handle handle) {
-            RECYCLER.recycle(this, handle);
-        }
+    private static boolean isOutbound(ChannelHandler handler) {
+        return handler instanceof ChannelOutboundHandler;
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java
new file mode 100644
index 000000000000..7f45f0bdbde9
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java
@@ -0,0 +1,454 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.util.Recycler;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.internal.OneTimeTask;
+import io.netty.util.internal.RecyclableMpscLinkedQueueNode;
+
+import java.net.SocketAddress;
+
+import static io.netty.channel.ChannelHandlerInvokerUtil.*;
+import static io.netty.channel.DefaultChannelPipeline.*;
+
+public class DefaultChannelHandlerInvoker implements ChannelHandlerInvoker {
+
+    private final EventExecutor executor;
+
+    public DefaultChannelHandlerInvoker(EventExecutor executor) {
+        if (executor == null) {
+            throw new NullPointerException("executor");
+        }
+
+        this.executor = executor;
+    }
+
+    @Override
+    public EventExecutor executor() {
+        return executor;
+    }
+
+    @Override
+    public void invokeChannelRegistered(final ChannelHandlerContext ctx) {
+        if (executor.inEventLoop()) {
+            invokeChannelRegisteredNow(ctx);
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeChannelRegisteredNow(ctx);
+                }
+            });
+        }
+    }
+
+    @Override
+    public void invokeChannelUnregistered(final ChannelHandlerContext ctx) {
+        if (executor.inEventLoop()) {
+            invokeChannelUnregisteredNow(ctx);
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeChannelUnregisteredNow(ctx);
+                }
+            });
+        }
+    }
+
+    @Override
+    public void invokeChannelActive(final ChannelHandlerContext ctx) {
+        if (executor.inEventLoop()) {
+            invokeChannelActiveNow(ctx);
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeChannelActiveNow(ctx);
+                }
+            });
+        }
+    }
+
+    @Override
+    public void invokeChannelInactive(final ChannelHandlerContext ctx) {
+        if (executor.inEventLoop()) {
+            invokeChannelInactiveNow(ctx);
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeChannelInactiveNow(ctx);
+                }
+            });
+        }
+    }
+
+    @Override
+    public void invokeExceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {
+        if (cause == null) {
+            throw new NullPointerException("cause");
+        }
+
+        if (executor.inEventLoop()) {
+            invokeExceptionCaughtNow(ctx, cause);
+        } else {
+            try {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        invokeExceptionCaughtNow(ctx, cause);
+                    }
+                });
+            } catch (Throwable t) {
+                if (logger.isWarnEnabled()) {
+                    logger.warn("Failed to submit an exceptionCaught() event.", t);
+                    logger.warn("The exceptionCaught() event that was failed to submit was:", cause);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void invokeUserEventTriggered(final ChannelHandlerContext ctx, final Object event) {
+        if (event == null) {
+            throw new NullPointerException("event");
+        }
+
+        if (executor.inEventLoop()) {
+            invokeUserEventTriggeredNow(ctx, event);
+        } else {
+            safeExecuteInbound(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeUserEventTriggeredNow(ctx, event);
+                }
+            }, event);
+        }
+    }
+
+    @Override
+    public void invokeChannelRead(final ChannelHandlerContext ctx, final Object msg) {
+        if (msg == null) {
+            throw new NullPointerException("msg");
+        }
+
+        if (executor.inEventLoop()) {
+            invokeChannelReadNow(ctx, msg);
+        } else {
+            safeExecuteInbound(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeChannelReadNow(ctx, msg);
+                }
+            }, msg);
+        }
+    }
+
+    @Override
+    public void invokeChannelReadComplete(final ChannelHandlerContext ctx) {
+        if (executor.inEventLoop()) {
+            invokeChannelReadCompleteNow(ctx);
+        } else {
+            AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
+            Runnable task = dctx.invokeChannelReadCompleteTask;
+            if (task == null) {
+                dctx.invokeChannelReadCompleteTask = task = new Runnable() {
+                    @Override
+                    public void run() {
+                        invokeChannelReadCompleteNow(ctx);
+                    }
+                };
+            }
+            executor.execute(task);
+        }
+    }
+
+    @Override
+    public void invokeChannelWritabilityChanged(final ChannelHandlerContext ctx) {
+        if (executor.inEventLoop()) {
+            invokeChannelWritabilityChangedNow(ctx);
+        } else {
+            AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
+            Runnable task = dctx.invokeChannelWritableStateChangedTask;
+            if (task == null) {
+                dctx.invokeChannelWritableStateChangedTask = task = new Runnable() {
+                    @Override
+                    public void run() {
+                        invokeChannelWritabilityChangedNow(ctx);
+                    }
+                };
+            }
+            executor.execute(task);
+        }
+    }
+
+    @Override
+    public void invokeBind(
+            final ChannelHandlerContext ctx, final SocketAddress localAddress, final ChannelPromise promise) {
+        if (localAddress == null) {
+            throw new NullPointerException("localAddress");
+        }
+        if (!validatePromise(ctx, promise, false)) {
+            // promise cancelled
+            return;
+        }
+
+        if (executor.inEventLoop()) {
+            invokeBindNow(ctx, localAddress, promise);
+        } else {
+            safeExecuteOutbound(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeBindNow(ctx, localAddress, promise);
+                }
+            }, promise);
+        }
+    }
+
+    @Override
+    public void invokeConnect(
+            final ChannelHandlerContext ctx,
+            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
+        if (remoteAddress == null) {
+            throw new NullPointerException("remoteAddress");
+        }
+        if (!validatePromise(ctx, promise, false)) {
+            // promise cancelled
+            return;
+        }
+
+        if (executor.inEventLoop()) {
+            invokeConnectNow(ctx, remoteAddress, localAddress, promise);
+        } else {
+            safeExecuteOutbound(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeConnectNow(ctx, remoteAddress, localAddress, promise);
+                }
+            }, promise);
+        }
+    }
+
+    @Override
+    public void invokeDisconnect(final ChannelHandlerContext ctx, final ChannelPromise promise) {
+        if (!validatePromise(ctx, promise, false)) {
+            // promise cancelled
+            return;
+        }
+
+        if (executor.inEventLoop()) {
+            invokeDisconnectNow(ctx, promise);
+        } else {
+            safeExecuteOutbound(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeDisconnectNow(ctx, promise);
+                }
+            }, promise);
+        }
+    }
+
+    @Override
+    public void invokeClose(final ChannelHandlerContext ctx, final ChannelPromise promise) {
+        if (!validatePromise(ctx, promise, false)) {
+            // promise cancelled
+            return;
+        }
+
+        if (executor.inEventLoop()) {
+            invokeCloseNow(ctx, promise);
+        } else {
+            safeExecuteOutbound(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeCloseNow(ctx, promise);
+                }
+            }, promise);
+        }
+    }
+
+    @Override
+    public void invokeDeregister(final ChannelHandlerContext ctx, final ChannelPromise promise) {
+        if (!validatePromise(ctx, promise, false)) {
+            // promise cancelled
+            return;
+        }
+
+        if (executor.inEventLoop()) {
+            invokeDeregisterNow(ctx, promise);
+        } else {
+            safeExecuteOutbound(new OneTimeTask() {
+                @Override
+                public void run() {
+                    invokeDeregisterNow(ctx, promise);
+                }
+            }, promise);
+        }
+    }
+
+    @Override
+    public void invokeRead(final ChannelHandlerContext ctx) {
+        if (executor.inEventLoop()) {
+            invokeReadNow(ctx);
+        } else {
+            AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
+            Runnable task = dctx.invokeReadTask;
+            if (task == null) {
+                dctx.invokeReadTask = task = new Runnable() {
+                    @Override
+                    public void run() {
+                        invokeReadNow(ctx);
+                    }
+                };
+            }
+            executor.execute(task);
+        }
+    }
+
+    @Override
+    public void invokeWrite(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+        if (msg == null) {
+            throw new NullPointerException("msg");
+        }
+        if (!validatePromise(ctx, promise, true)) {
+            // promise cancelled
+            ReferenceCountUtil.release(msg);
+            return;
+        }
+
+        if (executor.inEventLoop()) {
+            invokeWriteNow(ctx, msg, promise);
+        } else {
+            AbstractChannel channel = (AbstractChannel) ctx.channel();
+            int size = channel.estimatorHandle().size(msg);
+            if (size > 0) {
+                ChannelOutboundBuffer buffer = channel.unsafe().outboundBuffer();
+                // Check for null as it may be set to null if the channel is closed already
+                if (buffer != null) {
+                    buffer.incrementPendingOutboundBytes(size);
+                }
+            }
+            safeExecuteOutbound(WriteTask.newInstance(ctx, msg, size, promise), promise, msg);
+        }
+    }
+
+    @Override
+    public void invokeFlush(final ChannelHandlerContext ctx) {
+        if (executor.inEventLoop()) {
+            invokeFlushNow(ctx);
+        } else {
+            AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
+            Runnable task = dctx.invokeFlushTask;
+            if (task == null) {
+                dctx.invokeFlushTask = task = new Runnable() {
+                    @Override
+                    public void run() {
+                        invokeFlushNow(ctx);
+                    }
+                };
+            }
+            executor.execute(task);
+        }
+    }
+
+    private void safeExecuteInbound(Runnable task, Object msg) {
+        boolean success = false;
+        try {
+            executor.execute(task);
+            success = true;
+        } finally {
+            if (!success) {
+                ReferenceCountUtil.release(msg);
+            }
+        }
+    }
+
+    private void safeExecuteOutbound(Runnable task, ChannelPromise promise) {
+        try {
+            executor.execute(task);
+        } catch (Throwable cause) {
+            promise.setFailure(cause);
+        }
+    }
+    private void safeExecuteOutbound(Runnable task, ChannelPromise promise, Object msg) {
+        try {
+            executor.execute(task);
+        } catch (Throwable cause) {
+            try {
+                promise.setFailure(cause);
+            } finally {
+                ReferenceCountUtil.release(msg);
+            }
+        }
+    }
+
+    static final class WriteTask extends RecyclableMpscLinkedQueueNode<SingleThreadEventLoop.NonWakeupRunnable>
+            implements SingleThreadEventLoop.NonWakeupRunnable {
+        private ChannelHandlerContext ctx;
+        private Object msg;
+        private ChannelPromise promise;
+        private int size;
+
+        private static final Recycler<WriteTask> RECYCLER = new Recycler<WriteTask>() {
+            @Override
+            protected WriteTask newObject(Handle<WriteTask> handle) {
+                return new WriteTask(handle);
+            }
+        };
+
+        private static WriteTask newInstance(
+                ChannelHandlerContext ctx, Object msg, int size, ChannelPromise promise) {
+            WriteTask task = RECYCLER.get();
+            task.ctx = ctx;
+            task.msg = msg;
+            task.promise = promise;
+            task.size = size;
+            return task;
+        }
+
+        private WriteTask(Recycler.Handle<WriteTask> handle) {
+            super(handle);
+        }
+
+        @Override
+        public void run() {
+            try {
+                if (size > 0) {
+                    ChannelOutboundBuffer buffer = ctx.channel().unsafe().outboundBuffer();
+                    // Check for null as it may be set to null if the channel is closed already
+                    if (buffer != null) {
+                        buffer.decrementPendingOutboundBytes(size);
+                    }
+                }
+                invokeWriteNow(ctx, msg, promise);
+            } finally {
+                // Set to null so the GC can collect them directly
+                ctx = null;
+                msg = null;
+                promise = null;
+            }
+        }
+
+        @Override
+        public SingleThreadEventLoop.NonWakeupRunnable value() {
+            return this;
+        }
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelId.java b/transport/src/main/java/io/netty/channel/DefaultChannelId.java
new file mode 100644
index 000000000000..fb0e67b0425b
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java
@@ -0,0 +1,472 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.buffer.ByteBufUtil;
+import io.netty.util.internal.EmptyArrays;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.ThreadLocalRandom;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.lang.reflect.Method;
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.regex.Pattern;
+
+/**
+ * The default {@link ChannelId} implementation.
+ */
+final class DefaultChannelId implements ChannelId {
+
+    private static final long serialVersionUID = 3884076183504074063L;
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultChannelId.class);
+
+    private static final Pattern MACHINE_ID_PATTERN = Pattern.compile("^(?:[0-9a-fA-F][:-]?){6,8}$");
+    private static final int MACHINE_ID_LEN = 8;
+    private static final byte[] MACHINE_ID;
+    private static final int PROCESS_ID_LEN = 2;
+    private static final int MAX_PROCESS_ID = 65535;
+    private static final int PROCESS_ID;
+    private static final int SEQUENCE_LEN = 4;
+    private static final int TIMESTAMP_LEN = 8;
+    private static final int RANDOM_LEN = 4;
+
+    private static final AtomicInteger nextSequence = new AtomicInteger();
+
+    static ChannelId newInstance() {
+        DefaultChannelId id = new DefaultChannelId();
+        id.init();
+        return id;
+    }
+
+    static {
+        int processId = -1;
+        String customProcessId = SystemPropertyUtil.get("io.netty.processId");
+        if (customProcessId != null) {
+            try {
+                processId = Integer.parseInt(customProcessId);
+            } catch (NumberFormatException e) {
+                // Malformed input.
+            }
+
+            if (processId < 0 || processId > MAX_PROCESS_ID) {
+                processId = -1;
+                logger.warn("-Dio.netty.processId: {} (malformed)", customProcessId);
+            } else if (logger.isDebugEnabled()) {
+                logger.debug("-Dio.netty.processId: {} (user-set)", processId);
+            }
+        }
+
+        if (processId < 0) {
+            processId = defaultProcessId();
+            if (logger.isDebugEnabled()) {
+                logger.debug("-Dio.netty.processId: {} (auto-detected)", processId);
+            }
+        }
+
+        PROCESS_ID = processId;
+
+        byte[] machineId = null;
+        String customMachineId = SystemPropertyUtil.get("io.netty.machineId");
+        if (customMachineId != null) {
+            if (MACHINE_ID_PATTERN.matcher(customMachineId).matches()) {
+                machineId = parseMachineId(customMachineId);
+                logger.debug("-Dio.netty.machineId: {} (user-set)", customMachineId);
+            } else {
+                logger.warn("-Dio.netty.machineId: {} (malformed)", customMachineId);
+            }
+        }
+
+        if (machineId == null) {
+            machineId = defaultMachineId();
+            if (logger.isDebugEnabled()) {
+                logger.debug("-Dio.netty.machineId: {} (auto-detected)", formatAddress(machineId));
+            }
+        }
+
+        MACHINE_ID = machineId;
+    }
+
+    @SuppressWarnings("DynamicRegexReplaceableByCompiledPattern")
+    private static byte[] parseMachineId(String value) {
+        // Strip separators.
+        value = value.replaceAll("[:-]", "");
+
+        byte[] machineId = new byte[MACHINE_ID_LEN];
+        for (int i = 0; i < value.length(); i += 2) {
+            machineId[i] = (byte) Integer.parseInt(value.substring(i, i + 2), 16);
+        }
+
+        return machineId;
+    }
+
+    private static byte[] defaultMachineId() {
+        // Find the best MAC address available.
+        final byte[] NOT_FOUND = { -1 };
+        byte[] bestMacAddr = NOT_FOUND;
+        InetAddress bestInetAddr = null;
+        try {
+            bestInetAddr = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 });
+        } catch (UnknownHostException e) {
+            // Never happens.
+            PlatformDependent.throwException(e);
+        }
+
+        // Retrieve the list of available network interfaces.
+        Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<NetworkInterface, InetAddress>();
+        try {
+            for (Enumeration<NetworkInterface> i = NetworkInterface.getNetworkInterfaces(); i.hasMoreElements();) {
+                NetworkInterface iface = i.nextElement();
+                // Use the interface with proper INET addresses only.
+                Enumeration<InetAddress> addrs = iface.getInetAddresses();
+                if (addrs.hasMoreElements()) {
+                    InetAddress a = addrs.nextElement();
+                    if (!a.isLoopbackAddress()) {
+                        ifaces.put(iface, a);
+                    }
+                }
+            }
+        } catch (SocketException e) {
+            logger.warn("Failed to retrieve the list of available network interfaces", e);
+        }
+
+        for (Entry<NetworkInterface, InetAddress> entry: ifaces.entrySet()) {
+            NetworkInterface iface = entry.getKey();
+            InetAddress inetAddr = entry.getValue();
+            if (iface.isVirtual()) {
+                continue;
+            }
+
+            byte[] macAddr;
+            try {
+                macAddr = iface.getHardwareAddress();
+            } catch (SocketException e) {
+                logger.debug("Failed to get the hardware address of a network interface: {}", iface, e);
+                continue;
+            }
+
+            boolean replace = false;
+            int res = compareAddresses(bestMacAddr, macAddr);
+            if (res < 0) {
+                // Found a better MAC address.
+                replace = true;
+            } else if (res == 0) {
+                // Two MAC addresses are of pretty much same quality.
+                res = compareAddresses(bestInetAddr, inetAddr);
+                if (res < 0) {
+                    // Found a MAC address with better INET address.
+                    replace = true;
+                } else if (res == 0) {
+                    // Cannot tell the difference.  Choose the longer one.
+                    if (bestMacAddr.length < macAddr.length) {
+                        replace = true;
+                    }
+                }
+            }
+
+            if (replace) {
+                bestMacAddr = macAddr;
+                bestInetAddr = inetAddr;
+            }
+        }
+
+        if (bestMacAddr == NOT_FOUND) {
+            bestMacAddr = new byte[MACHINE_ID_LEN];
+            ThreadLocalRandom.current().nextBytes(bestMacAddr);
+            logger.warn(
+                    "Failed to find a usable hardware address from the network interfaces; using random bytes: {}",
+                    formatAddress(bestMacAddr));
+        }
+
+        switch (bestMacAddr.length) {
+            case 6: // EUI-48 - convert to EUI-64
+                byte[] newAddr = new byte[MACHINE_ID_LEN];
+                System.arraycopy(bestMacAddr, 0, newAddr, 0, 3);
+                newAddr[3] = (byte) 0xFF;
+                newAddr[4] = (byte) 0xFE;
+                System.arraycopy(bestMacAddr, 3, newAddr, 5, 3);
+                bestMacAddr = newAddr;
+                break;
+            default: // Unknown
+                bestMacAddr = Arrays.copyOf(bestMacAddr, MACHINE_ID_LEN);
+        }
+
+        return bestMacAddr;
+    }
+
+    /**
+     * @return positive - current is better, 0 - cannot tell from MAC addr, negative - candidate is better.
+     */
+    private static int compareAddresses(byte[] current, byte[] candidate) {
+        if (candidate == null) {
+            return 1;
+        }
+
+        // Must be EUI-48 or longer.
+        if (candidate.length < 6) {
+            return 1;
+        }
+
+        // Must not be filled with only 0 and 1.
+        boolean onlyZeroAndOne = true;
+        for (byte b: candidate) {
+            if (b != 0 && b != 1) {
+                onlyZeroAndOne = false;
+                break;
+            }
+        }
+
+        if (onlyZeroAndOne) {
+            return 1;
+        }
+
+        // Must not be a multicast address
+        if ((candidate[0] & 1) != 0) {
+            return 1;
+        }
+
+        // Prefer globally unique address.
+        if ((current[0] & 2) == 0) {
+            if ((candidate[0] & 2) == 0) {
+                // Both current and candidate are globally unique addresses.
+                return 0;
+            } else {
+                // Only current is globally unique.
+                return 1;
+            }
+        } else {
+            if ((candidate[0] & 2) == 0) {
+                // Only candidate is globally unique.
+                return -1;
+            } else {
+                // Both current and candidate are non-unique.
+                return 0;
+            }
+        }
+    }
+
+    /**
+     * @return positive - current is better, 0 - cannot tell, negative - candidate is better
+     */
+    private static int compareAddresses(InetAddress current, InetAddress candidate) {
+        return scoreAddress(current) - scoreAddress(candidate);
+    }
+
+    private static int scoreAddress(InetAddress addr) {
+        if (addr.isAnyLocalAddress()) {
+            return 0;
+        }
+        if (addr.isMulticastAddress()) {
+            return 1;
+        }
+        if (addr.isLinkLocalAddress()) {
+            return 2;
+        }
+        if (addr.isSiteLocalAddress()) {
+            return 3;
+        }
+
+        return 4;
+    }
+
+    private static String formatAddress(byte[] addr) {
+        StringBuilder buf = new StringBuilder(24);
+        for (byte b: addr) {
+            buf.append(String.format("%02x:", b & 0xff));
+        }
+        return buf.substring(0, buf.length() - 1);
+    }
+
+    private static int defaultProcessId() {
+        final ClassLoader loader = PlatformDependent.getSystemClassLoader();
+        String value;
+        try {
+            // Invoke java.lang.management.ManagementFactory.getRuntimeMXBean().getName()
+            Class<?> mgmtFactoryType = Class.forName("java.lang.management.ManagementFactory", true, loader);
+            Class<?> runtimeMxBeanType = Class.forName("java.lang.management.RuntimeMXBean", true, loader);
+
+            Method getRuntimeMXBean = mgmtFactoryType.getMethod("getRuntimeMXBean", EmptyArrays.EMPTY_CLASSES);
+            Object bean = getRuntimeMXBean.invoke(null, EmptyArrays.EMPTY_OBJECTS);
+            Method getName = runtimeMxBeanType.getDeclaredMethod("getName", EmptyArrays.EMPTY_CLASSES);
+            value = (String) getName.invoke(bean, EmptyArrays.EMPTY_OBJECTS);
+        } catch (Exception e) {
+            logger.debug("Could not invoke ManagementFactory.getRuntimeMXBean().getName(); Android?", e);
+            try {
+                // Invoke android.os.Process.myPid()
+                Class<?> processType = Class.forName("android.os.Process", true, loader);
+                Method myPid = processType.getMethod("myPid", EmptyArrays.EMPTY_CLASSES);
+                value = myPid.invoke(null, EmptyArrays.EMPTY_OBJECTS).toString();
+            } catch (Exception e2) {
+                logger.debug("Could not invoke Process.myPid(); not Android?", e2);
+                value = "";
+            }
+        }
+
+        int atIndex = value.indexOf('@');
+        if (atIndex >= 0) {
+            value = value.substring(0, atIndex);
+        }
+
+        int pid;
+        try {
+            pid = Integer.parseInt(value);
+        } catch (NumberFormatException e) {
+            // value did not contain an integer.
+            pid = -1;
+        }
+
+        if (pid < 0 || pid > MAX_PROCESS_ID) {
+            pid = ThreadLocalRandom.current().nextInt(MAX_PROCESS_ID + 1);
+            logger.warn("Failed to find the current process ID from '{}'; using a random value: {}",  value, pid);
+        }
+
+        return pid;
+    }
+
+    private final byte[] data = new byte[MACHINE_ID_LEN + PROCESS_ID_LEN + SEQUENCE_LEN + TIMESTAMP_LEN + RANDOM_LEN];
+    private int hashCode;
+
+    private transient String shortValue;
+    private transient String longValue;
+
+    private void init() {
+        int i = 0;
+
+        // machineId
+        System.arraycopy(MACHINE_ID, 0, data, i, MACHINE_ID_LEN);
+        i += MACHINE_ID_LEN;
+
+        // processId
+        i = writeShort(i, PROCESS_ID);
+
+        // sequence
+        i = writeInt(i, nextSequence.getAndIncrement());
+
+        // timestamp (kind of)
+        i = writeLong(i, Long.reverse(System.nanoTime()) ^ System.currentTimeMillis());
+
+        // random
+        int random = ThreadLocalRandom.current().nextInt();
+        hashCode = random;
+        i = writeInt(i, random);
+
+        assert i == data.length;
+    }
+
+    private int writeShort(int i, int value) {
+        data[i ++] = (byte) (value >>> 8);
+        data[i ++] = (byte) value;
+        return i;
+    }
+
+    private int writeInt(int i, int value) {
+        data[i ++] = (byte) (value >>> 24);
+        data[i ++] = (byte) (value >>> 16);
+        data[i ++] = (byte) (value >>> 8);
+        data[i ++] = (byte) value;
+        return i;
+    }
+
+    private int writeLong(int i, long value) {
+        data[i ++] = (byte) (value >>> 56);
+        data[i ++] = (byte) (value >>> 48);
+        data[i ++] = (byte) (value >>> 40);
+        data[i ++] = (byte) (value >>> 32);
+        data[i ++] = (byte) (value >>> 24);
+        data[i ++] = (byte) (value >>> 16);
+        data[i ++] = (byte) (value >>> 8);
+        data[i ++] = (byte) value;
+        return i;
+    }
+
+    @Override
+    public String asShortText() {
+        String shortValue = this.shortValue;
+        if (shortValue == null) {
+            this.shortValue = shortValue = ByteBufUtil.hexDump(
+                    data, MACHINE_ID_LEN + PROCESS_ID_LEN + SEQUENCE_LEN + TIMESTAMP_LEN, RANDOM_LEN);
+        }
+        return shortValue;
+    }
+
+    @Override
+    public String asLongText() {
+        String longValue = this.longValue;
+        if (longValue == null) {
+            this.longValue = longValue = newLongValue();
+        }
+        return longValue;
+    }
+
+    private String newLongValue() {
+        StringBuilder buf = new StringBuilder(2 * data.length + 5);
+        int i = 0;
+        i = appendHexDumpField(buf, i, MACHINE_ID_LEN);
+        i = appendHexDumpField(buf, i, PROCESS_ID_LEN);
+        i = appendHexDumpField(buf, i, SEQUENCE_LEN);
+        i = appendHexDumpField(buf, i, TIMESTAMP_LEN);
+        i = appendHexDumpField(buf, i, RANDOM_LEN);
+        assert i == data.length;
+        return buf.substring(0, buf.length() - 1);
+    }
+
+    private int appendHexDumpField(StringBuilder buf, int i, int length) {
+        buf.append(ByteBufUtil.hexDump(data, i, length));
+        buf.append('-');
+        i += length;
+        return i;
+    }
+
+    @Override
+    public int hashCode() {
+        return hashCode;
+    }
+
+    @Override
+    public int compareTo(ChannelId o) {
+        return 0;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+
+        if (!(obj instanceof DefaultChannelId)) {
+            return false;
+        }
+
+        return Arrays.equals(data, ((DefaultChannelId) obj).data);
+    }
+
+    @Override
+    public String toString() {
+        return asShortText();
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
index b8a968508215..5908e70075b3 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
@@ -57,26 +57,25 @@ final class DefaultChannelPipeline implements ChannelPipeline {
 
     final AbstractChannel channel;
 
-    final DefaultChannelHandlerContext head;
-    final DefaultChannelHandlerContext tail;
+    final AbstractChannelHandlerContext head;
+    final AbstractChannelHandlerContext tail;
 
-    private final Map<String, DefaultChannelHandlerContext> name2ctx =
-        new HashMap<String, DefaultChannelHandlerContext>(4);
+    private final Map<String, AbstractChannelHandlerContext> name2ctx =
+        new HashMap<String, AbstractChannelHandlerContext>(4);
 
-    final Map<EventExecutorGroup, EventExecutor> childExecutors =
-            new IdentityHashMap<EventExecutorGroup, EventExecutor>();
+    /**
+     * @see #findInvoker(EventExecutorGroup)
+     */
+    private Map<EventExecutorGroup, ChannelHandlerInvoker> childInvokers;
 
-    public DefaultChannelPipeline(AbstractChannel channel) {
+    DefaultChannelPipeline(AbstractChannel channel) {
         if (channel == null) {
             throw new NullPointerException("channel");
         }
         this.channel = channel;
 
-        TailHandler tailHandler = new TailHandler();
-        tail = new DefaultChannelHandlerContext(this, null, generateName(tailHandler), tailHandler);
-
-        HeadHandler headHandler = new HeadHandler(channel.unsafe());
-        head = new DefaultChannelHandlerContext(this, null, generateName(headHandler), headHandler);
+        tail = new TailContext(this);
+        head = new HeadContext(this);
 
         head.next = tail;
         tail.prev = head;
@@ -89,24 +88,31 @@ public Channel channel() {
 
     @Override
     public ChannelPipeline addFirst(String name, ChannelHandler handler) {
-        return addFirst(null, name, handler);
+        return addFirst((ChannelHandlerInvoker) null, name, handler);
     }
 
     @Override
-    public ChannelPipeline addFirst(EventExecutorGroup group, final String name, ChannelHandler handler) {
+    public ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler) {
         synchronized (this) {
             checkDuplicateName(name);
-            DefaultChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, group, name, handler);
-            addFirst0(name, newCtx);
+            addFirst0(name, new DefaultChannelHandlerContext(this, findInvoker(group), name, handler));
         }
+        return this;
+    }
 
+    @Override
+    public ChannelPipeline addFirst(ChannelHandlerInvoker invoker, final String name, ChannelHandler handler) {
+        synchronized (this) {
+            checkDuplicateName(name);
+            addFirst0(name, new DefaultChannelHandlerContext(this, invoker, name, handler));
+        }
         return this;
     }
 
-    private void addFirst0(String name, DefaultChannelHandlerContext newCtx) {
+    private void addFirst0(String name, AbstractChannelHandlerContext newCtx) {
         checkMultiplicity(newCtx);
 
-        DefaultChannelHandlerContext nextCtx = head.next;
+        AbstractChannelHandlerContext nextCtx = head.next;
         newCtx.prev = head;
         newCtx.next = nextCtx;
         head.next = newCtx;
@@ -119,25 +125,31 @@ private void addFirst0(String name, DefaultChannelHandlerContext newCtx) {
 
     @Override
     public ChannelPipeline addLast(String name, ChannelHandler handler) {
-        return addLast(null, name, handler);
+        return addLast((ChannelHandlerInvoker) null, name, handler);
     }
 
     @Override
-    public ChannelPipeline addLast(EventExecutorGroup group, final String name, ChannelHandler handler) {
+    public ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
         synchronized (this) {
             checkDuplicateName(name);
-
-            DefaultChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, group, name, handler);
-            addLast0(name, newCtx);
+            addLast0(name, new DefaultChannelHandlerContext(this, findInvoker(group), name, handler));
         }
+        return this;
+    }
 
+    @Override
+    public ChannelPipeline addLast(ChannelHandlerInvoker invoker, final String name, ChannelHandler handler) {
+        synchronized (this) {
+            checkDuplicateName(name);
+            addLast0(name, new DefaultChannelHandlerContext(this, invoker, name, handler));
+        }
         return this;
     }
 
-    private void addLast0(final String name, DefaultChannelHandlerContext newCtx) {
+    private void addLast0(final String name, AbstractChannelHandlerContext newCtx) {
         checkMultiplicity(newCtx);
 
-        DefaultChannelHandlerContext prev = tail.prev;
+        AbstractChannelHandlerContext prev = tail.prev;
         newCtx.prev = prev;
         newCtx.next = tail;
         prev.next = newCtx;
@@ -150,22 +162,32 @@ private void addLast0(final String name, DefaultChannelHandlerContext newCtx) {
 
     @Override
     public ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler) {
-        return addBefore(null, baseName, name, handler);
+        return addBefore((ChannelHandlerInvoker) null, baseName, name, handler);
+    }
+
+    @Override
+    public ChannelPipeline addBefore(EventExecutorGroup group, String baseName, String name, ChannelHandler handler) {
+        synchronized (this) {
+            AbstractChannelHandlerContext ctx = getContextOrDie(baseName);
+            checkDuplicateName(name);
+            addBefore0(name, ctx, new DefaultChannelHandlerContext(this, findInvoker(group), name, handler));
+        }
+        return this;
     }
 
     @Override
     public ChannelPipeline addBefore(
-            EventExecutorGroup group, String baseName, final String name, ChannelHandler handler) {
+            ChannelHandlerInvoker invoker, String baseName, final String name, ChannelHandler handler) {
         synchronized (this) {
-            DefaultChannelHandlerContext ctx = getContextOrDie(baseName);
+            AbstractChannelHandlerContext ctx = getContextOrDie(baseName);
             checkDuplicateName(name);
-            DefaultChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, group, name, handler);
-            addBefore0(name, ctx, newCtx);
+            addBefore0(name, ctx, new DefaultChannelHandlerContext(this, invoker, name, handler));
         }
         return this;
     }
 
-    private void addBefore0(final String name, DefaultChannelHandlerContext ctx, DefaultChannelHandlerContext newCtx) {
+    private void addBefore0(
+            final String name, AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx) {
         checkMultiplicity(newCtx);
 
         newCtx.prev = ctx.prev;
@@ -180,24 +202,31 @@ private void addBefore0(final String name, DefaultChannelHandlerContext ctx, Def
 
     @Override
     public ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler) {
-        return addAfter(null, baseName, name, handler);
+        return addAfter((ChannelHandlerInvoker) null, baseName, name, handler);
     }
 
     @Override
-    public ChannelPipeline addAfter(
-            EventExecutorGroup group, String baseName, final String name, ChannelHandler handler) {
+    public ChannelPipeline addAfter(EventExecutorGroup group, String baseName, String name, ChannelHandler handler) {
         synchronized (this) {
-            DefaultChannelHandlerContext ctx = getContextOrDie(baseName);
+            AbstractChannelHandlerContext ctx = getContextOrDie(baseName);
             checkDuplicateName(name);
-            DefaultChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, group, name, handler);
-
-            addAfter0(name, ctx, newCtx);
+            addAfter0(name, ctx, new DefaultChannelHandlerContext(this, findInvoker(group), name, handler));
         }
+        return this;
+    }
 
+    @Override
+    public ChannelPipeline addAfter(
+            ChannelHandlerInvoker invoker, String baseName, final String name, ChannelHandler handler) {
+        synchronized (this) {
+            AbstractChannelHandlerContext ctx = getContextOrDie(baseName);
+            checkDuplicateName(name);
+            addAfter0(name, ctx, new DefaultChannelHandlerContext(this, invoker, name, handler));
+        }
         return this;
     }
 
-    private void addAfter0(final String name, DefaultChannelHandlerContext ctx, DefaultChannelHandlerContext newCtx) {
+    private void addAfter0(final String name, AbstractChannelHandlerContext ctx, AbstractChannelHandlerContext newCtx) {
         checkDuplicateName(name);
         checkMultiplicity(newCtx);
 
@@ -213,11 +242,11 @@ private void addAfter0(final String name, DefaultChannelHandlerContext ctx, Defa
 
     @Override
     public ChannelPipeline addFirst(ChannelHandler... handlers) {
-        return addFirst(null, handlers);
+        return addFirst((ChannelHandlerInvoker) null, handlers);
     }
 
     @Override
-    public ChannelPipeline addFirst(EventExecutorGroup executor, ChannelHandler... handlers) {
+    public ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler... handlers) {
         if (handlers == null) {
             throw new NullPointerException("handlers");
         }
@@ -234,7 +263,31 @@ public ChannelPipeline addFirst(EventExecutorGroup executor, ChannelHandler... h
 
         for (int i = size - 1; i >= 0; i --) {
             ChannelHandler h = handlers[i];
-            addFirst(executor, generateName(h), h);
+            addFirst(group, generateName(h), h);
+        }
+
+        return this;
+    }
+
+    @Override
+    public ChannelPipeline addFirst(ChannelHandlerInvoker invoker, ChannelHandler... handlers) {
+        if (handlers == null) {
+            throw new NullPointerException("handlers");
+        }
+        if (handlers.length == 0 || handlers[0] == null) {
+            return this;
+        }
+
+        int size;
+        for (size = 1; size < handlers.length; size ++) {
+            if (handlers[size] == null) {
+                break;
+            }
+        }
+
+        for (int i = size - 1; i >= 0; i --) {
+            ChannelHandler h = handlers[i];
+            addFirst(invoker, generateName(h), h);
         }
 
         return this;
@@ -242,11 +295,27 @@ public ChannelPipeline addFirst(EventExecutorGroup executor, ChannelHandler... h
 
     @Override
     public ChannelPipeline addLast(ChannelHandler... handlers) {
-        return addLast(null, handlers);
+        return addLast((ChannelHandlerInvoker) null, handlers);
+    }
+
+    @Override
+    public ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers) {
+        if (handlers == null) {
+            throw new NullPointerException("handlers");
+        }
+
+        for (ChannelHandler h: handlers) {
+            if (h == null) {
+                break;
+            }
+            addLast(group, generateName(h), h);
+        }
+
+        return this;
     }
 
     @Override
-    public ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) {
+    public ChannelPipeline addLast(ChannelHandlerInvoker invoker, ChannelHandler... handlers) {
         if (handlers == null) {
             throw new NullPointerException("handlers");
         }
@@ -255,20 +324,48 @@ public ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... ha
             if (h == null) {
                 break;
             }
-            addLast(executor, generateName(h), h);
+            addLast(invoker, generateName(h), h);
         }
 
         return this;
     }
 
-    private String generateName(ChannelHandler handler) {
+    // No need for synchronization because it is always executed in a synchronized(this) block.
+    private ChannelHandlerInvoker findInvoker(EventExecutorGroup group) {
+        if (group == null) {
+            return null;
+        }
+
+        // Lazily initialize the data structure that maps an EventExecutorGroup to a ChannelHandlerInvoker.
+        Map<EventExecutorGroup, ChannelHandlerInvoker> childInvokers = this.childInvokers;
+        if (childInvokers == null) {
+            childInvokers = this.childInvokers = new IdentityHashMap<EventExecutorGroup, ChannelHandlerInvoker>(4);
+        }
+
+        // Pick one of the child executors and remember its invoker
+        // so that the same invoker is used to fire events for the same channel.
+        ChannelHandlerInvoker  invoker = childInvokers.get(group);
+        if (invoker == null) {
+            EventExecutor executor = group.next();
+            if (executor instanceof EventLoop) {
+                invoker = ((EventLoop) executor).asInvoker();
+            } else {
+                invoker = new DefaultChannelHandlerInvoker(executor);
+            }
+            childInvokers.put(group, invoker);
+        }
+
+        return invoker;
+    }
+
+    String generateName(ChannelHandler handler) {
         WeakHashMap<Class<?>, String> cache = nameCaches[(int) (Thread.currentThread().getId() % nameCaches.length)];
         Class<?> handlerType = handler.getClass();
         String name;
         synchronized (cache) {
             name = cache.get(handlerType);
             if (name == null) {
-                name = StringUtil.simpleClassName(handlerType) + "#0";
+                name = generateName0(handlerType);
                 cache.put(handlerType, name);
             }
         }
@@ -291,6 +388,10 @@ private String generateName(ChannelHandler handler) {
         return name;
     }
 
+    private static String generateName0(Class<?> handlerType) {
+        return StringUtil.simpleClassName(handlerType) + "#0";
+    }
+
     @Override
     public ChannelPipeline remove(ChannelHandler handler) {
         remove(getContextOrDie(handler));
@@ -308,10 +409,10 @@ public <T extends ChannelHandler> T remove(Class<T> handlerType) {
         return (T) remove(getContextOrDie(handlerType)).handler();
     }
 
-    private DefaultChannelHandlerContext remove(final DefaultChannelHandlerContext ctx) {
+    private AbstractChannelHandlerContext remove(final AbstractChannelHandlerContext ctx) {
         assert ctx != head && ctx != tail;
 
-        DefaultChannelHandlerContext context;
+        AbstractChannelHandlerContext context;
         Future<?> future;
 
         synchronized (this) {
@@ -339,9 +440,9 @@ public void run() {
         return context;
     }
 
-    void remove0(DefaultChannelHandlerContext ctx) {
-        DefaultChannelHandlerContext prev = ctx.prev;
-        DefaultChannelHandlerContext next = ctx.next;
+    void remove0(AbstractChannelHandlerContext ctx) {
+        AbstractChannelHandlerContext prev = ctx.prev;
+        AbstractChannelHandlerContext next = ctx.next;
         prev.next = next;
         next.prev = prev;
         name2ctx.remove(ctx.name());
@@ -383,7 +484,7 @@ public <T extends ChannelHandler> T replace(
     }
 
     private ChannelHandler replace(
-            final DefaultChannelHandlerContext ctx, final String newName,
+            final AbstractChannelHandlerContext ctx, final String newName,
             ChannelHandler newHandler) {
 
         assert ctx != head && ctx != tail;
@@ -395,8 +496,8 @@ private ChannelHandler replace(
                 checkDuplicateName(newName);
             }
 
-            final DefaultChannelHandlerContext newCtx =
-                    new DefaultChannelHandlerContext(this, ctx.executor, newName, newHandler);
+            final AbstractChannelHandlerContext newCtx =
+                    new DefaultChannelHandlerContext(this, ctx.invoker, newName, newHandler);
 
             if (!newCtx.channel().isRegistered() || newCtx.executor().inEventLoop()) {
                 replace0(ctx, newName, newCtx);
@@ -421,12 +522,12 @@ public void run() {
         return ctx.handler();
     }
 
-    private void replace0(DefaultChannelHandlerContext oldCtx, String newName,
-                          DefaultChannelHandlerContext newCtx) {
+    private void replace0(AbstractChannelHandlerContext oldCtx, String newName,
+                          AbstractChannelHandlerContext newCtx) {
         checkMultiplicity(newCtx);
 
-        DefaultChannelHandlerContext prev = oldCtx.prev;
-        DefaultChannelHandlerContext next = oldCtx.next;
+        AbstractChannelHandlerContext prev = oldCtx.prev;
+        AbstractChannelHandlerContext next = oldCtx.next;
         newCtx.prev = prev;
         newCtx.next = next;
 
@@ -466,7 +567,7 @@ private static void checkMultiplicity(ChannelHandlerContext ctx) {
         }
     }
 
-    private void callHandlerAdded(final ChannelHandlerContext ctx) {
+    private void callHandlerAdded(final AbstractChannelHandlerContext ctx) {
         if (ctx.channel().isRegistered() && !ctx.executor().inEventLoop()) {
             ctx.executor().execute(new Runnable() {
                 @Override
@@ -479,13 +580,13 @@ public void run() {
         callHandlerAdded0(ctx);
     }
 
-    private void callHandlerAdded0(final ChannelHandlerContext ctx) {
+    private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
         try {
             ctx.handler().handlerAdded(ctx);
         } catch (Throwable t) {
             boolean removed = false;
             try {
-                remove((DefaultChannelHandlerContext) ctx);
+                remove(ctx);
                 removed = true;
             } catch (Throwable t2) {
                 if (logger.isWarnEnabled()) {
@@ -505,7 +606,7 @@ private void callHandlerAdded0(final ChannelHandlerContext ctx) {
         }
     }
 
-    private void callHandlerRemoved(final DefaultChannelHandlerContext ctx) {
+    private void callHandlerRemoved(final AbstractChannelHandlerContext ctx) {
         if (ctx.channel().isRegistered() && !ctx.executor().inEventLoop()) {
             ctx.executor().execute(new Runnable() {
                 @Override
@@ -518,7 +619,7 @@ public void run() {
         callHandlerRemoved0(ctx);
     }
 
-    private void callHandlerRemoved0(final DefaultChannelHandlerContext ctx) {
+    private void callHandlerRemoved0(final AbstractChannelHandlerContext ctx) {
         // Notify the complete removal.
         try {
             ctx.handler().handlerRemoved(ctx);
@@ -567,8 +668,8 @@ public ChannelHandler first() {
 
     @Override
     public ChannelHandlerContext firstContext() {
-        DefaultChannelHandlerContext first = head.next;
-        if (first == head) {
+        AbstractChannelHandlerContext first = head.next;
+        if (first == tail) {
             return null;
         }
         return head.next;
@@ -576,7 +677,7 @@ public ChannelHandlerContext firstContext() {
 
     @Override
     public ChannelHandler last() {
-        DefaultChannelHandlerContext last = tail.prev;
+        AbstractChannelHandlerContext last = tail.prev;
         if (last == head) {
             return null;
         }
@@ -585,7 +686,7 @@ public ChannelHandler last() {
 
     @Override
     public ChannelHandlerContext lastContext() {
-        DefaultChannelHandlerContext last = tail.prev;
+        AbstractChannelHandlerContext last = tail.prev;
         if (last == head) {
             return null;
         }
@@ -630,7 +731,7 @@ public ChannelHandlerContext context(ChannelHandler handler) {
             throw new NullPointerException("handler");
         }
 
-        DefaultChannelHandlerContext ctx = head.next;
+        AbstractChannelHandlerContext ctx = head.next;
         for (;;) {
 
             if (ctx == null) {
@@ -651,7 +752,7 @@ public ChannelHandlerContext context(Class<? extends ChannelHandler> handlerType
             throw new NullPointerException("handlerType");
         }
 
-        DefaultChannelHandlerContext ctx = head.next;
+        AbstractChannelHandlerContext ctx = head.next;
         for (;;) {
             if (ctx == null) {
                 return null;
@@ -666,7 +767,7 @@ public ChannelHandlerContext context(Class<? extends ChannelHandler> handlerType
     @Override
     public List<String> names() {
         List<String> list = new ArrayList<String>();
-        DefaultChannelHandlerContext ctx = head.next;
+        AbstractChannelHandlerContext ctx = head.next;
         for (;;) {
             if (ctx == null) {
                 return list;
@@ -679,7 +780,7 @@ public List<String> names() {
     @Override
     public Map<String, ChannelHandler> toMap() {
         Map<String, ChannelHandler> map = new LinkedHashMap<String, ChannelHandler>();
-        DefaultChannelHandlerContext ctx = head.next;
+        AbstractChannelHandlerContext ctx = head.next;
         for (;;) {
             if (ctx == tail) {
                 return map;
@@ -702,7 +803,7 @@ public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(StringUtil.simpleClassName(this));
         buf.append('{');
-        DefaultChannelHandlerContext ctx = head.next;
+        AbstractChannelHandlerContext ctx = head.next;
         for (;;) {
             if (ctx == tail) {
                 break;
@@ -863,7 +964,7 @@ public ChannelFuture close(ChannelPromise promise) {
     }
 
     @Override
-    public ChannelFuture deregister(final ChannelPromise promise) {
+    public ChannelFuture deregister(ChannelPromise promise) {
         return tail.deregister(promise);
     }
 
@@ -899,8 +1000,8 @@ private void checkDuplicateName(String name) {
         }
     }
 
-    private DefaultChannelHandlerContext getContextOrDie(String name) {
-        DefaultChannelHandlerContext ctx = (DefaultChannelHandlerContext) context(name);
+    private AbstractChannelHandlerContext getContextOrDie(String name) {
+        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(name);
         if (ctx == null) {
             throw new NoSuchElementException(name);
         } else {
@@ -908,8 +1009,8 @@ private DefaultChannelHandlerContext getContextOrDie(String name) {
         }
     }
 
-    private DefaultChannelHandlerContext getContextOrDie(ChannelHandler handler) {
-        DefaultChannelHandlerContext ctx = (DefaultChannelHandlerContext) context(handler);
+    private AbstractChannelHandlerContext getContextOrDie(ChannelHandler handler) {
+        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handler);
         if (ctx == null) {
             throw new NoSuchElementException(handler.getClass().getName());
         } else {
@@ -917,8 +1018,8 @@ private DefaultChannelHandlerContext getContextOrDie(ChannelHandler handler) {
         }
     }
 
-    private DefaultChannelHandlerContext getContextOrDie(Class<? extends ChannelHandler> handlerType) {
-        DefaultChannelHandlerContext ctx = (DefaultChannelHandlerContext) context(handlerType);
+    private AbstractChannelHandlerContext getContextOrDie(Class<? extends ChannelHandler> handlerType) {
+        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handlerType);
         if (ctx == null) {
             throw new NoSuchElementException(handlerType.getName());
         } else {
@@ -927,7 +1028,18 @@ private DefaultChannelHandlerContext getContextOrDie(Class<? extends ChannelHand
     }
 
     // A special catch-all handler that handles both bytes and messages.
-    static final class TailHandler implements ChannelInboundHandler {
+    static final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
+
+        private static final String TAIL_NAME = generateName0(TailContext.class);
+
+        TailContext(DefaultChannelPipeline pipeline) {
+            super(pipeline, null, TAIL_NAME, true, false);
+        }
+
+        @Override
+        public ChannelHandler handler() {
+            return this;
+        }
 
         @Override
         public void channelRegistered(ChannelHandlerContext ctx) throws Exception { }
@@ -975,22 +1087,31 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { }
     }
 
-    static final class HeadHandler implements ChannelOutboundHandler {
+    static final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler {
 
-        protected final Unsafe unsafe;
+        private static final String HEAD_NAME = generateName0(HeadContext.class);
 
-        protected HeadHandler(Unsafe unsafe) {
-            this.unsafe = unsafe;
+        private final Unsafe unsafe;
+
+        HeadContext(DefaultChannelPipeline pipeline) {
+            super(pipeline, null, HEAD_NAME, false, true);
+            unsafe = pipeline.channel().unsafe();
         }
 
         @Override
-        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-            // NOOP
+        public ChannelHandler handler() {
+            return this;
         }
 
         @Override
-        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
-            // NOOP
+        public void handlerAdded(ChannelHandlerContext ctx) throws Exception { }
+
+        @Override
+        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception { }
+
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+            ctx.fireExceptionCaught(cause);
         }
 
         @Override
@@ -1037,10 +1158,5 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         public void flush(ChannelHandlerContext ctx) throws Exception {
             unsafe.flush();
         }
-
-        @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-            ctx.fireExceptionCaught(cause);
-        }
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java b/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java
index 4b101e0cc080..a71f01f5b8f7 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java
@@ -166,4 +166,14 @@ protected void checkDeadLock() {
             super.checkDeadLock();
         }
     }
+
+    @Override
+    public ChannelProgressivePromise unvoid() {
+        return this;
+    }
+
+    @Override
+    public boolean isVoid() {
+        return false;
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java
index 3d763472812f..0fc89b9069ca 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java
@@ -157,4 +157,14 @@ protected void checkDeadLock() {
             super.checkDeadLock();
         }
     }
+
+    @Override
+    public ChannelPromise unvoid() {
+        return this;
+    }
+
+    @Override
+    public boolean isVoid() {
+        return false;
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/local/LocalEventLoop.java b/transport/src/main/java/io/netty/channel/DefaultEventLoop.java
similarity index 57%
rename from transport/src/main/java/io/netty/channel/local/LocalEventLoop.java
rename to transport/src/main/java/io/netty/channel/DefaultEventLoop.java
index 418d5b2f962a..53d2e3b12bc6 100644
--- a/transport/src/main/java/io/netty/channel/local/LocalEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/DefaultEventLoop.java
@@ -13,18 +13,39 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.channel.local;
+package io.netty.channel;
 
-import io.netty.channel.SingleThreadEventLoop;
+import io.netty.util.concurrent.DefaultThreadFactory;
 
+import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 
-final class LocalEventLoop extends SingleThreadEventLoop {
+public class DefaultEventLoop extends SingleThreadEventLoop {
 
-    LocalEventLoop(LocalEventLoopGroup parent, ThreadFactory threadFactory) {
+    public DefaultEventLoop() {
+        this((EventLoopGroup) null);
+    }
+
+    public DefaultEventLoop(ThreadFactory threadFactory) {
+        this(null, threadFactory);
+    }
+
+    public DefaultEventLoop(Executor executor) {
+        this(null, executor);
+    }
+
+    public DefaultEventLoop(EventLoopGroup parent) {
+        this(parent, new DefaultThreadFactory(DefaultEventLoop.class));
+    }
+
+    public DefaultEventLoop(EventLoopGroup parent, ThreadFactory threadFactory) {
         super(parent, threadFactory, true);
     }
 
+    public DefaultEventLoop(EventLoopGroup parent, Executor executor) {
+        super(parent, executor, true);
+    }
+
     @Override
     protected void run() {
         for (;;) {
diff --git a/transport/src/main/java/io/netty/channel/DefaultEventLoopGroup.java b/transport/src/main/java/io/netty/channel/DefaultEventLoopGroup.java
new file mode 100644
index 000000000000..6e8ba13452f1
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/DefaultEventLoopGroup.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * {@link MultithreadEventLoopGroup} which must be used for the local transport.
+ */
+public class DefaultEventLoopGroup extends MultithreadEventLoopGroup {
+
+    /**
+     * Create a new instance with the default number of threads.
+     */
+    public DefaultEventLoopGroup() {
+        this(0);
+    }
+
+    /**
+     * Create a new instance
+     *
+     * @param nThreads          the number of threads to use
+     */
+    public DefaultEventLoopGroup(int nThreads) {
+        this(nThreads, null);
+    }
+
+    /**
+     * Create a new instance
+     *
+     * @param nThreads          the number of threads to use
+     * @param threadFactory     the {@link ThreadFactory} or {@code null} to use the default
+     */
+    public DefaultEventLoopGroup(int nThreads, ThreadFactory threadFactory) {
+        super(nThreads, threadFactory);
+    }
+
+    @Override
+    protected EventLoop newChild(Executor executor, Object... args) throws Exception {
+        return new DefaultEventLoop(this, executor);
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/DefaultFileRegion.java b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java
index c2ac264cc618..75ef56a9f048 100644
--- a/transport/src/main/java/io/netty/channel/DefaultFileRegion.java
+++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java
@@ -104,4 +104,26 @@ protected void deallocate() {
             }
         }
     }
+
+    @Override
+    public FileRegion retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public FileRegion retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public FileRegion touch() {
+        return this;
+    }
+
+    @Override
+    public FileRegion touch(Object hint) {
+        return this;
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/EventLoop.java b/transport/src/main/java/io/netty/channel/EventLoop.java
index 13a2a396f2cd..a750a216fd3b 100644
--- a/transport/src/main/java/io/netty/channel/EventLoop.java
+++ b/transport/src/main/java/io/netty/channel/EventLoop.java
@@ -27,4 +27,10 @@
 public interface EventLoop extends EventExecutor, EventLoopGroup {
     @Override
     EventLoopGroup parent();
+
+    /**
+     * Creates a new default {@link ChannelHandlerInvoker} implementation that uses this {@link EventLoop} to
+     * invoke event handler methods.
+     */
+    ChannelHandlerInvoker asInvoker();
 }
diff --git a/transport/src/main/java/io/netty/channel/FailedChannelFuture.java b/transport/src/main/java/io/netty/channel/FailedChannelFuture.java
index 323d8a4e1246..92f83cd24ecd 100644
--- a/transport/src/main/java/io/netty/channel/FailedChannelFuture.java
+++ b/transport/src/main/java/io/netty/channel/FailedChannelFuture.java
@@ -33,7 +33,7 @@ final class FailedChannelFuture extends CompleteChannelFuture {
      * @param channel the {@link Channel} associated with this future
      * @param cause   the cause of failure
      */
-    public FailedChannelFuture(Channel channel, EventExecutor executor, Throwable cause) {
+    FailedChannelFuture(Channel channel, EventExecutor executor, Throwable cause) {
         super(channel, executor);
         if (cause == null) {
             throw new NullPointerException("cause");
diff --git a/transport/src/main/java/io/netty/channel/FileRegion.java b/transport/src/main/java/io/netty/channel/FileRegion.java
index fe4fcdd4ba26..77c467c21372 100644
--- a/transport/src/main/java/io/netty/channel/FileRegion.java
+++ b/transport/src/main/java/io/netty/channel/FileRegion.java
@@ -80,4 +80,16 @@ public interface FileRegion extends ReferenceCounted {
      *                  byte of the region transferred.
      */
     long transferTo(WritableByteChannel target, long position) throws IOException;
+
+    @Override
+    FileRegion retain();
+
+    @Override
+    FileRegion retain(int increment);
+
+    @Override
+    FileRegion touch();
+
+    @Override
+    FileRegion touch(Object hint);
 }
diff --git a/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
index 8ee66f46eace..aae17b4505ed 100644
--- a/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
@@ -21,6 +21,7 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 
 /**
@@ -42,11 +43,18 @@ public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutor
         }
     }
 
+    /**
+     * @see {@link MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, Executor, Object...)}
+     */
+    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
+        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
+    }
+
     /**
      * @see {@link MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, ThreadFactory, Object...)}
      */
     protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
-        super(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);
+        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);
     }
 
     @Override
@@ -59,6 +67,9 @@ public EventLoop next() {
         return (EventLoop) super.next();
     }
 
+    @Override
+    protected abstract EventLoop newChild(Executor executor, Object... args) throws Exception;
+
     @Override
     public ChannelFuture register(Channel channel) {
         return next().register(channel);
diff --git a/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java b/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
index 85c130385594..6e2b4aa9f2c0 100644
--- a/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
+++ b/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
@@ -35,11 +35,13 @@
  *     }
  * </pre>
  *
- * Be aware that depending of the constructor parameters it will release all handled messages.
+ * Be aware that depending of the constructor parameters it will release all handled messages by pass them to
+ * {@link ReferenceCountUtil#release(Object)}. In this case you may need to use
+ * {@link ReferenceCountUtil#retain(Object)} if you pass the object to the next handler in the {@link ChannelPipeline}.
  *
  * <h3>Forward compatibility notice</h3>
  * <p>
- * Please keep in mind that {@link #channelRead0(ChannelHandlerContext, Object)} will be renamed to
+ * Please keep in mind that {@link #channelRead0(ChannelHandlerContext, I)} will be renamed to
  * {@code messageReceived(ChannelHandlerContext, I)} in 5.0.
  * </p>
  */
diff --git a/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
index d334fbfaf597..81cc3dbaefad 100644
--- a/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
@@ -15,24 +15,27 @@
  */
 package io.netty.channel;
 
-import io.netty.util.concurrent.EventExecutorGroup;
 import io.netty.util.concurrent.SingleThreadEventExecutor;
 
+import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 
 /**
- * Abstract base class for {@link EventLoop}'s that execute all its submitted tasks in a single thread.
+ * Abstract base class for {@link EventLoop}s that execute all its submitted tasks in a single thread.
  *
  */
 public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
 
-    /**
-     * @see {@link SingleThreadEventExecutor#SingleThreadEventExecutor(EventExecutorGroup, ThreadFactory, boolean)}
-     */
+    private final ChannelHandlerInvoker invoker = new DefaultChannelHandlerInvoker(this);
+
     protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {
         super(parent, threadFactory, addTaskWakesUp);
     }
 
+    protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor, boolean addTaskWakesUp) {
+        super(parent, executor, addTaskWakesUp);
+    }
+
     @Override
     public EventLoopGroup parent() {
         return (EventLoopGroup) super.parent();
@@ -43,6 +46,11 @@ public EventLoop next() {
         return (EventLoop) super.next();
     }
 
+    @Override
+    public ChannelHandlerInvoker asInvoker() {
+        return invoker;
+    }
+
     @Override
     public ChannelFuture register(Channel channel) {
         return register(channel, new DefaultChannelPromise(channel, this));
@@ -67,7 +75,7 @@ protected boolean wakesUpForTask(Runnable task) {
     }
 
     /**
-     * Marker interface for {@linkRunnable} that will not trigger an {@link #wakeup(boolean)} in all cases.
+     * Marker interface for {@link Runnable} that will not trigger an {@link #wakeup(boolean)} in all cases.
      */
     interface NonWakeupRunnable extends Runnable { }
 }
diff --git a/transport/src/main/java/io/netty/channel/SucceededChannelFuture.java b/transport/src/main/java/io/netty/channel/SucceededChannelFuture.java
index 26d6fff19ddd..c84b295d7251 100644
--- a/transport/src/main/java/io/netty/channel/SucceededChannelFuture.java
+++ b/transport/src/main/java/io/netty/channel/SucceededChannelFuture.java
@@ -29,7 +29,7 @@ final class SucceededChannelFuture extends CompleteChannelFuture {
      *
      * @param channel the {@link Channel} associated with this future
      */
-    public SucceededChannelFuture(Channel channel, EventExecutor executor) {
+    SucceededChannelFuture(Channel channel, EventExecutor executor) {
         super(channel, executor);
     }
 
diff --git a/transport/src/main/java/io/netty/channel/ThreadLocalPooledDirectByteBuf.java b/transport/src/main/java/io/netty/channel/ThreadLocalPooledDirectByteBuf.java
new file mode 100644
index 000000000000..7790e1492205
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/ThreadLocalPooledDirectByteBuf.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
+ */
+package io.netty.channel;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.UnpooledByteBufAllocator;
+import io.netty.buffer.UnpooledDirectByteBuf;
+import io.netty.buffer.UnpooledUnsafeDirectByteBuf;
+import io.netty.util.Recycler;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+final class ThreadLocalPooledDirectByteBuf {
+    private static final InternalLogger logger =
+            InternalLoggerFactory.getInstance(ThreadLocalPooledDirectByteBuf.class);
+    public static final int threadLocalDirectBufferSize;
+
+    static {
+        threadLocalDirectBufferSize = SystemPropertyUtil.getInt("io.netty.threadLocalDirectBufferSize", 64 * 1024);
+        logger.debug("-Dio.netty.threadLocalDirectBufferSize: {}", threadLocalDirectBufferSize);
+    }
+
+    public static ByteBuf newInstance() {
+        if (PlatformDependent.hasUnsafe()) {
+            return ThreadLocalUnsafeDirectByteBuf.newInstance();
+        } else {
+            return ThreadLocalDirectByteBuf.newInstance();
+        }
+    }
+
+    private ThreadLocalPooledDirectByteBuf() {
+        // utility
+    }
+
+    static final class ThreadLocalUnsafeDirectByteBuf extends UnpooledUnsafeDirectByteBuf {
+
+        private static final Recycler<ThreadLocalUnsafeDirectByteBuf> RECYCLER =
+                new Recycler<ThreadLocalUnsafeDirectByteBuf>() {
+            @Override
+            protected ThreadLocalUnsafeDirectByteBuf newObject(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {
+                return new ThreadLocalUnsafeDirectByteBuf(handle);
+            }
+        };
+
+        static ThreadLocalUnsafeDirectByteBuf newInstance() {
+            ThreadLocalUnsafeDirectByteBuf buf = RECYCLER.get();
+            buf.setRefCnt(1);
+            return buf;
+        }
+
+        private final Recycler.Handle<ThreadLocalUnsafeDirectByteBuf> handle;
+
+        private ThreadLocalUnsafeDirectByteBuf(Recycler.Handle<ThreadLocalUnsafeDirectByteBuf> handle) {
+            super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);
+            this.handle = handle;
+        }
+
+        @Override
+        protected void deallocate() {
+            if (capacity() > threadLocalDirectBufferSize) {
+                super.deallocate();
+            } else {
+                clear();
+                RECYCLER.recycle(this, handle);
+            }
+        }
+    }
+
+    static final class ThreadLocalDirectByteBuf extends UnpooledDirectByteBuf {
+
+        private static final Recycler<ThreadLocalDirectByteBuf> RECYCLER = new Recycler<ThreadLocalDirectByteBuf>() {
+            @Override
+            protected ThreadLocalDirectByteBuf newObject(Handle<ThreadLocalDirectByteBuf> handle) {
+                return new ThreadLocalDirectByteBuf(handle);
+            }
+        };
+
+        static ThreadLocalDirectByteBuf newInstance() {
+            ThreadLocalDirectByteBuf buf = RECYCLER.get();
+            buf.setRefCnt(1);
+            return buf;
+        }
+
+        private final Recycler.Handle<ThreadLocalDirectByteBuf> handle;
+
+        private ThreadLocalDirectByteBuf(Recycler.Handle<ThreadLocalDirectByteBuf> handle) {
+            super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);
+            this.handle = handle;
+        }
+
+        @Override
+        protected void deallocate() {
+            if (capacity() > threadLocalDirectBufferSize) {
+                super.deallocate();
+            } else {
+                clear();
+                RECYCLER.recycle(this, handle);
+            }
+        }
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
index a3a3d11b345f..c73f36a929c6 100644
--- a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
@@ -26,7 +26,7 @@ public class ThreadPerChannelEventLoop extends SingleThreadEventLoop {
     private Channel ch;
 
     public ThreadPerChannelEventLoop(ThreadPerChannelEventLoopGroup parent) {
-        super(parent, parent.threadFactory, true);
+        super(parent, parent.executor, true);
         this.parent = parent;
     }
 
@@ -34,7 +34,6 @@ public ThreadPerChannelEventLoop(ThreadPerChannelEventLoopGroup parent) {
     public ChannelFuture register(Channel channel, ChannelPromise promise) {
         return super.register(channel, promise).addListener(new ChannelFutureListener() {
             @Override
-            @SuppressWarnings("unchecked")
             public void operationComplete(ChannelFuture future) throws Exception {
                 if (future.isSuccess()) {
                     ch = future.channel();
diff --git a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
index 4c1cacebc551..700625506cc8 100644
--- a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
@@ -23,6 +23,7 @@
 import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.GlobalEventExecutor;
 import io.netty.util.concurrent.Promise;
+import io.netty.util.concurrent.ThreadPerTaskExecutor;
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.ReadOnlyIterator;
@@ -32,6 +33,7 @@
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ThreadFactory;
@@ -44,10 +46,11 @@ public class ThreadPerChannelEventLoopGroup extends AbstractEventExecutorGroup i
 
     private final Object[] childArgs;
     private final int maxChannels;
-    final ThreadFactory threadFactory;
-    final Set<ThreadPerChannelEventLoop> activeChildren =
-            Collections.newSetFromMap(PlatformDependent.<ThreadPerChannelEventLoop, Boolean>newConcurrentHashMap());
-    final Queue<ThreadPerChannelEventLoop> idleChildren = new ConcurrentLinkedQueue<ThreadPerChannelEventLoop>();
+    final Executor executor;
+    final Set<EventLoop> activeChildren =
+            Collections.newSetFromMap(PlatformDependent.<EventLoop, Boolean>newConcurrentHashMap());
+    private final Set<EventLoop> readOnlyActiveChildren = Collections.unmodifiableSet(activeChildren);
+    final Queue<EventLoop> idleChildren = new ConcurrentLinkedQueue<EventLoop>();
     private final ChannelException tooManyChannels;
 
     private volatile boolean shuttingDown;
@@ -74,7 +77,7 @@ protected ThreadPerChannelEventLoopGroup() {
      *
      * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
      *                          a new {@link Channel} and the maximum is exceed it will throw an
-     *                          {@link ChannelException} on the {@link #register(Channel)} and
+     *                          {@link ChannelException}. on the {@link #register(Channel)} and
      *                          {@link #register(Channel, ChannelPromise)} method.
      *                          Use {@code 0} to use no limit
      */
@@ -95,12 +98,28 @@ protected ThreadPerChannelEventLoopGroup(int maxChannels) {
      * @param args              arguments which will passed to each {@link #newChild(Object...)} call.
      */
     protected ThreadPerChannelEventLoopGroup(int maxChannels, ThreadFactory threadFactory, Object... args) {
+        this(maxChannels, new ThreadPerTaskExecutor(threadFactory), args);
+    }
+
+    /**
+     * Create a new {@link ThreadPerChannelEventLoopGroup}.
+     *
+     * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
+     *                          a new {@link Channel} and the maximum is exceed it will throw an
+     *                          {@link ChannelException} on the {@link #register(Channel)} and
+     *                          {@link #register(Channel, ChannelPromise)} method.
+     *                          Use {@code 0} to use no limit
+     * @param executor          the {@link Executor} used to create new {@link Thread} instances that handle the
+     *                          registered {@link Channel}s
+     * @param args              arguments which will passed to each {@link #newChild(Object...)} call.
+     */
+    protected ThreadPerChannelEventLoopGroup(int maxChannels, Executor executor, Object... args) {
         if (maxChannels < 0) {
             throw new IllegalArgumentException(String.format(
                     "maxChannels: %d (expected: >= 0)", maxChannels));
         }
-        if (threadFactory == null) {
-            throw new NullPointerException("threadFactory");
+        if (executor == null) {
+            throw new NullPointerException("executor");
         }
 
         if (args == null) {
@@ -110,7 +129,7 @@ protected ThreadPerChannelEventLoopGroup(int maxChannels, ThreadFactory threadFa
         }
 
         this.maxChannels = maxChannels;
-        this.threadFactory = threadFactory;
+        this.executor = executor;
 
         tooManyChannels = new ChannelException("too many channels (max: " + maxChannels + ')');
         tooManyChannels.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
@@ -119,8 +138,7 @@ protected ThreadPerChannelEventLoopGroup(int maxChannels, ThreadFactory threadFa
     /**
      * Creates a new {@link EventLoop}.  The default implementation creates a new {@link ThreadPerChannelEventLoop}.
      */
-    protected ThreadPerChannelEventLoop newChild(
-            @SuppressWarnings("UnusedParameters") Object... args) throws Exception {
+    protected EventLoop newChild(@SuppressWarnings("UnusedParameters") Object... args) throws Exception {
         return new ThreadPerChannelEventLoop(this);
     }
 
@@ -129,6 +147,12 @@ public Iterator<EventExecutor> iterator() {
         return new ReadOnlyIterator<EventExecutor>(activeChildren.iterator());
     }
 
+    @Override
+    @SuppressWarnings("unchecked")
+    public <E extends EventExecutor> Set<E> children() {
+        return (Set<E>) readOnlyActiveChildren;
+    }
+
     @Override
     public EventLoop next() {
         throw new UnsupportedOperationException();
@@ -281,7 +305,7 @@ private EventLoop nextChild() throws Exception {
             throw new RejectedExecutionException("shutting down");
         }
 
-        ThreadPerChannelEventLoop loop = idleChildren.poll();
+        EventLoop loop = idleChildren.poll();
         if (loop == null) {
             if (maxChannels > 0 && activeChildren.size() >= maxChannels) {
                 throw tooManyChannels;
diff --git a/transport/src/main/java/io/netty/channel/VoidChannelPromise.java b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java
index f32a544843df..0207a82c686e 100644
--- a/transport/src/main/java/io/netty/channel/VoidChannelPromise.java
+++ b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java
@@ -31,7 +31,7 @@ final class VoidChannelPromise extends AbstractFuture<Void> implements ChannelPr
      *
      * @param channel the {@link Channel} associated with this future
      */
-    public VoidChannelPromise(Channel channel, boolean fireException) {
+    VoidChannelPromise(Channel channel, boolean fireException) {
         if (channel == null) {
             throw new NullPointerException("channel");
         }
@@ -193,6 +193,27 @@ public Void getNow() {
         return null;
     }
 
+    @Override
+    public ChannelPromise unvoid() {
+        ChannelPromise promise = new DefaultChannelPromise(channel);
+        if (fireException) {
+            promise.addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    if (!future.isSuccess()) {
+                        fireException(future.cause());
+                    }
+                }
+            });
+        }
+        return promise;
+    }
+
+    @Override
+    public boolean isVoid() {
+        return true;
+    }
+
     private void fireException(Throwable cause) {
         // Only fire the exception if the channel is open and registered
         // if not the pipeline is not setup and so it would hit the tail
diff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
index 62777685deb2..81683d3796d7 100644
--- a/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
@@ -44,45 +44,50 @@
  */
 public class EmbeddedChannel extends AbstractChannel {
 
+    private static final SocketAddress LOCAL_ADDRESS = new EmbeddedSocketAddress();
+    private static final SocketAddress REMOTE_ADDRESS = new EmbeddedSocketAddress();
+
+    private static final ChannelHandler[] EMPTY_HANDLERS = new ChannelHandler[0];
+    private enum State { OPEN, ACTIVE, CLOSED }
+
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(EmbeddedChannel.class);
 
     private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private final EmbeddedEventLoop loop = new EmbeddedEventLoop();
     private final ChannelConfig config = new DefaultChannelConfig(this);
-    private final SocketAddress localAddress = new EmbeddedSocketAddress();
-    private final SocketAddress remoteAddress = new EmbeddedSocketAddress();
     private final Queue<Object> inboundMessages = new ArrayDeque<Object>();
     private final Queue<Object> outboundMessages = new ArrayDeque<Object>();
     private Throwable lastException;
-    private int state; // 0 = OPEN, 1 = ACTIVE, 2 = CLOSED
+    private State state;
+
+    /**
+     * Create a new instance with an empty pipeline.
+     */
+    public EmbeddedChannel() {
+        this(EMPTY_HANDLERS);
+    }
 
     /**
-     * Create a new instance
+     * Create a new instance with the pipeline initialized with the specified handlers.
      *
      * @param handlers the @link ChannelHandler}s which will be add in the {@link ChannelPipeline}
      */
     public EmbeddedChannel(ChannelHandler... handlers) {
-        super(null);
+        super(null, EmbeddedChannelId.INSTANCE);
 
         if (handlers == null) {
             throw new NullPointerException("handlers");
         }
 
-        int nHandlers = 0;
         ChannelPipeline p = pipeline();
         for (ChannelHandler h: handlers) {
             if (h == null) {
                 break;
             }
-            nHandlers ++;
             p.addLast(h);
         }
 
-        if (nHandlers == 0) {
-            throw new IllegalArgumentException("handlers is empty.");
-        }
-
         p.addLast(new LastInboundHandler());
         loop.register(this);
     }
@@ -99,12 +104,12 @@ public ChannelConfig config() {
 
     @Override
     public boolean isOpen() {
-        return state < 2;
+        return state != State.CLOSED;
     }
 
     @Override
     public boolean isActive() {
-        return state == 1;
+        return state == State.ACTIVE;
     }
 
     /**
@@ -140,15 +145,17 @@ public Queue<Object> lastOutboundBuffer() {
     /**
      * Return received data from this {@link Channel}
      */
-    public Object readInbound() {
-        return inboundMessages.poll();
+    @SuppressWarnings("unchecked")
+    public <T> T readInbound() {
+        return (T) inboundMessages.poll();
     }
 
     /**
      * Read data froum the outbound. This may return {@code null} if nothing is readable.
      */
-    public Object readOutbound() {
-        return outboundMessages.poll();
+    @SuppressWarnings("unchecked")
+    public <T> T readOutbound() {
+        return (T) outboundMessages.poll();
     }
 
     /**
@@ -279,17 +286,17 @@ protected boolean isCompatible(EventLoop loop) {
 
     @Override
     protected SocketAddress localAddress0() {
-        return isActive()? localAddress : null;
+        return isActive()? LOCAL_ADDRESS : null;
     }
 
     @Override
     protected SocketAddress remoteAddress0() {
-        return isActive()? remoteAddress : null;
+        return isActive()? REMOTE_ADDRESS : null;
     }
 
     @Override
     protected void doRegister() throws Exception {
-        state = 1;
+        state = State.ACTIVE;
     }
 
     @Override
@@ -304,7 +311,7 @@ protected void doDisconnect() throws Exception {
 
     @Override
     protected void doClose() throws Exception {
-        state = 2;
+        state = State.CLOSED;
     }
 
     @Override
diff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannelId.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannelId.java
new file mode 100644
index 000000000000..01675c2f68ca
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannelId.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel.embedded;
+
+import io.netty.channel.ChannelId;
+
+/**
+ * A dummy {@link ChannelId} implementation.
+ */
+final class EmbeddedChannelId implements ChannelId {
+
+    private static final long serialVersionUID = -251711922203466130L;
+
+    static final ChannelId INSTANCE = new EmbeddedChannelId();
+
+    private EmbeddedChannelId() { }
+
+    @Override
+    public String asShortText() {
+        return toString();
+    }
+
+    @Override
+    public String asLongText() {
+        return toString();
+    }
+
+    @Override
+    public int compareTo(ChannelId o) {
+        if (o == INSTANCE) {
+            return 0;
+        }
+
+        return asLongText().compareTo(o.asLongText());
+    }
+
+    @Override
+    public int hashCode() {
+        return super.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return super.equals(obj);
+    }
+
+    @Override
+    public String toString() {
+        return "embedded";
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
index 345b8d0f78db..21bb2c30ab0c 100644
--- a/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
@@ -15,20 +15,24 @@
  */
 package io.netty.channel.embedded;
 
+import io.netty.channel.AbstractEventLoop;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelHandlerInvoker;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.DefaultChannelPromise;
-import io.netty.channel.EventLoop;
-import io.netty.channel.EventLoopGroup;
-import io.netty.util.concurrent.AbstractEventExecutor;
+import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.Future;
 
+import java.net.SocketAddress;
 import java.util.ArrayDeque;
 import java.util.Queue;
 import java.util.concurrent.TimeUnit;
 
-final class EmbeddedEventLoop extends AbstractEventExecutor implements EventLoop {
+import static io.netty.channel.ChannelHandlerInvokerUtil.*;
+
+final class EmbeddedEventLoop extends AbstractEventLoop implements ChannelHandlerInvoker {
 
     private final Queue<Runnable> tasks = new ArrayDeque<Runnable>(2);
 
@@ -83,9 +87,7 @@ public boolean isTerminated() {
     }
 
     @Override
-    public boolean awaitTermination(long timeout, TimeUnit unit)
-            throws InterruptedException {
-        Thread.sleep(unit.toMillis(timeout));
+    public boolean awaitTermination(long timeout, TimeUnit unit) {
         return false;
     }
 
@@ -111,12 +113,99 @@ public boolean inEventLoop(Thread thread) {
     }
 
     @Override
-    public EventLoop next() {
+    public ChannelHandlerInvoker asInvoker() {
         return this;
     }
 
     @Override
-    public EventLoopGroup parent() {
+    public EventExecutor executor() {
         return this;
     }
+
+    @Override
+    public void invokeChannelRegistered(ChannelHandlerContext ctx) {
+        invokeChannelRegisteredNow(ctx);
+    }
+
+    @Override
+    public void invokeChannelUnregistered(ChannelHandlerContext ctx) {
+        invokeChannelUnregisteredNow(ctx);
+    }
+
+    @Override
+    public void invokeChannelActive(ChannelHandlerContext ctx) {
+        invokeChannelActiveNow(ctx);
+    }
+
+    @Override
+    public void invokeChannelInactive(ChannelHandlerContext ctx) {
+        invokeChannelInactiveNow(ctx);
+    }
+
+    @Override
+    public void invokeExceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        invokeExceptionCaughtNow(ctx, cause);
+    }
+
+    @Override
+    public void invokeUserEventTriggered(ChannelHandlerContext ctx, Object event) {
+        invokeUserEventTriggeredNow(ctx, event);
+    }
+
+    @Override
+    public void invokeChannelRead(ChannelHandlerContext ctx, Object msg) {
+        invokeChannelReadNow(ctx, msg);
+    }
+
+    @Override
+    public void invokeChannelReadComplete(ChannelHandlerContext ctx) {
+        invokeChannelReadCompleteNow(ctx);
+    }
+
+    @Override
+    public void invokeChannelWritabilityChanged(ChannelHandlerContext ctx) {
+        invokeChannelWritabilityChangedNow(ctx);
+    }
+
+    @Override
+    public void invokeBind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {
+        invokeBindNow(ctx, localAddress, promise);
+    }
+
+    @Override
+    public void invokeConnect(
+            ChannelHandlerContext ctx,
+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
+        invokeConnectNow(ctx, remoteAddress, localAddress, promise);
+    }
+
+    @Override
+    public void invokeDisconnect(ChannelHandlerContext ctx, ChannelPromise promise) {
+        invokeDisconnectNow(ctx, promise);
+    }
+
+    @Override
+    public void invokeClose(ChannelHandlerContext ctx, ChannelPromise promise) {
+        invokeCloseNow(ctx, promise);
+    }
+
+    @Override
+    public void invokeDeregister(ChannelHandlerContext ctx, ChannelPromise promise) {
+        invokeDeregisterNow(ctx, promise);
+    }
+
+    @Override
+    public void invokeRead(ChannelHandlerContext ctx) {
+        invokeReadNow(ctx);
+    }
+
+    @Override
+    public void invokeWrite(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+        invokeWriteNow(ctx, msg, promise);
+    }
+
+    @Override
+    public void invokeFlush(ChannelHandlerContext ctx) {
+        invokeFlushNow(ctx);
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/embedded/package-info.java b/transport/src/main/java/io/netty/channel/embedded/package-info.java
index 57321517e23f..b69473f70fc6 100644
--- a/transport/src/main/java/io/netty/channel/embedded/package-info.java
+++ b/transport/src/main/java/io/netty/channel/embedded/package-info.java
@@ -15,7 +15,7 @@
  */
 
 /**
- * A virtual {@link Channel} that helps wrapping a series of handlers to
+ * A virtual {@link io.netty.channel.Channel} that helps wrapping a series of handlers to
  * unit test the handlers or use them in non-I/O context.
  */
 package io.netty.channel.embedded;
diff --git a/transport/src/main/java/io/netty/channel/group/ChannelGroup.java b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
index 85cfa6e94bfc..7dbafa7377de 100644
--- a/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
@@ -21,6 +21,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelId;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.EventLoop;
 import io.netty.channel.ServerChannel;
@@ -100,6 +101,13 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
      */
     String name();
 
+    /**
+     * Returns the {@link Channel} which has the specified {@link ChannelId}.
+     *
+     * @return the matching {@link Channel} if found. {@code null} otherwise.
+     */
+    Channel find(ChannelId id);
+
     /**
      * Writes the specified {@code message} to all {@link Channel}s in this
      * group. If the specified {@code message} is an instance of
diff --git a/transport/src/main/java/io/netty/channel/group/ChannelMatchers.java b/transport/src/main/java/io/netty/channel/group/ChannelMatchers.java
index 30635430e02d..5f67f5f9d665 100644
--- a/transport/src/main/java/io/netty/channel/group/ChannelMatchers.java
+++ b/transport/src/main/java/io/netty/channel/group/ChannelMatchers.java
@@ -119,12 +119,12 @@ private static final class CompositeMatcher implements ChannelMatcher {
 
         @Override
         public boolean matches(Channel channel) {
-            for (int i = 0; i < matchers.length; i++) {
-                if (!matchers[i].matches(channel)) {
-                    return true;
+            for (ChannelMatcher m: matchers) {
+                if (!m.matches(channel)) {
+                    return false;
                 }
             }
-            return false;
+            return true;
         }
     }
 
diff --git a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
index c5bb5be00884..90b04b1f0d2d 100644
--- a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
@@ -20,10 +20,11 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelId;
 import io.netty.channel.ServerChannel;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
-import io.netty.util.internal.ConcurrentSet;
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
 
 import java.util.AbstractSet;
@@ -32,6 +33,7 @@
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
@@ -42,8 +44,8 @@ public class DefaultChannelGroup extends AbstractSet<Channel> implements Channel
     private static final AtomicInteger nextId = new AtomicInteger();
     private final String name;
     private final EventExecutor executor;
-    private final ConcurrentSet<Channel> serverChannels = new ConcurrentSet<Channel>();
-    private final ConcurrentSet<Channel> nonServerChannels = new ConcurrentSet<Channel>();
+    private final ConcurrentMap<ChannelId, Channel> serverChannels = PlatformDependent.newConcurrentHashMap();
+    private final ConcurrentMap<ChannelId, Channel> nonServerChannels = PlatformDependent.newConcurrentHashMap();
     private final ChannelFutureListener remover = new ChannelFutureListener() {
         @Override
         public void operationComplete(ChannelFuture future) throws Exception {
@@ -77,6 +79,16 @@ public String name() {
         return name;
     }
 
+    @Override
+    public Channel find(ChannelId id) {
+        Channel c = nonServerChannels.get(id);
+        if (c != null) {
+            return c;
+        } else {
+            return serverChannels.get(id);
+        }
+    }
+
     @Override
     public boolean isEmpty() {
         return nonServerChannels.isEmpty() && serverChannels.isEmpty();
@@ -92,9 +104,9 @@ public boolean contains(Object o) {
         if (o instanceof Channel) {
             Channel c = (Channel) o;
             if (o instanceof ServerChannel) {
-                return serverChannels.contains(c);
+                return serverChannels.containsValue(c);
             } else {
-                return nonServerChannels.contains(c);
+                return nonServerChannels.containsValue(c);
             }
         } else {
             return false;
@@ -103,10 +115,10 @@ public boolean contains(Object o) {
 
     @Override
     public boolean add(Channel channel) {
-        ConcurrentSet<Channel> set =
+        ConcurrentMap<ChannelId, Channel> map =
             channel instanceof ServerChannel? serverChannels : nonServerChannels;
 
-        boolean added = set.add(channel);
+        boolean added = map.putIfAbsent(channel.id(), channel) == null;
         if (added) {
             channel.closeFuture().addListener(remover);
         }
@@ -115,17 +127,22 @@ public boolean add(Channel channel) {
 
     @Override
     public boolean remove(Object o) {
-        if (!(o instanceof Channel)) {
-            return false;
-        }
-        boolean removed;
-        Channel c = (Channel) o;
-        if (c instanceof ServerChannel) {
-            removed = serverChannels.remove(c);
-        } else {
-            removed = nonServerChannels.remove(c);
+        Channel c = null;
+        if (o instanceof ChannelId) {
+            c = nonServerChannels.remove(o);
+            if (c == null) {
+                c = serverChannels.remove(o);
+            }
+        } else if (o instanceof Channel) {
+            c = (Channel) o;
+            if (c instanceof ServerChannel) {
+                c = serverChannels.remove(c.id());
+            } else {
+                c = nonServerChannels.remove(c.id());
+            }
         }
-        if (!removed) {
+
+        if (c == null) {
             return false;
         }
 
@@ -142,23 +159,23 @@ public void clear() {
     @Override
     public Iterator<Channel> iterator() {
         return new CombinedIterator<Channel>(
-                serverChannels.iterator(),
-                nonServerChannels.iterator());
+                serverChannels.values().iterator(),
+                nonServerChannels.values().iterator());
     }
 
     @Override
     public Object[] toArray() {
         Collection<Channel> channels = new ArrayList<Channel>(size());
-        channels.addAll(serverChannels);
-        channels.addAll(nonServerChannels);
+        channels.addAll(serverChannels.values());
+        channels.addAll(nonServerChannels.values());
         return channels.toArray();
     }
 
     @Override
     public <T> T[] toArray(T[] a) {
         Collection<Channel> channels = new ArrayList<Channel>(size());
-        channels.addAll(serverChannels);
-        channels.addAll(nonServerChannels);
+        channels.addAll(serverChannels.values());
+        channels.addAll(nonServerChannels.values());
         return channels.toArray(a);
     }
 
@@ -173,7 +190,6 @@ public ChannelGroupFuture disconnect() {
     }
 
     @Override
-    @Deprecated
     public ChannelGroupFuture deregister() {
         return deregister(ChannelMatchers.all());
     }
@@ -205,7 +221,7 @@ public ChannelGroupFuture write(Object message, ChannelMatcher matcher) {
         }
 
         Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());
-        for (Channel c: nonServerChannels) {
+        for (Channel c: nonServerChannels.values()) {
             if (matcher.matches(c)) {
                 futures.put(c, c.write(safeDuplicate(message)));
             }
@@ -239,12 +255,12 @@ public ChannelGroupFuture disconnect(ChannelMatcher matcher) {
         Map<Channel, ChannelFuture> futures =
                 new LinkedHashMap<Channel, ChannelFuture>(size());
 
-        for (Channel c: serverChannels) {
+        for (Channel c: serverChannels.values()) {
             if (matcher.matches(c)) {
                 futures.put(c, c.disconnect());
             }
         }
-        for (Channel c: nonServerChannels) {
+        for (Channel c: nonServerChannels.values()) {
             if (matcher.matches(c)) {
                 futures.put(c, c.disconnect());
             }
@@ -262,12 +278,12 @@ public ChannelGroupFuture close(ChannelMatcher matcher) {
         Map<Channel, ChannelFuture> futures =
                 new LinkedHashMap<Channel, ChannelFuture>(size());
 
-        for (Channel c: serverChannels) {
+        for (Channel c: serverChannels.values()) {
             if (matcher.matches(c)) {
                 futures.put(c, c.close());
             }
         }
-        for (Channel c: nonServerChannels) {
+        for (Channel c: nonServerChannels.values()) {
             if (matcher.matches(c)) {
                 futures.put(c, c.close());
             }
@@ -277,7 +293,6 @@ public ChannelGroupFuture close(ChannelMatcher matcher) {
     }
 
     @Override
-    @Deprecated
     public ChannelGroupFuture deregister(ChannelMatcher matcher) {
         if (matcher == null) {
             throw new NullPointerException("matcher");
@@ -286,12 +301,12 @@ public ChannelGroupFuture deregister(ChannelMatcher matcher) {
         Map<Channel, ChannelFuture> futures =
                 new LinkedHashMap<Channel, ChannelFuture>(size());
 
-        for (Channel c: serverChannels) {
+        for (Channel c: serverChannels.values()) {
             if (matcher.matches(c)) {
                 futures.put(c, c.deregister());
             }
         }
-        for (Channel c: nonServerChannels) {
+        for (Channel c: nonServerChannels.values()) {
             if (matcher.matches(c)) {
                 futures.put(c, c.deregister());
             }
@@ -302,7 +317,7 @@ public ChannelGroupFuture deregister(ChannelMatcher matcher) {
 
     @Override
     public ChannelGroup flush(ChannelMatcher matcher) {
-        for (Channel c: nonServerChannels) {
+        for (Channel c: nonServerChannels.values()) {
             if (matcher.matches(c)) {
                 c.flush();
             }
@@ -323,7 +338,7 @@ public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher)
 
         Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());
 
-        for (Channel c: nonServerChannels) {
+        for (Channel c: nonServerChannels.values()) {
             if (matcher.matches(c)) {
                 futures.put(c, c.writeAndFlush(safeDuplicate(message)));
             }
diff --git a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
index ebfe6d4d40ff..e4afe232c37d 100644
--- a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
@@ -80,7 +80,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     /**
      * Creates a new instance.
      */
-    public DefaultChannelGroupFuture(ChannelGroup group, Collection<ChannelFuture> futures,  EventExecutor executor) {
+    DefaultChannelGroupFuture(ChannelGroup group, Collection<ChannelFuture> futures,  EventExecutor executor) {
         super(executor);
         if (group == null) {
             throw new NullPointerException("group");
@@ -241,7 +241,7 @@ private static final class DefaultEntry<K, V> implements Map.Entry<K, V> {
         private final K key;
         private final V value;
 
-        public DefaultEntry(K key, V value) {
+        DefaultEntry(K key, V value) {
             this.key = key;
             this.value = value;
         }
diff --git a/transport/src/main/java/io/netty/channel/local/LocalChannel.java b/transport/src/main/java/io/netty/channel/local/LocalChannel.java
index 25ffb6ccad83..eac78cb7b872 100644
--- a/transport/src/main/java/io/netty/channel/local/LocalChannel.java
+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java
@@ -28,6 +28,7 @@
 import io.netty.channel.SingleThreadEventLoop;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.SingleThreadEventExecutor;
+import io.netty.util.internal.InternalThreadLocalMap;
 
 import java.net.SocketAddress;
 import java.nio.channels.AlreadyConnectedException;
@@ -43,15 +44,11 @@
  */
 public class LocalChannel extends AbstractChannel {
 
+    private enum State { OPEN, BOUND, CONNECTED, CLOSED }
+
     private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private static final int MAX_READER_STACK_DEPTH = 8;
-    private static final ThreadLocal<Integer> READER_STACK_DEPTH = new ThreadLocal<Integer>() {
-        @Override
-        protected Integer initialValue() {
-            return 0;
-        }
-    };
 
     private final ChannelConfig config = new DefaultChannelConfig(this);
     private final Queue<Object> inboundBuffer = new ArrayDeque<Object>();
@@ -77,12 +74,13 @@ public void run() {
         }
     };
 
-    private volatile int state; // 0 - open, 1 - bound, 2 - connected, 3 - closed
+    private volatile State state;
     private volatile LocalChannel peer;
     private volatile LocalAddress localAddress;
     private volatile LocalAddress remoteAddress;
     private volatile ChannelPromise connectPromise;
     private volatile boolean readInProgress;
+    private volatile boolean registerInProgress;
 
     public LocalChannel() {
         super(null);
@@ -122,12 +120,12 @@ public LocalAddress remoteAddress() {
 
     @Override
     public boolean isOpen() {
-        return state < 3;
+        return state != State.CLOSED;
     }
 
     @Override
     public boolean isActive() {
-        return state == 2;
+        return state == State.CONNECTED;
     }
 
     @Override
@@ -152,11 +150,24 @@ protected SocketAddress remoteAddress0() {
 
     @Override
     protected void doRegister() throws Exception {
-        if (peer != null) {
-            state = 2;
-
-            peer.remoteAddress = parent().localAddress();
-            peer.state = 2;
+        // Check if both peer and parent are non-null because this channel was created by a LocalServerChannel.
+        // This is needed as a peer may not be null also if a LocalChannel was connected before and
+        // deregistered / registered later again.
+        //
+        // See https://github.com/netty/netty/issues/2400
+        if (peer != null && parent() != null) {
+            // Store the peer in a local variable as it may be set to null if doClose() is called.
+            // Because of this we also set registerInProgress to true as we check for this in doClose() and make sure
+            // we delay the fireChannelInactive() to be fired after the fireChannelActive() and so keep the correct
+            // order of events.
+            //
+            // See https://github.com/netty/netty/issues/2144
+            final LocalChannel peer = this.peer;
+            registerInProgress = true;
+            state = State.CONNECTED;
+
+            peer.remoteAddress = parent() == null ? null : parent().localAddress();
+            peer.state = State.CONNECTED;
 
             // Always call peer.eventLoop().execute() even if peer.eventLoop().inEventLoop() is true.
             // This ensures that if both channels are on the same event loop, the peer's channelActive
@@ -165,6 +176,7 @@ protected void doRegister() throws Exception {
             peer.eventLoop().execute(new Runnable() {
                 @Override
                 public void run() {
+                    registerInProgress = false;
                     peer.pipeline().fireChannelActive();
                     peer.connectPromise.setSuccess();
                 }
@@ -178,7 +190,7 @@ protected void doBind(SocketAddress localAddress) throws Exception {
         this.localAddress =
                 LocalChannelRegistry.register(this, this.localAddress,
                         localAddress);
-        state = 1;
+        state = State.BOUND;
     }
 
     @Override
@@ -188,7 +200,7 @@ protected void doDisconnect() throws Exception {
 
     @Override
     protected void doClose() throws Exception {
-        if (state <= 2) {
+        if (state != State.CLOSED) {
             // Update all internal state before the closeFuture is notified.
             if (localAddress != null) {
                 if (parent() == null) {
@@ -196,7 +208,7 @@ protected void doClose() throws Exception {
                 }
                 localAddress = null;
             }
-            state = 3;
+            state = State.CLOSED;
         }
 
         final LocalChannel peer = this.peer;
@@ -204,7 +216,12 @@ protected void doClose() throws Exception {
             // Need to execute the close in the correct EventLoop
             // See https://github.com/netty/netty/issues/1777
             EventLoop eventLoop = peer.eventLoop();
-            if (eventLoop.inEventLoop()) {
+
+            // Also check if the registration was not done yet. In this case we submit the close to the EventLoop
+            // to make sure it is run after the registration completes.
+            //
+            // See https://github.com/netty/netty/issues/2144
+            if (eventLoop.inEventLoop() && !registerInProgress) {
                 peer.unsafe().close(unsafe().voidPromise());
             } else {
                 peer.eventLoop().execute(new Runnable() {
@@ -220,9 +237,7 @@ public void run() {
 
     @Override
     protected void doDeregister() throws Exception {
-        if (isOpen()) {
-            unsafe().close(unsafe().voidPromise());
-        }
+        // Just remove the shutdownHook as this Channel may be closed later or registered to another EventLoop
         ((SingleThreadEventExecutor) eventLoop()).removeShutdownHook(shutdownHook);
     }
 
@@ -239,9 +254,10 @@ protected void doBeginRead() throws Exception {
             return;
         }
 
-        final Integer stackDepth = READER_STACK_DEPTH.get();
+        final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
+        final Integer stackDepth = threadLocals.localChannelReaderStackDepth();
         if (stackDepth < MAX_READER_STACK_DEPTH) {
-            READER_STACK_DEPTH.set(stackDepth + 1);
+            threadLocals.setLocalChannelReaderStackDepth(stackDepth + 1);
             try {
                 for (;;) {
                     Object received = inboundBuffer.poll();
@@ -252,7 +268,7 @@ protected void doBeginRead() throws Exception {
                 }
                 pipeline.fireChannelReadComplete();
             } finally {
-                READER_STACK_DEPTH.set(stackDepth);
+                threadLocals.setLocalChannelReaderStackDepth(stackDepth);
             }
         } else {
             eventLoop().execute(readTask);
@@ -261,10 +277,11 @@ protected void doBeginRead() throws Exception {
 
     @Override
     protected void doWrite(ChannelOutboundBuffer in) throws Exception {
-        if (state < 2) {
+        switch (state) {
+        case OPEN:
+        case BOUND:
             throw new NotYetConnectedException();
-        }
-        if (state > 2) {
+        case CLOSED:
             throw new ClosedChannelException();
         }
 
@@ -324,7 +341,7 @@ public void connect(final SocketAddress remoteAddress,
                 return;
             }
 
-            if (state == 2) {
+            if (state == State.CONNECTED) {
                 Exception cause = new AlreadyConnectedException();
                 safeSetFailure(promise, cause);
                 pipeline().fireExceptionCaught(cause);
@@ -337,7 +354,7 @@ public void connect(final SocketAddress remoteAddress,
 
             connectPromise = promise;
 
-            if (state != 1) {
+            if (state != State.BOUND) {
                 // Not bound yet and no localAddress specified - get one.
                 if (localAddress == null) {
                     localAddress = new LocalAddress(LocalChannel.this);
diff --git a/transport/src/main/java/io/netty/channel/local/LocalEventLoopGroup.java b/transport/src/main/java/io/netty/channel/local/LocalEventLoopGroup.java
index dd3c7d316bec..2bd3ff611edc 100644
--- a/transport/src/main/java/io/netty/channel/local/LocalEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/local/LocalEventLoopGroup.java
@@ -15,22 +15,20 @@
  */
 package io.netty.channel.local;
 
-import io.netty.channel.MultithreadEventLoopGroup;
-import io.netty.util.concurrent.EventExecutor;
+import io.netty.channel.DefaultEventLoopGroup;
 
 import java.util.concurrent.ThreadFactory;
 
 /**
- * {@link MultithreadEventLoopGroup} which must be used for the local transport.
+ * @deprecated Use {@link DefaultEventLoopGroup} instead.
  */
-public class LocalEventLoopGroup extends MultithreadEventLoopGroup {
+@Deprecated
+public class LocalEventLoopGroup extends DefaultEventLoopGroup {
 
     /**
      * Create a new instance with the default number of threads.
      */
-    public LocalEventLoopGroup() {
-        this(0);
-    }
+    public LocalEventLoopGroup() { }
 
     /**
      * Create a new instance
@@ -38,7 +36,7 @@ public LocalEventLoopGroup() {
      * @param nThreads          the number of threads to use
      */
     public LocalEventLoopGroup(int nThreads) {
-        this(nThreads, null);
+        super(nThreads);
     }
 
     /**
@@ -50,10 +48,4 @@ public LocalEventLoopGroup(int nThreads) {
     public LocalEventLoopGroup(int nThreads, ThreadFactory threadFactory) {
         super(nThreads, threadFactory);
     }
-
-    @Override
-    protected EventExecutor newChild(
-            ThreadFactory threadFactory, Object... args) throws Exception {
-        return new LocalEventLoop(this, threadFactory);
-    }
 }
diff --git a/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
index 73647c8ac2c5..f798e56e0546 100644
--- a/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
+++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
@@ -96,8 +96,10 @@ protected void doBind(SocketAddress localAddress) throws Exception {
     protected void doClose() throws Exception {
         if (state <= 1) {
             // Update all internal state before the closeFuture is notified.
-            LocalChannelRegistry.unregister(localAddress);
-            localAddress = null;
+            if (localAddress != null) {
+                LocalChannelRegistry.unregister(localAddress);
+                localAddress = null;
+            }
             state = 2;
         }
     }
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
index 3ac9f72fb761..d18cff47f4dd 100644
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
@@ -55,21 +55,6 @@ protected AbstractNioUnsafe newUnsafe() {
     private final class NioByteUnsafe extends AbstractNioUnsafe {
         private RecvByteBufAllocator.Handle allocHandle;
 
-        private void removeReadOp() {
-            SelectionKey key = selectionKey();
-            // Check first if the key is still valid as it may be canceled as part of the deregistration
-            // from the EventLoop
-            // See https://github.com/netty/netty/issues/2104
-            if (!key.isValid()) {
-                return;
-            }
-            int interestOps = key.interestOps();
-            if ((interestOps & readInterestOp) != 0) {
-                // only remove readInterestOp if needed
-                key.interestOps(interestOps & ~readInterestOp);
-            }
-        }
-
         private void closeOnRead(ChannelPipeline pipeline) {
             SelectionKey key = selectionKey();
             setInputShutdown();
@@ -83,9 +68,11 @@ private void closeOnRead(ChannelPipeline pipeline) {
             }
         }
 
-        private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Throwable cause, boolean close) {
+        private void handleReadException(ChannelPipeline pipeline,
+                                         ByteBuf byteBuf, Throwable cause, boolean close) {
             if (byteBuf != null) {
                 if (byteBuf.isReadable()) {
+                    setReadPending(false);
                     pipeline.fireChannelRead(byteBuf);
                 } else {
                     byteBuf.release();
@@ -101,6 +88,12 @@ private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf, Thro
         @Override
         public void read() {
             final ChannelConfig config = config();
+            if (!config.isAutoRead() && !isReadPending()) {
+                // ChannelConfig.setAutoRead(false) was called in the meantime
+                removeReadOp();
+                return;
+            }
+
             final ChannelPipeline pipeline = pipeline();
             final ByteBufAllocator allocator = config.getAllocator();
             final int maxMessagesPerRead = config.getMaxMessagesPerRead();
@@ -113,10 +106,10 @@ public void read() {
             int messages = 0;
             boolean close = false;
             try {
-                int byteBufCapacity = allocHandle.guess();
                 int totalReadAmount = 0;
+                boolean readPendingReset = false;
                 do {
-                    byteBuf = allocator.ioBuffer(byteBufCapacity);
+                    byteBuf = allocHandle.allocate(allocator);
                     int writable = byteBuf.writableBytes();
                     int localReadAmount = doReadBytes(byteBuf);
                     if (localReadAmount <= 0) {
@@ -125,7 +118,10 @@ public void read() {
                         close = localReadAmount < 0;
                         break;
                     }
-
+                    if (!readPendingReset) {
+                        readPendingReset = true;
+                        setReadPending(false);
+                    }
                     pipeline.fireChannelRead(byteBuf);
                     byteBuf = null;
 
@@ -159,7 +155,13 @@ public void read() {
             } catch (Throwable t) {
                 handleReadException(pipeline, byteBuf, t, close);
             } finally {
-                if (!config.isAutoRead()) {
+                // Check if there is a readPending which was not processed yet.
+                // This could be for two reasons:
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
+                //
+                // See https://github.com/netty/netty/issues/2254
+                if (!config.isAutoRead() && !isReadPending()) {
                     removeReadOp();
                 }
             }
@@ -186,17 +188,6 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
                     continue;
                 }
 
-                if (!buf.isDirect()) {
-                    ByteBufAllocator alloc = alloc();
-                    if (alloc.isDirectBufferPooled()) {
-                        // Non-direct buffers are copied into JDK's own internal direct buffer on every I/O.
-                        // We can do a better job by using our pooled allocator. If the current allocator does not
-                        // pool a direct buffer, we rely on JDK's direct buffer pool.
-                        buf = alloc.directBuffer(readableBytes).writeBytes(buf);
-                        in.current(buf);
-                    }
-                }
-
                 boolean setOpWrite = false;
                 boolean done = false;
                 long flushedAmount = 0;
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
index 09a0d7262f04..516a94f6650a 100644
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
@@ -23,6 +23,7 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.ConnectTimeoutException;
 import io.netty.channel.EventLoop;
+import io.netty.util.internal.OneTimeTask;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -45,8 +46,9 @@ public abstract class AbstractNioChannel extends AbstractChannel {
 
     private final SelectableChannel ch;
     protected final int readInterestOp;
-    private volatile SelectionKey selectionKey;
+    volatile SelectionKey selectionKey;
     private volatile boolean inputShutdown;
+    private volatile boolean readPending;
 
     /**
      * The future of the current connection attempt.  If not null, subsequent
@@ -110,6 +112,14 @@ protected SelectionKey selectionKey() {
         return selectionKey;
     }
 
+    protected boolean isReadPending() {
+        return readPending;
+    }
+
+    protected void setReadPending(boolean readPending) {
+        this.readPending = readPending;
+    }
+
     /**
      * Return {@code true} if the input of this {@link Channel} is shutdown
      */
@@ -148,6 +158,28 @@ public interface NioUnsafe extends Unsafe {
 
     protected abstract class AbstractNioUnsafe extends AbstractUnsafe implements NioUnsafe {
 
+        protected final void removeReadOp() {
+            SelectionKey key = selectionKey();
+            // Check first if the key is still valid as it may be canceled as part of the deregistration
+            // from the EventLoop
+            // See https://github.com/netty/netty/issues/2104
+            if (!key.isValid()) {
+                return;
+            }
+            int interestOps = key.interestOps();
+            if ((interestOps & readInterestOp) != 0) {
+                // only remove readInterestOp if needed
+                key.interestOps(interestOps & ~readInterestOp);
+            }
+        }
+
+        @Override
+        public void beginRead() {
+            // Channel.read() or ChannelHandlerContext.read() was called
+            readPending = true;
+            super.beginRead();
+        }
+
         @Override
         public SelectableChannel ch() {
             return javaChannel();
@@ -175,7 +207,7 @@ public void connect(
                     // Schedule connect timeout.
                     int connectTimeoutMillis = config().getConnectTimeoutMillis();
                     if (connectTimeoutMillis > 0) {
-                        connectTimeoutFuture = eventLoop().schedule(new Runnable() {
+                        connectTimeoutFuture = eventLoop().schedule(new OneTimeTask() {
                             @Override
                             public void run() {
                                 ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
index 15a55f63b703..c9e537431af0 100644
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
@@ -48,24 +48,21 @@ private final class NioMessageUnsafe extends AbstractNioUnsafe {
 
         private final List<Object> readBuf = new ArrayList<Object>();
 
-        private void removeReadOp() {
-            SelectionKey key = selectionKey();
-            int interestOps = key.interestOps();
-            if ((interestOps & readInterestOp) != 0) {
-                // only remove readInterestOp if needed
-                key.interestOps(interestOps & ~readInterestOp);
-            }
-        }
         @Override
         public void read() {
             assert eventLoop().inEventLoop();
             final ChannelConfig config = config();
+            if (!config.isAutoRead() && !isReadPending()) {
+                // ChannelConfig.setAutoRead(false) was called in the meantime
+                removeReadOp();
+                return;
+            }
 
+            final int maxMessagesPerRead = config.getMaxMessagesPerRead();
+            final ChannelPipeline pipeline = pipeline();
+            boolean closed = false;
+            Throwable exception = null;
             try {
-                final int maxMessagesPerRead = config.getMaxMessagesPerRead();
-                final ChannelPipeline pipeline = pipeline();
-                boolean closed = false;
-                Throwable exception = null;
                 try {
                     for (;;) {
                         int localRead = doReadMessages(readBuf);
@@ -89,11 +86,12 @@ public void read() {
                 } catch (Throwable t) {
                     exception = t;
                 }
-
+                setReadPending(false);
                 int size = readBuf.size();
                 for (int i = 0; i < size; i ++) {
                     pipeline.fireChannelRead(readBuf.get(i));
                 }
+
                 readBuf.clear();
                 pipeline.fireChannelReadComplete();
 
@@ -113,7 +111,13 @@ public void read() {
                     }
                 }
             } finally {
-                if (!config().isAutoRead()) {
+                // Check if there is a readPending which was not processed yet.
+                // This could be for two reasons:
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
+                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
+                //
+                // See https://github.com/netty/netty/issues/2254
+                if (!config.isAutoRead() && !isReadPending()) {
                     removeReadOp();
                 }
             }
diff --git a/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
index 45a4977b3a12..ad64cd5f3ae7 100644
--- a/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
@@ -20,7 +20,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.EventLoopException;
 import io.netty.channel.SingleThreadEventLoop;
-import io.netty.channel.nio.AbstractNioChannel.NioUnsafe;
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -38,8 +38,8 @@
 import java.util.Iterator;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
@@ -67,7 +67,7 @@ public final class NioEventLoop extends SingleThreadEventLoop {
     static {
         String key = "sun.nio.ch.bugLevel";
         try {
-            String buglevel = System.getProperty(key);
+            String buglevel = SystemPropertyUtil.get(key);
             if (buglevel == null) {
                 System.setProperty(key, "");
             }
@@ -105,14 +105,13 @@ public final class NioEventLoop extends SingleThreadEventLoop {
      * waken up.
      */
     private final AtomicBoolean wakenUp = new AtomicBoolean();
-    private boolean oldWakenUp;
 
     private volatile int ioRatio = 50;
     private int cancelledKeys;
     private boolean needsToSelectAgain;
 
-    NioEventLoop(NioEventLoopGroup parent, ThreadFactory threadFactory, SelectorProvider selectorProvider) {
-        super(parent, threadFactory, false);
+    NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider) {
+        super(parent, executor, false);
         if (selectorProvider == null) {
             throw new NullPointerException("selectorProvider");
         }
@@ -136,7 +135,7 @@ private Selector openSelector() {
             SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();
 
             Class<?> selectorImplClass =
-                    Class.forName("sun.nio.ch.SelectorImpl", false, ClassLoader.getSystemClassLoader());
+                    Class.forName("sun.nio.ch.SelectorImpl", false, PlatformDependent.getSystemClassLoader());
 
             // Ensure the current selector implementation is what we can instrument.
             if (!selectorImplClass.isAssignableFrom(selector.getClass())) {
@@ -165,7 +164,7 @@ private Selector openSelector() {
     @Override
     protected Queue<Runnable> newTaskQueue() {
         // This event loop never calls takeTask()
-        return new ConcurrentLinkedQueue<Runnable>();
+        return PlatformDependent.newMpscQueue();
     }
 
     /**
@@ -259,7 +258,11 @@ public void run() {
 
                         int interestOps = key.interestOps();
                         key.cancel();
-                        key.channel().register(newSelector, interestOps, a);
+                        SelectionKey newKey = key.channel().register(newSelector, interestOps, a);
+                        if (a instanceof AbstractNioChannel) {
+                            // Update SelectionKey
+                            ((AbstractNioChannel) a).selectionKey = newKey;
+                        }
                         nChannels ++;
                     } catch (Exception e) {
                         logger.warn("Failed to re-register a Channel to the new Selector.", e);
@@ -298,12 +301,12 @@ public void run() {
     @Override
     protected void run() {
         for (;;) {
-            oldWakenUp = wakenUp.getAndSet(false);
+            boolean oldWakenUp = wakenUp.getAndSet(false);
             try {
                 if (hasTasks()) {
                     selectNow();
                 } else {
-                    select();
+                    select(oldWakenUp);
 
                     // 'wakenUp.compareAndSet(false, true)' is always evaluated
                     // before calling 'selector.wakeup()' to reduce the wake-up
@@ -454,6 +457,9 @@ private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
             if (k == null) {
                 break;
             }
+            // null out entry in the array to allow to have it GC'ed once the Channel close
+            // See https://github.com/netty/netty/issues/2363
+            selectedKeys[i] = null;
 
             final Object a = k.attachment();
 
@@ -466,6 +472,16 @@ private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
             }
 
             if (needsToSelectAgain) {
+                // null out entries in the array to allow to have it GC'ed once the Channel close
+                // See https://github.com/netty/netty/issues/2363
+                for (;;) {
+                    if (selectedKeys[i] == null) {
+                        break;
+                    }
+                    selectedKeys[i] = null;
+                    i++;
+                }
+
                 selectAgain();
                 // Need to flip the optimized selectedKeys to get the right reference to the array
                 // and reset the index to -1 which will then set to 0 on the for loop
@@ -479,7 +495,7 @@ private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
     }
 
     private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
-        final NioUnsafe unsafe = ch.unsafe();
+        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
         if (!k.isValid()) {
             // close the channel if the key is not valid anymore
             unsafe.close(unsafe.voidPromise());
@@ -510,7 +526,7 @@ private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
 
                 unsafe.finishConnect();
             }
-        } catch (CancelledKeyException e) {
+        } catch (CancelledKeyException ignored) {
             unsafe.close(unsafe.voidPromise());
         }
     }
@@ -586,7 +602,7 @@ void selectNow() throws IOException {
         }
     }
 
-    private void select() throws IOException {
+    private void select(boolean oldWakenUp) throws IOException {
         Selector selector = this.selector;
         try {
             int selectCnt = 0;
@@ -605,14 +621,33 @@ private void select() throws IOException {
                 int selectedKeys = selector.select(timeoutMillis);
                 selectCnt ++;
 
-                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks()) {
-                    // Selected something,
-                    // waken up by user, or
-                    // the task queue has a pending task.
+                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {
+                    // - Selected something,
+                    // - waken up by user, or
+                    // - the task queue has a pending task.
+                    // - a scheduled task is ready for processing
+                    break;
+                }
+                if (Thread.interrupted()) {
+                    // Thread was interrupted so reset selected keys and break so we not run into a busy loop.
+                    // As this is most likely a bug in the handler of the user or it's client library we will
+                    // also log it.
+                    //
+                    // See https://github.com/netty/netty/issues/2426
+                    if (logger.isDebugEnabled()) {
+                        logger.debug("Selector.select() returned prematurely because " +
+                                "Thread.currentThread().interrupt() was called. Use " +
+                                "NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.");
+                    }
+                    selectCnt = 1;
                     break;
                 }
 
-                if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&
+                long time = System.nanoTime();
+                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {
+                    // timeoutMillis elapsed without anything selected.
+                    selectCnt = 1;
+                } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&
                         selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {
                     // The selector returned prematurely many times in a row.
                     // Rebuild the selector to work around the problem.
@@ -629,7 +664,7 @@ private void select() throws IOException {
                     break;
                 }
 
-                currentTimeNanos = System.nanoTime();
+                currentTimeNanos = time;
             }
 
             if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS) {
diff --git a/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java b/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
index 96eb461eff51..584307816fb1 100644
--- a/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
@@ -16,11 +16,13 @@
 package io.netty.channel.nio;
 
 import io.netty.channel.Channel;
+import io.netty.channel.EventLoop;
 import io.netty.channel.MultithreadEventLoopGroup;
 import io.netty.util.concurrent.EventExecutor;
 
 import java.nio.channels.Selector;
 import java.nio.channels.spi.SelectorProvider;
+import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 
 /**
@@ -41,7 +43,7 @@ public NioEventLoopGroup() {
      * {@link SelectorProvider} which is returned by {@link SelectorProvider#provider()}.
      */
     public NioEventLoopGroup(int nThreads) {
-        this(nThreads, null);
+        this(nThreads, (Executor) null);
     }
 
     /**
@@ -52,6 +54,10 @@ public NioEventLoopGroup(int nThreads, ThreadFactory threadFactory) {
         this(nThreads, threadFactory, SelectorProvider.provider());
     }
 
+    public NioEventLoopGroup(int nThreads, Executor executor) {
+        this(nThreads, executor, SelectorProvider.provider());
+    }
+
     /**
      * Create a new instance using the specified number of threads, the given {@link ThreadFactory} and the given
      * {@link SelectorProvider}.
@@ -61,6 +67,11 @@ public NioEventLoopGroup(
         super(nThreads, threadFactory, selectorProvider);
     }
 
+    public NioEventLoopGroup(
+            int nThreads, Executor executor, final SelectorProvider selectorProvider) {
+        super(nThreads, executor, selectorProvider);
+    }
+
     /**
      * Sets the percentage of the desired amount of time spent for I/O in the child event loops.  The default value is
      * {@code 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.
@@ -82,8 +93,7 @@ public void rebuildSelectors() {
     }
 
     @Override
-    protected EventExecutor newChild(
-            ThreadFactory threadFactory, Object... args) throws Exception {
-        return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0]);
+    protected EventLoop newChild(Executor executor, Object... args) throws Exception {
+        return new NioEventLoop(this, executor, (SelectorProvider) args[0]);
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
index c459a5aa3ee5..4215ad2771a1 100644
--- a/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
@@ -17,11 +17,13 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelOutboundBuffer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.FileRegion;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.socket.ChannelInputShutdownEvent;
 import io.netty.util.internal.StringUtil;
 
@@ -31,6 +33,7 @@
  * Abstract base class for OIO which reads and writes bytes from/to a Socket
  */
 public abstract class AbstractOioByteChannel extends AbstractOioChannel {
+    private RecvByteBufAllocator.Handle allocHandle;
 
     private volatile boolean inputShutdown;
     private static final ChannelMetadata METADATA = new ChannelMetadata(false);
@@ -72,17 +75,25 @@ protected void doRead() {
         if (checkInputShutdown()) {
             return;
         }
-
+        final ChannelConfig config = config();
         final ChannelPipeline pipeline = pipeline();
 
-        // TODO: calculate size as in 3.x
-        ByteBuf byteBuf = alloc().buffer();
+        RecvByteBufAllocator.Handle allocHandle = this.allocHandle;
+        if (allocHandle == null) {
+            this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();
+        }
+
+        ByteBuf byteBuf = allocHandle.allocate(alloc());
+
         boolean closed = false;
         boolean read = false;
         Throwable exception = null;
+        int localReadAmount = 0;
         try {
+            int totalReadAmount = 0;
+
             for (;;) {
-                int localReadAmount = doReadBytes(byteBuf);
+                localReadAmount = doReadBytes(byteBuf);
                 if (localReadAmount > 0) {
                     read = true;
                 } else if (localReadAmount < 0) {
@@ -112,12 +123,23 @@ protected void doRead() {
                         }
                     }
                 }
-                if (!config().isAutoRead()) {
+
+                if (totalReadAmount >= Integer.MAX_VALUE - localReadAmount) {
+                    // Avoid overflow.
+                    totalReadAmount = Integer.MAX_VALUE;
+                    break;
+                }
+
+                totalReadAmount += localReadAmount;
+
+                if (!config.isAutoRead()) {
                     // stop reading until next Channel.read() call
                     // See https://github.com/netty/netty/issues/1363
                     break;
                 }
             }
+            allocHandle.record(totalReadAmount);
+
         } catch (Throwable t) {
             exception = t;
         } finally {
@@ -149,6 +171,15 @@ protected void doRead() {
                     }
                 }
             }
+            if (localReadAmount == 0 && isActive()) {
+                // If the read amount was 0 and the channel is still active we need to trigger a new read()
+                // as otherwise we will never try to read again and the user will never know.
+                // Just call read() is ok here as it will be submitted to the EventLoop as a task and so we are
+                // able to process the rest of the tasks in the queue first.
+                //
+                // See https://github.com/netty/netty/issues/2404
+                read();
+            }
         }
     }
 
diff --git a/transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java b/transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java
index eff7651cffed..bd163b279981 100644
--- a/transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java
@@ -31,12 +31,17 @@ public abstract class AbstractOioChannel extends AbstractChannel {
 
     protected static final int SO_TIMEOUT = 1000;
 
-    private boolean readInProgress;
+    private volatile boolean readPending;
 
     private final Runnable readTask = new Runnable() {
         @Override
         public void run() {
-            readInProgress = false;
+            if (!isReadPending() && !config().isAutoRead()) {
+                // ChannelConfig.setAutoRead(false) was called in the meantime so just return
+                return;
+            }
+
+            setReadPending(false);
             doRead();
         }
     };
@@ -94,13 +99,21 @@ protected abstract void doConnect(
 
     @Override
     protected void doBeginRead() throws Exception {
-        if (readInProgress) {
+        if (isReadPending()) {
             return;
         }
 
-        readInProgress = true;
+        setReadPending(true);
         eventLoop().execute(readTask);
     }
 
     protected abstract void doRead();
+
+    protected boolean isReadPending() {
+        return readPending;
+    }
+
+    protected void setReadPending(boolean readPending) {
+        this.readPending = readPending;
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java b/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java
index f981698268a3..3e7033da8fd4 100644
--- a/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java
@@ -36,15 +36,16 @@ protected AbstractOioMessageChannel(Channel parent) {
 
     @Override
     protected void doRead() {
+        final ChannelConfig config = config();
         final ChannelPipeline pipeline = pipeline();
         boolean closed = false;
-        final ChannelConfig config = config();
         final int maxMessagesPerRead = config.getMaxMessagesPerRead();
 
         Throwable exception = null;
+        int localRead = 0;
         try {
             for (;;) {
-                int localRead = doReadMessages(readBuf);
+                localRead = doReadMessages(readBuf);
                 if (localRead == 0) {
                     break;
                 }
@@ -80,6 +81,14 @@ protected void doRead() {
             if (isOpen()) {
                 unsafe().close(unsafe().voidPromise());
             }
+        } else if (localRead == 0 && isActive()) {
+            // If the read amount was 0 and the channel is still active we need to trigger a new read()
+            // as otherwise we will never try to read again and the user will never know.
+            // Just call read() is ok here as it will be submitted to the EventLoop as a task and so we are
+            // able to process the rest of the tasks in the queue first.
+            //
+            // See https://github.com/netty/netty/issues/2404
+            read();
         }
     }
 
diff --git a/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java b/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java
index 97f9c8171ee4..4ddc1646712f 100644
--- a/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java
@@ -88,18 +88,14 @@ public boolean isActive() {
         }
 
         OutputStream os = this.os;
-        if (os == null || os == CLOSED_OUT) {
-            return false;
-        }
-
-        return true;
+        return !(os == null || os == CLOSED_OUT);
     }
 
     @Override
     protected int available() {
         try {
             return is.available();
-        } catch (IOException e) {
+        } catch (IOException ignored) {
             return 0;
         }
     }
diff --git a/transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java b/transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java
index cc0a9f320361..e803f8b325e3 100644
--- a/transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java
@@ -23,6 +23,7 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.ThreadPerChannelEventLoopGroup;
 
+import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
 
@@ -52,6 +53,21 @@ public OioEventLoopGroup(int maxChannels) {
         this(maxChannels, Executors.defaultThreadFactory());
     }
 
+    /**
+     * Create a new {@link OioEventLoopGroup}.
+     *
+     * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
+     *                          a new {@link Channel} and the maximum is exceed it will throw an
+     *                          {@link ChannelException} on the {@link #register(Channel)} and
+     *                          {@link #register(Channel, ChannelPromise)} method.
+     *                          Use {@code 0} to use no limit
+     * @param executor     the {@link Executor} used to create new {@link Thread} instances that handle the
+     *                          registered {@link Channel}s
+     */
+    public OioEventLoopGroup(int maxChannels, Executor executor) {
+        super(maxChannels, executor);
+    }
+
     /**
      * Create a new {@link OioEventLoopGroup}.
      *
diff --git a/transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java b/transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java
index 40ed4140b594..c63090976ee0 100644
--- a/transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java
+++ b/transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java
@@ -29,6 +29,7 @@ public final class ChannelInputShutdownEvent {
     /**
      * Instance to use
      */
+    @SuppressWarnings("InstantiationOfUtilityClass")
     public static final ChannelInputShutdownEvent INSTANCE = new ChannelInputShutdownEvent();
 
     private ChannelInputShutdownEvent() { }
diff --git a/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java b/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java
index e1239dde3d0f..475285199a7f 100644
--- a/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java
+++ b/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java
@@ -63,4 +63,16 @@ public DatagramPacket retain(int increment) {
         super.retain(increment);
         return this;
     }
+
+    @Override
+    public DatagramPacket touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public DatagramPacket touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
index 751ad6ec4847..c7fd9b8264e4 100644
--- a/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
@@ -61,6 +61,7 @@ public DefaultDatagramChannelConfig(DatagramChannel channel, DatagramSocket java
     }
 
     @Override
+    @SuppressWarnings("deprecation")
     public Map<ChannelOption<?>, Object> getOptions() {
         return getOptions(
                 super.getOptions(),
@@ -68,8 +69,8 @@ public Map<ChannelOption<?>, Object> getOptions() {
                 IP_MULTICAST_ADDR, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_TOS, DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
+    @SuppressWarnings({ "unchecked", "deprecation" })
     public <T> T getOption(ChannelOption<T> option) {
         if (option == SO_BROADCAST) {
             return (T) Boolean.valueOf(isBroadcast());
@@ -87,12 +88,10 @@ public <T> T getOption(ChannelOption<T> option) {
             return (T) Boolean.valueOf(isLoopbackModeDisabled());
         }
         if (option == IP_MULTICAST_ADDR) {
-            T i = (T) getInterface();
-            return i;
+            return (T) getInterface();
         }
         if (option == IP_MULTICAST_IF) {
-            T i = (T) getNetworkInterface();
-            return i;
+            return (T) getNetworkInterface();
         }
         if (option == IP_MULTICAST_TTL) {
             return (T) Integer.valueOf(getTimeToLive());
@@ -107,6 +106,7 @@ public <T> T getOption(ChannelOption<T> option) {
     }
 
     @Override
+    @SuppressWarnings("deprecation")
     public <T> boolean setOption(ChannelOption<T> option, T value) {
         validate(option, value);
 
@@ -143,6 +143,7 @@ private void setActiveOnOpen(boolean activeOnOpen) {
         }
         this.activeOnOpen = activeOnOpen;
     }
+
     @Override
     public boolean isBroadcast() {
         try {
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
index c2619aba8897..93f772197653 100644
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
@@ -16,7 +16,6 @@
 package io.netty.channel.socket.nio;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufHolder;
 import io.netty.channel.AddressedEnvelope;
 import io.netty.channel.Channel;
@@ -26,7 +25,6 @@
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelOutboundBuffer;
 import io.netty.channel.ChannelPromise;
-import io.netty.channel.DefaultAddressedEnvelope;
 import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.nio.AbstractNioMessageChannel;
 import io.netty.channel.socket.DatagramChannelConfig;
@@ -45,6 +43,7 @@
 import java.nio.channels.DatagramChannel;
 import java.nio.channels.MembershipKey;
 import java.nio.channels.SelectionKey;
+import java.nio.channels.spi.SelectorProvider;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -62,30 +61,36 @@ public final class NioDatagramChannel
         extends AbstractNioMessageChannel implements io.netty.channel.socket.DatagramChannel {
 
     private static final ChannelMetadata METADATA = new ChannelMetadata(true);
+    private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();
 
     private final DatagramChannelConfig config;
-    private final Map<InetAddress, List<MembershipKey>> memberships =
-            new HashMap<InetAddress, List<MembershipKey>>();
 
+    private Map<InetAddress, List<MembershipKey>> memberships;
     private RecvByteBufAllocator.Handle allocHandle;
 
-    private static DatagramChannel newSocket() {
+    private static DatagramChannel newSocket(SelectorProvider provider) {
         try {
-            return DatagramChannel.open();
+            /**
+             *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in
+             *  {@link SelectorProvider#provider()} which is called by each DatagramChannel.open() otherwise.
+             *
+             *  See <a href="See https://github.com/netty/netty/issues/2308">#2308</a>.
+             */
+            return provider.openDatagramChannel();
         } catch (IOException e) {
             throw new ChannelException("Failed to open a socket.", e);
         }
     }
 
-    private static DatagramChannel newSocket(InternetProtocolFamily ipFamily) {
+    private static DatagramChannel newSocket(SelectorProvider provider, InternetProtocolFamily ipFamily) {
         if (ipFamily == null) {
-            return newSocket();
+            return newSocket(provider);
         }
 
         checkJavaVersion();
 
         try {
-            return DatagramChannel.open(ProtocolFamilyConverter.convert(ipFamily));
+            return provider.openDatagramChannel(ProtocolFamilyConverter.convert(ipFamily));
         } catch (IOException e) {
             throw new ChannelException("Failed to open a socket.", e);
         }
@@ -101,7 +106,15 @@ private static void checkJavaVersion() {
      * Create a new instance which will use the Operation Systems default {@link InternetProtocolFamily}.
      */
     public NioDatagramChannel() {
-        this(newSocket());
+        this(newSocket(DEFAULT_SELECTOR_PROVIDER));
+    }
+
+    /**
+     * Create a new instance using the given {@link SelectorProvider}
+     * which will use the Operation Systems default {@link InternetProtocolFamily}.
+     */
+    public NioDatagramChannel(SelectorProvider provider) {
+        this(newSocket(provider));
     }
 
     /**
@@ -109,7 +122,16 @@ public NioDatagramChannel() {
      * on the Operation Systems default which will be chosen.
      */
     public NioDatagramChannel(InternetProtocolFamily ipFamily) {
-        this(newSocket(ipFamily));
+        this(newSocket(DEFAULT_SELECTOR_PROVIDER, ipFamily));
+    }
+
+    /**
+     * Create a new instance using the given {@link SelectorProvider} and {@link InternetProtocolFamily}.
+     * If {@link InternetProtocolFamily} is {@code null} it will depend on the Operation Systems default
+     * which will be chosen.
+     */
+    public NioDatagramChannel(SelectorProvider provider, InternetProtocolFamily ipFamily) {
+        this(newSocket(provider, ipFamily));
     }
 
     /**
@@ -131,10 +153,11 @@ public DatagramChannelConfig config() {
     }
 
     @Override
+    @SuppressWarnings("deprecation")
     public boolean isActive() {
         DatagramChannel ch = javaChannel();
         return ch.isOpen() && (
-                (config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered())
+                config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered()
                 || ch.socket().isBound());
     }
 
@@ -260,20 +283,7 @@ protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Ex
             return true;
         }
 
-        ByteBufAllocator alloc = alloc();
-        boolean needsCopy = data.nioBufferCount() != 1;
-        if (!needsCopy) {
-            if (!data.isDirect() && alloc.isDirectBufferPooled()) {
-                needsCopy = true;
-            }
-        }
-        ByteBuffer nioData;
-        if (!needsCopy) {
-            nioData = data.nioBuffer();
-        } else {
-            data = alloc.directBuffer(dataLen).writeBytes(data);
-            nioData = data.nioBuffer();
-        }
+        ByteBuffer  nioData = data.nioBuffer();
 
         final int writtenBytes;
         if (remoteAddress != null) {
@@ -282,24 +292,7 @@ protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Ex
             writtenBytes = javaChannel().write(nioData);
         }
 
-        boolean done =  writtenBytes > 0;
-        if (needsCopy) {
-            // This means we have allocated a new buffer and need to store it back so we not need to allocate it again
-            // later
-            if (remoteAddress == null) {
-                // remoteAddress is null which means we can handle it as ByteBuf directly
-                in.current(data);
-            } else {
-                if (!done) {
-                    // store it back with all the needed informations
-                    in.current(new DefaultAddressedEnvelope<ByteBuf, SocketAddress>(data, remoteAddress));
-                } else {
-                    // Just store back the new create buffer so it is cleaned up once in.remove() is called.
-                    in.current(data);
-                }
-            }
-        }
-        return done;
+        return writtenBytes > 0;
     }
 
     @Override
@@ -373,7 +366,12 @@ public ChannelFuture joinGroup(
             }
 
             synchronized (this) {
-                List<MembershipKey> keys = memberships.get(multicastAddress);
+                List<MembershipKey> keys = null;
+                if (memberships == null) {
+                    memberships = new HashMap<InetAddress, List<MembershipKey>>();
+                } else {
+                    keys = memberships.get(multicastAddress);
+                }
                 if (keys == null) {
                     keys = new ArrayList<MembershipKey>();
                     memberships.put(multicastAddress, keys);
@@ -537,4 +535,14 @@ public ChannelFuture block(
         }
         return promise;
     }
+
+    @Override
+    protected ChannelOutboundBuffer newOutboundBuffer() {
+        return NioDatagramChannelOutboundBuffer.newInstance(this);
+    }
+
+    @Override
+    protected void setReadPending(boolean readPending) {
+        super.setReadPending(readPending);
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
index 349dcbf2358a..c85c96240274 100644
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
@@ -40,7 +40,7 @@ class NioDatagramChannelConfig extends DefaultDatagramChannelConfig {
     private static final Method SET_OPTION;
 
     static {
-        ClassLoader classLoader = DatagramChannel.class.getClassLoader();
+        ClassLoader classLoader = PlatformDependent.getClassLoader(DatagramChannel.class);
         Class<?> socketOptionType = null;
         try {
             socketOptionType = Class.forName("java.net.SocketOption", true, classLoader);
@@ -161,6 +161,17 @@ public DatagramChannelConfig setLoopbackModeDisabled(boolean loopbackModeDisable
         return this;
     }
 
+    @Override
+    public DatagramChannelConfig setAutoRead(boolean autoRead) {
+        super.setAutoRead(autoRead);
+        return this;
+    }
+
+    @Override
+    protected void autoReadCleared() {
+        ((NioDatagramChannel) channel).setReadPending(false);
+    }
+
     private Object getOption0(Object option) {
         if (PlatformDependent.javaVersion() < 7) {
             throw new UnsupportedOperationException();
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelOutboundBuffer.java b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelOutboundBuffer.java
new file mode 100644
index 000000000000..b3bd3b676d52
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelOutboundBuffer.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.socket.nio;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.util.Recycler;
+
+/**
+ * Special {@link ChannelOutboundBuffer} for {@link NioDatagramChannel} implementations.
+ */
+final class NioDatagramChannelOutboundBuffer extends ChannelOutboundBuffer {
+    private static final Recycler<NioDatagramChannelOutboundBuffer> RECYCLER =
+            new Recycler<NioDatagramChannelOutboundBuffer>() {
+                @Override
+                protected NioDatagramChannelOutboundBuffer newObject(Handle<NioDatagramChannelOutboundBuffer> handle) {
+                    return new NioDatagramChannelOutboundBuffer(handle);
+                }
+            };
+
+    /**
+     * Get a new instance of this {@link NioSocketChannelOutboundBuffer} and attach it the given
+     * {@link .NioDatagramChannel}.
+     */
+    static NioDatagramChannelOutboundBuffer newInstance(NioDatagramChannel channel) {
+        NioDatagramChannelOutboundBuffer buffer = RECYCLER.get();
+        buffer.channel = channel;
+        return buffer;
+    }
+
+    private NioDatagramChannelOutboundBuffer(Recycler.Handle<NioDatagramChannelOutboundBuffer> handle) {
+        super(handle);
+    }
+
+    /**
+     * Convert all non direct {@link ByteBuf} to direct {@link ByteBuf}'s. This is done as the JDK implementation
+     * will do the conversation itself and we can do a better job here.
+     */
+    @Override
+    protected Object beforeAdd(Object msg) {
+        if (msg instanceof DatagramPacket) {
+            DatagramPacket packet = (DatagramPacket) msg;
+            ByteBuf content = packet.content();
+            if (!content.isDirect() || content.nioBufferCount() != 1) {
+                ByteBuf direct = copyToDirectByteBuf(content);
+                return new DatagramPacket(direct, packet.recipient(), packet.sender());
+            }
+        }
+        return msg;
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
index e294f52b5d4c..c0dc36bc76bb 100644
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
@@ -26,10 +26,12 @@
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
+import java.net.ServerSocket;
 import java.net.SocketAddress;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
+import java.nio.channels.spi.SelectorProvider;
 import java.util.List;
 
 /**
@@ -40,12 +42,19 @@ public class NioServerSocketChannel extends AbstractNioMessageChannel
                              implements io.netty.channel.socket.ServerSocketChannel {
 
     private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+    private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioServerSocketChannel.class);
 
-    private static ServerSocketChannel newSocket() {
+    private static ServerSocketChannel newSocket(SelectorProvider provider) {
         try {
-            return ServerSocketChannel.open();
+            /**
+             *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in
+             *  {@link SelectorProvider#provider()} which is called by each ServerSocketChannel.open() otherwise.
+             *
+             *  See <a href="See https://github.com/netty/netty/issues/2308">#2308</a>.
+             */
+            return provider.openServerSocketChannel();
         } catch (IOException e) {
             throw new ChannelException(
                     "Failed to open a server socket.", e);
@@ -58,8 +67,22 @@ private static ServerSocketChannel newSocket() {
      * Create a new instance
      */
     public NioServerSocketChannel() {
-        super(null, newSocket(), SelectionKey.OP_ACCEPT);
-        config = new DefaultServerSocketChannelConfig(this, javaChannel().socket());
+        this(newSocket(DEFAULT_SELECTOR_PROVIDER));
+    }
+
+    /**
+     * Create a new instance using the given {@link SelectorProvider}.
+     */
+    public NioServerSocketChannel(SelectorProvider provider) {
+        this(newSocket(provider));
+    }
+
+    /**
+     * Create a new instance using the given {@link ServerSocketChannel}.
+     */
+    public NioServerSocketChannel(ServerSocketChannel channel) {
+        super(null, channel, SelectionKey.OP_ACCEPT);
+        config = new NioServerSocketChannelConfig(this, javaChannel().socket());
     }
 
     @Override
@@ -155,4 +178,15 @@ protected void doDisconnect() throws Exception {
     protected boolean doWriteMessage(Object msg, ChannelOutboundBuffer in) throws Exception {
         throw new UnsupportedOperationException();
     }
+
+    private final class NioServerSocketChannelConfig  extends DefaultServerSocketChannelConfig {
+        private NioServerSocketChannelConfig(NioServerSocketChannel channel, ServerSocket javaSocket) {
+            super(channel, javaSocket);
+        }
+
+        @Override
+        protected void autoReadCleared() {
+            setReadPending(false);
+        }
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
index 665ce2945c9d..f5d547081efc 100644
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
@@ -28,13 +28,16 @@
 import io.netty.channel.socket.DefaultSocketChannelConfig;
 import io.netty.channel.socket.ServerSocketChannel;
 import io.netty.channel.socket.SocketChannelConfig;
+import io.netty.util.internal.OneTimeTask;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
+import java.net.Socket;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.SocketChannel;
+import java.nio.channels.spi.SelectorProvider;
 
 /**
  * {@link io.netty.channel.socket.SocketChannel} which uses NIO selector based implementation.
@@ -42,10 +45,17 @@
 public class NioSocketChannel extends AbstractNioByteChannel implements io.netty.channel.socket.SocketChannel {
 
     private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+    private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();
 
-    private static SocketChannel newSocket() {
+    private static SocketChannel newSocket(SelectorProvider provider) {
         try {
-            return SocketChannel.open();
+            /**
+             *  Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in
+             *  {@link SelectorProvider#provider()} which is called by each SocketChannel.open() otherwise.
+             *
+             *  See <a href="See https://github.com/netty/netty/issues/2308">#2308</a>.
+             */
+            return provider.openSocketChannel();
         } catch (IOException e) {
             throw new ChannelException("Failed to open a socket.", e);
         }
@@ -57,7 +67,14 @@ private static SocketChannel newSocket() {
      * Create a new instance
      */
     public NioSocketChannel() {
-        this(newSocket());
+        this(DEFAULT_SELECTOR_PROVIDER);
+    }
+
+    /**
+     * Create a new instance using the given {@link SelectorProvider}.
+     */
+    public NioSocketChannel(SelectorProvider provider) {
+        this(newSocket(provider));
     }
 
     /**
@@ -75,7 +92,7 @@ public NioSocketChannel(SocketChannel socket) {
      */
     public NioSocketChannel(Channel parent, SocketChannel socket) {
         super(parent, socket);
-        config = new DefaultSocketChannelConfig(this, socket.socket());
+        config = new NioSocketChannelConfig(this, socket.socket());
     }
 
     @Override
@@ -140,7 +157,7 @@ public ChannelFuture shutdownOutput(final ChannelPromise promise) {
                 promise.setFailure(t);
             }
         } else {
-            loop.execute(new Runnable() {
+            loop.execute(new OneTimeTask() {
                 @Override
                 public void run() {
                     shutdownOutput(promise);
@@ -211,15 +228,13 @@ protected int doReadBytes(ByteBuf byteBuf) throws Exception {
     @Override
     protected int doWriteBytes(ByteBuf buf) throws Exception {
         final int expectedWrittenBytes = buf.readableBytes();
-        final int writtenBytes = buf.readBytes(javaChannel(), expectedWrittenBytes);
-        return writtenBytes;
+        return buf.readBytes(javaChannel(), expectedWrittenBytes);
     }
 
     @Override
     protected long doWriteFileRegion(FileRegion region) throws Exception {
         final long position = region.transfered();
-        final long writtenBytes = region.transferTo(javaChannel(), position);
-        return writtenBytes;
+        return region.transferTo(javaChannel(), position);
     }
 
     @Override
@@ -231,16 +246,16 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
                 super.doWrite(in);
                 return;
             }
-
+            NioSocketChannelOutboundBuffer nioIn = (NioSocketChannelOutboundBuffer) in;
             // Ensure the pending writes are made of ByteBufs only.
-            ByteBuffer[] nioBuffers = in.nioBuffers();
+            ByteBuffer[] nioBuffers = nioIn.nioBuffers();
             if (nioBuffers == null) {
                 super.doWrite(in);
                 return;
             }
 
-            int nioBufferCnt = in.nioBufferCount();
-            long expectedWrittenBytes = in.nioBufferSize();
+            int nioBufferCnt = nioIn.nioBufferCount();
+            long expectedWrittenBytes = nioIn.nioBufferSize();
 
             final SocketChannel ch = javaChannel();
             long writtenBytes = 0;
@@ -263,7 +278,7 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
             if (done) {
                 // Release all buffers
                 for (int i = msgCount; i > 0; i --) {
-                    in.remove();
+                    nioIn.remove();
                 }
 
                 // Finish the write loop if no new messages were flushed by in.remove().
@@ -281,16 +296,16 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
                     final int readableBytes = buf.writerIndex() - readerIndex;
 
                     if (readableBytes < writtenBytes) {
-                        in.progress(readableBytes);
-                        in.remove();
+                        nioIn.progress(readableBytes);
+                        nioIn.remove();
                         writtenBytes -= readableBytes;
                     } else if (readableBytes > writtenBytes) {
                         buf.readerIndex(readerIndex + (int) writtenBytes);
-                        in.progress(writtenBytes);
+                        nioIn.progress(writtenBytes);
                         break;
                     } else { // readableBytes == writtenBytes
-                        in.progress(readableBytes);
-                        in.remove();
+                        nioIn.progress(readableBytes);
+                        nioIn.remove();
                         break;
                     }
                 }
@@ -300,4 +315,20 @@ protected void doWrite(ChannelOutboundBuffer in) throws Exception {
             }
         }
     }
+
+    @Override
+    protected ChannelOutboundBuffer newOutboundBuffer() {
+        return NioSocketChannelOutboundBuffer.newInstance(this);
+    }
+
+    private final class NioSocketChannelConfig  extends DefaultSocketChannelConfig {
+        private NioSocketChannelConfig(NioSocketChannel channel, Socket javaSocket) {
+            super(channel, javaSocket);
+        }
+
+        @Override
+        protected void autoReadCleared() {
+            setReadPending(false);
+        }
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannelOutboundBuffer.java b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannelOutboundBuffer.java
new file mode 100644
index 000000000000..31ff82f6c9af
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannelOutboundBuffer.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright 2014 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
+ */
+package io.netty.channel.socket.nio;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.AbstractChannel;
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.util.Recycler;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Special {@link ChannelOutboundBuffer} implementation which allows to also access flushed {@link ByteBuffer} to
+ * allow efficent gathering writes.
+ */
+public final class NioSocketChannelOutboundBuffer extends ChannelOutboundBuffer {
+
+    private ByteBuffer[] nioBuffers;
+    private int nioBufferCount;
+    private long nioBufferSize;
+
+    private static final Recycler<NioSocketChannelOutboundBuffer> RECYCLER =
+            new Recycler<NioSocketChannelOutboundBuffer>() {
+        @Override
+        protected NioSocketChannelOutboundBuffer newObject(Handle<NioSocketChannelOutboundBuffer> handle) {
+            return new NioSocketChannelOutboundBuffer(handle);
+        }
+    };
+
+    /**
+     * Get a new instance of this {@link NioSocketChannelOutboundBuffer} and attach it the given {@link AbstractChannel}
+     */
+    public static NioSocketChannelOutboundBuffer newInstance(AbstractChannel channel) {
+        NioSocketChannelOutboundBuffer buffer = RECYCLER.get();
+        buffer.channel = channel;
+        return buffer;
+    }
+
+    private NioSocketChannelOutboundBuffer(Recycler.Handle<NioSocketChannelOutboundBuffer> handle) {
+        super(handle);
+        nioBuffers = new ByteBuffer[INITIAL_CAPACITY];
+    }
+
+    /**
+     * Convert all non direct {@link ByteBuf} to direct {@link ByteBuf}'s. This is done as the JDK implementation
+     * will do the conversation itself and we can do a better job here.
+     */
+    @Override
+    protected Object beforeAdd(Object msg) {
+        if (msg instanceof ByteBuf) {
+            ByteBuf buf = (ByteBuf) msg;
+            if (!buf.isDirect()) {
+                return copyToDirectByteBuf(buf);
+            }
+        }
+        return msg;
+    }
+
+    /**
+     * Returns an array of direct NIO buffers if the currently pending messages are made of {@link ByteBuf} only.
+     * {@code null} is returned otherwise.  If this method returns a non-null array, {@link #nioBufferCount()} and
+     * {@link #nioBufferSize()} will return the number of NIO buffers in the returned array and the total number
+     * of readable bytes of the NIO buffers respectively.
+     * <p>
+     * Note that the returned array is reused and thus should not escape
+     * {@link io.netty.channel.AbstractChannel#doWrite(ChannelOutboundBuffer)}.
+     * Refer to {@link io.netty.channel.socket.nio.NioSocketChannel#doWrite(ChannelOutboundBuffer)} for an example.
+     * </p>
+     */
+    public ByteBuffer[] nioBuffers() {
+        long nioBufferSize = 0;
+        int nioBufferCount = 0;
+        final Entry[] buffer = entries();
+        final int mask = buffer.length - 1;
+        ByteBuffer[] nioBuffers = this.nioBuffers;
+        Object m;
+        int unflushed = unflushed();
+        int i = flushed();
+        while (i != unflushed && (m = buffer[i].msg()) != null) {
+            if (!(m instanceof ByteBuf)) {
+                this.nioBufferCount = 0;
+                this.nioBufferSize = 0;
+                return null;
+            }
+
+            NioEntry entry = (NioEntry) buffer[i];
+
+            if (!entry.isCancelled()) {
+                ByteBuf buf = (ByteBuf) m;
+                final int readerIndex = buf.readerIndex();
+                final int readableBytes = buf.writerIndex() - readerIndex;
+
+                if (readableBytes > 0) {
+                    nioBufferSize += readableBytes;
+                    int count = entry.count;
+                    if (count == -1) {
+                        //noinspection ConstantValueVariableUse
+                        entry.count = count =  buf.nioBufferCount();
+                    }
+                    int neededSpace = nioBufferCount + count;
+                    if (neededSpace > nioBuffers.length) {
+                        this.nioBuffers = nioBuffers =
+                                expandNioBufferArray(nioBuffers, neededSpace, nioBufferCount);
+                    }
+                    if (count == 1) {
+                        ByteBuffer nioBuf = entry.buf;
+                        if (nioBuf == null) {
+                            // cache ByteBuffer as it may need to create a new ByteBuffer instance if its a
+                            // derived buffer
+                            entry.buf = nioBuf = buf.internalNioBuffer(readerIndex, readableBytes);
+                        }
+                        nioBuffers[nioBufferCount ++] = nioBuf;
+                    } else {
+                        ByteBuffer[] nioBufs = entry.buffers;
+                        if (nioBufs == null) {
+                            // cached ByteBuffers as they may be expensive to create in terms
+                            // of Object allocation
+                            entry.buffers = nioBufs = buf.nioBuffers();
+                        }
+                        nioBufferCount = fillBufferArray(nioBufs, nioBuffers, nioBufferCount);
+                    }
+                }
+            }
+
+            i = i + 1 & mask;
+        }
+        this.nioBufferCount = nioBufferCount;
+        this.nioBufferSize = nioBufferSize;
+
+        return nioBuffers;
+    }
+
+    private static int fillBufferArray(ByteBuffer[] nioBufs, ByteBuffer[] nioBuffers, int nioBufferCount) {
+        for (ByteBuffer nioBuf: nioBufs) {
+            if (nioBuf == null) {
+                break;
+            }
+            nioBuffers[nioBufferCount ++] = nioBuf;
+        }
+        return nioBufferCount;
+    }
+
+    private static ByteBuffer[] expandNioBufferArray(ByteBuffer[] array, int neededSpace, int size) {
+        int newCapacity = array.length;
+        do {
+            // double capacity until it is big enough
+            // See https://github.com/netty/netty/issues/1890
+            newCapacity <<= 1;
+
+            if (newCapacity < 0) {
+                throw new IllegalStateException();
+            }
+
+        } while (neededSpace > newCapacity);
+
+        ByteBuffer[] newArray = new ByteBuffer[newCapacity];
+        System.arraycopy(array, 0, newArray, 0, size);
+
+        return newArray;
+    }
+
+    /**
+     * Return the number of {@link java.nio.ByteBuffer} which can be written.
+     */
+    public int nioBufferCount() {
+        return nioBufferCount;
+    }
+
+    /**
+     * Return the number of bytes that can be written via gathering writes.
+     */
+    public long nioBufferSize() {
+        return nioBufferSize;
+    }
+
+    @Override
+    public void recycle() {
+        // take care of recycle the ByteBuffer[] structure.
+        if (nioBuffers.length > INITIAL_CAPACITY) {
+            nioBuffers = new ByteBuffer[INITIAL_CAPACITY];
+        } else {
+            // null out the nio buffers array so the can be GC'ed
+            // https://github.com/netty/netty/issues/1763
+            Arrays.fill(nioBuffers, null);
+        }
+        super.recycle();
+    }
+
+    @Override
+    protected NioEntry newEntry() {
+        return new NioEntry();
+    }
+
+    protected static final class NioEntry extends Entry {
+        ByteBuffer[] buffers;
+        ByteBuffer buf;
+        int count = -1;
+
+        @Override
+        public void clear() {
+            buffers = null;
+            buf = null;
+            count = -1;
+            super.clear();
+        }
+
+        @Override
+        public int cancel() {
+            buffers = null;
+            buf = null;
+            count = -1;
+            return super.cancel();
+        }
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
index ab2fa06ca770..934fc23f8b9e 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
@@ -35,10 +35,15 @@
 public class DefaultOioServerSocketChannelConfig extends DefaultServerSocketChannelConfig implements
         OioServerSocketChannelConfig {
 
+    @Deprecated
     public DefaultOioServerSocketChannelConfig(ServerSocketChannel channel, ServerSocket javaSocket) {
         super(channel, javaSocket);
     }
 
+    DefaultOioServerSocketChannelConfig(OioServerSocketChannel channel, ServerSocket javaSocket) {
+        super(channel, javaSocket);
+    }
+
     @Override
     public Map<ChannelOption<?>, Object> getOptions() {
         return getOptions(
@@ -145,6 +150,13 @@ public OioServerSocketChannelConfig setAutoRead(boolean autoRead) {
         return this;
     }
 
+    @Override
+    protected void autoReadCleared() {
+        if (channel instanceof OioServerSocketChannel) {
+            ((OioServerSocketChannel) channel).setReadPending(false);
+        }
+    }
+
     @Override
     public OioServerSocketChannelConfig setAutoClose(boolean autoClose) {
         super.setAutoClose(autoClose);
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
index ac9fdf72cf47..b9d8369e461b 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
@@ -33,10 +33,15 @@
  * Default {@link OioSocketChannelConfig} implementation
  */
 public class DefaultOioSocketChannelConfig extends DefaultSocketChannelConfig implements OioSocketChannelConfig {
+    @Deprecated
     public DefaultOioSocketChannelConfig(SocketChannel channel, Socket javaSocket) {
         super(channel, javaSocket);
     }
 
+    DefaultOioSocketChannelConfig(OioSocketChannel channel, Socket javaSocket) {
+        super(channel, javaSocket);
+    }
+
     @Override
     public Map<ChannelOption<?>, Object> getOptions() {
         return getOptions(
@@ -173,6 +178,13 @@ public OioSocketChannelConfig setAutoRead(boolean autoRead) {
         return this;
     }
 
+    @Override
+    protected void autoReadCleared() {
+        if (channel instanceof OioSocketChannel) {
+            ((OioSocketChannel) channel).setReadPending(false);
+        }
+    }
+
     @Override
     public OioSocketChannelConfig setAutoClose(boolean autoClose) {
         super.setAutoClose(autoClose);
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
index 852396d04941..ca873486b20e 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
@@ -125,9 +125,10 @@ public boolean isOpen() {
     }
 
     @Override
+    @SuppressWarnings("deprecation")
     public boolean isActive() {
         return isOpen()
-            && ((config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered())
+            && (config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered()
                  || socket.isBound());
     }
 
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
index 04428df54d38..72ce74c521cf 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
@@ -193,4 +193,9 @@ protected SocketAddress remoteAddress0() {
     protected void doDisconnect() throws Exception {
         throw new UnsupportedOperationException();
     }
+
+    @Override
+    protected void setReadPending(boolean readPending) {
+        super.setReadPending(readPending);
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
index 7ab6e4541ff7..4ad6624546a7 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
@@ -136,7 +136,7 @@ protected int doReadBytes(ByteBuf buf) throws Exception {
         }
         try {
             return super.doReadBytes(buf);
-        } catch (SocketTimeoutException e) {
+        } catch (SocketTimeoutException ignored) {
             return 0;
         }
     }
@@ -232,4 +232,9 @@ protected boolean checkInputShutdown() {
         }
         return false;
     }
+
+    @Override
+    protected void setReadPending(boolean readPending) {
+        super.setReadPending(readPending);
+    }
 }
diff --git a/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
index efcadfb6a1af..f454e71d6b38 100644
--- a/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
+++ b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
@@ -16,25 +16,36 @@
 
 package io.netty.bootstrap;
 
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelInboundHandler;
 import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.DefaultEventLoopGroup;
+import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoopGroup;
+import io.netty.channel.ServerChannel;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
-import io.netty.channel.local.LocalEventLoopGroup;
+import io.netty.channel.local.LocalServerChannel;
 import io.netty.util.concurrent.Future;
+import org.junit.Assert;
 import org.junit.Test;
 
+import java.net.SocketAddress;
+import java.net.SocketException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
 
 public class BootstrapTest {
 
     @Test(timeout = 10000)
     public void testBindDeadLock() throws Exception {
-        EventLoopGroup groupA = new LocalEventLoopGroup(1);
-        EventLoopGroup groupB = new LocalEventLoopGroup(1);
+        EventLoopGroup groupA = new DefaultEventLoopGroup(1);
+        EventLoopGroup groupB = new DefaultEventLoopGroup(1);
 
         try {
             ChannelInboundHandler dummyHandler = new DummyHandler();
@@ -81,8 +92,8 @@ public void run() {
 
     @Test(timeout = 10000)
     public void testConnectDeadLock() throws Exception {
-        EventLoopGroup groupA = new LocalEventLoopGroup(1);
-        EventLoopGroup groupB = new LocalEventLoopGroup(1);
+        EventLoopGroup groupA = new DefaultEventLoopGroup(1);
+        EventLoopGroup groupB = new DefaultEventLoopGroup(1);
 
         try {
             ChannelInboundHandler dummyHandler = new DummyHandler();
@@ -127,6 +138,96 @@ public void run() {
         }
     }
 
+    @Test
+    public void testLateRegisterSuccess() throws Exception {
+        TestEventLoopGroup group = new TestEventLoopGroup();
+        try {
+            ServerBootstrap bootstrap = new ServerBootstrap();
+            bootstrap.group(group);
+            bootstrap.channel(LocalServerChannel.class);
+            bootstrap.childHandler(new DummyHandler());
+            bootstrap.localAddress(new LocalAddress("1"));
+            ChannelFuture future = bootstrap.bind();
+            Assert.assertFalse(future.isDone());
+            group.promise.setSuccess();
+            final BlockingQueue<Boolean> queue = new LinkedBlockingQueue<Boolean>();
+            future.addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    queue.add(future.channel().eventLoop().inEventLoop(Thread.currentThread()));
+                    queue.add(future.isSuccess());
+                }
+            });
+            Assert.assertTrue(queue.take());
+            Assert.assertTrue(queue.take());
+        } finally {
+            group.shutdownGracefully();
+            group.terminationFuture().sync();
+        }
+    }
+
+    @Test
+    public void testLateRegisterSuccessBindFailed() throws Exception {
+        TestEventLoopGroup group = new TestEventLoopGroup();
+        try {
+            ServerBootstrap bootstrap = new ServerBootstrap();
+            bootstrap.group(group);
+            bootstrap.channelFactory(new ChannelFactory<ServerChannel>() {
+                @Override
+                public ServerChannel newChannel() {
+                    return new LocalServerChannel() {
+                        @Override
+                        public ChannelFuture bind(SocketAddress localAddress) {
+                            return newFailedFuture(new SocketException());
+                        }
+
+                        @Override
+                        public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
+                            return promise.setFailure(new SocketException());
+                        }
+                    };
+                }
+            });
+            bootstrap.childHandler(new DummyHandler());
+            bootstrap.localAddress(new LocalAddress("1"));
+            ChannelFuture future = bootstrap.bind();
+            Assert.assertFalse(future.isDone());
+            group.promise.setSuccess();
+            final BlockingQueue<Boolean> queue = new LinkedBlockingQueue<Boolean>();
+            future.addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    queue.add(future.channel().eventLoop().inEventLoop(Thread.currentThread()));
+                    queue.add(future.isSuccess());
+                }
+            });
+            Assert.assertTrue(queue.take());
+            Assert.assertFalse(queue.take());
+        } finally {
+            group.shutdownGracefully();
+            group.terminationFuture().sync();
+        }
+    }
+
+    private static final class TestEventLoopGroup extends DefaultEventLoopGroup {
+        ChannelPromise promise;
+        TestEventLoopGroup() {
+            super(1);
+        }
+
+        @Override
+        public ChannelFuture register(Channel channel) {
+            super.register(channel).syncUninterruptibly();
+            promise = channel.newPromise();
+            return promise;
+        }
+
+        @Override
+        public ChannelFuture register(Channel channel, final ChannelPromise promise) {
+            throw new UnsupportedOperationException();
+        }
+    }
+
     @Sharable
     private static final class DummyHandler extends ChannelInboundHandlerAdapter { }
 }
diff --git a/transport/src/test/java/io/netty/channel/BaseChannelTest.java b/transport/src/test/java/io/netty/channel/BaseChannelTest.java
index 907ed2def489..6c957f96f1d8 100644
--- a/transport/src/test/java/io/netty/channel/BaseChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/BaseChannelTest.java
@@ -16,25 +16,25 @@
 package io.netty.channel;
 
 
-import static org.junit.Assert.assertEquals;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.local.LocalChannel;
-import io.netty.channel.local.LocalEventLoopGroup;
 import io.netty.channel.local.LocalServerChannel;
 
+import static org.junit.Assert.*;
+
 class BaseChannelTest {
 
     private final LoggingHandler loggingHandler;
 
     BaseChannelTest() {
-        this.loggingHandler = new LoggingHandler();
+        loggingHandler = new LoggingHandler();
     }
 
     ServerBootstrap getLocalServerBootstrap() {
-        EventLoopGroup serverGroup = new LocalEventLoopGroup();
+        EventLoopGroup serverGroup = new DefaultEventLoopGroup();
         ServerBootstrap sb = new ServerBootstrap();
         sb.group(serverGroup);
         sb.channel(LocalServerChannel.class);
@@ -48,12 +48,12 @@ public void initChannel(LocalChannel ch) throws Exception {
     }
 
     Bootstrap getLocalClientBootstrap() {
-        EventLoopGroup clientGroup = new LocalEventLoopGroup();
+        EventLoopGroup clientGroup = new DefaultEventLoopGroup();
         Bootstrap cb = new Bootstrap();
         cb.channel(LocalChannel.class);
         cb.group(clientGroup);
 
-        cb.handler(this.loggingHandler);
+        cb.handler(loggingHandler);
 
         return cb;
     }
@@ -65,16 +65,16 @@ static ByteBuf createTestBuf(int len) {
     }
 
     void assertLog(String expected) {
-        String actual = this.loggingHandler.getLog();
+        String actual = loggingHandler.getLog();
         assertEquals(expected, actual);
     }
 
     void clearLog() {
-        this.loggingHandler.clear();
+        loggingHandler.clear();
     }
 
     void setInterest(LoggingHandler.Event... events) {
-        this.loggingHandler.setInterest(events);
+        loggingHandler.setInterest(events);
     }
 
 }
diff --git a/transport/src/test/java/io/netty/channel/DefaultChannelIdTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelIdTest.java
new file mode 100644
index 000000000000..3a2cee35c787
--- /dev/null
+++ b/transport/src/test/java/io/netty/channel/DefaultChannelIdTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import org.junit.Test;
+
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+@SuppressWarnings("DynamicRegexReplaceableByCompiledPattern")
+public class DefaultChannelIdTest {
+    @Test
+    public void testShortText() {
+        String text = DefaultChannelId.newInstance().asShortText();
+        assertTrue(text.matches("^[0-9a-f]{8}$"));
+    }
+
+    @Test
+    public void testLongText() {
+        String text = DefaultChannelId.newInstance().asLongText();
+        assertTrue(text.matches("^[0-9a-f]{16}-[0-9a-f]{4}-[0-9a-f]{8}-[0-9a-f]{16}-[0-9a-f]{8}$"));
+    }
+
+    @Test
+    public void testIdempotentMachineId() {
+        String a = DefaultChannelId.newInstance().asLongText().substring(0, 16);
+        String b = DefaultChannelId.newInstance().asLongText().substring(0, 16);
+        assertThat(a, is(b));
+    }
+
+    @Test
+    public void testIdempotentProcessId() {
+        String a = DefaultChannelId.newInstance().asLongText().substring(17, 21);
+        String b = DefaultChannelId.newInstance().asLongText().substring(17, 21);
+        assertThat(a, is(b));
+    }
+
+    @Test
+    public void testSerialization() throws Exception {
+        ChannelId a = DefaultChannelId.newInstance();
+        ChannelId b;
+
+        ByteBuf buf = Unpooled.buffer();
+        ObjectOutputStream out = new ObjectOutputStream(new ByteBufOutputStream(buf));
+        out.writeObject(a);
+        out.flush();
+
+        ObjectInputStream in = new ObjectInputStream(new ByteBufInputStream(buf));
+        b = (ChannelId) in.readObject();
+
+        assertThat(a, is(b));
+        assertThat(a, is(not(sameInstance(b))));
+        assertThat(a.asLongText(), is(b.asLongText()));
+    }
+}
diff --git a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
index ea22c0a41b16..734fa471b6ae 100644
--- a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
+++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
@@ -18,10 +18,11 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
-import io.netty.channel.local.LocalEventLoopGroup;
 import io.netty.channel.local.LocalServerChannel;
 import io.netty.util.AbstractReferenceCounted;
 import io.netty.util.ReferenceCountUtil;
@@ -43,7 +44,7 @@
 
 public class DefaultChannelPipelineTest {
 
-    private static final EventLoopGroup group = new LocalEventLoopGroup(1);
+    private static final EventLoopGroup group = new DefaultEventLoopGroup(1);
 
     private Channel self;
     private Channel peer;
@@ -106,6 +107,11 @@ public void testFreeCalled() throws Exception {
             protected void deallocate() {
                 free.countDown();
             }
+
+            @Override
+            public ReferenceCounted touch(Object hint) {
+                return this;
+            }
         };
 
         StringInboundHandler handler = new StringInboundHandler();
@@ -145,8 +151,11 @@ public void testRemoveChannelHandler() {
         assertSame(pipeline.get("handler3"), handler3);
 
         pipeline.remove(handler1);
+        assertNull(pipeline.get("handler1"));
         pipeline.remove(handler2);
+        assertNull(pipeline.get("handler2"));
         pipeline.remove(handler3);
+        assertNull(pipeline.get("handler3"));
     }
 
     @Test
@@ -250,7 +259,7 @@ public void testChannelHandlerContextOrder() {
         pipeline.addBefore("1", "0", newHandler());
         pipeline.addAfter("10", "11", newHandler());
 
-        DefaultChannelHandlerContext ctx = (DefaultChannelHandlerContext) pipeline.firstContext();
+        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) pipeline.firstContext();
         assertNotNull(ctx);
         while (ctx != null) {
             int i = toInt(ctx.name());
@@ -431,8 +440,116 @@ public void run() {
         }).sync();
     }
 
-    private static int next(DefaultChannelHandlerContext ctx) {
-        DefaultChannelHandlerContext next = ctx.next;
+    // Tests for https://github.com/netty/netty/issues/2349
+    @Test
+    public void testCancelBind() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        group.register(pipeline.channel());
+
+        ChannelPromise promise = pipeline.channel().newPromise();
+        assertTrue(promise.cancel(false));
+        ChannelFuture future = pipeline.bind(new LocalAddress("test"), promise);
+        assertTrue(future.isCancelled());
+    }
+
+    @Test
+    public void testCancelConnect() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        group.register(pipeline.channel());
+
+        ChannelPromise promise = pipeline.channel().newPromise();
+        assertTrue(promise.cancel(false));
+        ChannelFuture future = pipeline.connect(new LocalAddress("test"), promise);
+        assertTrue(future.isCancelled());
+    }
+
+    @Test
+    public void testCancelDisconnect() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        group.register(pipeline.channel());
+
+        ChannelPromise promise = pipeline.channel().newPromise();
+        assertTrue(promise.cancel(false));
+        ChannelFuture future = pipeline.disconnect(promise);
+        assertTrue(future.isCancelled());
+    }
+
+    @Test
+    public void testCancelClose() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        group.register(pipeline.channel());
+
+        ChannelPromise promise = pipeline.channel().newPromise();
+        assertTrue(promise.cancel(false));
+        ChannelFuture future = pipeline.close(promise);
+        assertTrue(future.isCancelled());
+    }
+
+    @Test
+    public void testCancelDeregister() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        group.register(pipeline.channel());
+
+        ChannelPromise promise = pipeline.channel().newPromise();
+        assertTrue(promise.cancel(false));
+        ChannelFuture future = pipeline.deregister(promise);
+        assertTrue(future.isCancelled());
+    }
+
+    @Test
+    public void testCancelWrite() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        group.register(pipeline.channel());
+
+        ChannelPromise promise = pipeline.channel().newPromise();
+        assertTrue(promise.cancel(false));
+        ByteBuf buffer = Unpooled.buffer();
+        assertEquals(1, buffer.refCnt());
+        ChannelFuture future = pipeline.write(buffer, promise);
+        assertTrue(future.isCancelled());
+        assertEquals(0, buffer.refCnt());
+    }
+
+    @Test
+    public void testCancelWriteAndFlush() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        group.register(pipeline.channel());
+
+        ChannelPromise promise = pipeline.channel().newPromise();
+        assertTrue(promise.cancel(false));
+        ByteBuf buffer = Unpooled.buffer();
+        assertEquals(1, buffer.refCnt());
+        ChannelFuture future = pipeline.writeAndFlush(buffer, promise);
+        assertTrue(future.isCancelled());
+        assertEquals(0, buffer.refCnt());
+    }
+
+    @Test
+    public void testFirstContextEmptyPipeline() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        assertNull(pipeline.firstContext());
+    }
+
+    @Test
+    public void testLastContextEmptyPipeline() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        assertNull(pipeline.lastContext());
+    }
+
+    @Test
+    public void testFirstHandlerEmptyPipeline() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        assertNull(pipeline.first());
+    }
+
+    @Test
+    public void testLastHandlerEmptyPipeline() throws Exception {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        assertNull(pipeline.last());
+    }
+
+    private static int next(AbstractChannelHandlerContext ctx) {
+        AbstractChannelHandlerContext next = ctx.next;
         if (next == null) {
             return Integer.MAX_VALUE;
         }
@@ -449,7 +566,7 @@ private static int toInt(String name) {
     }
 
     private static void verifyContextNumber(ChannelPipeline pipeline, int expectedNumber) {
-        DefaultChannelHandlerContext ctx = (DefaultChannelHandlerContext) pipeline.firstContext();
+        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) pipeline.firstContext();
         int handlerNumber = 0;
         while (ctx != ((DefaultChannelPipeline) pipeline).tail) {
             handlerNumber++;
diff --git a/transport/src/test/java/io/netty/channel/LoggingHandler.java b/transport/src/test/java/io/netty/channel/LoggingHandler.java
index 1fc72d8f40de..4e68b2ec02d2 100644
--- a/transport/src/test/java/io/netty/channel/LoggingHandler.java
+++ b/transport/src/test/java/io/netty/channel/LoggingHandler.java
@@ -21,13 +21,13 @@
 
 final class LoggingHandler implements ChannelInboundHandler, ChannelOutboundHandler {
 
-    static enum Event { WRITE, FLUSH, BIND, CONNECT, DISCONNECT, CLOSE, DEREGISTER, READ, WRITABILITY,
+    enum Event { WRITE, FLUSH, BIND, CONNECT, DISCONNECT, CLOSE, DEREGISTER, READ, WRITABILITY,
         HANDLER_ADDED, HANDLER_REMOVED, EXCEPTION, READ_COMPLETE, REGISTERED, UNREGISTERED, ACTIVE, INACTIVE,
-        USER };
+        USER }
 
     private StringBuilder log = new StringBuilder();
 
-    private final EnumSet<LoggingHandler.Event> interest = EnumSet.allOf(LoggingHandler.Event.class);
+    private final EnumSet<Event> interest = EnumSet.allOf(Event.class);
 
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
@@ -143,30 +143,29 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
     }
 
     String getLog() {
-        return this.log.toString();
+        return log.toString();
     }
 
     void clear() {
-        this.log = new StringBuilder();
+        log = new StringBuilder();
     }
 
-    void setInterest(LoggingHandler.Event... events) {
-        this.interest.clear();
-        Collections.addAll(this.interest, events);
+    void setInterest(Event... events) {
+        interest.clear();
+        Collections.addAll(interest, events);
     }
 
-    private void log(LoggingHandler.Event e) {
+    private void log(Event e) {
         log(e, null);
     }
 
-    private void log(LoggingHandler.Event e, String msg) {
-        if (this.interest.contains(e)) {
-            this.log.append(e);
+    private void log(Event e, String msg) {
+        if (interest.contains(e)) {
+            log.append(e);
             if (msg != null) {
-                this.log.append(": ").append(msg);
+                log.append(": ").append(msg);
             }
-            this.log.append('\n');
+            log.append('\n');
         }
     }
-
 }
diff --git a/transport/src/test/java/io/netty/channel/ReentrantChannelTest.java b/transport/src/test/java/io/netty/channel/ReentrantChannelTest.java
index 3f75017e3d6f..b6fc1e654165 100644
--- a/transport/src/test/java/io/netty/channel/ReentrantChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/ReentrantChannelTest.java
@@ -15,14 +15,18 @@
  */
 package io.netty.channel;
 
-import static org.junit.Assert.assertTrue;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.LoggingHandler.Event;
 import io.netty.channel.local.LocalAddress;
-
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
 import org.junit.Test;
 
+import java.nio.channels.ClosedChannelException;
+
+import static org.junit.Assert.*;
+
 public class ReentrantChannelTest extends BaseChannelTest {
 
     @Test
@@ -96,4 +100,135 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio
             "WRITABILITY: writable=true\n");
     }
 
+    @Test
+    public void testWriteFlushPingPong() throws Exception {
+
+        LocalAddress addr = new LocalAddress("testWriteFlushPingPong");
+
+        ServerBootstrap sb = getLocalServerBootstrap();
+        sb.bind(addr).sync().channel();
+
+        Bootstrap cb = getLocalClientBootstrap();
+
+        setInterest(Event.WRITE, Event.FLUSH, Event.CLOSE, Event.EXCEPTION);
+
+        Channel clientChannel = cb.connect(addr).sync().channel();
+
+        clientChannel.pipeline().addLast(new ChannelOutboundHandlerAdapter() {
+
+            int writeCount;
+            int flushCount;
+
+            @Override
+            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+                if (writeCount < 5) {
+                    writeCount++;
+                    ctx.channel().flush();
+                }
+                super.write(ctx, msg,  promise);
+            }
+
+            @Override
+            public void flush(ChannelHandlerContext ctx) throws Exception {
+                if (flushCount < 5) {
+                    flushCount++;
+                    ctx.channel().write(createTestBuf(2000));
+                }
+                super.flush(ctx);
+            }
+        });
+
+        clientChannel.writeAndFlush(createTestBuf(2000));
+        clientChannel.close().sync();
+
+        assertLog(
+                "WRITE\n" +
+                "FLUSH\n" +
+                "WRITE\n" +
+                "FLUSH\n" +
+                "WRITE\n" +
+                "FLUSH\n" +
+                "WRITE\n" +
+                "FLUSH\n" +
+                "WRITE\n" +
+                "FLUSH\n" +
+                "WRITE\n" +
+                "FLUSH\n" +
+                "CLOSE\n");
+    }
+
+    @Test
+    public void testCloseInFlush() throws Exception {
+
+        LocalAddress addr = new LocalAddress("testCloseInFlush");
+
+        ServerBootstrap sb = getLocalServerBootstrap();
+        sb.bind(addr).sync().channel();
+
+        Bootstrap cb = getLocalClientBootstrap();
+
+        setInterest(Event.WRITE, Event.FLUSH, Event.CLOSE, Event.EXCEPTION);
+
+        Channel clientChannel = cb.connect(addr).sync().channel();
+
+        clientChannel.pipeline().addLast(new ChannelOutboundHandlerAdapter() {
+
+            @Override
+            public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+                promise.addListener(new GenericFutureListener<Future<? super Void>>() {
+                    @Override
+                    public void operationComplete(Future<? super Void> future) throws Exception {
+                        ctx.channel().close();
+                    }
+                });
+                super.write(ctx, msg, promise);
+                ctx.channel().flush();
+            }
+        });
+
+        clientChannel.write(createTestBuf(2000)).sync();
+        clientChannel.closeFuture().sync();
+
+        assertLog("WRITE\nFLUSH\nCLOSE\n");
+    }
+
+    @Test
+    public void testFlushFailure() throws Exception {
+
+        LocalAddress addr = new LocalAddress("testFlushFailure");
+
+        ServerBootstrap sb = getLocalServerBootstrap();
+        sb.bind(addr).sync().channel();
+
+        Bootstrap cb = getLocalClientBootstrap();
+
+        setInterest(Event.WRITE, Event.FLUSH, Event.CLOSE, Event.EXCEPTION);
+
+        Channel clientChannel = cb.connect(addr).sync().channel();
+
+        clientChannel.pipeline().addLast(new ChannelOutboundHandlerAdapter() {
+
+            @Override
+            public void flush(ChannelHandlerContext ctx) throws Exception {
+                throw new Exception("intentional failure");
+            }
+
+            @Override
+            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+                ctx.close();
+            }
+        });
+
+        try {
+            clientChannel.writeAndFlush(createTestBuf(2000)).sync();
+            fail();
+        } catch (Throwable cce) {
+            // FIXME:  shouldn't this contain the "intentional failure" exception?
+            assertEquals(ClosedChannelException.class, cce.getClass());
+        }
+
+        clientChannel.closeFuture().sync();
+
+        assertLog("WRITE\nCLOSE\n");
+    }
 }
diff --git a/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java b/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
index 718b7bfc5bed..2c936bd23339 100644
--- a/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
+++ b/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
@@ -92,7 +92,7 @@ private static void runTest(ThreadPerChannelEventLoopGroup loopGroup) throws Int
 
     private static class TestEventExecutor extends SingleThreadEventExecutor {
 
-        public TestEventExecutor() {
+        TestEventExecutor() {
             super(null, new DefaultThreadFactory("test"), false);
         }
 
diff --git a/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
index f109040a2e31..c99868ff8f86 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
@@ -19,17 +19,23 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.DefaultEventLoopGroup;
+import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.SingleThreadEventLoop;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
 
 import java.nio.channels.ClosedChannelException;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
@@ -43,8 +49,8 @@ public class LocalChannelTest {
     @Test
     public void testLocalAddressReuse() throws Exception {
         for (int i = 0; i < 2; i ++) {
-            EventLoopGroup clientGroup = new LocalEventLoopGroup();
-            EventLoopGroup serverGroup = new LocalEventLoopGroup();
+            EventLoopGroup clientGroup = new DefaultEventLoopGroup();
+            EventLoopGroup serverGroup = new DefaultEventLoopGroup();
             LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);
             Bootstrap cb = new Bootstrap();
             ServerBootstrap sb = new ServerBootstrap();
@@ -97,8 +103,8 @@ public void run() {
 
     @Test
     public void testWriteFailsFastOnClosedChannel() throws Exception {
-        EventLoopGroup clientGroup = new LocalEventLoopGroup();
-        EventLoopGroup serverGroup = new LocalEventLoopGroup();
+        EventLoopGroup clientGroup = new DefaultEventLoopGroup();
+        EventLoopGroup serverGroup = new DefaultEventLoopGroup();
         LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);
         Bootstrap cb = new Bootstrap();
         ServerBootstrap sb = new ServerBootstrap();
@@ -147,7 +153,7 @@ public void initChannel(LocalChannel ch) throws Exception {
     @Test
     public void testServerCloseChannelSameEventLoop() throws Exception {
         LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);
-        LocalEventLoopGroup group = new LocalEventLoopGroup(1);
+        EventLoopGroup group = new DefaultEventLoopGroup(1);
         final CountDownLatch latch = new CountDownLatch(1);
         ServerBootstrap sb = new ServerBootstrap()
                 .group(group)
@@ -177,6 +183,104 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except
         group.terminationFuture().sync();
     }
 
+    @Test
+    public void localChannelRaceCondition() throws Exception {
+        final LocalAddress address = new LocalAddress("test");
+        final CountDownLatch closeLatch = new CountDownLatch(1);
+        final EventLoopGroup serverGroup = new DefaultEventLoopGroup(1);
+        final EventLoopGroup clientGroup = new DefaultEventLoopGroup(1) {
+            @Override
+            protected EventLoop newChild(Executor threadFactory, Object... args)
+                    throws Exception {
+                return new SingleThreadEventLoop(this, threadFactory, true) {
+                    @Override
+                    protected void run() {
+                        for (;;) {
+                            Runnable task = takeTask();
+                            if (task != null) {
+                                /* Only slow down the anonymous class in LocalChannel#doRegister() */
+                                if (task.getClass().getEnclosingClass() == LocalChannel.class) {
+                                    try {
+                                        closeLatch.await();
+                                    } catch (InterruptedException e) {
+                                        throw new Error(e);
+                                    }
+                                }
+                                task.run();
+                                updateLastExecutionTime();
+                            }
+
+                            if (confirmShutdown()) {
+                                break;
+                            }
+                        }
+                    }
+                };
+            }
+        };
+        try {
+            ServerBootstrap sb = new ServerBootstrap();
+            sb.group(serverGroup).
+                    channel(LocalServerChannel.class).
+                    childHandler(new ChannelInitializer<Channel>() {
+                        @Override
+                        protected void initChannel(Channel ch) throws Exception {
+                            ch.close();
+                            closeLatch.countDown();
+                        }
+                    }).
+                    bind(address).
+                    sync();
+            Bootstrap bootstrap = new Bootstrap();
+            bootstrap.group(clientGroup).
+                    channel(LocalChannel.class).
+                    handler(new ChannelInitializer<Channel>() {
+                        @Override
+                        protected void initChannel(Channel ch) throws Exception {
+                            /* Do nothing */
+                        }
+                    });
+            ChannelFuture future = bootstrap.connect(address);
+            assertTrue("Connection should finish, not time out", future.await(200));
+        } finally {
+            serverGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS).await();
+            clientGroup.shutdownGracefully(0, 0, TimeUnit.SECONDS).await();
+        }
+    }
+
+    @Test
+    public void testReRegister() {
+        EventLoopGroup group1 = new DefaultEventLoopGroup();
+        EventLoopGroup group2 = new DefaultEventLoopGroup();
+        LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);
+        Bootstrap cb = new Bootstrap();
+        ServerBootstrap sb = new ServerBootstrap();
+
+        cb.group(group1)
+                .channel(LocalChannel.class)
+                .handler(new TestHandler());
+
+        sb.group(group2)
+                .channel(LocalServerChannel.class)
+                .childHandler(new ChannelInitializer<LocalChannel>() {
+                    @Override
+                    public void initChannel(LocalChannel ch) throws Exception {
+                        ch.pipeline().addLast(new TestHandler());
+                    }
+                });
+
+        // Start server
+        final Channel sc = sb.bind(addr).syncUninterruptibly().channel();
+
+        // Connect to the server
+        final Channel cc = cb.connect(addr).syncUninterruptibly().channel();
+
+        cc.deregister().syncUninterruptibly();
+        // Change event loop group.
+        group2.register(cc).syncUninterruptibly();
+        cc.close().syncUninterruptibly();
+        sc.close().syncUninterruptibly();
+    }
     static class TestHandler extends ChannelInboundHandlerAdapter {
         @Override
         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
diff --git a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
index f69bad9ba8da..b3bb3219c9d3 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
@@ -24,6 +24,7 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.DefaultEventLoopGroup;
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
@@ -49,7 +50,7 @@ public class LocalTransportThreadModelTest {
     @BeforeClass
     public static void init() {
         // Configure a test server
-        group = new LocalEventLoopGroup();
+        group = new DefaultEventLoopGroup();
         ServerBootstrap sb = new ServerBootstrap();
         sb.group(group)
           .channel(LocalServerChannel.class)
@@ -84,12 +85,12 @@ public void testStagedExecutionMultiple() throws Throwable {
 
     @Test(timeout = 5000)
     public void testStagedExecution() throws Throwable {
-        EventLoopGroup l = new LocalEventLoopGroup(4, new DefaultThreadFactory("l"));
+        EventLoopGroup l = new DefaultEventLoopGroup(4, new DefaultThreadFactory("l"));
         EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e1"));
         EventExecutorGroup e2 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e2"));
         ThreadNameAuditor h1 = new ThreadNameAuditor();
         ThreadNameAuditor h2 = new ThreadNameAuditor();
-        ThreadNameAuditor h3 = new ThreadNameAuditor();
+        ThreadNameAuditor h3 = new ThreadNameAuditor(true);
 
         Channel ch = new LocalChannel();
         // With no EventExecutor specified, h1 will be always invoked by EventLoop 'l'.
@@ -227,7 +228,7 @@ public void testStagedExecution() throws Throwable {
     @Test(timeout = 30000)
     @Ignore
     public void testConcurrentMessageBufferAccess() throws Throwable {
-        EventLoopGroup l = new LocalEventLoopGroup(4, new DefaultThreadFactory("l"));
+        EventLoopGroup l = new DefaultEventLoopGroup(4, new DefaultThreadFactory("l"));
         EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e1"));
         EventExecutorGroup e2 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e2"));
         EventExecutorGroup e3 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e3"));
@@ -360,6 +361,15 @@ private static class ThreadNameAuditor extends ChannelDuplexHandler {
         private final Queue<String> inboundThreadNames = new ConcurrentLinkedQueue<String>();
         private final Queue<String> outboundThreadNames = new ConcurrentLinkedQueue<String>();
         private final Queue<String> removalThreadNames = new ConcurrentLinkedQueue<String>();
+        private final boolean discard;
+
+        ThreadNameAuditor() {
+            this(false);
+        }
+
+        ThreadNameAuditor(boolean discard) {
+            this.discard = discard;
+        }
 
         @Override
         public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
@@ -369,7 +379,9 @@ public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
         @Override
         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
             inboundThreadNames.add(Thread.currentThread().getName());
-            ctx.fireChannelRead(msg);
+            if (!discard) {
+                ctx.fireChannelRead(msg);
+            }
         }
 
         @Override
diff --git a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java
index 45218327aabf..4d2aa46fa2b2 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java
@@ -22,6 +22,7 @@
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.DefaultEventLoopGroup;
 import io.netty.util.ReferenceCountUtil;
 import org.junit.Test;
 
@@ -40,14 +41,14 @@ public void testSocketReuse() throws InterruptedException {
         ServerBootstrap serverBootstrap = new ServerBootstrap();
         LocalHander serverHandler = new LocalHander("SERVER");
         serverBootstrap
-                .group(new LocalEventLoopGroup(), new LocalEventLoopGroup())
+                .group(new DefaultEventLoopGroup(), new DefaultEventLoopGroup())
                 .channel(LocalServerChannel.class)
                 .childHandler(serverHandler);
 
         Bootstrap clientBootstrap = new Bootstrap();
         LocalHander clientHandler = new LocalHander("CLIENT");
         clientBootstrap
-                .group(new LocalEventLoopGroup())
+                .group(new DefaultEventLoopGroup())
                 .channel(LocalChannel.class)
                 .remoteAddress(new LocalAddress(LOCAL_CHANNEL)).handler(clientHandler);
 
@@ -100,7 +101,7 @@ static class LocalHander extends ChannelInboundHandlerAdapter {
 
         public final AtomicInteger count = new AtomicInteger(0);
 
-        public LocalHander(String name) {
+        LocalHander(String name) {
             this.name = name;
         }
 
diff --git a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java
index bfb3b4bd673a..2c636b5b2490 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java
@@ -23,6 +23,7 @@
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.DefaultEventLoopGroup;
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
@@ -62,7 +63,7 @@ enum EventType {
     @BeforeClass
     public static void init() {
         // Configure a test server
-        group = new LocalEventLoopGroup();
+        group = new DefaultEventLoopGroup();
         ServerBootstrap sb = new ServerBootstrap();
         sb.group(group)
                 .channel(LocalServerChannel.class)
@@ -116,7 +117,7 @@ public void testConcurrentAddRemoveOutboundEvents() throws Throwable {
     }
 
     private static void testConcurrentAddRemove(boolean inbound) throws Exception {
-        EventLoopGroup l = new LocalEventLoopGroup(4, new DefaultThreadFactory("l"));
+        EventLoopGroup l = new DefaultEventLoopGroup(4, new DefaultThreadFactory("l"));
         EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e1"));
         EventExecutorGroup e2 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e2"));
         EventExecutorGroup e3 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e3"));
@@ -210,7 +211,7 @@ public void run() {
             for (;;) {
                 EventType event = events.poll();
                 if (event == null) {
-                    Assert.assertTrue("Missing events:" + expectedEvents.toString(), expectedEvents.isEmpty());
+                    Assert.assertTrue("Missing events:" + expectedEvents, expectedEvents.isEmpty());
                     break;
                 }
                 Assert.assertEquals(event, expectedEvents.poll());
@@ -258,7 +259,7 @@ private static final class EventRecorder extends ChannelDuplexHandler {
         private final Queue<EventType> events;
         private final boolean inbound;
 
-        public EventRecorder(Queue<EventType> events, boolean inbound) {
+        EventRecorder(Queue<EventType> events, boolean inbound) {
             this.events = events;
             this.inbound = inbound;
         }
diff --git a/transport/src/test/java/io/netty/channel/nio/NioSocketChannelTest.java b/transport/src/test/java/io/netty/channel/nio/NioSocketChannelTest.java
index 0844167b8c16..3d5b47dfd4a9 100644
--- a/transport/src/test/java/io/netty/channel/nio/NioSocketChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/nio/NioSocketChannelTest.java
@@ -21,13 +21,16 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelOption;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.util.CharsetUtil;
+import io.netty.util.NetUtil;
 import org.junit.Test;
 
 import java.io.DataInput;
 import java.io.DataInputStream;
 import java.io.InputStream;
+import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.net.SocketAddress;
 import java.nio.channels.ClosedChannelException;
@@ -51,6 +54,7 @@ public void testFlushCloseReentrance() throws Exception {
 
             ServerBootstrap sb = new ServerBootstrap();
             sb.group(group).channel(NioServerSocketChannel.class);
+            sb.childOption(ChannelOption.SO_SNDBUF, 1024);
             sb.childHandler(new ChannelInboundHandlerAdapter() {
                 @Override
                 public void channelActive(ChannelHandlerContext ctx) throws Exception {
@@ -66,8 +70,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
 
             SocketAddress address = sb.bind(0).sync().channel().localAddress();
 
-            Socket s = new Socket();
-            s.connect(address);
+            Socket s = new Socket(NetUtil.LOCALHOST, ((InetSocketAddress) address).getPort());
 
             InputStream in = s.getInputStream();
             byte[] buf = new byte[8192];
@@ -125,8 +128,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
 
             SocketAddress address = sb.bind(0).sync().channel().localAddress();
 
-            Socket s = new Socket();
-            s.connect(address);
+            Socket s = new Socket(NetUtil.LOCALHOST, ((InetSocketAddress) address).getPort());
 
             DataInput in = new DataInputStream(s.getInputStream());
             byte[] buf = new byte[3];
diff --git a/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java b/transport/src/test/java/io/netty/channel/socket/nio/NioSocketChannelOutboundBufferTest.java
similarity index 57%
rename from transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java
rename to transport/src/test/java/io/netty/channel/socket/nio/NioSocketChannelOutboundBufferTest.java
index f1cfdb382085..7f825d4b0eea 100644
--- a/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java
+++ b/transport/src/test/java/io/netty/channel/socket/nio/NioSocketChannelOutboundBufferTest.java
@@ -13,25 +13,27 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.channel;
+package io.netty.channel.socket.nio;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.CompositeByteBuf;
+import io.netty.channel.AbstractChannel;
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 
-import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 
 import static io.netty.buffer.Unpooled.*;
 import static org.junit.Assert.*;
 
-public class ChannelOutboundBufferTest {
+public class NioSocketChannelOutboundBufferTest {
 
     @Test
     public void testEmptyNioBuffers() {
-        TestChannel channel = new TestChannel();
-        ChannelOutboundBuffer buffer = ChannelOutboundBuffer.newInstance(channel);
+        AbstractChannel channel = new EmbeddedChannel();
+        NioSocketChannelOutboundBuffer buffer = NioSocketChannelOutboundBuffer.newInstance(channel);
         assertEquals(0, buffer.nioBufferCount());
         ByteBuffer[] buffers = buffer.nioBuffers();
         assertEquals(32, buffers.length);
@@ -44,9 +46,8 @@ public void testEmptyNioBuffers() {
 
     @Test
     public void testNioBuffersSingleBacked() {
-        TestChannel channel = new TestChannel();
-
-        ChannelOutboundBuffer buffer = ChannelOutboundBuffer.newInstance(channel);
+        AbstractChannel channel = new EmbeddedChannel();
+        NioSocketChannelOutboundBuffer buffer = NioSocketChannelOutboundBuffer.newInstance(channel);
         assertEquals(0, buffer.nioBufferCount());
         ByteBuffer[] buffers = buffer.nioBuffers();
         assertEquals(32, buffers.length);
@@ -69,7 +70,7 @@ public void testNioBuffersSingleBacked() {
         assertEquals("Should still be 0 as not flushed yet", 1, buffer.nioBufferCount());
         for (int i = 0;  i < buffers.length; i++) {
             if (i == 0) {
-                assertEquals(buffers[i], nioBuf);
+                assertEquals(buffers[0], nioBuf);
             } else {
                 assertNull(buffers[i]);
             }
@@ -79,25 +80,24 @@ public void testNioBuffersSingleBacked() {
 
     @Test
     public void testNioBuffersExpand() {
-        TestChannel channel = new TestChannel();
-
-        ChannelOutboundBuffer buffer = ChannelOutboundBuffer.newInstance(channel);
+        AbstractChannel channel = new EmbeddedChannel();
+        NioSocketChannelOutboundBuffer buffer = NioSocketChannelOutboundBuffer.newInstance(channel);
 
         ByteBuf buf = directBuffer().writeBytes("buf1".getBytes(CharsetUtil.US_ASCII));
         for (int i = 0; i < 64; i++) {
             buffer.addMessage(buf.copy(), channel.voidPromise());
         }
-        ByteBuffer[] buffers = buffer.nioBuffers();
+        ByteBuffer[] nioBuffers = buffer.nioBuffers();
         assertEquals("Should still be 0 as not flushed yet", 0, buffer.nioBufferCount());
-        for (ByteBuffer b: buffers) {
+        for (ByteBuffer b: nioBuffers) {
             assertNull(b);
         }
         buffer.addFlush();
-        buffers = buffer.nioBuffers();
-        assertEquals(64, buffers.length);
+        nioBuffers = buffer.nioBuffers();
+        assertEquals(64, nioBuffers.length);
         assertEquals(64, buffer.nioBufferCount());
-        for (int i = 0;  i < buffers.length; i++) {
-            assertEquals(buffers[i], buf.internalNioBuffer(0, buf.readableBytes()));
+        for (ByteBuffer nioBuf: nioBuffers) {
+            assertEquals(nioBuf, buf.internalNioBuffer(0, buf.readableBytes()));
         }
         release(buffer);
         buf.release();
@@ -105,9 +105,8 @@ public void testNioBuffersExpand() {
 
     @Test
     public void testNioBuffersExpand2() {
-        TestChannel channel = new TestChannel();
-
-        ChannelOutboundBuffer buffer = ChannelOutboundBuffer.newInstance(channel);
+        AbstractChannel channel = new EmbeddedChannel();
+        NioSocketChannelOutboundBuffer buffer = NioSocketChannelOutboundBuffer.newInstance(channel);
 
         CompositeByteBuf comp = compositeBuffer(256);
         ByteBuf buf = directBuffer().writeBytes("buf1".getBytes(CharsetUtil.US_ASCII));
@@ -143,84 +142,4 @@ private static void release(ChannelOutboundBuffer buffer) {
             }
         }
     }
-
-    private static final class TestChannel extends AbstractChannel {
-        private final ChannelConfig config = new DefaultChannelConfig(this);
-
-        TestChannel() {
-            super(null);
-        }
-
-        @Override
-        protected AbstractUnsafe newUnsafe() {
-            return new TestUnsafe();
-        }
-
-        @Override
-        protected boolean isCompatible(EventLoop loop) {
-            return false;
-        }
-
-        @Override
-        protected SocketAddress localAddress0() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        protected SocketAddress remoteAddress0() {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        protected void doBind(SocketAddress localAddress) throws Exception {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        protected void doDisconnect() throws Exception {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        protected void doClose() throws Exception {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        protected void doBeginRead() throws Exception {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        protected void doWrite(ChannelOutboundBuffer in) throws Exception {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public ChannelConfig config() {
-            return config;
-        }
-
-        @Override
-        public boolean isOpen() {
-            return true;
-        }
-
-        @Override
-        public boolean isActive() {
-            return true;
-        }
-
-        @Override
-        public ChannelMetadata metadata() {
-            throw new UnsupportedOperationException();
-        }
-
-        final class TestUnsafe extends AbstractUnsafe {
-            @Override
-            public void connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
-                throw new UnsupportedOperationException();
-            }
-        }
-    }
 }