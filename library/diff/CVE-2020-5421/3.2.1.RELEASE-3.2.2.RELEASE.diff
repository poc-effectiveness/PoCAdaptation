diff --git a/.gitignore b/.gitignore
index 67d798efd45c..b1e4ec06c78d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,6 +19,7 @@ pom.xml
 /build
 buildSrc/build
 /spring-*/build
+target/
 
 # Eclipse artifacts, including WTP generated manifests
 .classpath
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 65db556fabd4..02d0bc12e2e2 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -87,7 +87,7 @@ present in the framework.
 
 ```java
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -108,16 +108,16 @@ package ...;
 ## Update Apache license header to modified files as necessary
 
 Always check the date range in the license header. For example, if you've
-modified a file in 2012 whose header still reads
+modified a file in 2013 whose header still reads
 
 ```java
  * Copyright 2002-2011 the original author or authors.
 ```
 
-then be sure to update it to 2012 appropriately
+then be sure to update it to 2013 appropriately
 
 ```java
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
 ```
 
 ## Use @since tags for newly-added public API types and methods
diff --git a/build.gradle b/build.gradle
index 19fe164e4dca..fac5af1ec003 100644
--- a/build.gradle
+++ b/build.gradle
@@ -4,7 +4,7 @@ buildscript {
 	}
 	dependencies {
 		classpath("org.springframework.build.gradle:propdeps-plugin:0.0.3")
-		classpath("org.springframework.build.gradle:docbook-reference-plugin:0.2.4")
+		classpath("org.springframework.build.gradle:docbook-reference-plugin:0.2.6")
 	}
 }
 
@@ -12,8 +12,7 @@ configure(allprojects) { project ->
 	group = "org.springframework"
 	version = qualifyVersionIfNecessary(version)
 
-	ext.aspectjVersion  = "1.7.1"
-	ext.easymockVersion = "2.5.2"
+	ext.aspectjVersion  = "1.7.2"
 	ext.hsqldbVersion   = "1.8.0.10"
 	ext.junitVersion    = "4.11"
 	ext.slf4jVersion    = "1.6.1"
@@ -69,13 +68,6 @@ configure(allprojects) { project ->
 		testCompile("junit:junit:${junitVersion}")
 		testCompile("org.hamcrest:hamcrest-all:1.3")
 		testCompile("org.mockito:mockito-core:1.9.5")
-		if (project.name in ["spring", "spring-jms",
-				"spring-orm-hibernate4", "spring-oxm", "spring-struts",
-				"spring-test", "spring-test-mvc", "spring-tx", "spring-web",
-				"spring-webmvc", "spring-webmvc-portlet", "spring-webmvc-tiles3"]) {
-			testCompile("org.easymock:easymock:${easymockVersion}")
-			testCompile "org.easymock:easymockclassextension:${easymockVersion}"
-		}
 	}
 
 	ext.javadocLinks = [
@@ -689,7 +681,7 @@ project("spring-test-mvc") {
 	description = "Spring Test MVC Framework"
 	merge.into = project(":spring-test")
 	dependencies {
-		provided(project(":spring-context"))
+		optional(project(":spring-context"))
 		provided(project(":spring-webmvc"))
 		provided("javax.servlet:javax.servlet-api:3.0.1")
 		optional("org.hamcrest:hamcrest-core:1.3")
@@ -817,6 +809,7 @@ configure(rootProject) {
 		options.author = true
 		options.header = rootProject.description
 		options.overview = "src/api/overview.html"
+		options.stylesheetFile = file("src/api/stylesheet.css")
 		options.splitIndex = true
 		options.links(project.ext.javadocLinks)
 
diff --git a/buildSrc/src/main/groovy/org/springframework/build/gradle/MergePlugin.groovy b/buildSrc/src/main/groovy/org/springframework/build/gradle/MergePlugin.groovy
index 097e65ab93cd..4143780702b6 100644
--- a/buildSrc/src/main/groovy/org/springframework/build/gradle/MergePlugin.groovy
+++ b/buildSrc/src/main/groovy/org/springframework/build/gradle/MergePlugin.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -110,7 +110,7 @@ class MergePlugin implements Plugin<Project> {
 
 		// update 'into' project artifacts to contain the source artifact contents
 		project.merge.into.sourcesJar.from(project.sourcesJar.source)
-		project.merge.into.jar.from(project.jar.source)
+		project.merge.into.jar.from(project.sourceSets.main.output)
 		project.merge.into.javadoc {
 			source += project.javadoc.source
 			classpath += project.javadoc.classpath
@@ -128,7 +128,13 @@ class MergePlugin implements Plugin<Project> {
 						(ExcludeRule.GROUP_KEY) : it.group,
 						(ExcludeRule.MODULE_KEY) : it.module])
 				}
-				intoConfiguration.dependencies.addAll(configuration.dependencies)
+				configuration.dependencies.each {
+					def intoCompile = project.merge.into.configurations.getByName("compile")
+					// Protect against changing a compile scope dependency (SPR-10218)
+					if(!intoCompile.dependencies.contains(it)) {
+						intoConfiguration.dependencies.add(it)
+					}
+				}
 				project.merge.into.install.repositories.mavenInstaller.pom.scopeMappings.addMapping(
 					mapping.priority + 100, intoConfiguration, mapping.scope)
 			}
diff --git a/gradle.properties b/gradle.properties
index e91e1373ca51..918f960f9cc3 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1 +1 @@
-version=3.2.1.RELEASE
+version=3.2.2.RELEASE
diff --git a/gradle/jdiff.gradle b/gradle/jdiff.gradle
index 48065503390f..cc07e3f71b32 100644
--- a/gradle/jdiff.gradle
+++ b/gradle/jdiff.gradle
@@ -45,7 +45,7 @@ task jdiff {
 				destdir: outputDir,
 				verbose: "off",
 				stats: "on",
-				docchanges: "on") {
+				docchanges: "off") {
 			old(name: "Spring Framework ${oldVersion}") {
 				oldVersionRoot.eachDirMatch( {
 						def candidate = new File(it)
diff --git a/gradle/publish-maven.gradle b/gradle/publish-maven.gradle
index 528e78c15d5d..d47098b4f128 100644
--- a/gradle/publish-maven.gradle
+++ b/gradle/publish-maven.gradle
@@ -13,6 +13,11 @@ def customizePom(pom, gradleProject) {
 			dep.scope == "test"
 		}
 
+		// sort to make pom dependencies order consistent to ease comparison of older poms
+		generatedPom.dependencies = generatedPom.dependencies.sort { dep ->
+			"$dep.scope:$dep.groupId:$dep.artifactId"
+		}
+
 		// add all items necessary for maven central publication
 		generatedPom.project {
 			name = gradleProject.description
diff --git a/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java
index 7e101ea57d69..e14f2546121b 100644
--- a/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java
+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.java
@@ -282,8 +282,8 @@ else if (shadowMatch.neverMatches()) {
 			return false;
 		}
 		else {
-		  // the maybe case
-		  return (beanHasIntroductions || matchesIgnoringSubtypes(shadowMatch) || matchesTarget(shadowMatch, targetClass));
+			// the maybe case
+			return (beanHasIntroductions || matchesIgnoringSubtypes(shadowMatch) || matchesTarget(shadowMatch, targetClass));
 		}
 	}
 
diff --git a/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJProxyUtils.java b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJProxyUtils.java
index 3463e8cc6132..0fe055967939 100644
--- a/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJProxyUtils.java
+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJProxyUtils.java
@@ -64,8 +64,8 @@ public static boolean makeAdvisorChainAspectJCapableIfNecessary(List<Advisor> ad
 	 */
 	private static boolean isAspectJAdvice(Advisor advisor) {
 		return (advisor instanceof InstantiationModelAwarePointcutAdvisor ||
-			   advisor.getAdvice() instanceof AbstractAspectJAdvice ||
-			   (advisor instanceof PointcutAdvisor &&
+				advisor.getAdvice() instanceof AbstractAspectJAdvice ||
+				(advisor instanceof PointcutAdvisor &&
 						 ((PointcutAdvisor) advisor).getPointcut() instanceof AspectJExpressionPointcut));
 	}
 
diff --git a/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJWeaverMessageHandler.java b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJWeaverMessageHandler.java
index 4505e6f33000..678c87baebf7 100644
--- a/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJWeaverMessageHandler.java
+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJWeaverMessageHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -51,36 +51,32 @@ public class AspectJWeaverMessageHandler implements IMessageHandler {
 	public boolean handleMessage(IMessage message) throws AbortException {
 		Kind messageKind = message.getKind();
 
-		if (LOGGER.isDebugEnabled() || LOGGER.isTraceEnabled()) {
-			if (messageKind == IMessage.DEBUG) {
+		if (messageKind == IMessage.DEBUG) {
+			if (LOGGER.isDebugEnabled() || LOGGER.isTraceEnabled()) {
 				LOGGER.debug(makeMessageFor(message));
 				return true;
 			}
 		}
-
-		if (LOGGER.isInfoEnabled()) {
-			if ((messageKind == IMessage.INFO) || (messageKind == IMessage.WEAVEINFO)) {
+		else if ((messageKind == IMessage.INFO) || (messageKind == IMessage.WEAVEINFO)) {
+			if (LOGGER.isInfoEnabled()) {
 				LOGGER.info(makeMessageFor(message));
 				return true;
 			}
 		}
-
-		if (LOGGER.isWarnEnabled()) {
-			if (messageKind == IMessage.WARNING) {
+		else if (messageKind == IMessage.WARNING) {
+			if (LOGGER.isWarnEnabled()) {
 				LOGGER.warn(makeMessageFor(message));
 				return true;
 			}
 		}
-
-		if (LOGGER.isErrorEnabled()) {
-			if (messageKind == IMessage.ERROR) {
+		else if (messageKind == IMessage.ERROR) {
+			if (LOGGER.isErrorEnabled()) {
 				LOGGER.error(makeMessageFor(message));
 				return true;
 			}
 		}
-
-		if (LOGGER.isFatalEnabled()) {
-			if (messageKind == IMessage.ABORT) {
+		else if (messageKind == IMessage.ABORT) {
+			if (LOGGER.isFatalEnabled()) {
 				LOGGER.fatal(makeMessageFor(message));
 				return true;
 			}
diff --git a/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl.java b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl.java
index b9863ab67add..65e296f594c6 100644
--- a/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl.java
+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl.java
@@ -63,8 +63,8 @@ class InstantiationModelAwarePointcutAdvisorImpl
 	private Boolean isAfterAdvice;
 
 
-	public InstantiationModelAwarePointcutAdvisorImpl(AspectJAdvisorFactory af,  AspectJExpressionPointcut ajexp,
-			MetadataAwareAspectInstanceFactory aif,  Method method, int declarationOrderInAspect, String aspectName) {
+	public InstantiationModelAwarePointcutAdvisorImpl(AspectJAdvisorFactory af, AspectJExpressionPointcut ajexp,
+			MetadataAwareAspectInstanceFactory aif, Method method, int declarationOrderInAspect, String aspectName) {
 
 		this.declaredPointcut = ajexp;
 		this.method = method;
diff --git a/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJAwareAdvisorAutoProxyCreator.java b/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJAwareAdvisorAutoProxyCreator.java
index dbfcbd380e35..271d961088b5 100644
--- a/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJAwareAdvisorAutoProxyCreator.java
+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJAwareAdvisorAutoProxyCreator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,8 @@
 
 package org.springframework.aop.aspectj.autoproxy;
 
+import java.util.ArrayList;
 import java.util.Comparator;
-import java.util.LinkedList;
 import java.util.List;
 
 import org.aopalliance.aop.Advice;
@@ -67,29 +67,24 @@ public class AspectJAwareAdvisorAutoProxyCreator extends AbstractAdvisorAutoProx
 	@Override
 	@SuppressWarnings("unchecked")
 	protected List<Advisor> sortAdvisors(List<Advisor> advisors) {
-		// build list for sorting
 		List<PartiallyComparableAdvisorHolder> partiallyComparableAdvisors =
-				new LinkedList<PartiallyComparableAdvisorHolder>();
+				new ArrayList<PartiallyComparableAdvisorHolder>(advisors.size());
 		for (Advisor element : advisors) {
 			partiallyComparableAdvisors.add(
 					new PartiallyComparableAdvisorHolder(element, DEFAULT_PRECEDENCE_COMPARATOR));
 		}
-
-		// sort it
 		List<PartiallyComparableAdvisorHolder> sorted =
 				PartialOrder.sort(partiallyComparableAdvisors);
-		if (sorted == null) {
-			// TODO: work harder to give a better error message here.
-			throw new IllegalArgumentException("Advice precedence circularity error");
+		if (sorted != null) {
+			List<Advisor> result = new ArrayList<Advisor>(advisors.size());
+			for (PartiallyComparableAdvisorHolder pcAdvisor : sorted) {
+				result.add(pcAdvisor.getAdvisor());
+			}
+			return result;
 		}
-
-		// extract results again
-		List<Advisor> result = new LinkedList<Advisor>();
-		for (PartiallyComparableAdvisorHolder pcAdvisor : sorted) {
-			result.add(pcAdvisor.getAdvisor());
+		else {
+			return super.sortAdvisors(advisors);
 		}
-
-		return result;
 	}
 
 	/**
diff --git a/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.java b/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.java
index 0dd176354eba..31fdb83f7d87 100644
--- a/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.java
+++ b/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -53,7 +53,6 @@ class AspectJPrecedenceComparator implements Comparator {
 	private static final int HIGHER_PRECEDENCE = -1;
 	private static final int SAME_PRECEDENCE = 0;
 	private static final int LOWER_PRECEDENCE = 1;
-	private static final int NOT_COMPARABLE = 0;
 
 	private final Comparator<? super Advisor> advisorComparator;
 
@@ -85,21 +84,11 @@ public int compare(Object o1, Object o2) {
 
 		Advisor advisor1 = (Advisor) o1;
 		Advisor advisor2 = (Advisor) o2;
-
-		boolean oneOrOtherIsAfterAdvice =
-				(AspectJAopUtils.isAfterAdvice(advisor1) || AspectJAopUtils.isAfterAdvice(advisor2));
-		boolean oneOrOtherIsBeforeAdvice =
-				(AspectJAopUtils.isBeforeAdvice(advisor1) || AspectJAopUtils.isBeforeAdvice(advisor2));
-		if (oneOrOtherIsAfterAdvice && oneOrOtherIsBeforeAdvice) {
-			return NOT_COMPARABLE;
-		}
-		else {
-			int advisorPrecedence = this.advisorComparator.compare(advisor1, advisor2);
-			if (advisorPrecedence == SAME_PRECEDENCE && declaredInSameAspect(advisor1, advisor2)) {
-				advisorPrecedence = comparePrecedenceWithinAspect(advisor1, advisor2);
-			}
-			return advisorPrecedence;
+		int advisorPrecedence = this.advisorComparator.compare(advisor1, advisor2);
+		if (advisorPrecedence == SAME_PRECEDENCE && declaredInSameAspect(advisor1, advisor2)) {
+			advisorPrecedence = comparePrecedenceWithinAspect(advisor1, advisor2);
 		}
+		return advisorPrecedence;
 	}
 
 	private int comparePrecedenceWithinAspect(Advisor advisor1, Advisor advisor2) {
diff --git a/spring-aop/src/main/java/org/springframework/aop/framework/AbstractAdvisingBeanPostProcessor.java b/spring-aop/src/main/java/org/springframework/aop/framework/AbstractAdvisingBeanPostProcessor.java
index 5d76f6c8a5e8..01b0fe856c37 100644
--- a/spring-aop/src/main/java/org/springframework/aop/framework/AbstractAdvisingBeanPostProcessor.java
+++ b/spring-aop/src/main/java/org/springframework/aop/framework/AbstractAdvisingBeanPostProcessor.java
@@ -39,6 +39,8 @@ public abstract class AbstractAdvisingBeanPostProcessor extends ProxyConfig
 
 	protected Advisor advisor;
 
+	protected boolean beforeExistingAdvisors = false;
+
 	private ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();
 
 	/**
@@ -50,6 +52,19 @@ public abstract class AbstractAdvisingBeanPostProcessor extends ProxyConfig
 	private final Map<Class, Boolean> eligibleBeans = new ConcurrentHashMap<Class, Boolean>(64);
 
 
+	/**
+	 * Set whether this post-processor's advisor is supposed to apply before
+	 * existing advisors when encountering a pre-advised object.
+	 * <p>Default is "false", applying the advisor after existing advisors, i.e.
+	 * as close as possible to the target method. Switch this to "true" in order
+	 * for this post-processor's advisor to wrap existing advisors as well.
+	 * <p>Note: Check the concrete post-processor's javadoc whether it possibly
+	 * changes this flag by default, depending on the nature of its advisor.
+	 */
+	public void setBeforeExistingAdvisors(boolean beforeExistingAdvisors) {
+		this.beforeExistingAdvisors = beforeExistingAdvisors;
+	}
+
 	public void setBeanClassLoader(ClassLoader beanClassLoader) {
 		this.beanClassLoader = beanClassLoader;
 	}
@@ -74,7 +89,13 @@ public Object postProcessAfterInitialization(Object bean, String beanName) {
 		}
 		if (isEligible(bean, beanName)) {
 			if (bean instanceof Advised) {
-				((Advised) bean).addAdvisor(0, this.advisor);
+				Advised advised = (Advised) bean;
+				if (this.beforeExistingAdvisors) {
+					advised.addAdvisor(0, this.advisor);
+				}
+				else {
+					advised.addAdvisor(this.advisor);
+				}
 				return bean;
 			}
 			else {
diff --git a/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java b/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java
index 06010d6710eb..d66adc843cc5 100644
--- a/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java
+++ b/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.java
@@ -152,11 +152,11 @@ public abstract class AbstractAutoProxyCreator extends ProxyConfig
 	 * @param order ordering value
 	 */
 	public final void setOrder(int order) {
-	  this.order = order;
+		this.order = order;
 	}
 
 	public final int getOrder() {
-	  return this.order;
+		return this.order;
 	}
 
 	/**
diff --git a/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java
index 96237b86d173..7fbfbf560445 100644
--- a/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java
+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,8 +17,8 @@
 package org.springframework.aop.interceptor;
 
 import java.lang.reflect.Method;
-import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 
 import org.springframework.beans.BeansException;
@@ -45,7 +45,7 @@
  */
 public abstract class AsyncExecutionAspectSupport implements BeanFactoryAware {
 
-	private final Map<Method, AsyncTaskExecutor> executors = new HashMap<Method, AsyncTaskExecutor>();
+	private final Map<Method, AsyncTaskExecutor> executors = new ConcurrentHashMap<Method, AsyncTaskExecutor>(16);
 
 	private Executor defaultExecutor;
 
@@ -59,7 +59,7 @@ public abstract class AsyncExecutionAspectSupport implements BeanFactoryAware {
 	 * @param defaultExecutor the executor to use when executing asynchronous methods
 	 */
 	public AsyncExecutionAspectSupport(Executor defaultExecutor) {
-		this.setExecutor(defaultExecutor);
+		this.defaultExecutor = defaultExecutor;
 	}
 
 
@@ -90,24 +90,25 @@ public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
 	 * @return the executor to use (never {@code null})
 	 */
 	protected AsyncTaskExecutor determineAsyncExecutor(Method method) {
-		if (!this.executors.containsKey(method)) {
-			Executor executor = this.defaultExecutor;
+		AsyncTaskExecutor executor = this.executors.get(method);
+		if (executor == null) {
+			Executor executorToUse = this.defaultExecutor;
 			String qualifier = getExecutorQualifier(method);
 			if (StringUtils.hasLength(qualifier)) {
-				Assert.notNull(this.beanFactory,
-						"BeanFactory must be set on " + this.getClass().getSimpleName() +
-						" to access qualified executor [" + qualifier + "]");
-				executor = BeanFactoryAnnotationUtils.qualifiedBeanOfType(
+				Assert.notNull(this.beanFactory, "BeanFactory must be set on " + getClass().getSimpleName() +
+						" to access qualified executor '" + qualifier + "'");
+				executorToUse = BeanFactoryAnnotationUtils.qualifiedBeanOfType(
 						this.beanFactory, Executor.class, qualifier);
 			}
-			if (executor instanceof AsyncTaskExecutor) {
-				this.executors.put(method, (AsyncTaskExecutor) executor);
-			}
-			else if (executor != null) {
-				this.executors.put(method, new TaskExecutorAdapter(executor));
+			else if (executorToUse == null) {
+				throw new IllegalStateException("No executor qualifier specified and no default executor set on " +
+						getClass().getSimpleName() + " either");
 			}
+			executor = (executorToUse instanceof AsyncTaskExecutor ?
+					(AsyncTaskExecutor) executorToUse : new TaskExecutorAdapter(executorToUse));
+			this.executors.put(method, executor);
 		}
-		return this.executors.get(method);
+		return executor;
 	}
 
 	/**
diff --git a/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java
index 792639b1c6f0..daa23a329364 100644
--- a/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java
+++ b/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,7 +17,6 @@
 package org.springframework.aop.interceptor;
 
 import java.lang.reflect.Method;
-
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
@@ -25,8 +24,11 @@
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
 
+import org.springframework.aop.support.AopUtils;
+import org.springframework.core.BridgeMethodResolver;
 import org.springframework.core.Ordered;
 import org.springframework.core.task.AsyncTaskExecutor;
+import org.springframework.util.ClassUtils;
 import org.springframework.util.ReflectionUtils;
 
 /**
@@ -76,7 +78,11 @@ public AsyncExecutionInterceptor(Executor executor) {
 	 * otherwise.
 	 */
 	public Object invoke(final MethodInvocation invocation) throws Throwable {
-		Future<?> result = this.determineAsyncExecutor(invocation.getMethod()).submit(
+		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);
+		Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);
+		specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
+
+		Future<?> result = determineAsyncExecutor(specificMethod).submit(
 				new Callable<Object>() {
 					public Object call() throws Exception {
 						try {
@@ -91,6 +97,7 @@ public Object call() throws Exception {
 						return null;
 					}
 				});
+
 		if (Future.class.isAssignableFrom(invocation.getMethod().getReturnType())) {
 			return result;
 		}
@@ -100,10 +107,9 @@ public Object call() throws Exception {
 	}
 
 	/**
-	 * {@inheritDoc}
-	 * <p>This implementation is a no-op for compatibility in Spring 3.1.2. Subclasses may
-	 * override to provide support for extracting qualifier information, e.g. via an
-	 * annotation on the given method.
+	 * This implementation is a no-op for compatibility in Spring 3.1.2.
+	 * Subclasses may override to provide support for extracting qualifier information,
+	 * e.g. via an annotation on the given method.
 	 * @return always {@code null}
 	 * @see #determineAsyncExecutor(Method)
 	 * @since 3.1.2
diff --git a/spring-aop/src/main/java/org/springframework/aop/support/DelegatingIntroductionInterceptor.java b/spring-aop/src/main/java/org/springframework/aop/support/DelegatingIntroductionInterceptor.java
index c27d1872cffb..a695d98e4c02 100644
--- a/spring-aop/src/main/java/org/springframework/aop/support/DelegatingIntroductionInterceptor.java
+++ b/spring-aop/src/main/java/org/springframework/aop/support/DelegatingIntroductionInterceptor.java
@@ -95,7 +95,7 @@ private void init(Object delegate) {
 
 
 	/**
-	 * Subclasses may need to override this if they want to  perform custom
+	 * Subclasses may need to override this if they want to perform custom
 	 * behaviour in around advice. However, subclasses should invoke this
 	 * method, which handles introduced interfaces and forwarding to the target.
 	 */
diff --git a/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJExpressionPointcutTests.java b/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJExpressionPointcutTests.java
index 429350b00d85..b042d8155a24 100644
--- a/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJExpressionPointcutTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJExpressionPointcutTests.java
@@ -309,10 +309,6 @@ private void assertMatchesTestBeanClass(ClassFilter classFilter) {
 		assertTrue("Expression should match TestBean class", classFilter.matches(TestBean.class));
 	}
 
-	private void assertDoesNotMatchStringClass(ClassFilter classFilter) {
-		assertFalse("Expression should not match String class", classFilter.matches(String.class));
-	}
-
 	@Test
 	public void testWithUnsupportedPointcutPrimitive() throws Exception {
 		String expression = "call(int org.springframework.tests.sample.beans.TestBean.getAge())";
diff --git a/spring-aop/src/test/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPointTests.java b/spring-aop/src/test/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPointTests.java
index 551756eea73a..0e0e4377c9ad 100644
--- a/spring-aop/src/test/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPointTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPointTests.java
@@ -139,7 +139,7 @@ public void testCanGetSourceLocationFromJoinPoint() {
 			@Override
 			public void before(Method method, Object[] args, Object target) throws Throwable {
 				SourceLocation sloc = AbstractAspectJAdvice.currentJoinPoint().getSourceLocation();
-				assertEquals("Same source location must be returned on subsequent requests",  sloc, AbstractAspectJAdvice.currentJoinPoint().getSourceLocation());
+				assertEquals("Same source location must be returned on subsequent requests", sloc, AbstractAspectJAdvice.currentJoinPoint().getSourceLocation());
 				assertEquals(TestBean.class, sloc.getWithinType());
 				try {
 					sloc.getLine();
@@ -172,7 +172,7 @@ public void testCanGetStaticPartFromJoinPoint() {
 			@Override
 			public void before(Method method, Object[] args, Object target) throws Throwable {
 				StaticPart staticPart = AbstractAspectJAdvice.currentJoinPoint().getStaticPart();
-				assertEquals("Same static part must be returned on subsequent requests",  staticPart, AbstractAspectJAdvice.currentJoinPoint().getStaticPart());
+				assertEquals("Same static part must be returned on subsequent requests", staticPart, AbstractAspectJAdvice.currentJoinPoint().getStaticPart());
 				assertEquals(ProceedingJoinPoint.METHOD_EXECUTION, staticPart.getKind());
 				assertSame(AbstractAspectJAdvice.currentJoinPoint().getSignature(), staticPart.getSignature());
 				assertEquals(AbstractAspectJAdvice.currentJoinPoint().getSourceLocation(), staticPart.getSourceLocation());
diff --git a/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests.java b/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests.java
index 13635c2c6d15..bc9f1b4f626e 100644
--- a/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests.java
@@ -89,6 +89,8 @@ public void testMatchGenericArgument() {
 
 	@Test
 	public void testMatchVarargs() throws SecurityException, NoSuchMethodException {
+
+		@SuppressWarnings("unused")
 		class MyTemplate {
 			public int queryForInt(String sql, Object... params) {
 				return 0;
diff --git a/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests.java b/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests.java
index 273869e8a0a0..d0009394a137 100644
--- a/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests.java
@@ -15,7 +15,14 @@
  */
 package org.springframework.aop.aspectj.annotation;
 
-import static org.junit.Assert.*;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.io.FileNotFoundException;
 import java.lang.annotation.Retention;
@@ -39,9 +46,7 @@
 import org.aspectj.lang.annotation.DeclarePrecedence;
 import org.aspectj.lang.annotation.Pointcut;
 import org.aspectj.lang.reflect.MethodSignature;
-
 import org.junit.Test;
-
 import org.springframework.aop.Advisor;
 import org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory.SyntheticInstantiationAdvisor;
 import org.springframework.aop.framework.Advised;
@@ -52,14 +57,14 @@
 import org.springframework.core.OrderComparator;
 import org.springframework.core.Ordered;
 import org.springframework.core.annotation.Order;
+import org.springframework.tests.sample.beans.ITestBean;
+import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.util.ObjectUtils;
 
 import test.aop.DefaultLockable;
 import test.aop.Lockable;
 import test.aop.PerTargetAspect;
 import test.aop.TwoAdviceAspect;
-import org.springframework.tests.sample.beans.ITestBean;
-import org.springframework.tests.sample.beans.TestBean;
 
 /**
  * Abstract tests for AspectJAdvisorFactory.
@@ -385,7 +390,7 @@ public void testIntroductionOnTargetImplementingInterface() {
 						CannotBeUnlocked.class
 				),
 				CannotBeUnlocked.class);
-		assertTrue(proxy instanceof Lockable);
+		assertThat(proxy, instanceOf(Lockable.class));
 		Lockable lockable = proxy;
 		assertTrue("Already locked", lockable.locked());
 		lockable.lock();
@@ -399,7 +404,6 @@ public void testIntroductionOnTargetImplementingInterface() {
 		}
 	}
 
-	@SuppressWarnings("unchecked")
 	@Test
 	public void testIntroductionOnTargetExcludedByTypePattern() {
 		LinkedList target = new LinkedList();
@@ -442,7 +446,7 @@ public void XtestIntroductionWithArgumentBinding() {
 		Modifiable modifiable = (Modifiable) createProxy(target,
 				advisors,
 				ITestBean.class);
-		assertTrue(modifiable instanceof Modifiable);
+		assertThat(modifiable, instanceOf(Modifiable.class));
 		Lockable lockable = (Lockable) modifiable;
 		assertFalse(lockable.locked());
 
@@ -936,7 +940,7 @@ public void recordModificationIfSetterArgumentDiffersFromOldValue(JoinPoint jp,
 		}
 
 		// Find the current raw value, by invoking the corresponding setter
-		Method correspondingGetter =  getGetterFromSetter(((MethodSignature) jp.getSignature()).getMethod());
+		Method correspondingGetter = getGetterFromSetter(((MethodSignature) jp.getSignature()).getMethod());
 		boolean modified = true;
 		if (correspondingGetter != null) {
 			try {
diff --git a/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparatorTests.java b/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparatorTests.java
index 08d95808edc4..96313821a35c 100644
--- a/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparatorTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparatorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,11 @@
 
 package org.springframework.aop.aspectj.autoproxy;
 
-import static org.junit.Assert.*;
-
 import java.lang.reflect.Method;
 
 import org.junit.Before;
 import org.junit.Test;
+
 import org.springframework.aop.Advisor;
 import org.springframework.aop.AfterReturningAdvice;
 import org.springframework.aop.BeforeAdvice;
@@ -35,11 +34,13 @@
 import org.springframework.aop.aspectj.AspectJPointcutAdvisor;
 import org.springframework.aop.support.DefaultPointcutAdvisor;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Adrian Colyer
  * @author Chris Beams
  */
-public final class AspectJPrecedenceComparatorTests {
+public class AspectJPrecedenceComparatorTests {
 
 	private static final int HIGH_PRECEDENCE_ADVISOR_ORDER = 100;
 	private static final int LOW_PRECEDENCE_ADVISOR_ORDER = 200;
@@ -89,7 +90,7 @@ public void testSameAspectAfterAdvice() {
 	public void testSameAspectOneOfEach() {
 		Advisor advisor1 = createAspectJAfterAdvice(HIGH_PRECEDENCE_ADVISOR_ORDER, EARLY_ADVICE_DECLARATION_ORDER, "someAspect");
 		Advisor advisor2 = createAspectJBeforeAdvice(HIGH_PRECEDENCE_ADVISOR_ORDER, LATE_ADVICE_DECLARATION_ORDER, "someAspect");
-		assertEquals("advisor1 and advisor2 not comparable", 0, this.comparator.compare(advisor1, advisor2));
+		assertEquals("advisor1 and advisor2 not comparable", 1, this.comparator.compare(advisor1, advisor2));
 	}
 
 	@Test
diff --git a/spring-aop/src/test/java/org/springframework/aop/framework/AopProxyUtilsTests.java b/spring-aop/src/test/java/org/springframework/aop/framework/AopProxyUtilsTests.java
index e2abdda7993c..bfd5a35c0792 100644
--- a/spring-aop/src/test/java/org/springframework/aop/framework/AopProxyUtilsTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/framework/AopProxyUtilsTests.java
@@ -137,4 +137,4 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
 		AopProxyUtils.proxiedUserInterfaces(proxy);
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-aop/src/test/java/org/springframework/aop/framework/PrototypeTargetTests.java b/spring-aop/src/test/java/org/springframework/aop/framework/PrototypeTargetTests.java
index d9d43527decc..3c373cdb77a7 100644
--- a/spring-aop/src/test/java/org/springframework/aop/framework/PrototypeTargetTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/framework/PrototypeTargetTests.java
@@ -63,7 +63,6 @@ public void testSingletonProxyWithPrototypeTarget() {
 		assertEquals(10, interceptor.invocationCount);
 	}
 
-
 	public static interface TestBean {
 		public void doSomething();
 	}
diff --git a/spring-aop/src/test/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptorTests.java b/spring-aop/src/test/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptorTests.java
index 633705f06865..f2224a4134d1 100644
--- a/spring-aop/src/test/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptorTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptorTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.aop.framework.adapter;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.lang.reflect.Method;
@@ -33,6 +28,9 @@
 import org.springframework.aop.ThrowsAdvice;
 import org.springframework.tests.aop.advice.MethodCounter;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 
 /**
  * @author Rod Johnson
@@ -144,7 +142,7 @@ public void afterThrowing(RemoteException ex) throws Throwable {
 	}
 
 	@SuppressWarnings("serial")
-	private static class MyThrowsHandler extends MethodCounter implements ThrowsAdvice {
+	static class MyThrowsHandler extends MethodCounter implements ThrowsAdvice {
 		// Full method signature
 		public void afterThrowing(Method m, Object[] args, Object target, IOException ex) {
 			count("ioException");
diff --git a/spring-aop/src/test/java/org/springframework/aop/interceptor/CustomizableTraceInterceptorTests.java b/spring-aop/src/test/java/org/springframework/aop/interceptor/CustomizableTraceInterceptorTests.java
index 0c1c50c9c529..6146571fa6f2 100644
--- a/spring-aop/src/test/java/org/springframework/aop/interceptor/CustomizableTraceInterceptorTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/interceptor/CustomizableTraceInterceptorTests.java
@@ -16,18 +16,13 @@
 
 package org.springframework.aop.interceptor;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import org.aopalliance.intercept.MethodInvocation;
 import org.apache.commons.logging.Log;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rob Harrop
  * @author Rick Evans
diff --git a/spring-aop/src/test/java/org/springframework/aop/interceptor/DebugInterceptorTests.java b/spring-aop/src/test/java/org/springframework/aop/interceptor/DebugInterceptorTests.java
index d0cee0780eb7..5096fe88dd7a 100644
--- a/spring-aop/src/test/java/org/springframework/aop/interceptor/DebugInterceptorTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/interceptor/DebugInterceptorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,18 +16,13 @@
 
 package org.springframework.aop.interceptor;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import org.aopalliance.intercept.MethodInvocation;
 import org.apache.commons.logging.Log;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for the {@link DebugInterceptor} class.
  *
diff --git a/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposeInvocationInterceptorTests.java b/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposeInvocationInterceptorTests.java
index 5405d09831bf..5a0cc658c937 100644
--- a/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposeInvocationInterceptorTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposeInvocationInterceptorTests.java
@@ -44,7 +44,7 @@ public void testXmlConfig() {
 		DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(bf).loadBeanDefinitions(CONTEXT);
 		ITestBean tb = (ITestBean) bf.getBean("proxy");
-		String name= "tony";
+		String name = "tony";
 		tb.setName(name);
 		// Fires context checks
 		assertEquals(name, tb.getName());
diff --git a/spring-aop/src/test/java/org/springframework/aop/interceptor/PerformanceMonitorInterceptorTests.java b/spring-aop/src/test/java/org/springframework/aop/interceptor/PerformanceMonitorInterceptorTests.java
index bf2c45fc2c6e..a08b03064a1e 100644
--- a/spring-aop/src/test/java/org/springframework/aop/interceptor/PerformanceMonitorInterceptorTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/interceptor/PerformanceMonitorInterceptorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,16 +16,13 @@
 
 package org.springframework.aop.interceptor;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.aopalliance.intercept.MethodInvocation;
 import org.apache.commons.logging.Log;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rob Harrop
  * @author Rick Evans
diff --git a/spring-aop/src/test/java/org/springframework/aop/interceptor/SimpleTraceInterceptorTests.java b/spring-aop/src/test/java/org/springframework/aop/interceptor/SimpleTraceInterceptorTests.java
index 96501f2c14f6..5bdeb414dff8 100644
--- a/spring-aop/src/test/java/org/springframework/aop/interceptor/SimpleTraceInterceptorTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/interceptor/SimpleTraceInterceptorTests.java
@@ -16,18 +16,13 @@
 
 package org.springframework.aop.interceptor;
 
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import org.aopalliance.intercept.MethodInvocation;
 import org.apache.commons.logging.Log;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for the {@link SimpleTraceInterceptor} class.
  *
diff --git a/spring-aop/src/test/java/org/springframework/aop/scope/DefaultScopedObjectTests.java b/spring-aop/src/test/java/org/springframework/aop/scope/DefaultScopedObjectTests.java
index 9ec42626db35..4e3d3ca61978 100644
--- a/spring-aop/src/test/java/org/springframework/aop/scope/DefaultScopedObjectTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/scope/DefaultScopedObjectTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,11 @@
 
 package org.springframework.aop.scope;
 
-import static org.mockito.Mockito.mock;
-
 import org.junit.Test;
 import org.springframework.beans.factory.config.ConfigurableBeanFactory;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for the {@link DefaultScopedObject} class.
  *
diff --git a/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests.java b/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests.java
index 1872a457f9a4..cf959b324ca7 100644
--- a/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests.java
+++ b/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests.java
@@ -16,12 +16,6 @@
 
 package org.springframework.aop.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import java.io.Serializable;
 
 import org.aopalliance.intercept.MethodInterceptor;
@@ -39,6 +33,10 @@
 import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.util.SerializationTestUtils;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Chris Beams
@@ -157,7 +155,7 @@ public long getTimeStamp() {
 		//assertTrue(Arrays.binarySearch(pf.getProxiedInterfaces(), TimeStamped.class) != -1);
 		TimeStamped ts = (TimeStamped) pf.getProxy();
 
-		assertTrue(ts instanceof TimeStamped);
+		assertThat(ts, instanceOf(TimeStamped.class));
 		// Shoulnd't proxy framework interfaces
 		assertTrue(!(ts instanceof MethodInterceptor));
 		assertTrue(!(ts instanceof IntroductionInterceptor));
diff --git a/spring-aop/src/test/java/org/springframework/tests/aop/advice/CountingAfterReturningAdvice.java b/spring-aop/src/test/java/org/springframework/tests/aop/advice/CountingAfterReturningAdvice.java
index 5b206516af9a..2b37761fabcb 100644
--- a/spring-aop/src/test/java/org/springframework/tests/aop/advice/CountingAfterReturningAdvice.java
+++ b/spring-aop/src/test/java/org/springframework/tests/aop/advice/CountingAfterReturningAdvice.java
@@ -33,4 +33,4 @@ public void afterReturning(Object o, Method m, Object[] args, Object target) thr
 		count(m);
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-aop/src/test/java/org/springframework/tests/aop/advice/MyThrowsHandler.java b/spring-aop/src/test/java/org/springframework/tests/aop/advice/MyThrowsHandler.java
index 96edd1280cda..cb2d10d6ab63 100644
--- a/spring-aop/src/test/java/org/springframework/tests/aop/advice/MyThrowsHandler.java
+++ b/spring-aop/src/test/java/org/springframework/tests/aop/advice/MyThrowsHandler.java
@@ -24,4 +24,4 @@ public void afterThrowing(RemoteException ex) throws Throwable {
 	public void afterThrowing(Method m, Exception ex) throws Throwable {
 		throw new UnsupportedOperationException("Shouldn't be called");
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-aop/src/test/java/test/annotation/EmptySpringAnnotation.java b/spring-aop/src/test/java/test/annotation/EmptySpringAnnotation.java
index 60c43c858ff6..140f0fee3d4d 100644
--- a/spring-aop/src/test/java/test/annotation/EmptySpringAnnotation.java
+++ b/spring-aop/src/test/java/test/annotation/EmptySpringAnnotation.java
@@ -25,4 +25,4 @@
 @Target(ElementType.TYPE)
 public @interface EmptySpringAnnotation {
 
-}
\ No newline at end of file
+}
diff --git a/spring-aop/src/test/java/test/aop/Lockable.java b/spring-aop/src/test/java/test/aop/Lockable.java
index 039b06e8a7d6..e62a4e2ff324 100644
--- a/spring-aop/src/test/java/test/aop/Lockable.java
+++ b/spring-aop/src/test/java/test/aop/Lockable.java
@@ -30,4 +30,4 @@ public interface Lockable {
 	void unlock();
 
 	boolean locked();
-}
\ No newline at end of file
+}
diff --git a/spring-aop/src/test/java/test/aop/PerTargetAspect.java b/spring-aop/src/test/java/test/aop/PerTargetAspect.java
index 3896f2dc7ab6..7c8c1fec83d7 100644
--- a/spring-aop/src/test/java/test/aop/PerTargetAspect.java
+++ b/spring-aop/src/test/java/test/aop/PerTargetAspect.java
@@ -33,4 +33,4 @@ public int getOrder() {
 	public void setOrder(int order) {
 		this.order = order;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-aop/src/test/java/test/aop/TwoAdviceAspect.java b/spring-aop/src/test/java/test/aop/TwoAdviceAspect.java
index 42ee4bf0ca3b..6745457a9d23 100644
--- a/spring-aop/src/test/java/test/aop/TwoAdviceAspect.java
+++ b/spring-aop/src/test/java/test/aop/TwoAdviceAspect.java
@@ -34,4 +34,4 @@ public int returnCallCount(ProceedingJoinPoint pjp) throws Exception {
 	public void countSet(int newAge) throws Exception {
 		++totalCalls;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj
index 85342e838b85..033a083016d2 100644
--- a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerAspect.aj
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
- 
+
 package org.springframework.beans.factory.aspectj;
 
 import org.aspectj.lang.annotation.SuppressAjWarnings;
@@ -23,12 +23,12 @@ import org.springframework.beans.factory.wiring.BeanConfigurerSupport;
  * Abstract superaspect for AspectJ aspects that can perform Dependency
  * Injection on objects, however they may be created. Define the beanCreation()
  * pointcut in subaspects.
- * 
+ *
  * <p>Subaspects may also need a metadata resolution strategy, in the
- * <code>BeanWiringInfoResolver</code> interface. The default implementation
+ * {@code BeanWiringInfoResolver} interface. The default implementation
  * looks for a bean with the same name as the FQN. This is the default name
  * of a bean in a Spring container if the id value is not supplied explicitly.
- * 
+ *
  * @author Rob Harrop
  * @author Rod Johnson
  * @author Adrian Colyer
@@ -62,7 +62,7 @@ public abstract aspect AbstractBeanConfigurerAspect extends BeanConfigurerSuppor
 
 	/**
 	 * The initialization of a new object.
-	 * 
+	 *
 	 * <p>WARNING: Although this pointcut is non-abstract for backwards
 	 * compatibility reasons, it is meant to be overridden to select
 	 * initialization of any configurable bean.
diff --git a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj
index 23b012ecc753..fa8fc6441f3a 100644
--- a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractDependencyInjectionAspect.aj
@@ -17,11 +17,12 @@
 package org.springframework.beans.factory.aspectj;
 
 import org.aspectj.lang.annotation.SuppressAjWarnings;
+import org.aspectj.lang.annotation.control.CodeGenerationHint;
 
 /**
  * Abstract base aspect that can perform Dependency
  * Injection on objects, however they may be created.
- * 
+ *
  * @author Ramnivas Laddad
  * @since 2.5.2
  */
@@ -29,28 +30,29 @@ public abstract aspect AbstractDependencyInjectionAspect {
 	/**
 	 * Select construction join points for objects to inject dependencies
 	 */
-	public abstract pointcut beanConstruction(Object bean); 
+	public abstract pointcut beanConstruction(Object bean);
 
 	/**
 	 * Select deserialization join points for objects to inject dependencies
 	 */
 	public abstract pointcut beanDeserialization(Object bean);
-	
+
 	/**
 	 * Select join points in a configurable bean
 	 */
 	public abstract pointcut inConfigurableBean();
-	
+
 	/**
 	 * Select join points in beans to be configured prior to construction?
 	 * By default, use post-construction injection matching the default in the Configurable annotation.
 	 */
 	public pointcut preConstructionConfiguration() : if(false);
-	
+
 	/**
-	 * Select the most-specific initialization join point 
+	 * Select the most-specific initialization join point
 	 * (most concrete class) for the initialization of an instance.
 	 */
+	@CodeGenerationHint(ifNameSuffix="6f1")
 	public pointcut mostSpecificSubTypeConstruction() :
 		if(thisJoinPoint.getSignature().getDeclaringType() == thisJoinPoint.getThis().getClass());
 
@@ -58,25 +60,25 @@ public abstract aspect AbstractDependencyInjectionAspect {
 	 * Select least specific super type that is marked for DI (so that injection occurs only once with pre-construction inejection
 	 */
 	public abstract pointcut leastSpecificSuperTypeConstruction();
-		
+
 	/**
 	 * Configure the bean
 	 */
 	public abstract void configureBean(Object bean);
 
-	
-	private pointcut preConstructionCondition() : 
+
+	private pointcut preConstructionCondition() :
 		leastSpecificSuperTypeConstruction() && preConstructionConfiguration();
-	
+
 	private pointcut postConstructionCondition() :
 		mostSpecificSubTypeConstruction() && !preConstructionConfiguration();
-	
+
 	/**
 	 * Pre-construction configuration.
 	 */
 	@SuppressAjWarnings("adviceDidNotMatch")
-	before(Object bean) : 
-		beanConstruction(bean) && preConstructionCondition() && inConfigurableBean()  { 
+	before(Object bean) :
+		beanConstruction(bean) && preConstructionCondition() && inConfigurableBean()  {
 		configureBean(bean);
 	}
 
@@ -84,18 +86,18 @@ public abstract aspect AbstractDependencyInjectionAspect {
 	 * Post-construction configuration.
 	 */
 	@SuppressAjWarnings("adviceDidNotMatch")
-	after(Object bean) returning : 
+	after(Object bean) returning :
 		beanConstruction(bean) && postConstructionCondition() && inConfigurableBean() {
 		configureBean(bean);
 	}
-	
+
 	/**
 	 * Post-deserialization configuration.
 	 */
 	@SuppressAjWarnings("adviceDidNotMatch")
-	after(Object bean) returning : 
+	after(Object bean) returning :
 		beanDeserialization(bean) && inConfigurableBean() {
 		configureBean(bean);
 	}
-	
+
 }
diff --git a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.aj b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.aj
index 8e8b634ef0fb..8270d6962d5b 100644
--- a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AbstractInterfaceDrivenDependencyInjectionAspect.aj
@@ -26,36 +26,36 @@ import java.io.Serializable;
  * upon deserialization. Subaspects need to simply provide definition for the configureBean() method. This
  * method may be implemented without relying on Spring container if so desired.
  * </p>
- * <p> 
+ * <p>
  * There are two cases that needs to be handled:
  * <ol>
- *   <li>Normal object creation via the '<code>new</code>' operator: this is
- *       taken care of by advising <code>initialization()</code> join points.</li>
+ *   <li>Normal object creation via the '{@code new}' operator: this is
+ *       taken care of by advising {@code initialization()} join points.</li>
  *   <li>Object creation through deserialization: since no constructor is
  *       invoked during deserialization, the aspect needs to advise a method that a
  *       deserialization mechanism is going to invoke. Ideally, we should not
  *       require user classes to implement any specific method. This implies that
  *       we need to <i>introduce</i> the chosen method. We should also handle the cases
  *       where the chosen method is already implemented in classes (in which case,
- *       the user's implementation for that method should take precedence over the 
+ *       the user's implementation for that method should take precedence over the
  *       introduced implementation). There are a few choices for the chosen method:
  *       <ul>
  *       <li>readObject(ObjectOutputStream): Java requires that the method must be
- *           <code>private</p>. Since aspects cannot introduce a private member, 
+ *           {@code private}</p>. Since aspects cannot introduce a private member,
  *           while preserving its name, this option is ruled out.</li>
- * 		 <li>readResolve(): Java doesn't pose any restriction on an access specifier. 
- *           Problem solved! There is one (minor) limitation of this approach in 
- *           that if a user class already has this method, that method must be 
- *           <code>public</code>. However, this shouldn't be a big burden, since
- *           use cases that need classes to implement readResolve() (custom enums, 
+ * 		 <li>readResolve(): Java doesn't pose any restriction on an access specifier.
+ *           Problem solved! There is one (minor) limitation of this approach in
+ *           that if a user class already has this method, that method must be
+ *           {@code public}. However, this shouldn't be a big burden, since
+ *           use cases that need classes to implement readResolve() (custom enums,
  *           for example) are unlikely to be marked as &#64;Configurable, and
- *           in any case asking to make that method <code>public</code> should not
+ *           in any case asking to make that method {@code public} should not
  *           pose any undue burden.</li>
  *       </ul>
- *       The minor collaboration needed by user classes (i.e., that the 
- *       implementation of <code>readResolve()</code>, if any, must be 
- *       <code>public</code>) can be lifted as well if we were to use an 
- *       experimental feature in AspectJ - the <code>hasmethod()</code> PCD.</li>
+ *       The minor collaboration needed by user classes (i.e., that the
+ *       implementation of {@code readResolve()}, if any, must be
+ *       {@code public}) can be lifted as well if we were to use an
+ *       experimental feature in AspectJ - the {@code hasmethod()} PCD.</li>
  * </ol>
 
  * <p>
@@ -63,7 +63,7 @@ import java.io.Serializable;
  * is to use a 'declare parents' statement another aspect (a subaspect of this aspect would be a logical choice)
  * that declares the classes that need to be configured by supplying the {@link ConfigurableObject} interface.
  * </p>
- * 
+ *
  * @author Ramnivas Laddad
  * @since 2.5.2
  */
@@ -71,8 +71,8 @@ public abstract aspect AbstractInterfaceDrivenDependencyInjectionAspect extends
 	/**
 	 * Select initialization join point as object construction
 	 */
-	public pointcut beanConstruction(Object bean) : 
-		initialization(ConfigurableObject+.new(..)) && this(bean); 
+	public pointcut beanConstruction(Object bean) :
+		initialization(ConfigurableObject+.new(..)) && this(bean);
 
 	/**
 	 * Select deserialization join point made available through ITDs for ConfigurableDeserializationSupport
@@ -80,40 +80,40 @@ public abstract aspect AbstractInterfaceDrivenDependencyInjectionAspect extends
 	public pointcut beanDeserialization(Object bean) :
 		execution(Object ConfigurableDeserializationSupport+.readResolve()) &&
 		this(bean);
-			
+
 	public pointcut leastSpecificSuperTypeConstruction() : initialization(ConfigurableObject.new(..));
-	
-	
-	
+
+
+
 	// Implementation to support re-injecting dependencies once an object is deserialized
 	/**
-	 * Declare any class implementing Serializable and ConfigurableObject as also implementing 
-	 * ConfigurableDeserializationSupport. This allows us to introduce the readResolve() 
+	 * Declare any class implementing Serializable and ConfigurableObject as also implementing
+	 * ConfigurableDeserializationSupport. This allows us to introduce the readResolve()
 	 * method and select it with the beanDeserialization() pointcut.
-	 * 
+	 *
 	 * <p>Here is an improved version that uses the hasmethod() pointcut and lifts
 	 * even the minor requirement on user classes:
 	 *
 	 * <pre class="code">declare parents: ConfigurableObject+ Serializable+
-	 *		            && !hasmethod(Object readResolve() throws ObjectStreamException) 
+	 *		            && !hasmethod(Object readResolve() throws ObjectStreamException)
 	 *		            implements ConfigurableDeserializationSupport;
 	 * </pre>
 	 */
-	declare parents: 
+	declare parents:
 		ConfigurableObject+ && Serializable+	implements ConfigurableDeserializationSupport;
-	
+
 	/**
-	 * A marker interface to which the <code>readResolve()</code> is introduced.
+	 * A marker interface to which the {@code readResolve()} is introduced.
 	 */
 	static interface ConfigurableDeserializationSupport extends Serializable {
 	}
-	
+
 	/**
-	 * Introduce the <code>readResolve()</code> method so that we can advise its
+	 * Introduce the {@code readResolve()} method so that we can advise its
 	 * execution to configure the object.
-	 * 
+	 *
 	 * <p>Note if a method with the same signature already exists in a
-	 * <code>Serializable</code> class of ConfigurableObject type,
+	 * {@code Serializable} class of ConfigurableObject type,
 	 * that implementation will take precedence (a good thing, since we are
 	 * merely interested in an opportunity to detect deserialization.)
 	 */
diff --git a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.aj b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.aj
index 4cdc292dbbcc..2f1e91ccd23e 100644
--- a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/AnnotationBeanConfigurerAspect.aj
@@ -18,6 +18,7 @@ package org.springframework.beans.factory.aspectj;
 
 import java.io.Serializable;
 
+import org.aspectj.lang.annotation.control.CodeGenerationHint;
 import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
@@ -32,7 +33,7 @@ import org.springframework.beans.factory.wiring.BeanConfigurerSupport;
  * annotation to identify which classes need autowiring.
  *
  * <p>The bean name to look up will be taken from the
- * <code>&#64;Configurable</code> annotation if specified, otherwise the
+ * {@code &#64;Configurable} annotation if specified, otherwise the
  * default bean name to look up will be the FQN of the class being configured.
  *
  * @author Rod Johnson
@@ -43,7 +44,7 @@ import org.springframework.beans.factory.wiring.BeanConfigurerSupport;
  * @see org.springframework.beans.factory.annotation.Configurable
  * @see org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolver
  */
-public aspect AnnotationBeanConfigurerAspect 
+public aspect AnnotationBeanConfigurerAspect
 		extends AbstractInterfaceDrivenDependencyInjectionAspect
 		implements BeanFactoryAware, InitializingBean, DisposableBean {
 
@@ -51,7 +52,7 @@ public aspect AnnotationBeanConfigurerAspect
 
 	public pointcut inConfigurableBean() : @this(Configurable);
 
-	public pointcut preConstructionConfiguration() : preConstructionConfigurationSupport(*); 
+	public pointcut preConstructionConfiguration() : preConstructionConfigurationSupport(*);
 
 	declare parents: @Configurable * implements ConfigurableObject;
 
@@ -77,13 +78,14 @@ public aspect AnnotationBeanConfigurerAspect
 	/*
 	 * An intermediary to match preConstructionConfiguration signature (that doesn't expose the annotation object)
 	 */
+	@CodeGenerationHint(ifNameSuffix="bb0")
 	private pointcut preConstructionConfigurationSupport(Configurable c) : @this(c) && if(c.preConstruction());
 
 	/*
-	 * This declaration shouldn't be needed, 
+	 * This declaration shouldn't be needed,
 	 * except for an AspectJ bug (https://bugs.eclipse.org/bugs/show_bug.cgi?id=214559)
 	 */
-	declare parents: @Configurable Serializable+ 
+	declare parents: @Configurable Serializable+
 		implements ConfigurableDeserializationSupport;
 
 }
diff --git a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/GenericInterfaceDrivenDependencyInjectionAspect.aj b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/GenericInterfaceDrivenDependencyInjectionAspect.aj
index 03f446ca7893..b4a3d93d1d3a 100644
--- a/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/GenericInterfaceDrivenDependencyInjectionAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/beans/factory/aspectj/GenericInterfaceDrivenDependencyInjectionAspect.aj
@@ -17,24 +17,24 @@ package org.springframework.beans.factory.aspectj;
 
 /**
  * Generic-based dependency injection aspect.
- * <p> 
- * This aspect allows users to implement efficient, type-safe dependency injection without 
+ * <p>
+ * This aspect allows users to implement efficient, type-safe dependency injection without
  * the use of the &#64;Configurable annotation.
- * 
- * The subaspect of this aspect doesn't need to include any AOP constructs. 
- * For example, here is a subaspect that configures the <code>PricingStrategyClient</code> objects.
+ *
+ * The subaspect of this aspect doesn't need to include any AOP constructs.
+ * For example, here is a subaspect that configures the {@code PricingStrategyClient} objects.
  * <pre>
- * aspect PricingStrategyDependencyInjectionAspect 
+ * aspect PricingStrategyDependencyInjectionAspect
  *        extends GenericInterfaceDrivenDependencyInjectionAspect<PricingStrategyClient> {
  *     private PricingStrategy pricingStrategy;
- *     
- *     public void configure(PricingStrategyClient bean) { 
- *         bean.setPricingStrategy(pricingStrategy); 
+ *
+ *     public void configure(PricingStrategyClient bean) {
+ *         bean.setPricingStrategy(pricingStrategy);
+ *     }
+ *
+ *     public void setPricingStrategy(PricingStrategy pricingStrategy) {
+ *         this.pricingStrategy = pricingStrategy;
  *     }
- *     
- *     public void setPricingStrategy(PricingStrategy pricingStrategy) { 
- *         this.pricingStrategy = pricingStrategy; 
- *     } 
  * }
  * </pre>
  * @author Ramnivas Laddad
@@ -42,13 +42,13 @@ package org.springframework.beans.factory.aspectj;
  */
 public abstract aspect GenericInterfaceDrivenDependencyInjectionAspect<I> extends AbstractInterfaceDrivenDependencyInjectionAspect {
     declare parents: I implements ConfigurableObject;
-           
+
 	public pointcut inConfigurableBean() : within(I+);
-	
+
 	public final void configureBean(Object bean) {
 		configure((I)bean);
 	}
-	
-	// Unfortunately, erasure used with generics won't allow to use the same named method 
+
+	// Unfortunately, erasure used with generics won't allow to use the same named method
 	protected abstract void configure(I bean);
 }
diff --git a/spring-aspects/src/main/java/org/springframework/cache/aspectj/AbstractCacheAspect.aj b/spring-aspects/src/main/java/org/springframework/cache/aspectj/AbstractCacheAspect.aj
index dbe15b8fb3a2..ce68942d4058 100644
--- a/spring-aspects/src/main/java/org/springframework/cache/aspectj/AbstractCacheAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/cache/aspectj/AbstractCacheAspect.aj
@@ -62,7 +62,7 @@ public abstract aspect AbstractCacheAspect extends CacheAspectSupport {
 			}
 		};
 
-		return execute(aspectJInvoker, thisJoinPoint.getTarget(), method, thisJoinPoint.getArgs());	
+		return execute(aspectJInvoker, thisJoinPoint.getTarget(), method, thisJoinPoint.getArgs());
 	}
 
 	/**
diff --git a/spring-aspects/src/main/java/org/springframework/context/annotation/aspectj/SpringConfiguredConfiguration.java b/spring-aspects/src/main/java/org/springframework/context/annotation/aspectj/SpringConfiguredConfiguration.java
index 51347810dd07..8534fd76b5a3 100644
--- a/spring-aspects/src/main/java/org/springframework/context/annotation/aspectj/SpringConfiguredConfiguration.java
+++ b/spring-aspects/src/main/java/org/springframework/context/annotation/aspectj/SpringConfiguredConfiguration.java
@@ -29,7 +29,7 @@
  * Configurable}.
  *
  * <p>This configuration class is automatically imported when using the @{@link
- * EnableSpringConfigured} annotation.  See {@code @EnableSpringConfigured} Javadoc for
+ * EnableSpringConfigured} annotation. See {@code @EnableSpringConfigured} Javadoc for
  * complete usage details.
  *
  * @author Chris Beams
diff --git a/spring-aspects/src/main/java/org/springframework/mock/staticmock/AbstractMethodMockingControl.aj b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AbstractMethodMockingControl.aj
index 7ab3fcd0c34a..972a32485939 100644
--- a/spring-aspects/src/main/java/org/springframework/mock/staticmock/AbstractMethodMockingControl.aj
+++ b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AbstractMethodMockingControl.aj
@@ -23,9 +23,9 @@ import java.util.List;
 /**
  * Abstract aspect to enable mocking of methods picked out by a pointcut.
  * Sub-aspects must define the mockStaticsTestMethod() pointcut to
- * indicate call stacks when mocking should be triggered, and the 
+ * indicate call stacks when mocking should be triggered, and the
  * methodToMock() pointcut to pick out a method invocations to mock.
- * 
+ *
  * @author Rod Johnson
  * @author Ramnivas Laddad
  */
@@ -42,7 +42,7 @@ public abstract aspect AbstractMethodMockingControl percflow(mockStaticsTestMeth
 	// Represents a list of expected calls to static entity methods
 	// Public to allow inserted code to access: is this normal??
 	public class Expectations {
-		
+
 		// Represents an expected call to a static entity method
 		private class Call {
 			private final String signature;
@@ -50,21 +50,21 @@ public abstract aspect AbstractMethodMockingControl percflow(mockStaticsTestMeth
 
 			private Object responseObject; // return value or throwable
 			private CallResponse responseType = CallResponse.nothing;
-			
+
 			public Call(String name, Object[] args) {
 				this.signature = name;
 				this.args = args;
 			}
-			
+
 			public boolean hasResponseSpecified() {
 				return responseType != CallResponse.nothing;
 			}
-			
+
 			public void setReturnVal(Object retVal) {
 				this.responseObject = retVal;
 				responseType = CallResponse.return_;
 			}
-			
+
 			public void setThrow(Throwable throwable) {
 				this.responseObject = throwable;
 				responseType = CallResponse.throw_;
@@ -89,7 +89,7 @@ public abstract aspect AbstractMethodMockingControl percflow(mockStaticsTestMeth
 				}
 			}
 		}
-		
+
 		private List<Call> calls = new LinkedList<Call>();
 
 		// Calls already verified
@@ -101,7 +101,7 @@ public abstract aspect AbstractMethodMockingControl percflow(mockStaticsTestMeth
 						+ " calls, received " + verified);
 			}
 		}
-		
+
 		/**
 		 * Validate the call and provide the expected return value
 		 * @param lastSig
@@ -175,7 +175,7 @@ public abstract aspect AbstractMethodMockingControl percflow(mockStaticsTestMeth
 			return expectations.respond(thisJoinPointStaticPart.toLongString(), thisJoinPoint.getArgs());
 		}
 	}
-	
+
 	public void expectReturnInternal(Object retVal) {
 		if (!recording) {
 			throw new IllegalStateException("Not recording: Cannot set return value");
diff --git a/spring-aspects/src/main/java/org/springframework/mock/staticmock/AnnotationDrivenStaticEntityMockingControl.aj b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AnnotationDrivenStaticEntityMockingControl.aj
index 031978ca91f5..816f6a1e424a 100644
--- a/spring-aspects/src/main/java/org/springframework/mock/staticmock/AnnotationDrivenStaticEntityMockingControl.aj
+++ b/spring-aspects/src/main/java/org/springframework/mock/staticmock/AnnotationDrivenStaticEntityMockingControl.aj
@@ -18,16 +18,16 @@ package org.springframework.mock.staticmock;
 
 /**
  * Annotation-based aspect to use in test build to enable mocking static methods
- * on JPA-annotated <code>@Entity</code> classes, as used by Roo for finders.
+ * on JPA-annotated {@code @Entity} classes, as used by Roo for finders.
  *
- * <p>Mocking will occur in the call stack of any method in a class (typically a test class) 
- * that is annotated with the @MockStaticEntityMethods annotation. 
+ * <p>Mocking will occur in the call stack of any method in a class (typically a test class)
+ * that is annotated with the @MockStaticEntityMethods annotation.
  *
  * <p>Also provides static methods to simplify the programming model for
  * entering playback mode and setting expected return values.
  *
  * <p>Usage:
- * <ol> 
+ * <ol>
  * <li>Annotate a test class with @MockStaticEntityMethods.
  * <li>In each test method, AnnotationDrivenStaticEntityMockingControl will begin in recording mode.
  * Invoke static methods on Entity classes, with each recording-mode invocation
@@ -37,20 +37,20 @@ package org.springframework.mock.staticmock;
  * <li>Call the code you wish to test that uses the static methods. Verification will
  * occur automatically.
  * </ol>
- * 
+ *
  * @author Rod Johnson
  * @author Ramnivas Laddad
  * @see MockStaticEntityMethods
  */
 public aspect AnnotationDrivenStaticEntityMockingControl extends AbstractMethodMockingControl {
-	
+
 	/**
 	 * Stop recording mock calls and enter playback state
 	 */
 	public static void playback() {
 		AnnotationDrivenStaticEntityMockingControl.aspectOf().playbackInternal();
 	}
-	
+
 	public static void expectReturn(Object retVal) {
 		AnnotationDrivenStaticEntityMockingControl.aspectOf().expectReturnInternal(retVal);
 	}
diff --git a/spring-aspects/src/main/java/org/springframework/orm/jpa/aspectj/JpaExceptionTranslatorAspect.aj b/spring-aspects/src/main/java/org/springframework/orm/jpa/aspectj/JpaExceptionTranslatorAspect.aj
index 6ff44249d082..131c82beefdc 100644
--- a/spring-aspects/src/main/java/org/springframework/orm/jpa/aspectj/JpaExceptionTranslatorAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/orm/jpa/aspectj/JpaExceptionTranslatorAspect.aj
@@ -1,3 +1,19 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package org.springframework.orm.jpa.aspectj;
 
 import javax.persistence.EntityManager;
@@ -9,14 +25,17 @@ import org.springframework.dao.DataAccessException;
 import org.springframework.orm.jpa.EntityManagerFactoryUtils;
 
 public aspect JpaExceptionTranslatorAspect {
-    pointcut entityManagerCall(): call(* EntityManager.*(..)) || call(* EntityManagerFactory.*(..)) || call(* EntityTransaction.*(..)) || call(* Query.*(..));
-    
-    after() throwing(RuntimeException re): entityManagerCall() {     
-    	DataAccessException dex = EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(re);
-    	if (dex != null) {
-    		throw dex;
-    	} else {
-    		throw re;
-    	}        
-    }	
+	pointcut entityManagerCall():
+		call(* EntityManager.*(..)) || call(* EntityManagerFactory.*(..)) ||
+		call(* EntityTransaction.*(..)) || call(* Query.*(..));
+
+	after() throwing(RuntimeException re): entityManagerCall() {
+		DataAccessException dex = EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(re);
+		if (dex != null) {
+			throw dex;
+		}
+		else {
+			throw re;
+		}
+	}
 }
\ No newline at end of file
diff --git a/spring-aspects/src/main/java/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect.aj b/spring-aspects/src/main/java/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect.aj
index 6cb3ad60e398..660b35c13614 100644
--- a/spring-aspects/src/main/java/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/scheduling/aspectj/AbstractAsyncExecutionAspect.aj
@@ -28,7 +28,7 @@ import org.springframework.core.task.AsyncTaskExecutor;
 /**
  * Abstract aspect that routes selected methods asynchronously.
  *
- * <p>This aspect needs to be injected with an implementation of 
+ * <p>This aspect needs to be injected with an implementation of
  * {@link Executor} to activate it for a specific thread pool.
  * Otherwise it will simply delegate all calls synchronously.
  *
diff --git a/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj
index 3ce264d9e1af..f9c70661ae1f 100644
--- a/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AbstractTransactionAspect.aj
@@ -16,8 +16,6 @@
 
 package org.springframework.transaction.aspectj;
 
-import java.lang.reflect.Method;
-
 import org.aspectj.lang.annotation.SuppressAjWarnings;
 import org.aspectj.lang.reflect.MethodSignature;
 import org.springframework.transaction.interceptor.TransactionAspectSupport;
@@ -25,7 +23,7 @@ import org.springframework.transaction.interceptor.TransactionAttributeSource;
 
 /**
  * Abstract superaspect for AspectJ transaction aspects. Concrete
- * subaspects will implement the <code>transactionalMethodExecution()</code>
+ * subaspects will implement the {@code transactionalMethodExecution()}
  * pointcut using a strategy such as Java 5 annotations.
  *
  * <p>Suitable for use inside or outside the Spring IoC container.
@@ -42,45 +40,42 @@ import org.springframework.transaction.interceptor.TransactionAttributeSource;
  *
  * @author Rod Johnson
  * @author Ramnivas Laddad
+ * @author Juergen Hoeller
  * @since 2.0
  */
 public abstract aspect AbstractTransactionAspect extends TransactionAspectSupport {
 
 	/**
-	 * Construct object using the given transaction metadata retrieval strategy.
+	 * Construct the aspect using the given transaction metadata retrieval strategy.
 	 * @param tas TransactionAttributeSource implementation, retrieving Spring
-	 * transaction metadata for each joinpoint. Write the subclass to pass in null
-	 * if it's intended to be configured by Setter Injection.
+	 * transaction metadata for each joinpoint. Implement the subclass to pass in
+	 * {@code null} if it is intended to be configured through Setter Injection.
 	 */
 	protected AbstractTransactionAspect(TransactionAttributeSource tas) {
 		setTransactionAttributeSource(tas);
 	}
 
 	@SuppressAjWarnings("adviceDidNotMatch")
-	before(Object txObject) : transactionalMethodExecution(txObject) {
+	Object around(final Object txObject): transactionalMethodExecution(txObject) {
 		MethodSignature methodSignature = (MethodSignature) thisJoinPoint.getSignature();
-		Method method = methodSignature.getMethod();
-		TransactionInfo txInfo = createTransactionIfNecessary(method, txObject.getClass());
-	}
-
-	@SuppressAjWarnings("adviceDidNotMatch")
-	after(Object txObject) throwing(Throwable t) : transactionalMethodExecution(txObject) {
+		// Adapt to TransactionAspectSupport's invokeWithinTransaction...
 		try {
-      		completeTransactionAfterThrowing(TransactionAspectSupport.currentTransactionInfo(), t);
+			return invokeWithinTransaction(methodSignature.getMethod(), txObject.getClass(), new InvocationCallback() {
+				public Object proceedWithInvocation() throws Throwable {
+					return proceed(txObject);
+				}
+			});
 		}
-		catch (Throwable t2) {
-			logger.error("Failed to close transaction after throwing in a transactional method", t2);
+		catch (RuntimeException ex) {
+			throw ex;
+		}
+		catch (Error err) {
+			throw err;
+		}
+		catch (Throwable thr) {
+			Rethrower.rethrow(thr);
+			throw new IllegalStateException("Should never get here", thr);
 		}
-	}
-
-	@SuppressAjWarnings("adviceDidNotMatch")
-	after(Object txObject) returning() : transactionalMethodExecution(txObject) {
-		commitTransactionAfterReturning(TransactionAspectSupport.currentTransactionInfo());
-	}
-
-	@SuppressAjWarnings("adviceDidNotMatch")
-	after(Object txObject) : transactionalMethodExecution(txObject) {
-		cleanupTransactionInfo(TransactionAspectSupport.currentTransactionInfo());
 	}
 
 	/**
@@ -90,4 +85,22 @@ public abstract aspect AbstractTransactionAspect extends TransactionAspectSuppor
 	 */
 	protected abstract pointcut transactionalMethodExecution(Object txObject);
 
+
+	/**
+	 * Ugly but safe workaround: We need to be able to propagate checked exceptions,
+	 * despite AspectJ around advice supporting specifically declared exceptions only.
+	 */
+	private static class Rethrower {
+
+		public static void rethrow(final Throwable exception) {
+			class CheckedExceptionRethrower<T extends Throwable> {
+				@SuppressWarnings("unchecked")
+				private void rethrow(Throwable exception) throws T {
+					throw (T) exception;
+				}
+			}
+			new CheckedExceptionRethrower<RuntimeException>().rethrow(exception);
+		}
+	}
+
 }
diff --git a/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AnnotationTransactionAspect.aj b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AnnotationTransactionAspect.aj
index 2ea8f9e3f584..70a82b5f4eef 100644
--- a/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AnnotationTransactionAspect.aj
+++ b/spring-aspects/src/main/java/org/springframework/transaction/aspectj/AnnotationTransactionAspect.aj
@@ -21,17 +21,17 @@ import org.springframework.transaction.annotation.Transactional;
 
 /**
  * Concrete AspectJ transaction aspect using Spring's @Transactional annotation.
- * 
+ *
  * <p>When using this aspect, you <i>must</i> annotate the implementation class
  * (and/or methods within that class), <i>not</i> the interface (if any) that
- * the class implements. AspectJ follows Java's rule that annotations on 
+ * the class implements. AspectJ follows Java's rule that annotations on
  * interfaces are <i>not</i> inherited.
  *
  * <p>An @Transactional annotation on a class specifies the default transaction
  * semantics for the execution of any <b>public</b> operation in the class.
  *
  * <p>An @Transactional annotation on a method within the class overrides the
- * default transaction semantics given by the class annotation (if present). 
+ * default transaction semantics given by the class annotation (if present).
  * Any method may be annotated (regardless of visibility).
  * Annotating non-public methods directly is the only way
  * to get transaction demarcation for the execution of such operations.
@@ -49,16 +49,14 @@ public aspect AnnotationTransactionAspect extends AbstractTransactionAspect {
 	}
 
 	/**
-	 * Matches the execution of any public method in a type with the
-	 * Transactional annotation, or any subtype of a type with the
-	 * Transactional annotation.
+	 * Matches the execution of any public method in a type with the Transactional
+	 * annotation, or any subtype of a type with the Transactional annotation.
 	 */
 	private pointcut executionOfAnyPublicMethodInAtTransactionalType() :
 		execution(public * ((@Transactional *)+).*(..)) && within(@Transactional *);
 
 	/**
-	 * Matches the execution of any method with the 
-	 * Transactional annotation.
+	 * Matches the execution of any method with the Transactional annotation.
 	 */
 	private pointcut executionOfTransactionalMethod() :
 		execution(@Transactional * *(..));
@@ -66,7 +64,7 @@ public aspect AnnotationTransactionAspect extends AbstractTransactionAspect {
 	/**
 	 * Definition of pointcut from super aspect - matched join points
 	 * will have Spring transaction management applied.
-	 */	
+	 */
 	protected pointcut transactionalMethodExecution(Object txObject) :
 		(executionOfAnyPublicMethodInAtTransactionalType()
 		 || executionOfTransactionalMethod() )
diff --git a/spring-aspects/src/test/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerTests.java b/spring-aspects/src/test/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerTests.java
index 6ff04cf7b87a..71a10afcaf1b 100644
--- a/spring-aspects/src/test/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerTests.java
+++ b/spring-aspects/src/test/java/org/springframework/beans/factory/aspectj/AbstractBeanConfigurerTests.java
@@ -211,6 +211,7 @@ public void testInterfaceDrivenDependencyInjectionUponDeserialization() throws E
 		MailClientDependencyInjectionAspect.aspectOf().setMailSender(new JavaMailSenderImpl());
 		Order testOrder = new Order();
 		Order deserializedOrder = serializeAndDeserialize(testOrder);
+		assertNotNull(deserializedOrder);
 		assertNotNull("Interface driven injection didn't occur for deserialization", testOrder.mailSender);
 	}
 
@@ -304,7 +305,7 @@ public Object readResolve() throws ObjectStreamException {
 //		}
 //	}
 
-
+	@SuppressWarnings("unused")
 	private static class ShouldNotBeConfiguredBySpring {
 
 		private String name;
@@ -335,6 +336,7 @@ public String getName() {
 
 
 	@Configurable
+	@SuppressWarnings("unused")
 	private static class ShouldBeConfiguredBySpringUsingTypeNameAsBeanName {
 
 		private String name;
@@ -350,6 +352,7 @@ public String getName() {
 
 
 	@Configurable(autowire=Autowire.BY_TYPE)
+	@SuppressWarnings("unused")
 	private static class ShouldBeConfiguredBySpringUsingAutowireByType {
 
 		private TestBean friend = null;
@@ -365,6 +368,7 @@ public void setFriend(TestBean friend) {
 
 
 	@Configurable(autowire=Autowire.BY_NAME)
+	@SuppressWarnings("unused")
 	private static class ValidAutowireByName {
 
 		private TestBean friend = null;
@@ -380,6 +384,7 @@ public void setRamnivas(TestBean friend) {
 
 
 	@Configurable(autowire=Autowire.BY_NAME, dependencyCheck=true)
+	@SuppressWarnings("unused")
 	private static class InvalidAutowireByName {
 
 		private TestBean friend;
@@ -393,7 +398,7 @@ public void setFriend(TestBean friend) {
 		}
 	}
 
-
+	@SuppressWarnings("unused")
 	private static class ArbitraryExistingPojo {
 
 		private TestBean friend;
@@ -426,6 +431,7 @@ public boolean isSingleton() {
 
 
 	@Configurable
+	@SuppressWarnings("unused")
 	private static class BaseBean {
 
 		public int setterCount;
@@ -447,7 +453,7 @@ private static class SubBeanPreConstruction extends BaseBean {
 	}
 
 	@Configurable
-	@SuppressWarnings("serial")
+	@SuppressWarnings({"serial", "unused"})
 	private static class BaseSerializableBean implements Serializable {
 
 		public int setterCount;
@@ -467,6 +473,7 @@ private static class SubSerializableBean extends BaseSerializableBean {
 
 
 	@Aspect
+	@SuppressWarnings("unused")
 	private static class WireArbitraryExistingPojo extends AbstractBeanConfigurerAspect {
 
 		@Pointcut("initialization(ArbitraryExistingPojo.new(..)) && this(beanInstance)")
@@ -477,6 +484,7 @@ protected void beanCreation(Object beanInstance){
 
 
 	@Aspect
+	@SuppressWarnings("unused")
 	private static class AspectThatWillNotBeUsed extends AbstractBeanConfigurerAspect {
 
 		@Pointcut("initialization(ClassThatWillNotActuallyBeWired.new(..)) && this(beanInstance)")
diff --git a/spring-aspects/src/test/java/org/springframework/beans/factory/aspectj/SpringConfiguredWithAutoProxyingTests.java b/spring-aspects/src/test/java/org/springframework/beans/factory/aspectj/SpringConfiguredWithAutoProxyingTests.java
index 1c678ba6b191..aae9ff6cd75c 100644
--- a/spring-aspects/src/test/java/org/springframework/beans/factory/aspectj/SpringConfiguredWithAutoProxyingTests.java
+++ b/spring-aspects/src/test/java/org/springframework/beans/factory/aspectj/SpringConfiguredWithAutoProxyingTests.java
@@ -30,4 +30,4 @@ protected void setUp() throws Exception {
 	public void testSpringConfiguredAndAutoProxyUsedTogether() {
 		; // set up is sufficient to trigger failure if this is going to fail...
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-aspects/src/test/java/org/springframework/cache/config/AnnotatedClassCacheableService.java b/spring-aspects/src/test/java/org/springframework/cache/config/AnnotatedClassCacheableService.java
index 52a1b4265e1d..b81080517983 100644
--- a/spring-aspects/src/test/java/org/springframework/cache/config/AnnotatedClassCacheableService.java
+++ b/spring-aspects/src/test/java/org/springframework/cache/config/AnnotatedClassCacheableService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,6 +25,7 @@
 
 /**
  * @author Costin Leau
+ * @author Phillip Webb
  */
 @Cacheable("default")
 public class AnnotatedClassCacheableService implements CacheableService<Object> {
@@ -40,6 +41,10 @@ public Object conditional(int field) {
 		return null;
 	}
 
+	public Object unless(int arg) {
+		return arg;
+	}
+
 	@CacheEvict("default")
 	public void invalidate(Object arg1) {
 	}
@@ -135,4 +140,4 @@ public Object multiConditionalCacheAndEvict(Object arg1) {
 	public Object multiUpdate(Object arg1) {
 		return arg1;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-aspects/src/test/java/org/springframework/cache/config/CacheableService.java b/spring-aspects/src/test/java/org/springframework/cache/config/CacheableService.java
index 81dd758d19d4..98c1da1e0315 100644
--- a/spring-aspects/src/test/java/org/springframework/cache/config/CacheableService.java
+++ b/spring-aspects/src/test/java/org/springframework/cache/config/CacheableService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
  * Basic service interface.
  *
  * @author Costin Leau
+ * @author Phillip Webb
  */
 public interface CacheableService<T> {
 
@@ -39,6 +40,8 @@ public interface CacheableService<T> {
 
 	T conditional(int field);
 
+	T unless(int arg);
+
 	T key(Object arg1, Object arg2);
 
 	T name(Object arg1);
@@ -67,4 +70,4 @@ public interface CacheableService<T> {
 	T multiConditionalCacheAndEvict(Object arg1);
 
 	T multiUpdate(Object arg1);
-}
\ No newline at end of file
+}
diff --git a/spring-aspects/src/test/java/org/springframework/cache/config/DefaultCacheableService.java b/spring-aspects/src/test/java/org/springframework/cache/config/DefaultCacheableService.java
index 6d83d91c02d8..d29d43894e03 100644
--- a/spring-aspects/src/test/java/org/springframework/cache/config/DefaultCacheableService.java
+++ b/spring-aspects/src/test/java/org/springframework/cache/config/DefaultCacheableService.java
@@ -27,6 +27,7 @@
  * Simple cacheable service
  *
  * @author Costin Leau
+ * @author Phillip Webb
  */
 public class DefaultCacheableService implements CacheableService<Long> {
 
@@ -78,6 +79,12 @@ public Long conditional(int classField) {
 		return counter.getAndIncrement();
 	}
 
+	@Override
+	@Cacheable(value = "default", unless = "#result > 10")
+	public Long unless(int arg) {
+		return (long) arg;
+	}
+
 	@Override
 	@Cacheable(value = "default", key = "#p0")
 	public Long key(Object arg1, Object arg2) {
diff --git a/spring-aspects/src/test/java/org/springframework/transaction/aspectj/TransactionAspectTests.java b/spring-aspects/src/test/java/org/springframework/transaction/aspectj/TransactionAspectTests.java
index 70892e39493d..b69e861933ac 100644
--- a/spring-aspects/src/test/java/org/springframework/transaction/aspectj/TransactionAspectTests.java
+++ b/spring-aspects/src/test/java/org/springframework/transaction/aspectj/TransactionAspectTests.java
@@ -16,19 +16,18 @@
 
 package org.springframework.transaction.aspectj;
 
-import java.lang.reflect.Method;
-
-import junit.framework.AssertionFailedError;
-
 import org.springframework.test.AbstractDependencyInjectionSpringContextTests;
 import org.springframework.tests.transaction.CallCountingTransactionManager;
 import org.springframework.transaction.annotation.AnnotationTransactionAttributeSource;
 import org.springframework.transaction.interceptor.TransactionAspectSupport;
 import org.springframework.transaction.interceptor.TransactionAttribute;
 
+import java.lang.reflect.Method;
+
 /**
  * @author Rod Johnson
  * @author Ramnivas Laddad
+ * @author Juergen Hoeller
  */
 public class TransactionAspectTests extends AbstractDependencyInjectionSpringContextTests {
 
@@ -123,50 +122,63 @@ public void testNotTransactional() throws Throwable {
 
 
 	public void testDefaultCommitOnAnnotatedClass() throws Throwable {
-		testRollback(new TransactionOperationCallback() {
-			public Object performTransactionalOperation() throws Throwable {
-				return annotationOnlyOnClassWithNoInterface.echo(new Exception());
-			}
-		}, false);
+		final Exception ex = new Exception();
+		try {
+			testRollback(new TransactionOperationCallback() {
+				public Object performTransactionalOperation() throws Throwable {
+					return annotationOnlyOnClassWithNoInterface.echo(ex);
+				}
+			}, false);
+			fail("Should have thrown Exception");
+		}
+		catch (Exception ex2) {
+			assertSame(ex, ex2);
+		}
 	}
 
 	public void testDefaultRollbackOnAnnotatedClass() throws Throwable {
-		testRollback(new TransactionOperationCallback() {
-			public Object performTransactionalOperation() throws Throwable {
-				return annotationOnlyOnClassWithNoInterface.echo(new RuntimeException());
-			}
-		}, true);
+		final RuntimeException ex = new RuntimeException();
+		try {
+			testRollback(new TransactionOperationCallback() {
+				public Object performTransactionalOperation() throws Throwable {
+					return annotationOnlyOnClassWithNoInterface.echo(ex);
+				}
+			}, true);
+			fail("Should have thrown RuntimeException");
+		}
+		catch (RuntimeException ex2) {
+			assertSame(ex, ex2);
+		}
 	}
 
 
-	public static class SubclassOfClassWithTransactionalAnnotation extends TransactionalAnnotationOnlyOnClassWithNoInterface {
-	}
-
 	public void testDefaultCommitOnSubclassOfAnnotatedClass() throws Throwable {
-		testRollback(new TransactionOperationCallback() {
-			public Object performTransactionalOperation() throws Throwable {
-				return new SubclassOfClassWithTransactionalAnnotation().echo(new Exception());
-			}
-		}, false);
-	}
-
-	public static class SubclassOfClassWithTransactionalMethodAnnotation extends MethodAnnotationOnClassWithNoInterface {
+		final Exception ex = new Exception();
+		try {
+				testRollback(new TransactionOperationCallback() {
+				public Object performTransactionalOperation() throws Throwable {
+					return new SubclassOfClassWithTransactionalAnnotation().echo(ex);
+				}
+			}, false);
+			fail("Should have thrown Exception");
+		}
+		catch (Exception ex2) {
+			assertSame(ex, ex2);
+		}
 	}
 
 	public void testDefaultCommitOnSubclassOfClassWithTransactionalMethodAnnotated() throws Throwable {
-		testRollback(new TransactionOperationCallback() {
-			public Object performTransactionalOperation() throws Throwable {
-				return new SubclassOfClassWithTransactionalMethodAnnotation().echo(new Exception());
-			}
-		}, false);
-	}
-
-	public static class ImplementsAnnotatedInterface implements ITransactional {
-		public Object echo(Throwable t) throws Throwable {
-			if (t != null) {
-				throw t;
-			}
-			return t;
+		final Exception ex = new Exception();
+		try {
+			testRollback(new TransactionOperationCallback() {
+				public Object performTransactionalOperation() throws Throwable {
+					return new SubclassOfClassWithTransactionalMethodAnnotation().echo(ex);
+				}
+			}, false);
+			fail("Should have thrown Exception");
+		}
+		catch (Exception ex2) {
+			assertSame(ex, ex2);
 		}
 	}
 
@@ -221,18 +233,12 @@ protected void testRollback(TransactionOperationCallback toc, boolean rollback)
 		assertEquals(0, txManager.begun);
 		try {
 			toc.performTransactionalOperation();
-			assertEquals(1, txManager.commits);
-		}
-		catch (Throwable caught) {
-			if (caught instanceof AssertionFailedError) {
-				return;
-			}
 		}
-
-		if (rollback) {
-			assertEquals(1, txManager.rollbacks);
+		finally {
+			assertEquals(1, txManager.begun);
+			assertEquals(rollback ? 0 : 1, txManager.commits);
+			assertEquals(rollback ? 1 : 0, txManager.rollbacks);
 		}
-		assertEquals(1, txManager.begun);
 	}
 
 	protected void testNotTransactional(TransactionOperationCallback toc, Throwable expected) throws Throwable {
@@ -258,4 +264,23 @@ private interface TransactionOperationCallback {
 		Object performTransactionalOperation() throws Throwable;
 	}
 
+
+	public static class SubclassOfClassWithTransactionalAnnotation extends TransactionalAnnotationOnlyOnClassWithNoInterface {
+	}
+
+
+	public static class SubclassOfClassWithTransactionalMethodAnnotation extends MethodAnnotationOnClassWithNoInterface {
+	}
+
+
+	public static class ImplementsAnnotatedInterface implements ITransactional {
+
+		public Object echo(Throwable t) throws Throwable {
+			if (t != null) {
+				throw t;
+			}
+			return t;
+		}
+	}
+
 }
diff --git a/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java
index bac8df4ce6d9..df5def12a8d3 100644
--- a/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java
+++ b/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java
@@ -699,7 +699,7 @@ public Object getPropertyValue(String propertyName) throws BeansException {
 		return nestedBw.getPropertyValue(tokens);
 	}
 
-	private Object getPropertyValue(PropertyTokenHolder tokens) throws BeansException {
+    private Object getPropertyValue(PropertyTokenHolder tokens) throws BeansException {
 		String propertyName = tokens.canonicalName;
 		String actualName = tokens.actualName;
 		PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(actualName);
diff --git a/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java b/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java
index c3609c10c229..6606741ee4e0 100644
--- a/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java
+++ b/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -56,7 +56,7 @@
  *         this.foo = foo;
  *         return this;
  *     }
- * }</pre>
+ * }}</pre>
  * The standard JavaBeans {@code Introspector} will discover the {@code getFoo} read
  * method, but will bypass the {@code #setFoo(Foo)} write method, because its non-void
  * returning signature does not comply with the JavaBeans specification.
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/Aware.java b/spring-beans/src/main/java/org/springframework/beans/factory/Aware.java
index fb107425c36f..f993f1f7135a 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/Aware.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/Aware.java
@@ -19,7 +19,7 @@
 /**
  * Marker superinterface indicating that a bean is eligible to be
  * notified by the Spring container of a particular framework object
- * through a callback-style method.  Actual method signature is
+ * through a callback-style method. Actual method signature is
  * determined by individual subinterfaces, but should typically
  * consist of just one void-returning method that accepts a single
  * argument.
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java
index e1f0e2f3921b..6775dd78edcd 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java
@@ -196,11 +196,11 @@ public void setRequiredParameterValue(boolean requiredParameterValue) {
 	}
 
 	public void setOrder(int order) {
-	  this.order = order;
+		this.order = order;
 	}
 
 	public int getOrder() {
-	  return this.order;
+		return this.order;
 	}
 
 	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.java b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.java
index 74a5e59d240d..62f62dccd9e8 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.java
@@ -109,11 +109,11 @@ public void setDestroyAnnotationType(Class<? extends Annotation> destroyAnnotati
 	}
 
 	public void setOrder(int order) {
-	  this.order = order;
+		this.order = order;
 	}
 
 	public int getOrder() {
-	  return this.order;
+		return this.order;
 	}
 
 
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.java b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.java
index 862dbd6fa6a3..4e945234860b 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.java
@@ -123,11 +123,11 @@ public void setBeanFactory(BeanFactory beanFactory) {
 	}
 
 	public void setOrder(int order) {
-	  this.order = order;
+		this.order = order;
 	}
 
 	public int getOrder() {
-	  return this.order;
+		return this.order;
 	}
 
 
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/config/CustomEditorConfigurer.java b/spring-beans/src/main/java/org/springframework/beans/factory/config/CustomEditorConfigurer.java
index 03e5716fdd79..a9b29f96571c 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/config/CustomEditorConfigurer.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/CustomEditorConfigurer.java
@@ -116,11 +116,11 @@ public class CustomEditorConfigurer implements BeanFactoryPostProcessor, BeanCla
 
 
 	public void setOrder(int order) {
-	  this.order = order;
+		this.order = order;
 	}
 
 	public int getOrder() {
-	  return this.order;
+		return this.order;
 	}
 
 	/**
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/config/RuntimeBeanNameReference.java b/spring-beans/src/main/java/org/springframework/beans/factory/config/RuntimeBeanNameReference.java
index 7477e197cb8e..b23c93e97fd3 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/config/RuntimeBeanNameReference.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/RuntimeBeanNameReference.java
@@ -80,7 +80,7 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-	   return '<' + getBeanName() + '>';
+		return '<' + getBeanName() + '>';
 	}
 
 }
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/config/RuntimeBeanReference.java b/spring-beans/src/main/java/org/springframework/beans/factory/config/RuntimeBeanReference.java
index 836098ff8cd7..e9e5e60a7a5d 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/config/RuntimeBeanReference.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/config/RuntimeBeanReference.java
@@ -107,7 +107,7 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-	   return '<' + getBeanName() + '>';
+		return '<' + getBeanName() + '>';
 	}
 
 }
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java
index c112676ea1d9..09faf0c3b256 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -572,28 +572,30 @@ else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
 	}
 
 	@Override
-	protected Class predictBeanType(String beanName, RootBeanDefinition mbd, Class... typesToMatch) {
-		Class beanClass;
-		if (mbd.getFactoryMethodName() != null) {
-			beanClass = getTypeForFactoryMethod(beanName, mbd, typesToMatch);
-		}
-		else {
-			beanClass = resolveBeanClass(mbd, beanName, typesToMatch);
+	protected Class<?> predictBeanType(String beanName, RootBeanDefinition mbd, Class... typesToMatch) {
+		Class<?> targetType = mbd.getTargetType();
+		if (targetType == null) {
+			targetType = (mbd.getFactoryMethodName() != null ? getTypeForFactoryMethod(beanName, mbd, typesToMatch) :
+					resolveBeanClass(mbd, beanName, typesToMatch));
+			if (ObjectUtils.isEmpty(typesToMatch) || getTempClassLoader() == null) {
+				mbd.setTargetType(targetType);
+			}
 		}
 		// Apply SmartInstantiationAwareBeanPostProcessors to predict the
 		// eventual type after a before-instantiation shortcut.
-		if (beanClass != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
+		if (targetType != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
 			for (BeanPostProcessor bp : getBeanPostProcessors()) {
 				if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
 					SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
-					Class processedType = ibp.predictBeanType(beanClass, beanName);
-					if (processedType != null) {
-						return processedType;
+					Class predicted = ibp.predictBeanType(targetType, beanName);
+					if (predicted != null && (typesToMatch.length != 1 || !FactoryBean.class.equals(typesToMatch[0]) ||
+							FactoryBean.class.isAssignableFrom(predicted))) {
+						return predicted;
 					}
 				}
 			}
 		}
-		return beanClass;
+		return targetType;
 	}
 
 	/**
@@ -610,8 +612,8 @@ protected Class predictBeanType(String beanName, RootBeanDefinition mbd, Class..
 	 * @return the type for the bean if determinable, or {@code null} else
 	 * @see #createBean
 	 */
-	protected Class getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class[] typesToMatch) {
-		Class factoryClass;
+	protected Class<?> getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class[] typesToMatch) {
+		Class<?> factoryClass;
 		boolean isStatic = true;
 
 		String factoryBeanName = mbd.getFactoryBeanName();
@@ -685,7 +687,7 @@ class Holder { Class<?> value = null; }
 		if (factoryBeanName != null && factoryMethodName != null) {
 			// Try to obtain the FactoryBean's object type without instantiating it at all.
 			BeanDefinition fbDef = getBeanDefinition(factoryBeanName);
-			if (fbDef instanceof AbstractBeanDefinition) {
+			if (fbDef instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) fbDef).hasBeanClass()) {
 				Class<?> fbClass = ((AbstractBeanDefinition) fbDef).getBeanClass();
 				if (ClassUtils.isCglibProxyClass(fbClass)) {
 					// CGLIB subclass methods hide generic parameters. look at the superclass.
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java
index 6ec60e6e61b6..9e97ba2fafa8 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -497,18 +497,21 @@ else if (containsSingleton(beanName) && !containsBeanDefinition(beanName)) {
 			// Retrieve corresponding bean definition.
 			RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
 
+			Class[] typesToMatch = (FactoryBean.class.equals(typeToMatch) ?
+					new Class[] {typeToMatch} : new Class[] {FactoryBean.class, typeToMatch});
+
 			// Check decorated bean definition, if any: We assume it'll be easier
 			// to determine the decorated bean's type than the proxy's type.
 			BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();
 			if (dbd != null && !BeanFactoryUtils.isFactoryDereference(name)) {
 				RootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);
-				Class<?> targetClass = predictBeanType(dbd.getBeanName(), tbd, FactoryBean.class, typeToMatch);
+				Class<?> targetClass = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);
 				if (targetClass != null && !FactoryBean.class.isAssignableFrom(targetClass)) {
 					return typeToMatch.isAssignableFrom(targetClass);
 				}
 			}
 
-			Class<?> beanClass = predictBeanType(beanName, mbd, FactoryBean.class, typeToMatch);
+			Class<?> beanClass = predictBeanType(beanName, mbd, typesToMatch);
 			if (beanClass == null) {
 				return false;
 			}
@@ -1332,9 +1335,8 @@ protected Class<?> predictBeanType(String beanName, RootBeanDefinition mbd, Clas
 	 * @param mbd the corresponding bean definition
 	 */
 	protected boolean isFactoryBean(String beanName, RootBeanDefinition mbd) {
-		Class<?> predictedType = predictBeanType(beanName, mbd, FactoryBean.class);
-		return (predictedType != null && FactoryBean.class.isAssignableFrom(predictedType)) ||
-				(mbd.hasBeanClass() && FactoryBean.class.isAssignableFrom(mbd.getBeanClass()));
+		Class<?> beanClass = predictBeanType(beanName, mbd, FactoryBean.class);
+		return (beanClass != null && FactoryBean.class.isAssignableFrom(beanClass));
 	}
 
 	/**
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/support/BeanDefinitionBuilder.java b/spring-beans/src/main/java/org/springframework/beans/factory/support/BeanDefinitionBuilder.java
index 6a2cb27e495d..5b9b571f80f5 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/support/BeanDefinitionBuilder.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/BeanDefinitionBuilder.java
@@ -30,7 +30,7 @@
  * @author Juergen Hoeller
  * @since 2.0
  */
-public class BeanDefinitionBuilder  {
+public class BeanDefinitionBuilder {
 
 	/**
 	 * Create a new {@code BeanDefinitionBuilder} used to construct a {@link GenericBeanDefinition}.
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java b/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java
index 161eae7e99b2..384866ffdd78 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java
@@ -888,4 +888,4 @@ public static String[] evaluateAnnotation(Constructor<?> candidate, int paramCou
 			}
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java
index 9e681d0dd69b..e88e04f46903 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java
@@ -135,11 +135,11 @@ public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFacto
 	/** Map of bean definition objects, keyed by bean name */
 	private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>(64);
 
-	/** Map of singleton bean names keyed by bean class */
-	private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);
+	/** Map of singleton and non-singleton bean names keyed by dependency type */
+	private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);
 
-	/** Map of non-singleton bean names keyed by bean class */
-	private final Map<Class<?>, String[]> nonSingletonBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);
+	/** Map of singleton-only bean names keyed by dependency type */
+	private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);
 
 	/** List of bean definition names, in registration order */
 	private final List<String> beanDefinitionNames = new ArrayList<String>();
@@ -326,8 +326,8 @@ public String[] getBeanNamesForType(Class<?> type, boolean includeNonSingletons,
 		if (!isConfigurationFrozen()  || type == null || !allowEagerInit) {
 			return doGetBeanNamesForType(type, includeNonSingletons, allowEagerInit);
 		}
-		Map<Class<?>, String[]> cache = includeNonSingletons ?
-				this.nonSingletonBeanNamesByType : this.singletonBeanNamesByType;
+		Map<Class<?>, String[]> cache =
+				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);
 		String[] resolvedBeanNames = cache.get(type);
 		if (resolvedBeanNames != null) {
 			return resolvedBeanNames;
@@ -707,9 +707,8 @@ protected void resetBeanDefinition(String beanName) {
 		// (e.g. the default StaticMessageSource in a StaticApplicationContext).
 		destroySingleton(beanName);
 
-		// Remove any assumptions about by-type mappings
-		this.singletonBeanNamesByType.clear();
-		this.nonSingletonBeanNamesByType.clear();
+		// Remove any assumptions about by-type mappings.
+		clearByTypeCache();
 
 		// Reset all bean definitions that have the given bean as parent (recursively).
 		for (String bdName : this.beanDefinitionNames) {
@@ -730,13 +729,33 @@ protected boolean allowAliasOverriding() {
 		return this.allowBeanDefinitionOverriding;
 	}
 
+	@Override
+	public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException {
+		super.registerSingleton(beanName, singletonObject);
+		clearByTypeCache();
+	}
+
+	@Override
+	public void destroySingleton(String beanName) {
+		super.destroySingleton(beanName);
+		clearByTypeCache();
+	}
+
+	/**
+	 * Remove any assumptions about by-type mappings.
+	 */
+	private void clearByTypeCache() {
+		this.allBeanNamesByType.clear();
+		this.singletonBeanNamesByType.clear();
+	}
+
 
 	//---------------------------------------------------------------------
 	// Dependency resolution functionality
 	//---------------------------------------------------------------------
 
 	public Object resolveDependency(DependencyDescriptor descriptor, String beanName,
-			Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException  {
+			Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException {
 
 		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
 		if (descriptor.getDependencyType().equals(ObjectFactory.class)) {
@@ -751,7 +770,7 @@ else if (descriptor.getDependencyType().equals(javaxInjectProviderClass)) {
 	}
 
 	protected Object doResolveDependency(DependencyDescriptor descriptor, Class<?> type, String beanName,
-			Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException  {
+			Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException {
 
 		Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
 		if (value != null) {
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/support/PropertiesBeanDefinitionReader.java b/spring-beans/src/main/java/org/springframework/beans/factory/support/PropertiesBeanDefinitionReader.java
index 7b7822f0df0e..d51dc55fa723 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/support/PropertiesBeanDefinitionReader.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/PropertiesBeanDefinitionReader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -165,7 +165,7 @@ public PropertiesBeanDefinitionReader(BeanDefinitionRegistry registry) {
 	 * class can still override this.
 	 * <p>Strictly speaking, the rule that a default parent setting does
 	 * not apply to a bean definition that carries a class is there for
-	 * backwards compatiblity reasons. It still matches the typical use case.
+	 * backwards compatibility reasons. It still matches the typical use case.
 	 */
 	public void setDefaultParentBean(String defaultParentBean) {
 		this.defaultParentBean = defaultParentBean;
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java b/spring-beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java
index 7eaba17a5468..64d0555d4913 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -61,8 +61,12 @@ public class RootBeanDefinition extends AbstractBeanDefinition {
 
 	boolean allowCaching = true;
 
+	private volatile Class<?> targetType;
+
 	boolean isFactoryMethodUnique = false;
 
+	final Object constructorArgumentLock = new Object();
+
 	/** Package-visible field for caching the resolved constructor or factory method */
 	Object resolvedConstructorOrFactoryMethod;
 
@@ -75,15 +79,13 @@ public class RootBeanDefinition extends AbstractBeanDefinition {
 	/** Package-visible field for caching partly prepared constructor arguments */
 	Object[] preparedConstructorArguments;
 
-	final Object constructorArgumentLock = new Object();
-
-	/** Package-visible field that indicates a before-instantiation post-processor having kicked in */
-	volatile Boolean beforeInstantiationResolved;
+	final Object postProcessingLock = new Object();
 
 	/** Package-visible field that indicates MergedBeanDefinitionPostProcessor having been applied */
 	boolean postProcessed = false;
 
-	final Object postProcessingLock = new Object();
+	/** Package-visible field that indicates a before-instantiation post-processor having kicked in */
+	volatile Boolean beforeInstantiationResolved;
 
 
 	/**
@@ -236,6 +238,8 @@ public RootBeanDefinition(RootBeanDefinition original) {
 		if (original instanceof RootBeanDefinition) {
 			RootBeanDefinition originalRbd = (RootBeanDefinition) original;
 			this.decoratedDefinition = originalRbd.decoratedDefinition;
+			this.allowCaching = originalRbd.allowCaching;
+			this.targetType = originalRbd.targetType;
 			this.isFactoryMethodUnique = originalRbd.isFactoryMethodUnique;
 		}
 	}
@@ -251,6 +255,21 @@ public void setParentName(String parentName) {
 		}
 	}
 
+	/**
+	 * Specify the target type of this bean definition, if known in advance.
+	 */
+	public void setTargetType(Class<?> targetType) {
+		this.targetType = targetType;
+	}
+
+	/**
+	 * Return the target type of this bean definition, if known
+	 * (either specified in advance or resolved on first instantiation).
+	 */
+	public Class<?> getTargetType() {
+		return this.targetType;
+	}
+
 	/**
 	 * Specify a factory method name that refers to a non-overloaded method.
 	 */
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/wiring/BeanConfigurerSupport.java b/spring-beans/src/main/java/org/springframework/beans/factory/wiring/BeanConfigurerSupport.java
index e46145f29682..81fa4242b2f6 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/wiring/BeanConfigurerSupport.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/wiring/BeanConfigurerSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,14 +30,13 @@
 import org.springframework.util.ClassUtils;
 
 /**
- * Convenient base class for configurers that can perform Dependency Injection
+ * Convenient base class for bean configurers that can perform Dependency Injection
  * on objects (however they may be created). Typically subclassed by AspectJ aspects.
  *
  * <p>Subclasses may also need a custom metadata resolution strategy, in the
- * {@link BeanWiringInfoResolver} interface. The default implementation looks
- * for a bean with the same name as the fully-qualified class name. (This is
- * the default name of the bean in a Spring XML file if the '{@code id}'
- * attribute is not used.)
+ * {@link BeanWiringInfoResolver} interface. The default implementation looks for
+ * a bean with the same name as the fully-qualified class name. (This is the default
+ * name of the bean in a Spring XML file if the '{@code id}' attribute is not used.)
 
  * @author Rob Harrop
  * @author Rod Johnson
@@ -47,7 +46,7 @@
  * @see #setBeanWiringInfoResolver
  * @see ClassNameBeanWiringInfoResolver
  */
-public class BeanConfigurerSupport implements BeanFactoryAware, InitializingBean, DisposableBean  {
+public class BeanConfigurerSupport implements BeanFactoryAware, InitializingBean, DisposableBean {
 
 	/** Logger available to subclasses */
 	protected final Log logger = LogFactory.getLog(getClass());
@@ -113,8 +112,7 @@ public void destroy() {
 	/**
 	 * Configure the bean instance.
 	 * <p>Subclasses can override this to provide custom configuration logic.
-	 * Typically called by an aspect, for all bean instances matched by a
-	 * pointcut.
+	 * Typically called by an aspect, for all bean instances matched by a pointcut.
 	 * @param beanInstance the bean instance to configure (must <b>not</b> be {@code null})
 	 */
 	public void configureBean(Object beanInstance) {
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionDocumentReader.java b/spring-beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionDocumentReader.java
index 37ef1b40904f..ffe9d294d9ba 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionDocumentReader.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionDocumentReader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,11 @@
 
 package org.springframework.beans.factory.xml;
 
+import org.w3c.dom.Document;
+
 import org.springframework.beans.factory.BeanDefinitionStoreException;
 import org.springframework.core.env.Environment;
 
-import org.w3c.dom.Document;
-
 /**
  * SPI for parsing an XML document that contains Spring bean definitions.
  * Used by XmlBeanDefinitionReader for actually parsing a DOM document.
@@ -38,20 +38,21 @@
 public interface BeanDefinitionDocumentReader {
 
 	/**
-	 * Read bean definitions from the given DOM document,
-	 * and register them with the given bean factory.
+	 * Set the Environment to use when reading bean definitions.
+	 * <p>Used for evaluating profile information to determine whether a
+	 * {@code <beans/>} document/element should be included or ignored.
+	 */
+	void setEnvironment(Environment environment);
+
+	/**
+	 * Read bean definitions from the given DOM document and
+	 * register them with the registry in the given reader context.
 	 * @param doc the DOM document
-	 * @param readerContext the current context of the reader. Includes the resource being parsed
+	 * @param readerContext the current context of the reader
+	 * (includes the target registry and the resource being parsed)
 	 * @throws BeanDefinitionStoreException in case of parsing errors
 	 */
 	void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)
 			throws BeanDefinitionStoreException;
 
-	/**
-	 * Set the Environment to use when reading bean definitions. Used for evaluating
-	 * profile information to determine whether a {@code <beans/>} document/element should
-	 * be included or omitted.
-	 */
-	void setEnvironment(Environment environment);
-
 }
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/xml/DefaultBeanDefinitionDocumentReader.java b/spring-beans/src/main/java/org/springframework/beans/factory/xml/DefaultBeanDefinitionDocumentReader.java
index 9900aa16517f..a422d5b4fcd4 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/xml/DefaultBeanDefinitionDocumentReader.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/xml/DefaultBeanDefinitionDocumentReader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,16 +72,15 @@ public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocume
 
 	public static final String RESOURCE_ATTRIBUTE = "resource";
 
-	/** @see org.springframework.context.annotation.Profile */
 	public static final String PROFILE_ATTRIBUTE = "profile";
 
 
 	protected final Log logger = LogFactory.getLog(getClass());
 
-	private XmlReaderContext readerContext;
-
 	private Environment environment;
 
+	private XmlReaderContext readerContext;
+
 	private BeanDefinitionParserDelegate delegate;
 
 
@@ -104,13 +103,12 @@ public void setEnvironment(Environment environment) {
 	 */
 	public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
 		this.readerContext = readerContext;
-
 		logger.debug("Loading bean definitions");
 		Element root = doc.getDocumentElement();
-
 		doRegisterBeanDefinitions(root);
 	}
 
+
 	/**
 	 * Register each bean definition within the given root {@code <beans/>} element.
 	 * @throws IllegalStateException if {@code <beans profile="..."} attribute is present
@@ -120,21 +118,22 @@ public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext
 	protected void doRegisterBeanDefinitions(Element root) {
 		String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
 		if (StringUtils.hasText(profileSpec)) {
-			Assert.state(this.environment != null, "environment property must not be null");
-			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
+			Assert.state(this.environment != null, "Environment must be set for evaluating profiles");
+			String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
+					profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
 			if (!this.environment.acceptsProfiles(specifiedProfiles)) {
 				return;
 			}
 		}
 
-		// any nested <beans> elements will cause recursion in this method. In
+		// Any nested <beans> elements will cause recursion in this method. In
 		// order to propagate and preserve <beans> default-* attributes correctly,
 		// keep track of the current (parent) delegate, which may be null. Create
 		// the new (child) delegate with a reference to the parent for fallback purposes,
 		// then ultimately reset this.delegate back to its original (parent) reference.
 		// this behavior emulates a stack of delegates without actually necessitating one.
 		BeanDefinitionParserDelegate parent = this.delegate;
-		this.delegate = createHelper(readerContext, root, parent);
+		this.delegate = createHelper(this.readerContext, root, parent);
 
 		preProcessXml(root);
 		parseBeanDefinitions(root, this.delegate);
@@ -143,7 +142,9 @@ protected void doRegisterBeanDefinitions(Element root) {
 		this.delegate = parent;
 	}
 
-	protected BeanDefinitionParserDelegate createHelper(XmlReaderContext readerContext, Element root, BeanDefinitionParserDelegate parentDelegate) {
+	protected BeanDefinitionParserDelegate createHelper(
+			XmlReaderContext readerContext, Element root, BeanDefinitionParserDelegate parentDelegate) {
+
 		BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext, environment);
 		delegate.initDefaults(root, parentDelegate);
 		return delegate;
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/xml/DelegatingEntityResolver.java b/spring-beans/src/main/java/org/springframework/beans/factory/xml/DelegatingEntityResolver.java
index 07bfe7afa93b..3bd9e1d85e92 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/xml/DelegatingEntityResolver.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/xml/DelegatingEntityResolver.java
@@ -92,7 +92,7 @@ else if (systemId.endsWith(XSD_SUFFIX)) {
 	@Override
 	public String toString() {
 		return "EntityResolver delegating " + XSD_SUFFIX + " to " + this.schemaResolver +
-				" and " + DTD_SUFFIX +  " to " + this.dtdResolver;
+				" and " + DTD_SUFFIX + " to " + this.dtdResolver;
 	}
 
 }
diff --git a/spring-beans/src/main/java/org/springframework/beans/factory/xml/SimpleConstructorNamespaceHandler.java b/spring-beans/src/main/java/org/springframework/beans/factory/xml/SimpleConstructorNamespaceHandler.java
index a7ca4fbd54ec..4110ed0a220d 100644
--- a/spring-beans/src/main/java/org/springframework/beans/factory/xml/SimpleConstructorNamespaceHandler.java
+++ b/spring-beans/src/main/java/org/springframework/beans/factory/xml/SimpleConstructorNamespaceHandler.java
@@ -148,4 +148,4 @@ private boolean checkName(String name, Collection<ValueHolder> values) {
 		}
 		return false;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-beans/src/test/java/org/springframework/beans/BeanUtilsTests.java b/spring-beans/src/test/java/org/springframework/beans/BeanUtilsTests.java
index 9d53409e73fb..b35e6aabf75a 100644
--- a/spring-beans/src/test/java/org/springframework/beans/BeanUtilsTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/BeanUtilsTests.java
@@ -267,6 +267,7 @@ private void assertSignatureEquals(Method desiredMethod, String signature) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class NameAndSpecialProperty {
 
 		private String name;
@@ -291,6 +292,7 @@ public int getSpecialProperty() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class ContainerBean {
 
 		private ContainedBean[] containedBeans;
@@ -305,6 +307,7 @@ public void setContainedBeans(ContainedBean[] containedBeans) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class ContainedBean {
 
 		private String name;
@@ -319,6 +322,7 @@ public void setName(String name) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class MethodSignatureBean {
 
 		public void doSomething() {
diff --git a/spring-beans/src/test/java/org/springframework/beans/BeanWrapperAutoGrowingTests.java b/spring-beans/src/test/java/org/springframework/beans/BeanWrapperAutoGrowingTests.java
index 73bdeaee1c62..06a7eb86ac1f 100644
--- a/spring-beans/src/test/java/org/springframework/beans/BeanWrapperAutoGrowingTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/BeanWrapperAutoGrowingTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.hamcrest.Matchers.instanceOf;
 import static org.junit.Assert.*;
 
 /**
@@ -59,7 +60,7 @@ public void getPropertyValueNullValueInNestedPathNoDefaultConstructor() {
 	public void getPropertyValueAutoGrowArray() {
 		assertNotNull(wrapper.getPropertyValue("array[0]"));
 		assertEquals(1, bean.getArray().length);
-		assertTrue(bean.getArray()[0] instanceof Bean);
+		assertThat(bean.getArray()[0], instanceOf(Bean.class));
 	}
 
 	@Test
@@ -72,11 +73,11 @@ public void setPropertyValueAutoGrowArray() {
 	public void getPropertyValueAutoGrowArrayBySeveralElements() {
 		assertNotNull(wrapper.getPropertyValue("array[4]"));
 		assertEquals(5, bean.getArray().length);
-		assertTrue(bean.getArray()[0] instanceof Bean);
-		assertTrue(bean.getArray()[1] instanceof Bean);
-		assertTrue(bean.getArray()[2] instanceof Bean);
-		assertTrue(bean.getArray()[3] instanceof Bean);
-		assertTrue(bean.getArray()[4] instanceof Bean);
+		assertThat(bean.getArray()[0], instanceOf(Bean.class));
+		assertThat(bean.getArray()[1], instanceOf(Bean.class));
+		assertThat(bean.getArray()[2], instanceOf(Bean.class));
+		assertThat(bean.getArray()[3], instanceOf(Bean.class));
+		assertThat(bean.getArray()[4], instanceOf(Bean.class));
 		assertNotNull(wrapper.getPropertyValue("array[0]"));
 		assertNotNull(wrapper.getPropertyValue("array[1]"));
 		assertNotNull(wrapper.getPropertyValue("array[2]"));
@@ -87,14 +88,14 @@ public void getPropertyValueAutoGrowArrayBySeveralElements() {
 	public void getPropertyValueAutoGrowMultiDimensionalArray() {
 		assertNotNull(wrapper.getPropertyValue("multiArray[0][0]"));
 		assertEquals(1, bean.getMultiArray()[0].length);
-		assertTrue(bean.getMultiArray()[0][0] instanceof Bean);
+		assertThat(bean.getMultiArray()[0][0], instanceOf(Bean.class));
 	}
 
 	@Test
 	public void getPropertyValueAutoGrowList() {
 		assertNotNull(wrapper.getPropertyValue("list[0]"));
 		assertEquals(1, bean.getList().size());
-		assertTrue(bean.getList().get(0) instanceof Bean);
+		assertThat(bean.getList().get(0), instanceOf(Bean.class));
 	}
 
 	@Test
@@ -107,11 +108,11 @@ public void setPropertyValueAutoGrowList() {
 	public void getPropertyValueAutoGrowListBySeveralElements() {
 		assertNotNull(wrapper.getPropertyValue("list[4]"));
 		assertEquals(5, bean.getList().size());
-		assertTrue(bean.getList().get(0) instanceof Bean);
-		assertTrue(bean.getList().get(1) instanceof Bean);
-		assertTrue(bean.getList().get(2) instanceof Bean);
-		assertTrue(bean.getList().get(3) instanceof Bean);
-		assertTrue(bean.getList().get(4) instanceof Bean);
+		assertThat(bean.getList().get(0), instanceOf(Bean.class));
+		assertThat(bean.getList().get(1), instanceOf(Bean.class));
+		assertThat(bean.getList().get(2), instanceOf(Bean.class));
+		assertThat(bean.getList().get(3), instanceOf(Bean.class));
+		assertThat(bean.getList().get(4), instanceOf(Bean.class));
 		assertNotNull(wrapper.getPropertyValue("list[0]"));
 		assertNotNull(wrapper.getPropertyValue("list[1]"));
 		assertNotNull(wrapper.getPropertyValue("list[2]"));
@@ -135,7 +136,7 @@ public void getPropertyValueAutoGrowListFailsAgainstLimit() {
 	public void getPropertyValueAutoGrowMultiDimensionalList() {
 		assertNotNull(wrapper.getPropertyValue("multiList[0][0]"));
 		assertEquals(1, bean.getMultiList().get(0).size());
-		assertTrue(bean.getMultiList().get(0).get(0) instanceof Bean);
+		assertThat(bean.getMultiList().get(0).get(0), instanceOf(Bean.class));
 	}
 
 	@Test(expected=InvalidPropertyException.class)
@@ -146,13 +147,13 @@ public void getPropertyValueAutoGrowListNotParameterized() {
 	@Test
 	public void setPropertyValueAutoGrowMap() {
 		wrapper.setPropertyValue("map[A]", new Bean());
-		assertTrue(bean.getMap().get("A") instanceof Bean);
+		assertThat(bean.getMap().get("A"), instanceOf(Bean.class));
 	}
 
 	@Test
 	public void setNestedPropertyValueAutoGrowMap() {
 		wrapper.setPropertyValue("map[A].nested", new Bean());
-		assertTrue(bean.getMap().get("A").getNested() instanceof Bean);
+		assertThat(bean.getMap().get("A").getNested(), instanceOf(Bean.class));
 	}
 
 
diff --git a/spring-beans/src/test/java/org/springframework/beans/BeanWrapperGenericsTests.java b/spring-beans/src/test/java/org/springframework/beans/BeanWrapperGenericsTests.java
index 3d310bdc686b..3a9e03accc03 100644
--- a/spring-beans/src/test/java/org/springframework/beans/BeanWrapperGenericsTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/BeanWrapperGenericsTests.java
@@ -157,7 +157,6 @@ public void testGenericMapWithCollectionValue() {
 		GenericBean<?> gb = new GenericBean<Object>();
 		BeanWrapper bw = new BeanWrapperImpl(gb);
 		bw.registerCustomEditor(Number.class, new CustomNumberEditor(Integer.class, false));
-		@SuppressWarnings("unchecked")
 		Map<String, Collection> input = new HashMap<String, Collection>();
 		HashSet<Integer> value1 = new HashSet<Integer>();
 		value1.add(new Integer(1));
@@ -497,6 +496,7 @@ private static abstract class BaseGenericCollectionBean {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class NestedGenericCollectionBean extends BaseGenericCollectionBean {
 
 		private Map<String, Integer> mapOfInteger;
@@ -544,6 +544,7 @@ public void setMapOfListOfListOfInteger(Map<String, List<List<Integer>>> mapOfLi
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class ComplexMapHolder {
 
 		private Map<List<Integer>, List<Long>> genericMap;
diff --git a/spring-beans/src/test/java/org/springframework/beans/BeanWrapperTests.java b/spring-beans/src/test/java/org/springframework/beans/BeanWrapperTests.java
index 9d4e022a64a1..9ec9af033b8d 100644
--- a/spring-beans/src/test/java/org/springframework/beans/BeanWrapperTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/BeanWrapperTests.java
@@ -1569,6 +1569,7 @@ public static void setProp1(String prop1) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class Foo {
 
 		private List list;
@@ -1598,6 +1599,7 @@ private static class DifferentTestBean extends TestBean {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class NoRead {
 
 		public void setAge(int age) {
@@ -1605,6 +1607,7 @@ public void setAge(int age) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class EnumTester {
 
 		private Autowire autowire;
@@ -1619,6 +1622,7 @@ public Autowire getAutowire() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class PropsTester {
 
 		private Properties props;
@@ -1647,6 +1651,7 @@ public void setIntArray(int[] intArray) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class GetterBean {
 
 		private String name;
@@ -1664,6 +1669,7 @@ public String getName() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class ThrowsException {
 
 		public void doSomething(Throwable t) throws Throwable {
@@ -1672,6 +1678,7 @@ public void doSomething(Throwable t) throws Throwable {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class PrimitiveArrayBean {
 
 		private int[] array;
@@ -1686,6 +1693,7 @@ public void setArray(int[] array) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class NumberPropertyBean {
 
 		private byte myPrimitiveByte;
@@ -1804,6 +1812,7 @@ public void setMyDouble(Double myDouble) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class IntelliBean {
 
 		public void setName(String name) {}
@@ -1818,6 +1827,7 @@ public void setMyStringss(String string) {}
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class Employee extends TestBean {
 
 		private String co;
diff --git a/spring-beans/src/test/java/org/springframework/beans/ConcurrentBeanWrapperTests.java b/spring-beans/src/test/java/org/springframework/beans/ConcurrentBeanWrapperTests.java
index 95c3fbb8cc93..2d98f138bae8 100644
--- a/spring-beans/src/test/java/org/springframework/beans/ConcurrentBeanWrapperTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/ConcurrentBeanWrapperTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -135,6 +135,7 @@ public void run() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class TestBean {
 
 		private Properties properties;
diff --git a/spring-beans/src/test/java/org/springframework/beans/ExtendedBeanInfoTests.java b/spring-beans/src/test/java/org/springframework/beans/ExtendedBeanInfoTests.java
index ec2ca31e2bb3..30b2013d072e 100644
--- a/spring-beans/src/test/java/org/springframework/beans/ExtendedBeanInfoTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/ExtendedBeanInfoTests.java
@@ -974,7 +974,6 @@ public void shouldSupportStaticWriteMethod() throws IntrospectionException {
 	}
 
 	static class WithStaticWriteMethod {
-		@SuppressWarnings("unused")
 		public static void setProp1(String prop1) {
 		}
 	}
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/DefaultListableBeanFactoryTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/DefaultListableBeanFactoryTests.java
index fc4ac5d55c6c..73c2ab592a6c 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/DefaultListableBeanFactoryTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/DefaultListableBeanFactoryTests.java
@@ -16,24 +16,6 @@
 
 package org.springframework.beans.factory;
 
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.Matchers.containsString;
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.isNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
 import java.io.Closeable;
 import java.lang.reflect.Field;
 import java.net.MalformedURLException;
@@ -104,6 +86,10 @@
 import org.springframework.util.StopWatch;
 import org.springframework.util.StringValueResolver;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Tests properties population and autowire behavior.
  *
@@ -591,7 +577,6 @@ public void testPossibleMatches() {
 			fail("Should throw exception on invalid property");
 		}
 		catch (BeanCreationException ex) {
-			ex.printStackTrace();
 			assertTrue(ex.getCause() instanceof NotWritablePropertyException);
 			NotWritablePropertyException cause = (NotWritablePropertyException) ex.getCause();
 			// expected
@@ -2200,7 +2185,6 @@ public void testFieldSettingWithInstantiationAwarePostProcessorWithShortCircuit(
 		doTestFieldSettingWithInstantiationAwarePostProcessor(true);
 	}
 
-	@SuppressWarnings("unchecked")
 	private void doTestFieldSettingWithInstantiationAwarePostProcessor(final boolean skipPropertyPopulation) {
 		DefaultListableBeanFactory lbf = new DefaultListableBeanFactory();
 		RootBeanDefinition bd = new RootBeanDefinition(TestBean.class);
@@ -2263,8 +2247,8 @@ public void testContainsBeanReturnsTrueEvenForAbstractBeanDefinition() {
 		DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
 		bf.registerBeanDefinition("abs", BeanDefinitionBuilder
 				.rootBeanDefinition(TestBean.class).setAbstract(true).getBeanDefinition());
-		assertThat(bf.containsBean("abs"), is(true));
-		assertThat(bf.containsBean("bogus"), is(false));
+		assertThat(bf.containsBean("abs"), equalTo(true));
+		assertThat(bf.containsBean("bogus"), equalTo(false));
 	}
 
 	@Test
@@ -2334,6 +2318,7 @@ public ConstructorDependency(TestBean spouse) {
 			this.spouse = spouse;
 		}
 
+		@SuppressWarnings("unused")
 		private ConstructorDependency(TestBean spouse, TestBean otherSpouse) {
 			throw new IllegalArgumentException("Should never be called");
 		}
@@ -2560,6 +2545,7 @@ public Resource[] getResourceArray() {
 	/**
 	 * Bean with a dependency on a {@link FactoryBean}.
 	 */
+	@SuppressWarnings("unused")
 	private static class FactoryBeanDependentBean {
 
 		private FactoryBean<?> factoryBean;
@@ -2646,6 +2632,7 @@ public int hashCode() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class TestSecuredBean {
 
 		private String userName;
@@ -2675,6 +2662,7 @@ public String getUserName() {
 		}
 	}
 
+	@SuppressWarnings("unused")
 	private static class KnowsIfInstantiated {
 
 		private static boolean instantiated;
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/config/CustomScopeConfigurerTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/config/CustomScopeConfigurerTests.java
index 65e6debd15f7..4c6725e01ecb 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/config/CustomScopeConfigurerTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/config/CustomScopeConfigurerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,6 @@
 
 package org.springframework.beans.factory.config;
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-
 import java.util.HashMap;
 import java.util.Map;
 
@@ -26,6 +23,9 @@
 import org.junit.Test;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for {@link CustomScopeConfigurer}.
  *
@@ -45,7 +45,6 @@ public void setUp() {
 
 	@Test
 	public void testWithNoScopes() throws Exception {
-		Scope scope = mock(Scope.class);
 		CustomScopeConfigurer figurer = new CustomScopeConfigurer();
 		figurer.postProcessBeanFactory(factory);
 	}
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/config/ObjectFactoryCreatingFactoryBeanTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/config/ObjectFactoryCreatingFactoryBeanTests.java
index dc56161776db..a41a5c97bb73 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/config/ObjectFactoryCreatingFactoryBeanTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/config/ObjectFactoryCreatingFactoryBeanTests.java
@@ -16,14 +16,6 @@
 
 package org.springframework.beans.factory.config;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.springframework.tests.TestResourceUtils.qualifiedResource;
-
 import java.util.Date;
 
 import javax.inject.Provider;
@@ -38,6 +30,10 @@
 import org.springframework.core.io.Resource;
 import org.springframework.util.SerializationTestUtils;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+import static org.springframework.tests.TestResourceUtils.*;
+
 /**
  * @author Colin Sampaleanu
  * @author Juergen Hoeller
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/config/PropertyResourceConfigurerTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/config/PropertyResourceConfigurerTests.java
index 1212913cb1b6..fab64afdcb5c 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/config/PropertyResourceConfigurerTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/config/PropertyResourceConfigurerTests.java
@@ -17,6 +17,7 @@
 package org.springframework.beans.factory.config;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
@@ -644,6 +645,7 @@ public void testPropertyPlaceholderConfigurerWithSelfReferencingPlaceholderInAli
 		ppc.postProcessBeanFactory(factory);
 
 		TestBean tb = (TestBean) factory.getBean("tb");
+		assertNotNull(tb);
 		assertEquals(0, factory.getAliases("tb").length);
 	}
 
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/config/ServiceLocatorFactoryBeanTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/config/ServiceLocatorFactoryBeanTests.java
index f7ab438e7659..ae7c2b845198 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/config/ServiceLocatorFactoryBeanTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/config/ServiceLocatorFactoryBeanTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,6 @@
 
 package org.springframework.beans.factory.config;
 
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.mock;
-import static org.springframework.beans.factory.support.BeanDefinitionBuilder.genericBeanDefinition;
-
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -30,6 +26,10 @@
 import org.springframework.core.NestedCheckedException;
 import org.springframework.core.NestedRuntimeException;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+import static org.springframework.beans.factory.support.BeanDefinitionBuilder.*;
+
 /**
  * Unit tests for {@link ServiceLocatorFactoryBean}.
  *
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/parsing/CustomProblemReporterTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/parsing/CustomProblemReporterTests.java
index 20bdd506544a..550e87375b23 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/parsing/CustomProblemReporterTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/parsing/CustomProblemReporterTests.java
@@ -29,7 +29,6 @@
 import org.springframework.core.io.Resource;
 import org.springframework.tests.sample.beans.TestBean;
 
-
 /**
  * @author Rob Harrop
  * @author Chris Beams
@@ -78,7 +77,6 @@ public void fatal(Problem problem) {
 
 		@Override
 		public void error(Problem problem) {
-			System.out.println(problem);
 			this.errors.add(problem);
 		}
 
@@ -88,13 +86,8 @@ public Problem[] getErrors() {
 
 		@Override
 		public void warning(Problem problem) {
-			System.out.println(problem);
 			this.warnings.add(problem);
 		}
-
-		public Problem[] getWarnings() {
-			return this.warnings.toArray(new Problem[this.warnings.size()]);
-		}
 	}
 
 }
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/parsing/FailFastProblemReporterTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/parsing/FailFastProblemReporterTests.java
index 622b7fda5d38..af6ec0c484fb 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/parsing/FailFastProblemReporterTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/parsing/FailFastProblemReporterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,13 @@
 
 package org.springframework.beans.factory.parsing;
 
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.apache.commons.logging.Log;
 import org.junit.Test;
 import org.springframework.core.io.DescriptiveResource;
 
+import static org.mockito.Matchers.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/support/QualifierAnnotationAutowireBeanFactoryTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/support/QualifierAnnotationAutowireBeanFactoryTests.java
index 195ad775290d..cb7cf5580bae 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/support/QualifierAnnotationAutowireBeanFactoryTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/support/QualifierAnnotationAutowireBeanFactoryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -208,6 +208,7 @@ public void testAutowireCandidateWithMultipleCandidatesDescriptor() throws Excep
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class QualifiedTestBean {
 
 		@TestQualifier
@@ -226,6 +227,7 @@ public void autowireNonqualified(Person tpb) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class Person {
 
 		private String name;
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/support/Spr8954Tests.java b/spring-beans/src/test/java/org/springframework/beans/factory/support/Spr8954Tests.java
index 5c1368c4610b..411f53804519 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/support/Spr8954Tests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/support/Spr8954Tests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,8 @@
 import java.util.Map;
 
 import org.junit.Test;
+
+import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.FactoryBean;
 import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
@@ -49,6 +51,8 @@ public void repro() {
 		assertThat(bf.getBean("foo"), instanceOf(Foo.class));
 		assertThat(bf.getBean("&foo"), instanceOf(FooFactoryBean.class));
 
+		assertThat(bf.isTypeMatch("&foo", FactoryBean.class), is(true));
+
 		@SuppressWarnings("rawtypes")
 		Map<String, FactoryBean> fbBeans = bf.getBeansOfType(FactoryBean.class);
 		assertThat(1, equalTo(fbBeans.size()));
@@ -59,6 +63,25 @@ public void repro() {
 		assertThat("&foo", equalTo(aiBeans.keySet().iterator().next()));
 	}
 
+	@Test
+	public void findsBeansByTypeIfNotInstantiated() {
+		DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
+		bf.registerBeanDefinition("foo", new RootBeanDefinition(FooFactoryBean.class));
+		bf.addBeanPostProcessor(new PredictingBPP());
+
+		assertThat(bf.isTypeMatch("&foo", FactoryBean.class), is(true));
+
+		@SuppressWarnings("rawtypes")
+		Map<String, FactoryBean> fbBeans = bf.getBeansOfType(FactoryBean.class);
+		assertThat(1, equalTo(fbBeans.size()));
+		assertThat("&foo", equalTo(fbBeans.keySet().iterator().next()));
+
+		Map<String, AnInterface> aiBeans = bf.getBeansOfType(AnInterface.class);
+		assertThat(1, equalTo(aiBeans.size()));
+		assertThat("&foo", equalTo(aiBeans.keySet().iterator().next()));
+	}
+
+
 	static class FooFactoryBean implements FactoryBean<Foo>, AnInterface {
 
 		@Override
@@ -84,7 +107,9 @@ static class Foo {
 	}
 
 	interface PredictedType {
+	}
 
+	static class PredictedTypeImpl implements PredictedType {
 	}
 
 	static class PredictingBPP extends InstantiationAwareBeanPostProcessorAdapter {
@@ -92,8 +117,8 @@ static class PredictingBPP extends InstantiationAwareBeanPostProcessorAdapter {
 		@Override
 		public Class<?> predictBeanType(Class<?> beanClass, String beanName) {
 			return FactoryBean.class.isAssignableFrom(beanClass) ?
-					PredictedType.class :
-					super.predictBeanType(beanClass, beanName);
+					PredictedType.class : null;
 		}
 	}
+
 }
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/support/security/CallbacksSecurityTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/support/security/CallbacksSecurityTests.java
index 65e380d3e2e8..d0439fa93eff 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/support/security/CallbacksSecurityTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/support/security/CallbacksSecurityTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,6 @@
 
 package org.springframework.beans.factory.support.security;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.lang.reflect.Method;
 import java.net.URL;
 import java.security.AccessControlContext;
@@ -39,8 +33,8 @@
 import javax.security.auth.Subject;
 
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
+
 import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.BeanClassLoaderAware;
 import org.springframework.beans.factory.BeanCreationException;
@@ -60,6 +54,8 @@
 import org.springframework.core.io.DefaultResourceLoader;
 import org.springframework.core.io.Resource;
 
+import static org.junit.Assert.*;
+
 /**
  * Security test case. Checks whether the container uses its privileges for its
  * internal work but does not leak them when touching/calling user code.
@@ -75,6 +71,7 @@ public class CallbacksSecurityTests {
 	private DefaultListableBeanFactory beanFactory;
 	private SecurityContextProvider provider;
 
+	@SuppressWarnings("unused")
 	private static class NonPrivilegedBean {
 
 		private String expectedName;
@@ -117,6 +114,7 @@ private void checkCurrentContext() {
 		}
 	}
 
+	@SuppressWarnings("unused")
 	private static class NonPrivilegedSpringCallbacksBean implements
 			InitializingBean, DisposableBean, BeanClassLoaderAware,
 			BeanFactoryAware, BeanNameAware {
@@ -161,6 +159,7 @@ private void checkCurrentContext() {
 		}
 	}
 
+	@SuppressWarnings("unused")
 	private static class NonPrivilegedFactoryBean implements SmartFactoryBean {
 		private String expectedName;
 
@@ -204,6 +203,7 @@ private void checkCurrentContext() {
 		}
 	}
 
+	@SuppressWarnings("unused")
 	private static class NonPrivilegedFactory {
 
 		private final String expectedName;
@@ -452,9 +452,6 @@ public void testConstructor() throws Exception {
 	}
 
 	@Test
-	@Ignore("passes under Eclipse, but fails under Gradle with https://gist.github.com/1664133")
-	// TODO [SPR-10074] passes under Eclipse, but fails under Gradle with
-	// https://gist.github.com/1664133
 	public void testContainerPrivileges() throws Exception {
 		AccessControlContext acc = provider.getAccessControlContext();
 
@@ -511,8 +508,7 @@ public void testTrustedExecution() throws Exception {
 		perms.add(new AuthPermission("getSubject"));
 		ProtectionDomain pd = new ProtectionDomain(null, perms);
 
-		AccessControlContext acc = new AccessControlContext(
-				new ProtectionDomain[] { pd });
+		new AccessControlContext(new ProtectionDomain[] { pd });
 
 		final Subject subject = new Subject();
 		subject.getPrincipals().add(new TestPrincipal("user1"));
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/support/security/support/ConstructorBean.java b/spring-beans/src/test/java/org/springframework/beans/factory/support/security/support/ConstructorBean.java
index 0b65929fdd31..a68028c5921d 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/support/security/support/ConstructorBean.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/support/security/support/ConstructorBean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.springframework.beans.factory.support.security.support;
 
 /**
@@ -25,6 +26,5 @@ public ConstructorBean() {
 	}
 
 	public ConstructorBean(Object obj) {
-		System.out.println("Received object " + obj);
 	}
 }
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/wiring/BeanConfigurerSupportTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/wiring/BeanConfigurerSupportTests.java
index 625e8c7085e7..7b039cc66083 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/wiring/BeanConfigurerSupportTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/wiring/BeanConfigurerSupportTests.java
@@ -16,9 +16,6 @@
 
 package org.springframework.beans.factory.wiring;
 
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
 import junit.framework.TestCase;
 
 import org.springframework.beans.factory.BeanFactory;
@@ -26,6 +23,8 @@
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
 import org.springframework.tests.sample.beans.TestBean;
 
+import static org.mockito.BDDMockito.*;
+
 
 /**
  * @author Rick Evans
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/xml/AbstractBeanFactoryTests.java b/spring-beans/src/test/java/org/springframework/beans/factory/xml/AbstractBeanFactoryTests.java
index 4510487801a0..3d88251b7e15 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/xml/AbstractBeanFactoryTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/xml/AbstractBeanFactoryTests.java
@@ -121,7 +121,7 @@ public void testGetInstanceByMatchingClass() {
 
 	public void testGetInstanceByNonmatchingClass() {
 		try {
-			Object o = getBeanFactory().getBean("rod", BeanFactory.class);
+			getBeanFactory().getBean("rod", BeanFactory.class);
 			fail("Rod bean is not of type BeanFactory; getBeanInstance(rod, BeanFactory.class) should throw BeanNotOfRequiredTypeException");
 		}
 		catch (BeanNotOfRequiredTypeException ex) {
@@ -155,7 +155,7 @@ public void testGetSharedInstanceByMatchingClassNoCatch() {
 
 	public void testGetSharedInstanceByNonmatchingClass() {
 		try {
-			Object o = getBeanFactory().getBean("rod", BeanFactory.class);
+			getBeanFactory().getBean("rod", BeanFactory.class);
 			fail("Rod bean is not of type BeanFactory; getBeanInstance(rod, BeanFactory.class) should throw BeanNotOfRequiredTypeException");
 		}
 		catch (BeanNotOfRequiredTypeException ex) {
@@ -199,7 +199,7 @@ public void testPrototypeInstancesAreIndependent() {
 	public void testNotThere() {
 		assertFalse(getBeanFactory().containsBean("Mr Squiggle"));
 		try {
-			Object o = getBeanFactory().getBean("Mr Squiggle");
+			getBeanFactory().getBean("Mr Squiggle");
 			fail("Can't find missing bean");
 		}
 		catch (BeansException ex) {
@@ -223,7 +223,7 @@ public void testValidEmpty() {
 
 	public void xtestTypeMismatch() {
 		try {
-			Object o = getBeanFactory().getBean("typeMismatch");
+			getBeanFactory().getBean("typeMismatch");
 			fail("Shouldn't succeed with type mismatch");
 		}
 		catch (BeanCreationException wex) {
@@ -278,6 +278,7 @@ public void testGetFactoryItself() throws Exception {
 	 */
 	public void testFactoryIsInitialized() throws Exception {
 		TestBean tb = (TestBean) getBeanFactory().getBean("singletonFactory");
+		assertNotNull(tb);
 		DummyFactory factory = (DummyFactory) getBeanFactory().getBean("&singletonFactory");
 		assertTrue("Factory was initialized because it implemented InitializingBean", factory.wasInitialized());
 	}
diff --git a/spring-beans/src/test/java/org/springframework/beans/factory/xml/FactoryMethods.java b/spring-beans/src/test/java/org/springframework/beans/factory/xml/FactoryMethods.java
index a5ef87cb1f65..ba8c74bfe960 100644
--- a/spring-beans/src/test/java/org/springframework/beans/factory/xml/FactoryMethods.java
+++ b/spring-beans/src/test/java/org/springframework/beans/factory/xml/FactoryMethods.java
@@ -62,6 +62,7 @@ static FactoryMethods newInstance(TestBean tb, int num, Integer something) {
 		return new FactoryMethods(tb, null, num);
 	}
 
+	@SuppressWarnings("unused")
 	private static List listInstance() {
 		return Collections.EMPTY_LIST;
 	}
@@ -99,6 +100,7 @@ protected TestBean protectedGetTestBean() {
 		return this.tb;
 	}
 
+	@SuppressWarnings("unused")
 	private TestBean privateGetTestBean() {
 		return this.tb;
 	}
diff --git a/spring-beans/src/test/java/org/springframework/beans/propertyeditors/CustomCollectionEditorTests.java b/spring-beans/src/test/java/org/springframework/beans/propertyeditors/CustomCollectionEditorTests.java
index 14b3f4d48d0d..4f9463a5c711 100644
--- a/spring-beans/src/test/java/org/springframework/beans/propertyeditors/CustomCollectionEditorTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/propertyeditors/CustomCollectionEditorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2006 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -85,7 +85,7 @@ public void testSunnyDaySetAsTextYieldsSingleValue() throws Exception {
 	}
 
 
-	@SuppressWarnings("serial")
+	@SuppressWarnings({ "serial", "unused" })
 	private static final class CollectionTypeWithNoNoArgCtor extends ArrayList<Object> {
 		public CollectionTypeWithNoNoArgCtor(String anArg) {
 		}
diff --git a/spring-beans/src/test/java/org/springframework/beans/propertyeditors/CustomEditorTests.java b/spring-beans/src/test/java/org/springframework/beans/propertyeditors/CustomEditorTests.java
index d2052916203e..af590e3936b7 100644
--- a/spring-beans/src/test/java/org/springframework/beans/propertyeditors/CustomEditorTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/propertyeditors/CustomEditorTests.java
@@ -1506,6 +1506,7 @@ public void setAsText(String text) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class PrimitiveArrayBean {
 
 		private byte[] byteArray;
@@ -1530,6 +1531,7 @@ public void setCharArray(char[] charArray) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class CharBean {
 
 		private char myChar;
@@ -1554,6 +1556,7 @@ public void setMyCharacter(Character myCharacter) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class OldCollectionsBean {
 
 		private Vector<?> vector;
diff --git a/spring-beans/src/test/java/org/springframework/beans/support/PropertyComparatorTests.java b/spring-beans/src/test/java/org/springframework/beans/support/PropertyComparatorTests.java
index 320759d1b8a5..ad1666fcd11c 100644
--- a/spring-beans/src/test/java/org/springframework/beans/support/PropertyComparatorTests.java
+++ b/spring-beans/src/test/java/org/springframework/beans/support/PropertyComparatorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -96,6 +96,7 @@ public void testCompoundComparatorInvert() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class Dog implements Comparable<Object> {
 
 		private String nickName;
diff --git a/spring-beans/src/test/resources/log4j.xml b/spring-beans/src/test/resources/log4j.xml
index 37f573d2aef2..6f012e992400 100644
--- a/spring-beans/src/test/resources/log4j.xml
+++ b/spring-beans/src/test/resources/log4j.xml
@@ -11,21 +11,13 @@
 		</layout>
 	</appender>
 
-	<logger name="org.springframework.beans">
-		<level value="warn" />
-	</logger>
-
-	<logger name="org.springframework.binding">
-		<level value="debug" />
-	</logger>
-
-	<logger name="org.springframework.core.GenericTypeResolver">
+	<logger name="org.springframework.beans.factory.config.DeprecatedBeanWarnerTests$MyDeprecatedBeanWarner">
 		<level value="warn" />
 	</logger>
 
 	<!-- Root Logger -->
 	<root>
-		<priority value="warn" />
+		<priority value="error" />
 		<appender-ref ref="console" />
 	</root>
 	
diff --git a/spring-context-support/src/main/java/org/springframework/cache/ehcache/EhCacheFactoryBean.java b/spring-context-support/src/main/java/org/springframework/cache/ehcache/EhCacheFactoryBean.java
index fc2ad0002229..dcec4047eeec 100644
--- a/spring-context-support/src/main/java/org/springframework/cache/ehcache/EhCacheFactoryBean.java
+++ b/spring-context-support/src/main/java/org/springframework/cache/ehcache/EhCacheFactoryBean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -40,9 +40,9 @@
 import org.springframework.util.Assert;
 
 /**
- * {@link FactoryBean} that creates a named EHCache {@link net.sf.ehcache.Cache} instance
+ * {@link FactoryBean} that creates a named EhCache {@link net.sf.ehcache.Cache} instance
  * (or a decorator that implements the {@link net.sf.ehcache.Ehcache} interface),
- * representing a cache region within an EHCache {@link net.sf.ehcache.CacheManager}.
+ * representing a cache region within an EhCache {@link net.sf.ehcache.CacheManager}.
  *
  * <p>If the specified named cache is not configured in the cache configuration descriptor,
  * this FactoryBean will construct an instance of a Cache with the provided name and the
@@ -52,7 +52,8 @@
  * <p>Note: If the named Cache instance is found, the properties will be ignored and the
  * Cache instance will be retrieved from the CacheManager.
  *
- * <p>Note: As of Spring 3.0, Spring's EHCache support requires EHCache 1.3 or higher.
+ * <p>Note: As of Spring 3.0, Spring's EhCache support requires EhCache 1.3 or higher.
+ * As of Spring 3.2, we recommend using EhCache 2.1 or higher.
 
  * @author Dmitriy Kopylenko
  * @author Juergen Hoeller
@@ -117,7 +118,7 @@ public class EhCacheFactoryBean implements FactoryBean<Ehcache>, BeanNameAware,
 	 * properly handle the shutdown of the CacheManager: Set up a separate
 	 * EhCacheManagerFactoryBean and pass a reference to this bean property.
 	 * <p>A separate EhCacheManagerFactoryBean is also necessary for loading
-	 * EHCache configuration from a non-default config location.
+	 * EhCache configuration from a non-default config location.
 	 * @see EhCacheManagerFactoryBean
 	 * @see net.sf.ehcache.CacheManager#getInstance
 	 */
@@ -152,7 +153,7 @@ public void setMaxElementsOnDisk(int maxElementsOnDisk) {
 	/**
 	 * Set the memory style eviction policy for this cache.
 	 * <p>Supported values are "LRU", "LFU" and "FIFO", according to the
-	 * constants defined in EHCache's MemoryStoreEvictionPolicy class.
+	 * constants defined in EhCache's MemoryStoreEvictionPolicy class.
 	 * Default is "LRU".
 	 */
 	public void setMemoryStoreEvictionPolicy(MemoryStoreEvictionPolicy memoryStoreEvictionPolicy) {
@@ -239,9 +240,9 @@ public void setBlocking(boolean blocking) {
 	}
 
 	/**
-	 * Set an EHCache {@link net.sf.ehcache.constructs.blocking.CacheEntryFactory}
+	 * Set an EhCache {@link net.sf.ehcache.constructs.blocking.CacheEntryFactory}
 	 * to use for a self-populating cache. If such a factory is specified,
-	 * the cache will be decorated with EHCache's
+	 * the cache will be decorated with EhCache's
 	 * {@link net.sf.ehcache.constructs.blocking.SelfPopulatingCache}.
 	 * <p>The specified factory can be of type
 	 * {@link net.sf.ehcache.constructs.blocking.UpdatingCacheEntryFactory},
@@ -257,7 +258,7 @@ public void setCacheEntryFactory(CacheEntryFactory cacheEntryFactory) {
 	}
 
 	/**
-	 * Set an EHCache {@link net.sf.ehcache.bootstrap.BootstrapCacheLoader}
+	 * Set an EhCache {@link net.sf.ehcache.bootstrap.BootstrapCacheLoader}
 	 * for this cache, if any.
 	 */
 	public void setBootstrapCacheLoader(BootstrapCacheLoader bootstrapCacheLoader) {
@@ -265,7 +266,7 @@ public void setBootstrapCacheLoader(BootstrapCacheLoader bootstrapCacheLoader) {
 	}
 
 	/**
-	 * Specify EHCache {@link net.sf.ehcache.event.CacheEventListener cache event listeners}
+	 * Specify EhCache {@link net.sf.ehcache.event.CacheEventListener cache event listeners}
 	 * to registered with this cache.
 	 */
 	public void setCacheEventListeners(Set<CacheEventListener> cacheEventListeners) {
@@ -305,7 +306,7 @@ public void afterPropertiesSet() throws CacheException, IOException {
 		// If no CacheManager given, fetch the default.
 		if (this.cacheManager == null) {
 			if (logger.isDebugEnabled()) {
-				logger.debug("Using default EHCache CacheManager for cache region '" + this.cacheName + "'");
+				logger.debug("Using default EhCache CacheManager for cache region '" + this.cacheName + "'");
 			}
 			this.cacheManager = CacheManager.getInstance();
 		}
@@ -320,13 +321,13 @@ public void afterPropertiesSet() throws CacheException, IOException {
 		Ehcache rawCache;
 		if (this.cacheManager.cacheExists(this.cacheName)) {
 			if (logger.isDebugEnabled()) {
-				logger.debug("Using existing EHCache cache region '" + this.cacheName + "'");
+				logger.debug("Using existing EhCache cache region '" + this.cacheName + "'");
 			}
 			rawCache = this.cacheManager.getEhcache(this.cacheName);
 		}
 		else {
 			if (logger.isDebugEnabled()) {
-				logger.debug("Creating new EHCache cache region '" + this.cacheName + "'");
+				logger.debug("Creating new EhCache cache region '" + this.cacheName + "'");
 			}
 			rawCache = createCache();
 			this.cacheManager.addCache(rawCache);
@@ -359,7 +360,7 @@ public void afterPropertiesSet() throws CacheException, IOException {
 	 * Create a raw Cache object based on the configuration of this FactoryBean.
 	 */
 	protected Cache createCache() {
-		// Only call EHCache 1.6 constructor if actually necessary (for compatibility with EHCache 1.3+)
+		// Only call EhCache 1.6 constructor if actually necessary (for compatibility with EhCache 1.3+)
 		return (!this.clearOnFlush) ?
 				new Cache(this.cacheName, this.maxElementsInMemory, this.memoryStoreEvictionPolicy,
 						this.overflowToDisk, null, this.eternal, this.timeToLive, this.timeToIdle,
diff --git a/spring-context-support/src/main/java/org/springframework/cache/ehcache/EhCacheManagerFactoryBean.java b/spring-context-support/src/main/java/org/springframework/cache/ehcache/EhCacheManagerFactoryBean.java
index a170eb84f85d..a94c1fe2cb17 100644
--- a/spring-context-support/src/main/java/org/springframework/cache/ehcache/EhCacheManagerFactoryBean.java
+++ b/spring-context-support/src/main/java/org/springframework/cache/ehcache/EhCacheManagerFactoryBean.java
@@ -35,19 +35,20 @@
 import org.springframework.util.ReflectionUtils;
 
 /**
- * {@link FactoryBean} that exposes an EHCache {@link net.sf.ehcache.CacheManager}
+ * {@link FactoryBean} that exposes an EhCache {@link net.sf.ehcache.CacheManager}
  * instance (independent or shared), configured from a specified config location.
  *
  * <p>If no config location is specified, a CacheManager will be configured from
- * "ehcache.xml" in the root of the class path (that is, default EHCache initialization
- * - as defined in the EHCache docs - will apply).
+ * "ehcache.xml" in the root of the class path (that is, default EhCache initialization
+ * - as defined in the EhCache docs - will apply).
  *
  * <p>Setting up a separate EhCacheManagerFactoryBean is also advisable when using
  * EhCacheFactoryBean, as it provides a (by default) independent CacheManager instance
  * and cares for proper shutdown of the CacheManager. EhCacheManagerFactoryBean is
- * also necessary for loading EHCache configuration from a non-default config location.
+ * also necessary for loading EhCache configuration from a non-default config location.
  *
- * <p>Note: As of Spring 3.0, Spring's EHCache support requires EHCache 1.3 or higher.
+ * <p>Note: As of Spring 3.0, Spring's EhCache support requires EhCache 1.3 or higher.
+ * As of Spring 3.2, we recommend using EhCache 2.1 or higher.
  *
  * @author Dmitriy Kopylenko
  * @author Juergen Hoeller
@@ -59,7 +60,7 @@
  */
 public class EhCacheManagerFactoryBean implements FactoryBean<CacheManager>, InitializingBean, DisposableBean {
 
-	// Check whether EHCache 2.1+ CacheManager.create(Configuration) method is available...
+	// Check whether EhCache 2.1+ CacheManager.create(Configuration) method is available...
 	private static final Method createWithConfiguration =
 			ClassUtils.getMethodIfAvailable(CacheManager.class, "create", Configuration.class);
 
@@ -75,9 +76,9 @@ public class EhCacheManagerFactoryBean implements FactoryBean<CacheManager>, Ini
 
 
 	/**
-	 * Set the location of the EHCache config file. A typical value is "/WEB-INF/ehcache.xml".
+	 * Set the location of the EhCache config file. A typical value is "/WEB-INF/ehcache.xml".
 	 * <p>Default is "ehcache.xml" in the root of the class path, or if not found,
-	 * "ehcache-failsafe.xml" in the EHCache jar (default EHCache initialization).
+	 * "ehcache-failsafe.xml" in the EhCache jar (default EhCache initialization).
 	 * @see net.sf.ehcache.CacheManager#create(java.io.InputStream)
 	 * @see net.sf.ehcache.CacheManager#CacheManager(java.io.InputStream)
 	 */
@@ -86,7 +87,7 @@ public void setConfigLocation(Resource configLocation) {
 	}
 
 	/**
-	 * Set whether the EHCache CacheManager should be shared (as a singleton at the VM level)
+	 * Set whether the EhCache CacheManager should be shared (as a singleton at the VM level)
 	 * or independent (typically local within the application). Default is "false", creating
 	 * an independent instance.
 	 * @see net.sf.ehcache.CacheManager#create()
@@ -97,7 +98,7 @@ public void setShared(boolean shared) {
 	}
 
 	/**
-	 * Set the name of the EHCache CacheManager (if a specific name is desired).
+	 * Set the name of the EhCache CacheManager (if a specific name is desired).
 	 * @see net.sf.ehcache.CacheManager#setName(String)
 	 */
 	public void setCacheManagerName(String cacheManagerName) {
@@ -106,14 +107,14 @@ public void setCacheManagerName(String cacheManagerName) {
 
 
 	public void afterPropertiesSet() throws IOException, CacheException {
-		logger.info("Initializing EHCache CacheManager");
+		logger.info("Initializing EhCache CacheManager");
 		InputStream is = (this.configLocation != null ? this.configLocation.getInputStream() : null);
 		try {
-			// A bit convoluted for EHCache 1.x/2.0 compatibility.
-			// To be much simpler once we require EHCache 2.1+
+			// A bit convoluted for EhCache 1.x/2.0 compatibility.
+			// To be much simpler once we require EhCache 2.1+
 			if (this.cacheManagerName != null) {
 				if (this.shared && createWithConfiguration == null) {
-					// No CacheManager.create(Configuration) method available before EHCache 2.1;
+					// No CacheManager.create(Configuration) method available before EhCache 2.1;
 					// can only set CacheManager name after creation.
 					this.cacheManager = (is != null ? CacheManager.create(is) : CacheManager.create());
 					this.cacheManager.setName(this.cacheManagerName);
@@ -160,7 +161,7 @@ public boolean isSingleton() {
 
 
 	public void destroy() {
-		logger.info("Shutting down EHCache CacheManager");
+		logger.info("Shutting down EhCache CacheManager");
 		this.cacheManager.shutdown();
 	}
 
diff --git a/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java
index 84db22173a5e..ed8baa41dff6 100644
--- a/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java
+++ b/spring-context-support/src/main/java/org/springframework/scheduling/quartz/SchedulerFactoryBean.java
@@ -173,7 +173,7 @@ public static DataSource getConfigTimeNonTransactionalDataSource() {
 	private DataSource nonTransactionalDataSource;
 
 
-	private Map schedulerContextMap;
+    private Map schedulerContextMap;
 
 	private ApplicationContext applicationContext;
 
diff --git a/spring-context-support/src/test/java/org/springframework/cache/ehcache/EhCacheSupportTests.java b/spring-context-support/src/test/java/org/springframework/cache/ehcache/EhCacheSupportTests.java
index fcfe22164250..6e8efcd81656 100644
--- a/spring-context-support/src/test/java/org/springframework/cache/ehcache/EhCacheSupportTests.java
+++ b/spring-context-support/src/test/java/org/springframework/cache/ehcache/EhCacheSupportTests.java
@@ -133,7 +133,6 @@ private void doTestEhCacheFactoryBean(boolean useCacheManagerFb) throws Exceptio
 			cacheFb.setBeanName("undefinedCache2");
 			cacheFb.setMaxElementsInMemory(5);
 			cacheFb.setOverflowToDisk(false);
-			cacheFb.setEternal(true);
 			cacheFb.setTimeToLive(8);
 			cacheFb.setTimeToIdle(7);
 			cacheFb.setDiskPersistent(true);
@@ -145,7 +144,6 @@ private void doTestEhCacheFactoryBean(boolean useCacheManagerFb) throws Exceptio
 			assertEquals("undefinedCache2", cache.getName());
 			assertTrue("overridden maxElements is correct", config.getMaxElementsInMemory() == 5);
 			assertFalse("overridden overflowToDisk is correct", config.isOverflowToDisk());
-			assertTrue("overridden eternal is correct", config.isEternal());
 			assertTrue("default timeToLive is correct", config.getTimeToLiveSeconds() == 8);
 			assertTrue("default timeToIdle is correct", config.getTimeToIdleSeconds() == 7);
 			assertTrue("overridden diskPersistent is correct", config.isDiskPersistent());
diff --git a/spring-context-support/src/test/java/org/springframework/scheduling/quartz/QuartzSupportTests.java b/spring-context-support/src/test/java/org/springframework/scheduling/quartz/QuartzSupportTests.java
index ca55ed9a0e19..04d7bda02f3f 100644
--- a/spring-context-support/src/test/java/org/springframework/scheduling/quartz/QuartzSupportTests.java
+++ b/spring-context-support/src/test/java/org/springframework/scheduling/quartz/QuartzSupportTests.java
@@ -16,15 +16,6 @@
 
 package org.springframework.scheduling.quartz;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.util.Arrays;
 import java.util.Date;
 import java.util.HashMap;
@@ -52,19 +43,22 @@
 import org.quartz.TriggerListener;
 import org.quartz.impl.SchedulerRepository;
 import org.quartz.spi.JobFactory;
-import org.springframework.tests.context.TestMethodInvokingTask;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.beans.factory.config.BeanDefinition;
 import org.springframework.beans.factory.support.BeanDefinitionBuilder;
 import org.springframework.beans.factory.support.RootBeanDefinition;
 import org.springframework.beans.factory.support.StaticListableBeanFactory;
-import org.springframework.tests.Assume;
-import org.springframework.tests.TestGroup;
 import org.springframework.context.support.ClassPathXmlApplicationContext;
 import org.springframework.context.support.StaticApplicationContext;
 import org.springframework.core.io.FileSystemResourceLoader;
 import org.springframework.core.task.TaskExecutor;
 import org.springframework.jdbc.core.JdbcTemplate;
+import org.springframework.tests.Assume;
+import org.springframework.tests.TestGroup;
+import org.springframework.tests.context.TestMethodInvokingTask;
+import org.springframework.tests.sample.beans.TestBean;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Juergen Hoeller
diff --git a/spring-context/src/main/java/org/springframework/cache/annotation/CachePut.java b/spring-context/src/main/java/org/springframework/cache/annotation/CachePut.java
index 0cc7f883f193..3ab2f52b0a0e 100644
--- a/spring-context/src/main/java/org/springframework/cache/annotation/CachePut.java
+++ b/spring-context/src/main/java/org/springframework/cache/annotation/CachePut.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,6 +32,7 @@
  * always causes the method to be invoked and its result to be placed into the cache.
  *
  * @author Costin Leau
+ * @author Phillip Webb
  * @since 3.1
  */
 @Target({ ElementType.METHOD, ElementType.TYPE })
@@ -58,4 +59,13 @@
 	 * <p>Default is "", meaning the method result is always cached.
 	 */
 	String condition() default "";
+
+	/**
+	 * Spring Expression Language (SpEL) attribute used to veto the cache update.
+	 * <p>Unlike {@link #condition()}, this expression is evaluated after the method
+	 * has been called and can therefore refer to the {@code result}. Default is "",
+	 * meaning that caching is never vetoed.
+	 * @since 3.2
+	 */
+	String unless() default "";
 }
diff --git a/spring-context/src/main/java/org/springframework/cache/annotation/Cacheable.java b/spring-context/src/main/java/org/springframework/cache/annotation/Cacheable.java
index 716b840ad0e6..1ab8df5762f0 100644
--- a/spring-context/src/main/java/org/springframework/cache/annotation/Cacheable.java
+++ b/spring-context/src/main/java/org/springframework/cache/annotation/Cacheable.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,6 +30,7 @@
  * returned instance is used as the cache value.
  *
  * @author Costin Leau
+ * @author Phillip Webb
  * @since 3.1
  */
 @Target({ElementType.METHOD, ElementType.TYPE})
@@ -56,4 +57,13 @@
 	 * <p>Default is "", meaning the method is always cached.
 	 */
 	String condition() default "";
+
+	/**
+	 * Spring Expression Language (SpEL) attribute used to veto method caching.
+	 * <p>Unlike {@link #condition()}, this expression is evaluated after the method
+	 * has been called and can therefore refer to the {@code result}. Default is "",
+	 * meaning that caching is never vetoed.
+	 * @since 3.2
+	 */
+	String unless() default "";
 }
diff --git a/spring-context/src/main/java/org/springframework/cache/annotation/Caching.java b/spring-context/src/main/java/org/springframework/cache/annotation/Caching.java
index 7d3e77d3192c..6bad879b76f8 100644
--- a/spring-context/src/main/java/org/springframework/cache/annotation/Caching.java
+++ b/spring-context/src/main/java/org/springframework/cache/annotation/Caching.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,7 @@
 
 package org.springframework.cache.annotation;
 
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Inherited;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
+import java.lang.annotation.*;
 
 /**
  * Group annotation for multiple cache annotations (of different or the same type).
@@ -30,7 +25,7 @@
  * @author Chris Beams
  * @since 3.1
  */
-@Target({ ElementType.METHOD, ElementType.TYPE })
+@Target({ElementType.METHOD, ElementType.TYPE})
 @Retention(RetentionPolicy.RUNTIME)
 @Inherited
 @Documented
@@ -41,4 +36,5 @@
 	CachePut[] put() default {};
 
 	CacheEvict[] evict() default {};
+
 }
diff --git a/spring-context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java b/spring-context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java
index 9114dfc6332b..d8c7575ce7e8 100644
--- a/spring-context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java
+++ b/spring-context/src/main/java/org/springframework/cache/annotation/SpringCacheAnnotationParser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -35,6 +35,7 @@
  * @author Costin Leau
  * @author Juergen Hoeller
  * @author Chris Beams
+ * @author Phillip Webb
  * @since 3.1
  */
 @SuppressWarnings("serial")
@@ -82,6 +83,7 @@ CacheableOperation parseCacheableAnnotation(AnnotatedElement ae, Cacheable cachi
 		CacheableOperation cuo = new CacheableOperation();
 		cuo.setCacheNames(caching.value());
 		cuo.setCondition(caching.condition());
+		cuo.setUnless(caching.unless());
 		cuo.setKey(caching.key());
 		cuo.setName(ae.toString());
 		return cuo;
@@ -102,6 +104,7 @@ CacheOperation parseUpdateAnnotation(AnnotatedElement ae, CachePut caching) {
 		CachePutOperation cuo = new CachePutOperation();
 		cuo.setCacheNames(caching.value());
 		cuo.setCondition(caching.condition());
+		cuo.setUnless(caching.unless());
 		cuo.setKey(caching.key());
 		cuo.setName(ae.toString());
 		return cuo;
diff --git a/spring-context/src/main/java/org/springframework/cache/config/CacheAdviceParser.java b/spring-context/src/main/java/org/springframework/cache/config/CacheAdviceParser.java
index a1206c576f7f..5092f474c73b 100644
--- a/spring-context/src/main/java/org/springframework/cache/config/CacheAdviceParser.java
+++ b/spring-context/src/main/java/org/springframework/cache/config/CacheAdviceParser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,6 +44,7 @@
  * BeanDefinitionParser} for the {@code <tx:advice/>} tag.
  *
  * @author Costin Leau
+ * @author Phillip Webb
  */
 class CacheAdviceParser extends AbstractSingleBeanDefinitionParser {
 
@@ -54,7 +55,9 @@ class CacheAdviceParser extends AbstractSingleBeanDefinitionParser {
 	 */
 	private static class Props {
 
-		private String key, condition, method;
+		private String key;
+		private String condition;
+		private String method;
 		private String[] caches = null;
 
 		Props(Element root) {
@@ -70,13 +73,9 @@ private static class Props {
 
 		<T extends CacheOperation> T merge(Element element, ReaderContext readerCtx, T op) {
 			String cache = element.getAttribute("cache");
-			String k = element.getAttribute("key");
-			String c = element.getAttribute("condition");
-
-			String[] localCaches = caches;
-			String localKey = key, localCondition = condition;
 
 			// sanity check
+			String[] localCaches = caches;
 			if (StringUtils.hasText(cache)) {
 				localCaches = StringUtils.commaDelimitedListToStringArray(cache.trim());
 			} else {
@@ -84,17 +83,10 @@ <T extends CacheOperation> T merge(Element element, ReaderContext readerCtx, T o
 					readerCtx.error("No cache specified specified for " + element.getNodeName(), element);
 				}
 			}
-
-			if (StringUtils.hasText(k)) {
-				localKey = k.trim();
-			}
-
-			if (StringUtils.hasText(c)) {
-				localCondition = c.trim();
-			}
 			op.setCacheNames(localCaches);
-			op.setKey(localKey);
-			op.setCondition(localCondition);
+
+			op.setKey(getAttributeValue(element, "key", this.key));
+			op.setCondition(getAttributeValue(element, "condition", this.condition));
 
 			return op;
 		}
@@ -165,7 +157,8 @@ private RootBeanDefinition parseDefinitionSource(Element definition, ParserConte
 			String name = prop.merge(opElement, parserContext.getReaderContext());
 			TypedStringValue nameHolder = new TypedStringValue(name);
 			nameHolder.setSource(parserContext.extractSource(opElement));
-			CacheOperation op = prop.merge(opElement, parserContext.getReaderContext(), new CacheableOperation());
+			CacheableOperation op = prop.merge(opElement, parserContext.getReaderContext(), new CacheableOperation());
+			op.setUnless(getAttributeValue(opElement, "unless", ""));
 
 			Collection<CacheOperation> col = cacheOpMap.get(nameHolder);
 			if (col == null) {
@@ -207,7 +200,8 @@ private RootBeanDefinition parseDefinitionSource(Element definition, ParserConte
 			String name = prop.merge(opElement, parserContext.getReaderContext());
 			TypedStringValue nameHolder = new TypedStringValue(name);
 			nameHolder.setSource(parserContext.extractSource(opElement));
-			CacheOperation op = prop.merge(opElement, parserContext.getReaderContext(), new CachePutOperation());
+			CachePutOperation op = prop.merge(opElement, parserContext.getReaderContext(), new CachePutOperation());
+			op.setUnless(getAttributeValue(opElement, "unless", ""));
 
 			Collection<CacheOperation> col = cacheOpMap.get(nameHolder);
 			if (col == null) {
@@ -222,4 +216,14 @@ private RootBeanDefinition parseDefinitionSource(Element definition, ParserConte
 		attributeSourceDefinition.getPropertyValues().add("nameMap", cacheOpMap);
 		return attributeSourceDefinition;
 	}
+
+
+	private static String getAttributeValue(Element element, String attributeName, String defaultValue) {
+		String attribute = element.getAttribute(attributeName);
+		if(StringUtils.hasText(attribute)) {
+			return attribute.trim();
+		}
+		return defaultValue;
+	}
+
 }
diff --git a/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java
index 7c62a21af7ae..8e0b36889d1d 100644
--- a/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java
+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -56,6 +56,7 @@
  * @author Costin Leau
  * @author Juergen Hoeller
  * @author Chris Beams
+ * @author Phillip Webb
  * @since 3.1
  */
 public abstract class CacheAspectSupport implements InitializingBean {
@@ -212,7 +213,7 @@ protected Object execute(Invoker invoker, Object target, Method method, Object[]
 
 			retVal = invoker.invoke();
 
-			inspectAfterCacheEvicts(ops.get(EVICT));
+			inspectAfterCacheEvicts(ops.get(EVICT), retVal);
 
 			if (!updates.isEmpty()) {
 				update(updates, retVal);
@@ -225,14 +226,16 @@ protected Object execute(Invoker invoker, Object target, Method method, Object[]
 	}
 
 	private void inspectBeforeCacheEvicts(Collection<CacheOperationContext> evictions) {
-		inspectCacheEvicts(evictions, true);
+		inspectCacheEvicts(evictions, true, ExpressionEvaluator.NO_RESULT);
 	}
 
-	private void inspectAfterCacheEvicts(Collection<CacheOperationContext> evictions) {
-		inspectCacheEvicts(evictions, false);
+	private void inspectAfterCacheEvicts(Collection<CacheOperationContext> evictions,
+			Object result) {
+		inspectCacheEvicts(evictions, false, result);
 	}
 
-	private void inspectCacheEvicts(Collection<CacheOperationContext> evictions, boolean beforeInvocation) {
+	private void inspectCacheEvicts(Collection<CacheOperationContext> evictions,
+			boolean beforeInvocation, Object result) {
 
 		if (!evictions.isEmpty()) {
 
@@ -242,7 +245,7 @@ private void inspectCacheEvicts(Collection<CacheOperationContext> evictions, boo
 				CacheEvictOperation evictOp = (CacheEvictOperation) context.operation;
 
 				if (beforeInvocation == evictOp.isBeforeInvocation()) {
-					if (context.isConditionPassing()) {
+					if (context.isConditionPassing(result)) {
 						// for each cache
 						// lazy key initialization
 						Object key = null;
@@ -278,7 +281,7 @@ private void inspectCacheEvicts(Collection<CacheOperationContext> evictions, boo
 	private CacheStatus inspectCacheables(Collection<CacheOperationContext> cacheables) {
 		Map<CacheOperationContext, Object> cUpdates = new LinkedHashMap<CacheOperationContext, Object>(cacheables.size());
 
-		boolean updateRequire = false;
+		boolean updateRequired = false;
 		Object retVal = null;
 
 		if (!cacheables.isEmpty()) {
@@ -305,7 +308,7 @@ private CacheStatus inspectCacheables(Collection<CacheOperationContext> cacheabl
 					boolean localCacheHit = false;
 
 					// check whether the cache needs to be inspected or not (the method will be invoked anyway)
-					if (!updateRequire) {
+					if (!updateRequired) {
 						for (Cache cache : context.getCaches()) {
 							Cache.ValueWrapper wrapper = cache.get(key);
 							if (wrapper != null) {
@@ -317,7 +320,7 @@ private CacheStatus inspectCacheables(Collection<CacheOperationContext> cacheabl
 					}
 
 					if (!localCacheHit) {
-						updateRequire = true;
+						updateRequired = true;
 					}
 				}
 				else {
@@ -329,7 +332,7 @@ private CacheStatus inspectCacheables(Collection<CacheOperationContext> cacheabl
 
 			// return a status only if at least on cacheable matched
 			if (atLeastOnePassed) {
-				return new CacheStatus(cUpdates, updateRequire, retVal);
+				return new CacheStatus(cUpdates, updateRequired, retVal);
 			}
 		}
 
@@ -386,8 +389,11 @@ private Map<CacheOperationContext, Object> inspectCacheUpdates(Collection<CacheO
 
 	private void update(Map<CacheOperationContext, Object> updates, Object retVal) {
 		for (Map.Entry<CacheOperationContext, Object> entry : updates.entrySet()) {
-			for (Cache cache : entry.getKey().getCaches()) {
-				cache.put(entry.getValue(), retVal);
+			CacheOperationContext operationContext = entry.getKey();
+			if(operationContext.canPutToCache(retVal)) {
+				for (Cache cache : operationContext.getCaches()) {
+					cache.put(entry.getValue(), retVal);
+				}
 			}
 		}
 	}
@@ -427,30 +433,49 @@ protected class CacheOperationContext {
 
 		private final CacheOperation operation;
 
-		private final Collection<Cache> caches;
-
-		private final Object target;
-
 		private final Method method;
 
 		private final Object[] args;
 
-		// context passed around to avoid multiple creations
-		private final EvaluationContext evalContext;
+		private final Object target;
+
+		private final Class<?> targetClass;
+
+		private final Collection<Cache> caches;
 
 		public CacheOperationContext(CacheOperation operation, Method method, Object[] args, Object target, Class<?> targetClass) {
 			this.operation = operation;
-			this.caches = CacheAspectSupport.this.getCaches(operation);
-			this.target = target;
 			this.method = method;
 			this.args = args;
-
-			this.evalContext = evaluator.createEvaluationContext(caches, method, args, target, targetClass);
+			this.target = target;
+			this.targetClass = targetClass;
+			this.caches = CacheAspectSupport.this.getCaches(operation);
 		}
 
 		protected boolean isConditionPassing() {
+			return isConditionPassing(ExpressionEvaluator.NO_RESULT);
+		}
+
+		protected boolean isConditionPassing(Object result) {
 			if (StringUtils.hasText(this.operation.getCondition())) {
-				return evaluator.condition(this.operation.getCondition(), this.method, this.evalContext);
+				EvaluationContext evaluationContext = createEvaluationContext(result);
+				return evaluator.condition(this.operation.getCondition(), this.method,
+						evaluationContext);
+			}
+			return true;
+		}
+
+		protected boolean canPutToCache(Object value) {
+			String unless = "";
+			if (this.operation instanceof CacheableOperation) {
+				unless = ((CacheableOperation) this.operation).getUnless();
+			}
+			else if (this.operation instanceof CachePutOperation) {
+				unless = ((CachePutOperation) this.operation).getUnless();
+			}
+			if(StringUtils.hasText(unless)) {
+				EvaluationContext evaluationContext = createEvaluationContext(value);
+				return !evaluator.unless(unless, this.method, evaluationContext);
 			}
 			return true;
 		}
@@ -461,13 +486,19 @@ protected boolean isConditionPassing() {
 		 */
 		protected Object generateKey() {
 			if (StringUtils.hasText(this.operation.getKey())) {
-				return evaluator.key(this.operation.getKey(), this.method, this.evalContext);
+				EvaluationContext evaluationContext = createEvaluationContext(ExpressionEvaluator.NO_RESULT);
+				return evaluator.key(this.operation.getKey(), this.method, evaluationContext);
 			}
 			return keyGenerator.generate(this.target, this.method, this.args);
 		}
 
+		private EvaluationContext createEvaluationContext(Object result) {
+			return evaluator.createEvaluationContext(this.caches, this.method, this.args,
+					this.target, this.targetClass, result);
+		}
+
 		protected Collection<Cache> getCaches() {
 			return this.caches;
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/cache/interceptor/CacheEvictOperation.java b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheEvictOperation.java
index 62186d896611..f671c84f759f 100644
--- a/spring-context/src/main/java/org/springframework/cache/interceptor/CacheEvictOperation.java
+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheEvictOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,6 +27,7 @@ public class CacheEvictOperation extends CacheOperation {
 	private boolean cacheWide = false;
 	private boolean beforeInvocation = false;
 
+
 	public void setCacheWide(boolean cacheWide) {
 		this.cacheWide = cacheWide;
 	}
diff --git a/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperation.java b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperation.java
index cd8a40ceb2c8..46d84590e8e7 100644
--- a/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperation.java
+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -119,10 +119,10 @@ protected StringBuilder getOperationDescription() {
 		result.append(this.name);
 		result.append("] caches=");
 		result.append(this.cacheNames);
-		result.append(" | condition='");
-		result.append(this.condition);
-		result.append("' | key='");
+		result.append(" | key='");
 		result.append(this.key);
+		result.append("' | condition='");
+		result.append(this.condition);
 		result.append("'");
 		return result;
 	}
diff --git a/spring-context/src/main/java/org/springframework/cache/interceptor/CachePutOperation.java b/spring-context/src/main/java/org/springframework/cache/interceptor/CachePutOperation.java
index edb84ba156bc..e6a61b0adfb9 100644
--- a/spring-context/src/main/java/org/springframework/cache/interceptor/CachePutOperation.java
+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CachePutOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,8 +20,28 @@
  * Class describing a cache 'put' operation.
  *
  * @author Costin Leau
+ * @author Phillip Webb
  * @since 3.1
  */
 public class CachePutOperation extends CacheOperation {
 
+	private String unless;
+
+
+	public String getUnless() {
+		return unless;
+	}
+
+	public void setUnless(String unless) {
+		this.unless = unless;
+	}
+
+	@Override
+	protected StringBuilder getOperationDescription() {
+		StringBuilder sb = super.getOperationDescription();
+		sb.append(" | unless='");
+		sb.append(this.unless);
+		sb.append("'");
+		return sb;
+	}
 }
diff --git a/spring-context/src/main/java/org/springframework/cache/interceptor/CacheableOperation.java b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheableOperation.java
index 23c0b20e2c84..f9375a9a54eb 100644
--- a/spring-context/src/main/java/org/springframework/cache/interceptor/CacheableOperation.java
+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/CacheableOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,8 +20,28 @@
  * Class describing a cache 'cacheable' operation.
  *
  * @author Costin Leau
+ * @author Phillip Webb
  * @since 3.1
  */
 public class CacheableOperation extends CacheOperation {
 
+	private String unless;
+
+
+	public String getUnless() {
+		return unless;
+	}
+
+	public void setUnless(String unless) {
+		this.unless = unless;
+	}
+
+	@Override
+	protected StringBuilder getOperationDescription() {
+		StringBuilder sb = super.getOperationDescription();
+		sb.append(" | unless='");
+		sb.append(this.unless);
+		sb.append("'");
+		return sb;
+	}
 }
diff --git a/spring-context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java b/spring-context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java
index 2ee38bb87280..ba109397a22b 100644
--- a/spring-context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java
+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/ExpressionEvaluator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -35,49 +35,84 @@
  * <p>Performs internal caching for performance reasons.
  *
  * @author Costin Leau
+ * @author Phillip Webb
  * @since 3.1
  */
 class ExpressionEvaluator {
 
+	public static final Object NO_RESULT = new Object();
+
 	private final SpelExpressionParser parser = new SpelExpressionParser();
 
 	// shared param discoverer since it caches data internally
 	private final ParameterNameDiscoverer paramNameDiscoverer = new LocalVariableTableParameterNameDiscoverer();
 
+	private final Map<String, Expression> keyCache = new ConcurrentHashMap<String, Expression>(64);
+
 	private final Map<String, Expression> conditionCache = new ConcurrentHashMap<String, Expression>(64);
 
-	private final Map<String, Expression> keyCache = new ConcurrentHashMap<String, Expression>(64);
+	private final Map<String, Expression> unlessCache = new ConcurrentHashMap<String, Expression>(64);
 
 	private final Map<String, Method> targetMethodCache = new ConcurrentHashMap<String, Method>(64);
 
 
-	public EvaluationContext createEvaluationContext(
-			Collection<Cache> caches, Method method, Object[] args, Object target, Class<?> targetClass) {
+	/**
+	 * Create an {@link EvaluationContext} without a return value.
+	 * @see #createEvaluationContext(Collection, Method, Object[], Object, Class, Object)
+	 */
+	public EvaluationContext createEvaluationContext(Collection<Cache> caches,
+			Method method, Object[] args, Object target, Class<?> targetClass) {
+		return createEvaluationContext(caches, method, args, target, targetClass,
+				NO_RESULT);
+	}
 
-		CacheExpressionRootObject rootObject =
-				new CacheExpressionRootObject(caches, method, args, target, targetClass);
-		return new LazyParamAwareEvaluationContext(rootObject,
+	/**
+	 * Create an {@link EvaluationContext}.
+	 *
+	 * @param caches the current caches
+	 * @param method the method
+	 * @param args the method arguments
+	 * @param target the target object
+	 * @param targetClass the target class
+	 * @param result the return value (can be {@code null}) or
+	 *        {@link #NO_RESULT} if there is no return at this time
+	 * @return the evalulation context
+	 */
+	public EvaluationContext createEvaluationContext(Collection<Cache> caches,
+			Method method, Object[] args, Object target, Class<?> targetClass,
+			final Object result) {
+		CacheExpressionRootObject rootObject = new CacheExpressionRootObject(caches,
+				method, args, target, targetClass);
+		LazyParamAwareEvaluationContext evaluationContext = new LazyParamAwareEvaluationContext(rootObject,
 				this.paramNameDiscoverer, method, args, targetClass, this.targetMethodCache);
+		if(result != NO_RESULT) {
+			evaluationContext.setVariable("result", result);
+		}
+		return evaluationContext;
+	}
+
+	public Object key(String keyExpression, Method method, EvaluationContext evalContext) {
+		return getExpression(this.keyCache, keyExpression, method).getValue(evalContext);
 	}
 
 	public boolean condition(String conditionExpression, Method method, EvaluationContext evalContext) {
-		String key = toString(method, conditionExpression);
-		Expression condExp = this.conditionCache.get(key);
-		if (condExp == null) {
-			condExp = this.parser.parseExpression(conditionExpression);
-			this.conditionCache.put(key, condExp);
-		}
-		return condExp.getValue(evalContext, boolean.class);
+		return getExpression(this.conditionCache, conditionExpression, method).getValue(
+				evalContext, boolean.class);
 	}
 
-	public Object key(String keyExpression, Method method, EvaluationContext evalContext) {
-		String key = toString(method, keyExpression);
-		Expression keyExp = this.keyCache.get(key);
-		if (keyExp == null) {
-			keyExp = this.parser.parseExpression(keyExpression);
-			this.keyCache.put(key, keyExp);
+	public boolean unless(String unlessExpression, Method method, EvaluationContext evalContext) {
+		return getExpression(this.unlessCache, unlessExpression, method).getValue(
+				evalContext, boolean.class);
+	}
+
+	private Expression getExpression(Map<String, Expression> cache, String expression, Method method) {
+		String key = toString(method, expression);
+		Expression rtn = cache.get(key);
+		if (rtn == null) {
+			rtn = this.parser.parseExpression(expression);
+			cache.put(key, rtn);
 		}
-		return keyExp.getValue(evalContext);
+		return rtn;
 	}
 
 	private String toString(Method method, String expression) {
@@ -89,4 +124,4 @@ private String toString(Method method, String expression) {
 		sb.append(expression);
 		return sb.toString();
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/cache/interceptor/LazyParamAwareEvaluationContext.java b/spring-context/src/main/java/org/springframework/cache/interceptor/LazyParamAwareEvaluationContext.java
index c8c3e27905b7..7dc1289a41a1 100644
--- a/spring-context/src/main/java/org/springframework/cache/interceptor/LazyParamAwareEvaluationContext.java
+++ b/spring-context/src/main/java/org/springframework/cache/interceptor/LazyParamAwareEvaluationContext.java
@@ -117,4 +117,4 @@ private String toString(Method m) {
 		sb.append(m.toString());
 		return sb.toString();
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/AdviceMode.java b/spring-context/src/main/java/org/springframework/context/annotation/AdviceMode.java
index 91b82e2825d2..5b741d606943 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/AdviceMode.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/AdviceMode.java
@@ -29,4 +29,4 @@
 public enum AdviceMode {
 	PROXY,
 	ASPECTJ
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/Bean.java b/spring-context/src/main/java/org/springframework/context/annotation/Bean.java
index a0c8ab11593a..679352decf1c 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/Bean.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/Bean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -177,7 +177,7 @@
  * @see org.springframework.beans.factory.annotation.Autowired
  * @see org.springframework.beans.factory.annotation.Value
  */
-@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })
+@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 public @interface Bean {
@@ -190,7 +190,7 @@
 	String[] name() default {};
 
 	/**
-	 * Are dependencies to be injected via autowiring?
+	 * Are dependencies to be injected via convention-based autowiring by name or type?
 	 */
 	Autowire autowire() default Autowire.NO;
 
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.java b/spring-context/src/main/java/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.java
index a105e147f798..93a71336a0fb 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.java
@@ -725,4 +725,4 @@ public Class<?> getDependencyType() {
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java
index b09623c29c0f..ec3cf117ef76 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/Configuration.java
@@ -68,8 +68,7 @@
  * <beans>
  *    <context:annotation-config/>
  *    <bean class="com.acme.AppConfig"/>
- * </beans>
- * }</pre>
+ * </beans>}</pre>
  *
  * In the example above, {@code <context:annotation-config/>} is required in order to
  * enable {@link ConfigurationClassPostProcessor} and other annotation-related
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java
index e41aca172808..e1676c6eb2c5 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -256,7 +256,8 @@ else if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){
 		if (proxyMode != ScopedProxyMode.NO) {
 			BeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(
 					new BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);
-			beanDefToRegister = proxyDef.getBeanDefinition();
+			beanDefToRegister =
+					new ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);
 		}
 
 		if (logger.isDebugEnabled()) {
@@ -307,12 +308,17 @@ private void loadBeanDefinitionsFromImportedResources(
 	@SuppressWarnings("serial")
 	private static class ConfigurationClassBeanDefinition extends RootBeanDefinition implements AnnotatedBeanDefinition {
 
-		private AnnotationMetadata annotationMetadata;
+		private final AnnotationMetadata annotationMetadata;
 
 		public ConfigurationClassBeanDefinition(ConfigurationClass configClass) {
 			this.annotationMetadata = configClass.getMetadata();
 		}
 
+		public ConfigurationClassBeanDefinition(RootBeanDefinition original, ConfigurationClass configClass) {
+			super(original);
+			this.annotationMetadata = configClass.getMetadata();
+		}
+
 		private ConfigurationClassBeanDefinition(ConfigurationClassBeanDefinition original) {
 			super(original);
 			this.annotationMetadata = original.annotationMetadata;
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java
index 99678159d336..a74deefd0700 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassEnhancer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,17 +17,11 @@
 package org.springframework.context.annotation;
 
 import java.lang.reflect.Method;
+import java.util.Arrays;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
-import org.springframework.cglib.proxy.Callback;
-import org.springframework.cglib.proxy.CallbackFilter;
-import org.springframework.cglib.proxy.Enhancer;
-import org.springframework.cglib.proxy.MethodInterceptor;
-import org.springframework.cglib.proxy.MethodProxy;
-import org.springframework.cglib.proxy.NoOp;
-
 import org.springframework.aop.scope.ScopedProxyFactoryBean;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.DisposableBean;
@@ -35,6 +29,12 @@
 import org.springframework.beans.factory.config.BeanFactoryPostProcessor;
 import org.springframework.beans.factory.config.ConfigurableBeanFactory;
 import org.springframework.beans.factory.support.SimpleInstantiationStrategy;
+import org.springframework.cglib.proxy.Callback;
+import org.springframework.cglib.proxy.CallbackFilter;
+import org.springframework.cglib.proxy.Enhancer;
+import org.springframework.cglib.proxy.MethodInterceptor;
+import org.springframework.cglib.proxy.MethodProxy;
+import org.springframework.cglib.proxy.NoOp;
 import org.springframework.core.annotation.AnnotationUtils;
 import org.springframework.util.Assert;
 
@@ -52,25 +52,13 @@ class ConfigurationClassEnhancer {
 
 	private static final Log logger = LogFactory.getLog(ConfigurationClassEnhancer.class);
 
-	private static final Class<?>[] CALLBACK_TYPES = { BeanMethodInterceptor.class,
-		DisposableBeanMethodInterceptor.class, NoOp.class };
-
-	private static final CallbackFilter CALLBACK_FILTER = new CallbackFilter() {
-		public int accept(Method candidateMethod) {
-			// Set up the callback filter to return the index of the BeanMethodInterceptor when
-			// handling a @Bean-annotated method; otherwise, return index of the NoOp callback.
-			if (BeanAnnotationHelper.isBeanAnnotated(candidateMethod)) {
-				return 0;
-			}
-			if (DisposableBeanMethodInterceptor.isDestroyMethod(candidateMethod)) {
-				return 1;
-			}
-			return 2;
-		}
-	};
+	private static final CallbackFilter CALLBACK_FILTER = new ConfigurationClassCallbackFilter();
 
 	private static final Callback DISPOSABLE_BEAN_METHOD_INTERCEPTOR = new DisposableBeanMethodInterceptor();
 
+	private static final Class<?>[] CALLBACK_TYPES =
+			{BeanMethodInterceptor.class, DisposableBeanMethodInterceptor.class, NoOp.class};
+
 	private final Callback[] callbackInstances;
 
 
@@ -80,10 +68,8 @@ public int accept(Method candidateMethod) {
 	public ConfigurationClassEnhancer(ConfigurableBeanFactory beanFactory) {
 		Assert.notNull(beanFactory, "BeanFactory must not be null");
 		// Callback instances must be ordered in the same way as CALLBACK_TYPES and CALLBACK_FILTER
-		this.callbackInstances = new Callback[] {
-				new BeanMethodInterceptor(beanFactory),
-				DISPOSABLE_BEAN_METHOD_INTERCEPTOR,
-				NoOp.INSTANCE };
+		this.callbackInstances = new Callback[]
+				{new BeanMethodInterceptor(beanFactory), DISPOSABLE_BEAN_METHOD_INTERCEPTOR, NoOp.INSTANCE};
 	}
 
 	/**
@@ -111,21 +97,6 @@ public Class<?> enhance(Class<?> configClass) {
 		return enhancedClass;
 	}
 
-	/**
-	 * Marker interface to be implemented by all @Configuration CGLIB subclasses.
-	 * Facilitates idempotent behavior for {@link ConfigurationClassEnhancer#enhance(Class)}
-	 * through checking to see if candidate classes are already assignable to it, e.g.
-	 * have already been enhanced.
-	 * <p>Also extends {@link DisposableBean}, as all enhanced
-	 * {@code @Configuration} classes must de-register static CGLIB callbacks on
-	 * destruction, which is handled by the (private) {@code DisposableBeanMethodInterceptor}.
-	 * <p>Note that this interface is intended for framework-internal use only, however
-	 * must remain public in order to allow access to subclasses generated from other
-	 * packages (i.e. user code).
-	 */
-	public interface EnhancedConfiguration extends DisposableBean {
-	}
-
 	/**
 	 * Creates a new CGLIB {@link Enhancer} instance.
 	 */
@@ -151,6 +122,43 @@ private Class<?> createClass(Enhancer enhancer) {
 	}
 
 
+
+	/**
+	 * Marker interface to be implemented by all @Configuration CGLIB subclasses.
+	 * Facilitates idempotent behavior for {@link ConfigurationClassEnhancer#enhance(Class)}
+	 * through checking to see if candidate classes are already assignable to it, e.g.
+	 * have already been enhanced.
+	 * <p>Also extends {@link DisposableBean}, as all enhanced
+	 * {@code @Configuration} classes must de-register static CGLIB callbacks on
+	 * destruction, which is handled by the (private) {@code DisposableBeanMethodInterceptor}.
+	 * <p>Note that this interface is intended for framework-internal use only, however
+	 * must remain public in order to allow access to subclasses generated from other
+	 * packages (i.e. user code).
+	 */
+	public interface EnhancedConfiguration extends DisposableBean {
+	}
+
+
+	/**
+	 * CGLIB CallbackFilter implementation that points to BeanMethodInterceptor and
+	 * DisposableBeanMethodInterceptor.
+	 */
+	private static class ConfigurationClassCallbackFilter implements CallbackFilter {
+
+		public int accept(Method candidateMethod) {
+			// Set up the callback filter to return the index of the BeanMethodInterceptor when
+			// handling a @Bean-annotated method; otherwise, return index of the NoOp callback.
+			if (BeanAnnotationHelper.isBeanAnnotated(candidateMethod)) {
+				return 0;
+			}
+			if (DisposableBeanMethodInterceptor.isDestroyMethod(candidateMethod)) {
+				return 1;
+			}
+			return 2;
+		}
+	}
+
+
 	/**
 	 * Intercepts calls to {@link FactoryBean#getObject()}, delegating to calling
 	 * {@link BeanFactory#getBean(String)} in order to respect caching / scoping.
@@ -169,16 +177,15 @@ public GetObjectMethodInterceptor(ConfigurableBeanFactory beanFactory, String be
 		}
 
 		public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
-			return beanFactory.getBean(beanName);
+			return this.beanFactory.getBean(this.beanName);
 		}
-
 	}
 
 
 	/**
 	 * Intercepts the invocation of any {@link DisposableBean#destroy()} on @Configuration
 	 * class instances for the purpose of de-registering CGLIB callbacks. This helps avoid
-	 * garbage collection issues See SPR-7901.
+	 * garbage collection issues. See SPR-7901.
 	 * @see EnhancedConfiguration
 	 */
 	private static class DisposableBeanMethodInterceptor implements MethodInterceptor {
@@ -209,19 +216,16 @@ public static boolean isDestroyMethod(Method candidateMethod) {
 	 */
 	private static class BeanMethodInterceptor implements MethodInterceptor {
 
-		private static final Class<?>[] CALLBACK_TYPES = {
-			GetObjectMethodInterceptor.class, NoOp.class };
+		private static final Class<?>[] CALLBACK_TYPES = {GetObjectMethodInterceptor.class, NoOp.class};
 
-		private static final CallbackFilter CALLBACK_FITLER = new CallbackFilter() {
+		private static final CallbackFilter CALLBACK_FILTER = new CallbackFilter() {
 			public int accept(Method method) {
-				return method.getName().equals("getObject") ? 0 : 1;
+				return (method.getName().equals("getObject") ? 0 : 1);
 			}
 		};
 
-
 		private final ConfigurableBeanFactory beanFactory;
 
-
 		public BeanMethodInterceptor(ConfigurableBeanFactory beanFactory) {
 			this.beanFactory = beanFactory;
 		}
@@ -229,7 +233,6 @@ public BeanMethodInterceptor(ConfigurableBeanFactory beanFactory) {
 		/**
 		 * Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the
 		 * existence of this bean object.
-		 *
 		 * @throws Throwable as a catch-all for any exception that may be thrown when
 		 * invoking the super implementation of the proxied method i.e., the actual
 		 * {@code @Bean} method.
@@ -255,8 +258,8 @@ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object
 			// proxy that intercepts calls to getObject() and returns any cached bean instance.
 			// this ensures that the semantics of calling a FactoryBean from within @Bean methods
 			// is the same as that of referring to a FactoryBean within XML. See SPR-6602.
-			if (factoryContainsBean('&'+beanName) && factoryContainsBean(beanName)) {
-				Object factoryBean = this.beanFactory.getBean('&'+beanName);
+			if (factoryContainsBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName) && factoryContainsBean(beanName)) {
+				Object factoryBean = this.beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);
 				if (factoryBean instanceof ScopedProxyFactoryBean) {
 					// pass through - scoped proxy factory beans are a special case and should not
 					// be further proxied
@@ -267,9 +270,7 @@ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object
 				}
 			}
 
-			boolean factoryIsCaller = beanMethod.equals(SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod());
-			boolean factoryAlreadyContainsSingleton = this.beanFactory.containsSingleton(beanName);
-			if (factoryIsCaller && !factoryAlreadyContainsSingleton) {
+			if (isCurrentlyInvokedFactoryMethod(beanMethod) && !this.beanFactory.containsSingleton(beanName)) {
 				// the factory is calling the bean method in order to instantiate and register the bean
 				// (i.e. via a getBean() call) -> invoke the super implementation of the method to actually
 				// create the bean instance.
@@ -306,7 +307,7 @@ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object
 		}
 
 		/**
-		 * Check the beanFactory to see whether the bean named <var>beanName</var> already
+		 * Check the BeanFactory to see whether the bean named <var>beanName</var> already
 		 * exists. Accounts for the fact that the requested bean may be "in creation", i.e.:
 		 * we're in the middle of servicing the initial request for this bean. From an enhanced
 		 * factory method's perspective, this means that the bean does not actually yet exist,
@@ -319,9 +320,19 @@ public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object
 		 * @return whether <var>beanName</var> already exists in the factory
 		 */
 		private boolean factoryContainsBean(String beanName) {
-			boolean containsBean = this.beanFactory.containsBean(beanName);
-			boolean currentlyInCreation = this.beanFactory.isCurrentlyInCreation(beanName);
-			return (containsBean && !currentlyInCreation);
+			return (this.beanFactory.containsBean(beanName) && !this.beanFactory.isCurrentlyInCreation(beanName));
+		}
+
+		/**
+		 * Check whether the given method corresponds to the container's currently invoked
+		 * factory method. Compares method name and parameter types only in order to work
+		 * around a potential problem with covariant return types (currently only known
+		 * to happen on Groovy classes).
+		 */
+		private boolean isCurrentlyInvokedFactoryMethod(Method method) {
+			Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();
+			return (currentlyInvoked != null && method.getName().equals(currentlyInvoked.getName()) &&
+					Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()));
 		}
 
 		/**
@@ -335,13 +346,12 @@ private Object enhanceFactoryBean(Class<?> fbClass, String beanName) throws Inst
 			Enhancer enhancer = new Enhancer();
 			enhancer.setSuperclass(fbClass);
 			enhancer.setUseFactory(false);
-			enhancer.setCallbackFilter(CALLBACK_FITLER);
+			enhancer.setCallbackFilter(CALLBACK_FILTER);
 			// Callback instances must be ordered in the same way as CALLBACK_TYPES and CALLBACK_FILTER
 			Callback[] callbackInstances = new Callback[] {
 					new GetObjectMethodInterceptor(this.beanFactory, beanName),
 					NoOp.INSTANCE
 			};
-
 			enhancer.setCallbackTypes(CALLBACK_TYPES);
 			Class<?> fbSubclass = enhancer.createClass();
 			Enhancer.registerCallbacks(fbSubclass, callbackInstances);
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java
index 2901e5cea0d9..c03aca61ddfa 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -54,6 +54,7 @@
 import org.springframework.core.type.classreading.MetadataReader;
 import org.springframework.core.type.classreading.MetadataReaderFactory;
 import org.springframework.core.type.filter.AssignableTypeFilter;
+import org.springframework.util.CollectionUtils;
 import org.springframework.util.StringUtils;
 
 import static org.springframework.context.annotation.MetadataUtils.*;
@@ -228,7 +229,7 @@ protected AnnotationMetadata doProcessConfigurationClass(
 
 		// process any @Import annotations
 		Set<String> imports = getImports(metadata.getClassName(), null, new HashSet<String>());
-		if (imports != null && !imports.isEmpty()) {
+		if (!CollectionUtils.isEmpty(imports)) {
 			processImport(configClass, imports.toArray(new String[imports.size()]), true);
 		}
 
@@ -292,9 +293,8 @@ else if (superclass.startsWith("java")) {
 	 * @return a set of all {@link Import#value() import values} or {@code null}
 	 * @throws IOException if there is any problem reading metadata from the named class
 	 */
-	private Set<String> getImports(String className, Set<String> imports,
-			Set<String> visited) throws IOException {
-		if (visited.add(className)) {
+	private Set<String> getImports(String className, Set<String> imports, Set<String> visited) throws IOException {
+		if (visited.add(className) && !className.startsWith("java")) {
 			AnnotationMetadata metadata = metadataReaderFactory.getMetadataReader(className).getAnnotationMetadata();
 			for (String annotationType : metadata.getAnnotationTypes()) {
 				imports = getImports(annotationType, imports, visited);
@@ -331,7 +331,7 @@ private void processImport(ConfigurationClass configClass, String[] classesToImp
 						throw new IllegalStateException(ex);
 					}
 				}
-				else if (new AssignableTypeFilter(ImportBeanDefinitionRegistrar.class).match(reader, metadataReaderFactory)) {
+				else if (new AssignableTypeFilter(ImportBeanDefinitionRegistrar.class).match(reader, this.metadataReaderFactory)) {
 					// the candidate class is an ImportBeanDefinitionRegistrar -> delegate to it to register additional bean definitions
 					try {
 						ImportBeanDefinitionRegistrar registrar = BeanUtils.instantiateClass(
@@ -360,17 +360,16 @@ else if (new AssignableTypeFilter(ImportBeanDefinitionRegistrar.class).match(rea
 	private void invokeAwareMethods(ImportBeanDefinitionRegistrar registrar) {
 		if (registrar instanceof Aware) {
 			if (registrar instanceof ResourceLoaderAware) {
-				((ResourceLoaderAware) registrar).setResourceLoader(resourceLoader);
+				((ResourceLoaderAware) registrar).setResourceLoader(this.resourceLoader);
 			}
 			if (registrar instanceof BeanClassLoaderAware) {
-				ClassLoader classLoader =
-						registry instanceof ConfigurableBeanFactory ?
-						((ConfigurableBeanFactory) registry).getBeanClassLoader() :
-						resourceLoader.getClassLoader();
+				ClassLoader classLoader = (this.registry instanceof ConfigurableBeanFactory ?
+						((ConfigurableBeanFactory) this.registry).getBeanClassLoader() :
+						this.resourceLoader.getClassLoader());
 				((BeanClassLoaderAware) registrar).setBeanClassLoader(classLoader);
 			}
-			if (registrar instanceof BeanFactoryAware && registry instanceof BeanFactory) {
-				((BeanFactoryAware) registrar).setBeanFactory((BeanFactory) registry);
+			if (registrar instanceof BeanFactoryAware && this.registry instanceof BeanFactory) {
+				((BeanFactoryAware) registrar).setBeanFactory((BeanFactory) this.registry);
 			}
 		}
 	}
@@ -398,6 +397,7 @@ public ImportRegistry getImportRegistry() {
 		return this.importStack;
 	}
 
+
 	interface ImportRegistry {
 
 		String getImportingClassFor(String importedClass);
@@ -470,4 +470,5 @@ public CircularImportProblem(ConfigurationClass attemptedImport, Stack<Configura
 					new Location(importStack.peek().getResource(), metadata));
 		}
 	}
+
 }
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/EnableAspectJAutoProxy.java b/spring-context/src/main/java/org/springframework/context/annotation/EnableAspectJAutoProxy.java
index a4cf352a2b73..effcec5df915 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/EnableAspectJAutoProxy.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/EnableAspectJAutoProxy.java
@@ -110,4 +110,4 @@
 	 */
 	boolean proxyTargetClass() default false;
 
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/context/annotation/ImportBeanDefinitionRegistrar.java b/spring-context/src/main/java/org/springframework/context/annotation/ImportBeanDefinitionRegistrar.java
index da58779fd874..648a8e92113e 100644
--- a/spring-context/src/main/java/org/springframework/context/annotation/ImportBeanDefinitionRegistrar.java
+++ b/spring-context/src/main/java/org/springframework/context/annotation/ImportBeanDefinitionRegistrar.java
@@ -60,4 +60,4 @@ public interface ImportBeanDefinitionRegistrar {
 	public void registerBeanDefinitions(
 			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);
 
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/context/config/PropertyOverrideBeanDefinitionParser.java b/spring-context/src/main/java/org/springframework/context/config/PropertyOverrideBeanDefinitionParser.java
index c7ad16ac5013..3a70e3c5f064 100644
--- a/spring-context/src/main/java/org/springframework/context/config/PropertyOverrideBeanDefinitionParser.java
+++ b/spring-context/src/main/java/org/springframework/context/config/PropertyOverrideBeanDefinitionParser.java
@@ -44,4 +44,4 @@ protected void doParse(Element element, BeanDefinitionBuilder builder) {
 
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/context/event/SimpleApplicationEventMulticaster.java b/spring-context/src/main/java/org/springframework/context/event/SimpleApplicationEventMulticaster.java
index 2e13855d4a5d..71e4ec536940 100644
--- a/spring-context/src/main/java/org/springframework/context/event/SimpleApplicationEventMulticaster.java
+++ b/spring-context/src/main/java/org/springframework/context/event/SimpleApplicationEventMulticaster.java
@@ -87,7 +87,6 @@ public void multicastEvent(final ApplicationEvent event) {
 			Executor executor = getTaskExecutor();
 			if (executor != null) {
 				executor.execute(new Runnable() {
-					@SuppressWarnings("unchecked")
 					public void run() {
 						listener.onApplicationEvent(event);
 					}
diff --git a/spring-context/src/main/java/org/springframework/context/support/AbstractMessageSource.java b/spring-context/src/main/java/org/springframework/context/support/AbstractMessageSource.java
index 768c963d3b51..ddf87c933242 100644
--- a/spring-context/src/main/java/org/springframework/context/support/AbstractMessageSource.java
+++ b/spring-context/src/main/java/org/springframework/context/support/AbstractMessageSource.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
+import java.util.Properties;
 
 import org.springframework.context.HierarchicalMessageSource;
 import org.springframework.context.MessageSource;
@@ -64,6 +65,8 @@ public abstract class AbstractMessageSource extends MessageSourceSupport impleme
 
 	private MessageSource parentMessageSource;
 
+	private Properties commonMessages;
+
 	private boolean useCodeAsDefaultMessage = false;
 
 
@@ -75,6 +78,23 @@ public MessageSource getParentMessageSource() {
 		return this.parentMessageSource;
 	}
 
+	/**
+	 * Specify locale-independent common messages, with the message code as key
+	 * and the full message String (may contain argument placeholders) as value.
+	 * <p>May also link to an externally defined Properties object, e.g. defined
+	 * through a {@link org.springframework.beans.factory.config.PropertiesFactoryBean}.
+	 */
+	public void setCommonMessages(Properties commonMessages) {
+		this.commonMessages = commonMessages;
+	}
+
+	/**
+	 * Return a Properties object defining locale-independent common messages, if any.
+	 */
+	protected Properties getCommonMessages() {
+		return this.commonMessages;
+	}
+
 	/**
 	 * Set whether to use the message code as default message instead of
 	 * throwing a NoSuchMessageException. Useful for development and debugging.
@@ -210,6 +230,15 @@ protected String getMessageInternal(String code, Object[] args, Locale locale) {
 			}
 		}
 
+		// Check locale-independent common messages for the given message code.
+		Properties commonMessages = getCommonMessages();
+		if (commonMessages != null) {
+			String commonMessage = commonMessages.getProperty(code);
+			if (commonMessage != null) {
+				return formatMessage(commonMessage, args, locale);
+			}
+		}
+
 		// Not found -> check parent, if any.
 		return getMessageFromParent(code, argsToUse, locale);
 	}
diff --git a/spring-context/src/main/java/org/springframework/context/support/ResourceBundleMessageSource.java b/spring-context/src/main/java/org/springframework/context/support/ResourceBundleMessageSource.java
index eeca86a10809..8d711989d972 100644
--- a/spring-context/src/main/java/org/springframework/context/support/ResourceBundleMessageSource.java
+++ b/spring-context/src/main/java/org/springframework/context/support/ResourceBundleMessageSource.java
@@ -135,7 +135,7 @@ public void setBasename(String basename) {
 	 * @see #setBasename
 	 * @see java.util.ResourceBundle#getBundle(String)
 	 */
-	public void setBasenames(String... basenames)  {
+	public void setBasenames(String... basenames) {
 		if (basenames != null) {
 			this.basenames = new String[basenames.length];
 			for (int i = 0; i < basenames.length; i++) {
diff --git a/spring-context/src/main/java/org/springframework/ejb/access/SimpleRemoteSlsbInvokerInterceptor.java b/spring-context/src/main/java/org/springframework/ejb/access/SimpleRemoteSlsbInvokerInterceptor.java
index ce39ce9a6cd8..29de41bc3edf 100644
--- a/spring-context/src/main/java/org/springframework/ejb/access/SimpleRemoteSlsbInvokerInterceptor.java
+++ b/spring-context/src/main/java/org/springframework/ejb/access/SimpleRemoteSlsbInvokerInterceptor.java
@@ -110,7 +110,7 @@ protected Object doInvoke(MethodInvocation invocation) throws Throwable {
 			}
 			else if (targetEx instanceof CreateException) {
 				throw RmiClientInterceptorUtils.convertRmiAccessException(
-				    invocation.getMethod(), targetEx, "Could not create remote EJB [" + getJndiName() + "]");
+					invocation.getMethod(), targetEx, "Could not create remote EJB [" + getJndiName() + "]");
 			}
 			throw targetEx;
 		}
diff --git a/spring-context/src/main/java/org/springframework/format/datetime/DateFormatterRegistrar.java b/spring-context/src/main/java/org/springframework/format/datetime/DateFormatterRegistrar.java
index aedf1184373a..b74b53262b5b 100644
--- a/spring-context/src/main/java/org/springframework/format/datetime/DateFormatterRegistrar.java
+++ b/spring-context/src/main/java/org/springframework/format/datetime/DateFormatterRegistrar.java
@@ -40,20 +40,24 @@
 public class DateFormatterRegistrar implements FormatterRegistrar {
 
 
-	private DateFormatter dateFormatter = new DateFormatter();
+	private DateFormatter dateFormatter;
 
 
 	public void registerFormatters(FormatterRegistry registry) {
 		addDateConverters(registry);
-		registry.addFormatter(dateFormatter);
-		registry.addFormatterForFieldType(Calendar.class, dateFormatter);
 		registry.addFormatterForFieldAnnotation(new DateTimeFormatAnnotationFormatterFactory());
+
+		// In order to retain back compatibility we only register Date/Calendar
+		// types when a user defined formatter is specified (see SPR-10105)
+		if(this.dateFormatter != null) {
+			registry.addFormatter(this.dateFormatter);
+			registry.addFormatterForFieldType(Calendar.class, this.dateFormatter);
+		}
 	}
 
 	/**
-	 * Set the date formatter to register. If not specified the default {@link DateFormatter}
-	 * will be used. This method can be used if additional formatter configuration is
-	 * required.
+	 * Set the date formatter to register. If not specified no formatter is registered.
+	 * This method can be used if global formatter configuration is required.
 	 * @param dateFormatter the date formatter
 	 */
 	public void setFormatter(DateFormatter dateFormatter) {
@@ -117,7 +121,7 @@ private static class LongToCalendarConverter implements Converter<Long, Calendar
 		private DateToCalendarConverter dateToCalendarConverter = new DateToCalendarConverter();
 
 		public Calendar convert(Long source) {
-			return dateToCalendarConverter.convert(new Date(source));
+			return this.dateToCalendarConverter.convert(new Date(source));
 		}
 	}
 }
diff --git a/spring-context/src/main/java/org/springframework/format/datetime/joda/JodaTimeFormatterRegistrar.java b/spring-context/src/main/java/org/springframework/format/datetime/joda/JodaTimeFormatterRegistrar.java
index 51d9f9684b1c..7ad1a4e62e64 100644
--- a/spring-context/src/main/java/org/springframework/format/datetime/joda/JodaTimeFormatterRegistrar.java
+++ b/spring-context/src/main/java/org/springframework/format/datetime/joda/JodaTimeFormatterRegistrar.java
@@ -75,7 +75,7 @@ public JodaTimeFormatterRegistrar() {
 	 * Default is {@link DateTimeFormat#shortDate()}.
 	 */
 	public void setDateStyle(String dateStyle) {
-		factories.get(Type.DATE).setStyle(dateStyle+"-");
+		this.factories.get(Type.DATE).setStyle(dateStyle+"-");
 	}
 
 	/**
@@ -83,7 +83,7 @@ public void setDateStyle(String dateStyle) {
 	 * Default is {@link DateTimeFormat#shortTime()}.
 	 */
 	public void setTimeStyle(String timeStyle) {
-		factories.get(Type.TIME).setStyle("-"+timeStyle);
+		this.factories.get(Type.TIME).setStyle("-"+timeStyle);
 	}
 
 	/**
@@ -92,7 +92,7 @@ public void setTimeStyle(String timeStyle) {
 	 * Default is {@link DateTimeFormat#shortDateTime()}.
 	 */
 	public void setDateTimeStyle(String dateTimeStyle) {
-		factories.get(Type.DATE_TIME).setStyle(dateTimeStyle);
+		this.factories.get(Type.DATE_TIME).setStyle(dateTimeStyle);
 	}
 
 	/**
@@ -101,9 +101,9 @@ public void setDateTimeStyle(String dateTimeStyle) {
 	 * If set to true, the dateStyle, timeStyle, and dateTimeStyle properties are ignored.
 	 */
 	public void setUseIsoFormat(boolean useIsoFormat) {
-		factories.get(Type.DATE).setIso(useIsoFormat ? ISO.DATE : null);
-		factories.get(Type.TIME).setIso(useIsoFormat ? ISO.TIME : null);
-		factories.get(Type.DATE_TIME).setIso(useIsoFormat ? ISO.DATE_TIME : null);
+		this.factories.get(Type.DATE).setIso(useIsoFormat ? ISO.DATE : null);
+		this.factories.get(Type.TIME).setIso(useIsoFormat ? ISO.TIME : null);
+		this.factories.get(Type.DATE_TIME).setIso(useIsoFormat ? ISO.DATE_TIME : null);
 	}
 
 	/**
@@ -174,19 +174,28 @@ public void registerFormatters(FormatterRegistry registry) {
 		addFormatterForFields(registry,
 				new ReadableInstantPrinter(dateTimeFormatter),
 				new DateTimeParser(dateTimeFormatter),
-				ReadableInstant.class, Date.class, Calendar.class);
+				ReadableInstant.class);
+
+		// In order to retain back compatibility we only register Date/Calendar
+		// types when a user defined formatter is specified (see SPR-10105)
+		if(this.formatters.containsKey(Type.DATE_TIME)) {
+			addFormatterForFields(registry,
+					new ReadableInstantPrinter(dateTimeFormatter),
+					new DateTimeParser(dateTimeFormatter),
+					Date.class, Calendar.class);
+		}
 
 		registry.addFormatterForFieldAnnotation(
 				new JodaDateTimeFormatAnnotationFormatterFactory());
 	}
 
 	private DateTimeFormatter getFormatter(Type type) {
-		DateTimeFormatter formatter = formatters.get(type);
+		DateTimeFormatter formatter = this.formatters.get(type);
 		if(formatter != null) {
 			return formatter;
 		}
 		DateTimeFormatter fallbackFormatter = getFallbackFormatter(type);
-		return factories.get(type).createDateTimeFormatter(fallbackFormatter );
+		return this.factories.get(type).createDateTimeFormatter(fallbackFormatter );
 	}
 
 	private DateTimeFormatter getFallbackFormatter(Type type) {
diff --git a/spring-context/src/main/java/org/springframework/format/support/FormattingConversionService.java b/spring-context/src/main/java/org/springframework/format/support/FormattingConversionService.java
index 345131a5aa4d..7c5fceaed58a 100644
--- a/spring-context/src/main/java/org/springframework/format/support/FormattingConversionService.java
+++ b/spring-context/src/main/java/org/springframework/format/support/FormattingConversionService.java
@@ -195,7 +195,7 @@ private class AnnotationPrinterConverter implements ConditionalGenericConverter
 
 		private Class<? extends Annotation> annotationType;
 
-		private AnnotationFormatterFactory annotationFormatterFactory;
+        private AnnotationFormatterFactory annotationFormatterFactory;
 
 		private Class<?> fieldType;
 
diff --git a/spring-context/src/main/java/org/springframework/format/support/FormattingConversionServiceFactoryBean.java b/spring-context/src/main/java/org/springframework/format/support/FormattingConversionServiceFactoryBean.java
index 2dc19dda744f..25d20688ddee 100644
--- a/spring-context/src/main/java/org/springframework/format/support/FormattingConversionServiceFactoryBean.java
+++ b/spring-context/src/main/java/org/springframework/format/support/FormattingConversionServiceFactoryBean.java
@@ -116,7 +116,7 @@ public void setFormatterRegistrars(Set<FormatterRegistrar> formatterRegistrars)
 	/**
 	 * Indicate whether default formatters should be registered or not.
 	 * <p>By default, built-in formatters are registered. This flag can be used
-	 * to  turn that off and rely on explicitly registered formatters only.
+	 * to turn that off and rely on explicitly registered formatters only.
 	 * @see #setFormatters(Set)
 	 * @see #setFormatterRegistrars(Set)
 	 */
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/ReflectiveLoadTimeWeaver.java b/spring-context/src/main/java/org/springframework/instrument/classloading/ReflectiveLoadTimeWeaver.java
index 86907d33ddc3..14d1beeb8a61 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/ReflectiveLoadTimeWeaver.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/ReflectiveLoadTimeWeaver.java
@@ -135,4 +135,4 @@ public ClassLoader getThrowawayClassLoader() {
 			return new SimpleThrowawayClassLoader(this.classLoader);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/SimpleInstrumentableClassLoader.java b/spring-context/src/main/java/org/springframework/instrument/classloading/SimpleInstrumentableClassLoader.java
index e35bd31fcb7d..4405dc3fdc51 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/SimpleInstrumentableClassLoader.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/SimpleInstrumentableClassLoader.java
@@ -29,7 +29,7 @@
  * @author Costin Leau
  * @since 2.0
  */
-public class SimpleInstrumentableClassLoader extends OverridingClassLoader  {
+public class SimpleInstrumentableClassLoader extends OverridingClassLoader {
 
 	private final WeavingTransformer weavingTransformer;
 
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossMCAdapter.java b/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossMCAdapter.java
index a128608d84de..8ae2481ea522 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossMCAdapter.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossMCAdapter.java
@@ -142,4 +142,4 @@ public void addTransformer(ClassFileTransformer transformer) {
 	public ClassLoader getInstrumentableClassLoader() {
 		return classLoader;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossMCTranslatorAdapter.java b/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossMCTranslatorAdapter.java
index 8325e1b79824..2ba16e0f8e76 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossMCTranslatorAdapter.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossMCTranslatorAdapter.java
@@ -79,4 +79,4 @@ public String toString() {
 		builder.append(this.transformer);
 		return builder.toString();
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossModulesAdapter.java b/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossModulesAdapter.java
index f9ba2b62045d..03403036d06f 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossModulesAdapter.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/jboss/JBossModulesAdapter.java
@@ -68,4 +68,4 @@ public void addTransformer(ClassFileTransformer transformer) {
 	public ClassLoader getInstrumentableClassLoader() {
 		return classLoader;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JClassLoaderAdapter.java b/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JClassLoaderAdapter.java
index 723a947e1abd..b1300d699b11 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JClassLoaderAdapter.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JClassLoaderAdapter.java
@@ -85,4 +85,4 @@ public ClassLoader getThrowawayClassLoader() {
 			throw new IllegalStateException("Could not copy OC4J classloader", ex);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JClassPreprocessorAdapter.java b/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JClassPreprocessorAdapter.java
index dce576189814..5b56adf42ca5 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JClassPreprocessorAdapter.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JClassPreprocessorAdapter.java
@@ -92,4 +92,4 @@ public String toString() {
 		builder.append(this.transformer);
 		return builder.toString();
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JLoadTimeWeaver.java b/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JLoadTimeWeaver.java
index 1e71d0cdbbfe..54211b00d60a 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JLoadTimeWeaver.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/oc4j/OC4JLoadTimeWeaver.java
@@ -76,5 +76,4 @@ public ClassLoader getInstrumentableClassLoader() {
 	public ClassLoader getThrowawayClassLoader() {
 		return this.classLoader.getThrowawayClassLoader();
 	}
-
 }
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicClassLoaderAdapter.java b/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicClassLoaderAdapter.java
index 03b49e132607..e925e5bfc38b 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicClassLoaderAdapter.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicClassLoaderAdapter.java
@@ -110,4 +110,4 @@ public ClassLoader getThrowawayClassLoader() {
 			throw new IllegalStateException("Could not construct WebLogic GenericClassLoader", ex);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicClassPreProcessorAdapter.java b/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicClassPreProcessorAdapter.java
index aede3544be83..5967740664eb 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicClassPreProcessorAdapter.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicClassPreProcessorAdapter.java
@@ -87,4 +87,4 @@ public String toString() {
 		builder.append(this.transformer);
 		return builder.toString();
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicLoadTimeWeaver.java b/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicLoadTimeWeaver.java
index 6662830c73a8..a4e38db93d32 100644
--- a/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicLoadTimeWeaver.java
+++ b/spring-context/src/main/java/org/springframework/instrument/classloading/weblogic/WebLogicLoadTimeWeaver.java
@@ -69,4 +69,4 @@ public ClassLoader getInstrumentableClassLoader() {
 	public ClassLoader getThrowawayClassLoader() {
 		return this.classLoader.getThrowawayClassLoader();
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/jmx/export/SpringModelMBean.java b/spring-context/src/main/java/org/springframework/jmx/export/SpringModelMBean.java
index f313e65fbc39..95f1d07b5fb9 100644
--- a/spring-context/src/main/java/org/springframework/jmx/export/SpringModelMBean.java
+++ b/spring-context/src/main/java/org/springframework/jmx/export/SpringModelMBean.java
@@ -58,7 +58,7 @@ public SpringModelMBean() throws MBeanException, RuntimeOperationsException {
 	 * Construct a new SpringModelMBean instance with the given {@link ModelMBeanInfo}.
 	 * @see javax.management.modelmbean.RequiredModelMBean#RequiredModelMBean(ModelMBeanInfo)
 	 */
-	public SpringModelMBean(ModelMBeanInfo mbi) throws MBeanException, RuntimeOperationsException  {
+	public SpringModelMBean(ModelMBeanInfo mbi) throws MBeanException, RuntimeOperationsException {
 		super(mbi);
 	}
 
diff --git a/spring-context/src/main/java/org/springframework/remoting/rmi/RmiClientInterceptor.java b/spring-context/src/main/java/org/springframework/remoting/rmi/RmiClientInterceptor.java
index ba9d8775d996..fb8e9032755e 100644
--- a/spring-context/src/main/java/org/springframework/remoting/rmi/RmiClientInterceptor.java
+++ b/spring-context/src/main/java/org/springframework/remoting/rmi/RmiClientInterceptor.java
@@ -345,7 +345,7 @@ protected Object doInvoke(MethodInvocation invocation, Remote stub) throws Throw
 			}
 			catch (RemoteException ex) {
 				throw RmiClientInterceptorUtils.convertRmiAccessException(
-				    invocation.getMethod(), ex, isConnectFailure(ex), getServiceUrl());
+					invocation.getMethod(), ex, isConnectFailure(ex), getServiceUrl());
 			}
 			catch (InvocationTargetException ex) {
 				Throwable exToThrow = ex.getTargetException();
@@ -389,7 +389,7 @@ protected Object doInvoke(MethodInvocation invocation, Remote stub) throws Throw
 	 * @see org.springframework.remoting.support.RemoteInvocation
 	 */
 	protected Object doInvoke(MethodInvocation methodInvocation, RmiInvocationHandler invocationHandler)
-	    throws RemoteException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
+		throws RemoteException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
 
 		if (AopUtils.isToStringMethod(methodInvocation.getMethod())) {
 			return "RMI invoker proxy for service URL [" + getServiceUrl() + "]";
diff --git a/spring-context/src/main/java/org/springframework/remoting/rmi/RmiServiceExporter.java b/spring-context/src/main/java/org/springframework/remoting/rmi/RmiServiceExporter.java
index dcd5f91f85ba..81bf07e825cd 100644
--- a/spring-context/src/main/java/org/springframework/remoting/rmi/RmiServiceExporter.java
+++ b/spring-context/src/main/java/org/springframework/remoting/rmi/RmiServiceExporter.java
@@ -456,4 +456,4 @@ private void unexportObjectSilently() {
 			}
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/scheduling/annotation/AnnotationAsyncExecutionInterceptor.java b/spring-context/src/main/java/org/springframework/scheduling/annotation/AnnotationAsyncExecutionInterceptor.java
index a9abadab855d..542aa15e322b 100644
--- a/spring-context/src/main/java/org/springframework/scheduling/annotation/AnnotationAsyncExecutionInterceptor.java
+++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AnnotationAsyncExecutionInterceptor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -39,7 +39,7 @@ public class AnnotationAsyncExecutionInterceptor extends AsyncExecutionIntercept
 	/**
 	 * Create a new {@code AnnotationAsyncExecutionInterceptor} with the given executor.
 	 * @param defaultExecutor the executor to be used by default if no more specific
-	 * executor has been qualified at the method level using {@link Async#value()}.
+	 * executor has been qualified at the method level using {@link Async#value()}
 	 */
 	public AnnotationAsyncExecutionInterceptor(Executor defaultExecutor) {
 		super(defaultExecutor);
@@ -64,7 +64,7 @@ protected String getExecutorQualifier(Method method) {
 		if (async == null) {
 			async = AnnotationUtils.findAnnotation(method.getDeclaringClass(), Async.class);
 		}
-		return async == null ? null : async.value();
+		return (async != null ? async.value() : null);
 	}
 
 }
diff --git a/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationAdvisor.java b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationAdvisor.java
index 873740c21c79..35e57c59d202 100644
--- a/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationAdvisor.java
+++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationAdvisor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,7 +28,6 @@
 import org.springframework.aop.support.AbstractPointcutAdvisor;
 import org.springframework.aop.support.ComposablePointcut;
 import org.springframework.aop.support.annotation.AnnotationMatchingPointcut;
-import org.springframework.beans.BeansException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
 import org.springframework.core.task.SimpleAsyncTaskExecutor;
@@ -58,8 +57,6 @@ public class AsyncAnnotationAdvisor extends AbstractPointcutAdvisor implements B
 
 	private Pointcut pointcut;
 
-	private BeanFactory beanFactory;
-
 
 	/**
 	 * Create a new {@code AsyncAnnotationAdvisor} for bean-style configuration.
@@ -84,30 +81,15 @@ public AsyncAnnotationAdvisor(Executor executor) {
 			// If EJB 3.1 API not present, simply ignore.
 		}
 		this.advice = buildAdvice(executor);
-		this.setTaskExecutor(executor);
 		this.pointcut = buildPointcut(asyncAnnotationTypes);
 	}
 
-	/**
-	 * Set the {@code BeanFactory} to be used when looking up executors by qualifier.
-	 */
-	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
-		this.beanFactory = beanFactory;
-		delegateBeanFactory(beanFactory);
-	}
-
-	public void delegateBeanFactory(BeanFactory beanFactory) {
-		if (this.advice instanceof AnnotationAsyncExecutionInterceptor) {
-			((AnnotationAsyncExecutionInterceptor)this.advice).setBeanFactory(beanFactory);
-		}
-	}
 
 	/**
-	 * Specify the task executor to use for asynchronous methods.
+	 * Specify the default task executor to use for asynchronous methods.
 	 */
 	public void setTaskExecutor(Executor executor) {
 		this.advice = buildAdvice(executor);
-		delegateBeanFactory(this.beanFactory);
 	}
 
 	/**
@@ -126,6 +108,15 @@ public void setAsyncAnnotationType(Class<? extends Annotation> asyncAnnotationTy
 		this.pointcut = buildPointcut(asyncAnnotationTypes);
 	}
 
+	/**
+	 * Set the {@code BeanFactory} to be used when looking up executors by qualifier.
+	 */
+	public void setBeanFactory(BeanFactory beanFactory) {
+		if (this.advice instanceof BeanFactoryAware) {
+			((BeanFactoryAware) this.advice).setBeanFactory(beanFactory);
+		}
+	}
+
 
 	public Advice getAdvice() {
 		return this.advice;
diff --git a/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationBeanPostProcessor.java b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationBeanPostProcessor.java
index f4c7d65125e2..0ac2f757f033 100644
--- a/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationBeanPostProcessor.java
+++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/AsyncAnnotationBeanPostProcessor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -38,11 +38,15 @@
  * processor will detect both Spring's {@link Async @Async} annotation as well
  * as the EJB 3.1 {@code javax.ejb.Asynchronous} annotation.
  *
+ * <p>Note: The underlying async advisor applies before existing advisors by default,
+ * in order to switch to async execution as early as possible in the invocation chain.
+ *
  * @author Mark Fisher
  * @author Juergen Hoeller
  * @since 3.0
  * @see Async
  * @see AsyncAnnotationAdvisor
+ * @see #setBeforeExistingAdvisors
  */
 @SuppressWarnings("serial")
 public class AsyncAnnotationBeanPostProcessor extends AbstractAdvisingBeanPostProcessor
@@ -53,6 +57,10 @@ public class AsyncAnnotationBeanPostProcessor extends AbstractAdvisingBeanPostPr
 	private Executor executor;
 
 
+	public AsyncAnnotationBeanPostProcessor() {
+		setBeforeExistingAdvisors(true);
+	}
+
 	/**
 	 * Set the 'async' annotation type to be detected at either class or method
 	 * level. By default, both the {@link Async} annotation and the EJB 3.1
diff --git a/spring-context/src/main/java/org/springframework/scheduling/annotation/Scheduled.java b/spring-context/src/main/java/org/springframework/scheduling/annotation/Scheduled.java
index dea788ce088a..383e4adc5dee 100644
--- a/spring-context/src/main/java/org/springframework/scheduling/annotation/Scheduled.java
+++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/Scheduled.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,18 +64,41 @@
 	 */
 	long fixedDelay() default -1;
 
+	/**
+	 * Execute the annotated method with a fixed period between the end
+	 * of the last invocation and the start of the next.
+	 * @return the delay in milliseconds as a String value, e.g. a placeholder
+	 * @since 3.2.2
+	 */
+	String fixedDelayString() default "";
+
 	/**
 	 * Execute the annotated method with a fixed period between invocations.
 	 * @return the period in milliseconds
 	 */
 	long fixedRate() default -1;
 
+	/**
+	 * Execute the annotated method with a fixed period between invocations.
+	 * @return the period in milliseconds as a String value, e.g. a placeholder
+	 * @since 3.2.2
+	 */
+	String fixedRateString() default "";
+
 	/**
 	 * Number of milliseconds to delay before the first execution of a
 	 * {@link #fixedRate()} or {@link #fixedDelay()} task.
 	 * @return the initial delay in milliseconds
 	 * @since 3.2
 	 */
-	long initialDelay() default 0;
+	long initialDelay() default -1;
+
+	/**
+	 * Number of milliseconds to delay before the first execution of a
+	 * {@link #fixedRate()} or {@link #fixedDelay()} task.
+	 * @return the initial delay in milliseconds as a String value, e.g. a placeholder
+	 * @since 3.2.2
+	 */
+	String initialDelayString() default "";
 
 }
diff --git a/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java b/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java
index f5f236d2f9d5..754afc5bd671 100644
--- a/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java
+++ b/spring-context/src/main/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,7 +17,6 @@
 package org.springframework.scheduling.annotation;
 
 import java.lang.reflect.Method;
-
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ScheduledExecutorService;
@@ -111,53 +110,115 @@ public Object postProcessAfterInitialization(final Object bean, String beanName)
 			public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
 				Scheduled annotation = AnnotationUtils.getAnnotation(method, Scheduled.class);
 				if (annotation != null) {
-					Assert.isTrue(void.class.equals(method.getReturnType()),
-							"Only void-returning methods may be annotated with @Scheduled.");
-					Assert.isTrue(method.getParameterTypes().length == 0,
-							"Only no-arg methods may be annotated with @Scheduled.");
-					if (AopUtils.isJdkDynamicProxy(bean)) {
-						try {
-							// found a @Scheduled method on the target class for this JDK proxy -> is it
-							// also present on the proxy itself?
-							method = bean.getClass().getMethod(method.getName(), method.getParameterTypes());
+					try {
+						Assert.isTrue(void.class.equals(method.getReturnType()),
+								"Only void-returning methods may be annotated with @Scheduled");
+						Assert.isTrue(method.getParameterTypes().length == 0,
+								"Only no-arg methods may be annotated with @Scheduled");
+						if (AopUtils.isJdkDynamicProxy(bean)) {
+							try {
+								// found a @Scheduled method on the target class for this JDK proxy -> is it
+								// also present on the proxy itself?
+								method = bean.getClass().getMethod(method.getName(), method.getParameterTypes());
+							}
+							catch (SecurityException ex) {
+								ReflectionUtils.handleReflectionException(ex);
+							}
+							catch (NoSuchMethodException ex) {
+								throw new IllegalStateException(String.format(
+										"@Scheduled method '%s' found on bean target class '%s', " +
+										"but not found in any interface(s) for bean JDK proxy. Either " +
+										"pull the method up to an interface or switch to subclass (CGLIB) " +
+										"proxies by setting proxy-target-class/proxyTargetClass " +
+										"attribute to 'true'", method.getName(), targetClass.getSimpleName()));
+							}
 						}
-						catch (SecurityException ex) {
-							ReflectionUtils.handleReflectionException(ex);
+						Runnable runnable = new ScheduledMethodRunnable(bean, method);
+						boolean processedSchedule = false;
+						String errorMessage = "Exactly one of the 'cron', 'fixedDelay(String)', or 'fixedRate(String)' attributes is required";
+						// Determine initial delay
+						long initialDelay = annotation.initialDelay();
+						String initialDelayString = annotation.initialDelayString();
+						if (!"".equals(initialDelayString)) {
+							Assert.isTrue(initialDelay < 0, "Specify 'initialDelay' or 'initialDelayString', not both");
+							if (embeddedValueResolver != null) {
+								initialDelayString = embeddedValueResolver.resolveStringValue(initialDelayString);
+							}
+							try {
+								initialDelay = Integer.parseInt(initialDelayString);
+							}
+							catch (NumberFormatException ex) {
+								throw new IllegalArgumentException(
+										"Invalid initialDelayString value \"" + initialDelayString + "\" - cannot parse into integer");
+							}
 						}
-						catch (NoSuchMethodException ex) {
-							throw new IllegalStateException(String.format(
-									"@Scheduled method '%s' found on bean target class '%s', " +
-									"but not found in any interface(s) for bean JDK proxy. Either " +
-									"pull the method up to an interface or switch to subclass (CGLIB) " +
-									"proxies by setting proxy-target-class/proxyTargetClass " +
-									"attribute to 'true'", method.getName(), targetClass.getSimpleName()));
+						// Check cron expression
+						String cron = annotation.cron();
+						if (!"".equals(cron)) {
+							Assert.isTrue(initialDelay == -1, "'initialDelay' not supported for cron triggers");
+							processedSchedule = true;
+							if (embeddedValueResolver != null) {
+								cron = embeddedValueResolver.resolveStringValue(cron);
+							}
+							registrar.addCronTask(new CronTask(runnable, cron));
 						}
-					}
-					Runnable runnable = new ScheduledMethodRunnable(bean, method);
-					boolean processedSchedule = false;
-					String errorMessage = "Exactly one of the 'cron', 'fixedDelay', or 'fixedRate' attributes is required.";
-					String cron = annotation.cron();
-					if (!"".equals(cron)) {
-						processedSchedule = true;
-						if (embeddedValueResolver != null) {
-							cron = embeddedValueResolver.resolveStringValue(cron);
+						// At this point we don't need to differentiate between initial delay set or not anymore
+						if (initialDelay < 0) {
+							initialDelay = 0;
 						}
-						registrar.addCronTask(new CronTask(runnable, cron));
-					}
-					long initialDelay = annotation.initialDelay();
-					long fixedDelay = annotation.fixedDelay();
-					if (fixedDelay >= 0) {
-						Assert.isTrue(!processedSchedule, errorMessage);
-						processedSchedule = true;
-						registrar.addFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay));
+						// Check fixed delay
+						long fixedDelay = annotation.fixedDelay();
+						if (fixedDelay >= 0) {
+							Assert.isTrue(!processedSchedule, errorMessage);
+							processedSchedule = true;
+							registrar.addFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay));
+						}
+						String fixedDelayString = annotation.fixedDelayString();
+						if (!"".equals(fixedDelayString)) {
+							Assert.isTrue(!processedSchedule, errorMessage);
+							processedSchedule = true;
+							if (embeddedValueResolver != null) {
+								fixedDelayString = embeddedValueResolver.resolveStringValue(fixedDelayString);
+							}
+							try {
+								fixedDelay = Integer.parseInt(fixedDelayString);
+							}
+							catch (NumberFormatException ex) {
+								throw new IllegalArgumentException(
+										"Invalid fixedDelayString value \"" + fixedDelayString + "\" - cannot parse into integer");
+							}
+							registrar.addFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay));
+						}
+						// Check fixed rate
+						long fixedRate = annotation.fixedRate();
+						if (fixedRate >= 0) {
+							Assert.isTrue(!processedSchedule, errorMessage);
+							processedSchedule = true;
+							registrar.addFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay));
+						}
+						String fixedRateString = annotation.fixedRateString();
+						if (!"".equals(fixedRateString)) {
+							Assert.isTrue(!processedSchedule, errorMessage);
+							processedSchedule = true;
+							if (embeddedValueResolver != null) {
+								fixedRateString = embeddedValueResolver.resolveStringValue(fixedRateString);
+							}
+							try {
+								fixedRate = Integer.parseInt(fixedRateString);
+							}
+							catch (NumberFormatException ex) {
+								throw new IllegalArgumentException(
+										"Invalid fixedRateString value \"" + fixedRateString + "\" - cannot parse into integer");
+							}
+							registrar.addFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay));
+						}
+						// Check whether we had any attribute set
+						Assert.isTrue(processedSchedule, errorMessage);
 					}
-					long fixedRate = annotation.fixedRate();
-					if (fixedRate >= 0) {
-						Assert.isTrue(!processedSchedule, errorMessage);
-						processedSchedule = true;
-						registrar.addFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay));
+					catch (IllegalArgumentException ex) {
+						throw new IllegalStateException(
+								"Encountered invalid @Scheduled method '" + method.getName() + "': " + ex.getMessage());
 					}
-					Assert.isTrue(processedSchedule, errorMessage);
 				}
 			}
 		});
@@ -168,18 +229,14 @@ public void onApplicationEvent(ContextRefreshedEvent event) {
 		if (event.getApplicationContext() != this.applicationContext) {
 			return;
 		}
-
 		Map<String, SchedulingConfigurer> configurers =
 				this.applicationContext.getBeansOfType(SchedulingConfigurer.class);
-
 		if (this.scheduler != null) {
 			this.registrar.setScheduler(this.scheduler);
 		}
-
 		for (SchedulingConfigurer configurer : configurers.values()) {
 			configurer.configureTasks(this.registrar);
 		}
-
 		if (this.registrar.hasTasks() && this.registrar.getScheduler() == null) {
 			Map<String, ? super Object> schedulers = new HashMap<String, Object>();
 			schedulers.putAll(applicationContext.getBeansOfType(TaskScheduler.class));
@@ -199,7 +256,6 @@ else if (schedulers.size() >= 2){
 						"configureTasks() callback. Found the following beans: " + schedulers.keySet());
 			}
 		}
-
 		this.registrar.afterPropertiesSet();
 	}
 
diff --git a/spring-context/src/main/java/org/springframework/scheduling/config/IntervalTask.java b/spring-context/src/main/java/org/springframework/scheduling/config/IntervalTask.java
index 4b39927e8f74..567f9fdbfe12 100644
--- a/spring-context/src/main/java/org/springframework/scheduling/config/IntervalTask.java
+++ b/spring-context/src/main/java/org/springframework/scheduling/config/IntervalTask.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,8 +44,8 @@ public class IntervalTask extends Task {
 	 */
 	public IntervalTask(Runnable runnable, long interval, long initialDelay) {
 		super(runnable);
-		this.initialDelay = initialDelay;
 		this.interval = interval;
+		this.initialDelay = initialDelay;
 	}
 
 	/**
@@ -59,10 +59,11 @@ public IntervalTask(Runnable runnable, long interval) {
 
 
 	public long getInterval() {
-		return interval;
+		return this.interval;
 	}
 
 	public long getInitialDelay() {
-		return initialDelay;
+		return this.initialDelay;
 	}
+
 }
diff --git a/spring-context/src/main/java/org/springframework/scheduling/support/CronSequenceGenerator.java b/spring-context/src/main/java/org/springframework/scheduling/support/CronSequenceGenerator.java
index b3530ebf7859..68d127c72f33 100644
--- a/spring-context/src/main/java/org/springframework/scheduling/support/CronSequenceGenerator.java
+++ b/spring-context/src/main/java/org/springframework/scheduling/support/CronSequenceGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -69,8 +69,21 @@ public class CronSequenceGenerator {
 
 	private final TimeZone timeZone;
 
+
 	/**
-	 * Construct a {@link CronSequenceGenerator} from the pattern provided.
+	 * Construct a {@link CronSequenceGenerator} from the pattern provided,
+	 * using the default {@link TimeZone}.
+	 * @param expression a space-separated list of time fields
+	 * @throws IllegalArgumentException if the pattern cannot be parsed
+	 * @see java.util.TimeZone#getDefault()
+	 */
+	public CronSequenceGenerator(String expression) {
+		this(expression, TimeZone.getDefault());
+	}
+
+	/**
+	 * Construct a {@link CronSequenceGenerator} from the pattern provided,
+	 * using the specified {@link TimeZone}.
 	 * @param expression a space-separated list of time fields
 	 * @param timeZone the TimeZone to use for generated trigger times
 	 * @throws IllegalArgumentException if the pattern cannot be parsed
@@ -81,6 +94,7 @@ public CronSequenceGenerator(String expression, TimeZone timeZone) {
 		parse(expression);
 	}
 
+
 	/**
 	 * Get the next {@link Date} in the sequence matching the Cron pattern and
 	 * after the value provided. The return value will have a whole number of
@@ -112,12 +126,17 @@ public Date next(Date date) {
 		calendar.setTimeZone(this.timeZone);
 		calendar.setTime(date);
 
-		// Truncate to the next whole second
-		calendar.add(Calendar.SECOND, 1);
+		// First, just reset the milliseconds and try to calculate from there...
 		calendar.set(Calendar.MILLISECOND, 0);
-
+		long originalTimestamp = calendar.getTimeInMillis();
 		doNext(calendar, calendar.get(Calendar.YEAR));
 
+		if (calendar.getTimeInMillis() == originalTimestamp) {
+			// We arrived at the original timestamp - round up to the next whole second and try again...
+			calendar.add(Calendar.SECOND, 1);
+			doNext(calendar, calendar.get(Calendar.YEAR));
+		}
+
 		return calendar.getTime();
 	}
 
@@ -135,7 +154,8 @@ private void doNext(Calendar calendar, int dot) {
 		int updateMinute = findNext(this.minutes, minute, calendar, Calendar.MINUTE, Calendar.HOUR_OF_DAY, resets);
 		if (minute == updateMinute) {
 			resets.add(Calendar.MINUTE);
-		} else {
+		}
+		else {
 			doNext(calendar, dot);
 		}
 
@@ -143,7 +163,8 @@ private void doNext(Calendar calendar, int dot) {
 		int updateHour = findNext(this.hours, hour, calendar, Calendar.HOUR_OF_DAY, Calendar.DAY_OF_WEEK, resets);
 		if (hour == updateHour) {
 			resets.add(Calendar.HOUR_OF_DAY);
-		} else {
+		}
+		else {
 			doNext(calendar, dot);
 		}
 
@@ -152,7 +173,8 @@ private void doNext(Calendar calendar, int dot) {
 		int updateDayOfMonth = findNextDay(calendar, this.daysOfMonth, dayOfMonth, daysOfWeek, dayOfWeek, resets);
 		if (dayOfMonth == updateDayOfMonth) {
 			resets.add(Calendar.DAY_OF_MONTH);
-		} else {
+		}
+		else {
 			doNext(calendar, dot);
 		}
 
@@ -160,7 +182,8 @@ private void doNext(Calendar calendar, int dot) {
 		int updateMonth = findNext(this.months, month, calendar, Calendar.MONTH, Calendar.YEAR, resets);
 		if (month != updateMonth) {
 			if (calendar.get(Calendar.YEAR) - dot > 4) {
-				throw new IllegalStateException("Invalid cron expression led to runaway search for next trigger");
+				throw new IllegalArgumentException("Invalid cron expression \"" + this.expression +
+						"\" led to runaway search for next trigger");
 			}
 			doNext(calendar, dot);
 		}
@@ -181,7 +204,7 @@ private int findNextDay(Calendar calendar, BitSet daysOfMonth, int dayOfMonth, B
 			reset(calendar, resets);
 		}
 		if (count >= max) {
-			throw new IllegalStateException("Overflow in day for expression=" + this.expression);
+			throw new IllegalArgumentException("Overflow in day for expression \"" + this.expression + "\"");
 		}
 		return dayOfMonth;
 	}
@@ -222,7 +245,8 @@ private void reset(Calendar calendar, List<Integer> fields) {
 		}
 	}
 
-	// Parsing logic invoked by the constructor.
+
+	// Parsing logic invoked by the constructor
 
 	/**
 	 * Parse the given pattern expression.
@@ -230,8 +254,8 @@ private void reset(Calendar calendar, List<Integer> fields) {
 	private void parse(String expression) throws IllegalArgumentException {
 		String[] fields = StringUtils.tokenizeToStringArray(expression, " ");
 		if (fields.length != 6) {
-			throw new IllegalArgumentException(String.format(""
-					+ "cron expression must consist of 6 fields (found %d in %s)", fields.length, expression));
+			throw new IllegalArgumentException(String.format(
+					"Cron expression must consist of 6 fields (found %d in \"%s\")", fields.length, expression));
 		}
 		setNumberHits(this.seconds, fields[0], 0, 60);
 		setNumberHits(this.minutes, fields[1], 0, 60);
@@ -296,10 +320,12 @@ private void setNumberHits(BitSet bits, String value, int min, int max) {
 				// Not an incrementer so it must be a range (possibly empty)
 				int[] range = getRange(field, min, max);
 				bits.set(range[0], range[1] + 1);
-			} else {
+			}
+			else {
 				String[] split = StringUtils.delimitedListToStringArray(field, "/");
 				if (split.length > 2) {
-					throw new IllegalArgumentException("Incrementer has more than two fields: " + field);
+					throw new IllegalArgumentException("Incrementer has more than two fields: '" +
+							field + "' in expression \"" + this.expression + "\"");
 				}
 				int[] range = getRange(split[0], min, max);
 				if (!split[0].contains("-")) {
@@ -322,19 +348,23 @@ private int[] getRange(String field, int min, int max) {
 		}
 		if (!field.contains("-")) {
 			result[0] = result[1] = Integer.valueOf(field);
-		} else {
+		}
+		else {
 			String[] split = StringUtils.delimitedListToStringArray(field, "-");
 			if (split.length > 2) {
-				throw new IllegalArgumentException("Range has more than two fields: " + field);
+				throw new IllegalArgumentException("Range has more than two fields: '" +
+						field + "' in expression \"" + this.expression + "\"");
 			}
 			result[0] = Integer.valueOf(split[0]);
 			result[1] = Integer.valueOf(split[1]);
 		}
 		if (result[0] >= max || result[1] >= max) {
-			throw new IllegalArgumentException("Range exceeds maximum (" + max + "): " + field);
+			throw new IllegalArgumentException("Range exceeds maximum (" + max + "): '" +
+					field + "' in expression \"" + this.expression + "\"");
 		}
 		if (result[0] < min || result[1] < min) {
-			throw new IllegalArgumentException("Range less than minimum (" + min + "): " + field);
+			throw new IllegalArgumentException("Range less than minimum (" + min + "): '" +
+					field + "' in expression \"" + this.expression + "\"");
 		}
 		return result;
 	}
diff --git a/spring-context/src/main/java/org/springframework/scheduling/support/CronTrigger.java b/spring-context/src/main/java/org/springframework/scheduling/support/CronTrigger.java
index eca37982e6d4..94f6385a1a9c 100644
--- a/spring-context/src/main/java/org/springframework/scheduling/support/CronTrigger.java
+++ b/spring-context/src/main/java/org/springframework/scheduling/support/CronTrigger.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,12 @@
 
 package org.springframework.scheduling.support;
 
-import java.util.Date;
-import java.util.TimeZone;
-
 import org.springframework.scheduling.Trigger;
 import org.springframework.scheduling.TriggerContext;
 
+import java.util.Date;
+import java.util.TimeZone;
+
 /**
  * {@link Trigger} implementation for cron expressions.
  * Wraps a {@link CronSequenceGenerator}.
@@ -41,7 +41,7 @@ public class CronTrigger implements Trigger {
 	 * following cron expression conventions
 	 */
 	public CronTrigger(String cronExpression) {
-		this(cronExpression, TimeZone.getDefault());
+		this.sequenceGenerator = new CronSequenceGenerator(cronExpression);
 	}
 
 	/**
@@ -89,7 +89,7 @@ public int hashCode() {
 
 	@Override
 	public String toString() {
-		return sequenceGenerator.toString();
+		return this.sequenceGenerator.toString();
 	}
 
 }
diff --git a/spring-context/src/main/java/org/springframework/scripting/config/ScriptBeanDefinitionParser.java b/spring-context/src/main/java/org/springframework/scripting/config/ScriptBeanDefinitionParser.java
index 23cfe64423f8..f12e4004bf7a 100644
--- a/spring-context/src/main/java/org/springframework/scripting/config/ScriptBeanDefinitionParser.java
+++ b/spring-context/src/main/java/org/springframework/scripting/config/ScriptBeanDefinitionParser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,6 +26,7 @@
 import org.springframework.beans.factory.support.BeanDefinitionDefaults;
 import org.springframework.beans.factory.support.GenericBeanDefinition;
 import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
+import org.springframework.beans.factory.xml.BeanDefinitionParserDelegate;
 import org.springframework.beans.factory.xml.ParserContext;
 import org.springframework.beans.factory.xml.XmlReaderContext;
 import org.springframework.scripting.support.ScriptFactoryPostProcessor;
@@ -64,6 +65,8 @@ class ScriptBeanDefinitionParser extends AbstractBeanDefinitionParser {
 
 	private static final String DEPENDENCY_CHECK_ATTRIBUTE = "dependency-check";
 
+	private static final String DEPENDS_ON_ATTRIBUTE = "depends-on";
+
 	private static final String INIT_METHOD_ATTRIBUTE = "init-method";
 
 	private static final String DESTROY_METHOD_ATTRIBUTE = "destroy-method";
@@ -138,6 +141,13 @@ else if (autowireMode == GenericBeanDefinition.AUTOWIRE_CONSTRUCTOR) {
 		String dependencyCheck = element.getAttribute(DEPENDENCY_CHECK_ATTRIBUTE);
 		bd.setDependencyCheck(parserContext.getDelegate().getDependencyCheck(dependencyCheck));
 
+		// Parse depends-on list of bean names.
+		String dependsOn = element.getAttribute(DEPENDS_ON_ATTRIBUTE);
+		if (StringUtils.hasLength(dependsOn)) {
+			bd.setDependsOn(StringUtils.tokenizeToStringArray(
+					dependsOn, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS));
+		}
+
 		// Retrieve the defaults for bean definitions within this parser context
 		BeanDefinitionDefaults beanDefinitionDefaults = parserContext.getDelegate().getBeanDefinitionDefaults();
 
diff --git a/spring-context/src/main/java/org/springframework/scripting/jruby/JRubyScriptUtils.java b/spring-context/src/main/java/org/springframework/scripting/jruby/JRubyScriptUtils.java
index 97b9a3bc43d9..3d019c22fec1 100644
--- a/spring-context/src/main/java/org/springframework/scripting/jruby/JRubyScriptUtils.java
+++ b/spring-context/src/main/java/org/springframework/scripting/jruby/JRubyScriptUtils.java
@@ -81,7 +81,7 @@ public static Object createJRubyObject(String scriptSource, Class[] interfaces,
 
 		Node scriptRootNode = ruby.parseEval(scriptSource, "", null, 0);
 		// keep using the deprecated runNormally variant for JRuby 1.1/1.2 compatibility...
-		IRubyObject rubyObject = ruby.runNormally(scriptRootNode, false);
+        IRubyObject rubyObject = ruby.runNormally(scriptRootNode, false);
 
 		if (rubyObject instanceof RubyNil) {
 			String className = findClassName(scriptRootNode);
diff --git a/spring-context/src/main/java/org/springframework/scripting/support/ResourceScriptSource.java b/spring-context/src/main/java/org/springframework/scripting/support/ResourceScriptSource.java
index 23be717eacdc..c0de42493f40 100644
--- a/spring-context/src/main/java/org/springframework/scripting/support/ResourceScriptSource.java
+++ b/spring-context/src/main/java/org/springframework/scripting/support/ResourceScriptSource.java
@@ -126,4 +126,4 @@ public void setEncoding(String encoding) {
 	public String toString() {
 		return this.resource.toString();
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/main/java/org/springframework/validation/beanvalidation/MethodValidationInterceptor.java b/spring-context/src/main/java/org/springframework/validation/beanvalidation/MethodValidationInterceptor.java
index 58cd161175be..3d4b907fa2fb 100644
--- a/spring-context/src/main/java/org/springframework/validation/beanvalidation/MethodValidationInterceptor.java
+++ b/spring-context/src/main/java/org/springframework/validation/beanvalidation/MethodValidationInterceptor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -46,8 +46,8 @@
  * of that class. By default, JSR-303 will validate against its default group only.
  *
  * <p>As of Spring 3.1, this functionality requires Hibernate Validator 4.2 or higher.
- * In Spring 3.1.2, this class will autodetect a Bean Validation 1.1 compliant provider
- * and automatically use the standard method validation support there (once available).
+ * Once Bean Validation 1.1 becomes available, this class will autodetect a compliant
+ * provider and automatically use the standard method validation support there.
  *
  * @author Juergen Hoeller
  * @since 3.1
diff --git a/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java b/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java
index 7565e82099cb..f3c45fc2fa2b 100644
--- a/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java
+++ b/spring-context/src/main/java/org/springframework/validation/beanvalidation/SpringValidatorAdapter.java
@@ -130,7 +130,8 @@ protected void processConstraintViolations(Set<ConstraintViolation<Object>> viol
 						}
 						else {
 							Object invalidValue = violation.getInvalidValue();
-							if (field.contains(".") && !field.contains("[]")) {
+							if (!"".equals(field) && (invalidValue == violation.getLeafBean() ||
+									(field.contains(".") && !field.contains("[]")))) {
 								// Possibly a bean constraint with property path: retrieve the actual property value.
 								// However, explicitly avoid this for "address[]" style paths that we can't handle.
 								invalidValue = bindingResult.getRawFieldValue(field);
diff --git a/spring-context/src/main/resources/org/springframework/cache/config/spring-cache-3.2.xsd b/spring-context/src/main/resources/org/springframework/cache/config/spring-cache-3.2.xsd
index 9bfdf1401020..baf1f802c0a0 100644
--- a/spring-context/src/main/resources/org/springframework/cache/config/spring-cache-3.2.xsd
+++ b/spring-context/src/main/resources/org/springframework/cache/config/spring-cache-3.2.xsd
@@ -36,7 +36,7 @@
 				<xsd:annotation>
 					<xsd:documentation source="java:org.springframework.cache.CacheManager"><![CDATA[
 	The bean name of the CacheManager that is to be used to retrieve the backing caches.
-	
+
 	This attribute is not required, and only needs to be specified
 	explicitly if the bean name of the desired CacheManager
 	is not 'cacheManager'.
@@ -52,7 +52,7 @@
 				<xsd:annotation>
 					<xsd:documentation source="java:org.springframework.cache.interceptor.KeyGenerator"><![CDATA[
 	The bean name of the KeyGenerator that is to be used to retrieve the backing caches.
-	
+
 	This attribute is not required, and only needs to be specified
 	explicitly if the default strategy (DefaultKeyGenerator) is not sufficient.
 					]]></xsd:documentation>
@@ -150,7 +150,7 @@
 						<xsd:annotation>
 							<xsd:documentation source="java:org.springframework.cache.interceptor.KeyGenerator"><![CDATA[
 	The bean name of the KeyGenerator that is to be used to retrieve the backing caches.
-	
+
 	This attribute is not required, and only needs to be specified
 	explicitly if the default strategy (DefaultKeyGenerator) is not sufficient.
 							]]></xsd:documentation>
@@ -160,7 +160,7 @@
 								</tool:annotation>
 							</xsd:appinfo>
 						</xsd:annotation>
-					</xsd:attribute>					
+					</xsd:attribute>
 				</xsd:extension>
 			</xsd:complexContent>
 		</xsd:complexType>
@@ -194,16 +194,42 @@
 	example, 'get*', 'handle*', '*Order', 'on*Event', etc.]]></xsd:documentation>
 			</xsd:annotation>
 		</xsd:attribute>
-		
+
 	</xsd:complexType>
-	
+
 	<xsd:complexType name="definitionsType">
 		<xsd:complexContent>
 			<xsd:extension base="basedefinitionType">
 				<xsd:sequence>
 				  <xsd:choice minOccurs="0" maxOccurs="unbounded">
-					<xsd:element name="cacheable" minOccurs="0" maxOccurs="unbounded" type="basedefinitionType"/>
-					<xsd:element name="cache-put" minOccurs="0" maxOccurs="unbounded" type="basedefinitionType"/>					
+					<xsd:element name="cacheable" minOccurs="0" maxOccurs="unbounded">
+						<xsd:complexType>
+							<xsd:complexContent>
+								<xsd:extension base="basedefinitionType">
+									<xsd:attribute name="unless" type="xsd:string" use="optional">
+										<xsd:annotation>
+											<xsd:documentation><![CDATA[
+	The SpEL expression used to veto the method caching.]]></xsd:documentation>
+										</xsd:annotation>
+									</xsd:attribute>
+								</xsd:extension>
+							</xsd:complexContent>
+						</xsd:complexType>
+					</xsd:element>
+					<xsd:element name="cache-put" minOccurs="0" maxOccurs="unbounded">
+						<xsd:complexType>
+							<xsd:complexContent>
+								<xsd:extension base="basedefinitionType">
+									<xsd:attribute name="unless" type="xsd:string" use="optional">
+										<xsd:annotation>
+											<xsd:documentation><![CDATA[
+	The SpEL expression used to veto the method caching.]]></xsd:documentation>
+										</xsd:annotation>
+									</xsd:attribute>
+								</xsd:extension>
+							</xsd:complexContent>
+						</xsd:complexType>
+					</xsd:element>
 					<xsd:element name="cache-evict" minOccurs="0" maxOccurs="unbounded">
 						<xsd:complexType>
 							<xsd:complexContent>
@@ -217,16 +243,16 @@
 									<xsd:attribute name="before-invocation" type="xsd:boolean" use="optional">
 										<xsd:annotation>
 											<xsd:documentation><![CDATA[
-	Whether the eviction should occur after the method is successfully 
+	Whether the eviction should occur after the method is successfully
 	invoked (default) or before.]]></xsd:documentation>
 										</xsd:annotation>
 									</xsd:attribute>
-									
+
 								</xsd:extension>
 							</xsd:complexContent>
 						</xsd:complexType>
 					</xsd:element>
-				  </xsd:choice>			
+				  </xsd:choice>
 				</xsd:sequence>
 			</xsd:extension>
 		</xsd:complexContent>
diff --git a/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-2.5.xsd b/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-2.5.xsd
index ac7c3174183d..e6288503896a 100644
--- a/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-2.5.xsd
+++ b/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-2.5.xsd
@@ -82,7 +82,7 @@
 					<xsd:annotation>
 						<xsd:documentation source="java:org.springframework.core.io.Resource"><![CDATA[
 	The resource containing the script for the dynamic language-backed bean.
-	
+
 	Examples might be '/WEB-INF/scripts/Anais.groovy', 'classpath:Nin.bsh', etc.
 						]]></xsd:documentation>
 					</xsd:annotation>
@@ -137,13 +137,13 @@
 				<xsd:attribute name="depends-on" type="xsd:string">
 					<xsd:annotation>
 						<xsd:documentation><![CDATA[
-			The names of the beans that this bean depends on being initialized.
-			The bean factory will guarantee that these beans get initialized
-			before this bean.
+	The names of the beans that this bean depends on being initialized.
+	The bean factory will guarantee that these beans get initialized
+	before this bean.
 
-			Note that dependencies are normally expressed through bean properties.
-			This property should just be necessary other kinds of dependencies
-			like statics (*ugh*) or database preparation on startup.
+	Note that dependencies are normally expressed through bean properties.
+	This property should just be necessary for other kinds of dependencies
+	like statics (*ugh*) or database preparation on startup.
 						]]></xsd:documentation>
 					</xsd:annotation>
 				</xsd:attribute>
diff --git a/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.0.xsd b/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.0.xsd
index 574fb05b4328..5a34213de743 100644
--- a/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.0.xsd
+++ b/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.0.xsd
@@ -82,7 +82,7 @@
 					<xsd:annotation>
 						<xsd:documentation source="java:org.springframework.core.io.Resource"><![CDATA[
 	The resource containing the script for the dynamic language-backed bean.
-	
+
 	Examples might be '/WEB-INF/scripts/Anais.groovy', 'classpath:Nin.bsh', etc.
 						]]></xsd:documentation>
 					</xsd:annotation>
@@ -127,13 +127,13 @@
 				<xsd:attribute name="depends-on" type="xsd:string">
 					<xsd:annotation>
 						<xsd:documentation><![CDATA[
-			The names of the beans that this bean depends on being initialized.
-			The bean factory will guarantee that these beans get initialized
-			before this bean.
+	The names of the beans that this bean depends on being initialized.
+	The bean factory will guarantee that these beans get initialized
+	before this bean.
 
-			Note that dependencies are normally expressed through bean properties.
-			This property should just be necessary other kinds of dependencies
-			like statics (*ugh*) or database preparation on startup.
+	Note that dependencies are normally expressed through bean properties.
+	This property should just be necessary for other kinds of dependencies
+	like statics (*ugh*) or database preparation on startup.
 						]]></xsd:documentation>
 					</xsd:annotation>
 				</xsd:attribute>
diff --git a/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.1.xsd b/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.1.xsd
index edce1324f4de..54ae90e9e124 100644
--- a/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.1.xsd
+++ b/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.1.xsd
@@ -147,13 +147,13 @@
 				<xsd:attribute name="depends-on" type="xsd:string">
 					<xsd:annotation>
 						<xsd:documentation><![CDATA[
-			The names of the beans that this bean depends on being initialized.
-			The bean factory will guarantee that these beans get initialized
-			before this bean.
+	The names of the beans that this bean depends on being initialized.
+	The bean factory will guarantee that these beans get initialized
+	before this bean.
 
-			Note that dependencies are normally expressed through bean properties.
-			This property should just be necessary other kinds of dependencies
-			like statics (*ugh*) or database preparation on startup.
+	Note that dependencies are normally expressed through bean properties.
+	This property should just be necessary for other kinds of dependencies
+	like statics (*ugh*) or database preparation on startup.
 						]]></xsd:documentation>
 					</xsd:annotation>
 				</xsd:attribute>
diff --git a/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.2.xsd b/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.2.xsd
index 34e9775fe24c..5bd66ded4366 100644
--- a/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.2.xsd
+++ b/spring-context/src/main/resources/org/springframework/scripting/config/spring-lang-3.2.xsd
@@ -147,13 +147,13 @@
 				<xsd:attribute name="depends-on" type="xsd:string">
 					<xsd:annotation>
 						<xsd:documentation><![CDATA[
-			The names of the beans that this bean depends on being initialized.
-			The bean factory will guarantee that these beans get initialized
-			before this bean.
+	The names of the beans that this bean depends on being initialized.
+	The bean factory will guarantee that these beans get initialized
+	before this bean.
 
-			Note that dependencies are normally expressed through bean properties.
-			This property should just be necessary other kinds of dependencies
-			like statics (*ugh*) or database preparation on startup.
+	Note that dependencies are normally expressed through bean properties.
+	This property should just be necessary for other kinds of dependencies
+	like statics (*ugh*) or database preparation on startup.
 						]]></xsd:documentation>
 					</xsd:annotation>
 				</xsd:attribute>
diff --git a/spring-context/src/test/java/example/scannable/FooServiceImpl.java b/spring-context/src/test/java/example/scannable/FooServiceImpl.java
index 1db44f5bb0bd..15da02b0f2d1 100644
--- a/spring-context/src/test/java/example/scannable/FooServiceImpl.java
+++ b/spring-context/src/test/java/example/scannable/FooServiceImpl.java
@@ -65,7 +65,6 @@ public class FooServiceImpl implements FooService {
 
 	private boolean initCalled = false;
 
-	@SuppressWarnings("unused")
 	@PostConstruct
 	private void init() {
 		if (this.initCalled) {
diff --git a/spring-context/src/test/java/org/springframework/aop/aspectj/AfterAdviceBindingTests.java b/spring-context/src/test/java/org/springframework/aop/aspectj/AfterAdviceBindingTests.java
index 364d5415920c..b078e3c0048e 100644
--- a/spring-context/src/test/java/org/springframework/aop/aspectj/AfterAdviceBindingTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/aspectj/AfterAdviceBindingTests.java
@@ -16,18 +16,17 @@
 
 package org.springframework.aop.aspectj;
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.aop.aspectj.AdviceBindingTestAspect.AdviceBindingCollaborator;
 import org.springframework.aop.framework.Advised;
 import org.springframework.aop.support.AopUtils;
+import org.springframework.context.support.ClassPathXmlApplicationContext;
 import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.tests.sample.beans.TestBean;
-import org.springframework.context.support.ClassPathXmlApplicationContext;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * Tests for various parameter binding scenarios with before advice.
diff --git a/spring-context/src/test/java/org/springframework/aop/aspectj/AfterReturningAdviceBindingTests.java b/spring-context/src/test/java/org/springframework/aop/aspectj/AfterReturningAdviceBindingTests.java
index c04a54f8e646..3d6f902d3425 100644
--- a/spring-context/src/test/java/org/springframework/aop/aspectj/AfterReturningAdviceBindingTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/aspectj/AfterReturningAdviceBindingTests.java
@@ -16,19 +16,17 @@
 
 package org.springframework.aop.aspectj;
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.aop.aspectj.AfterReturningAdviceBindingTestAspect.AfterReturningAdviceBindingCollaborator;
 import org.springframework.aop.framework.Advised;
 import org.springframework.aop.support.AopUtils;
+import org.springframework.context.support.ClassPathXmlApplicationContext;
 import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.tests.sample.beans.TestBean;
-import org.springframework.context.support.ClassPathXmlApplicationContext;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * Tests for various parameter binding scenarios with before advice.
diff --git a/spring-context/src/test/java/org/springframework/aop/aspectj/AfterThrowingAdviceBindingTests.java b/spring-context/src/test/java/org/springframework/aop/aspectj/AfterThrowingAdviceBindingTests.java
index 076050792495..c98aea5211d1 100644
--- a/spring-context/src/test/java/org/springframework/aop/aspectj/AfterThrowingAdviceBindingTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/aspectj/AfterThrowingAdviceBindingTests.java
@@ -16,14 +16,13 @@
 
 package org.springframework.aop.aspectj;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.aop.aspectj.AfterThrowingAdviceBindingTestAspect.AfterThrowingAdviceBindingCollaborator;
-import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.context.support.ClassPathXmlApplicationContext;
+import org.springframework.tests.sample.beans.ITestBean;
+
+import static org.mockito.BDDMockito.*;
 
 /**
  * Tests for various parameter binding scenarios with before advice.
diff --git a/spring-context/src/test/java/org/springframework/aop/aspectj/AroundAdviceBindingTests.java b/spring-context/src/test/java/org/springframework/aop/aspectj/AroundAdviceBindingTests.java
index 879e846b2bdc..0d9911560e64 100644
--- a/spring-context/src/test/java/org/springframework/aop/aspectj/AroundAdviceBindingTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/aspectj/AroundAdviceBindingTests.java
@@ -16,20 +16,19 @@
 
 package org.springframework.aop.aspectj;
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.aspectj.lang.ProceedingJoinPoint;
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.aop.aspectj.AroundAdviceBindingTestAspect.AroundAdviceBindingCollaborator;
 import org.springframework.aop.framework.Advised;
 import org.springframework.aop.support.AopUtils;
-import org.springframework.tests.sample.beans.ITestBean;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.support.ClassPathXmlApplicationContext;
+import org.springframework.tests.sample.beans.ITestBean;
+import org.springframework.tests.sample.beans.TestBean;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * Tests for various parameter binding scenarios with before advice.
diff --git a/spring-context/src/test/java/org/springframework/aop/aspectj/BeforeAdviceBindingTests.java b/spring-context/src/test/java/org/springframework/aop/aspectj/BeforeAdviceBindingTests.java
index 94e6e43f8abc..c313c6f33932 100644
--- a/spring-context/src/test/java/org/springframework/aop/aspectj/BeforeAdviceBindingTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/aspectj/BeforeAdviceBindingTests.java
@@ -16,18 +16,17 @@
 
 package org.springframework.aop.aspectj;
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.aop.aspectj.AdviceBindingTestAspect.AdviceBindingCollaborator;
 import org.springframework.aop.framework.Advised;
 import org.springframework.aop.support.AopUtils;
+import org.springframework.context.support.ClassPathXmlApplicationContext;
 import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.tests.sample.beans.TestBean;
-import org.springframework.context.support.ClassPathXmlApplicationContext;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * Tests for various parameter binding scenarios with before advice.
diff --git a/spring-context/src/test/java/org/springframework/aop/config/MethodLocatingFactoryBeanTests.java b/spring-context/src/test/java/org/springframework/aop/config/MethodLocatingFactoryBeanTests.java
index 753fb3341a75..7959a45b08a8 100644
--- a/spring-context/src/test/java/org/springframework/aop/config/MethodLocatingFactoryBeanTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/config/MethodLocatingFactoryBeanTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,19 +16,15 @@
 
 package org.springframework.aop.config;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.lang.reflect.Method;
 
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.beans.factory.BeanFactory;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Chris Beams
diff --git a/spring-context/src/test/java/org/springframework/aop/framework/AbstractAopProxyTests.java b/spring-context/src/test/java/org/springframework/aop/framework/AbstractAopProxyTests.java
index 9fd4e9fa07c5..b9e0a9eaaebe 100644
--- a/spring-context/src/test/java/org/springframework/aop/framework/AbstractAopProxyTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/framework/AbstractAopProxyTests.java
@@ -62,6 +62,8 @@
 import org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor;
 import org.springframework.aop.target.HotSwappableTargetSource;
 import org.springframework.aop.target.SingletonTargetSource;
+import org.springframework.tests.Assume;
+import org.springframework.tests.TestGroup;
 import org.springframework.tests.TimeStamped;
 import org.springframework.tests.aop.advice.CountingAfterReturningAdvice;
 import org.springframework.tests.aop.advice.CountingBeforeAdvice;
@@ -170,6 +172,7 @@ public void testValuesStick() {
 	 */
 	@Test
 	public void testManyProxies() {
+		Assume.group(TestGroup.PERFORMANCE);
 		int howMany = 10000;
 		StopWatch sw = new StopWatch();
 		sw.start("Create " + howMany + " proxies");
diff --git a/spring-context/src/test/java/org/springframework/aop/framework/CglibProxyTests.java b/spring-context/src/test/java/org/springframework/aop/framework/CglibProxyTests.java
index 9b423759f799..2330909eecce 100644
--- a/spring-context/src/test/java/org/springframework/aop/framework/CglibProxyTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/framework/CglibProxyTests.java
@@ -137,10 +137,13 @@ public void testProxyCanBeClassNotInterface() throws Exception {
 
 	@Test
 	public void testCglibProxyingGivesMeaningfulExceptionIfAskedToProxyNonvisibleClass() {
+
+		@SuppressWarnings("unused")
 		class YouCantSeeThis {
 			void hidden() {
 			}
 		}
+
 		YouCantSeeThis mine = new YouCantSeeThis();
 		try {
 			ProxyFactory pf = new ProxyFactory(mine);
diff --git a/spring-context/src/test/java/org/springframework/aop/framework/JdkDynamicProxyTests.java b/spring-context/src/test/java/org/springframework/aop/framework/JdkDynamicProxyTests.java
index 77101f6cc902..562ab9bf3287 100644
--- a/spring-context/src/test/java/org/springframework/aop/framework/JdkDynamicProxyTests.java
+++ b/spring-context/src/test/java/org/springframework/aop/framework/JdkDynamicProxyTests.java
@@ -16,21 +16,19 @@
 
 package org.springframework.aop.framework;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import java.io.Serializable;
 
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
-
 import org.springframework.aop.interceptor.ExposeInvocationInterceptor;
 import org.springframework.aop.support.AopUtils;
 import org.springframework.tests.sample.beans.IOther;
 import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.tests.sample.beans.TestBean;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @since 13.03.2003
  * @author Rod Johnson
diff --git a/spring-context/src/test/java/org/springframework/beans/factory/support/InjectAnnotationAutowireContextTests.java b/spring-context/src/test/java/org/springframework/beans/factory/support/InjectAnnotationAutowireContextTests.java
index d7cf863defa0..3544595d9dc9 100644
--- a/spring-context/src/test/java/org/springframework/beans/factory/support/InjectAnnotationAutowireContextTests.java
+++ b/spring-context/src/test/java/org/springframework/beans/factory/support/InjectAnnotationAutowireContextTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -608,6 +608,7 @@ public Person getPerson() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class QualifiedFieldWithBaseQualifierDefaultValueTestBean {
 
 		@Inject
diff --git a/spring-context/src/test/java/org/springframework/beans/factory/xml/QualifierAnnotationTests.java b/spring-context/src/test/java/org/springframework/beans/factory/xml/QualifierAnnotationTests.java
index 91d1d7565adb..5271e479157d 100644
--- a/spring-context/src/test/java/org/springframework/beans/factory/xml/QualifierAnnotationTests.java
+++ b/spring-context/src/test/java/org/springframework/beans/factory/xml/QualifierAnnotationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -199,6 +199,7 @@ public void testInterfaceWithOneQualifiedFactoryAndOneQualifiedBean() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class NonQualifiedTestBean {
 
 		@Autowired
@@ -305,6 +306,7 @@ public Person getLarry() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class QualifiedByAttributesTestBean {
 
 		@Autowired @MultipleAttributeQualifier(name="moe", age=42)
@@ -323,6 +325,7 @@ public Person getMoeJunior() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class Person {
 
 		private String name;
diff --git a/spring-context/src/test/java/org/springframework/beans/factory/xml/XmlBeanFactoryTestTypes.java b/spring-context/src/test/java/org/springframework/beans/factory/xml/XmlBeanFactoryTestTypes.java
index 6f68b6bf6006..a5bc212cedb7 100644
--- a/spring-context/src/test/java/org/springframework/beans/factory/xml/XmlBeanFactoryTestTypes.java
+++ b/spring-context/src/test/java/org/springframework/beans/factory/xml/XmlBeanFactoryTestTypes.java
@@ -198,7 +198,7 @@ public void setSetterString(String setterString) {
  * @author Juergen Hoeller
  * @since 09.11.2003
  */
-@SuppressWarnings("serial")
+@SuppressWarnings({ "serial", "unused" })
 class DerivedConstructorDependenciesBean extends ConstructorDependenciesBean {
 
 	boolean initialized;
@@ -332,6 +332,7 @@ public TestBean getTestBean2() {
  * @author Rod Johnson
  * @author Juergen Hoeller
  */
+@SuppressWarnings("unused")
 class FactoryMethods {
 
 	public static FactoryMethods nullInstance() {
diff --git a/spring-context/src/test/java/org/springframework/beans/factory/xml/XmlBeanFactoryTests.java b/spring-context/src/test/java/org/springframework/beans/factory/xml/XmlBeanFactoryTests.java
index b4e6a07538c5..6115b4979e76 100644
--- a/spring-context/src/test/java/org/springframework/beans/factory/xml/XmlBeanFactoryTests.java
+++ b/spring-context/src/test/java/org/springframework/beans/factory/xml/XmlBeanFactoryTests.java
@@ -134,13 +134,15 @@ private static ClassPathResource classPathResource(String suffix) {
 	}
 
 	/* SPR-2368 */
-	public @Test void testCollectionsReferredToAsRefLocals() throws Exception {
+	@Test
+	public void testCollectionsReferredToAsRefLocals() throws Exception {
 		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(factory).loadBeanDefinitions(COLLECTIONS_XSD_CONTEXT);
 		factory.preInstantiateSingletons();
 	}
 
-	public @Test void testRefToSeparatePrototypeInstances() throws Exception {
+	@Test
+	public void testRefToSeparatePrototypeInstances() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);
@@ -158,7 +160,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue("They object equal direct ref", emmasJenks.equals(xbf.getBean("jenks")));
 	}
 
-	public @Test void testRefToSingleton() throws Exception {
+	@Test
+	public void testRefToSingleton() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);
@@ -173,7 +176,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue("1 jen instance", davesJen == jen);
 	}
 
-	public @Test void testInnerBeans() throws IOException {
+	@Test
+	public void testInnerBeans() throws IOException {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 
@@ -236,7 +240,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(inner5.wasDestroyed());
 	}
 
-	public @Test void testInnerBeansWithoutDestroy() {
+	@Test
+	public void testInnerBeansWithoutDestroy() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);
@@ -269,7 +274,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertEquals("innerBean", inner5.getBeanName());
 	}
 
-	public @Test void testFailsOnInnerBean() {
+	@Test
+	public void testFailsOnInnerBean() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);
@@ -296,7 +302,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testInheritanceFromParentFactoryPrototype() throws Exception {
+	@Test
+	public void testInheritanceFromParentFactoryPrototype() throws Exception {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -311,7 +318,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertFalse(inherits2 == inherits);
 	}
 
-	public @Test void testInheritanceWithDifferentClass() throws Exception {
+	@Test
+	public void testInheritanceWithDifferentClass() throws Exception {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -325,7 +333,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(inherits.wasInitialized());
 	}
 
-	public @Test void testInheritanceWithClass() throws Exception {
+	@Test
+	public void testInheritanceWithClass() throws Exception {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -339,7 +348,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(inherits.wasInitialized());
 	}
 
-	public @Test void testPrototypeInheritanceFromParentFactoryPrototype() throws Exception {
+	@Test
+	public void testPrototypeInheritanceFromParentFactoryPrototype() throws Exception {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -358,7 +368,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(inherits.getAge() == 2);
 	}
 
-	public @Test void testPrototypeInheritanceFromParentFactorySingleton() throws Exception {
+	@Test
+	public void testPrototypeInheritanceFromParentFactorySingleton() throws Exception {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -376,7 +387,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(inherits.getAge() == 1);
 	}
 
-	public @Test void testAutowireModeNotInherited() {
+	@Test
+	public void testAutowireModeNotInherited() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.loadBeanDefinitions(OVERRIDES_CONTEXT);
@@ -390,7 +402,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertNull("autowiring not propagated along child relationships", derivedDavid.getSpouse());
 	}
 
-	public @Test void testAbstractParentBeans() {
+	@Test
+	public void testAbstractParentBeans() {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		parent.preInstantiateSingletons();
@@ -415,7 +428,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(parent.getBean("inheritedTestBeanPrototype") instanceof TestBean);
 	}
 
-	public @Test void testDependenciesMaterializeThis() throws Exception {
+	@Test
+	public void testDependenciesMaterializeThis() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(DEP_MATERIALIZE_CONTEXT);
 
@@ -433,7 +447,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(bos.dao == bop.dao);
 	}
 
-	public @Test void testChildOverridesParentBean() throws Exception {
+	@Test
+	public void testChildOverridesParentBean() throws Exception {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -451,7 +466,8 @@ private static ClassPathResource classPathResource(String suffix) {
 	 * Check that a prototype can't inherit from a bogus parent.
 	 * If a singleton does this the factory will fail to load.
 	 */
-	public @Test void testBogusParentageFromParentFactory() throws Exception {
+	@Test
+	public void testBogusParentageFromParentFactory() throws Exception {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -472,7 +488,8 @@ private static ClassPathResource classPathResource(String suffix) {
 	 * It's possible for a subclass singleton not to return independent
 	 * instances even if derived from a prototype
 	 */
-	public @Test void testSingletonInheritsFromParentFactoryPrototype() throws Exception {
+	@Test
+	public void testSingletonInheritsFromParentFactoryPrototype() throws Exception {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -486,7 +503,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(inherits2 == inherits);
 	}
 
-	public @Test void testSingletonFromParent() {
+	@Test
+	public void testSingletonFromParent() {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		TestBean beanFromParent = (TestBean) parent.getBean("inheritedTestBeanSingleton");
@@ -496,7 +514,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue("singleton from parent and child is the same", beanFromParent == beanFromChild);
 	}
 
-	public @Test void testNestedPropertyValue() {
+	@Test
+	public void testNestedPropertyValue() {
 		DefaultListableBeanFactory parent = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(parent).loadBeanDefinitions(PARENT_CONTEXT);
 		DefaultListableBeanFactory child = new DefaultListableBeanFactory(parent);
@@ -505,7 +524,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertEquals("name applied correctly", "myname", bean.getArray()[0].getName());
 	}
 
-	public @Test void testCircularReferences() {
+	@Test
+	public void testCircularReferences() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);
@@ -522,7 +542,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue("Correct circular reference", complexEgo.getSpouse().getSpouse() == complexEgo);
 	}
 
-	public @Test void testCircularReferenceWithFactoryBeanFirst() {
+	@Test
+	public void testCircularReferenceWithFactoryBeanFirst() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);
@@ -532,7 +553,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue("Correct circular reference", complexEgo.getSpouse().getSpouse() == complexEgo);
 	}
 
-	public @Test void testCircularReferenceWithTwoFactoryBeans() {
+	@Test
+	public void testCircularReferenceWithTwoFactoryBeans() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);
@@ -543,7 +565,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue("Correct circular reference", ego3.getSpouse().getSpouse() == ego3);
 	}
 
-	public @Test void testCircularReferencesWithNotAllowed() {
+	@Test
+	public void testCircularReferencesWithNotAllowed() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		xbf.setAllowCircularReferences(false);
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
@@ -558,7 +581,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testCircularReferencesWithWrapping() {
+	@Test
+	public void testCircularReferencesWithWrapping() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.setValidationMode(XmlBeanDefinitionReader.VALIDATION_NONE);
@@ -573,7 +597,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testCircularReferencesWithWrappingAndRawInjectionAllowed() {
+	@Test
+	public void testCircularReferencesWithWrappingAndRawInjectionAllowed() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		xbf.setAllowRawInjectionDespiteWrapping(true);
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
@@ -593,7 +618,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(!AopUtils.isAopProxy(david.getSpouse()));
 	}
 
-	public @Test void testFactoryReferenceCircle() {
+	@Test
+	public void testFactoryReferenceCircle() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(FACTORY_CIRCLE_CONTEXT);
 		TestBean tb = (TestBean) xbf.getBean("singletonFactory");
@@ -601,13 +627,15 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(tb == db.getOtherTestBean());
 	}
 
-	public @Test void testFactoryReferenceWithDoublePrefix() {
+	@Test
+	public void testFactoryReferenceWithDoublePrefix() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(FACTORY_CIRCLE_CONTEXT);
 		assertThat(xbf.getBean("&&singletonFactory"), instanceOf(DummyFactory.class));
 	}
 
-	public @Test void testComplexFactoryReferenceCircle() {
+	@Test
+	public void testComplexFactoryReferenceCircle() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(COMPLEX_FACTORY_CIRCLE_CONTEXT);
 		xbf.getBean("proxy1");
@@ -618,7 +646,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertEquals(5, xbf.getSingletonCount());
 	}
 
-	public @Test void testNoSuchFactoryBeanMethod() {
+	@Test
+	public void testNoSuchFactoryBeanMethod() {
 		try {
 			DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(NO_SUCH_FACTORY_METHOD_CONTEXT);
@@ -630,7 +659,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testInitMethodIsInvoked() throws Exception {
+	@Test
+	public void testInitMethodIsInvoked() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(INITIALIZERS_CONTEXT);
 		DoubleInitializer in = (DoubleInitializer) xbf.getBean("init-method1");
@@ -641,7 +671,8 @@ private static ClassPathResource classPathResource(String suffix) {
 	/**
 	 * Test that if a custom initializer throws an exception, it's handled correctly
 	 */
-	public @Test void testInitMethodThrowsException() {
+	@Test
+	public void testInitMethodThrowsException() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(INITIALIZERS_CONTEXT);
 		try {
@@ -655,7 +686,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testNoSuchInitMethod() throws Exception {
+	@Test
+	public void testNoSuchInitMethod() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(INITIALIZERS_CONTEXT);
 		try {
@@ -673,7 +705,8 @@ private static ClassPathResource classPathResource(String suffix) {
 	/**
 	 * Check that InitializingBean method is called first.
 	 */
-	public @Test void testInitializingBeanAndInitMethod() throws Exception {
+	@Test
+	public void testInitializingBeanAndInitMethod() throws Exception {
 		InitAndIB.constructed = false;
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(INITIALIZERS_CONTEXT);
@@ -693,7 +726,8 @@ private static ClassPathResource classPathResource(String suffix) {
 	/**
 	 * Check that InitializingBean method is not called twice.
 	 */
-	public @Test void testInitializingBeanAndSameInitMethod() throws Exception {
+	@Test
+	public void testInitializingBeanAndSameInitMethod() throws Exception {
 		InitAndIB.constructed = false;
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(INITIALIZERS_CONTEXT);
@@ -710,7 +744,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertTrue(iib.destroyed && !iib.customDestroyed);
 	}
 
-	public @Test void testDefaultLazyInit() throws Exception {
+	@Test
+	public void testDefaultLazyInit() throws Exception {
 		InitAndIB.constructed = false;
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(DEFAULT_LAZY_CONTEXT);
@@ -725,7 +760,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testNoSuchXmlFile() throws Exception {
+	@Test
+	public void testNoSuchXmlFile() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		try {
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(MISSING_CONTEXT);
@@ -735,7 +771,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testInvalidXmlFile() throws Exception {
+	@Test
+	public void testInvalidXmlFile() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		try {
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(INVALID_CONTEXT);
@@ -745,7 +782,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testUnsatisfiedObjectDependencyCheck() throws Exception {
+	@Test
+	public void testUnsatisfiedObjectDependencyCheck() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		try {
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(UNSATISFIED_OBJECT_DEP_CONTEXT);
@@ -756,7 +794,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testUnsatisfiedSimpleDependencyCheck() throws Exception {
+	@Test
+	public void testUnsatisfiedSimpleDependencyCheck() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		try {
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(UNSATISFIED_SIMPLE_DEP_CONTEXT);
@@ -767,7 +806,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testSatisfiedObjectDependencyCheck() throws Exception {
+	@Test
+	public void testSatisfiedObjectDependencyCheck() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(SATISFIED_OBJECT_DEP_CONTEXT);
 		DependenciesBean a = (DependenciesBean) xbf.getBean("a");
@@ -775,14 +815,16 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertEquals(xbf, a.getBeanFactory());
 	}
 
-	public @Test void testSatisfiedSimpleDependencyCheck() throws Exception {
+	@Test
+	public void testSatisfiedSimpleDependencyCheck() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(SATISFIED_SIMPLE_DEP_CONTEXT);
 		DependenciesBean a = (DependenciesBean) xbf.getBean("a");
 		assertEquals(a.getAge(), 33);
 	}
 
-	public @Test void testUnsatisfiedAllDependencyCheck() throws Exception {
+	@Test
+	public void testUnsatisfiedAllDependencyCheck() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		try {
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(UNSATISFIED_ALL_DEP_CONTEXT);
@@ -793,7 +835,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		}
 	}
 
-	public @Test void testSatisfiedAllDependencyCheck() throws Exception {
+	@Test
+	public void testSatisfiedAllDependencyCheck() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(SATISFIED_ALL_DEP_CONTEXT);
 		DependenciesBean a = (DependenciesBean) xbf.getBean("a");
@@ -802,7 +845,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		assertNotNull(a.getSpouse());
 	}
 
-	public @Test void testAutowire() throws Exception {
+	@Test
+	public void testAutowire() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(AUTOWIRE_CONTEXT);
 		TestBean spouse = new TestBean("kerry", 0);
@@ -810,7 +854,8 @@ private static ClassPathResource classPathResource(String suffix) {
 		doTestAutowire(xbf);
 	}
 
-	public @Test void testAutowireWithParent() throws Exception {
+	@Test
+	public void testAutowireWithParent() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(AUTOWIRE_CONTEXT);
 		DefaultListableBeanFactory lbf = new DefaultListableBeanFactory();
@@ -871,7 +916,8 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		assertTrue(appCtx.containsBean("jenny"));
 	}
 
-	public @Test void testAutowireWithDefault() throws Exception {
+	@Test
+	public void testAutowireWithDefault() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(DEFAULT_AUTOWIRE_CONTEXT);
 
@@ -893,7 +939,8 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		}
 	}
 
-	public @Test void testAutowireByConstructor() throws Exception {
+	@Test
+	public void testAutowireByConstructor() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		ConstructorDependenciesBean rod1 = (ConstructorDependenciesBean) xbf.getBean("rod1");
@@ -930,7 +977,8 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		assertEquals(null, rod.getName());
 	}
 
-	public @Test void testAutowireByConstructorWithSimpleValues() throws Exception {
+	@Test
+	public void testAutowireByConstructorWithSimpleValues() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 
@@ -959,7 +1007,8 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		assertTrue(rod6.destroyed);
 	}
 
-	public @Test void testRelatedCausesFromConstructorResolution() {
+	@Test
+	public void testRelatedCausesFromConstructorResolution() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 
@@ -973,7 +1022,8 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		}
 	}
 
-	public @Test void testConstructorArgResolution() {
+	@Test
+	public void testConstructorArgResolution() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		TestBean kerry1 = (TestBean) xbf.getBean("kerry1");
@@ -1021,7 +1071,8 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		assertEquals(29, rod17.getAge());
 	}
 
-	public @Test void testPrototypeWithExplicitArguments() {
+	@Test
+	public void testPrototypeWithExplicitArguments() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		SimpleConstructorArgBean cd1 = (SimpleConstructorArgBean) xbf.getBean("rod18");
@@ -1036,14 +1087,16 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		assertEquals(97, cd5.getAge());
 	}
 
-	public @Test void testConstructorArgWithSingleMatch() {
+	@Test
+	public void testConstructorArgWithSingleMatch() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		File file = (File) xbf.getBean("file");
 		assertEquals(File.separator + "test", file.getPath());
 	}
 
-	public @Test void testThrowsExceptionOnTooManyArguments() throws Exception {
+	@Test
+	public void testThrowsExceptionOnTooManyArguments() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		try {
@@ -1054,7 +1107,8 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		}
 	}
 
-	public @Test void testThrowsExceptionOnAmbiguousResolution() throws Exception {
+	@Test
+	public void testThrowsExceptionOnAmbiguousResolution() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		try {
@@ -1065,43 +1119,53 @@ private void doTestAutowire(DefaultListableBeanFactory xbf) throws Exception {
 		}
 	}
 
-	public @Test void testDependsOn() {
+	@Test
+	public void testDependsOn() {
 		doTestDependencies(DEP_DEPENDSON_CONTEXT, 1);
 	}
 
-	public @Test void testDependsOnInInnerBean() {
+	@Test
+	public void testDependsOnInInnerBean() {
 		doTestDependencies(DEP_DEPENDSON_INNER_CONTEXT, 4);
 	}
 
-	public @Test void testDependenciesThroughConstructorArguments() {
+	@Test
+	public void testDependenciesThroughConstructorArguments() {
 		doTestDependencies(DEP_CARG_CONTEXT, 1);
 	}
 
-	public @Test void testDependenciesThroughConstructorArgumentAutowiring() {
+	@Test
+	public void testDependenciesThroughConstructorArgumentAutowiring() {
 		doTestDependencies(DEP_CARG_AUTOWIRE_CONTEXT, 1);
 	}
 
-	public @Test void testDependenciesThroughConstructorArgumentsInInnerBean() {
+	@Test
+	public void testDependenciesThroughConstructorArgumentsInInnerBean() {
 		doTestDependencies(DEP_CARG_INNER_CONTEXT, 1);
 	}
 
-	public @Test void testDependenciesThroughProperties() {
+	@Test
+	public void testDependenciesThroughProperties() {
 		doTestDependencies(DEP_PROP, 1);
 	}
 
-	public @Test void testDependenciesThroughPropertiesWithInTheMiddle() {
+	@Test
+	public void testDependenciesThroughPropertiesWithInTheMiddle() {
 		doTestDependencies(DEP_PROP_MIDDLE_CONTEXT, 1);
 	}
 
-	public @Test void testDependenciesThroughPropertyAutowiringByName() {
+	@Test
+	public void testDependenciesThroughPropertyAutowiringByName() {
 		doTestDependencies(DEP_PROP_ABN_CONTEXT, 1);
 	}
 
-	public @Test void testDependenciesThroughPropertyAutowiringByType() {
+	@Test
+	public void testDependenciesThroughPropertyAutowiringByType() {
 		doTestDependencies(DEP_PROP_ABT_CONTEXT, 1);
 	}
 
-	public @Test void testDependenciesThroughPropertiesInInnerBean() {
+	@Test
+	public void testDependenciesThroughPropertiesInInnerBean() {
 		doTestDependencies(DEP_PROP_INNER_CONTEXT, 1);
 	}
 
@@ -1132,7 +1196,8 @@ private void doTestDependencies(ClassPathResource resource, int nrOfHoldingBeans
 	 * bean def is being parsed, 'cos everything on a bean def is now lazy, but
 	 * must rather only be picked up when the bean is instantiated.
 	 */
-	public @Test void testClassNotFoundWithDefaultBeanClassLoader() {
+	@Test
+	public void testClassNotFoundWithDefaultBeanClassLoader() {
 		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(factory).loadBeanDefinitions(CLASS_NOT_FOUND_CONTEXT);
 		// cool, no errors, so the rubbish class name in the bean def was not resolved
@@ -1147,7 +1212,8 @@ private void doTestDependencies(ClassPathResource resource, int nrOfHoldingBeans
 		}
 	}
 
-	public @Test void testClassNotFoundWithNoBeanClassLoader() {
+	@Test
+	public void testClassNotFoundWithNoBeanClassLoader() {
 		DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(bf);
 		reader.setBeanClassLoader(null);
@@ -1155,7 +1221,8 @@ private void doTestDependencies(ClassPathResource resource, int nrOfHoldingBeans
 		assertEquals("WhatALotOfRubbish", bf.getBeanDefinition("classNotFound").getBeanClassName());
 	}
 
-	public @Test void testResourceAndInputStream() throws IOException {
+	@Test
+	public void testResourceAndInputStream() throws IOException {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(RESOURCE_CONTEXT);
 		// comes from "resourceImport.xml"
@@ -1178,7 +1245,8 @@ private void doTestDependencies(ClassPathResource resource, int nrOfHoldingBeans
 		assertEquals("test", writer.toString());
 	}
 
-	public @Test void testClassPathResourceWithImport() {
+	@Test
+	public void testClassPathResourceWithImport() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(RESOURCE_CONTEXT);
 		// comes from "resourceImport.xml"
@@ -1187,7 +1255,8 @@ private void doTestDependencies(ClassPathResource resource, int nrOfHoldingBeans
 		xbf.getBean("resource2", ResourceTestBean.class);
 	}
 
-	public @Test void testUrlResourceWithImport() {
+	@Test
+	public void testUrlResourceWithImport() {
 		URL url = getClass().getResource(RESOURCE_CONTEXT.getPath());
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(new UrlResource(url));
@@ -1197,7 +1266,8 @@ private void doTestDependencies(ClassPathResource resource, int nrOfHoldingBeans
 		xbf.getBean("resource2", ResourceTestBean.class);
 	}
 
-	public @Test void testFileSystemResourceWithImport() throws URISyntaxException {
+	@Test
+	public void testFileSystemResourceWithImport() throws URISyntaxException {
 		String file = getClass().getResource(RESOURCE_CONTEXT.getPath()).toURI().getPath();
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(new FileSystemResource(file));
@@ -1207,7 +1277,8 @@ private void doTestDependencies(ClassPathResource resource, int nrOfHoldingBeans
 		xbf.getBean("resource2", ResourceTestBean.class);
 	}
 
-	public @Test void testRecursiveImport() {
+	@Test
+	public void testRecursiveImport() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		try {
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(RECURSIVE_IMPORT_CONTEXT);
@@ -1220,7 +1291,8 @@ private void doTestDependencies(ClassPathResource resource, int nrOfHoldingBeans
 	}
 
 
-	public @Test void testLookupOverrideMethodsWithSetterInjection() {
+	@Test
+	public void testLookupOverrideMethodsWithSetterInjection() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.loadBeanDefinitions(OVERRIDES_CONTEXT);
@@ -1285,7 +1357,8 @@ private void testLookupOverrideMethodsWithSetterInjection(BeanFactory xbf, Strin
 		assertSame(dave1, dave2);
 	}
 
-	public @Test void testReplaceMethodOverrideWithSetterInjection() {
+	@Test
+	public void testReplaceMethodOverrideWithSetterInjection() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.loadBeanDefinitions(DELEGATION_OVERRIDES_CONTEXT);
@@ -1332,7 +1405,8 @@ private void testLookupOverrideMethodsWithSetterInjection(BeanFactory xbf, Strin
 		assertEquals(s2, dos.lastArg);
 	}
 
-	public @Test void testLookupOverrideOneMethodWithConstructorInjection() {
+	@Test
+	public void testLookupOverrideOneMethodWithConstructorInjection() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.loadBeanDefinitions(CONSTRUCTOR_OVERRIDES_CONTEXT);
@@ -1355,7 +1429,8 @@ private void testLookupOverrideMethodsWithSetterInjection(BeanFactory xbf, Strin
 				fm1.getTestBean(), fm2.getTestBean());
 	}
 
-	public @Test void testRejectsOverrideOfBogusMethodName() {
+	@Test
+	public void testRejectsOverrideOfBogusMethodName() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		try {
@@ -1372,7 +1447,8 @@ private void testLookupOverrideMethodsWithSetterInjection(BeanFactory xbf, Strin
 	/**
 	 * Assert the presence of this bug until we resolve it.
 	 */
-	public @Test void testSerializabilityOfMethodReplacer() throws Exception {
+	@Test
+	public void testSerializabilityOfMethodReplacer() throws Exception {
 		try {
 			BUGtestSerializableMethodReplacerAndSuperclass();
 			fail();
@@ -1395,7 +1471,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals("Method replace still works after serialization and deserialization", backwards, s.replaceMe(forwards));
 	}
 
-	public @Test void testInnerBeanInheritsScopeFromConcreteChildDefinition() {
+	@Test
+	public void testInnerBeanInheritsScopeFromConcreteChildDefinition() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.loadBeanDefinitions(OVERRIDES_CONTEXT);
@@ -1404,7 +1481,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertTrue(jenny.getFriends().iterator().next() instanceof TestBean);
 	}
 
-	public @Test void testConstructorArgWithSingleSimpleTypeMatch() {
+	@Test
+	public void testConstructorArgWithSingleSimpleTypeMatch() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 
@@ -1415,7 +1493,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertTrue(bean2.isSingleBoolean());
 	}
 
-	public @Test void testConstructorArgWithDoubleSimpleTypeMatch() {
+	@Test
+	public void testConstructorArgWithDoubleSimpleTypeMatch() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 
@@ -1428,7 +1507,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals("A String", bean2.getTestString());
 	}
 
-	public @Test void testDoubleBooleanAutowire() {
+	@Test
+	public void testDoubleBooleanAutowire() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		DoubleBooleanConstructorBean bean = (DoubleBooleanConstructorBean) xbf.getBean("beanWithDoubleBoolean");
@@ -1436,7 +1516,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals(Boolean.FALSE, bean.boolean2);
 	}
 
-	public @Test void testDoubleBooleanAutowireWithIndex() {
+	@Test
+	public void testDoubleBooleanAutowireWithIndex() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		DoubleBooleanConstructorBean bean = (DoubleBooleanConstructorBean) xbf.getBean("beanWithDoubleBooleanAndIndex");
@@ -1444,21 +1525,24 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals(Boolean.TRUE, bean.boolean2);
 	}
 
-	public @Test void testLenientDependencyMatching() {
+	@Test
+	public void testLenientDependencyMatching() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		LenientDependencyTestBean bean = (LenientDependencyTestBean) xbf.getBean("lenientDependencyTestBean");
 		assertTrue(bean.tb instanceof DerivedTestBean);
 	}
 
-	public @Test void testLenientDependencyMatchingFactoryMethod() {
+	@Test
+	public void testLenientDependencyMatchingFactoryMethod() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		LenientDependencyTestBean bean = (LenientDependencyTestBean) xbf.getBean("lenientDependencyTestBeanFactoryMethod");
 		assertTrue(bean.tb instanceof DerivedTestBean);
 	}
 
-	public @Test void testNonLenientDependencyMatching() {
+	@Test
+	public void testNonLenientDependencyMatching() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		AbstractBeanDefinition bd = (AbstractBeanDefinition) xbf.getBeanDefinition("lenientDependencyTestBean");
@@ -1474,7 +1558,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		}
 	}
 
-	public @Test void testNonLenientDependencyMatchingFactoryMethod() {
+	@Test
+	public void testNonLenientDependencyMatchingFactoryMethod() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		AbstractBeanDefinition bd = (AbstractBeanDefinition) xbf.getBeanDefinition("lenientDependencyTestBeanFactoryMethod");
@@ -1490,7 +1575,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		}
 	}
 
-	public @Test void testJavaLangStringConstructor() {
+	@Test
+	public void testJavaLangStringConstructor() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		AbstractBeanDefinition bd = (AbstractBeanDefinition) xbf.getBeanDefinition("string");
@@ -1499,7 +1585,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals("test", str);
 	}
 
-	public @Test void testCustomStringConstructor() {
+	@Test
+	public void testCustomStringConstructor() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		AbstractBeanDefinition bd = (AbstractBeanDefinition) xbf.getBeanDefinition("stringConstructor");
@@ -1508,7 +1595,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals("test", tb.name);
 	}
 
-	public @Test void testPrimitiveConstructorArray() {
+	@Test
+	public void testPrimitiveConstructorArray() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		ConstructorArrayTestBean bean = (ConstructorArrayTestBean) xbf.getBean("constructorArray");
@@ -1517,7 +1605,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals(1, ((int[]) bean.array)[0]);
 	}
 
-	public @Test void testIndexedPrimitiveConstructorArray() {
+	@Test
+	public void testIndexedPrimitiveConstructorArray() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		ConstructorArrayTestBean bean = (ConstructorArrayTestBean) xbf.getBean("indexedConstructorArray");
@@ -1526,7 +1615,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals(1, ((int[]) bean.array)[0]);
 	}
 
-	public @Test void testStringConstructorArrayNoType() {
+	@Test
+	public void testStringConstructorArrayNoType() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		ConstructorArrayTestBean bean = (ConstructorArrayTestBean) xbf.getBean("constructorArrayNoType");
@@ -1534,7 +1624,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals(0, ((String[]) bean.array).length);
 	}
 
-	public @Test void testStringConstructorArrayNoTypeNonLenient() {
+	@Test
+	public void testStringConstructorArrayNoTypeNonLenient() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(CONSTRUCTOR_ARG_CONTEXT);
 		AbstractBeanDefinition bd = (AbstractBeanDefinition) xbf.getBeanDefinition("constructorArrayNoType");
@@ -1544,7 +1635,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals(0, ((String[]) bean.array).length);
 	}
 
-	public @Test void testWithDuplicateName() throws Exception {
+	@Test
+	public void testWithDuplicateName() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		try {
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(TEST_WITH_DUP_NAMES_CONTEXT);
@@ -1555,7 +1647,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		}
 	}
 
-	public @Test void testWithDuplicateNameInAlias() throws Exception {
+	@Test
+	public void testWithDuplicateNameInAlias() throws Exception {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		try {
 			new XmlBeanDefinitionReader(xbf).loadBeanDefinitions(TEST_WITH_DUP_NAME_IN_ALIAS_CONTEXT);
@@ -1566,7 +1659,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		}
 	}
 
-	public @Test void testOverrideMethodByArgTypeAttribute() {
+	@Test
+	public void testOverrideMethodByArgTypeAttribute() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.loadBeanDefinitions(DELEGATION_OVERRIDES_CONTEXT);
@@ -1575,7 +1669,8 @@ public void BUGtestSerializableMethodReplacerAndSuperclass() throws IOException,
 		assertEquals("should replace", "cba", oom.replaceMe("abc"));
 	}
 
-	public @Test void testOverrideMethodByArgTypeElement() {
+	@Test
+	public void testOverrideMethodByArgTypeElement() {
 		DefaultListableBeanFactory xbf = new DefaultListableBeanFactory();
 		XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(xbf);
 		reader.loadBeanDefinitions(DELEGATION_OVERRIDES_CONTEXT);
diff --git a/spring-context/src/test/java/org/springframework/cache/config/AbstractAnnotationTests.java b/spring-context/src/test/java/org/springframework/cache/config/AbstractAnnotationTests.java
index 4bc0c888b31a..41d717d6927e 100644
--- a/spring-context/src/test/java/org/springframework/cache/config/AbstractAnnotationTests.java
+++ b/spring-context/src/test/java/org/springframework/cache/config/AbstractAnnotationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010-2011 the original author or authors.
+ * Copyright 2010-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,8 @@
 
 package org.springframework.cache.config;
 
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.nullValue;
 import static org.junit.Assert.*;
 
 import java.util.Collection;
@@ -33,6 +35,7 @@
  *
  * @author Costin Leau
  * @author Chris Beams
+ * @author Phillip Webb
  */
 public abstract class AbstractAnnotationTests {
 
@@ -187,6 +190,15 @@ public void testConditionalExpression(CacheableService<?> service) throws Except
 		assertSame(r3, r4);
 	}
 
+	public void testUnlessExpression(CacheableService<?> service) throws Exception {
+		Cache cache = cm.getCache("default");
+		cache.clear();
+		service.unless(10);
+		service.unless(11);
+		assertThat(cache.get(10).get(), equalTo((Object) 10L));
+		assertThat(cache.get(11), nullValue());
+	}
+
 	public void testKeyExpression(CacheableService<?> service) throws Exception {
 		Object r1 = service.key(5, 1);
 		Object r2 = service.key(5, 2);
@@ -441,6 +453,16 @@ public void testConditionalExpression() throws Exception {
 		testConditionalExpression(cs);
 	}
 
+	@Test
+	public void testUnlessExpression() throws Exception {
+		testUnlessExpression(cs);
+	}
+
+	@Test
+	public void testClassCacheUnlessExpression() throws Exception {
+		testUnlessExpression(cs);
+	}
+
 	@Test
 	public void testKeyExpression() throws Exception {
 		testKeyExpression(cs);
@@ -618,4 +640,4 @@ public void testMultiConditionalCacheAndEvict() {
 	public void testClassMultiConditionalCacheAndEvict() {
 		testMultiConditionalCacheAndEvict(ccs);
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/test/java/org/springframework/cache/config/AnnotatedClassCacheableService.java b/spring-context/src/test/java/org/springframework/cache/config/AnnotatedClassCacheableService.java
index 4c72d9d59370..f168ab990ad1 100644
--- a/spring-context/src/test/java/org/springframework/cache/config/AnnotatedClassCacheableService.java
+++ b/spring-context/src/test/java/org/springframework/cache/config/AnnotatedClassCacheableService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,6 +25,7 @@
 
 /**
  * @author Costin Leau
+ * @author Phillip Webb
  */
 @Cacheable("default")
 public class AnnotatedClassCacheableService implements CacheableService<Object> {
@@ -42,6 +43,12 @@ public Object conditional(int field) {
 		return null;
 	}
 
+	@Override
+	@Cacheable(value = "default", unless = "#result > 10")
+	public Object unless(int arg) {
+		return arg;
+	}
+
 	@Override
 	@CacheEvict("default")
 	public void invalidate(Object arg1) {
@@ -157,4 +164,4 @@ public Object multiConditionalCacheAndEvict(Object arg1) {
 	public Object multiUpdate(Object arg1) {
 		return arg1;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/test/java/org/springframework/cache/config/CacheableService.java b/spring-context/src/test/java/org/springframework/cache/config/CacheableService.java
index 81dd758d19d4..98c1da1e0315 100644
--- a/spring-context/src/test/java/org/springframework/cache/config/CacheableService.java
+++ b/spring-context/src/test/java/org/springframework/cache/config/CacheableService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
  * Basic service interface.
  *
  * @author Costin Leau
+ * @author Phillip Webb
  */
 public interface CacheableService<T> {
 
@@ -39,6 +40,8 @@ public interface CacheableService<T> {
 
 	T conditional(int field);
 
+	T unless(int arg);
+
 	T key(Object arg1, Object arg2);
 
 	T name(Object arg1);
@@ -67,4 +70,4 @@ public interface CacheableService<T> {
 	T multiConditionalCacheAndEvict(Object arg1);
 
 	T multiUpdate(Object arg1);
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/test/java/org/springframework/cache/config/DefaultCacheableService.java b/spring-context/src/test/java/org/springframework/cache/config/DefaultCacheableService.java
index f9f19b475940..f987d7bbe613 100644
--- a/spring-context/src/test/java/org/springframework/cache/config/DefaultCacheableService.java
+++ b/spring-context/src/test/java/org/springframework/cache/config/DefaultCacheableService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,6 +27,7 @@
  * Simple cacheable service
  *
  * @author Costin Leau
+ * @author Phillip Webb
  */
 public class DefaultCacheableService implements CacheableService<Long> {
 
@@ -78,6 +79,12 @@ public Long conditional(int classField) {
 		return counter.getAndIncrement();
 	}
 
+	@Override
+	@Cacheable(value = "default", unless = "#result > 10")
+	public Long unless(int arg) {
+		return (long) arg;
+	}
+
 	@Override
 	@Cacheable(value = "default", key = "#p0")
 	public Long key(Object arg1, Object arg2) {
@@ -163,4 +170,4 @@ public Long multiConditionalCacheAndEvict(Object arg1) {
 	public Long multiUpdate(Object arg1) {
 		return Long.valueOf(arg1.toString());
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/test/java/org/springframework/cache/interceptor/ExpressionEvalutatorTest.java b/spring-context/src/test/java/org/springframework/cache/interceptor/ExpressionEvaluatorTests.java
similarity index 61%
rename from spring-context/src/test/java/org/springframework/cache/interceptor/ExpressionEvalutatorTest.java
rename to spring-context/src/test/java/org/springframework/cache/interceptor/ExpressionEvaluatorTests.java
index b52f364746a4..44762719bcf0 100644
--- a/spring-context/src/test/java/org/springframework/cache/interceptor/ExpressionEvalutatorTest.java
+++ b/spring-context/src/test/java/org/springframework/cache/interceptor/ExpressionEvaluatorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,24 +16,39 @@
 
 package org.springframework.cache.interceptor;
 
-import static org.junit.Assert.*;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.nullValue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
 
 import java.lang.reflect.Method;
 import java.util.Collection;
 import java.util.Iterator;
 
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.springframework.cache.Cache;
 import org.springframework.cache.annotation.AnnotationCacheOperationSource;
 import org.springframework.cache.annotation.Cacheable;
 import org.springframework.cache.annotation.Caching;
 import org.springframework.cache.concurrent.ConcurrentMapCache;
 import org.springframework.expression.EvaluationContext;
+import org.springframework.expression.spel.standard.SpelExpressionParser;
 import org.springframework.util.ReflectionUtils;
 
 import edu.emory.mathcs.backport.java.util.Collections;
 
-public class ExpressionEvalutatorTest {
+/**
+ * @author Costin Leau
+ * @author Phillip Webb
+ */
+public class ExpressionEvaluatorTests {
+
+	@Rule
+	public ExpectedException thrown = ExpectedException.none();
+
 	private ExpressionEvaluator eval = new ExpressionEvaluator();
 
 	private AnnotationCacheOperationSource source = new AnnotationCacheOperationSource();
@@ -59,6 +74,7 @@ public void testMultipleCachingSource() throws Exception {
 	}
 
 	@Test
+	@SuppressWarnings("unchecked")
 	public void testMultipleCachingEval() throws Exception {
 		AnnotatedClass target = new AnnotatedClass();
 		Method method = ReflectionUtils.findMethod(AnnotatedClass.class, "multipleCaching", Object.class,
@@ -78,9 +94,41 @@ public void testMultipleCachingEval() throws Exception {
 		assertEquals(args[1], keyB);
 	}
 
+	@Test
+	public void withReturnValue() throws Exception {
+		EvaluationContext context = createEvaluationContext("theResult");
+		Object value = new SpelExpressionParser().parseExpression("#result").getValue(context);
+		assertThat(value, equalTo((Object) "theResult"));
+	}
+
+	@Test
+	public void withNullReturn() throws Exception {
+		EvaluationContext context = createEvaluationContext(null);
+		Object value = new SpelExpressionParser().parseExpression("#result").getValue(context);
+		assertThat(value, nullValue());
+	}
+
+	@Test
+	public void withoutReturnValue() throws Exception {
+		EvaluationContext context = createEvaluationContext(ExpressionEvaluator.NO_RESULT);
+		Object value = new SpelExpressionParser().parseExpression("#result").getValue(context);
+		assertThat(value, nullValue());
+	}
+
+	private EvaluationContext createEvaluationContext(Object result) {
+		AnnotatedClass target = new AnnotatedClass();
+		Method method = ReflectionUtils.findMethod(AnnotatedClass.class, "multipleCaching", Object.class,
+				Object.class);
+		Object[] args = new Object[] { new Object(), new Object() };
+		@SuppressWarnings("unchecked")
+		Collection<Cache> map = Collections.singleton(new ConcurrentMapCache("test"));
+		EvaluationContext context = eval.createEvaluationContext(map, method, args, target, target.getClass(), result);
+		return context;
+	}
+
 	private static class AnnotatedClass {
 		@Caching(cacheable = { @Cacheable(value = "test", key = "#a"), @Cacheable(value = "test", key = "#b") })
 		public void multipleCaching(Object a, Object b) {
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-context/src/test/java/org/springframework/context/access/ContextBeanFactoryReferenceTests.java b/spring-context/src/test/java/org/springframework/context/access/ContextBeanFactoryReferenceTests.java
index 33bdac26e819..f9aefe64da1c 100644
--- a/spring-context/src/test/java/org/springframework/context/access/ContextBeanFactoryReferenceTests.java
+++ b/spring-context/src/test/java/org/springframework/context/access/ContextBeanFactoryReferenceTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,13 +16,12 @@
 
 package org.springframework.context.access;
 
-import static org.junit.Assert.assertNotNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.junit.Test;
 import org.springframework.context.ConfigurableApplicationContext;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit test for {@link ContextBeanFactoryReference}
  *
diff --git a/spring-context/src/test/java/org/springframework/context/annotation/AnnotationConfigApplicationContextTests.java b/spring-context/src/test/java/org/springframework/context/annotation/AnnotationConfigApplicationContextTests.java
index 5906ea485dc0..f53c9e1a2536 100644
--- a/spring-context/src/test/java/org/springframework/context/annotation/AnnotationConfigApplicationContextTests.java
+++ b/spring-context/src/test/java/org/springframework/context/annotation/AnnotationConfigApplicationContextTests.java
@@ -133,7 +133,6 @@ public void getBeanByTypeRaisesNoSuchBeanDefinitionException() {
 		}
 	}
 
-	@SuppressWarnings("unchecked")
 	@Test
 	public void getBeanByTypeAmbiguityRaisesException() {
 		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(TwoTestBeanConfig.class);
diff --git a/spring-context/src/test/java/org/springframework/context/annotation/BeanMethodPolymorphismTests.java b/spring-context/src/test/java/org/springframework/context/annotation/BeanMethodPolymorphismTests.java
index 655324d1c7d7..1d573540f8a2 100644
--- a/spring-context/src/test/java/org/springframework/context/annotation/BeanMethodPolymorphismTests.java
+++ b/spring-context/src/test/java/org/springframework/context/annotation/BeanMethodPolymorphismTests.java
@@ -47,7 +47,7 @@ public class BeanMethodPolymorphismTests {
 
 	@Test
 	public void beanMethodOverloadingWithoutInheritance() {
-		@SuppressWarnings({ "unused", "hiding" })
+		@SuppressWarnings({ "hiding" })
 		@Configuration class Config {
 			@Bean String aString() { return "na"; }
 			@Bean String aString(Integer dependency) { return "na"; }
diff --git a/spring-context/src/test/java/org/springframework/context/annotation/CommonAnnotationBeanPostProcessorTests.java b/spring-context/src/test/java/org/springframework/context/annotation/CommonAnnotationBeanPostProcessorTests.java
index 331a2f0af2ae..e2c1cc3b57d2 100644
--- a/spring-context/src/test/java/org/springframework/context/annotation/CommonAnnotationBeanPostProcessorTests.java
+++ b/spring-context/src/test/java/org/springframework/context/annotation/CommonAnnotationBeanPostProcessorTests.java
@@ -700,6 +700,7 @@ private static class ConvertedResourceInjectionBean {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class NullFactory {
 
 		public static Object create() {
diff --git a/spring-context/src/test/java/org/springframework/context/annotation/ComponentScanParserBeanDefinitionDefaultsTests.java b/spring-context/src/test/java/org/springframework/context/annotation/ComponentScanParserBeanDefinitionDefaultsTests.java
index 28fdcccca0ab..bf0baeaa53c9 100644
--- a/spring-context/src/test/java/org/springframework/context/annotation/ComponentScanParserBeanDefinitionDefaultsTests.java
+++ b/spring-context/src/test/java/org/springframework/context/annotation/ComponentScanParserBeanDefinitionDefaultsTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2007 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -214,6 +214,7 @@ public void testDefaultNonExistingInitAndDestroyMethodsDefined() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class DefaultsTestBean {
 
 		static int INIT_COUNT;
@@ -276,6 +277,7 @@ public PropertyDependencyTestBean getPropertyDependency2() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class PropertyDependencyTestBean {
 
 		private String name;
@@ -290,6 +292,7 @@ public String getName() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class ConstructorDependencyTestBean {
 
 		private String name;
diff --git a/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassSpr8954Tests.java b/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassSpr8954Tests.java
new file mode 100644
index 000000000000..1a7a5b1b33eb
--- /dev/null
+++ b/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassSpr8954Tests.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.context.annotation;
+
+import java.util.Map;
+
+import org.junit.Test;
+
+import org.springframework.beans.factory.FactoryBean;
+import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;
+import org.springframework.beans.factory.support.DefaultListableBeanFactory;
+import org.springframework.beans.factory.support.RootBeanDefinition;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+/**
+ * Unit tests for SPR-8954, in which a custom {@link InstantiationAwareBeanPostProcessor}
+ * forces the predicted type of a FactoryBean, effectively preventing retrieval of the
+ * bean from calls to #getBeansOfType(FactoryBean.class). The implementation of
+ * {@link AbstractBeanFactory#isFactoryBean(String, RootBeanDefinition)} now ensures
+ * that not only the predicted bean type is considered, but also the original bean
+ * definition's beanClass.
+ *
+ * @author Chris Beams
+ * @author Oliver Gierke
+ */
+public class ConfigurationClassSpr8954Tests {
+
+	@Test
+	public void repro() {
+		AnnotationConfigApplicationContext bf = new AnnotationConfigApplicationContext();
+		bf.registerBeanDefinition("fooConfig", new RootBeanDefinition(FooConfig.class));
+		bf.getBeanFactory().addBeanPostProcessor(new PredictingBPP());
+		bf.refresh();
+
+		assertThat(bf.getBean("foo"), instanceOf(Foo.class));
+		assertThat(bf.getBean("&foo"), instanceOf(FooFactoryBean.class));
+
+		assertThat(bf.isTypeMatch("&foo", FactoryBean.class), is(true));
+
+		@SuppressWarnings("rawtypes")
+		Map<String, FactoryBean> fbBeans = bf.getBeansOfType(FactoryBean.class);
+		assertThat(1, equalTo(fbBeans.size()));
+		assertThat("&foo", equalTo(fbBeans.keySet().iterator().next()));
+
+		Map<String, AnInterface> aiBeans = bf.getBeansOfType(AnInterface.class);
+		assertThat(1, equalTo(aiBeans.size()));
+		assertThat("&foo", equalTo(aiBeans.keySet().iterator().next()));
+	}
+
+	@Test
+	public void findsBeansByTypeIfNotInstantiated() {
+		AnnotationConfigApplicationContext bf = new AnnotationConfigApplicationContext();
+		bf.registerBeanDefinition("fooConfig", new RootBeanDefinition(FooConfig.class));
+		bf.getBeanFactory().addBeanPostProcessor(new PredictingBPP());
+		bf.refresh();
+
+		assertThat(bf.isTypeMatch("&foo", FactoryBean.class), is(true));
+
+		@SuppressWarnings("rawtypes")
+		Map<String, FactoryBean> fbBeans = bf.getBeansOfType(FactoryBean.class);
+		assertThat(1, equalTo(fbBeans.size()));
+		assertThat("&foo", equalTo(fbBeans.keySet().iterator().next()));
+
+		Map<String, AnInterface> aiBeans = bf.getBeansOfType(AnInterface.class);
+		assertThat(1, equalTo(aiBeans.size()));
+		assertThat("&foo", equalTo(aiBeans.keySet().iterator().next()));
+	}
+
+
+	static class FooConfig {
+
+		@Bean FooFactoryBean foo() {
+			return new FooFactoryBean();
+		}
+	}
+
+	static class FooFactoryBean implements FactoryBean<Foo>, AnInterface {
+
+		@Override
+		public Foo getObject() throws Exception {
+			return new Foo();
+		}
+
+		@Override
+		public Class<?> getObjectType() {
+			return Foo.class;
+		}
+
+		@Override
+		public boolean isSingleton() {
+			return true;
+		}
+	}
+
+	interface AnInterface {
+	}
+
+	static class Foo {
+	}
+
+	interface PredictedType {
+	}
+
+	static class PredictedTypeImpl implements PredictedType {
+	}
+
+	static class PredictingBPP extends InstantiationAwareBeanPostProcessorAdapter {
+
+		@Override
+		public Class<?> predictBeanType(Class<?> beanClass, String beanName) {
+			return FactoryBean.class.isAssignableFrom(beanClass) ?
+					PredictedType.class : null;
+		}
+	}
+
+}
diff --git a/spring-context/src/test/java/org/springframework/context/annotation/EnableLoadTimeWeavingTests.java b/spring-context/src/test/java/org/springframework/context/annotation/EnableLoadTimeWeavingTests.java
index 9a3ced52d704..a8b40b2ac33f 100644
--- a/spring-context/src/test/java/org/springframework/context/annotation/EnableLoadTimeWeavingTests.java
+++ b/spring-context/src/test/java/org/springframework/context/annotation/EnableLoadTimeWeavingTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,6 @@
 
 package org.springframework.context.annotation;
 
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-
 import java.lang.instrument.ClassFileTransformer;
 
 import org.junit.Test;
@@ -28,6 +23,9 @@
 import org.springframework.context.support.GenericXmlApplicationContext;
 import org.springframework.instrument.classloading.LoadTimeWeaver;
 
+import static org.mockito.Matchers.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for @EnableLoadTimeWeaving
  *
diff --git a/spring-context/src/test/java/org/springframework/context/annotation/configuration/BeanAnnotationAttributePropagationTests.java b/spring-context/src/test/java/org/springframework/context/annotation/configuration/BeanAnnotationAttributePropagationTests.java
index f0dcbab8abb4..f063133eab3b 100644
--- a/spring-context/src/test/java/org/springframework/context/annotation/configuration/BeanAnnotationAttributePropagationTests.java
+++ b/spring-context/src/test/java/org/springframework/context/annotation/configuration/BeanAnnotationAttributePropagationTests.java
@@ -41,7 +41,6 @@
  *
  * @author Chris Beams
  */
-@SuppressWarnings("unused") // for unused @Bean methods in local classes
 public class BeanAnnotationAttributePropagationTests {
 
 	@Test
diff --git a/spring-context/src/test/java/org/springframework/context/annotation/configuration/ConfigurationClassProcessingTests.java b/spring-context/src/test/java/org/springframework/context/annotation/configuration/ConfigurationClassProcessingTests.java
index 54846f4133c4..7e11066fe836 100644
--- a/spring-context/src/test/java/org/springframework/context/annotation/configuration/ConfigurationClassProcessingTests.java
+++ b/spring-context/src/test/java/org/springframework/context/annotation/configuration/ConfigurationClassProcessingTests.java
@@ -272,6 +272,7 @@ public TestBean baz() {
 	}
 
 
+	@SuppressWarnings("unused")
 	static class ConfigWithPostProcessor extends ConfigWithPrototypeBean {
 
 		@Value("${myProp}")
@@ -280,10 +281,13 @@ static class ConfigWithPostProcessor extends ConfigWithPrototypeBean {
 		@Bean
 		public POBPP beanPostProcessor() {
 			return new POBPP() {
+
 				String nameSuffix = "-processed-" + myProp;
+
 				public void setNameSuffix(String nameSuffix) {
 					this.nameSuffix = nameSuffix;
 				}
+
 				@Override
 				public Object postProcessBeforeInitialization(Object bean, String beanName) {
 					if (bean instanceof ITestBean) {
@@ -291,10 +295,12 @@ public Object postProcessBeforeInitialization(Object bean, String beanName) {
 					}
 					return bean;
 				}
+
 				@Override
 				public Object postProcessAfterInitialization(Object bean, String beanName) {
 					return bean;
 				}
+
 				public int getOrder() {
 					return 0;
 				}
diff --git a/spring-context/src/test/java/org/springframework/context/event/ApplicationContextEventTests.java b/spring-context/src/test/java/org/springframework/context/event/ApplicationContextEventTests.java
index d124bac83066..24c1a4da95a2 100644
--- a/spring-context/src/test/java/org/springframework/context/event/ApplicationContextEventTests.java
+++ b/spring-context/src/test/java/org/springframework/context/event/ApplicationContextEventTests.java
@@ -20,16 +20,8 @@
 import java.util.Set;
 
 import org.aopalliance.intercept.MethodInvocation;
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.junit.Test;
-
 import org.springframework.aop.framework.ProxyFactory;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.beans.factory.config.RuntimeBeanReference;
 import org.springframework.beans.factory.support.RootBeanDefinition;
 import org.springframework.context.ApplicationContext;
@@ -39,6 +31,10 @@
 import org.springframework.context.BeanThatListens;
 import org.springframework.context.support.StaticApplicationContext;
 import org.springframework.core.Ordered;
+import org.springframework.tests.sample.beans.TestBean;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * Unit and integration tests for the ApplicationContext event support.
diff --git a/spring-context/src/test/java/org/springframework/context/event/EventPublicationInterceptorTests.java b/spring-context/src/test/java/org/springframework/context/event/EventPublicationInterceptorTests.java
index 1a0e064b757f..128abf301dc6 100644
--- a/spring-context/src/test/java/org/springframework/context/event/EventPublicationInterceptorTests.java
+++ b/spring-context/src/test/java/org/springframework/context/event/EventPublicationInterceptorTests.java
@@ -16,21 +16,21 @@
 
 package org.springframework.context.event;
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.aop.framework.ProxyFactory;
 import org.springframework.beans.BeansException;
-import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.beans.MutablePropertyValues;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.beans.factory.FactoryBean;
 import org.springframework.context.ApplicationEvent;
 import org.springframework.context.ApplicationEventPublisher;
 import org.springframework.context.TestListener;
 import org.springframework.context.support.StaticApplicationContext;
+import org.springframework.tests.sample.beans.ITestBean;
+import org.springframework.tests.sample.beans.TestBean;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Dmitriy Kopylenko
diff --git a/spring-context/src/test/java/org/springframework/context/support/ConversionServiceFactoryBeanTests.java b/spring-context/src/test/java/org/springframework/context/support/ConversionServiceFactoryBeanTests.java
index 676ff05a305a..396e4a1bb0ca 100644
--- a/spring-context/src/test/java/org/springframework/context/support/ConversionServiceFactoryBeanTests.java
+++ b/spring-context/src/test/java/org/springframework/context/support/ConversionServiceFactoryBeanTests.java
@@ -33,6 +33,7 @@
 import org.springframework.core.io.ClassPathResource;
 import org.springframework.core.io.FileSystemResource;
 
+import static org.hamcrest.Matchers.instanceOf;
 import static org.junit.Assert.*;
 
 /**
@@ -136,8 +137,8 @@ public static class ComplexConstructorArgument {
 
 		public ComplexConstructorArgument(Map<String, Class<?>> map) {
 			assertTrue(!map.isEmpty());
-			assertTrue(map.keySet().iterator().next() instanceof String);
-			assertTrue(map.values().iterator().next() instanceof Class);
+			assertThat(map.keySet().iterator().next(), instanceOf(String.class));
+			assertThat(map.values().iterator().next(), instanceOf(Class.class));
 		}
 	}
 
diff --git a/spring-context/src/test/java/org/springframework/context/support/ResourceBundleMessageSourceTests.java b/spring-context/src/test/java/org/springframework/context/support/ResourceBundleMessageSourceTests.java
index c0121a4a2dd0..3a265516cdfb 100644
--- a/spring-context/src/test/java/org/springframework/context/support/ResourceBundleMessageSourceTests.java
+++ b/spring-context/src/test/java/org/springframework/context/support/ResourceBundleMessageSourceTests.java
@@ -249,6 +249,18 @@ public void testReloadableResourceBundleMessageSourceStandalone() {
 		assertEquals("nachricht2", ms.getMessage("code2", null, Locale.GERMAN));
 	}
 
+	public void testReloadableResourceBundleMessageSourceWithCommonMessages() {
+		ReloadableResourceBundleMessageSource ms = new ReloadableResourceBundleMessageSource();
+		Properties commonMessages = new Properties();
+		commonMessages.setProperty("warning", "Do not do {0}");
+		ms.setCommonMessages(commonMessages);
+		ms.setBasename("org/springframework/context/support/messages");
+		assertEquals("message1", ms.getMessage("code1", null, Locale.ENGLISH));
+		assertEquals("nachricht2", ms.getMessage("code2", null, Locale.GERMAN));
+		assertEquals("Do not do this", ms.getMessage("warning", new Object[] {"this"}, Locale.ENGLISH));
+		assertEquals("Do not do that", ms.getMessage("warning", new Object[] {"that"}, Locale.GERMAN));
+	}
+
 	public void testReloadableResourceBundleMessageSourceWithWhitespaceInBasename() {
 		ReloadableResourceBundleMessageSource ms = new ReloadableResourceBundleMessageSource();
 		ms.setBasename("  org/springframework/context/support/messages  ");
diff --git a/spring-context/src/test/java/org/springframework/ejb/access/LocalSlsbInvokerInterceptorTests.java b/spring-context/src/test/java/org/springframework/ejb/access/LocalSlsbInvokerInterceptorTests.java
index b8206b21a28f..a87d56eb9bd7 100644
--- a/spring-context/src/test/java/org/springframework/ejb/access/LocalSlsbInvokerInterceptorTests.java
+++ b/spring-context/src/test/java/org/springframework/ejb/access/LocalSlsbInvokerInterceptorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,6 @@
 
 package org.springframework.ejb.access;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import javax.ejb.CreateException;
 import javax.ejb.EJBLocalHome;
 import javax.ejb.EJBLocalObject;
@@ -31,6 +26,9 @@
 import org.springframework.aop.framework.ProxyFactory;
 import org.springframework.jndi.JndiTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
diff --git a/spring-context/src/test/java/org/springframework/ejb/access/LocalStatelessSessionProxyFactoryBeanTests.java b/spring-context/src/test/java/org/springframework/ejb/access/LocalStatelessSessionProxyFactoryBeanTests.java
index c0a78215bd67..d10dce2a5ac7 100644
--- a/spring-context/src/test/java/org/springframework/ejb/access/LocalStatelessSessionProxyFactoryBeanTests.java
+++ b/spring-context/src/test/java/org/springframework/ejb/access/LocalStatelessSessionProxyFactoryBeanTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,6 @@
 
 package org.springframework.ejb.access;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-
 import java.lang.reflect.Proxy;
 
 import javax.ejb.CreateException;
@@ -32,6 +26,9 @@
 import org.junit.Test;
 import org.springframework.jndi.JndiTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
diff --git a/spring-context/src/test/java/org/springframework/ejb/access/SimpleRemoteSlsbInvokerInterceptorTests.java b/spring-context/src/test/java/org/springframework/ejb/access/SimpleRemoteSlsbInvokerInterceptorTests.java
index 0c03c57c69db..0191220b1bf3 100644
--- a/spring-context/src/test/java/org/springframework/ejb/access/SimpleRemoteSlsbInvokerInterceptorTests.java
+++ b/spring-context/src/test/java/org/springframework/ejb/access/SimpleRemoteSlsbInvokerInterceptorTests.java
@@ -16,12 +16,6 @@
 
 package org.springframework.ejb.access;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.rmi.ConnectException;
 import java.rmi.RemoteException;
 
@@ -36,6 +30,9 @@
 import org.springframework.jndi.JndiTemplate;
 import org.springframework.remoting.RemoteAccessException;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
diff --git a/spring-context/src/test/java/org/springframework/ejb/access/SimpleRemoteStatelessSessionProxyFactoryBeanTests.java b/spring-context/src/test/java/org/springframework/ejb/access/SimpleRemoteStatelessSessionProxyFactoryBeanTests.java
index 8e03115c1f30..68af4a9b06db 100644
--- a/spring-context/src/test/java/org/springframework/ejb/access/SimpleRemoteStatelessSessionProxyFactoryBeanTests.java
+++ b/spring-context/src/test/java/org/springframework/ejb/access/SimpleRemoteStatelessSessionProxyFactoryBeanTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,6 @@
 
 package org.springframework.ejb.access;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-
 import java.lang.reflect.Proxy;
 import java.rmi.RemoteException;
 
@@ -34,6 +28,9 @@
 import org.springframework.jndi.JndiTemplate;
 import org.springframework.remoting.RemoteAccessException;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
diff --git a/spring-context/src/test/java/org/springframework/format/datetime/DateFormattingTests.java b/spring-context/src/test/java/org/springframework/format/datetime/DateFormattingTests.java
index 5698ed06518e..2803f0dc9f9d 100644
--- a/spring-context/src/test/java/org/springframework/format/datetime/DateFormattingTests.java
+++ b/spring-context/src/test/java/org/springframework/format/datetime/DateFormattingTests.java
@@ -16,7 +16,10 @@
 
 package org.springframework.format.datetime;
 
+import static org.hamcrest.Matchers.equalTo;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
 
 import java.util.ArrayList;
 import java.util.Calendar;
@@ -50,9 +53,12 @@ public class DateFormattingTests {
 
 	@Before
 	public void setUp() {
-		DefaultConversionService.addDefaultConverters(conversionService);
-
 		DateFormatterRegistrar registrar = new DateFormatterRegistrar();
+		setUp(registrar);
+	}
+
+	private void setUp(DateFormatterRegistrar registrar) {
+		DefaultConversionService.addDefaultConverters(conversionService);
 		registrar.registerFormatters(conversionService);
 
 		SimpleDateBean bean = new SimpleDateBean();
@@ -187,13 +193,48 @@ public void testBindNestedDateAnnotated() {
 	}
 
 	@Test
-	public void dateToString() throws Exception {
+	public void dateToStringWithoutGlobalFormat() throws Exception {
+		Date date = new Date();
+		Object actual = this.conversionService.convert(date, TypeDescriptor.valueOf(Date.class), TypeDescriptor.valueOf(String.class));
+		String expected = date.toString();
+		assertEquals(expected, actual);
+	}
+
+	@Test
+	public void dateToStringWithGlobalFormat() throws Exception {
+		DateFormatterRegistrar registrar = new DateFormatterRegistrar();
+		registrar.setFormatter(new DateFormatter());
+		setUp(registrar);
 		Date date = new Date();
 		Object actual = this.conversionService.convert(date, TypeDescriptor.valueOf(Date.class), TypeDescriptor.valueOf(String.class));
 		String expected = new DateFormatter().print(date, Locale.US);
 		assertEquals(expected, actual);
 	}
 
+	@Test
+	@SuppressWarnings("deprecation")
+	public void stringToDateWithoutGlobalFormat() throws Exception {
+		// SPR-10105
+		String string = "Sat, 12 Aug 1995 13:30:00 GM";
+		Date date = this.conversionService.convert(string, Date.class);
+		assertThat(date, equalTo(new Date(string)));
+	}
+
+	@Test
+	public void stringToDateWithGlobalFormat() throws Exception {
+		// SPR-10105
+		DateFormatterRegistrar registrar = new DateFormatterRegistrar();
+		DateFormatter dateFormatter = new DateFormatter();
+		dateFormatter.setIso(ISO.DATE_TIME);
+		registrar.setFormatter(dateFormatter);
+		setUp(registrar);
+		// This is a format that cannot be parsed by new Date(String)
+		String string = "2009-06-01T14:23:05.003+0000";
+		Date date = this.conversionService.convert(string, Date.class);
+		assertNotNull(date);
+	}
+
+
 	@SuppressWarnings("unused")
 	private static class SimpleDateBean {
 
diff --git a/spring-context/src/test/java/org/springframework/format/datetime/joda/JodaTimeFormattingTests.java b/spring-context/src/test/java/org/springframework/format/datetime/joda/JodaTimeFormattingTests.java
index 237df0509f3f..c2aaf8d36a3c 100644
--- a/spring-context/src/test/java/org/springframework/format/datetime/joda/JodaTimeFormattingTests.java
+++ b/spring-context/src/test/java/org/springframework/format/datetime/joda/JodaTimeFormattingTests.java
@@ -16,6 +16,11 @@
 
 package org.springframework.format.datetime.joda;
 
+import static org.hamcrest.Matchers.equalTo;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
+
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
@@ -32,7 +37,6 @@
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.beans.MutablePropertyValues;
 import org.springframework.context.i18n.LocaleContextHolder;
 import org.springframework.core.convert.TypeDescriptor;
@@ -42,8 +46,6 @@
 import org.springframework.format.support.FormattingConversionService;
 import org.springframework.validation.DataBinder;
 
-import static org.junit.Assert.*;
-
 /**
  * @author Keith Donald
  * @author Juergen Hoeller
@@ -459,13 +461,40 @@ public void testBindMutableDateTimeAnnotated() {
 	}
 
 	@Test
-	public void dateToString() throws Exception {
+	public void dateToStringWithFormat() throws Exception {
+		JodaTimeFormatterRegistrar registrar = new JodaTimeFormatterRegistrar();
+		registrar.setDateTimeFormatter(org.joda.time.format.DateTimeFormat.shortDateTime());
+		setUp(registrar);
 		Date date = new Date();
 		Object actual = this.conversionService.convert(date, TypeDescriptor.valueOf(Date.class), TypeDescriptor.valueOf(String.class));
 		String expected = JodaTimeContextHolder.getFormatter(org.joda.time.format.DateTimeFormat.shortDateTime(), Locale.US).print(new DateTime(date));
 		assertEquals(expected, actual);
 	}
 
+	@Test
+	@SuppressWarnings("deprecation")
+	public void stringToDateWithoutGlobalFormat() throws Exception {
+		// SPR-10105
+		String string = "Sat, 12 Aug 1995 13:30:00 GM";
+		Date date = this.conversionService.convert(string, Date.class);
+		assertThat(date, equalTo(new Date(string)));
+	}
+
+	@Test
+	public void stringToDateWithGlobalFormat() throws Exception {
+		// SPR-10105
+		JodaTimeFormatterRegistrar registrar = new JodaTimeFormatterRegistrar();
+		DateTimeFormatterFactory factory = new DateTimeFormatterFactory();
+		factory.setIso(ISO.DATE_TIME);
+		registrar.setDateTimeFormatter(factory.createDateTimeFormatter());
+		setUp(registrar);
+		// This is a format that cannot be parsed by new Date(String)
+		String string = "2009-10-31T07:00:00.000-05:00";
+		Date date = this.conversionService.convert(string, Date.class);
+		assertNotNull(date);
+	}
+
+
 	@SuppressWarnings("unused")
 	private static class JodaTimeBean {
 
diff --git a/spring-context/src/test/java/org/springframework/format/support/FormattingConversionServiceFactoryBeanTests.java b/spring-context/src/test/java/org/springframework/format/support/FormattingConversionServiceFactoryBeanTests.java
index ae9aa8be0e8c..284b238e56d7 100644
--- a/spring-context/src/test/java/org/springframework/format/support/FormattingConversionServiceFactoryBeanTests.java
+++ b/spring-context/src/test/java/org/springframework/format/support/FormattingConversionServiceFactoryBeanTests.java
@@ -130,7 +130,6 @@ public void testInvalidFormatter() throws Exception {
 
 	private static class TestBean {
 
-		@SuppressWarnings("unused")
 		@NumberFormat(style = Style.PERCENT)
 		private double percent;
 
diff --git a/spring-context/src/test/java/org/springframework/format/support/FormattingConversionServiceTests.java b/spring-context/src/test/java/org/springframework/format/support/FormattingConversionServiceTests.java
index 6b0fb87da7e9..417ded1a459c 100644
--- a/spring-context/src/test/java/org/springframework/format/support/FormattingConversionServiceTests.java
+++ b/spring-context/src/test/java/org/springframework/format/support/FormattingConversionServiceTests.java
@@ -393,7 +393,6 @@ public static class MyDate extends Date {
 
 	private static class ModelWithSubclassField {
 
-		@SuppressWarnings("unused")
 		@org.springframework.format.annotation.DateTimeFormat(style = "S-")
 		public MyDate date;
 	}
diff --git a/spring-context/src/test/java/org/springframework/instrument/classloading/glassfish/GlassFishLoadTimeWeaverTests.java b/spring-context/src/test/java/org/springframework/instrument/classloading/glassfish/GlassFishLoadTimeWeaverTests.java
index b2efa269c1eb..7907a518719f 100644
--- a/spring-context/src/test/java/org/springframework/instrument/classloading/glassfish/GlassFishLoadTimeWeaverTests.java
+++ b/spring-context/src/test/java/org/springframework/instrument/classloading/glassfish/GlassFishLoadTimeWeaverTests.java
@@ -20,7 +20,6 @@
 
 // converting away from old-style EasyMock APIs was problematic with this class
 // glassfish dependencies no longer on classpath
-@SuppressWarnings("deprecation")
 @Ignore
 public class GlassFishLoadTimeWeaverTests {
 
diff --git a/spring-context/src/test/java/org/springframework/jmx/AbstractMBeanServerTests.java b/spring-context/src/test/java/org/springframework/jmx/AbstractMBeanServerTests.java
index 12dbf05a50c3..ab05a3ea6ed0 100644
--- a/spring-context/src/test/java/org/springframework/jmx/AbstractMBeanServerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/AbstractMBeanServerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,32 +20,38 @@
 import javax.management.MBeanServerFactory;
 import javax.management.ObjectName;
 
-import junit.framework.TestCase;
-
+import org.junit.After;
+import org.junit.Before;
 import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.context.support.GenericApplicationContext;
+import org.springframework.tests.TestGroup;
 import org.springframework.util.MBeanTestUtils;
 
+import static org.junit.Assert.*;
+
 /**
- * <strong>Note:</strong> the JMX test suite requires the presence of the
- * {@code jmxremote_optional.jar} in your classpath. Thus, if you
- * run into the <em>"Unsupported protocol: jmxmp"</em> error, you will
- * need to download the
- * <a href="http://www.oracle.com/technetwork/java/javase/tech/download-jsp-141676.html">JMX Remote API 1.0.1_04 Reference Implementation</a>
- * from Oracle and extract {@code jmxremote_optional.jar} into your
- * classpath, for example in the {@code lib/ext} folder of your JVM.
+ * <strong>Note:</strong> certain tests throughout this hierarchy require the presence of
+ * the {@code jmxremote_optional.jar} in your classpath. For this reason, these tests are
+ * run only if {@link TestGroup#JMXMP} is enabled. If you wish to run these tests, follow
+ * the instructions in the TestGroup class to enable JMXMP tests. If you run into the
+ * <em>"Unsupported protocol: jmxmp"</em> error, you will need to download the
+ * <a href="http://www.oracle.com/technetwork/java/javase/tech/download-jsp-141676.html">
+ * JMX Remote API 1.0.1_04 Reference Implementation</a> from Oracle and extract
+ * {@code jmxremote_optional.jar} into your classpath, for example in the {@code lib/ext}
+ * folder of your JVM.
  * See also <a href="https://issuetracker.springsource.com/browse/EBR-349">EBR-349</a>.
  *
  * @author Rob Harrop
  * @author Juergen Hoeller
  * @author Sam Brannen
+ * @author Chris Beams
  */
-public abstract class AbstractMBeanServerTests extends TestCase {
+public abstract class AbstractMBeanServerTests {
 
 	protected MBeanServer server;
 
-	@Override
+	@Before
 	public final void setUp() throws Exception {
 		this.server = MBeanServerFactory.createMBeanServer();
 		try {
@@ -64,8 +70,8 @@ protected ConfigurableApplicationContext loadContext(String configLocation) {
 		return ctx;
 	}
 
-	@Override
-	protected void tearDown() throws Exception {
+	@After
+	public void tearDown() throws Exception {
 		releaseServer();
 		onTearDown();
 	}
diff --git a/spring-context/src/test/java/org/springframework/jmx/JmxTestBean.java b/spring-context/src/test/java/org/springframework/jmx/JmxTestBean.java
index d42fbf201b35..b1a773128df8 100644
--- a/spring-context/src/test/java/org/springframework/jmx/JmxTestBean.java
+++ b/spring-context/src/test/java/org/springframework/jmx/JmxTestBean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -138,12 +138,14 @@ public void dontExposeMe() {
 	protected void someProtectedMethod() {
 	}
 
+	@SuppressWarnings("unused")
 	private void somePrivateMethod() {
 	}
 
 	protected void getSomething() {
 	}
 
+	@SuppressWarnings("unused")
 	private void getSomethingElse() {
 	}
 
diff --git a/spring-context/src/test/java/org/springframework/jmx/access/MBeanClientInterceptorTests.java b/spring-context/src/test/java/org/springframework/jmx/access/MBeanClientInterceptorTests.java
index 7842ee328cb2..e1bd521a1df6 100644
--- a/spring-context/src/test/java/org/springframework/jmx/access/MBeanClientInterceptorTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/access/MBeanClientInterceptorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -29,18 +29,23 @@
 import javax.management.remote.JMXConnectorServerFactory;
 import javax.management.remote.JMXServiceURL;
 
-import org.junit.Ignore;
+import org.junit.Test;
 import org.springframework.jmx.AbstractMBeanServerTests;
 import org.springframework.jmx.IJmxTestBean;
 import org.springframework.jmx.JmxException;
 import org.springframework.jmx.JmxTestBean;
 import org.springframework.jmx.export.MBeanExporter;
 import org.springframework.jmx.export.assembler.AbstractReflectiveMBeanInfoAssembler;
+import org.springframework.tests.Assume;
+import org.springframework.tests.TestGroup;
+
+import static org.junit.Assert.*;
 
 /**
  * @author Rob Harrop
  * @author Juergen Hoeller
  * @author Sam Brannen
+ * @author Chris Beams
  */
 public class MBeanClientInterceptorTests extends AbstractMBeanServerTests {
 
@@ -78,6 +83,7 @@ protected IJmxTestBean getProxy() throws Exception {
 		return (IJmxTestBean) factory.getObject();
 	}
 
+	@Test
 	public void testProxyClassIsDifferent() throws Exception {
 		if (!runTests)
 			return;
@@ -85,6 +91,7 @@ public void testProxyClassIsDifferent() throws Exception {
 		assertTrue("The proxy class should be different than the base class", (proxy.getClass() != IJmxTestBean.class));
 	}
 
+	@Test
 	public void testDifferentProxiesSameClass() throws Exception {
 		if (!runTests)
 			return;
@@ -95,6 +102,7 @@ public void testDifferentProxiesSameClass() throws Exception {
 		assertSame("The proxy classes should be the same", proxy1.getClass(), proxy2.getClass());
 	}
 
+	@Test
 	public void testGetAttributeValue() throws Exception {
 		if (!runTests)
 			return;
@@ -103,6 +111,7 @@ public void testGetAttributeValue() throws Exception {
 		assertEquals("The age should be 100", 100, age);
 	}
 
+	@Test
 	public void testSetAttributeValue() throws Exception {
 		if (!runTests)
 			return;
@@ -111,6 +120,7 @@ public void testSetAttributeValue() throws Exception {
 		assertEquals("The name of the bean should have been updated", "Rob Harrop", target.getName());
 	}
 
+	@Test
 	public void testSetAttributeValueWithRuntimeException() throws Exception {
 		if (!runTests)
 			return;
@@ -123,6 +133,7 @@ public void testSetAttributeValueWithRuntimeException() throws Exception {
 		}
 	}
 
+	@Test
 	public void testSetAttributeValueWithCheckedException() throws Exception {
 		if (!runTests)
 			return;
@@ -135,6 +146,7 @@ public void testSetAttributeValueWithCheckedException() throws Exception {
 		}
 	}
 
+	@Test
 	public void testSetAttributeValueWithIOException() throws Exception {
 		if (!runTests)
 			return;
@@ -147,6 +159,7 @@ public void testSetAttributeValueWithIOException() throws Exception {
 		}
 	}
 
+	@Test
 	public void testSetReadOnlyAttribute() throws Exception {
 		if (!runTests)
 			return;
@@ -159,6 +172,7 @@ public void testSetReadOnlyAttribute() throws Exception {
 		}
 	}
 
+	@Test
 	public void testInvokeNoArgs() throws Exception {
 		if (!runTests)
 			return;
@@ -167,6 +181,7 @@ public void testInvokeNoArgs() throws Exception {
 		assertEquals("The operation should return 1", 1, result);
 	}
 
+	@Test
 	public void testInvokeArgs() throws Exception {
 		if (!runTests)
 			return;
@@ -175,6 +190,7 @@ public void testInvokeArgs() throws Exception {
 		assertEquals("The operation should return 3", 3, result);
 	}
 
+	@Test
 	public void testInvokeUnexposedMethodWithException() throws Exception {
 		if (!runTests)
 			return;
@@ -187,19 +203,13 @@ public void testInvokeUnexposedMethodWithException() throws Exception {
 		}
 	}
 
-	// TODO [SPR-8089] Clean up ignored JMX tests.
-	//
-	// @Ignore should have no effect for JUnit 3.8 tests; however, it appears
-	// that tests on the CI server -- as well as those in Eclipse -- do in
-	// fact get ignored. So we leave @Ignore here so that developers can
-	// easily search for ignored tests.
-	//
-	// Once fixed, renamed to test* instead of ignore*.
-	@Ignore("Requires jmxremote_optional.jar; see comments in AbstractMBeanServerTests for details.")
-	public void ignoreTestLazyConnectionToRemote() throws Exception {
+	@Test
+	public void testTestLazyConnectionToRemote() throws Exception {
 		if (!runTests)
 			return;
 
+		Assume.group(TestGroup.JMXMP);
+
 		JMXServiceURL url = new JMXServiceURL("service:jmx:jmxmp://localhost:9876");
 		JMXConnectorServer connector = JMXConnectorServerFactory.newJMXConnectorServer(url, null, getServer());
 
diff --git a/spring-context/src/test/java/org/springframework/jmx/access/RemoteMBeanClientInterceptorTestsIgnore.java b/spring-context/src/test/java/org/springframework/jmx/access/RemoteMBeanClientInterceptorTests.java
similarity index 75%
rename from spring-context/src/test/java/org/springframework/jmx/access/RemoteMBeanClientInterceptorTestsIgnore.java
rename to spring-context/src/test/java/org/springframework/jmx/access/RemoteMBeanClientInterceptorTests.java
index 7082efec132e..74a29b0be018 100644
--- a/spring-context/src/test/java/org/springframework/jmx/access/RemoteMBeanClientInterceptorTestsIgnore.java
+++ b/spring-context/src/test/java/org/springframework/jmx/access/RemoteMBeanClientInterceptorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -26,19 +26,14 @@
 import javax.management.remote.JMXConnectorServerFactory;
 import javax.management.remote.JMXServiceURL;
 
-import org.junit.Ignore;
+import org.springframework.tests.Assume;
+import org.springframework.tests.TestGroup;
 
 /**
  * @author Rob Harrop
+ * @author Chris Beams
  */
-// TODO [SPR-8089] Clean up ignored JMX tests.
-//
-// @Ignore should have no effect for JUnit 3.8 tests; however, it appears
-// that tests on the CI server -- as well as those in Eclipse -- do in
-// fact get ignored. So we leave @Ignore here so that developers can
-// easily search for ignored tests.
-@Ignore("Requires jmxremote_optional.jar; see comments in AbstractMBeanServerTests for details.")
-public class RemoteMBeanClientInterceptorTestsIgnore extends MBeanClientInterceptorTests {
+public class RemoteMBeanClientInterceptorTests extends MBeanClientInterceptorTests {
 
 	private static final String SERVICE_URL = "service:jmx:jmxmp://localhost:9876";
 
@@ -48,6 +43,9 @@ public class RemoteMBeanClientInterceptorTestsIgnore extends MBeanClientIntercep
 
 	@Override
 	public void onSetUp() throws Exception {
+		runTests = false;
+		Assume.group(TestGroup.JMXMP);
+		runTests = true;
 		super.onSetUp();
 		this.connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(getServiceUrl(), null, getServer());
 		try {
@@ -73,8 +71,12 @@ public void tearDown() throws Exception {
 		if (this.connector != null) {
 			this.connector.close();
 		}
-		this.connectorServer.stop();
-		super.tearDown();
+		if (this.connectorServer != null) {
+			this.connectorServer.stop();
+		}
+		if (runTests) {
+			super.tearDown();
+		}
 	}
 
 }
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/CustomEditorConfigurerTests.java b/spring-context/src/test/java/org/springframework/jmx/export/CustomEditorConfigurerTests.java
index 2c71236d78a7..190190111422 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/CustomEditorConfigurerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/CustomEditorConfigurerTests.java
@@ -22,8 +22,11 @@
 
 import javax.management.ObjectName;
 
+import org.junit.Test;
 import org.springframework.jmx.AbstractJmxTests;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
  */
@@ -36,6 +39,7 @@ protected String getApplicationContextPath() {
 		return "org/springframework/jmx/export/customConfigurer.xml";
 	}
 
+	@Test
 	public void testDatesInJmx() throws Exception {
 		// System.out.println(getServer().getClass().getName());
 		ObjectName oname = new ObjectName("bean:name=dateRange");
@@ -47,6 +51,7 @@ public void testDatesInJmx() throws Exception {
 		assertEquals("endDate ", getEndDate(), endJmx);
 	}
 
+	@Test
 	public void testGetDates() throws Exception {
 		DateRange dr = (DateRange) getContext().getBean("dateRange");
 
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/MBeanExporterOperationsTests.java b/spring-context/src/test/java/org/springframework/jmx/export/MBeanExporterOperationsTests.java
index 59740fa0db44..f2bee326688c 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/MBeanExporterOperationsTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/MBeanExporterOperationsTests.java
@@ -28,6 +28,8 @@
 import org.springframework.jmx.export.naming.ObjectNamingStrategy;
 import org.springframework.jmx.support.ObjectNameManager;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
  * @author Juergen Hoeller
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/MBeanExporterTests.java b/spring-context/src/test/java/org/springframework/jmx/export/MBeanExporterTests.java
index 2d7d9e26398d..c08a9f73b2f7 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/MBeanExporterTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/MBeanExporterTests.java
@@ -33,6 +33,7 @@
 import javax.management.ObjectName;
 import javax.management.modelmbean.ModelMBeanInfo;
 
+import org.junit.Test;
 import org.springframework.aop.framework.ProxyFactory;
 import org.springframework.beans.factory.support.BeanDefinitionBuilder;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
@@ -50,6 +51,8 @@
 import org.springframework.tests.aop.interceptor.NopInterceptor;
 import org.springframework.tests.sample.beans.TestBean;
 
+import static org.junit.Assert.*;
+
 /**
  * Integration tests for the {@link MBeanExporter} class.
  *
@@ -66,6 +69,7 @@ public final class MBeanExporterTests extends AbstractMBeanServerTests {
 	private static final String OBJECT_NAME = "spring:test=jmxMBeanAdaptor";
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNonNotificationListenerType() throws Exception {
 		Map listeners = new HashMap();
 		// put a non-NotificationListener instance in as a value...
@@ -80,6 +84,7 @@ public void testRegisterNonNotificationListenerType() throws Exception {
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNullNotificationListenerType() throws Exception {
 		Map listeners = new HashMap();
 		// put null in as a value...
@@ -94,6 +99,7 @@ public void testRegisterNullNotificationListenerType() throws Exception {
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNotificationListenerForNonExistentMBean() throws Exception {
 		Map listeners = new HashMap();
 		NotificationListener dummyListener = new NotificationListener() {
@@ -117,6 +123,7 @@ public void handleNotification(Notification notification, Object handback) {
 		}
 	}
 
+	@Test
 	public void testWithSuppliedMBeanServer() throws Exception {
 		MBeanExporter exporter = new MBeanExporter();
 		exporter.setBeans(getBeanMap());
@@ -127,6 +134,7 @@ public void testWithSuppliedMBeanServer() throws Exception {
 	}
 
 	/** Fails if JVM platform MBean server has been started already
+	@Test
 	public void testWithLocatedMBeanServer() throws Exception {
 		MBeanExporter adaptor = new MBeanExporter();
 		adaptor.setBeans(getBeanMap());
@@ -136,6 +144,7 @@ public void testWithLocatedMBeanServer() throws Exception {
 	}
 	*/
 
+	@Test
 	public void testUserCreatedMBeanRegWithDynamicMBean() throws Exception {
 		Map<String, Object> map = new HashMap<String, Object>();
 		map.put("spring:name=dynBean", new TestDynamicMBean());
@@ -153,6 +162,7 @@ public void testUserCreatedMBeanRegWithDynamicMBean() throws Exception {
 		assertFalse("Assembler should not have been invoked", asm.invoked);
 	}
 
+	@Test
 	public void testAutodetectMBeans() throws Exception {
 		DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(bf).loadBeanDefinitions(new ClassPathResource("autodetectMBeans.xml", getClass()));
@@ -170,6 +180,7 @@ public void testAutodetectMBeans() throws Exception {
 		}
 	}
 
+	@Test
 	public void testAutodetectWithExclude() throws Exception {
 		DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(bf).loadBeanDefinitions(new ClassPathResource("autodetectMBeans.xml", getClass()));
@@ -189,6 +200,7 @@ public void testAutodetectWithExclude() throws Exception {
 		}
 	}
 
+	@Test
 	public void testAutodetectLazyMBeans() throws Exception {
 		DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(bf).loadBeanDefinitions(new ClassPathResource("autodetectLazyMBeans.xml", getClass()));
@@ -210,6 +222,7 @@ public void testAutodetectLazyMBeans() throws Exception {
 		}
 	}
 
+	@Test
 	public void testAutodetectNoMBeans() throws Exception {
 		DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
 		new XmlBeanDefinitionReader(bf).loadBeanDefinitions(new ClassPathResource("autodetectNoMBeans.xml", getClass()));
@@ -220,6 +233,7 @@ public void testAutodetectNoMBeans() throws Exception {
 		}
 	}
 
+	@Test
 	public void testWithMBeanExporterListeners() throws Exception {
 		MockMBeanExporterListener listener1 = new MockMBeanExporterListener();
 		MockMBeanExporterListener listener2 = new MockMBeanExporterListener();
@@ -235,6 +249,7 @@ public void testWithMBeanExporterListeners() throws Exception {
 		assertListener(listener2);
 	}
 
+	@Test
 	public void testExportJdkProxy() throws Exception {
 		JmxTestBean bean = new JmxTestBean();
 		bean.setName("Rob Harrop");
@@ -260,6 +275,7 @@ public void testExportJdkProxy() throws Exception {
 		assertEquals("Rob Harrop", nameValue);
 	}
 
+	@Test
 	public void testSelfNaming() throws Exception {
 		ObjectName objectName = ObjectNameManager.getInstance(OBJECT_NAME);
 		SelfNamingTestBean testBean = new SelfNamingTestBean();
@@ -278,6 +294,7 @@ public void testSelfNaming() throws Exception {
 		assertNotNull(instance);
 	}
 
+	@Test
 	public void testRegisterIgnoreExisting() throws Exception {
 		ObjectName objectName = ObjectNameManager.getInstance(OBJECT_NAME);
 
@@ -311,6 +328,7 @@ public void testRegisterIgnoreExisting() throws Exception {
 		assertEquals("Rob Harrop", server.getAttribute(objectName, "Name"));
 	}
 
+	@Test
 	public void testRegisterReplaceExisting() throws Exception {
 		ObjectName objectName = ObjectNameManager.getInstance(OBJECT_NAME);
 
@@ -339,6 +357,7 @@ public void testRegisterReplaceExisting() throws Exception {
 		assertEquals("Sally Greenwood", server.getAttribute(objectName, "Name"));
 	}
 
+	@Test
 	public void testWithExposeClassLoader() throws Exception {
 		String name = "Rob Harrop";
 		String otherName = "Juergen Hoeller";
@@ -368,6 +387,7 @@ public void testWithExposeClassLoader() throws Exception {
 		assertEquals("Incorrect updated name.", otherName, bean.getName());
 	}
 
+	@Test
 	public void testBonaFideMBeanIsNotExportedWhenAutodetectIsTotallyTurnedOff() throws Exception {
 		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(Person.class);
 		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
@@ -386,6 +406,7 @@ public void testBonaFideMBeanIsNotExportedWhenAutodetectIsTotallyTurnedOff() thr
 		exporter.afterPropertiesSet();
 	}
 
+	@Test
 	public void testOnlyBonaFideMBeanIsExportedWhenAutodetectIsMBeanOnly() throws Exception {
 		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(Person.class);
 		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
@@ -405,6 +426,7 @@ public void testOnlyBonaFideMBeanIsExportedWhenAutodetectIsMBeanOnly() throws Ex
 				ObjectNameManager.getInstance(exportedBeanName));
 	}
 
+	@Test
 	public void testBonaFideMBeanAndRegularBeanExporterWithAutodetectAll() throws Exception {
 		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(Person.class);
 		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
@@ -428,6 +450,7 @@ public void testBonaFideMBeanAndRegularBeanExporterWithAutodetectAll() throws Ex
 				ObjectNameManager.getInstance(notToBeExportedBeanName));
 	}
 
+	@Test
 	public void testBonaFideMBeanIsNotExportedWithAutodetectAssembler() throws Exception {
 		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(Person.class);
 		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
@@ -450,6 +473,7 @@ public void testBonaFideMBeanIsNotExportedWithAutodetectAssembler() throws Excep
 	/**
 	 * Want to ensure that said MBean is not exported twice.
 	 */
+	@Test
 	public void testBonaFideMBeanExplicitlyExportedAndAutodetectionIsOn() throws Exception {
 		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(Person.class);
 		DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
@@ -468,6 +492,7 @@ public void testBonaFideMBeanExplicitlyExportedAndAutodetectionIsOn() throws Exc
 				ObjectNameManager.getInstance(OBJECT_NAME));
 	}
 
+	@Test
 	public void testSetAutodetectModeToOutOfRangeNegativeValue() throws Exception {
 		try {
 			MBeanExporter exporter = new MBeanExporter();
@@ -478,6 +503,7 @@ public void testSetAutodetectModeToOutOfRangeNegativeValue() throws Exception {
 		}
 	}
 
+	@Test
 	public void testSetAutodetectModeToOutOfRangePositiveValue() throws Exception {
 		try {
 			MBeanExporter exporter = new MBeanExporter();
@@ -488,6 +514,7 @@ public void testSetAutodetectModeToOutOfRangePositiveValue() throws Exception {
 		}
 	}
 
+	@Test
 	public void testSetAutodetectModeNameToNull() throws Exception {
 		try {
 			MBeanExporter exporter = new MBeanExporter();
@@ -498,6 +525,7 @@ public void testSetAutodetectModeNameToNull() throws Exception {
 		}
 	}
 
+	@Test
 	public void testSetAutodetectModeNameToAnEmptyString() throws Exception {
 		try {
 			MBeanExporter exporter = new MBeanExporter();
@@ -508,6 +536,7 @@ public void testSetAutodetectModeNameToAnEmptyString() throws Exception {
 		}
 	}
 
+	@Test
 	public void testSetAutodetectModeNameToAWhitespacedString() throws Exception {
 		try {
 			MBeanExporter exporter = new MBeanExporter();
@@ -518,6 +547,7 @@ public void testSetAutodetectModeNameToAWhitespacedString() throws Exception {
 		}
 	}
 
+	@Test
 	public void testSetAutodetectModeNameToARubbishValue() throws Exception {
 		try {
 			MBeanExporter exporter = new MBeanExporter();
@@ -528,6 +558,7 @@ public void testSetAutodetectModeNameToARubbishValue() throws Exception {
 		}
 	}
 
+	@Test
 	public void testNotRunningInBeanFactoryAndPassedBeanNameToExport() throws Exception {
 		try {
 			MBeanExporter exporter = new MBeanExporter();
@@ -541,6 +572,7 @@ public void testNotRunningInBeanFactoryAndPassedBeanNameToExport() throws Except
 		}
 	}
 
+	@Test
 	public void testNotRunningInBeanFactoryAndAutodetectionIsOn() throws Exception {
 		try {
 			MBeanExporter exporter = new MBeanExporter();
@@ -555,6 +587,7 @@ public void testNotRunningInBeanFactoryAndAutodetectionIsOn() throws Exception {
 	/**
 	 * SPR-2158
 	 */
+	@Test
 	public void testMBeanIsNotUnregisteredSpuriouslyIfSomeExternalProcessHasUnregisteredMBean() throws Exception {
 		MBeanExporter exporter = new MBeanExporter();
 		exporter.setBeans(getBeanMap());
@@ -574,6 +607,7 @@ public void testMBeanIsNotUnregisteredSpuriouslyIfSomeExternalProcessHasUnregist
 	/**
 	 * SPR-3302
 	 */
+	@Test
 	public void testBeanNameCanBeUsedInNotificationListenersMap() throws Exception {
 		String beanName = "charlesDexterWard";
 		BeanDefinitionBuilder testBean = BeanDefinitionBuilder.rootBeanDefinition(JmxTestBean.class);
@@ -595,6 +629,7 @@ public void testBeanNameCanBeUsedInNotificationListenersMap() throws Exception {
 		exporter.afterPropertiesSet();
 	}
 
+	@Test
 	public void testWildcardCanBeUsedInNotificationListenersMap() throws Exception {
 		String beanName = "charlesDexterWard";
 		BeanDefinitionBuilder testBean = BeanDefinitionBuilder.rootBeanDefinition(JmxTestBean.class);
@@ -619,6 +654,7 @@ public void testWildcardCanBeUsedInNotificationListenersMap() throws Exception {
 	/*
 	 * SPR-3625
 	 */
+	@Test
 	public void testMBeanIsUnregisteredForRuntimeExceptionDuringInitialization() throws Exception {
 		BeanDefinitionBuilder builder1 = BeanDefinitionBuilder.rootBeanDefinition(Person.class);
 		BeanDefinitionBuilder builder2 = BeanDefinitionBuilder
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/NotificationListenerTests.java b/spring-context/src/test/java/org/springframework/jmx/export/NotificationListenerTests.java
index 45244123079c..a6423dcee8db 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/NotificationListenerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/NotificationListenerTests.java
@@ -26,6 +26,7 @@
 import javax.management.NotificationListener;
 import javax.management.ObjectName;
 
+import org.junit.Test;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
 import org.springframework.jmx.AbstractMBeanServerTests;
 import org.springframework.jmx.JmxTestBean;
@@ -33,6 +34,8 @@
 import org.springframework.jmx.export.naming.SelfNaming;
 import org.springframework.jmx.support.ObjectNameManager;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
  * @author Mark Fisher
@@ -41,6 +44,7 @@
 public class NotificationListenerTests extends AbstractMBeanServerTests {
 
 	@SuppressWarnings({"rawtypes", "unchecked"})
+	@Test
 	public void testRegisterNotificationListenerForMBean() throws Exception {
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
 		JmxTestBean bean = new JmxTestBean();
@@ -66,6 +70,7 @@ public void testRegisterNotificationListenerForMBean() throws Exception {
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNotificationListenerWithWildcard() throws Exception {
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
 		JmxTestBean bean = new JmxTestBean();
@@ -90,6 +95,7 @@ public void testRegisterNotificationListenerWithWildcard() throws Exception {
 		assertEquals("Listener not notified", 1, listener.getCount(attributeName));
 	}
 
+	@Test
 	public void testRegisterNotificationListenerWithHandback() throws Exception {
 		String objectName = "spring:name=Test";
 		JmxTestBean bean = new JmxTestBean();
@@ -120,6 +126,7 @@ public void testRegisterNotificationListenerWithHandback() throws Exception {
 		assertEquals("Handback object not transmitted correctly", handback, listener.getLastHandback(attributeName));
 	}
 
+	@Test
 	public void testRegisterNotificationListenerForAllMBeans() throws Exception {
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
 		JmxTestBean bean = new JmxTestBean();
@@ -146,6 +153,7 @@ public void testRegisterNotificationListenerForAllMBeans() throws Exception {
 	}
 
 	@SuppressWarnings("serial")
+	@Test
 	public void testRegisterNotificationListenerWithFilter() throws Exception {
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
 		JmxTestBean bean = new JmxTestBean();
@@ -186,6 +194,7 @@ public boolean isNotificationEnabled(Notification notification) {
 		assertEquals("Listener incorrectly notified for Age", 0, listener.getCount(ageAttribute));
 	}
 
+	@Test
 	public void testCreationWithNoNotificationListenerSet() {
 		try {
 			new NotificationListenerBean().afterPropertiesSet();
@@ -195,6 +204,7 @@ public void testCreationWithNoNotificationListenerSet() {
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNotificationListenerWithBeanNameAndBeanNameInBeansMap() throws Exception {
 		String beanName = "testBean";
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
@@ -225,6 +235,7 @@ public void testRegisterNotificationListenerWithBeanNameAndBeanNameInBeansMap()
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNotificationListenerWithBeanNameAndBeanInstanceInBeansMap() throws Exception {
 		String beanName = "testBean";
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
@@ -255,6 +266,7 @@ public void testRegisterNotificationListenerWithBeanNameAndBeanInstanceInBeansMa
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNotificationListenerWithBeanNameBeforeObjectNameMappedToSameBeanInstance() throws Exception {
 		String beanName = "testBean";
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
@@ -286,6 +298,7 @@ public void testRegisterNotificationListenerWithBeanNameBeforeObjectNameMappedTo
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNotificationListenerWithObjectNameBeforeBeanNameMappedToSameBeanInstance() throws Exception {
 		String beanName = "testBean";
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
@@ -317,6 +330,7 @@ public void testRegisterNotificationListenerWithObjectNameBeforeBeanNameMappedTo
 	}
 
 	@SuppressWarnings({ "rawtypes", "unchecked" })
+	@Test
 	public void testRegisterNotificationListenerWithTwoBeanNamesMappedToDifferentBeanInstances() throws Exception {
 		String beanName1 = "testBean1";
 		String beanName2 = "testBean2";
@@ -359,6 +373,7 @@ public void testRegisterNotificationListenerWithTwoBeanNamesMappedToDifferentBea
 		assertEquals("Listener not notified for testBean2", 2, listener.getCount("Age"));
 	}
 
+	@Test
 	public void testNotificationListenerRegistrar() throws Exception {
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
 		JmxTestBean bean = new JmxTestBean();
@@ -391,6 +406,7 @@ public void testNotificationListenerRegistrar() throws Exception {
 		assertEquals("Listener notified after destruction", 1, listener.getCount(attributeName));
 	}
 
+	@Test
 	public void testNotificationListenerRegistrarWithMultipleNames() throws Exception {
 		ObjectName objectName = ObjectName.getInstance("spring:name=Test");
 		ObjectName objectName2 = ObjectName.getInstance("spring:name=Test2");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/NotificationPublisherTests.java b/spring-context/src/test/java/org/springframework/jmx/export/NotificationPublisherTests.java
index a6abda7ed2ef..2237fcc15533 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/NotificationPublisherTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/NotificationPublisherTests.java
@@ -32,12 +32,15 @@
 import javax.management.NotificationListener;
 import javax.management.ReflectionException;
 
+import org.junit.Test;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.jmx.AbstractMBeanServerTests;
 import org.springframework.jmx.export.notification.NotificationPublisher;
 import org.springframework.jmx.export.notification.NotificationPublisherAware;
 import org.springframework.jmx.support.ObjectNameManager;
 
+import static org.junit.Assert.*;
+
 /**
  * Integration tests for the Spring JMX {@link NotificationPublisher} functionality.
  *
@@ -48,6 +51,7 @@ public class NotificationPublisherTests extends AbstractMBeanServerTests {
 
 	private CountingNotificationListener listener = new CountingNotificationListener();
 
+	@Test
 	public void testSimpleBean() throws Exception {
 		// start the MBeanExporter
 		ConfigurableApplicationContext ctx = loadContext("org/springframework/jmx/export/notificationPublisherTests.xml");
@@ -60,6 +64,7 @@ public void testSimpleBean() throws Exception {
 		assertEquals("Notification not sent", 1, listener.count);
 	}
 
+	@Test
 	public void testSimpleBeanRegisteredManually() throws Exception {
 		// start the MBeanExporter
 		ConfigurableApplicationContext ctx = loadContext("org/springframework/jmx/export/notificationPublisherTests.xml");
@@ -74,6 +79,7 @@ public void testSimpleBeanRegisteredManually() throws Exception {
 		assertEquals("Notification not sent", 1, listener.count);
 	}
 
+	@Test
 	public void testMBean() throws Exception {
 		// start the MBeanExporter
 		ConfigurableApplicationContext ctx = loadContext("org/springframework/jmx/export/notificationPublisherTests.xml");
@@ -86,6 +92,7 @@ public void testMBean() throws Exception {
 	}
 
 	/*
+	@Test
 	public void testStandardMBean() throws Exception {
 		// start the MBeanExporter
 		ApplicationContext ctx = new ClassPathXmlApplicationContext("org/springframework/jmx/export/notificationPublisherTests.xml");
@@ -97,6 +104,7 @@ public void testStandardMBean() throws Exception {
 	}
 	*/
 
+	@Test
 	public void testLazyInit() throws Exception {
 		// start the MBeanExporter
 		ConfigurableApplicationContext ctx = loadContext("org/springframework/jmx/export/notificationPublisherLazyTests.xml");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/PropertyPlaceholderConfigurerTests.java b/spring-context/src/test/java/org/springframework/jmx/export/PropertyPlaceholderConfigurerTests.java
index c95000c59da2..256372eb1bfd 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/PropertyPlaceholderConfigurerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/PropertyPlaceholderConfigurerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -18,11 +18,15 @@
 
 import javax.management.ObjectName;
 
+import org.junit.Test;
 import org.springframework.jmx.AbstractJmxTests;
 import org.springframework.jmx.IJmxTestBean;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
+ * @author Chris Beams
  */
 public class PropertyPlaceholderConfigurerTests extends AbstractJmxTests {
 
@@ -31,6 +35,7 @@ protected String getApplicationContextPath() {
 		return "org/springframework/jmx/export/propertyPlaceholderConfigurer.xml";
 	}
 
+	@Test
 	public void testPropertiesReplaced() {
 		IJmxTestBean bean = (IJmxTestBean) getContext().getBean("testBean");
 
@@ -38,6 +43,7 @@ public void testPropertiesReplaced() {
 		assertEquals("Age is incorrect", 100, bean.getAge());
 	}
 
+	@Test
 	public void testPropertiesCorrectInJmx() throws Exception {
 		ObjectName oname = new ObjectName("bean:name=proxyTestBean1");
 		Object name = getServer().getAttribute(oname, "Name");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/annotation/AnnotationMetadataAssemblerTests.java b/spring-context/src/test/java/org/springframework/jmx/export/annotation/AnnotationMetadataAssemblerTests.java
index d74787b7f81f..11c68dcb99fb 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/annotation/AnnotationMetadataAssemblerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/annotation/AnnotationMetadataAssemblerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -20,15 +20,22 @@
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanOperationInfo;
 
+import org.junit.Test;
 import org.springframework.jmx.IJmxTestBean;
 import org.springframework.jmx.export.assembler.AbstractMetadataAssemblerTests;
 import org.springframework.jmx.export.metadata.JmxAttributeSource;
 
-/** @author Rob Harrop */
+import static org.junit.Assert.*;
+
+/**
+ * @author Rob Harrop
+ * @author Chris Beams
+ */
 public class AnnotationMetadataAssemblerTests extends AbstractMetadataAssemblerTests {
 
 	private static final String OBJECT_NAME = "bean:name=testBean4";
 
+	@Test
 	public void testAttributeFromInterface() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = inf.getAttribute("Colour");
@@ -36,12 +43,14 @@ public void testAttributeFromInterface() throws Exception {
 		assertTrue("The name attribute should be readable", attr.isReadable());
 	}
 
+	@Test
 	public void testOperationFromInterface() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanOperationInfo op = inf.getOperation("fromInterface");
 		assertNotNull(op);
 	}
 
+	@Test
 	public void testOperationOnGetter() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanOperationInfo op = inf.getOperation("getExpensiveToCalculate");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/AbstractJmxAssemblerTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/AbstractJmxAssemblerTests.java
index 59b71a58b27d..42962c5f6426 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/AbstractJmxAssemblerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/AbstractJmxAssemblerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -28,12 +28,16 @@
 import javax.management.modelmbean.ModelMBeanInfo;
 import javax.management.modelmbean.ModelMBeanOperationInfo;
 
+import org.junit.Test;
 import org.springframework.jmx.AbstractJmxTests;
 import org.springframework.jmx.IJmxTestBean;
 import org.springframework.jmx.support.ObjectNameManager;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
+ * @author Chris Beams
  */
 public abstract class AbstractJmxAssemblerTests extends AbstractJmxTests {
 
@@ -43,31 +47,38 @@ public abstract class AbstractJmxAssemblerTests extends AbstractJmxTests {
 
 	protected abstract String getObjectName();
 
+	@Test
 	public void testMBeanRegistration() throws Exception {
 		// beans are registered at this point - just grab them from the server
 		ObjectInstance instance = getObjectInstance();
 		assertNotNull("Bean should not be null", instance);
 	}
 
+	@Test
 	public void testRegisterOperations() throws Exception {
 		IJmxTestBean bean = getBean();
+		assertNotNull(bean);
 		MBeanInfo inf = getMBeanInfo();
 		assertEquals("Incorrect number of operations registered",
 				getExpectedOperationCount(), inf.getOperations().length);
 	}
 
+	@Test
 	public void testRegisterAttributes() throws Exception {
 		IJmxTestBean bean = getBean();
+		assertNotNull(bean);
 		MBeanInfo inf = getMBeanInfo();
 		assertEquals("Incorrect number of attributes registered",
 				getExpectedAttributeCount(), inf.getAttributes().length);
 	}
 
+	@Test
 	public void testGetMBeanInfo() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		assertNotNull("MBeanInfo should not be null", info);
 	}
 
+	@Test
 	public void testGetMBeanAttributeInfo() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		MBeanAttributeInfo[] inf = info.getAttributes();
@@ -82,6 +93,7 @@ public void testGetMBeanAttributeInfo() throws Exception {
 		}
 	}
 
+	@Test
 	public void testGetMBeanOperationInfo() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		MBeanOperationInfo[] inf = info.getOperations();
@@ -96,6 +108,7 @@ public void testGetMBeanOperationInfo() throws Exception {
 		}
 	}
 
+	@Test
 	public void testDescriptionNotNull() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 
@@ -103,6 +116,7 @@ public void testDescriptionNotNull() throws Exception {
 				info.getDescription());
 	}
 
+	@Test
 	public void testSetAttribute() throws Exception {
 		ObjectName objectName = ObjectNameManager.getInstance(getObjectName());
 		getServer().setAttribute(objectName, new Attribute(NAME_ATTRIBUTE, "Rob Harrop"));
@@ -110,6 +124,7 @@ public void testSetAttribute() throws Exception {
 		assertEquals("Rob Harrop", bean.getName());
 	}
 
+	@Test
 	public void testGetAttribute() throws Exception {
 		ObjectName objectName = ObjectNameManager.getInstance(getObjectName());
 		getBean().setName("John Smith");
@@ -117,6 +132,7 @@ public void testGetAttribute() throws Exception {
 		assertEquals("Incorrect result", "John Smith", val);
 	}
 
+	@Test
 	public void testOperationInvocation() throws Exception{
 		ObjectName objectName = ObjectNameManager.getInstance(getObjectName());
 		Object result = getServer().invoke(objectName, "add",
@@ -124,6 +140,7 @@ public void testOperationInvocation() throws Exception{
 	assertEquals("Incorrect result", new Integer(50), result);
 	}
 
+	@Test
 	public void testAttributeInfoHasDescriptors() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 
@@ -139,6 +156,7 @@ public void testAttributeInfoHasDescriptors() throws Exception {
 				desc.getFieldValue("setMethod"));
 	}
 
+	@Test
 	public void testAttributeHasCorrespondingOperations() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 
@@ -157,6 +175,7 @@ public void testAttributeHasCorrespondingOperations() throws Exception {
 		assertEquals("set operation should have role \"setter\"", "setter", set.getDescriptor().getFieldValue("role"));
 	}
 
+	@Test
 	public void testNotificationMetadata() throws Exception {
 		ModelMBeanInfo info = (ModelMBeanInfo) getMBeanInfo();
 		MBeanNotificationInfo[] notifications = info.getNotifications();
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/AbstractMetadataAssemblerTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/AbstractMetadataAssemblerTests.java
index 99cefe715835..0c3ece78395f 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/AbstractMetadataAssemblerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/AbstractMetadataAssemblerTests.java
@@ -26,6 +26,7 @@
 import javax.management.modelmbean.ModelMBeanInfo;
 import javax.management.modelmbean.ModelMBeanOperationInfo;
 
+import org.junit.Test;
 import org.springframework.aop.framework.ProxyFactory;
 import org.springframework.jmx.IJmxTestBean;
 import org.springframework.jmx.JmxTestBean;
@@ -34,6 +35,8 @@
 import org.springframework.jmx.support.ObjectNameManager;
 import org.springframework.tests.aop.interceptor.NopInterceptor;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
  * @author Chris Beams
@@ -44,12 +47,14 @@ public abstract class AbstractMetadataAssemblerTests extends AbstractJmxAssemble
 
 	protected static final String CACHE_ENTRIES_METRIC = "CacheEntries";
 
+	@Test
 	public void testDescription() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		assertEquals("The descriptions are not the same", "My Managed Bean",
 				info.getDescription());
 	}
 
+	@Test
 	public void testAttributeDescriptionOnSetter() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = inf.getAttribute(AGE_ATTRIBUTE);
@@ -57,6 +62,7 @@ public void testAttributeDescriptionOnSetter() throws Exception {
 				"The Age Attribute", attr.getDescription());
 	}
 
+	@Test
 	public void testAttributeDescriptionOnGetter() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = inf.getAttribute(NAME_ATTRIBUTE);
@@ -67,12 +73,14 @@ public void testAttributeDescriptionOnGetter() throws Exception {
 	/**
 	 * Tests the situation where the attribute is only defined on the getter.
 	 */
+	@Test
 	public void testReadOnlyAttribute() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = inf.getAttribute(AGE_ATTRIBUTE);
 		assertFalse("The age attribute should not be writable", attr.isWritable());
 	}
 
+	@Test
 	public void testReadWriteAttribute() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = inf.getAttribute(NAME_ATTRIBUTE);
@@ -83,6 +91,7 @@ public void testReadWriteAttribute() throws Exception {
 	/**
 	 * Tests the situation where the property only has a getter.
 	 */
+	@Test
 	public void testWithOnlySetter() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = inf.getAttribute("NickName");
@@ -92,12 +101,14 @@ public void testWithOnlySetter() throws Exception {
 	/**
 	 * Tests the situation where the property only has a setter.
 	 */
+	@Test
 	public void testWithOnlyGetter() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute("Superman");
 		assertNotNull("Attribute should not be null", attr);
 	}
 
+	@Test
 	public void testManagedResourceDescriptor() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		Descriptor desc = info.getMBeanDescriptor();
@@ -111,6 +122,7 @@ public void testManagedResourceDescriptor() throws Exception {
 		assertEquals("Persist Name should be bar", "bar.jmx", desc.getFieldValue("persistName"));
 	}
 
+	@Test
 	public void testAttributeDescriptor() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		Descriptor desc = info.getAttribute(NAME_ATTRIBUTE).getDescriptor();
@@ -121,6 +133,7 @@ public void testAttributeDescriptor() throws Exception {
 		assertEquals("Persist Period should be 300", "300", desc.getFieldValue("persistPeriod"));
 	}
 
+	@Test
 	public void testOperationDescriptor() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		Descriptor desc = info.getOperation("myOperation").getDescriptor();
@@ -129,6 +142,7 @@ public void testOperationDescriptor() throws Exception {
 		assertEquals("Role should be \"operation\"", "operation", desc.getFieldValue("role"));
 	}
 
+	@Test
 	public void testOperationParameterMetadata() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanOperationInfo oper = info.getOperation("add");
@@ -142,6 +156,7 @@ public void testOperationParameterMetadata() throws Exception {
 		assertEquals("Incorrect type for y param", int.class.getName(), params[1].getType());
 	}
 
+	@Test
 	public void testWithCglibProxy() throws Exception {
 		IJmxTestBean tb = createJmxTestBean();
 		ProxyFactory pf = new ProxyFactory();
@@ -169,6 +184,7 @@ public void testWithCglibProxy() throws Exception {
 		assertTrue("Not included in autodetection", assembler.includeBean(proxy.getClass(), "some bean name"));
 	}
 
+	@Test
 	public void testMetricDescription() throws Exception {
 		ModelMBeanInfo inf = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo metric = inf.getAttribute(QUEUE_SIZE_METRIC);
@@ -179,6 +195,7 @@ public void testMetricDescription() throws Exception {
 				"The QueueSize metric", operation.getDescription());
 	}
 
+	@Test
 	public void testMetricDescriptor() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		Descriptor desc = info.getAttribute(QUEUE_SIZE_METRIC).getDescriptor();
@@ -191,6 +208,7 @@ public void testMetricDescriptor() throws Exception {
 		assertEquals("Metric Category should be utilization", "utilization",desc.getFieldValue("metricCategory"));
 	}
 
+	@Test
 	public void testMetricDescriptorDefaults() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		Descriptor desc = info.getAttribute(CACHE_ENTRIES_METRIC).getDescriptor();
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/InterfaceBasedMBeanInfoAssemblerCustomTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/InterfaceBasedMBeanInfoAssemblerCustomTests.java
index d4034ed4494c..e7bb1d68c9e5 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/InterfaceBasedMBeanInfoAssemblerCustomTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/InterfaceBasedMBeanInfoAssemblerCustomTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -19,8 +19,13 @@
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanInfo;
 
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
+ * @author Chris Beams
  */
 public class InterfaceBasedMBeanInfoAssemblerCustomTests extends AbstractJmxAssemblerTests {
 
@@ -48,6 +53,7 @@ protected MBeanInfoAssembler getAssembler() {
 		return assembler;
 	}
 
+	@Test
 	public void testGetAgeIsReadOnly() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute(AGE_ATTRIBUTE);
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/InterfaceBasedMBeanInfoAssemblerMappedTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/InterfaceBasedMBeanInfoAssemblerMappedTests.java
index dc9db0fc5e2b..1a485f377e6e 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/InterfaceBasedMBeanInfoAssemblerMappedTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/InterfaceBasedMBeanInfoAssemblerMappedTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,13 +22,19 @@
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanInfo;
 
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
+ * @author Chris Beams
  */
 public class InterfaceBasedMBeanInfoAssemblerMappedTests extends AbstractJmxAssemblerTests {
 
 	protected static final String OBJECT_NAME = "bean:name=testBean4";
 
+	@Test
 	public void testGetAgeIsReadOnly() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute(AGE_ATTRIBUTE);
@@ -37,9 +43,10 @@ public void testGetAgeIsReadOnly() throws Exception {
 		assertFalse("Age is not writable", attr.isWritable());
 	}
 
+	@Test
 	public void testWithUnknownClass() throws Exception {
 		try {
-			InterfaceBasedMBeanInfoAssembler assembler = getWithMapping("com.foo.bar.Unknown");
+			getWithMapping("com.foo.bar.Unknown");
 			fail("Should have thrown IllegalArgumentException");
 		}
 		catch (IllegalArgumentException ex) {
@@ -47,9 +54,10 @@ public void testWithUnknownClass() throws Exception {
 		}
 	}
 
+	@Test
 	public void testWithNonInterface() throws Exception {
 		try {
-			InterfaceBasedMBeanInfoAssembler assembler = getWithMapping("JmxTestBean");
+			getWithMapping("JmxTestBean");
 			fail("Should have thrown IllegalArgumentException");
 		}
 		catch (IllegalArgumentException ex) {
@@ -57,7 +65,8 @@ public void testWithNonInterface() throws Exception {
 		}
 	}
 
-	public void ignoreTestWithFallThrough() throws Exception {
+	@Test
+	public void testWithFallThrough() throws Exception {
 		InterfaceBasedMBeanInfoAssembler assembler =
 				getWithMapping("foobar", "org.springframework.jmx.export.assembler.ICustomJmxBean");
 		assembler.setManagedInterfaces(new Class<?>[] {IAdditionalTestMethods.class});
@@ -68,6 +77,7 @@ public void ignoreTestWithFallThrough() throws Exception {
 		assertNickName(attr);
 	}
 
+	@Test
 	public void testNickNameIsExposed() throws Exception {
 		ModelMBeanInfo inf = (ModelMBeanInfo) getMBeanInfo();
 		MBeanAttributeInfo attr = inf.getAttribute("NickName");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerComboTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerComboTests.java
index 2c2a8618eb12..ea234b09e8ca 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerComboTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerComboTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,14 +22,20 @@
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanInfo;
 
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
 /**
  * @author Juergen Hoeller
  * @author Rob Harrop
+ * @author Chris Beams
  */
 public class MethodExclusionMBeanInfoAssemblerComboTests extends AbstractJmxAssemblerTests {
 
 	protected static final String OBJECT_NAME = "bean:name=testBean4";
 
+	@Test
 	public void testGetAgeIsReadOnly() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute(AGE_ATTRIBUTE);
@@ -37,6 +43,7 @@ public void testGetAgeIsReadOnly() throws Exception {
 		assertFalse("Age is not writable", attr.isWritable());
 	}
 
+	@Test
 	public void testNickNameIsExposed() throws Exception {
 		ModelMBeanInfo inf = (ModelMBeanInfo) getMBeanInfo();
 		MBeanAttributeInfo attr = inf.getAttribute("NickName");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerMappedTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerMappedTests.java
index 35fe1082703b..aa1e2d57c227 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerMappedTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerMappedTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,13 +22,19 @@
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanInfo;
 
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
+ * @author Chris Beams
  */
 public class MethodExclusionMBeanInfoAssemblerMappedTests extends AbstractJmxAssemblerTests {
 
 	protected static final String OBJECT_NAME = "bean:name=testBean4";
 
+	@Test
 	public void testGetAgeIsReadOnly() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute(AGE_ATTRIBUTE);
@@ -36,6 +42,7 @@ public void testGetAgeIsReadOnly() throws Exception {
 		assertFalse("Age is not writable", attr.isWritable());
 	}
 
+	@Test
 	public void testNickNameIsExposed() throws Exception {
 		ModelMBeanInfo inf = (ModelMBeanInfo) getMBeanInfo();
 		MBeanAttributeInfo attr = inf.getAttribute("NickName");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerNotMappedTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerNotMappedTests.java
index f037d87bcb7d..6b12c74d971f 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerNotMappedTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerNotMappedTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,14 +22,20 @@
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanInfo;
 
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
 /**
  * @author Juergen Hoeller
  * @author Rob Harrop
+ * @author Chris Beams
  */
 public class MethodExclusionMBeanInfoAssemblerNotMappedTests extends AbstractJmxAssemblerTests {
 
 	protected static final String OBJECT_NAME = "bean:name=testBean4";
 
+	@Test
 	public void testGetAgeIsReadOnly() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute(AGE_ATTRIBUTE);
@@ -37,6 +43,7 @@ public void testGetAgeIsReadOnly() throws Exception {
 		assertTrue("Age is not writable", attr.isWritable());
 	}
 
+	@Test
 	public void testNickNameIsExposed() throws Exception {
 		ModelMBeanInfo inf = (ModelMBeanInfo) getMBeanInfo();
 		MBeanAttributeInfo attr = inf.getAttribute("NickName");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerTests.java
index 8a4929300664..53335e50d70f 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodExclusionMBeanInfoAssemblerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,11 +22,15 @@
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanInfo;
 
+import org.junit.Test;
 import org.springframework.jmx.JmxTestBean;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
  * @author Rick Evans
+ * @author Chris Beams
  */
 public class MethodExclusionMBeanInfoAssemblerTests extends AbstractJmxAssemblerTests {
 
@@ -60,6 +64,7 @@ protected MBeanInfoAssembler getAssembler() {
 		return assembler;
 	}
 
+	@Test
 	public void testSupermanIsReadOnly() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute("Superman");
@@ -71,6 +76,7 @@ public void testSupermanIsReadOnly() throws Exception {
 	/*
 	 * http://opensource.atlassian.com/projects/spring/browse/SPR-2754
 	 */
+	@Test
 	public void testIsNotIgnoredDoesntIgnoreUnspecifiedBeanMethods() throws Exception {
 		final String beanKey = "myTestBean";
 		MethodExclusionMBeanInfoAssembler assembler = new MethodExclusionMBeanInfoAssembler();
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodNameBasedMBeanInfoAssemblerMappedTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodNameBasedMBeanInfoAssemblerMappedTests.java
index 062a45febd79..10b1985515b3 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodNameBasedMBeanInfoAssemblerMappedTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodNameBasedMBeanInfoAssemblerMappedTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -16,18 +16,25 @@
 
 package org.springframework.jmx.export.assembler;
 
+import java.util.Properties;
+
 import javax.management.MBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanInfo;
-import java.util.Properties;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
 
 /**
  * @author Rob Harrop
+ * @author Chris Beams
  */
 public class MethodNameBasedMBeanInfoAssemblerMappedTests extends AbstractJmxAssemblerTests {
 
 	protected static final String OBJECT_NAME = "bean:name=testBean4";
 
+	@Test
 	public void testGetAgeIsReadOnly() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute(AGE_ATTRIBUTE);
@@ -36,6 +43,7 @@ public void testGetAgeIsReadOnly() throws Exception {
 		assertFalse("Age is not writable", attr.isWritable());
 	}
 
+	@Test
 	public void testWithFallThrough() throws Exception {
 		MethodNameBasedMBeanInfoAssembler assembler =
 				getWithMapping("foobar", "add,myOperation,getName,setName,getAge");
@@ -47,6 +55,7 @@ public void testWithFallThrough() throws Exception {
 		assertNickName(attr);
 	}
 
+	@Test
 	public void testNickNameIsExposed() throws Exception {
 		ModelMBeanInfo inf = (ModelMBeanInfo) getMBeanInfo();
 		MBeanAttributeInfo attr = inf.getAttribute("NickName");
diff --git a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodNameBasedMBeanInfoAssemblerTests.java b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodNameBasedMBeanInfoAssemblerTests.java
index 72da54f6f360..d85f42b508e1 100644
--- a/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodNameBasedMBeanInfoAssemblerTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/export/assembler/MethodNameBasedMBeanInfoAssemblerTests.java
@@ -20,9 +20,14 @@
 import javax.management.modelmbean.ModelMBeanAttributeInfo;
 import javax.management.modelmbean.ModelMBeanInfo;
 
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
 /**
  * @author Rob Harrop
  * @author David Boden
+ * @author Chris Beams
  */
 public class MethodNameBasedMBeanInfoAssemblerTests extends AbstractJmxAssemblerTests {
 
@@ -50,6 +55,7 @@ protected MBeanInfoAssembler getAssembler() {
 		return assembler;
 	}
 
+	@Test
 	public void testGetAgeIsReadOnly() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 		ModelMBeanAttributeInfo attr = info.getAttribute(AGE_ATTRIBUTE);
@@ -58,6 +64,7 @@ public void testGetAgeIsReadOnly() throws Exception {
 		assertFalse(attr.isWritable());
 	}
 
+	@Test
 	public void testSetNameParameterIsNamed() throws Exception {
 		ModelMBeanInfo info = getMBeanInfoFromAssembler();
 
diff --git a/spring-context/src/test/java/org/springframework/jmx/support/ConnectorServerFactoryBeanTestsIgnore.java b/spring-context/src/test/java/org/springframework/jmx/support/ConnectorServerFactoryBeanTests.java
similarity index 86%
rename from spring-context/src/test/java/org/springframework/jmx/support/ConnectorServerFactoryBeanTestsIgnore.java
rename to spring-context/src/test/java/org/springframework/jmx/support/ConnectorServerFactoryBeanTests.java
index ef244b085e56..6d66caa79cf9 100644
--- a/spring-context/src/test/java/org/springframework/jmx/support/ConnectorServerFactoryBeanTestsIgnore.java
+++ b/spring-context/src/test/java/org/springframework/jmx/support/ConnectorServerFactoryBeanTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -28,23 +28,36 @@
 import javax.management.remote.JMXConnectorFactory;
 import javax.management.remote.JMXServiceURL;
 
-import org.junit.Ignore;
+import org.junit.Test;
 import org.springframework.jmx.AbstractMBeanServerTests;
+import org.springframework.tests.Assume;
+import org.springframework.tests.TestGroup;
+
+import static org.junit.Assert.*;
 
 /**
  * @author Rob Harrop
+ * @author Chris Beams
  */
-// TODO [SPR-8089] Clean up ignored JMX tests.
-//
-// @Ignore should have no effect for JUnit 3.8 tests; however, it appears
-// that tests on the CI server -- as well as those in Eclipse -- do in
-// fact get ignored. So we leave @Ignore here so that developers can
-// easily search for ignored tests.
-@Ignore("Requires jmxremote_optional.jar; see comments in AbstractMBeanServerTests for details.")
-public class ConnectorServerFactoryBeanTestsIgnore extends AbstractMBeanServerTests {
+public class ConnectorServerFactoryBeanTests extends AbstractMBeanServerTests {
 
 	private static final String OBJECT_NAME = "spring:type=connector,name=test";
+	private boolean runTests = false;
+
+	@Override
+	protected void onSetUp() throws Exception {
+		Assume.group(TestGroup.JMXMP);
+		runTests = true;
+	}
+
+	@Override
+	public void tearDown() throws Exception {
+		if (runTests) {
+			super.tearDown();
+		}
+	}
 
+	@Test
 	public void testStartupWithLocatedServer() throws Exception {
 		ConnectorServerFactoryBean bean = new ConnectorServerFactoryBean();
 		bean.afterPropertiesSet();
@@ -56,6 +69,7 @@ public void testStartupWithLocatedServer() throws Exception {
 		}
 	}
 
+	@Test
 	public void testStartupWithSuppliedServer() throws Exception {
 		//Added a brief snooze here - seems to fix occasional
 		//java.net.BindException: Address already in use errors
@@ -72,6 +86,7 @@ public void testStartupWithSuppliedServer() throws Exception {
 		}
 	}
 
+	@Test
 	public void testRegisterWithMBeanServer() throws Exception {
 		//Added a brief snooze here - seems to fix occasional
 		//java.net.BindException: Address already in use errors
@@ -89,6 +104,7 @@ public void testRegisterWithMBeanServer() throws Exception {
 		}
 	}
 
+	@Test
 	public void testNoRegisterWithMBeanServer() throws Exception {
 		ConnectorServerFactoryBean bean = new ConnectorServerFactoryBean();
 		bean.afterPropertiesSet();
diff --git a/spring-context/src/test/java/org/springframework/jmx/support/MBeanServerConnectionFactoryBeanTests.java b/spring-context/src/test/java/org/springframework/jmx/support/MBeanServerConnectionFactoryBeanTests.java
index 598bc73e8c9b..c9c83cffaeed 100644
--- a/spring-context/src/test/java/org/springframework/jmx/support/MBeanServerConnectionFactoryBeanTests.java
+++ b/spring-context/src/test/java/org/springframework/jmx/support/MBeanServerConnectionFactoryBeanTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,9 +23,13 @@
 import javax.management.remote.JMXConnectorServerFactory;
 import javax.management.remote.JMXServiceURL;
 
-import org.junit.Ignore;
+import org.junit.Test;
 import org.springframework.aop.support.AopUtils;
 import org.springframework.jmx.AbstractMBeanServerTests;
+import org.springframework.tests.Assume;
+import org.springframework.tests.TestGroup;
+
+import static org.junit.Assert.*;
 
 /**
  * @author Rob Harrop
@@ -43,16 +47,9 @@ private JMXConnectorServer getConnectorServer() throws Exception {
 		return JMXConnectorServerFactory.newJMXConnectorServer(getServiceUrl(), null, getServer());
 	}
 
-	// TODO [SPR-8089] Clean up ignored JMX tests.
-	//
-	// @Ignore should have no effect for JUnit 3.8 tests; however, it appears
-	// that tests on the CI server -- as well as those in Eclipse -- do in
-	// fact get ignored. So we leave @Ignore here so that developers can
-	// easily search for ignored tests.
-	//
-	// Once fixed, renamed to test* instead of ignore*.
-	@Ignore("Requires jmxremote_optional.jar; see comments in AbstractMBeanServerTests for details.")
-	public void ignoreTestValidConnection() throws Exception {
+	@Test
+	public void testTestValidConnection() throws Exception {
+		Assume.group(TestGroup.JMXMP);
 		JMXConnectorServer connectorServer = getConnectorServer();
 		connectorServer.start();
 
@@ -75,6 +72,7 @@ public void ignoreTestValidConnection() throws Exception {
 		}
 	}
 
+	@Test
 	public void testWithNoServiceUrl() throws Exception {
 		MBeanServerConnectionFactoryBean bean = new MBeanServerConnectionFactoryBean();
 		try {
@@ -85,16 +83,9 @@ public void testWithNoServiceUrl() throws Exception {
 		}
 	}
 
-	// TODO [SPR-8089] Clean up ignored JMX tests.
-	//
-	// @Ignore should have no effect for JUnit 3.8 tests; however, it appears
-	// that tests on the CI server -- as well as those in Eclipse -- do in
-	// fact get ignored. So we leave @Ignore here so that developers can
-	// easily search for ignored tests.
-	//
-	// Once fixed, renamed to test* instead of ignore*.
-	@Ignore("Requires jmxremote_optional.jar; see comments in AbstractMBeanServerTests for details.")
-	public void ignoreTestWithLazyConnection() throws Exception {
+	@Test
+	public void testTestWithLazyConnection() throws Exception {
+		Assume.group(TestGroup.JMXMP);
 		MBeanServerConnectionFactoryBean bean = new MBeanServerConnectionFactoryBean();
 		bean.setServiceUrl(SERVICE_URL);
 		bean.setConnectOnStartup(false);
@@ -116,6 +107,7 @@ public void ignoreTestWithLazyConnection() throws Exception {
 		}
 	}
 
+	@Test
 	public void testWithLazyConnectionAndNoAccess() throws Exception {
 		MBeanServerConnectionFactoryBean bean = new MBeanServerConnectionFactoryBean();
 		bean.setServiceUrl(SERVICE_URL);
diff --git a/spring-context/src/test/java/org/springframework/jndi/JndiObjectFactoryBeanTests.java b/spring-context/src/test/java/org/springframework/jndi/JndiObjectFactoryBeanTests.java
index 4ad2255d2c49..d9d7e60ac6b5 100644
--- a/spring-context/src/test/java/org/springframework/jndi/JndiObjectFactoryBeanTests.java
+++ b/spring-context/src/test/java/org/springframework/jndi/JndiObjectFactoryBeanTests.java
@@ -16,12 +16,6 @@
 
 package org.springframework.jndi;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import javax.naming.Context;
 import javax.naming.NamingException;
 
@@ -31,6 +25,9 @@
 import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.tests.sample.beans.TestBean;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
diff --git a/spring-context/src/test/java/org/springframework/jndi/JndiTemplateTests.java b/spring-context/src/test/java/org/springframework/jndi/JndiTemplateTests.java
index 401880247598..ef73a867f189 100644
--- a/spring-context/src/test/java/org/springframework/jndi/JndiTemplateTests.java
+++ b/spring-context/src/test/java/org/springframework/jndi/JndiTemplateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,16 +16,14 @@
 
 package org.springframework.jndi;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import javax.naming.Context;
 import javax.naming.NameNotFoundException;
 
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
diff --git a/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java b/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java
index f679713eb96d..028f60c559d4 100644
--- a/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java
+++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/AsyncExecutionTests.java
@@ -66,6 +66,21 @@ public void asyncMethods() throws Exception {
 		assertEquals("20", future.get());
 	}
 
+	@Test
+	public void asyncMethodsThroughInterface() throws Exception {
+		originalThreadName = Thread.currentThread().getName();
+		GenericApplicationContext context = new GenericApplicationContext();
+		context.registerBeanDefinition("asyncTest", new RootBeanDefinition(SimpleAsyncMethodBean.class));
+		context.registerBeanDefinition("autoProxyCreator", new RootBeanDefinition(DefaultAdvisorAutoProxyCreator.class));
+		context.registerBeanDefinition("asyncAdvisor", new RootBeanDefinition(AsyncAnnotationAdvisor.class));
+		context.refresh();
+		SimpleInterface asyncTest = context.getBean("asyncTest", SimpleInterface.class);
+		asyncTest.doNothing(5);
+		asyncTest.doSomething(10);
+		Future<String> future = asyncTest.returnSomething(20);
+		assertEquals("20", future.get());
+	}
+
 	@Test
 	public void asyncMethodsWithQualifier() throws Exception {
 		originalThreadName = Thread.currentThread().getName();
@@ -86,6 +101,26 @@ public void asyncMethodsWithQualifier() throws Exception {
 		assertEquals("30", future2.get());
 	}
 
+	@Test
+	public void asyncMethodsWithQualifierThroughInterface() throws Exception {
+		originalThreadName = Thread.currentThread().getName();
+		GenericApplicationContext context = new GenericApplicationContext();
+		context.registerBeanDefinition("asyncTest", new RootBeanDefinition(SimpleAsyncMethodWithQualifierBean.class));
+		context.registerBeanDefinition("autoProxyCreator", new RootBeanDefinition(DefaultAdvisorAutoProxyCreator.class));
+		context.registerBeanDefinition("asyncAdvisor", new RootBeanDefinition(AsyncAnnotationAdvisor.class));
+		context.registerBeanDefinition("e0", new RootBeanDefinition(ThreadPoolTaskExecutor.class));
+		context.registerBeanDefinition("e1", new RootBeanDefinition(ThreadPoolTaskExecutor.class));
+		context.registerBeanDefinition("e2", new RootBeanDefinition(ThreadPoolTaskExecutor.class));
+		context.refresh();
+		SimpleInterface asyncTest = context.getBean("asyncTest", SimpleInterface.class);
+		asyncTest.doNothing(5);
+		asyncTest.doSomething(10);
+		Future<String> future = asyncTest.returnSomething(20);
+		assertEquals("20", future.get());
+		Future<String> future2 = asyncTest.returnSomething2(30);
+		assertEquals("30", future2.get());
+	}
+
 	@Test
 	public void asyncClass() throws Exception {
 		originalThreadName = Thread.currentThread().getName();
@@ -177,6 +212,18 @@ public void asyncPrototypeClassListener() throws Exception {
 	}
 
 
+	public interface SimpleInterface {
+
+		void doNothing(int i);
+
+		void doSomething(int i);
+
+		Future<String> returnSomething(int i);
+
+		Future<String> returnSomething2(int i);
+	}
+
+
 	public static class AsyncMethodBean {
 
 		public void doNothing(int i) {
@@ -196,6 +243,15 @@ public Future<String> returnSomething(int i) {
 	}
 
 
+	public static class SimpleAsyncMethodBean extends AsyncMethodBean implements SimpleInterface {
+
+		@Override
+		public Future<String> returnSomething2(int i) {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+
 	@Async("e0")
 	public static class AsyncMethodWithQualifierBean {
 
@@ -224,6 +280,10 @@ public Future<String> returnSomething2(int i) {
 	}
 
 
+	public static class SimpleAsyncMethodWithQualifierBean extends AsyncMethodWithQualifierBean implements SimpleInterface {
+	}
+
+
 	@Async("e2")
 	@Retention(RetentionPolicy.RUNTIME)
 	public @interface MyAsync {
diff --git a/spring-context/src/test/java/org/springframework/scheduling/annotation/EnableAsyncTests.java b/spring-context/src/test/java/org/springframework/scheduling/annotation/EnableAsyncTests.java
index 3b3329e0d951..bc30910d5f68 100644
--- a/spring-context/src/test/java/org/springframework/scheduling/annotation/EnableAsyncTests.java
+++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/EnableAsyncTests.java
@@ -74,7 +74,6 @@ public AsyncBean asyncBean() {
 	}
 
 
-	@SuppressWarnings("unchecked")
 	@Test
 	public void withAsyncBeanWithExecutorQualifiedByName() throws ExecutionException, InterruptedException {
 		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
diff --git a/spring-context/src/test/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessorTests.java b/spring-context/src/test/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessorTests.java
index e100da3d47df..91bf0f697e61 100644
--- a/spring-context/src/test/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessorTests.java
+++ b/spring-context/src/test/java/org/springframework/scheduling/annotation/ScheduledAnnotationBeanPostProcessorTests.java
@@ -26,6 +26,7 @@
 import java.util.Properties;
 
 import org.junit.Test;
+
 import org.springframework.beans.DirectFieldAccessor;
 import org.springframework.beans.factory.BeanCreationException;
 import org.springframework.beans.factory.config.BeanDefinition;
@@ -52,8 +53,7 @@ public class ScheduledAnnotationBeanPostProcessorTests {
 	public void fixedDelayTask() {
 		StaticApplicationContext context = new StaticApplicationContext();
 		BeanDefinition processorDefinition = new RootBeanDefinition(ScheduledAnnotationBeanPostProcessor.class);
-		BeanDefinition targetDefinition = new RootBeanDefinition(
-				ScheduledAnnotationBeanPostProcessorTests.FixedDelayTestBean.class);
+		BeanDefinition targetDefinition = new RootBeanDefinition(FixedDelayTestBean.class);
 		context.registerBeanDefinition("postProcessor", processorDefinition);
 		context.registerBeanDefinition("target", targetDefinition);
 		context.refresh();
@@ -106,8 +106,7 @@ public void fixedRateTask() {
 	public void fixedRateTaskWithInitialDelay() {
 		StaticApplicationContext context = new StaticApplicationContext();
 		BeanDefinition processorDefinition = new RootBeanDefinition(ScheduledAnnotationBeanPostProcessor.class);
-		BeanDefinition targetDefinition = new RootBeanDefinition(
-				ScheduledAnnotationBeanPostProcessorTests.FixedRateWithInitialDelayTestBean.class);
+		BeanDefinition targetDefinition = new RootBeanDefinition(FixedRateWithInitialDelayTestBean.class);
 		context.registerBeanDefinition("postProcessor", processorDefinition);
 		context.registerBeanDefinition("target", targetDefinition);
 		context.refresh();
@@ -162,8 +161,7 @@ public void cronTask() throws InterruptedException {
 	public void metaAnnotationWithFixedRate() {
 		StaticApplicationContext context = new StaticApplicationContext();
 		BeanDefinition processorDefinition = new RootBeanDefinition(ScheduledAnnotationBeanPostProcessor.class);
-		BeanDefinition targetDefinition = new RootBeanDefinition(
-				ScheduledAnnotationBeanPostProcessorTests.MetaAnnotationFixedRateTestBean.class);
+		BeanDefinition targetDefinition = new RootBeanDefinition(MetaAnnotationFixedRateTestBean.class);
 		context.registerBeanDefinition("postProcessor", processorDefinition);
 		context.registerBeanDefinition("target", targetDefinition);
 		context.refresh();
@@ -211,7 +209,7 @@ public void metaAnnotationWithCronExpression() {
 	}
 
 	@Test
-	public void propertyPlaceholderWithCronExpression() {
+	public void propertyPlaceholderWithCron() {
 		String businessHoursCronExpression = "0 0 9-17 * * MON-FRI";
 		StaticApplicationContext context = new StaticApplicationContext();
 		BeanDefinition processorDefinition = new RootBeanDefinition(ScheduledAnnotationBeanPostProcessor.class);
@@ -219,8 +217,7 @@ public void propertyPlaceholderWithCronExpression() {
 		Properties properties = new Properties();
 		properties.setProperty("schedules.businessHours", businessHoursCronExpression);
 		placeholderDefinition.getPropertyValues().addPropertyValue("properties", properties);
-		BeanDefinition targetDefinition = new RootBeanDefinition(
-				ScheduledAnnotationBeanPostProcessorTests.PropertyPlaceholderTestBean.class);
+		BeanDefinition targetDefinition = new RootBeanDefinition(PropertyPlaceholderWithCronTestBean.class);
 		context.registerBeanDefinition("placeholder", placeholderDefinition);
 		context.registerBeanDefinition("postProcessor", processorDefinition);
 		context.registerBeanDefinition("target", targetDefinition);
@@ -242,6 +239,70 @@ public void propertyPlaceholderWithCronExpression() {
 		assertEquals(businessHoursCronExpression, task.getExpression());
 	}
 
+	@Test
+	public void propertyPlaceholderWithFixedDelay() {
+		StaticApplicationContext context = new StaticApplicationContext();
+		BeanDefinition processorDefinition = new RootBeanDefinition(ScheduledAnnotationBeanPostProcessor.class);
+		BeanDefinition placeholderDefinition = new RootBeanDefinition(PropertyPlaceholderConfigurer.class);
+		Properties properties = new Properties();
+		properties.setProperty("fixedDelay", "5000");
+		properties.setProperty("initialDelay", "1000");
+		placeholderDefinition.getPropertyValues().addPropertyValue("properties", properties);
+		BeanDefinition targetDefinition = new RootBeanDefinition(PropertyPlaceholderWithFixedDelayTestBean.class);
+		context.registerBeanDefinition("placeholder", placeholderDefinition);
+		context.registerBeanDefinition("postProcessor", processorDefinition);
+		context.registerBeanDefinition("target", targetDefinition);
+		context.refresh();
+		Object postProcessor = context.getBean("postProcessor");
+		Object target = context.getBean("target");
+		ScheduledTaskRegistrar registrar = (ScheduledTaskRegistrar)
+				new DirectFieldAccessor(postProcessor).getPropertyValue("registrar");
+		@SuppressWarnings("unchecked")
+		List<IntervalTask> fixedDelayTasks = (List<IntervalTask>)
+				new DirectFieldAccessor(registrar).getPropertyValue("fixedDelayTasks");
+		assertEquals(1, fixedDelayTasks.size());
+		IntervalTask task = fixedDelayTasks.get(0);
+		ScheduledMethodRunnable runnable = (ScheduledMethodRunnable) task.getRunnable();
+		Object targetObject = runnable.getTarget();
+		Method targetMethod = runnable.getMethod();
+		assertEquals(target, targetObject);
+		assertEquals("fixedDelay", targetMethod.getName());
+		assertEquals(1000L, task.getInitialDelay());
+		assertEquals(5000L, task.getInterval());
+	}
+
+	@Test
+	public void propertyPlaceholderWithFixedRate() {
+		StaticApplicationContext context = new StaticApplicationContext();
+		BeanDefinition processorDefinition = new RootBeanDefinition(ScheduledAnnotationBeanPostProcessor.class);
+		BeanDefinition placeholderDefinition = new RootBeanDefinition(PropertyPlaceholderConfigurer.class);
+		Properties properties = new Properties();
+		properties.setProperty("fixedRate", "3000");
+		properties.setProperty("initialDelay", "1000");
+		placeholderDefinition.getPropertyValues().addPropertyValue("properties", properties);
+		BeanDefinition targetDefinition = new RootBeanDefinition(PropertyPlaceholderWithFixedRateTestBean.class);
+		context.registerBeanDefinition("placeholder", placeholderDefinition);
+		context.registerBeanDefinition("postProcessor", processorDefinition);
+		context.registerBeanDefinition("target", targetDefinition);
+		context.refresh();
+		Object postProcessor = context.getBean("postProcessor");
+		Object target = context.getBean("target");
+		ScheduledTaskRegistrar registrar = (ScheduledTaskRegistrar)
+				new DirectFieldAccessor(postProcessor).getPropertyValue("registrar");
+		@SuppressWarnings("unchecked")
+		List<IntervalTask> fixedRateTasks = (List<IntervalTask>)
+				new DirectFieldAccessor(registrar).getPropertyValue("fixedRateTasks");
+		assertEquals(1, fixedRateTasks.size());
+		IntervalTask task = fixedRateTasks.get(0);
+		ScheduledMethodRunnable runnable = (ScheduledMethodRunnable) task.getRunnable();
+		Object targetObject = runnable.getTarget();
+		Method targetMethod = runnable.getMethod();
+		assertEquals(target, targetObject);
+		assertEquals("fixedRate", targetMethod.getName());
+		assertEquals(1000L, task.getInitialDelay());
+		assertEquals(3000L, task.getInterval());
+	}
+
 	@Test
 	public void propertyPlaceholderForMetaAnnotation() {
 		String businessHoursCronExpression = "0 0 9-17 * * MON-FRI";
@@ -285,7 +346,7 @@ public void emptyAnnotation() {
 		context.refresh();
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = BeanCreationException.class)
 	public void invalidCron() throws Throwable {
 		StaticApplicationContext context = new StaticApplicationContext();
 		BeanDefinition processorDefinition = new RootBeanDefinition(ScheduledAnnotationBeanPostProcessor.class);
@@ -293,12 +354,7 @@ public void invalidCron() throws Throwable {
 				ScheduledAnnotationBeanPostProcessorTests.InvalidCronTestBean.class);
 		context.registerBeanDefinition("postProcessor", processorDefinition);
 		context.registerBeanDefinition("target", targetDefinition);
-		try {
-			context.refresh();
-			fail("expected exception");
-		} catch (BeanCreationException ex) {
-			throw ex.getRootCause();
-		}
+		context.refresh();
 	}
 
 	@Test(expected = BeanCreationException.class)
@@ -342,7 +398,7 @@ public void fixedRate() {
 
 	static class FixedRateWithInitialDelayTestBean {
 
-		@Scheduled(initialDelay=1000, fixedRate=3000)
+		@Scheduled(fixedRate=3000, initialDelay=1000)
 		public void fixedRate() {
 		}
 	}
@@ -395,13 +451,13 @@ public void invalid(String oops) {
 	}
 
 
-	@Scheduled(fixedRate = 5000)
+	@Scheduled(fixedRate=5000)
 	@Target(ElementType.METHOD)
 	@Retention(RetentionPolicy.RUNTIME)
 	private static @interface EveryFiveSeconds {}
 
 
-	@Scheduled(cron = "0 0 * * * ?")
+	@Scheduled(cron="0 0 * * * ?")
 	@Target(ElementType.METHOD)
 	@Retention(RetentionPolicy.RUNTIME)
 	private static @interface Hourly {}
@@ -423,7 +479,7 @@ public void generateReport() {
 	}
 
 
-	static class PropertyPlaceholderTestBean {
+	static class PropertyPlaceholderWithCronTestBean {
 
 		@Scheduled(cron = "${schedules.businessHours}")
 		public void x() {
@@ -431,7 +487,23 @@ public void x() {
 	}
 
 
-	@Scheduled(cron = "${schedules.businessHours}")
+	static class PropertyPlaceholderWithFixedDelayTestBean {
+
+		@Scheduled(fixedDelayString="${fixedDelay}", initialDelayString="${initialDelay}")
+		public void fixedDelay() {
+		}
+	}
+
+
+	static class PropertyPlaceholderWithFixedRateTestBean {
+
+		@Scheduled(fixedRateString="${fixedRate}", initialDelayString="${initialDelay}")
+		public void fixedRate() {
+		}
+	}
+
+
+	@Scheduled(cron="${schedules.businessHours}")
 	@Target(ElementType.METHOD)
 	@Retention(RetentionPolicy.RUNTIME)
 	private static @interface BusinessHours {}
diff --git a/spring-context/src/test/java/org/springframework/scheduling/support/CronSequenceGeneratorTests.java b/spring-context/src/test/java/org/springframework/scheduling/support/CronSequenceGeneratorTests.java
new file mode 100644
index 000000000000..491706f9e31b
--- /dev/null
+++ b/spring-context/src/test/java/org/springframework/scheduling/support/CronSequenceGeneratorTests.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.scheduling.support;
+
+import java.util.Date;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Juergen Hoeller
+ */
+public class CronSequenceGeneratorTests {
+
+	@Test
+	public void testAt50Seconds() {
+		assertEquals(new Date(2012, 6, 2, 1, 0),
+				new CronSequenceGenerator("*/15 * 1-4 * * *").next(new Date(2012, 6, 1, 9, 53, 50)));
+	}
+
+	@Test
+	public void testAt0Seconds() {
+		assertEquals(new Date(2012, 6, 2, 1, 0),
+				new CronSequenceGenerator("*/15 * 1-4 * * *").next(new Date(2012, 6, 1, 9, 53)));
+	}
+
+	@Test
+	public void testAt0Minutes() {
+		assertEquals(new Date(2012, 6, 2, 1, 0),
+				new CronSequenceGenerator("0 */2 1-4 * * *").next(new Date(2012, 6, 1, 9, 0)));
+	}
+
+}
diff --git a/spring-context/src/test/java/org/springframework/scheduling/support/CronTriggerTests.java b/spring-context/src/test/java/org/springframework/scheduling/support/CronTriggerTests.java
index 49574ae29d5f..261ea34bd806 100644
--- a/spring-context/src/test/java/org/springframework/scheduling/support/CronTriggerTests.java
+++ b/spring-context/src/test/java/org/springframework/scheduling/support/CronTriggerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -41,7 +41,7 @@
 @RunWith(Parameterized.class)
 public class CronTriggerTests {
 
-	private Calendar calendar = new GregorianCalendar();
+	private final Calendar calendar = new GregorianCalendar();
 
 	private final Date date;
 
@@ -49,14 +49,14 @@ public class CronTriggerTests {
 
 
 	public CronTriggerTests(Date date, TimeZone timeZone) {
-		this.timeZone = timeZone;
 		this.date = date;
+		this.timeZone = timeZone;
 	}
 
 	@Parameters
 	public static List<Object[]> getParameters() {
 		List<Object[]> list = new ArrayList<Object[]>();
-		list.add(new Object[] { new Date(), TimeZone.getDefault() });
+		list.add(new Object[] { new Date(), TimeZone.getTimeZone("PST") });
 		list.add(new Object[] { new Date(), TimeZone.getTimeZone("CET") });
 		return list;
 	}
@@ -66,6 +66,7 @@ private void roundup(Calendar calendar) {
 		calendar.set(Calendar.MILLISECOND, 0);
 	}
 
+
 	@Before
 	public void setUp() {
 		calendar.setTimeZone(timeZone);
@@ -421,8 +422,8 @@ public void testSpecificMinuteSecond() throws Exception {
 
 	@Test
 	public void testSpecificHourSecond() throws Exception {
-		CronTrigger trigger = new CronTrigger("55 * 2 * * *", timeZone);
-		calendar.set(Calendar.HOUR_OF_DAY, 1);
+		CronTrigger trigger = new CronTrigger("55 * 10 * * *", timeZone);
+		calendar.set(Calendar.HOUR_OF_DAY, 9);
 		calendar.set(Calendar.SECOND, 54);
 		Date date = calendar.getTime();
 		TriggerContext context1 = getTriggerContext(date);
@@ -487,7 +488,7 @@ public void testSpecificDate() throws Exception {
 		assertEquals(calendar.getTime(), date = trigger.nextExecutionTime(context2));
 	}
 
-	@Test(expected=IllegalStateException.class)
+	@Test(expected = IllegalArgumentException.class)
 	public void testNonExistentSpecificDate() throws Exception {
 		// TODO: maybe try and detect this as a special case in parser?
 		CronTrigger trigger = new CronTrigger("0 0 0 31 6 *", timeZone);
@@ -693,6 +694,26 @@ public void testMonthSequence() throws Exception {
 		assertEquals(calendar.getTime(), date = trigger.nextExecutionTime(context3));
 	}
 
+	@Test
+	public void testDaylightSavingMissingHour() throws Exception {
+		// This trigger has to be somewhere in between 2am and 3am
+		CronTrigger trigger = new CronTrigger("0 10 2 * * *", timeZone);
+		calendar.set(Calendar.DAY_OF_MONTH, 31);
+		calendar.set(Calendar.MONTH, Calendar.MARCH);
+		calendar.set(Calendar.YEAR, 2013);
+		calendar.set(Calendar.HOUR_OF_DAY, 1);
+		calendar.set(Calendar.SECOND, 54);
+		Date date = calendar.getTime();
+		TriggerContext context1 = getTriggerContext(date);
+		if (timeZone.equals(TimeZone.getTimeZone("CET"))) {
+			// Clocks go forward an hour so 2am doesn't exist in CET for this date
+			calendar.add(Calendar.DAY_OF_MONTH, 1);
+		}
+		calendar.add(Calendar.HOUR_OF_DAY, 1);
+		calendar.set(Calendar.MINUTE, 10);
+		calendar.set(Calendar.SECOND, 0);
+		assertEquals(calendar.getTime(), date = trigger.nextExecutionTime(context1));
+	}
 
 	private void assertMatchesNextSecond(CronTrigger trigger, Calendar calendar) {
 		Date date = calendar.getTime();
diff --git a/spring-context/src/test/java/org/springframework/scheduling/timer/TimerSupportTests.java b/spring-context/src/test/java/org/springframework/scheduling/timer/TimerSupportTests.java
index 3beaf36b84a1..283ee0acf3b3 100644
--- a/spring-context/src/test/java/org/springframework/scheduling/timer/TimerSupportTests.java
+++ b/spring-context/src/test/java/org/springframework/scheduling/timer/TimerSupportTests.java
@@ -16,6 +16,9 @@
 
 package org.springframework.scheduling.timer;
 
+import static org.hamcrest.Matchers.instanceOf;
+import static org.junit.Assert.assertThat;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Timer;
@@ -84,7 +87,7 @@ protected Timer createTimer(String name, boolean daemon) {
 		try {
 			timerFactoryBean.setScheduledTimerTasks(tasks);
 			timerFactoryBean.afterPropertiesSet();
-			assertTrue(timerFactoryBean.getObject() instanceof Timer);
+			assertThat(timerFactoryBean.getObject(), instanceOf(Timer.class));
 			timerTask0.run();
 			timerTask1.run();
 			timerTask2.run();
diff --git a/spring-context/src/test/java/org/springframework/scripting/bsh/BshScriptFactoryTests.java b/spring-context/src/test/java/org/springframework/scripting/bsh/BshScriptFactoryTests.java
index 05601840108e..93b33b48bc99 100644
--- a/spring-context/src/test/java/org/springframework/scripting/bsh/BshScriptFactoryTests.java
+++ b/spring-context/src/test/java/org/springframework/scripting/bsh/BshScriptFactoryTests.java
@@ -16,9 +16,6 @@
 
 package org.springframework.scripting.bsh;
 
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -26,7 +23,6 @@
 
 import org.springframework.aop.support.AopUtils;
 import org.springframework.aop.target.dynamic.Refreshable;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.ApplicationEvent;
 import org.springframework.context.support.ClassPathXmlApplicationContext;
@@ -38,6 +34,9 @@
 import org.springframework.scripting.ScriptSource;
 import org.springframework.scripting.TestBeanAwareMessenger;
 import org.springframework.scripting.support.ScriptFactoryPostProcessor;
+import org.springframework.tests.sample.beans.TestBean;
+
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Rob Harrop
diff --git a/spring-context/src/test/java/org/springframework/scripting/groovy/GroovyScriptFactoryTests.java b/spring-context/src/test/java/org/springframework/scripting/groovy/GroovyScriptFactoryTests.java
index 96d3db7fdf22..7ced7671ce37 100644
--- a/spring-context/src/test/java/org/springframework/scripting/groovy/GroovyScriptFactoryTests.java
+++ b/spring-context/src/test/java/org/springframework/scripting/groovy/GroovyScriptFactoryTests.java
@@ -16,15 +16,6 @@
 
 package org.springframework.scripting.groovy;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
 import groovy.lang.DelegatingMetaClass;
 import groovy.lang.GroovyObject;
 
@@ -37,10 +28,10 @@
 import org.junit.Test;
 import org.springframework.aop.support.AopUtils;
 import org.springframework.aop.target.dynamic.Refreshable;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.beans.factory.BeanCreationException;
 import org.springframework.beans.factory.FactoryBean;
 import org.springframework.beans.factory.UnsatisfiedDependencyException;
+import org.springframework.beans.factory.config.BeanDefinition;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.support.ClassPathXmlApplicationContext;
 import org.springframework.core.NestedRuntimeException;
@@ -56,6 +47,11 @@
 import org.springframework.stereotype.Component;
 import org.springframework.tests.Assume;
 import org.springframework.tests.TestGroup;
+import org.springframework.tests.sample.beans.TestBean;
+import org.springframework.util.ObjectUtils;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Rob Harrop
@@ -350,7 +346,9 @@ public void testPrototypeScriptFromTag() throws Exception {
 
 	@Test
 	public void testInlineScriptFromTag() throws Exception {
-		ApplicationContext ctx = new ClassPathXmlApplicationContext("groovy-with-xsd.xml", getClass());
+		ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("groovy-with-xsd.xml", getClass());
+		BeanDefinition bd = ctx.getBeanFactory().getBeanDefinition("calculator");
+		assertTrue(ObjectUtils.containsElement(bd.getDependsOn(), "messenger"));
 		Calculator calculator = (Calculator) ctx.getBean("calculator");
 		assertNotNull(calculator);
 		assertFalse(calculator instanceof Refreshable);
diff --git a/spring-context/src/test/java/org/springframework/scripting/support/RefreshableScriptTargetSourceTests.java b/spring-context/src/test/java/org/springframework/scripting/support/RefreshableScriptTargetSourceTests.java
index 5a5b72715c56..a443bee0bb43 100644
--- a/spring-context/src/test/java/org/springframework/scripting/support/RefreshableScriptTargetSourceTests.java
+++ b/spring-context/src/test/java/org/springframework/scripting/support/RefreshableScriptTargetSourceTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,12 @@
 
 package org.springframework.scripting.support;
 
-import static org.mockito.Mockito.mock;
 import junit.framework.TestCase;
 
 import org.springframework.beans.factory.BeanFactory;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  */
diff --git a/spring-context/src/test/java/org/springframework/scripting/support/ResourceScriptSourceTests.java b/spring-context/src/test/java/org/springframework/scripting/support/ResourceScriptSourceTests.java
index e1fe7c848e06..08c9353bb923 100644
--- a/spring-context/src/test/java/org/springframework/scripting/support/ResourceScriptSourceTests.java
+++ b/spring-context/src/test/java/org/springframework/scripting/support/ResourceScriptSourceTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,6 @@
 
 package org.springframework.scripting.support;
 
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 
@@ -27,6 +24,8 @@
 import org.springframework.core.io.ByteArrayResource;
 import org.springframework.core.io.Resource;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
diff --git a/spring-context/src/test/java/org/springframework/scripting/support/ScriptFactoryPostProcessorTests.java b/spring-context/src/test/java/org/springframework/scripting/support/ScriptFactoryPostProcessorTests.java
index d561ac7e7eb7..680bbe65d259 100644
--- a/spring-context/src/test/java/org/springframework/scripting/support/ScriptFactoryPostProcessorTests.java
+++ b/spring-context/src/test/java/org/springframework/scripting/support/ScriptFactoryPostProcessorTests.java
@@ -16,11 +16,8 @@
 
 package org.springframework.scripting.support;
 
-import static org.mockito.Mockito.mock;
-
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.beans.FatalBeanException;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.config.BeanDefinition;
@@ -34,6 +31,7 @@
 import org.springframework.tests.TestGroup;
 
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Rick Evans
diff --git a/spring-context/src/test/java/org/springframework/validation/DataBinderTests.java b/spring-context/src/test/java/org/springframework/validation/DataBinderTests.java
index 515a1013b024..77fc0dee24d9 100644
--- a/spring-context/src/test/java/org/springframework/validation/DataBinderTests.java
+++ b/spring-context/src/test/java/org/springframework/validation/DataBinderTests.java
@@ -1630,6 +1630,7 @@ public void testNestedGrowingList() {
 	  }
 
 
+	@SuppressWarnings("unused")
 	private static class BeanWithIntegerList {
 
 		private List<Integer> integerList;
@@ -1644,6 +1645,7 @@ public void setIntegerList(List<Integer> integerList) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class Book {
 
 		private String Title;
@@ -1728,6 +1730,7 @@ public void validate(Object obj, Errors errors) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class GrowingList<E> extends AbstractList<E> {
 
 		private List<E> list;
diff --git a/spring-context/src/test/java/org/springframework/validation/beanvalidation/ValidatorFactoryTests.java b/spring-context/src/test/java/org/springframework/validation/beanvalidation/ValidatorFactoryTests.java
index 3e6cac575980..be4f45213a09 100644
--- a/spring-context/src/test/java/org/springframework/validation/beanvalidation/ValidatorFactoryTests.java
+++ b/spring-context/src/test/java/org/springframework/validation/beanvalidation/ValidatorFactoryTests.java
@@ -42,6 +42,7 @@
 import org.springframework.validation.FieldError;
 import org.springframework.validation.ObjectError;
 
+import static org.hamcrest.Matchers.*;
 import static org.junit.Assert.*;
 
 /**
@@ -102,6 +103,20 @@ public void testSimpleValidationWithClassLevel() throws Exception {
 		assertTrue(cv.getConstraintDescriptor().getAnnotation() instanceof NameAddressValid);
 	}
 
+	@Test
+	public void testSpringValidationFieldType() throws Exception {
+		LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean();
+		validator.afterPropertiesSet();
+		ValidPerson person = new ValidPerson();
+		person.setName("Phil");
+		person.getAddress().setStreet("Phil's Street");
+		BeanPropertyBindingResult errors = new BeanPropertyBindingResult(person, "person");
+		validator.validate(person, errors);
+		assertEquals(1, errors.getErrorCount());
+		assertThat("Field/Value type mismatch", errors.getFieldError("address").getRejectedValue(),
+				instanceOf(ValidAddress.class));
+	}
+
 	@Test
 	public void testSpringValidation() throws Exception {
 		LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean();
@@ -289,8 +304,13 @@ public void initialize(NameAddressValid constraintAnnotation) {
 		}
 
 		@Override
-		public boolean isValid(ValidPerson value, ConstraintValidatorContext constraintValidatorContext) {
-			return (value.name == null || !value.address.street.contains(value.name));
+		public boolean isValid(ValidPerson value, ConstraintValidatorContext context) {
+			boolean valid = (value.name == null || !value.address.street.contains(value.name));
+			if (!valid && "Phil".equals(value.name)) {
+				context.buildConstraintViolationWithTemplate(
+						context.getDefaultConstraintMessageTemplate()).addNode("address").addConstraintViolation().disableDefaultConstraintViolation();
+			}
+			return valid;
 		}
 	}
 
diff --git a/spring-context/src/test/resources/org/springframework/cache/config/cache-advice.xml b/spring-context/src/test/resources/org/springframework/cache/config/cache-advice.xml
index d9eef4816bb4..5ebf54ddcb42 100644
--- a/spring-context/src/test/resources/org/springframework/cache/config/cache-advice.xml
+++ b/spring-context/src/test/resources/org/springframework/cache/config/cache-advice.xml
@@ -3,7 +3,7 @@
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:cache="http://www.springframework.org/schema/cache"
        xmlns:p="http://www.springframework.org/schema/p"
-       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd 
+       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
        		http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd">
 
@@ -11,6 +11,7 @@
 		<cache:caching cache="default">
 			<cache:cacheable method="cache"/>
 			<cache:cacheable method="conditional" condition="#classField == 3"/>
+			<cache:cacheable method="unless" unless="#result > 10"/>
 			<cache:cacheable method="key" key="#p0"/>
 			<cache:cacheable method="nam*" key="#root.methodName"/>
 			<cache:cacheable method="rootVars" key="#root.methodName + #root.method.name + #root.targetClass + #root.target"/>
@@ -54,6 +55,7 @@
 			<cache:cacheable method="rootVars" key="#root.methodName + #root.method.name + #root.targetClass + #root.target"/>
 			<cache:cacheable method="cache"/>
 			<cache:cacheable method="conditional"/>
+			<cache:cacheable method="unless"/>
 			<cache:cacheable method="null*"/>
 		</cache:caching>
 		<cache:caching>
@@ -80,9 +82,9 @@
 			<cache:cache-evict method="multiConditionalCacheAndEvict" cache="secondary"/>
 			<cache:cache-put method="multiUpdate" cache="primary"/>
 			<cache:cache-put method="multiUpdate" cache="secondary"/>
-		</cache:caching>		
+		</cache:caching>
 	</cache:advice>
-		
+
 	<aop:config>
 		<aop:advisor advice-ref="cacheAdviceInterface" pointcut="execution(* *..DefaultCacheableService.*(..))" order="1"/>
 		<aop:advisor advice-ref="cacheAdviceClass" pointcut="execution(* *..AnnotatedClassCacheableService.*(..))" order="1"/>
@@ -98,12 +100,12 @@
 			</set>
 		</property>
 	</bean>
-	
+
 	<bean id="keyGenerator" class="org.springframework.cache.config.SomeKeyGenerator"/>
 
 	<bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/>
-	
+
 	<bean id="service" class="org.springframework.cache.config.DefaultCacheableService"/>
-	
+
 	<bean id="classService" class="org.springframework.cache.config.AnnotatedClassCacheableService"/>
 </beans>
diff --git a/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java
index cb9e8fba331b..7d8045b51ba6 100644
--- a/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java
+++ b/spring-core/src/main/java/org/springframework/core/GenericTypeResolver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,11 +26,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
 import org.springframework.util.Assert;
-import org.springframework.util.ObjectUtils;
 import org.springframework.util.ConcurrentReferenceHashMap;
 
 /**
@@ -47,12 +43,11 @@
  */
 public abstract class GenericTypeResolver {
 
-	private static final Log logger = LogFactory.getLog(GenericTypeResolver.class);
-
 	/** Cache from Class to TypeVariable Map */
 	private static final Map<Class, Map<TypeVariable, Type>> typeVariableCache =
 			new ConcurrentReferenceHashMap<Class, Map<TypeVariable,Type>>();
 
+
 	/**
 	 * Determine the target type for the given parameter specification.
 	 * @param methodParam the method parameter specification
@@ -93,7 +88,6 @@ public static Class<?> resolveParameterType(MethodParameter methodParam, Class c
 	/**
 	 * Determine the target type for the generic return type of the given method,
 	 * where formal type variables are declared on the given class.
-	 *
 	 * @param method the method to introspect
 	 * @param clazz the class to resolve type variables against
 	 * @return the corresponding generic parameter or return type
@@ -112,15 +106,12 @@ public static Class<?> resolveReturnType(Method method, Class<?> clazz) {
 	 * Determine the target type for the generic return type of the given
 	 * <em>generic method</em>, where formal type variables are declared on
 	 * the given method itself.
-	 *
 	 * <p>For example, given a factory method with the following signature,
 	 * if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected
 	 * method for {@code creatProxy()} and an {@code Object[]} array containing
 	 * {@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will
 	 * infer that the target return type is {@code MyService}.
-	 *
 	 * <pre>{@code public static <T> T createProxy(Class<T> clazz)}</pre>
-	 *
 	 * <h4>Possible Return Values</h4>
 	 * <ul>
 	 * <li>the target return type, if it can be inferred</li>
@@ -134,27 +125,20 @@ public static Class<?> resolveReturnType(Method method, Class<?> clazz) {
 	 * Method#getGenericParameterTypes() formal argument list} for the given
 	 * method</li>
 	 * </ul>
-	 *
 	 * @param method the method to introspect, never {@code null}
 	 * @param args the arguments that will be supplied to the method when it is
 	 * invoked, never {@code null}
-	 * @return the resolved target return type, the standard return type, or
-	 * {@code null}
+	 * @return the resolved target return type, the standard return type, or {@code null}
 	 * @since 3.2
 	 * @see #resolveReturnType
 	 */
 	public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[] args) {
-		Assert.notNull(method, "method must not be null");
-		Assert.notNull(args, "args must not be null");
-
-		if (logger.isDebugEnabled()) {
-			logger.debug(String.format("Resolving return type for [%s] with concrete method arguments [%s].",
-				method.toGenericString(), ObjectUtils.nullSafeToString(args)));
-		}
+		Assert.notNull(method, "Method must not be null");
+		Assert.notNull(args, "Argument array must not be null");
 
-		final TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters();
-		final Type genericReturnType = method.getGenericReturnType();
-		final Type[] methodArgumentTypes = method.getGenericParameterTypes();
+		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters();
+		Type genericReturnType = method.getGenericReturnType();
+		Type[] methodArgumentTypes = method.getGenericParameterTypes();
 
 		// No declared type variables to inspect, so just return the standard return type.
 		if (declaredTypeVariables.length == 0) {
@@ -172,11 +156,6 @@ public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[]
 		boolean locallyDeclaredTypeVariableMatchesReturnType = false;
 		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {
 			if (currentTypeVariable.equals(genericReturnType)) {
-				if (logger.isDebugEnabled()) {
-					logger.debug(String.format(
-						"Found declared type variable [%s] that matches the target return type [%s].",
-						currentTypeVariable, genericReturnType));
-				}
 				locallyDeclaredTypeVariableMatchesReturnType = true;
 				break;
 			}
@@ -184,39 +163,20 @@ public static Class<?> resolveReturnTypeForGenericMethod(Method method, Object[]
 
 		if (locallyDeclaredTypeVariableMatchesReturnType) {
 			for (int i = 0; i < methodArgumentTypes.length; i++) {
-				final Type currentMethodArgumentType = methodArgumentTypes[i];
-
+				Type currentMethodArgumentType = methodArgumentTypes[i];
 				if (currentMethodArgumentType.equals(genericReturnType)) {
-					if (logger.isDebugEnabled()) {
-						logger.debug(String.format(
-							"Found method argument type at index [%s] that matches the target return type.", i));
-					}
 					return args[i].getClass();
 				}
-
 				if (currentMethodArgumentType instanceof ParameterizedType) {
 					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType;
 					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
-
-					for (int j = 0; j < actualTypeArguments.length; j++) {
-						final Type typeArg = actualTypeArguments[j];
-
+					for (Type typeArg : actualTypeArguments) {
 						if (typeArg.equals(genericReturnType)) {
-							if (logger.isDebugEnabled()) {
-								logger.debug(String.format(
-									"Found method argument type at index [%s] that is parameterized with a type argument that matches the target return type.",
-									i));
-							}
-
 							if (args[i] instanceof Class) {
 								return (Class<?>) args[i];
-							} else {
-								// Consider adding logic to determine the class of the
-								// J'th typeArg, if possible.
-								logger.info(String.format(
-									"Could not determine the target type for type argument [%s] for method [%s].",
-									typeArg, method.toGenericString()));
-
+							}
+							else {
+								// Consider adding logic to determine the class of the typeArg, if possible.
 								// For now, just fall back...
 								return method.getReturnType();
 							}
@@ -409,8 +369,7 @@ static Type getRawType(Type genericType, Map<TypeVariable, Type> typeVariableMap
 	 * all super types, enclosing types and interfaces.
 	 */
 	public static Map<TypeVariable, Type> getTypeVariableMap(Class clazz) {
-		Map<TypeVariable, Type> ref = typeVariableCache.get(clazz);
-		Map<TypeVariable, Type> typeVariableMap = (ref != null ? ref : null);
+		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz);
 
 		if (typeVariableMap == null) {
 			typeVariableMap = new HashMap<TypeVariable, Type>();
diff --git a/spring-core/src/main/java/org/springframework/core/NamedInheritableThreadLocal.java b/spring-core/src/main/java/org/springframework/core/NamedInheritableThreadLocal.java
index bb7cfb8937a4..3d30f24615b7 100644
--- a/spring-core/src/main/java/org/springframework/core/NamedInheritableThreadLocal.java
+++ b/spring-core/src/main/java/org/springframework/core/NamedInheritableThreadLocal.java
@@ -45,4 +45,4 @@ public String toString() {
 		return this.name;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java
index a1701c9db138..e177856e821d 100644
--- a/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java
+++ b/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java
@@ -20,6 +20,7 @@
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Method;
 
+import java.util.List;
 import java.util.Map;
 import java.util.WeakHashMap;
 
@@ -240,14 +241,58 @@ public static <A extends Annotation> A findAnnotation(Class<?> clazz, Class<A> a
 	 * if not found
 	 * @see Class#isAnnotationPresent(Class)
 	 * @see Class#getDeclaredAnnotations()
+	 * @see #findAnnotationDeclaringClassForTypes(List, Class)
+	 * @see #isAnnotationDeclaredLocally(Class, Class)
 	 */
 	public static Class<?> findAnnotationDeclaringClass(Class<? extends Annotation> annotationType, Class<?> clazz) {
 		Assert.notNull(annotationType, "Annotation type must not be null");
 		if (clazz == null || clazz.equals(Object.class)) {
 			return null;
 		}
-		return (isAnnotationDeclaredLocally(annotationType, clazz)) ? clazz :
-				findAnnotationDeclaringClass(annotationType, clazz.getSuperclass());
+		return (isAnnotationDeclaredLocally(annotationType, clazz)) ? clazz : findAnnotationDeclaringClass(
+			annotationType, clazz.getSuperclass());
+	}
+
+	/**
+	 * Find the first {@link Class} in the inheritance hierarchy of the specified
+	 * {@code clazz} (including the specified {@code clazz} itself) which declares
+	 * at least one of the specified {@code annotationTypes}, or {@code null} if
+	 * none of the specified annotation types could be found.
+	 * <p>If the supplied {@code clazz} is {@code null}, {@code null} will be
+	 * returned.
+	 * <p>If the supplied {@code clazz} is an interface, only the interface itself
+	 * will be checked; the inheritance hierarchy for interfaces will not be traversed.
+	 * <p>The standard {@link Class} API does not provide a mechanism for determining
+	 * which class in an inheritance hierarchy actually declares one of several
+	 * candidate {@linkplain Annotation annotations}, so we need to handle this
+	 * explicitly.
+	 * @param annotationTypes the list of Class objects corresponding to the
+	 * annotation types
+	 * @param clazz the Class object corresponding to the class on which to check
+	 * for the annotations, or {@code null}
+	 * @return the first {@link Class} in the inheritance hierarchy of the specified
+	 * {@code clazz} which declares an annotation of at least one of the specified
+	 * {@code annotationTypes}, or {@code null} if not found
+	 * @see Class#isAnnotationPresent(Class)
+	 * @see Class#getDeclaredAnnotations()
+	 * @see #findAnnotationDeclaringClass(Class, Class)
+	 * @see #isAnnotationDeclaredLocally(Class, Class)
+	 * @since 3.2.2
+	 */
+	public static Class<?> findAnnotationDeclaringClassForTypes(List<Class<? extends Annotation>> annotationTypes,
+			Class<?> clazz) {
+		Assert.notEmpty(annotationTypes, "The list of annotation types must not be empty");
+		if (clazz == null || clazz.equals(Object.class)) {
+			return null;
+		}
+
+		for (Class<? extends Annotation> annotationType : annotationTypes) {
+			if (isAnnotationDeclaredLocally(annotationType, clazz)) {
+				return clazz;
+			}
+		}
+
+		return findAnnotationDeclaringClassForTypes(annotationTypes, clazz.getSuperclass());
 	}
 
 	/**
@@ -348,8 +393,8 @@ public static Map<String, Object> getAnnotationAttributes(Annotation annotation,
 	 * and corresponding attribute values as values
 	 * @since 3.1.1
 	 */
-	public static AnnotationAttributes getAnnotationAttributes(
-			Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {
+	public static AnnotationAttributes getAnnotationAttributes(Annotation annotation, boolean classValuesAsString,
+			boolean nestedAnnotationsAsMap) {
 
 		AnnotationAttributes attrs = new AnnotationAttributes();
 		Method[] methods = annotation.annotationType().getDeclaredMethods();
@@ -371,15 +416,15 @@ else if (value instanceof Class[]) {
 						}
 					}
 					if (nestedAnnotationsAsMap && value instanceof Annotation) {
-						attrs.put(method.getName(), getAnnotationAttributes(
-								(Annotation)value, classValuesAsString, nestedAnnotationsAsMap));
+						attrs.put(method.getName(),
+							getAnnotationAttributes((Annotation) value, classValuesAsString, nestedAnnotationsAsMap));
 					}
 					else if (nestedAnnotationsAsMap && value instanceof Annotation[]) {
-						Annotation[] realAnnotations = (Annotation[])value;
+						Annotation[] realAnnotations = (Annotation[]) value;
 						AnnotationAttributes[] mappedAnnotations = new AnnotationAttributes[realAnnotations.length];
 						for (int i = 0; i < realAnnotations.length; i++) {
-							mappedAnnotations[i] = getAnnotationAttributes(
-									realAnnotations[i], classValuesAsString, nestedAnnotationsAsMap);
+							mappedAnnotations[i] = getAnnotationAttributes(realAnnotations[i], classValuesAsString,
+								nestedAnnotationsAsMap);
 						}
 						attrs.put(method.getName(), mappedAnnotations);
 					}
diff --git a/spring-core/src/main/java/org/springframework/core/convert/support/StringToEnumConverterFactory.java b/spring-core/src/main/java/org/springframework/core/convert/support/StringToEnumConverterFactory.java
index 62cf4748eae4..7326b3f045f5 100644
--- a/spring-core/src/main/java/org/springframework/core/convert/support/StringToEnumConverterFactory.java
+++ b/spring-core/src/main/java/org/springframework/core/convert/support/StringToEnumConverterFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2009 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@
 
 import org.springframework.core.convert.converter.Converter;
 import org.springframework.core.convert.converter.ConverterFactory;
+import org.springframework.util.Assert;
 
 /**
  * Converts from a String to a java.lang.Enum by calling {@link Enum#valueOf(Class, String)}.
@@ -29,7 +30,13 @@
 final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {
 
 	public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
-		return new StringToEnum(targetType);
+		Class<?> enumType = targetType;
+		while(enumType != null && !enumType.isEnum()) {
+			enumType = enumType.getSuperclass();
+		}
+		Assert.notNull(enumType, "The target type " + targetType.getName()
+				+ " does not refer to an enum");
+		return new StringToEnum(enumType);
 	}
 
 	private class StringToEnum<T extends Enum> implements Converter<String, T> {
diff --git a/spring-core/src/main/java/org/springframework/core/env/MapPropertySource.java b/spring-core/src/main/java/org/springframework/core/env/MapPropertySource.java
index 54f5bad4c5f0..b8b62706c1bd 100644
--- a/spring-core/src/main/java/org/springframework/core/env/MapPropertySource.java
+++ b/spring-core/src/main/java/org/springframework/core/env/MapPropertySource.java
@@ -41,4 +41,4 @@ public String[] getPropertyNames() {
 		return this.source.keySet().toArray(EMPTY_NAMES_ARRAY);
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-core/src/main/java/org/springframework/core/env/SimpleCommandLineArgsParser.java b/spring-core/src/main/java/org/springframework/core/env/SimpleCommandLineArgsParser.java
index d0e219799873..b7ad3c42d9a7 100644
--- a/spring-core/src/main/java/org/springframework/core/env/SimpleCommandLineArgsParser.java
+++ b/spring-core/src/main/java/org/springframework/core/env/SimpleCommandLineArgsParser.java
@@ -83,4 +83,4 @@ public CommandLineArgs parse(String... args) {
 		return commandLineArgs;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-core/src/main/java/org/springframework/core/env/SystemEnvironmentPropertySource.java b/spring-core/src/main/java/org/springframework/core/env/SystemEnvironmentPropertySource.java
index 09082aad5c22..0baba6a8c196 100644
--- a/spring-core/src/main/java/org/springframework/core/env/SystemEnvironmentPropertySource.java
+++ b/spring-core/src/main/java/org/springframework/core/env/SystemEnvironmentPropertySource.java
@@ -88,10 +88,6 @@ public boolean containsProperty(String name) {
 	public Object getProperty(String name) {
 		Assert.notNull(name, "property name must not be null");
 		String actualName = resolvePropertyName(name);
-		if (actualName == null) {
-			// at this point we know the property does not exist
-			return null;
-		}
 		if (logger.isDebugEnabled() && !name.equals(actualName)) {
 			logger.debug(String.format(
 					"PropertySource [%s] does not contain '%s', but found equivalent '%s'",
diff --git a/spring-core/src/main/java/org/springframework/core/io/VfsUtils.java b/spring-core/src/main/java/org/springframework/core/io/VfsUtils.java
index 863c8d73ead1..8c9a7aa195ce 100644
--- a/spring-core/src/main/java/org/springframework/core/io/VfsUtils.java
+++ b/spring-core/src/main/java/org/springframework/core/io/VfsUtils.java
@@ -257,4 +257,4 @@ protected static Object doGetVisitorAttribute() {
 	protected static String doGetPath(Object resource) {
 		return (String) ReflectionUtils.invokeMethod(VIRTUAL_FILE_METHOD_GET_PATH_NAME, resource);
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java b/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java
index 9b2f8493b669..89e8b69be48b 100644
--- a/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java
+++ b/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -658,6 +658,7 @@ public static Set<Resource> findMatchingResources(
 	/**
 	 * VFS visitor for path matching purposes.
 	 */
+	@SuppressWarnings("unused")
 	private static class PatternVirtualFileVisitor implements InvocationHandler {
 
 		private final String subPattern;
diff --git a/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationAttributesReadingVisitor.java b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationAttributesReadingVisitor.java
index cdf49fd6b609..77a8fef3a0ef 100644
--- a/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationAttributesReadingVisitor.java
+++ b/spring-core/src/main/java/org/springframework/core/type/classreading/AnnotationAttributesReadingVisitor.java
@@ -258,4 +258,4 @@ private void registerMetaAnnotations(Class<?> annotationClass) {
 			this.metaAnnotationMap.put(annotationClass.getName(), metaAnnotationTypeNames);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-core/src/main/java/org/springframework/core/type/classreading/MethodMetadataReadingVisitor.java b/spring-core/src/main/java/org/springframework/core/type/classreading/MethodMetadataReadingVisitor.java
index 4cae5b582935..58256b6049d5 100644
--- a/spring-core/src/main/java/org/springframework/core/type/classreading/MethodMetadataReadingVisitor.java
+++ b/spring-core/src/main/java/org/springframework/core/type/classreading/MethodMetadataReadingVisitor.java
@@ -97,4 +97,4 @@ public AnnotationAttributes getAnnotationAttributes(String annotationType) {
 	public String getDeclaringClassName() {
 		return this.declaringClassName;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-core/src/main/java/org/springframework/core/type/classreading/SimpleMetadataReader.java b/spring-core/src/main/java/org/springframework/core/type/classreading/SimpleMetadataReader.java
index b2bf4405da72..af2d4c62d86b 100644
--- a/spring-core/src/main/java/org/springframework/core/type/classreading/SimpleMetadataReader.java
+++ b/spring-core/src/main/java/org/springframework/core/type/classreading/SimpleMetadataReader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 import java.io.InputStream;
 
 import org.springframework.asm.ClassReader;
+import org.springframework.core.NestedIOException;
 import org.springframework.core.io.Resource;
 import org.springframework.core.type.AnnotationMetadata;
 import org.springframework.core.type.ClassMetadata;
@@ -47,10 +48,14 @@ final class SimpleMetadataReader implements MetadataReader {
 
 	SimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException {
 		InputStream is = new BufferedInputStream(resource.getInputStream());
-		ClassReader classReader = null;
+		ClassReader classReader;
 		try {
 			classReader = new ClassReader(is);
 		}
+		catch (IllegalArgumentException ex) {
+			throw new NestedIOException("ASM ClassReader failed to parse class file - " +
+					"probably due to a new Java class file version that isn't supported yet: " + resource, ex);
+		}
 		finally {
 			is.close();
 		}
@@ -64,6 +69,7 @@ final class SimpleMetadataReader implements MetadataReader {
 		this.resource = resource;
 	}
 
+
 	public Resource getResource() {
 		return this.resource;
 	}
diff --git a/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java
index 0ae86e087925..e7fefa175d9d 100644
--- a/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java
+++ b/spring-core/src/main/java/org/springframework/util/AntPathMatcher.java
@@ -317,7 +317,9 @@ else if (!StringUtils.hasText(pattern1)) {
 		else if (!StringUtils.hasText(pattern2)) {
 			return pattern1;
 		}
-		else if (!pattern1.equals(pattern2) && !pattern1.contains("{") && match(pattern1, pattern2)) {
+
+		boolean pattern1ContainsUriVar = pattern1.indexOf('{') != -1;
+		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {
 			// /* + /hotel -> /hotel ; "/*.*" + "/*.html" -> /*.html
 			// However /user + /user -> /usr/user ; /{foo} + /bar -> /{foo}/bar
 			return pattern2;
@@ -344,7 +346,7 @@ else if (pattern1.endsWith("/**")) {
 		}
 		else {
 			int dotPos1 = pattern1.indexOf('.');
-			if (dotPos1 == -1) {
+			if (dotPos1 == -1 || pattern1ContainsUriVar) {
 				// simply concatenate the two patterns
 				if (pattern1.endsWith("/") || pattern2.startsWith("/")) {
 					return pattern1 + pattern2;
diff --git a/spring-core/src/main/java/org/springframework/util/Assert.java b/spring-core/src/main/java/org/springframework/util/Assert.java
index 05c1c4babe2c..193d461a0547 100644
--- a/spring-core/src/main/java/org/springframework/util/Assert.java
+++ b/spring-core/src/main/java/org/springframework/util/Assert.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -334,8 +334,9 @@ public static void isInstanceOf(Class clazz, Object obj) {
 	public static void isInstanceOf(Class type, Object obj, String message) {
 		notNull(type, "Type to check against must not be null");
 		if (!type.isInstance(obj)) {
-			throw new IllegalArgumentException(message +
-					". Object of class [" + (obj != null ? obj.getClass().getName() : "null") +
+			throw new IllegalArgumentException(
+					(StringUtils.hasLength(message) ? message + " " : "") +
+					"Object of class [" + (obj != null ? obj.getClass().getName() : "null") +
 					"] must be an instance of " + type);
 		}
 	}
diff --git a/spring-core/src/main/java/org/springframework/util/CompositeIterator.java b/spring-core/src/main/java/org/springframework/util/CompositeIterator.java
index 1e70018f5c20..97142514c742 100644
--- a/spring-core/src/main/java/org/springframework/util/CompositeIterator.java
+++ b/spring-core/src/main/java/org/springframework/util/CompositeIterator.java
@@ -72,4 +72,4 @@ public E next() {
 	public void remove() {
 		throw new UnsupportedOperationException("Remove is not supported");
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-core/src/main/java/org/springframework/util/FileCopyUtils.java b/spring-core/src/main/java/org/springframework/util/FileCopyUtils.java
index 5aac30908663..2c14da3b517d 100644
--- a/spring-core/src/main/java/org/springframework/util/FileCopyUtils.java
+++ b/spring-core/src/main/java/org/springframework/util/FileCopyUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,19 +31,19 @@
 import java.io.Writer;
 
 /**
- * Simple utility methods for file and stream copying.
- * All copy methods use a block size of 4096 bytes,
- * and close all affected streams when done.
+ * Simple utility methods for file and stream copying. All copy methods use a block size
+ * of 4096 bytes, and close all affected streams when done. A variation of the copy
+ * methods from this class that leave streams open can be found in {@link StreamUtils}.
  *
- * <p>Mainly for use within the framework,
- * but also useful for application code.
+ * <p>Mainly for use within the framework, but also useful for application code.
  *
  * @author Juergen Hoeller
  * @since 06.10.2003
+ * @see StreamUtils
  */
 public abstract class FileCopyUtils {
 
-	public static final int BUFFER_SIZE = 4096;
+	public static final int BUFFER_SIZE = StreamUtils.BUFFER_SIZE;
 
 
 	//---------------------------------------------------------------------
@@ -106,15 +106,7 @@ public static int copy(InputStream in, OutputStream out) throws IOException {
 		Assert.notNull(in, "No InputStream specified");
 		Assert.notNull(out, "No OutputStream specified");
 		try {
-			int byteCount = 0;
-			byte[] buffer = new byte[BUFFER_SIZE];
-			int bytesRead = -1;
-			while ((bytesRead = in.read(buffer)) != -1) {
-				out.write(buffer, 0, bytesRead);
-				byteCount += bytesRead;
-			}
-			out.flush();
-			return byteCount;
+			return StreamUtils.copy(in, out);
 		}
 		finally {
 			try {
@@ -208,7 +200,7 @@ public static int copy(Reader in, Writer out) throws IOException {
 
 	/**
 	 * Copy the contents of the given String to the given output Writer.
-	 * Closes the write when done.
+	 * Closes the writer when done.
 	 * @param in the String to copy from
 	 * @param out the Writer to copy to
 	 * @throws IOException in case of I/O errors
diff --git a/spring-core/src/main/java/org/springframework/util/ObjectUtils.java b/spring-core/src/main/java/org/springframework/util/ObjectUtils.java
index 3ec361741887..09980f1e2ca7 100644
--- a/spring-core/src/main/java/org/springframework/util/ObjectUtils.java
+++ b/spring-core/src/main/java/org/springframework/util/ObjectUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -481,7 +481,7 @@ public static int nullSafeHashCode(short[] array) {
 	}
 
 	/**
-	 * Return the same value as {@code {@link Boolean#hashCode()}}.
+	 * Return the same value as {@link Boolean#hashCode()}}.
 	 * @see Boolean#hashCode()
 	 */
 	public static int hashCode(boolean bool) {
@@ -489,7 +489,7 @@ public static int hashCode(boolean bool) {
 	}
 
 	/**
-	 * Return the same value as {@code {@link Double#hashCode()}}.
+	 * Return the same value as {@link Double#hashCode()}}.
 	 * @see Double#hashCode()
 	 */
 	public static int hashCode(double dbl) {
@@ -498,7 +498,7 @@ public static int hashCode(double dbl) {
 	}
 
 	/**
-	 * Return the same value as {@code {@link Float#hashCode()}}.
+	 * Return the same value as {@link Float#hashCode()}}.
 	 * @see Float#hashCode()
 	 */
 	public static int hashCode(float flt) {
@@ -506,7 +506,7 @@ public static int hashCode(float flt) {
 	}
 
 	/**
-	 * Return the same value as {@code {@link Long#hashCode()}}.
+	 * Return the same value as {@link Long#hashCode()}}.
 	 * @see Long#hashCode()
 	 */
 	public static int hashCode(long lng) {
diff --git a/spring-core/src/main/java/org/springframework/util/StreamUtils.java b/spring-core/src/main/java/org/springframework/util/StreamUtils.java
new file mode 100644
index 000000000000..cc3107d81ff0
--- /dev/null
+++ b/spring-core/src/main/java/org/springframework/util/StreamUtils.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.util;
+
+import java.io.ByteArrayOutputStream;
+import java.io.FilterInputStream;
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.nio.charset.Charset;
+
+
+/**
+ * Simple utility methods for dealing with streams. The copy methods of this class are
+ * similar to those defined in {@link FileCopyUtils} except that all affected streams are
+ * left open when done. All copy methods use a block size of 4096 bytes.
+ *
+ * <p>Mainly for use within the framework, but also useful for application code.
+ *
+ * @author Juergen Hoeller
+ * @author Phillip Webb
+ * @since 3.2.2
+ * @see FileCopyUtils
+ */
+public abstract class StreamUtils {
+
+	public static final int BUFFER_SIZE = 4096;
+
+
+	/**
+	 * Copy the contents of the given InputStream into a new byte array.
+	 * Leaves the stream open when done.
+	 * @param in the stream to copy from
+	 * @return the new byte array that has been copied to
+	 * @throws IOException in case of I/O errors
+	 */
+	public static byte[] copyToByteArray(InputStream in) throws IOException {
+		ByteArrayOutputStream out = new ByteArrayOutputStream(BUFFER_SIZE);
+		copy(in, out);
+		return out.toByteArray();
+	}
+
+	/**
+	 * Copy the contents of the given InputStream into a String.
+	 * Leaves the stream open when done.
+	 * @param in the InputStream to copy from
+	 * @return the String that has been copied to
+	 * @throws IOException in case of I/O errors
+	 */
+	public static String copyToString(InputStream in, Charset charset) throws IOException {
+		Assert.notNull(in, "No InputStream specified");
+		StringBuilder out = new StringBuilder();
+		InputStreamReader reader = new InputStreamReader(in, charset);
+		char[] buffer = new char[BUFFER_SIZE];
+		int bytesRead = -1;
+		while ((bytesRead = reader.read(buffer)) != -1) {
+			out.append(buffer, 0, bytesRead);
+		}
+		return out.toString();
+	}
+
+	/**
+	 * Copy the contents of the given byte array to the given OutputStream.
+	 * Leaves the stream open when done.
+	 * @param in the byte array to copy from
+	 * @param out the OutputStream to copy to
+	 * @throws IOException in case of I/O errors
+	 */
+	public static void copy(byte[] in, OutputStream out) throws IOException {
+		Assert.notNull(in, "No input byte array specified");
+		Assert.notNull(out, "No OutputStream specified");
+		out.write(in);
+	}
+
+	/**
+	 * Copy the contents of the given String to the given output OutputStream.
+	 * Leaves the stream open when done.
+	 * @param in the String to copy from
+	 * @param charset the Charset
+	 * @param out the OutputStream to copy to
+	 * @throws IOException in case of I/O errors
+	 */
+	public static void copy(String in, Charset charset, OutputStream out) throws IOException {
+		Assert.notNull(in, "No input String specified");
+		Assert.notNull(charset, "No charset specified");
+		Assert.notNull(out, "No OutputStream specified");
+		Writer writer = new OutputStreamWriter(out, charset);
+		writer.write(in);
+		writer.flush();
+	}
+
+	/**
+	 * Copy the contents of the given InputStream to the given OutputStream.
+	 * Leaves both streams open when done.
+	 * @param in the InputStream to copy from
+	 * @param out the OutputStream to copy to
+	 * @return the number of bytes copied
+	 * @throws IOException in case of I/O errors
+	 */
+	public static int copy(InputStream in, OutputStream out) throws IOException {
+		Assert.notNull(in, "No InputStream specified");
+		Assert.notNull(out, "No OutputStream specified");
+		int byteCount = 0;
+		byte[] buffer = new byte[BUFFER_SIZE];
+		int bytesRead = -1;
+		while ((bytesRead = in.read(buffer)) != -1) {
+			out.write(buffer, 0, bytesRead);
+			byteCount += bytesRead;
+		}
+		out.flush();
+		return byteCount;
+	}
+
+	/**
+	 * Returns a variant of the given {@link InputStream} where calling
+	 * {@link InputStream#close() close()} has no effect.
+	 * @param in the InputStream to decorate
+	 * @return a version of the InputStream that ignores calls to close
+	 */
+	public static InputStream nonClosing(InputStream in) {
+		Assert.notNull(in, "No InputStream specified");
+		return new NonClosingInputStream(in);
+	}
+
+	/**
+	 * Returns a variant of the given {@link OutputStream} where calling
+	 * {@link OutputStream#close() close()} has no effect.
+	 * @param out the OutputStream to decorate
+	 * @return a version of the OutputStream that ignores calls to close
+	 */
+	public static OutputStream nonClosing(OutputStream out) {
+		Assert.notNull(out, "No OutputStream specified");
+		return new NonClosingOutputStream(out);
+	}
+
+
+	private static class NonClosingInputStream extends FilterInputStream {
+
+		public NonClosingInputStream(InputStream in) {
+			super(in);
+		}
+
+		@Override
+		public void close() throws IOException {
+		}
+	}
+
+
+	private static class NonClosingOutputStream extends FilterOutputStream {
+
+		public NonClosingOutputStream(OutputStream out) {
+			super(out);
+		}
+
+		@Override
+		public void write(byte[] b, int off, int let) throws IOException {
+			// It is critical that we override this method for performance
+			out.write(b, off, let);
+		}
+
+		@Override
+		public void close() throws IOException {
+		}
+	}
+}
diff --git a/spring-core/src/main/java/org/springframework/util/xml/StaxResult.java b/spring-core/src/main/java/org/springframework/util/xml/StaxResult.java
index c001902252aa..801769cdfab1 100644
--- a/spring-core/src/main/java/org/springframework/util/xml/StaxResult.java
+++ b/spring-core/src/main/java/org/springframework/util/xml/StaxResult.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,24 +24,24 @@
 import org.xml.sax.ContentHandler;
 
 /**
- * Implementation of the {@code Result} tagging interface for StAX writers. Can be constructed with a
- * {@code XMLEventConsumer} or a {@code XMLStreamWriter}.
+ * Implementation of the {@code Result} tagging interface for StAX writers. Can be constructed with
+ * an {@code XMLEventConsumer} or an {@code XMLStreamWriter}.
  *
- * <p>This class is necessary because there is no implementation of {@code Source} for StaxReaders in JAXP 1.3.
- * There is a {@code StAXResult} in JAXP 1.4 (JDK 1.6), but this class is kept around for back-ward compatibility
- * reasons.
+ * <p>This class is necessary because there is no implementation of {@code Source} for StaxReaders
+ * in JAXP 1.3. There is a {@code StAXResult} in JAXP 1.4 (JDK 1.6), but this class is kept around
+ * for backwards compatibility reasons.
  *
  * <p>Even though {@code StaxResult} extends from {@code SAXResult}, calling the methods of
- * {@code SAXResult} is <strong>not supported</strong>. In general, the only supported operation on this class is
- * to use the {@code ContentHandler} obtained via {@link #getHandler()} to parse an input source using an
- * {@code XMLReader}. Calling {@link #setHandler(org.xml.sax.ContentHandler)} will result in
- * {@code UnsupportedOperationException}s.
+ * {@code SAXResult} is <strong>not supported</strong>. In general, the only supported operation
+ * on this class is to use the {@code ContentHandler} obtained via {@link #getHandler()} to parse an
+ * input source using an {@code XMLReader}. Calling {@link #setHandler(org.xml.sax.ContentHandler)}
+ * will result in {@code UnsupportedOperationException}s.
  *
  * @author Arjen Poutsma
+ * @since 3.0
  * @see XMLEventWriter
  * @see XMLStreamWriter
  * @see javax.xml.transform.Transformer
- * @since 3.0
  */
 class StaxResult extends SAXResult {
 
@@ -49,9 +49,9 @@ class StaxResult extends SAXResult {
 
 	private XMLStreamWriter streamWriter;
 
+
 	/**
-	 * Constructs a new instance of the {@code StaxResult} with the specified {@code XMLStreamWriter}.
-	 *
+	 * Construct a new instance of the {@code StaxResult} with the specified {@code XMLStreamWriter}.
 	 * @param streamWriter the {@code XMLStreamWriter} to write to
 	 */
 	StaxResult(XMLStreamWriter streamWriter) {
@@ -60,8 +60,7 @@ class StaxResult extends SAXResult {
 	}
 
 	/**
-	 * Constructs a new instance of the {@code StaxResult} with the specified {@code XMLEventWriter}.
-	 *
+	 * Construct a new instance of the {@code StaxResult} with the specified {@code XMLEventWriter}.
 	 * @param eventWriter the {@code XMLEventWriter} to write to
 	 */
 	StaxResult(XMLEventWriter eventWriter) {
@@ -70,9 +69,8 @@ class StaxResult extends SAXResult {
 	}
 
 	/**
-	 * Constructs a new instance of the {@code StaxResult} with the specified {@code XMLEventWriter} and
-	 * {@code XMLEventFactory}.
-	 *
+	 * Construct a new instance of the {@code StaxResult} with the specified {@code XMLEventWriter}
+	 * and {@code XMLEventFactory}.
 	 * @param eventWriter  the {@code XMLEventWriter} to write to
 	 * @param eventFactory the {@code XMLEventFactory} to use for creating events
 	 */
@@ -81,35 +79,35 @@ class StaxResult extends SAXResult {
 		this.eventWriter = eventWriter;
 	}
 
+
 	/**
-	 * Returns the {@code XMLEventWriter} used by this {@code StaxResult}. If this {@code StaxResult} was
-	 * created with an {@code XMLStreamWriter}, the result will be {@code null}.
-	 *
+	 * Return the {@code XMLEventWriter} used by this {@code StaxResult}. If this {@code StaxResult}
+	 * was created with an {@code XMLStreamWriter}, the result will be {@code null}.
 	 * @return the StAX event writer used by this result
 	 * @see #StaxResult(javax.xml.stream.XMLEventWriter)
 	 */
 	XMLEventWriter getXMLEventWriter() {
-		return eventWriter;
+		return this.eventWriter;
 	}
 
 	/**
-	 * Returns the {@code XMLStreamWriter} used by this {@code StaxResult}. If this {@code StaxResult} was
-	 * created with an {@code XMLEventConsumer}, the result will be {@code null}.
-	 *
+	 * Return the {@code XMLStreamWriter} used by this {@code StaxResult}. If this {@code StaxResult}
+	 * was created with an {@code XMLEventConsumer}, the result will be {@code null}.
 	 * @return the StAX stream writer used by this result
 	 * @see #StaxResult(javax.xml.stream.XMLStreamWriter)
 	 */
 	XMLStreamWriter getXMLStreamWriter() {
-		return streamWriter;
+		return this.streamWriter;
 	}
 
+
 	/**
-	 * Throws a {@code UnsupportedOperationException}.
-	 *
+	 * Throws an {@code UnsupportedOperationException}.
 	 * @throws UnsupportedOperationException always
 	 */
 	@Override
 	public void setHandler(ContentHandler handler) {
 		throw new UnsupportedOperationException("setHandler is not supported");
 	}
+
 }
diff --git a/spring-core/src/main/java/org/springframework/util/xml/StaxSource.java b/spring-core/src/main/java/org/springframework/util/xml/StaxSource.java
index af005ecc1497..5706a4317ed5 100644
--- a/spring-core/src/main/java/org/springframework/util/xml/StaxSource.java
+++ b/spring-core/src/main/java/org/springframework/util/xml/StaxSource.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,24 +24,24 @@
 import org.xml.sax.XMLReader;
 
 /**
- * Implementation of the {@code Source} tagging interface for StAX readers. Can be constructed with a
- * {@code XMLEventReader} or a {@code XMLStreamReader}.
+ * Implementation of the {@code Source} tagging interface for StAX readers. Can be constructed with
+ * an {@code XMLEventReader} or an {@code XMLStreamReader}.
  *
- * <p>This class is necessary because there is no implementation of {@code Source} for StAX Readers in JAXP 1.3.
- * There is a {@code StAXSource} in JAXP 1.4 (JDK 1.6), but this class is kept around for back-ward compatibility
- * reasons.
+ * <p>This class is necessary because there is no implementation of {@code Source} for StAX Readers
+ * in JAXP 1.3. There is a {@code StAXSource} in JAXP 1.4 (JDK 1.6), but this class is kept around
+ * for backwards compatibility reasons.
  *
  * <p>Even though {@code StaxSource} extends from {@code SAXSource}, calling the methods of
- * {@code SAXSource} is <strong>not supported</strong>. In general, the only supported operation on this class is
- * to use the {@code XMLReader} obtained via {@link #getXMLReader()} to parse the input source obtained via {@link
- * #getInputSource()}. Calling {@link #setXMLReader(XMLReader)} or {@link #setInputSource(InputSource)} will result in
- * {@code UnsupportedOperationException}s.
+ * {@code SAXSource} is <strong>not supported</strong>. In general, the only supported operation
+ * on this class is to use the {@code XMLReader} obtained via {@link #getXMLReader()} to parse the
+ * input source obtained via {@link #getInputSource()}. Calling {@link #setXMLReader(XMLReader)}
+ * or {@link #setInputSource(InputSource)} will result in {@code UnsupportedOperationException}s.
  *
  * @author Arjen Poutsma
+ * @since 3.0
  * @see XMLEventReader
  * @see XMLStreamReader
  * @see javax.xml.transform.Transformer
- * @since 3.0
  */
 class StaxSource extends SAXSource {
 
@@ -49,11 +49,11 @@ class StaxSource extends SAXSource {
 
 	private XMLStreamReader streamReader;
 
+
 	/**
-	 * Constructs a new instance of the {@code StaxSource} with the specified {@code XMLStreamReader}. The
-	 * supplied stream reader must be in {@code XMLStreamConstants.START_DOCUMENT} or
+	 * Construct a new instance of the {@code StaxSource} with the specified {@code XMLStreamReader}.
+	 * The supplied stream reader must be in {@code XMLStreamConstants.START_DOCUMENT} or
 	 * {@code XMLStreamConstants.START_ELEMENT} state.
-	 *
 	 * @param streamReader the {@code XMLStreamReader} to read from
 	 * @throws IllegalStateException if the reader is not at the start of a document or element
 	 */
@@ -63,10 +63,9 @@ class StaxSource extends SAXSource {
 	}
 
 	/**
-	 * Constructs a new instance of the {@code StaxSource} with the specified {@code XMLEventReader}. The
-	 * supplied event reader must be in {@code XMLStreamConstants.START_DOCUMENT} or
+	 * Construct a new instance of the {@code StaxSource} with the specified {@code XMLEventReader}.
+	 * The supplied event reader must be in {@code XMLStreamConstants.START_DOCUMENT} or
 	 * {@code XMLStreamConstants.START_ELEMENT} state.
-	 *
 	 * @param eventReader the {@code XMLEventReader} to read from
 	 * @throws IllegalStateException if the reader is not at the start of a document or element
 	 */
@@ -75,31 +74,30 @@ class StaxSource extends SAXSource {
 		this.eventReader = eventReader;
 	}
 
+
 	/**
-	 * Returns the {@code XMLEventReader} used by this {@code StaxSource}. If this {@code StaxSource} was
-	 * created with an {@code XMLStreamReader}, the result will be {@code null}.
-	 *
+	 * Return the {@code XMLEventReader} used by this {@code StaxSource}. If this {@code StaxSource}
+	 * was created with an {@code XMLStreamReader}, the result will be {@code null}.
 	 * @return the StAX event reader used by this source
 	 * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)
 	 */
 	XMLEventReader getXMLEventReader() {
-		return eventReader;
+		return this.eventReader;
 	}
 
 	/**
-	 * Returns the {@code XMLStreamReader} used by this {@code StaxSource}. If this {@code StaxSource} was
-	 * created with an {@code XMLEventReader}, the result will be {@code null}.
-	 *
+	 * Return the {@code XMLStreamReader} used by this {@code StaxSource}. If this {@code StaxSource}
+	 * was created with an {@code XMLEventReader}, the result will be {@code null}.
 	 * @return the StAX event reader used by this source
 	 * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)
 	 */
 	XMLStreamReader getXMLStreamReader() {
-		return streamReader;
+		return this.streamReader;
 	}
 
+
 	/**
-	 * Throws a {@code UnsupportedOperationException}.
-	 *
+	 * Throws an {@code UnsupportedOperationException}.
 	 * @throws UnsupportedOperationException always
 	 */
 	@Override
@@ -108,12 +106,12 @@ public void setInputSource(InputSource inputSource) {
 	}
 
 	/**
-	 * Throws a {@code UnsupportedOperationException}.
-	 *
+	 * Throws an {@code UnsupportedOperationException}.
 	 * @throws UnsupportedOperationException always
 	 */
 	@Override
 	public void setXMLReader(XMLReader reader) {
 		throw new UnsupportedOperationException("setXMLReader is not supported");
 	}
+
 }
diff --git a/spring-core/src/main/java/org/springframework/util/xml/StaxUtils.java b/spring-core/src/main/java/org/springframework/util/xml/StaxUtils.java
index 576f39ebcf56..efafa259d43c 100644
--- a/spring-core/src/main/java/org/springframework/util/xml/StaxUtils.java
+++ b/spring-core/src/main/java/org/springframework/util/xml/StaxUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -45,14 +45,15 @@
  */
 public abstract class StaxUtils {
 
+	// JAXP 1.4 is only available on JDK 1.6+
 	private static boolean jaxp14Available =
 			ClassUtils.isPresent("javax.xml.transform.stax.StAXSource", StaxUtils.class.getClassLoader());
 
+
 	// Stax Source
 
 	/**
 	 * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLStreamReader}.
-	 *
 	 * @param streamReader the StAX stream reader
 	 * @return a source wrapping the {@code streamReader}
 	 */
@@ -62,9 +63,8 @@ public static Source createCustomStaxSource(XMLStreamReader streamReader) {
 
 	/**
 	 * Create a StAX {@link Source} for the given {@link XMLStreamReader}.
-	 *
-	 * <p>If JAXP 1.4 is available, this method returns a {@link StAXSource}; otherwise it returns a
-	 * custom StAX Source.
+	 * <p>If JAXP 1.4 is available, this method returns a {@link StAXSource};
+	 * otherwise it returns a custom StAX Source.
 	 * @param streamReader the StAX stream reader
 	 * @return a source wrapping the {@code streamReader}
 	 * @see #createCustomStaxSource(XMLStreamReader)
@@ -80,7 +80,6 @@ public static Source createStaxSource(XMLStreamReader streamReader) {
 
 	/**
 	 * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLEventReader}.
-	 *
 	 * @param eventReader the StAX event reader
 	 * @return a source wrapping the {@code eventReader}
 	 */
@@ -90,9 +89,8 @@ public static Source createCustomStaxSource(XMLEventReader eventReader) {
 
 	/**
 	 * Create a StAX {@link Source} for the given {@link XMLEventReader}.
-	 *
-	 * <p>If JAXP 1.4 is available, this method returns a {@link StAXSource}; otherwise it returns a
-	 * custom StAX Source.
+	 * <p>If JAXP 1.4 is available, this method returns a {@link StAXSource};
+	 * otherwise it returns a custom StAX Source.
 	 * @param eventReader the StAX event reader
 	 * @return a source wrapping the {@code eventReader}
 	 * @throws XMLStreamException in case of StAX errors
@@ -116,11 +114,11 @@ public static boolean isStaxSource(Source source) {
 		return (source instanceof StaxSource || (jaxp14Available && Jaxp14StaxHandler.isStaxSource(source)));
 	}
 
+
 	// Stax Result
 
 	/**
 	 * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLStreamWriter}.
-	 *
 	 * @param streamWriter the StAX stream writer
 	 * @return a source wrapping the {@code streamWriter}
 	 */
@@ -130,9 +128,8 @@ public static Result createCustomStaxResult(XMLStreamWriter streamWriter) {
 
 	/**
 	 * Create a StAX {@link Result} for the given {@link XMLStreamWriter}.
-	 *
-	 * <p>If JAXP 1.4 is available, this method returns a {@link StAXResult}; otherwise it returns a
-	 * custom StAX Result.
+	 * <p>If JAXP 1.4 is available, this method returns a {@link StAXResult};
+	 * otherwise it returns a custom StAX Result.
 	 * @param streamWriter the StAX stream writer
 	 * @return a result wrapping the {@code streamWriter}
 	 * @see #createCustomStaxResult(XMLStreamWriter)
@@ -148,7 +145,6 @@ public static Result createStaxResult(XMLStreamWriter streamWriter) {
 
 	/**
 	 * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLEventWriter}.
-	 *
 	 * @param eventWriter the StAX event writer
 	 * @return a source wrapping the {@code eventWriter}
 	 */
@@ -158,7 +154,6 @@ public static Result createCustomStaxResult(XMLEventWriter eventWriter) {
 
 	/**
 	 * Create a StAX {@link Result} for the given {@link XMLEventWriter}.
-	 *
 	 * <p>If JAXP 1.4 is available, this method returns a {@link StAXResult}; otherwise it returns a
 	 * custom StAX Result.
 	 * @param eventWriter the StAX event writer
@@ -177,8 +172,8 @@ public static Result createStaxResult(XMLEventWriter eventWriter) throws XMLStre
 
 	/**
 	 * Indicate whether the given {@link javax.xml.transform.Result} is a StAX Result.
-	 * @return {@code true} if {@code result} is a custom Stax Result or JAXP
-	 * 1.4 {@link StAXResult}; {@code false} otherwise.
+	 * @return {@code true} if {@code result} is a custom Stax Result or JAXP 1.4
+	 * {@link StAXResult}; {@code false} otherwise.
 	 */
 	public static boolean isStaxResult(Result result) {
 		return (result instanceof StaxResult || (jaxp14Available && Jaxp14StaxHandler.isStaxResult(result)));
@@ -327,6 +322,7 @@ public static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter
 		return new XMLEventStreamWriter(eventWriter, eventFactory);
 	}
 
+
 	/**
 	 * Inner class to avoid a static JAXP 1.4 dependency.
 	 */
@@ -349,11 +345,11 @@ private static Result createStaxResult(XMLEventWriter eventWriter) {
 		}
 
 		private static boolean isStaxSource(Source source) {
-			return source instanceof StAXSource;
+			return (source instanceof StAXSource);
 		}
 
 		private static boolean isStaxResult(Result result) {
-			return result instanceof StAXResult;
+			return (result instanceof StAXResult);
 		}
 
 		private static XMLStreamReader getXMLStreamReader(Source source) {
diff --git a/spring-core/src/test/java/org/springframework/core/BridgeMethodResolverTests.java b/spring-core/src/test/java/org/springframework/core/BridgeMethodResolverTests.java
index c013f3d3db5d..dbca8b7b5b3f 100644
--- a/spring-core/src/test/java/org/springframework/core/BridgeMethodResolverTests.java
+++ b/spring-core/src/test/java/org/springframework/core/BridgeMethodResolverTests.java
@@ -560,6 +560,7 @@ public static interface GenericParameter<T> {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class StringGenericParameter implements GenericParameter<String> {
 
 		@Override
@@ -1163,6 +1164,7 @@ private static class Other<S,E> {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class MegaMessageProducerImpl extends Other<Long, String> implements MegaMessageProducer {
 
 		public void receive(NewMegaMessageEvent event) {
@@ -1198,6 +1200,7 @@ public interface IGenericInterface<D extends DomainObjectSuper> {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static abstract class AbstractImplementsInterface<D extends DomainObjectSuper> implements IGenericInterface<D> {
 
 		@Override
diff --git a/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java b/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java
index 0c5d88f33436..9f7e76b0c92d 100644
--- a/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java
+++ b/spring-core/src/test/java/org/springframework/core/annotation/AnnotationUtilsTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,21 +16,26 @@
 
 package org.springframework.core.annotation;
 
+import static org.junit.Assert.*;
+import static org.springframework.core.annotation.AnnotationUtils.*;
+
+import java.lang.annotation.Annotation;
 import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Method;
 
+import java.util.Arrays;
+import java.util.List;
+
 import org.junit.Test;
 
 import org.springframework.core.Ordered;
 import org.springframework.stereotype.Component;
 
-import static org.junit.Assert.*;
-
-import static org.springframework.core.annotation.AnnotationUtils.*;
-
 /**
+ * Unit tests for {@link AnnotationUtils}.
+ *
  * @author Rod Johnson
  * @author Juergen Hoeller
  * @author Sam Brannen
@@ -102,23 +107,91 @@ public void testFindAnnotationDeclaringClass() throws Exception {
 		assertNull(findAnnotationDeclaringClass(Transactional.class, NonAnnotatedClass.class));
 
 		// inherited class-level annotation; note: @Transactional is inherited
-		assertEquals(InheritedAnnotationInterface.class, findAnnotationDeclaringClass(Transactional.class,
-				InheritedAnnotationInterface.class));
+		assertEquals(InheritedAnnotationInterface.class,
+			findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationInterface.class));
 		assertNull(findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationInterface.class));
-		assertEquals(InheritedAnnotationClass.class, findAnnotationDeclaringClass(Transactional.class,
-				InheritedAnnotationClass.class));
-		assertEquals(InheritedAnnotationClass.class, findAnnotationDeclaringClass(Transactional.class,
-				SubInheritedAnnotationClass.class));
+		assertEquals(InheritedAnnotationClass.class,
+			findAnnotationDeclaringClass(Transactional.class, InheritedAnnotationClass.class));
+		assertEquals(InheritedAnnotationClass.class,
+			findAnnotationDeclaringClass(Transactional.class, SubInheritedAnnotationClass.class));
 
 		// non-inherited class-level annotation; note: @Order is not inherited,
-		// but findAnnotationDeclaringClass() should still find it.
-		assertEquals(NonInheritedAnnotationInterface.class, findAnnotationDeclaringClass(Order.class,
-				NonInheritedAnnotationInterface.class));
+		// but findAnnotationDeclaringClass() should still find it on classes.
+		assertEquals(NonInheritedAnnotationInterface.class,
+			findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationInterface.class));
 		assertNull(findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationInterface.class));
-		assertEquals(NonInheritedAnnotationClass.class, findAnnotationDeclaringClass(Order.class,
-				NonInheritedAnnotationClass.class));
-		assertEquals(NonInheritedAnnotationClass.class, findAnnotationDeclaringClass(Order.class,
-				SubNonInheritedAnnotationClass.class));
+		assertEquals(NonInheritedAnnotationClass.class,
+			findAnnotationDeclaringClass(Order.class, NonInheritedAnnotationClass.class));
+		assertEquals(NonInheritedAnnotationClass.class,
+			findAnnotationDeclaringClass(Order.class, SubNonInheritedAnnotationClass.class));
+	}
+
+	@Test
+	public void findAnnotationDeclaringClassForTypesWithSingleCandidateType() {
+
+		// no class-level annotation
+		List<Class<? extends Annotation>> transactionalCandidateList = Arrays.<Class<? extends Annotation>> asList(Transactional.class);
+		assertNull(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedInterface.class));
+		assertNull(findAnnotationDeclaringClassForTypes(transactionalCandidateList, NonAnnotatedClass.class));
+
+		// inherited class-level annotation; note: @Transactional is inherited
+		assertEquals(InheritedAnnotationInterface.class,
+			findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationInterface.class));
+		assertNull(findAnnotationDeclaringClassForTypes(transactionalCandidateList,
+			SubInheritedAnnotationInterface.class));
+		assertEquals(InheritedAnnotationClass.class,
+			findAnnotationDeclaringClassForTypes(transactionalCandidateList, InheritedAnnotationClass.class));
+		assertEquals(InheritedAnnotationClass.class,
+			findAnnotationDeclaringClassForTypes(transactionalCandidateList, SubInheritedAnnotationClass.class));
+
+		// non-inherited class-level annotation; note: @Order is not inherited,
+		// but findAnnotationDeclaringClassForTypes() should still find it on classes.
+		List<Class<? extends Annotation>> orderCandidateList = Arrays.<Class<? extends Annotation>> asList(Order.class);
+		assertEquals(NonInheritedAnnotationInterface.class,
+			findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationInterface.class));
+		assertNull(findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationInterface.class));
+		assertEquals(NonInheritedAnnotationClass.class,
+			findAnnotationDeclaringClassForTypes(orderCandidateList, NonInheritedAnnotationClass.class));
+		assertEquals(NonInheritedAnnotationClass.class,
+			findAnnotationDeclaringClassForTypes(orderCandidateList, SubNonInheritedAnnotationClass.class));
+	}
+
+	@Test
+	public void findAnnotationDeclaringClassForTypesWithMultipleCandidateTypes() {
+
+		List<Class<? extends Annotation>> candidates = Arrays.<Class<? extends Annotation>> asList(Transactional.class,
+			Order.class);
+
+		// no class-level annotation
+		assertNull(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedInterface.class));
+		assertNull(findAnnotationDeclaringClassForTypes(candidates, NonAnnotatedClass.class));
+
+		// inherited class-level annotation; note: @Transactional is inherited
+		assertEquals(InheritedAnnotationInterface.class,
+			findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationInterface.class));
+		assertNull(findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationInterface.class));
+		assertEquals(InheritedAnnotationClass.class,
+			findAnnotationDeclaringClassForTypes(candidates, InheritedAnnotationClass.class));
+		assertEquals(InheritedAnnotationClass.class,
+			findAnnotationDeclaringClassForTypes(candidates, SubInheritedAnnotationClass.class));
+
+		// non-inherited class-level annotation; note: @Order is not inherited,
+		// but findAnnotationDeclaringClassForTypes() should still find it on classes.
+		assertEquals(NonInheritedAnnotationInterface.class,
+			findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationInterface.class));
+		assertNull(findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationInterface.class));
+		assertEquals(NonInheritedAnnotationClass.class,
+			findAnnotationDeclaringClassForTypes(candidates, NonInheritedAnnotationClass.class));
+		assertEquals(NonInheritedAnnotationClass.class,
+			findAnnotationDeclaringClassForTypes(candidates, SubNonInheritedAnnotationClass.class));
+
+		// class hierarchy mixed with @Transactional and @Order declarations
+		assertEquals(TransactionalClass.class,
+			findAnnotationDeclaringClassForTypes(candidates, TransactionalClass.class));
+		assertEquals(TransactionalAndOrderedClass.class,
+			findAnnotationDeclaringClassForTypes(candidates, TransactionalAndOrderedClass.class));
+		assertEquals(TransactionalAndOrderedClass.class,
+			findAnnotationDeclaringClassForTypes(candidates, SubTransactionalAndOrderedClass.class));
 	}
 
 	@Test
@@ -216,18 +289,18 @@ public void testFindAnnotationFromInterfaceWhenSuperDoesNotImplementMethod() thr
 	}
 
 
-	@Component(value="meta1")
+	@Component(value = "meta1")
 	@Retention(RetentionPolicy.RUNTIME)
 	@interface Meta1 {
 	}
 
-	@Component(value="meta2")
+	@Component(value = "meta2")
 	@Retention(RetentionPolicy.RUNTIME)
 	@interface Meta2 {
 	}
 
 	@Meta1
-	@Component(value="local")
+	@Component(value = "local")
 	@Meta2
 	static class HasLocalAndMetaComponentAnnotation {
 	}
@@ -332,6 +405,16 @@ public static class NonInheritedAnnotationClass {
 	public static class SubNonInheritedAnnotationClass extends NonInheritedAnnotationClass {
 	}
 
+	@Transactional
+	public static class TransactionalClass {
+	}
+
+	@Order
+	public static class TransactionalAndOrderedClass {
+	}
+
+	public static class SubTransactionalAndOrderedClass extends TransactionalAndOrderedClass {
+	}
 
 	public static interface InterfaceWithAnnotatedMethod {
 
@@ -353,10 +436,12 @@ public void foo() {
 		}
 	}
 
-	public abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod implements InterfaceWithAnnotatedMethod {
+	public abstract static class AbstractDoesNotImplementInterfaceWithAnnotatedMethod implements
+			InterfaceWithAnnotatedMethod {
 	}
 
-	public static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod extends AbstractDoesNotImplementInterfaceWithAnnotatedMethod {
+	public static class SubOfAbstractImplementsInterfaceWithAnnotatedMethod extends
+			AbstractDoesNotImplementInterfaceWithAnnotatedMethod {
 
 		@Override
 		public void foo() {
diff --git a/spring-core/src/test/java/org/springframework/core/convert/support/DefaultConversionTests.java b/spring-core/src/test/java/org/springframework/core/convert/support/DefaultConversionTests.java
index 7b2ff0490a11..ba42cddf9daa 100644
--- a/spring-core/src/test/java/org/springframework/core/convert/support/DefaultConversionTests.java
+++ b/spring-core/src/test/java/org/springframework/core/convert/support/DefaultConversionTests.java
@@ -17,6 +17,7 @@
 package org.springframework.core.convert.support;
 
 import static org.hamcrest.Matchers.equalTo;
+import static org.junit.Assert.*;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -212,6 +213,11 @@ public void testStringToEnum() throws Exception {
 		assertEquals(Foo.BAR, conversionService.convert("BAR", Foo.class));
 	}
 
+	@Test
+	public void testStringToEnumWithSubclss() throws Exception {
+		assertEquals(SubFoo.BAZ, conversionService.convert("BAZ", SubFoo.BAR.getClass()));
+	}
+
 	@Test
 	public void testStringToEnumEmptyString() {
 		assertEquals(null, conversionService.convert("", Foo.class));
@@ -226,6 +232,24 @@ public static enum Foo {
 		BAR, BAZ;
 	}
 
+	public static enum SubFoo {
+
+		BAR {
+			@Override
+			String s() {
+				return "x";
+			}
+		},
+		BAZ {
+			@Override
+			String s() {
+				return "y";
+			}
+		};
+
+		abstract String s();
+	}
+
 	@Test
 	public void testStringToLocale() {
 		assertEquals(Locale.ENGLISH, conversionService.convert("en", Locale.class));
diff --git a/spring-core/src/test/java/org/springframework/core/convert/support/GenericConversionServiceTests.java b/spring-core/src/test/java/org/springframework/core/convert/support/GenericConversionServiceTests.java
index 01dd03c77039..c08cdeebb775 100644
--- a/spring-core/src/test/java/org/springframework/core/convert/support/GenericConversionServiceTests.java
+++ b/spring-core/src/test/java/org/springframework/core/convert/support/GenericConversionServiceTests.java
@@ -358,7 +358,6 @@ public void testListOfList() {
 		GenericConversionService service = new DefaultConversionService();
 		List<String> list1 = Arrays.asList("Foo", "Bar");
 		List<String> list2 = Arrays.asList("Baz", "Boop");
-		@SuppressWarnings("unchecked")
 		List<List<String>> list = Arrays.asList(list1, list2);
 		String result = service.convert(list, String.class);
 		assertNotNull(result);
diff --git a/spring-core/src/test/java/org/springframework/core/enums/LabeledEnumTests.java b/spring-core/src/test/java/org/springframework/core/enums/LabeledEnumTests.java
index 4bd9a3f182d4..de0fccf46b51 100644
--- a/spring-core/src/test/java/org/springframework/core/enums/LabeledEnumTests.java
+++ b/spring-core/src/test/java/org/springframework/core/enums/LabeledEnumTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -104,7 +104,7 @@ public void testLabelFoundForAbstractEnums() {
 
 	public void testDoesNotMatchWrongClass() {
 		try {
-			LabeledEnum none = StaticLabeledEnumResolver.instance().getLabeledEnumByCode(Dog.class,
+			StaticLabeledEnumResolver.instance().getLabeledEnumByCode(Dog.class,
 					new Short((short) 1));
 			fail("Should have failed");
 		}
@@ -119,10 +119,11 @@ public void testEquals() {
 	}
 
 
-	@SuppressWarnings("serial")
+	@SuppressWarnings({ "serial", "unused" })
 	private static class Other extends StaticLabeledEnum {
 
 		public static final Other THING1 = new Other(1, "Thing1");
+
 		public static final Other THING2 = new Other(2, "Thing2");
 
 
diff --git a/spring-core/src/test/java/org/springframework/core/type/AnnotationTypeFilterTests.java b/spring-core/src/test/java/org/springframework/core/type/AnnotationTypeFilterTests.java
index e9d8c1e19de7..b316d1749e20 100644
--- a/spring-core/src/test/java/org/springframework/core/type/AnnotationTypeFilterTests.java
+++ b/spring-core/src/test/java/org/springframework/core/type/AnnotationTypeFilterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -122,10 +122,12 @@ private static interface SomeComponentInterface {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class SomeSubClassOfSomeComponentInterface implements SomeComponentInterface {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class SomeSubClassOfSomeComponent extends SomeComponent {
 	}
 
@@ -139,10 +141,12 @@ private static class SomeClassMarkedWithNonInheritedAnnotation {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation extends SomeClassMarkedWithNonInheritedAnnotation {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class SomeNonCandidateClass {
 	}
 
diff --git a/spring-core/src/test/java/org/springframework/core/type/AssignableTypeFilterTests.java b/spring-core/src/test/java/org/springframework/core/type/AssignableTypeFilterTests.java
index 0ca007ea2ef4..cc624af1b87f 100644
--- a/spring-core/src/test/java/org/springframework/core/type/AssignableTypeFilterTests.java
+++ b/spring-core/src/test/java/org/springframework/core/type/AssignableTypeFilterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -81,6 +81,7 @@ private static interface TestInterface {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class TestInterfaceImpl implements TestInterface {
 	}
 
@@ -89,6 +90,7 @@ private static interface SomeDaoLikeInterface {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class SomeDaoLikeImpl extends SimpleJdbcDaoSupport implements SomeDaoLikeInterface {
 	}
 
diff --git a/spring-core/src/test/java/org/springframework/core/type/CachingMetadataReaderLeakTest.java b/spring-core/src/test/java/org/springframework/core/type/CachingMetadataReaderLeakTest.java
index db0b50242d1d..1d138b76f633 100644
--- a/spring-core/src/test/java/org/springframework/core/type/CachingMetadataReaderLeakTest.java
+++ b/spring-core/src/test/java/org/springframework/core/type/CachingMetadataReaderLeakTest.java
@@ -31,7 +31,7 @@
 import org.springframework.tests.TestGroup;
 
 /**
- * Unit test checking the behaviour of {@link CachingMetadataReaderFactory under load.
+ * Unit test checking the behaviour of {@link CachingMetadataReaderFactory} under load.
  * If the cache is not controller, this test should fail with an out of memory exception around entry
  * 5k.
  *
diff --git a/spring-core/src/test/java/org/springframework/tests/TestGroup.java b/spring-core/src/test/java/org/springframework/tests/TestGroup.java
index dcc376eea494..662f0dab532f 100644
--- a/spring-core/src/test/java/org/springframework/tests/TestGroup.java
+++ b/spring-core/src/test/java/org/springframework/tests/TestGroup.java
@@ -21,6 +21,10 @@
 import java.util.HashSet;
 import java.util.Set;
 
+import org.springframework.util.StringUtils;
+
+import static java.lang.String.*;
+
 /**
  * A test group used to limit when certain tests are run.
  *
@@ -44,7 +48,13 @@ public enum TestGroup {
 	 * {@code StopWatch}, etc. should be considered a candidate as their successful
 	 * execution is likely to be based on events occurring within a given time window.
 	 */
-	PERFORMANCE;
+	PERFORMANCE,
+
+	/**
+	 * Tests requiring the presence of jmxremote_optional.jar in jre/lib/ext in order to
+	 * avoid "Unsupported protocol: jmxmp" errors.
+	 */
+	JMXMP;
 
 
 	/**
@@ -64,8 +74,10 @@ public static Set<TestGroup> parse(String value) {
 			try {
 				groups.add(valueOf(group.trim().toUpperCase()));
 			} catch (IllegalArgumentException e) {
-				throw new IllegalArgumentException("Unable to find test group '" + group.trim()
-						+ "' when parsing '" + value + "'");
+				throw new IllegalArgumentException(format(
+						"Unable to find test group '%s' when parsing testGroups value: '%s'. " +
+						"Available groups include: [%s]", group.trim(), value,
+						StringUtils.arrayToCommaDelimitedString(TestGroup.values())));
 			}
 		}
 		return groups;
diff --git a/spring-core/src/test/java/org/springframework/tests/TestGroupTests.java b/spring-core/src/test/java/org/springframework/tests/TestGroupTests.java
index 2b4860fd7284..7f9fe924c4b4 100644
--- a/spring-core/src/test/java/org/springframework/tests/TestGroupTests.java
+++ b/spring-core/src/test/java/org/springframework/tests/TestGroupTests.java
@@ -62,7 +62,9 @@ public void parseInMixedCase() throws Exception {
 	@Test
 	public void parseMissing() throws Exception {
 		thrown.expect(IllegalArgumentException.class);
-		thrown.expectMessage("Unable to find test group 'missing' when parsing 'performance, missing'");
+		thrown.expectMessage("Unable to find test group 'missing' when parsing " +
+				"testGroups value: 'performance, missing'. Available groups include: " +
+				"[LONG_RUNNING,PERFORMANCE,JMXMP]");
 		TestGroup.parse("performance, missing");
 	}
 
diff --git a/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java b/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java
index 0a34e1c470ce..05a98f405d4c 100644
--- a/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java
+++ b/spring-core/src/test/java/org/springframework/util/AntPathMatcherTests.java
@@ -412,6 +412,7 @@ public void combine() {
 		assertEquals("/*.html", pathMatcher.combine("/*.*", "/*.html"));
 		assertEquals("/{foo}/bar", pathMatcher.combine("/{foo}", "/bar"));	// SPR-8858
 		assertEquals("/user/user", pathMatcher.combine("/user", "/user"));	// SPR-7970
+		assertEquals("/{foo:.*[^0-9].*}/edit/", pathMatcher.combine("/{foo:.*[^0-9].*}", "/edit/")); // SPR-10062
 	}
 
 	@Test
diff --git a/spring-core/src/test/java/org/springframework/util/AssertTests.java b/spring-core/src/test/java/org/springframework/util/AssertTests.java
index 744b492f6170..0dfe86f1dceb 100644
--- a/spring-core/src/test/java/org/springframework/util/AssertTests.java
+++ b/spring-core/src/test/java/org/springframework/util/AssertTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,7 +24,9 @@
 import java.util.Map;
 import java.util.Set;
 
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 
 /**
  * Unit tests for the {@link Assert} class.
@@ -36,6 +38,9 @@
  */
 public class AssertTests {
 
+	@Rule
+	public ExpectedException thrown = ExpectedException.none();
+
 	@Test(expected = IllegalArgumentException.class)
 	public void instanceOf() {
 		final Set<?> set = new HashSet<Object>();
@@ -43,6 +48,22 @@ public void instanceOf() {
 		Assert.isInstanceOf(HashMap.class, set);
 	}
 
+	@Test
+	public void instanceOfNoMessage() throws Exception {
+		thrown.expect(IllegalArgumentException.class);
+		thrown.expectMessage("Object of class [java.lang.Object] must be an instance " +
+				"of interface java.util.Set");
+		Assert.isInstanceOf(Set.class, new Object(), null);
+	}
+
+	@Test
+	public void instanceOfMessage() throws Exception {
+		thrown.expect(IllegalArgumentException.class);
+		thrown.expectMessage("Custom message. Object of class [java.lang.Object] must " +
+				"be an instance of interface java.util.Set");
+		Assert.isInstanceOf(Set.class, new Object(), "Custom message.");
+	}
+
 	@Test
 	public void isNullDoesNotThrowExceptionIfArgumentIsNullWithMessage() {
 		Assert.isNull(null, "Bla");
diff --git a/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java b/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java
index f4078360de67..ce187d7c71b2 100644
--- a/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java
+++ b/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java
@@ -308,19 +308,25 @@ public static void argStaticMethod(String anArg) {
 		}
 	}
 
+	@SuppressWarnings("unused")
 	private static class OverloadedMethodsClass {
+
 		public void print(String messages) {
 			/* no-op */
 		}
+
 		public void print(String[] messages) {
 			/* no-op */
 		}
 	}
 
-	private static class SubOverloadedMethodsClass extends OverloadedMethodsClass{
+	@SuppressWarnings("unused")
+	private static class SubOverloadedMethodsClass extends OverloadedMethodsClass {
+
 		public void print(String header, String[] messages) {
 			/* no-op */
 		}
+
 		void print(String header, String[] messages, String footer) {
 			/* no-op */
 		}
diff --git a/spring-core/src/test/java/org/springframework/util/MethodInvokerTests.java b/spring-core/src/test/java/org/springframework/util/MethodInvokerTests.java
index 2fa0245aa17e..679ab9566ed1 100644
--- a/spring-core/src/test/java/org/springframework/util/MethodInvokerTests.java
+++ b/spring-core/src/test/java/org/springframework/util/MethodInvokerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -191,6 +191,7 @@ public static String supertypes2(Collection<?> c, List<?> l, String s, String s2
 	}
 
 
+	@SuppressWarnings("unused")
 	public static class Greeter {
 
 		// should handle Salesman (only interface)
diff --git a/spring-core/src/test/java/org/springframework/util/StopWatchTests.java b/spring-core/src/test/java/org/springframework/util/StopWatchTests.java
index e7d745d416ae..4170f556245e 100644
--- a/spring-core/src/test/java/org/springframework/util/StopWatchTests.java
+++ b/spring-core/src/test/java/org/springframework/util/StopWatchTests.java
@@ -1,6 +1,6 @@
 
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -34,7 +34,6 @@ public void testValidUsage() throws Exception {
 		String name1 = "Task 1";
 		String name2 = "Task 2";
 
-		long fudgeFactor = 5L;
 		assertFalse(sw.isRunning());
 		sw.start(name1);
 		Thread.sleep(int1);
@@ -44,6 +43,7 @@ public void testValidUsage() throws Exception {
 		// TODO are timings off in JUnit? Why do these assertions sometimes fail
 		// under both Ant and Eclipse?
 
+		//long fudgeFactor = 5L;
 		//assertTrue("Unexpected timing " + sw.getTotalTime(), sw.getTotalTime() >= int1);
 		//assertTrue("Unexpected timing " + sw.getTotalTime(), sw.getTotalTime() <= int1 + fudgeFactor);
 		sw.start(name2);
@@ -72,7 +72,6 @@ public void testValidUsageNotKeepingTaskList() throws Exception {
 		String name1 = "Task 1";
 		String name2 = "Task 2";
 
-		long fudgeFactor = 5L;
 		assertFalse(sw.isRunning());
 		sw.start(name1);
 		Thread.sleep(int1);
@@ -82,6 +81,7 @@ public void testValidUsageNotKeepingTaskList() throws Exception {
 		// TODO are timings off in JUnit? Why do these assertions sometimes fail
 		// under both Ant and Eclipse?
 
+		//long fudgeFactor = 5L;
 		//assertTrue("Unexpected timing " + sw.getTotalTime(), sw.getTotalTime() >= int1);
 		//assertTrue("Unexpected timing " + sw.getTotalTime(), sw.getTotalTime() <= int1 + fudgeFactor);
 		sw.start(name2);
diff --git a/spring-core/src/test/java/org/springframework/util/StreamUtilsTests.java b/spring-core/src/test/java/org/springframework/util/StreamUtilsTests.java
new file mode 100644
index 000000000000..61810c98ec64
--- /dev/null
+++ b/spring-core/src/test/java/org/springframework/util/StreamUtilsTests.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.util;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.charset.Charset;
+import java.util.Random;
+import java.util.UUID;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.InOrder;
+
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
+/**
+ * Tests for {@link StreamUtils}.
+ *
+ * @author Phillip Webb
+ */
+public class StreamUtilsTests {
+
+	private byte[] bytes = new byte[StreamUtils.BUFFER_SIZE + 10];
+
+	private String string = "";
+
+	@Before
+	public void setup() {
+		new Random().nextBytes(bytes);
+		while (string.length() < StreamUtils.BUFFER_SIZE + 10) {
+			string += UUID.randomUUID().toString();
+		}
+	}
+
+	@Test
+	public void copyToByteArray() throws Exception {
+		InputStream inputStream = spy(new ByteArrayInputStream(bytes));
+		byte[] actual = StreamUtils.copyToByteArray(inputStream);
+		assertThat(actual, equalTo(bytes));
+		verify(inputStream, never()).close();
+	}
+
+	@Test
+	public void copyToString() throws Exception {
+		Charset charset = Charset.defaultCharset();
+		InputStream inputStream = spy(new ByteArrayInputStream(string.getBytes(charset)));
+		String actual = StreamUtils.copyToString(inputStream, charset);
+		assertThat(actual, equalTo(string));
+		verify(inputStream, never()).close();
+	}
+
+	@Test
+	public void copyBytes() throws Exception {
+		ByteArrayOutputStream out = spy(new ByteArrayOutputStream());
+		StreamUtils.copy(bytes, out);
+		assertThat(out.toByteArray(), equalTo(bytes));
+		verify(out, never()).close();
+	}
+
+	@Test
+	public void copyString() throws Exception {
+		Charset charset = Charset.defaultCharset();
+		ByteArrayOutputStream out = spy(new ByteArrayOutputStream());
+		StreamUtils.copy(string, charset, out);
+		assertThat(out.toByteArray(), equalTo(string.getBytes(charset)));
+		verify(out, never()).close();
+	}
+
+	@Test
+	public void copyStream() throws Exception {
+		ByteArrayOutputStream out = spy(new ByteArrayOutputStream());
+		StreamUtils.copy(new ByteArrayInputStream(bytes), out);
+		assertThat(out.toByteArray(), equalTo(bytes));
+		verify(out, never()).close();
+	}
+
+	@Test
+	public void nonClosingInputStream() throws Exception {
+		InputStream source = mock(InputStream.class);
+		InputStream nonClosing = StreamUtils.nonClosing(source);
+		nonClosing.read();
+		nonClosing.read(bytes);
+		nonClosing.read(bytes, 1, 2);
+		nonClosing.close();
+		InOrder ordered = inOrder(source);
+		ordered.verify(source).read();
+		ordered.verify(source).read(bytes, 0, bytes.length);
+		ordered.verify(source).read(bytes, 1, 2);
+		ordered.verify(source, never()).close();
+	}
+
+	@Test
+	public void nonClosingOutputStream() throws Exception {
+		OutputStream source = mock(OutputStream.class);
+		OutputStream nonClosing = StreamUtils.nonClosing(source);
+		nonClosing.write(1);
+		nonClosing.write(bytes);
+		nonClosing.write(bytes, 1, 2);
+		nonClosing.close();
+		InOrder ordered = inOrder(source);
+		ordered.verify(source).write(1);
+		ordered.verify(source).write(bytes, 0, bytes.length);
+		ordered.verify(source).write(bytes, 1, 2);
+		ordered.verify(source, never()).close();
+	}
+}
diff --git a/spring-core/src/test/java/org/springframework/util/xml/AbstractStaxXMLReaderTestCase.java b/spring-core/src/test/java/org/springframework/util/xml/AbstractStaxXMLReaderTestCase.java
index 0c3b9f0e49de..3ced43ba0ce9 100644
--- a/spring-core/src/test/java/org/springframework/util/xml/AbstractStaxXMLReaderTestCase.java
+++ b/spring-core/src/test/java/org/springframework/util/xml/AbstractStaxXMLReaderTestCase.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,6 @@
 
 package org.springframework.util.xml;
 
-import static org.mockito.BDDMockito.willAnswer;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-
 import java.io.InputStream;
 
 import javax.xml.stream.XMLInputFactory;
@@ -44,6 +38,8 @@
 import org.xml.sax.helpers.AttributesImpl;
 import org.xml.sax.helpers.XMLReaderFactory;
 
+import static org.mockito.BDDMockito.*;
+
 public abstract class AbstractStaxXMLReaderTestCase {
 
 	protected static XMLInputFactory inputFactory;
diff --git a/spring-core/src/test/java/org/springframework/util/xml/StaxEventXMLReaderTests.java b/spring-core/src/test/java/org/springframework/util/xml/StaxEventXMLReaderTests.java
index 5a34a003ee25..355cb94438b4 100644
--- a/spring-core/src/test/java/org/springframework/util/xml/StaxEventXMLReaderTests.java
+++ b/spring-core/src/test/java/org/springframework/util/xml/StaxEventXMLReaderTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,9 @@
 
 package org.springframework.util.xml;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.InputStream;
 import java.io.StringReader;
+
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
@@ -29,6 +27,8 @@
 import org.xml.sax.InputSource;
 import org.xml.sax.helpers.AttributesImpl;
 
+import static org.mockito.BDDMockito.*;
+
 public class StaxEventXMLReaderTests extends AbstractStaxXMLReaderTestCase {
 
 	public static final String CONTENT = "<root xmlns='http://springframework.org/spring-ws'><child/></root>";
diff --git a/spring-core/src/test/java/org/springframework/util/xml/StaxStreamXMLReaderTests.java b/spring-core/src/test/java/org/springframework/util/xml/StaxStreamXMLReaderTests.java
index ba84eadd760f..e074085f6d7b 100644
--- a/spring-core/src/test/java/org/springframework/util/xml/StaxStreamXMLReaderTests.java
+++ b/spring-core/src/test/java/org/springframework/util/xml/StaxStreamXMLReaderTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,23 +18,22 @@
 
 import java.io.InputStream;
 import java.io.StringReader;
+
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.XMLStreamReader;
 
-import static org.junit.Assert.*;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import org.junit.Test;
 import org.xml.sax.Attributes;
 import org.xml.sax.ContentHandler;
 import org.xml.sax.InputSource;
 import org.xml.sax.Locator;
 
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.BDDMockito.*;
+
 public class StaxStreamXMLReaderTests extends AbstractStaxXMLReaderTestCase {
 
 	public static final String CONTENT = "<root xmlns='http://springframework.org/spring-ws'><child/></root>";
diff --git a/spring-expression/src/main/java/org/springframework/expression/MethodFilter.java b/spring-expression/src/main/java/org/springframework/expression/MethodFilter.java
index e273125d34db..50992dd79805 100644
--- a/spring-expression/src/main/java/org/springframework/expression/MethodFilter.java
+++ b/spring-expression/src/main/java/org/springframework/expression/MethodFilter.java
@@ -43,4 +43,4 @@ public interface MethodFilter {
 	 */
 	List<Method> filter(List<Method> methods);
 
-}
\ No newline at end of file
+}
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/SpelMessage.java b/spring-expression/src/main/java/org/springframework/expression/spel/SpelMessage.java
index d9ae1a2efb13..3f89bed5121c 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/SpelMessage.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/SpelMessage.java
@@ -109,7 +109,8 @@ public enum SpelMessage {
 	OPERAND_NOT_DECREMENTABLE(Kind.ERROR,1067,"the expression component ''{0}'' does not support decrement"), //
 	NOT_ASSIGNABLE(Kind.ERROR,1068,"the expression component ''{0}'' is not assignable"), //
 	MISSING_CHARACTER(Kind.ERROR,1069,"missing expected character ''{0}''"),
-	LEFT_OPERAND_PROBLEM(Kind.ERROR,1070, "Problem parsing left operand");
+	LEFT_OPERAND_PROBLEM(Kind.ERROR,1070, "Problem parsing left operand"),
+	MISSING_SELECTION_EXPRESSION(Kind.ERROR, 1071, "A required selection expression has not been specified");
 
 	private Kind kind;
 	private int code;
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/SpelParserConfiguration.java b/spring-expression/src/main/java/org/springframework/expression/spel/SpelParserConfiguration.java
index c9e7bad2f1ee..ccadb93061b5 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/SpelParserConfiguration.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/SpelParserConfiguration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2009 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
  * Configuration object for the SpEL expression parser.
  *
  * @author Juergen Hoeller
+ * @author Phillip Webb
  * @since 3.0
  * @see org.springframework.expression.spel.standard.SpelExpressionParser#SpelExpressionParser(SpelParserConfiguration)
  */
@@ -29,19 +30,52 @@ public class SpelParserConfiguration {
 
 	private final boolean autoGrowCollections;
 
+	private int maximumAutoGrowSize;
 
+
+	/**
+	 * Create a new {@link SpelParserConfiguration} instance.
+	 * @param autoGrowNullReferences if null references should automatically grow
+	 * @param autoGrowCollections if collections should automatically grow
+	 * @see #SpelParserConfiguration(boolean, boolean, int)
+	 */
 	public SpelParserConfiguration(boolean autoGrowNullReferences, boolean autoGrowCollections) {
+		this(autoGrowNullReferences, autoGrowCollections, Integer.MAX_VALUE);
+	}
+
+	/**
+	 * Create a new {@link SpelParserConfiguration} instance.
+	 * @param autoGrowNullReferences if null references should automatically grow
+	 * @param autoGrowCollections if collections should automatically grow
+	 * @param maximumAutoGrowSize the maximum size that the collection can auto grow
+	 */
+	public SpelParserConfiguration(boolean autoGrowNullReferences,
+			boolean autoGrowCollections, int maximumAutoGrowSize) {
 		this.autoGrowNullReferences = autoGrowNullReferences;
 		this.autoGrowCollections = autoGrowCollections;
+		this.maximumAutoGrowSize = maximumAutoGrowSize;
 	}
 
 
+	/**
+	 * @return {@code true} if {@code null} references should be automatically grown
+	 */
 	public boolean isAutoGrowNullReferences() {
 		return this.autoGrowNullReferences;
 	}
 
+	/**
+	 * @return {@code true} if collections should be automatically grown
+	 */
 	public boolean isAutoGrowCollections() {
 		return this.autoGrowCollections;
 	}
 
+	/**
+	 * @return the maximum size that a collection can auto grow
+	 */
+	public int getMaximumAutoGrowSize() {
+		return this.maximumAutoGrowSize;
+	}
+
 }
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java
index 7ec464075d1e..b632adec5e7b 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java
@@ -36,6 +36,7 @@ public CompoundExpression(int pos,SpelNodeImpl... expressionComponents) {
 		}
 	}
 
+
 	@Override
 	protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {
 		if (getChildCount()==1) {
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java
index f0613262511e..2e19cc81e29c 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -38,6 +38,7 @@
  * (lists/sets)/arrays
  *
  * @author Andy Clement
+ * @author Phillip Webb
  * @since 3.0
  */
 // TODO support multidimensional arrays
@@ -257,25 +258,20 @@ private class CollectionIndexingValueRef implements ValueRef {
 
 		private final boolean growCollection;
 
+		private int maximumSize;
+
 		CollectionIndexingValueRef(Collection collection, int index, TypeDescriptor collectionEntryTypeDescriptor,
-				TypeConverter typeConverter, boolean growCollection) {
+				TypeConverter typeConverter, boolean growCollection, int maximumSize) {
 			this.collection = collection;
 			this.index = index;
 			this.collectionEntryTypeDescriptor = collectionEntryTypeDescriptor;
 			this.typeConverter = typeConverter;
 			this.growCollection = growCollection;
+			this.maximumSize = maximumSize;
 		}
 
 		public TypedValue getValue() {
-			if (this.index >= this.collection.size()) {
-				if (this.growCollection) {
-					growCollection(this.collectionEntryTypeDescriptor, this.index, this.collection);
-				}
-				else {
-					throw new SpelEvaluationException(getStartPosition(), SpelMessage.COLLECTION_INDEX_OUT_OF_BOUNDS,
-							this.collection.size(), this.index);
-				}
-			}
+			growCollectionIfNecessary();
 			if (this.collection instanceof List) {
 				Object o = ((List) this.collection).get(this.index);
 				return new TypedValue(o, this.collectionEntryTypeDescriptor.elementTypeDescriptor(o));
@@ -291,15 +287,7 @@ public TypedValue getValue() {
 		}
 
 		public void setValue(Object newValue) {
-			if (this.index >= this.collection.size()) {
-				if (this.growCollection) {
-					growCollection(this.collectionEntryTypeDescriptor, this.index, this.collection);
-				}
-				else {
-					throw new SpelEvaluationException(getStartPosition(), SpelMessage.COLLECTION_INDEX_OUT_OF_BOUNDS,
-							this.collection.size(), this.index);
-				}
-			}
+			growCollectionIfNecessary();
 			if (this.collection instanceof List) {
 				List list = (List) this.collection;
 				if (this.collectionEntryTypeDescriptor.getElementTypeDescriptor() != null) {
@@ -314,6 +302,36 @@ public void setValue(Object newValue) {
 			}
 		}
 
+		private void growCollectionIfNecessary() {
+			if (this.index >= this.collection.size()) {
+
+				if (!this.growCollection) {
+					throw new SpelEvaluationException(getStartPosition(), SpelMessage.COLLECTION_INDEX_OUT_OF_BOUNDS,
+							this.collection.size(), this.index);
+				}
+
+				if(this.index >= this.maximumSize) {
+					throw new SpelEvaluationException(getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION);
+				}
+
+				if (this.collectionEntryTypeDescriptor.getElementTypeDescriptor() == null) {
+					throw new SpelEvaluationException(getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION_UNKNOWN_ELEMENT_TYPE);
+				}
+
+				TypeDescriptor elementType = this.collectionEntryTypeDescriptor.getElementTypeDescriptor();
+				try {
+					int newElements = this.index - this.collection.size();
+					while (newElements >= 0) {
+						(this.collection).add(elementType.getType().newInstance());
+						newElements--;
+					}
+				}
+				catch (Exception ex) {
+					throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.UNABLE_TO_GROW_COLLECTION);
+				}
+			}
+		}
+
 		public boolean isWritable() {
 			return true;
 		}
@@ -403,7 +421,8 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException
 			}
 			else if (targetObject instanceof Collection) {
 				return new CollectionIndexingValueRef((Collection<?>) targetObject, idx, targetObjectTypeDescriptor,
-						state.getTypeConverter(), state.getConfiguration().isAutoGrowCollections());
+						state.getTypeConverter(), state.getConfiguration().isAutoGrowCollections(),
+						state.getConfiguration().getMaximumAutoGrowSize());
 			}
 			else if (targetObject instanceof String) {
 				return new StringIndexingLValue((String) targetObject, idx, targetObjectTypeDescriptor);
@@ -421,32 +440,6 @@ else if (targetObject instanceof String) {
 				targetObjectTypeDescriptor.toString());
 	}
 
-	/**
-	 * Attempt to grow the specified collection so that the specified index is valid.
-	 * @param targetType the type of the elements in the collection
-	 * @param index the index into the collection that needs to be valid
-	 * @param collection the collection to grow with elements
-	 */
-	private void growCollection(TypeDescriptor targetType, int index, Collection<Object> collection) {
-		if (targetType.getElementTypeDescriptor() == null) {
-			throw new SpelEvaluationException(getStartPosition(), SpelMessage.UNABLE_TO_GROW_COLLECTION_UNKNOWN_ELEMENT_TYPE);
-		}
-		TypeDescriptor elementType = targetType.getElementTypeDescriptor();
-		Object newCollectionElement;
-		try {
-			int newElements = index - collection.size();
-			while (newElements > 0) {
-				collection.add(elementType.getType().newInstance());
-				newElements--;
-			}
-			newCollectionElement = elementType.getType().newInstance();
-		}
-		catch (Exception ex) {
-			throw new SpelEvaluationException(getStartPosition(), ex, SpelMessage.UNABLE_TO_GROW_COLLECTION);
-		}
-		collection.add(newCollectionElement);
-	}
-
 	@Override
 	public String toStringAST() {
 		StringBuilder sb = new StringBuilder();
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/ast/Literal.java b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Literal.java
index 19ddf7caacb8..9b35a78a4031 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/ast/Literal.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Literal.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,23 +17,32 @@
 package org.springframework.expression.spel.ast;
 
 import org.springframework.expression.TypedValue;
-import org.springframework.expression.spel.*;
+import org.springframework.expression.spel.ExpressionState;
+import org.springframework.expression.spel.InternalParseException;
+import org.springframework.expression.spel.SpelEvaluationException;
+import org.springframework.expression.spel.SpelMessage;
+import org.springframework.expression.spel.SpelParseException;
 
 /**
  * Common superclass for nodes representing literals (boolean, string, number, etc).
  *
  * @author Andy Clement
+ * @author Juergen Hoeller
  */
 public abstract class Literal extends SpelNodeImpl {
 
-	protected String literalValue;
+	private final String originalValue;
 
-	public Literal(String payload, int pos) {
+
+	public Literal(String originalValue, int pos) {
 		super(pos);
-		this.literalValue = payload;
+		this.originalValue = originalValue;
 	}
 
-	public abstract TypedValue getLiteralValue();
+
+	public final String getOriginalValue() {
+		return this.originalValue;
+	}
 
 	@Override
 	public final TypedValue getValueInternal(ExpressionState state) throws SpelEvaluationException {
@@ -50,10 +59,13 @@ public String toStringAST() {
 		return toString();
 	}
 
+
+	public abstract TypedValue getLiteralValue();
+
+
 	/**
 	 * Process the string form of a number, using the specified base if supplied and return an appropriate literal to
 	 * hold it. Any suffix to indicate a long will be taken into account (either 'l' or 'L' is supported).
-	 *
 	 * @param numberToken the token holding the number as its payload (eg. 1234 or 0xCAFE)
 	 * @param radix the base of number
 	 * @return a subtype of Literal that can represent it
@@ -62,7 +74,8 @@ public static Literal getIntLiteral(String numberToken, int pos, int radix) {
 		try {
 			int value = Integer.parseInt(numberToken, radix);
 			return new IntLiteral(numberToken, pos, value);
-		} catch (NumberFormatException nfe) {
+		}
+		catch (NumberFormatException nfe) {
 			throw new InternalParseException(new SpelParseException(pos>>16, nfe, SpelMessage.NOT_AN_INTEGER, numberToken));
 		}
 	}
@@ -71,25 +84,26 @@ public static Literal getLongLiteral(String numberToken, int pos, int radix) {
 		try {
 			long value = Long.parseLong(numberToken, radix);
 			return new LongLiteral(numberToken, pos, value);
-		} catch (NumberFormatException nfe) {
+		}
+		catch (NumberFormatException nfe) {
 			throw new InternalParseException(new SpelParseException(pos>>16, nfe, SpelMessage.NOT_A_LONG, numberToken));
 		}
 	}
 
-
 	public static Literal getRealLiteral(String numberToken, int pos, boolean isFloat) {
 		try {
 			if (isFloat) {
 				float value = Float.parseFloat(numberToken);
 				return new FloatLiteral(numberToken, pos, value);
-			} else {
+			}
+			else {
 				double value = Double.parseDouble(numberToken);
 				return new RealLiteral(numberToken, pos, value);
 			}
-		} catch (NumberFormatException nfe) {
+		}
+		catch (NumberFormatException nfe) {
 			throw new InternalParseException(new SpelParseException(pos>>16, nfe, SpelMessage.NOT_A_REAL, numberToken));
 		}
 	}
 
 }
-
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/ast/Projection.java b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Projection.java
index ffc5819367ae..226063cf7c0a 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/ast/Projection.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Projection.java
@@ -70,7 +70,7 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException
 		if (operand instanceof Map) {
 			Map<?, ?> mapData = (Map<?, ?>) operand;
 			List<Object> result = new ArrayList<Object>();
-			for (Map.Entry<?,?> entry : mapData.entrySet()) {
+			for (Map.Entry<?, ?> entry : mapData.entrySet()) {
 				try {
 					state.pushActiveContextObject(new TypedValue(entry));
 					result.add(this.children[0].getValueInternal(state).getValue());
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/ast/Selection.java b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Selection.java
index e532aa9ebc1e..710e97592163 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/ast/Selection.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/Selection.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -29,6 +29,7 @@
 import org.springframework.expression.spel.ExpressionState;
 import org.springframework.expression.spel.SpelEvaluationException;
 import org.springframework.expression.spel.SpelMessage;
+import org.springframework.util.Assert;
 import org.springframework.util.ClassUtils;
 import org.springframework.util.ObjectUtils;
 
@@ -54,7 +55,9 @@ public class Selection extends SpelNodeImpl {
 	private final boolean nullSafe;
 
 	public Selection(boolean nullSafe, int variant,int pos,SpelNodeImpl expression) {
-		super(pos,expression);
+		super(pos, expression != null ? new SpelNodeImpl[] { expression }
+				: new SpelNodeImpl[] {});
+		Assert.notNull(expression, "Expression must not be null");
 		this.nullSafe = nullSafe;
 		this.variant = variant;
 	}
@@ -73,9 +76,9 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException
 		if (operand instanceof Map) {
 			Map<?, ?> mapdata = (Map<?, ?>) operand;
 			// TODO don't lose generic info for the new map
-			Map<Object,Object> result = new HashMap<Object,Object>();
+			Map<Object, Object> result = new HashMap<Object, Object>();
 			Object lastKey = null;
-			for (Map.Entry<?,?> entry : mapdata.entrySet()) {
+			for (Map.Entry<?, ?> entry : mapdata.entrySet()) {
 				try {
 					TypedValue kvpair = new TypedValue(entry);
 					state.pushActiveContextObject(kvpair);
@@ -101,7 +104,7 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException
 				return new ValueRef.TypedValueHolderValueRef(new TypedValue(null),this);
 			}
 			if (variant == LAST) {
-				Map<Object,Object> resultMap = new HashMap<Object,Object>();
+				Map<Object, Object> resultMap = new HashMap<Object, Object>();
 				Object lastValue = result.get(lastKey);
 				resultMap.put(lastKey,lastValue);
 				return new ValueRef.TypedValueHolderValueRef(new TypedValue(resultMap),this);
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java b/spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java
index 109de5fdc1b1..e1ee6f90b481 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java
@@ -149,5 +149,4 @@ public int getEndPosition() {
 	protected ValueRef getValueRef(ExpressionState state) throws EvaluationException {
 		throw new SpelEvaluationException(pos,SpelMessage.NOT_ASSIGNABLE,toStringAST());
 	}
-
 }
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java
index c243b5d7f4b4..7915a3c01572 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/InternalSpelExpressionParser.java
@@ -557,6 +557,9 @@ private boolean maybeEatSelection(boolean nullSafeNavigation) {
 		}
 		nextToken();
 		SpelNodeImpl expr = eatExpression();
+		if(expr == null) {
+			raiseInternalException(toPos(t), SpelMessage.MISSING_SELECTION_EXPRESSION);
+		}
 		eatToken(TokenKind.RSQUARE);
 		if (t.kind==TokenKind.SELECT_FIRST) {
 			constructedNodes.push(new Selection(nullSafeNavigation,Selection.FIRST,toPos(t),expr));
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/standard/Token.java b/spring-expression/src/main/java/org/springframework/expression/spel/standard/Token.java
index 3f8593c5fe8e..aaba8236a7e4 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/standard/Token.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/Token.java
@@ -84,4 +84,4 @@ public Token asMatchesToken() {
 	public Token asBetweenToken() {
 		return new Token(TokenKind.BETWEEN,startpos,endpos);
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java b/spring-expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java
index ffa6ffa88c97..cd1db13d6d41 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/standard/TokenKind.java
@@ -56,4 +56,4 @@ public boolean hasPayload() {
 	public int getLength() {
 		return tokenChars.length;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java
index c086771cbed8..ce6ad5123be5 100644
--- a/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java
+++ b/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodResolver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,13 +19,16 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import org.springframework.core.BridgeMethodResolver;
 import org.springframework.core.MethodParameter;
 import org.springframework.core.convert.TypeDescriptor;
 import org.springframework.expression.AccessException;
@@ -37,7 +40,6 @@
 import org.springframework.expression.TypeConverter;
 import org.springframework.expression.spel.SpelEvaluationException;
 import org.springframework.expression.spel.SpelMessage;
-import org.springframework.util.CollectionUtils;
 
 /**
  * Reflection-based {@link MethodResolver} used by default in
@@ -92,25 +94,16 @@ public MethodExecutor resolve(EvaluationContext context, Object targetObject, St
 		try {
 			TypeConverter typeConverter = context.getTypeConverter();
 			Class<?> type = (targetObject instanceof Class ? (Class<?>) targetObject : targetObject.getClass());
-			Method[] methods = getMethods(type, targetObject);
+			List<Method> methods = new ArrayList<Method>(Arrays.asList(getMethods(type, targetObject)));
 
 			// If a filter is registered for this type, call it
 			MethodFilter filter = (this.filters != null ? this.filters.get(type) : null);
 			if (filter != null) {
-				List<Method> methodsForFiltering = new ArrayList<Method>();
-				for (Method method: methods) {
-					methodsForFiltering.add(method);
-				}
-				List<Method> methodsFiltered = filter.filter(methodsForFiltering);
-				if (CollectionUtils.isEmpty(methodsFiltered)) {
-					methods = NO_METHODS;
-				}
-				else {
-					methods = methodsFiltered.toArray(new Method[methodsFiltered.size()]);
-				}
+				methods = filter.filter(methods);
 			}
 
-			Arrays.sort(methods, new Comparator<Method>() {
+			// Sort methods into a sensible order
+			Collections.sort(methods, new Comparator<Method>() {
 				public int compare(Method m1, Method m2) {
 					int m1pl = m1.getParameterTypes().length;
 					int m2pl = m2.getParameterTypes().length;
@@ -118,6 +111,14 @@ public int compare(Method m1, Method m2) {
 				}
 			});
 
+			// Resolve any bridge methods
+			for (int i = 0; i < methods.size(); i++) {
+				methods.set(i, BridgeMethodResolver.findBridgedMethod(methods.get(i)));
+			}
+
+			// Remove duplicate methods (possible due to resolved bridge methods)
+			methods = new ArrayList<Method>(new LinkedHashSet<Method>(methods));
+
 			Method closeMatch = null;
 			int closeMatchDistance = Integer.MAX_VALUE;
 			int[] argsToConvert = null;
@@ -125,9 +126,6 @@ public int compare(Method m1, Method m2) {
 			boolean multipleOptions = false;
 
 			for (Method method : methods) {
-				if (method.isBridge()) {
-					continue;
-				}
 				if (method.getName().equals(name)) {
 					Class<?>[] paramTypes = method.getParameterTypes();
 					List<TypeDescriptor> paramDescriptors = new ArrayList<TypeDescriptor>(paramTypes.length);
diff --git a/spring-expression/src/test/java/org/springframework/expression/spel/EvaluationTests.java b/spring-expression/src/test/java/org/springframework/expression/spel/EvaluationTests.java
index aeb991ab5538..25fcba0f4b8e 100644
--- a/spring-expression/src/test/java/org/springframework/expression/spel/EvaluationTests.java
+++ b/spring-expression/src/test/java/org/springframework/expression/spel/EvaluationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,14 @@
 
 package org.springframework.expression.spel;
 
-import static org.junit.Assert.*;
+import static org.hamcrest.Matchers.equalTo;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import java.lang.reflect.Method;
 import java.util.ArrayList;
@@ -24,7 +31,6 @@
 import java.util.Map;
 
 import org.junit.Test;
-
 import org.springframework.core.convert.TypeDescriptor;
 import org.springframework.expression.AccessException;
 import org.springframework.expression.BeanResolver;
@@ -48,6 +54,7 @@
  * @author Andy Clement
  * @author Mark Fisher
  * @author Sam Brannen
+ * @author Phillip Webb
  * @since 3.0
  */
 public class EvaluationTests extends ExpressionTestCase {
@@ -708,6 +715,23 @@ public void collectionGrowingViaIndexer() {
 		}
 	}
 
+	@Test
+	public void limitCollectionGrowing() throws Exception {
+		TestClass instance = new TestClass();
+		StandardEvaluationContext ctx = new StandardEvaluationContext(instance);
+		SpelExpressionParser parser = new SpelExpressionParser( new SpelParserConfiguration(true, true, 3));
+		Expression expression = parser.parseExpression("foo[2]");
+		expression.setValue(ctx, "2");
+		assertThat(instance.getFoo().size(), equalTo(3));
+		expression = parser.parseExpression("foo[3]");
+		try {
+			expression.setValue(ctx, "3");
+		} catch(SpelEvaluationException see) {
+			assertEquals(SpelMessage.UNABLE_TO_GROW_COLLECTION, see.getMessageCode());
+			assertThat(instance.getFoo().size(), equalTo(3));
+		}
+	}
+
 	// For now I am making #this not assignable
 	@Test
 	public void increment01root() {
diff --git a/spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java b/spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java
index 3ea0f98e3ddf..6118c82af976 100644
--- a/spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java
+++ b/spring-expression/src/test/java/org/springframework/expression/spel/MapAccessTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package org.springframework.expression.spel;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -83,9 +84,10 @@ public void testGetValue(){
 
 		ExpressionParser parser = new SpelExpressionParser();
 		Expression exp = parser.parseExpression("testBean.properties['key2']");
-		String key= (String)exp.getValue(bean);
+		String key = (String) exp.getValue(bean);
+		assertNotNull(key);
 
-		}
+	}
 
 	public static class TestBean
 	{
diff --git a/spring-expression/src/test/java/org/springframework/expression/spel/SpelDocumentationTests.java b/spring-expression/src/test/java/org/springframework/expression/spel/SpelDocumentationTests.java
index 9416ba87cff5..41261a4d7cec 100644
--- a/spring-expression/src/test/java/org/springframework/expression/spel/SpelDocumentationTests.java
+++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelDocumentationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
@@ -213,9 +214,11 @@ public void testDictionaryAccess() throws Exception {
 		societyContext.setRootObject(new IEEE());
 		// Officer's Dictionary
 		Inventor pupin = parser.parseExpression("officers['president']").getValue(societyContext, Inventor.class);
+		assertNotNull(pupin);
 
 		// evaluates to "Idvor"
 		String city = parser.parseExpression("officers['president'].PlaceOfBirth.city").getValue(societyContext, String.class);
+		assertNotNull(city);
 
 		// setting values
 		Inventor i = parser.parseExpression("officers['advisors'][0]").getValue(societyContext,Inventor.class);
diff --git a/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java b/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java
index 765422302a7e..e6e28eedd3c4 100644
--- a/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java
+++ b/spring-expression/src/test/java/org/springframework/expression/spel/SpelReproTests.java
@@ -19,6 +19,7 @@
 import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -26,6 +27,7 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -1680,6 +1682,7 @@ public void SPR_10091_simpleTestValueType() {
 		ExpressionParser parser = new SpelExpressionParser();
 		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new BooleanHolder());
 		Class<?> valueType = parser.parseExpression("simpleProperty").getValueType(evaluationContext);
+		assertNotNull(valueType);
 	}
 
 	@Test
@@ -1687,6 +1690,7 @@ public void SPR_10091_simpleTestValue() {
 		ExpressionParser parser = new SpelExpressionParser();
 		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new BooleanHolder());
 		Object value = parser.parseExpression("simpleProperty").getValue(evaluationContext);
+		assertNotNull(value);
 	}
 
 	@Test
@@ -1694,6 +1698,7 @@ public void SPR_10091_primitiveTestValueType() {
 		ExpressionParser parser = new SpelExpressionParser();
 		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new BooleanHolder());
 		Class<?> valueType = parser.parseExpression("primitiveProperty").getValueType(evaluationContext);
+		assertNotNull(valueType);
 	}
 
 	@Test
@@ -1701,6 +1706,7 @@ public void SPR_10091_primitiveTestValue() {
 		ExpressionParser parser = new SpelExpressionParser();
 		StandardEvaluationContext evaluationContext = new StandardEvaluationContext(new BooleanHolder());
 		Object value = parser.parseExpression("primitiveProperty").getValue(evaluationContext);
+		assertNotNull(value);
 	}
 
 	@Test
@@ -1731,6 +1737,22 @@ public void SPR_10125() throws Exception {
 		assertThat(fromClass, is("interfaceValue"));
 	}
 
+	@Test
+	public void SPR_10210() throws Exception {
+		StandardEvaluationContext context = new StandardEvaluationContext();
+		context.setVariable("bridgeExample", new org.springframework.expression.spel.spr10210.D());
+		Expression parseExpression = parser.parseExpression("#bridgeExample.bridgeMethod()");
+		parseExpression.getValue(context);
+	}
+
+	@Test
+	public void SPR_10328() throws Exception {
+		thrown.expect(SpelParseException.class);
+		thrown.expectMessage("EL1071E:(pos 2): A required selection expression has not been specified");
+		Expression exp = parser.parseExpression("$[]");
+		exp.getValue(Arrays.asList("foo", "bar", "baz"));
+	}
+
 	public static class BooleanHolder {
 
 		private Boolean simpleProperty = true;
@@ -1791,4 +1813,5 @@ public static class StaticFinalImpl1 extends AbstractStaticFinal implements Stat
 
 	public static class StaticFinalImpl2 extends AbstractStaticFinal {
 	}
+
 }
diff --git a/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/A.java b/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/A.java
new file mode 100644
index 000000000000..3098b293c743
--- /dev/null
+++ b/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/A.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.expression.spel.spr10210;
+
+import org.springframework.expression.spel.spr10210.comp.B;
+import org.springframework.expression.spel.spr10210.infra.C;
+
+abstract class A extends B<C> {
+
+	public void bridgeMethod() {
+	}
+
+}
diff --git a/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/D.java b/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/D.java
new file mode 100644
index 000000000000..e4776d70e66e
--- /dev/null
+++ b/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/D.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.expression.spel.spr10210;
+
+public class D extends A {
+}
diff --git a/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/comp/B.java b/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/comp/B.java
new file mode 100644
index 000000000000..3250836265ce
--- /dev/null
+++ b/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/comp/B.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.expression.spel.spr10210.comp;
+
+import java.io.Serializable;
+
+import org.springframework.expression.spel.spr10210.infra.C;
+
+public class B<T extends C> implements Serializable {
+}
diff --git a/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/infra/C.java b/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/infra/C.java
new file mode 100644
index 000000000000..2f0a32e53bee
--- /dev/null
+++ b/spring-expression/src/test/java/org/springframework/expression/spel/spr10210/infra/C.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.expression.spel.spr10210.infra;
+
+public interface C {
+}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcOperations.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcOperations.java
index 8f5a9964cd39..6db102fc64fb 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcOperations.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcOperations.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -133,7 +133,8 @@ public interface JdbcOperations {
 	 * object via a RowMapper.
 	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
 	 * execute a static query with a PreparedStatement, use the overloaded
-	 * {@code queryForObject} method with {@code null} as argument array.
+	 * {@link #queryForObject(String, RowMapper, Object...)} method with
+	 * {@code null} as argument array.
 	 * @param sql SQL query to execute
 	 * @param rowMapper object that will map one object per row
 	 * @return the single mapped object
@@ -148,7 +149,8 @@ public interface JdbcOperations {
 	 * Execute a query for a result object, given static SQL.
 	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
 	 * execute a static query with a PreparedStatement, use the overloaded
-	 * {@code queryForObject} method with {@code null} as argument array.
+	 * {@link #queryForObject(String, Class, Object...)} method with
+	 * {@code null} as argument array.
 	 * <p>This method is useful for running static SQL with a known outcome.
 	 * The query is expected to be a single row/single column query; the returned
 	 * result will be directly mapped to the corresponding object type.
@@ -166,7 +168,8 @@ public interface JdbcOperations {
 	 * Execute a query for a result Map, given static SQL.
 	 * <p>Uses a JDBC Statement, not a PreparedStatement. If you want to
 	 * execute a static query with a PreparedStatement, use the overloaded
-	 * {@code queryForMap} method with {@code null} as argument array.
+	 * {@link #queryForMap(String, Object...)} method with {@code null}
+	 * as argument array.
 	 * <p>The query is expected to be a single row query; the result row will be
 	 * mapped to a Map (one entry for each column, using the column name as the key).
 	 * @param sql SQL query to execute
@@ -194,7 +197,9 @@ public interface JdbcOperations {
 	 * exactly one row, or does not return exactly one column in that row
 	 * @throws DataAccessException if there is any problem executing the query
 	 * @see #queryForLong(String, Object[])
+	 * @deprecated in favor of {@link #queryForObject(String, Class)}
 	 */
+	@Deprecated
 	long queryForLong(String sql) throws DataAccessException;
 
 	/**
@@ -211,7 +216,9 @@ public interface JdbcOperations {
 	 * exactly one row, or does not return exactly one column in that row
 	 * @throws DataAccessException if there is any problem executing the query
 	 * @see #queryForInt(String, Object[])
+	 * @deprecated in favor of {@link #queryForObject(String, Class)}
 	 */
+	@Deprecated
 	int queryForInt(String sql) throws DataAccessException;
 
 	/**
@@ -712,7 +719,9 @@ <T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> require
 	 * @throws DataAccessException if the query fails
 	 * @see #queryForLong(String)
 	 * @see java.sql.Types
+	 * @deprecated in favor of {@link #queryForObject(String, Object[], int[], Class)} )}
 	 */
+	@Deprecated
 	long queryForLong(String sql, Object[] args, int[] argTypes) throws DataAccessException;
 
 	/**
@@ -730,7 +739,9 @@ <T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> require
 	 * exactly one row, or does not return exactly one column in that row
 	 * @throws DataAccessException if the query fails
 	 * @see #queryForLong(String)
+	 * @deprecated in favor of {@link #queryForObject(String, Class, Object[])} )}
 	 */
+	@Deprecated
 	long queryForLong(String sql, Object... args) throws DataAccessException;
 
 	/**
@@ -748,7 +759,9 @@ <T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> require
 	 * @throws DataAccessException if the query fails
 	 * @see #queryForInt(String)
 	 * @see java.sql.Types
+	 * @deprecated in favor of {@link #queryForObject(String, Object[], int[], Class)} )}
 	 */
+	@Deprecated
 	int queryForInt(String sql, Object[] args, int[] argTypes) throws DataAccessException;
 
 	/**
@@ -766,7 +779,9 @@ <T> T queryForObject(String sql, Object[] args, int[] argTypes, Class<T> require
 	 * exactly one row, or does not return exactly one column in that row
 	 * @throws DataAccessException if the query fails
 	 * @see #queryForInt(String)
+	 * @deprecated in favor of {@link #queryForObject(String, Class, Object[])} )}
 	 */
+	@Deprecated
 	int queryForInt(String sql, Object... args) throws DataAccessException;
 
 	/**
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java
index 3f0085cebf41..910d20687229 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -477,11 +477,13 @@ public <T> T queryForObject(String sql, Class<T> requiredType) throws DataAccess
 		return queryForObject(sql, getSingleColumnRowMapper(requiredType));
 	}
 
+	@Deprecated
 	public long queryForLong(String sql) throws DataAccessException {
 		Number number = queryForObject(sql, Long.class);
 		return (number != null ? number.longValue() : 0);
 	}
 
+	@Deprecated
 	public int queryForInt(String sql) throws DataAccessException {
 		Number number = queryForObject(sql, Integer.class);
 		return (number != null ? number.intValue() : 0);
@@ -757,21 +759,25 @@ public Map<String, Object> queryForMap(String sql, Object... args) throws DataAc
 		return queryForObject(sql, args, getColumnMapRowMapper());
 	}
 
+	@Deprecated
 	public long queryForLong(String sql, Object[] args, int[] argTypes) throws DataAccessException {
 		Number number = queryForObject(sql, args, argTypes, Long.class);
 		return (number != null ? number.longValue() : 0);
 	}
 
+	@Deprecated
 	public long queryForLong(String sql, Object... args) throws DataAccessException {
 		Number number = queryForObject(sql, args, Long.class);
 		return (number != null ? number.longValue() : 0);
 	}
 
+	@Deprecated
 	public int queryForInt(String sql, Object[] args, int[] argTypes) throws DataAccessException {
 		Number number = queryForObject(sql, args, argTypes, Integer.class);
 		return (number != null ? number.intValue() : 0);
 	}
 
+	@Deprecated
 	public int queryForInt(String sql, Object... args) throws DataAccessException {
 		Number number = queryForObject(sql, args, Integer.class);
 		return (number != null ? number.intValue() : 0);
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallMetaDataProvider.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallMetaDataProvider.java
index a3da020588fd..29accf8ffa2d 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallMetaDataProvider.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallMetaDataProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2010 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -56,33 +56,33 @@ void initializeWithProcedureColumnMetaData(
 
 	/**
 	 * Provide any modification of the procedure name passed in to match the meta data currently used.
-	 * This could include alterig the case.
+	 * This could include altering the case.
 	 */
 	String procedureNameToUse(String procedureName);
 
 	/**
 	 * Provide any modification of the catalog name passed in to match the meta data currently used.
-	 * This could include alterig the case.
+	 * This could include altering the case.
 	 */
 	String catalogNameToUse(String catalogName);
 
 	/**
 	 * Provide any modification of the schema name passed in to match the meta data currently used.
-	 * This could include alterig the case.
+	 * This could include altering the case.
 	 */
 	String schemaNameToUse(String schemaName);
 
 	/**
 	 * Provide any modification of the catalog name passed in to match the meta data currently used.
-	 * The reyurned value will be used for meta data lookups. This could include alterig the case used
-	 * or providing a base catalog if mone provided.
+	 * The returned value will be used for meta data lookups. This could include altering the case used
+	 * or providing a base catalog if none is provided.
 	 */
 	String metaDataCatalogNameToUse(String catalogName) ;
 
 	/**
 	 * Provide any modification of the schema name passed in to match the meta data currently used.
-	 * The reyurned value will be used for meta data lookups. This could include alterig the case used
-	 * or providing a base schema if mone provided.
+	 * The returned value will be used for meta data lookups. This could include altering the case used
+	 * or providing a base schema if none is provided.
 	 */
 	String metaDataSchemaNameToUse(String schemaName) ;
 
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallParameterMetaData.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallParameterMetaData.java
index 4c1393640d2e..55e747b9cdcf 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallParameterMetaData.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/CallParameterMetaData.java
@@ -75,4 +75,4 @@ public String getTypeName() {
 	public boolean isNullable() {
 		return nullable;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/DerbyTableMetaDataProvider.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/DerbyTableMetaDataProvider.java
index dc3e2131286a..afabd9bcf984 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/DerbyTableMetaDataProvider.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/DerbyTableMetaDataProvider.java
@@ -53,4 +53,4 @@ public boolean isGetGeneratedKeysSupported() {
 		}
 		return derbysAnswer;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/GenericTableMetaDataProvider.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/GenericTableMetaDataProvider.java
index 138518660a89..8eb1e1ea5a16 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/GenericTableMetaDataProvider.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/GenericTableMetaDataProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -310,7 +310,6 @@ private void locateTableAndProcessMetaData(DatabaseMetaData databaseMetaData, St
 				tmd.setCatalogName(tables.getString("TABLE_CAT"));
 				tmd.setSchemaName(tables.getString("TABLE_SCHEM"));
 				tmd.setTableName(tables.getString("TABLE_NAME"));
-				tmd.setType(tables.getString("TABLE_TYPE"));
 				if (tmd.getSchemaName() == null) {
 					tableMeta.put(userName != null ? userName.toUpperCase() : "", tmd);
 				}
@@ -445,7 +444,6 @@ private static class TableMetaData {
 
 		private String tableName;
 
-		private String type;
 
 		public void setCatalogName(String catalogName) {
 			this.catalogName = catalogName;
@@ -470,14 +468,6 @@ public void setTableName(String tableName) {
 		public String getTableName() {
 			return this.tableName;
 		}
-
-		public void setType(String type) {
-			this.type = type;
-		}
-
-		public String getType() {
-			return this.type;
-		}
 	}
 
 }
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/TableMetaDataProvider.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/TableMetaDataProvider.java
index 0dff1678c4c6..c7365bed5bce 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/TableMetaDataProvider.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/metadata/TableMetaDataProvider.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -76,8 +76,8 @@ void initializeWithTableColumnMetaData(DatabaseMetaData databaseMetaData, String
 
 	/**
 	 * Provide any modification of the catalog name passed in to match the meta data currently used.
-	 * The reyurned value will be used for meta data lookups.  This could include alterig the case used or
-	 * providing a base catalog if mone provided.
+	 * The returned value will be used for meta data lookups.  This could include altering the case used or
+	 * providing a base catalog if none is provided.
 	 *
 	 * @param catalogName
 	 * @return catalog name to use
@@ -86,8 +86,8 @@ void initializeWithTableColumnMetaData(DatabaseMetaData databaseMetaData, String
 
 	/**
 	 * Provide any modification of the schema name passed in to match the meta data currently used.
-	 * The reyurned value will be used for meta data lookups.  This could include alterig the case used or
-	 * providing a base schema if mone provided.
+	 * The returned value will be used for meta data lookups.  This could include altering the case used or
+	 * providing a base schema if none is provided.
 	 *
 	 * @param schemaName
 	 * @return schema name to use
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/EmptySqlParameterSource.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/EmptySqlParameterSource.java
new file mode 100644
index 000000000000..a0b525f0dcd8
--- /dev/null
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/EmptySqlParameterSource.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.jdbc.core.namedparam;
+
+/**
+ * A simple empty implementation of the {@link SqlParameterSource} interface.
+ *
+ * @author Juergen Hoeller
+ * @since 3.2.2
+ */
+public class EmptySqlParameterSource implements SqlParameterSource {
+
+	/**
+	 * A shared instance of {@link EmptySqlParameterSource}.
+	 */
+	public static final EmptySqlParameterSource INSTANCE = new EmptySqlParameterSource();
+
+
+	public boolean hasValue(String paramName) {
+		return false;
+	}
+
+	public Object getValue(String paramName) throws IllegalArgumentException {
+		throw new IllegalArgumentException("This SqlParameterSource is empty");
+	}
+
+	public int getSqlType(String paramName) {
+		return TYPE_UNKNOWN;
+	}
+
+	public String getTypeName(String paramName) {
+		return null;
+	}
+
+}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcOperations.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcOperations.java
index a7f5c9f7c9cc..91e20f3fcd9b 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcOperations.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcOperations.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -88,6 +88,21 @@ <T> T execute(String sql, SqlParameterSource paramSource, PreparedStatementCallb
 	<T> T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallback<T> action)
 			throws DataAccessException;
 
+	/**
+	 * Execute a JDBC data access operation, implemented as callback action
+	 * working on a JDBC PreparedStatement. This allows for implementing arbitrary
+	 * data access operations on a single Statement, within Spring's managed
+	 * JDBC environment: that is, participating in Spring-managed transactions
+	 * and converting JDBC SQLExceptions into Spring's DataAccessException hierarchy.
+	 * <p>The callback action can return a result object, for example a
+	 * domain object or a collection of domain objects.
+	 * @param sql SQL to execute
+	 * @param action callback object that specifies the action
+	 * @return a result object returned by the action, or {@code null}
+	 * @throws DataAccessException if there is any problem
+	 */
+	<T> T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException;
+
 	/**
 	 * Query given SQL to create a prepared statement from SQL and a list
 	 * of arguments to bind to the query, reading the ResultSet with a
@@ -115,6 +130,19 @@ <T> T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rs
 	<T> T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rse)
 			throws DataAccessException;
 
+	/**
+	 * Query given SQL to create a prepared statement from SQL,
+	 * reading the ResultSet with a ResultSetExtractor.
+	 * <p>Note: In contrast to the JdbcOperations method with the same signature,
+	 * this query variant always uses a PreparedStatement. It is effectively
+	 * equivalent to a query call with an empty parameter Map.
+	 * @param sql SQL query to execute
+	 * @param rse object that will extract results
+	 * @return an arbitrary result object, as returned by the ResultSetExtractor
+	 * @throws org.springframework.dao.DataAccessException if the query fails
+	 */
+	<T> T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException;
+
 	/**
 	 * Query given SQL to create a prepared statement from SQL and a list of
 	 * arguments to bind to the query, reading the ResultSet on a per-row basis
@@ -139,6 +167,18 @@ void query(String sql, SqlParameterSource paramSource, RowCallbackHandler rch)
 	 */
 	void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch) throws DataAccessException;
 
+	/**
+	 * Query given SQL to create a prepared statement from SQL,
+	 * reading the ResultSet on a per-row basis with a RowCallbackHandler.
+	 * <p>Note: In contrast to the JdbcOperations method with the same signature,
+	 * this query variant always uses a PreparedStatement. It is effectively
+	 * equivalent to a query call with an empty parameter Map.
+	 * @param sql SQL query to execute
+	 * @param rch object that will extract results, one row at a time
+	 * @throws org.springframework.dao.DataAccessException if the query fails
+	 */
+	void query(String sql, RowCallbackHandler rch) throws DataAccessException;
+
 	/**
 	 * Query given SQL to create a prepared statement from SQL and a list
 	 * of arguments to bind to the query, mapping each row to a Java object
@@ -166,6 +206,19 @@ <T> List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMa
 	<T> List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMapper)
 			throws DataAccessException;
 
+	/**
+	 * Query given SQL to create a prepared statement from SQL,
+	 * mapping each row to a Java object via a RowMapper.
+	 * <p>Note: In contrast to the JdbcOperations method with the same signature,
+	 * this query variant always uses a PreparedStatement. It is effectively
+	 * equivalent to a query call with an empty parameter Map.
+	 * @param sql SQL query to execute
+	 * @param rowMapper object that will map one object per row
+	 * @return the result List, containing mapped objects
+	 * @throws org.springframework.dao.DataAccessException if the query fails
+	 */
+	<T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException;
+
 	/**
 	 * Query given SQL to create a prepared statement from SQL and a list
 	 * of arguments to bind to the query, mapping a single result row to a
@@ -245,8 +298,7 @@ <T> T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)
 	 * @param paramSource container of arguments to bind to the query
 	 * @return the result Map (one entry for each column, using the column name as the key)
 	 * @throws org.springframework.dao.IncorrectResultSizeDataAccessException
-	 * if the query does not return exactly one row, or does not return exactly
-	 * one column in that row
+	 * if the query does not return exactly one row
 	 * @throws org.springframework.dao.DataAccessException if the query fails
 	 * @see org.springframework.jdbc.core.JdbcTemplate#queryForMap(String)
 	 * @see org.springframework.jdbc.core.ColumnMapRowMapper
@@ -266,8 +318,7 @@ <T> T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)
 	 * (leaving it to the PreparedStatement to guess the corresponding SQL type)
 	 * @return the result Map (one entry for each column, using the column name as the key)
 	 * @throws org.springframework.dao.IncorrectResultSizeDataAccessException
-	 * if the query does not return exactly one row, or does not return exactly
-	 * one column in that row
+	 * if the query does not return exactly one row
 	 * @throws org.springframework.dao.DataAccessException if the query fails
 	 * @see org.springframework.jdbc.core.JdbcTemplate#queryForMap(String)
 	 * @see org.springframework.jdbc.core.ColumnMapRowMapper
@@ -287,7 +338,9 @@ <T> T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)
 	 * one column in that row
 	 * @throws org.springframework.dao.DataAccessException if the query fails
 	 * @see org.springframework.jdbc.core.JdbcTemplate#queryForLong(String)
+	 * @deprecated in favor of {@link #queryForObject(String, SqlParameterSource, Class)}
 	 */
+	@Deprecated
 	long queryForLong(String sql, SqlParameterSource paramSource) throws DataAccessException;
 
 	/**
@@ -304,7 +357,9 @@ <T> T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)
 	 * one column in that row
 	 * @throws org.springframework.dao.DataAccessException if the query fails
 	 * @see org.springframework.jdbc.core.JdbcTemplate#queryForLong(String)
+	 * @deprecated in favor of {@link #queryForObject(String, Map, Class)}
 	 */
+	@Deprecated
 	long queryForLong(String sql, Map<String, ?> paramMap) throws DataAccessException;
 
 	/**
@@ -319,7 +374,9 @@ <T> T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)
 	 * exactly one row, or does not return exactly one column in that row
 	 * @throws org.springframework.dao.DataAccessException if the query fails
 	 * @see org.springframework.jdbc.core.JdbcTemplate#queryForInt(String)
+	 * @deprecated in favor of {@link #queryForObject(String, SqlParameterSource, Class)}
 	 */
+	@Deprecated
 	int queryForInt(String sql, SqlParameterSource paramSource) throws DataAccessException;
 
 	/**
@@ -335,7 +392,9 @@ <T> T queryForObject(String sql, Map<String, ?> paramMap, Class<T> requiredType)
 	 * exactly one row, or does not return exactly one column in that row
 	 * @throws org.springframework.dao.DataAccessException if the query fails
 	 * @see org.springframework.jdbc.core.JdbcTemplate#queryForInt(String)
+	 * @deprecated in favor of {@link #queryForObject(String, Map, Class)}
 	 */
+	@Deprecated
 	int queryForInt(String sql, Map<String, ?> paramMap) throws DataAccessException;
 
 	/**
@@ -378,8 +437,8 @@ <T> List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementTy
 	 * list of arguments to bind to the query, expecting a result list.
 	 * <p>The results will be mapped to a List (one entry for each row) of
 	 * Maps (one entry for each column, using the column name as the key).
-	 * Thus  Each element in the list will be of the form returned by this interface's
-	 * queryForMap() methods.
+	 * Each element in the list will be of the form returned by this interface's
+	 * {@code queryForMap} methods.
 	 * @param sql SQL query to execute
 	 * @param paramSource container of arguments to bind to the query
 	 * @return a List that contains a Map per row
@@ -394,7 +453,7 @@ <T> List<T> queryForList(String sql, Map<String, ?> paramMap, Class<T> elementTy
 	 * <p>The results will be mapped to a List (one entry for each row) of
 	 * Maps (one entry for each column, using the column name as the key).
 	 * Each element in the list will be of the form returned by this interface's
-	 * queryForMap() methods.
+	 * {@code queryForMap} methods.
 	 * @param sql SQL query to execute
 	 * @param paramMap map of parameters to bind to the query
 	 * (leaving it to the PreparedStatement to guess the corresponding SQL type)
@@ -499,7 +558,7 @@ int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHol
 	 * @param batchValues the array of Maps containing the batch of arguments for the query
 	 * @return an array containing the numbers of rows affected by each update in the batch
 	 */
-	public int[] batchUpdate(String sql, Map<String, ?>[] batchValues);
+	int[] batchUpdate(String sql, Map<String, ?>[] batchValues);
 
 	/**
 	 * Execute a batch using the supplied SQL statement with the batch of supplied arguments.
@@ -507,6 +566,6 @@ int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHol
 	 * @param batchArgs the array of {@link SqlParameterSource} containing the batch of arguments for the query
 	 * @return an array containing the numbers of rows affected by each update in the batch
 	 */
-	public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs);
+	int[] batchUpdate(String sql, SqlParameterSource[] batchArgs);
 
 }
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplate.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplate.java
index 1abfdea3c218..d8258cefc957 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplate.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplate.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -137,6 +137,10 @@ public <T> T execute(String sql, Map<String, ?> paramMap, PreparedStatementCallb
 		return execute(sql, new MapSqlParameterSource(paramMap), action);
 	}
 
+	public <T> T execute(String sql, PreparedStatementCallback<T> action) throws DataAccessException {
+		return execute(sql, EmptySqlParameterSource.INSTANCE, action);
+	}
+
 	public <T> T query(String sql, SqlParameterSource paramSource, ResultSetExtractor<T> rse)
 			throws DataAccessException {
 
@@ -149,6 +153,10 @@ public <T> T query(String sql, Map<String, ?> paramMap, ResultSetExtractor<T> rs
 		return query(sql, new MapSqlParameterSource(paramMap), rse);
 	}
 
+	public <T> T query(String sql, ResultSetExtractor<T> rse) throws DataAccessException {
+		return query(sql, EmptySqlParameterSource.INSTANCE, rse);
+	}
+
 	public void query(String sql, SqlParameterSource paramSource, RowCallbackHandler rch)
 			throws DataAccessException {
 
@@ -161,6 +169,10 @@ public void query(String sql, Map<String, ?> paramMap, RowCallbackHandler rch)
 		query(sql, new MapSqlParameterSource(paramMap), rch);
 	}
 
+	public void query(String sql, RowCallbackHandler rch) throws DataAccessException {
+		query(sql, EmptySqlParameterSource.INSTANCE, rch);
+	}
+
 	public <T> List<T> query(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)
 			throws DataAccessException {
 
@@ -173,6 +185,10 @@ public <T> List<T> query(String sql, Map<String, ?> paramMap, RowMapper<T> rowMa
 		return query(sql, new MapSqlParameterSource(paramMap), rowMapper);
 	}
 
+	public <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {
+		return query(sql, EmptySqlParameterSource.INSTANCE, rowMapper);
+	}
+
 	public <T> T queryForObject(String sql, SqlParameterSource paramSource, RowMapper<T> rowMapper)
 			throws DataAccessException {
 
@@ -206,20 +222,24 @@ public Map<String, Object> queryForMap(String sql, Map<String, ?> paramMap) thro
 		return queryForObject(sql, paramMap, new ColumnMapRowMapper());
 	}
 
+	@Deprecated
 	public long queryForLong(String sql, SqlParameterSource paramSource) throws DataAccessException {
 		Number number = queryForObject(sql, paramSource, Long.class);
 		return (number != null ? number.longValue() : 0);
 	}
 
+	@Deprecated
 	public long queryForLong(String sql, Map<String, ?> paramMap) throws DataAccessException {
 		return queryForLong(sql, new MapSqlParameterSource(paramMap));
 	}
 
+	@Deprecated
 	public int queryForInt(String sql, SqlParameterSource paramSource) throws DataAccessException {
 		Number number = queryForObject(sql, paramSource, Integer.class);
 		return (number != null ? number.intValue() : 0);
 	}
 
+	@Deprecated
 	public int queryForInt(String sql, Map<String, ?> paramMap) throws DataAccessException {
 		return queryForInt(sql, new MapSqlParameterSource(paramMap));
 	}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/AbstractJdbcCall.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/AbstractJdbcCall.java
index 7c80a14d0fec..12e1dbd85ef0 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/AbstractJdbcCall.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/AbstractJdbcCall.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -97,7 +97,7 @@ protected AbstractJdbcCall(JdbcTemplate jdbcTemplate) {
 
 
 	/**
-	 * Get the configured {@link JdbcTemplate}
+	 * Get the configured {@link JdbcTemplate}.
 	 */
 	public JdbcTemplate getJdbcTemplate() {
 		return this.jdbcTemplate;
@@ -110,7 +110,6 @@ protected CallableStatementCreatorFactory getCallableStatementFactory() {
 		return this.callableStatementFactory;
 	}
 
-
 	/**
 	 * Set the name of the stored procedure.
 	 */
@@ -294,7 +293,7 @@ protected void compileInternal() {
 					this.callMetaDataContext.createReturnResultSetParameter(entry.getKey(), entry.getValue());
 			this.declaredParameters.add(resultSetParameter);
 		}
-		callMetaDataContext.processParameters(this.declaredParameters);
+		this.callMetaDataContext.processParameters(this.declaredParameters);
 
 		this.callString = this.callMetaDataContext.createCallString();
 		if (logger.isDebugEnabled()) {
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/AbstractJdbcInsert.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/AbstractJdbcInsert.java
index 98f0e5991ebb..cb66d803c70f 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/AbstractJdbcInsert.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/AbstractJdbcInsert.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -74,9 +74,9 @@ public abstract class AbstractJdbcInsert {
 	private final List<String> declaredColumns = new ArrayList<String>();
 
 	/**
-	 * Has this operation been compiled? Compilation means at
-	 * least checking that a DataSource or JdbcTemplate has been provided,
-	 * but subclasses may also implement their own custom validation.
+	 * Has this operation been compiled? Compilation means at least checking
+	 * that a DataSource or JdbcTemplate has been provided, but subclasses
+	 * may also implement their own custom validation.
 	 */
 	private boolean compiled = false;
 
@@ -108,9 +108,16 @@ protected AbstractJdbcInsert(JdbcTemplate jdbcTemplate) {
 
 
 	//-------------------------------------------------------------------------
-	// Methods dealing with configuaration properties
+	// Methods dealing with configuration properties
 	//-------------------------------------------------------------------------
 
+	/**
+	 * Get the {@link JdbcTemplate} that is configured to be used.
+	 */
+	public JdbcTemplate getJdbcTemplate() {
+		return this.jdbcTemplate;
+	}
+
 	/**
 	 * Set the name of the table for this insert
 	 */
@@ -230,41 +237,31 @@ public int[] getInsertTypes() {
 		return this.insertTypes;
 	}
 
-	/**
-	 * Get the {@link JdbcTemplate} that is configured to be used
-	 */
-	protected JdbcTemplate getJdbcTemplate() {
-		return this.jdbcTemplate;
-	}
-
 
 	//-------------------------------------------------------------------------
 	// Methods handling compilation issues
 	//-------------------------------------------------------------------------
 
 	/**
-	 * Compile this JdbcInsert using provided parameters and meta data plus other settings.  This
-	 * finalizes the configuration for this object and subsequent attempts to compile are ignored.
-	 * This will be implicitly called the first time an un-compiled insert is executed.
-	 * @throws org.springframework.dao.InvalidDataAccessApiUsageException if the object hasn't
-	 * been correctly initialized, for example if no DataSource has been provided
+	 * Compile this JdbcInsert using provided parameters and meta data plus other settings.
+	 * This finalizes the configuration for this object and subsequent attempts to compile are
+	 * ignored. This will be implicitly called the first time an un-compiled insert is executed.
+	 * @throws InvalidDataAccessApiUsageException if the object hasn't been correctly initialized,
+	 * for example if no DataSource has been provided
 	 */
 	public synchronized final void compile() throws InvalidDataAccessApiUsageException {
 		if (!isCompiled()) {
 			if (getTableName() == null) {
 				throw new InvalidDataAccessApiUsageException("Table name is required");
 			}
-
 			try {
 				this.jdbcTemplate.afterPropertiesSet();
 			}
 			catch (IllegalArgumentException ex) {
 				throw new InvalidDataAccessApiUsageException(ex.getMessage());
 			}
-
 			compileInternal();
 			this.compiled = true;
-
 			if (logger.isDebugEnabled()) {
 				logger.debug("JdbcInsert for table [" + getTableName() + "] compiled");
 			}
@@ -272,21 +269,17 @@ public synchronized final void compile() throws InvalidDataAccessApiUsageExcepti
 	}
 
 	/**
-	 * Method to perform the actual compilation.  Subclasses can override this template method to perform
-	 * their own compilation.  Invoked after this base class's compilation is complete.
+	 * Method to perform the actual compilation. Subclasses can override this template method
+	 * to perform  their own compilation. Invoked after this base class's compilation is complete.
 	 */
 	protected void compileInternal() {
-
-		tableMetaDataContext.processMetaData(getJdbcTemplate().getDataSource(), getColumnNames(), getGeneratedKeyNames());
-
-		insertString = tableMetaDataContext.createInsertString(getGeneratedKeyNames());
-
-		insertTypes = tableMetaDataContext.createInsertTypes();
-
+		this.tableMetaDataContext.processMetaData(
+				getJdbcTemplate().getDataSource(), getColumnNames(), getGeneratedKeyNames());
+		this.insertString = this.tableMetaDataContext.createInsertString(getGeneratedKeyNames());
+		this.insertTypes = this.tableMetaDataContext.createInsertTypes();
 		if (logger.isDebugEnabled()) {
-			logger.debug("Compiled JdbcInsert. Insert string is [" + getInsertString() + "]");
+			logger.debug("Compiled insert object: insert string is [" + getInsertString() + "]");
 		}
-
 		onCompileInternal();
 	}
 
@@ -318,12 +311,13 @@ protected void checkCompiled() {
 	}
 
 	/**
-	 * Method to check whether we are allowd to make any configuration changes at this time.  If the class has been
-	 * compiled, then no further changes to the configuration are allowed.
+	 * Method to check whether we are allowd to make any configuration changes at this time.
+	 * If the class has been compiled, then no further changes to the configuration are allowed.
 	 */
 	protected void checkIfConfigurationModificationIsAllowed() {
 		if (isCompiled()) {
-			throw new InvalidDataAccessApiUsageException("Configuration can't be altered once the class has been compiled or used.");
+			throw new InvalidDataAccessApiUsageException(
+					"Configuration can't be altered once the class has been compiled or used");
 		}
 	}
 
@@ -334,7 +328,6 @@ protected void checkIfConfigurationModificationIsAllowed() {
 
 	/**
 	 * Method that provides execution of the insert using the passed in Map of parameters
-	 *
 	 * @param args Map with parameter names and values to be used in insert
 	 * @return number of rows affected
 	 */
@@ -346,7 +339,6 @@ protected int doExecute(Map<String, Object> args) {
 
 	/**
 	 * Method that provides execution of the insert using the passed in {@link SqlParameterSource}
-	 *
 	 * @param parameterSource parameter names and values to be used in insert
 	 * @return number of rows affected
 	 */
@@ -357,14 +349,13 @@ protected int doExecute(SqlParameterSource parameterSource) {
 	}
 
 	/**
-	 * Method to execute the insert
+	 * Method to execute the insert.
 	 */
 	private int executeInsertInternal(List<Object> values) {
 		if (logger.isDebugEnabled()) {
 			logger.debug("The following parameters are used for insert " + getInsertString() + " with: " + values);
 		}
-		int updateCount = jdbcTemplate.update(getInsertString(), values.toArray(), getInsertTypes());
-		return updateCount;
+		return getJdbcTemplate().update(getInsertString(), values.toArray(), getInsertTypes());
 	}
 
 	/**
@@ -428,8 +419,8 @@ private Number executeInsertAndReturnKeyInternal(final List<Object> values) {
 			return kh.getKey();
 		}
 		else {
-			throw new DataIntegrityViolationException("Unable to retrieve the generated key for the insert: " +
-					getInsertString());
+			throw new DataIntegrityViolationException(
+					"Unable to retrieve the generated key for the insert: " + getInsertString());
 		}
 	}
 
@@ -442,7 +433,7 @@ private KeyHolder executeInsertAndReturnKeyHolderInternal(final List<Object> val
 		}
 		final KeyHolder keyHolder = new GeneratedKeyHolder();
 		if (this.tableMetaDataContext.isGetGeneratedKeysSupported()) {
-			jdbcTemplate.update(
+			getJdbcTemplate().update(
 					new PreparedStatementCreator() {
 						public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
 							PreparedStatement ps = prepareStatementForGeneratedKeys(con);
@@ -467,22 +458,20 @@ public PreparedStatement createPreparedStatement(Connection con) throws SQLExcep
 						getGeneratedKeyNames().length  + " columns specified: " + Arrays.asList(getGeneratedKeyNames()));
 			}
 			// This is a hack to be able to get the generated key from a database that doesn't support
-			// get generated keys feature.  HSQL is one, PostgreSQL is another.  Postgres uses a RETURNING
+			// get generated keys feature. HSQL is one, PostgreSQL is another. Postgres uses a RETURNING
 			// clause while HSQL uses a second query that has to be executed with the same connection.
-			final String keyQuery = tableMetaDataContext.getSimulationQueryForGetGeneratedKey(
-					tableMetaDataContext.getTableName(),
-					getGeneratedKeyNames()[0]);
+			final String keyQuery = this.tableMetaDataContext.getSimulationQueryForGetGeneratedKey(
+					this.tableMetaDataContext.getTableName(), getGeneratedKeyNames()[0]);
 			Assert.notNull(keyQuery, "Query for simulating get generated keys can't be null");
 			if (keyQuery.toUpperCase().startsWith("RETURNING")) {
-				Long key = jdbcTemplate.queryForLong(
-						getInsertString() + " " + keyQuery,
-						values.toArray(new Object[values.size()]));
-				HashMap keys = new HashMap(1);
+				Long key = getJdbcTemplate().queryForObject(getInsertString() + " " + keyQuery,
+						values.toArray(new Object[values.size()]), Long.class);
+				Map<String, Object> keys = new HashMap<String, Object>(1);
 				keys.put(getGeneratedKeyNames()[0], key);
 				keyHolder.getKeyList().add(keys);
 			}
 			else {
-				jdbcTemplate.execute(new ConnectionCallback() {
+				getJdbcTemplate().execute(new ConnectionCallback<Object>() {
 					public Object doInConnection(Connection con) throws SQLException, DataAccessException {
 						// Do the insert
 						PreparedStatement ps = null;
@@ -490,13 +479,14 @@ public Object doInConnection(Connection con) throws SQLException, DataAccessExce
 							ps = con.prepareStatement(getInsertString());
 							setParameterValues(ps, values, getInsertTypes());
 							ps.executeUpdate();
-						} finally {
+						}
+						finally {
 							JdbcUtils.closeStatement(ps);
 						}
 						//Get the key
 						Statement keyStmt = null;
 						ResultSet rs = null;
-						HashMap keys = new HashMap(1);
+						Map<String, Object> keys = new HashMap<String, Object>(1);
 						try {
 							keyStmt = con.createStatement();
 							rs = keyStmt.executeQuery(keyQuery);
@@ -505,7 +495,8 @@ public Object doInConnection(Connection con) throws SQLException, DataAccessExce
 								keys.put(getGeneratedKeyNames()[0], key);
 								keyHolder.getKeyList().add(keys);
 							}
-						} finally {
+						}
+						finally {
 							JdbcUtils.closeResultSet(rs);
 							JdbcUtils.closeStatement(keyStmt);
 						}
@@ -547,14 +538,14 @@ private PreparedStatement prepareStatementForGeneratedKeys(Connection con) throw
 	}
 
 	/**
-	 * Method that provides execution of a batch insert using the passed in Maps of parameters
-	 *
+	 * Method that provides execution of a batch insert using the passed in Maps of parameters.
 	 * @param batch array of Maps with parameter names and values to be used in batch insert
 	 * @return array of number of rows affected
 	 */
+	@SuppressWarnings("unchecked")
 	protected int[] doExecuteBatch(Map<String, Object>[] batch) {
 		checkCompiled();
-		List[] batchValues = new ArrayList[batch.length];
+		List<Object>[] batchValues = new ArrayList[batch.length];
 		int i = 0;
 		for (Map<String, Object> args : batch) {
 			List<Object> values = matchInParameterValuesWithInsertColumns(args);
@@ -565,13 +556,13 @@ protected int[] doExecuteBatch(Map<String, Object>[] batch) {
 
 	/**
 	 * Method that provides execution of a batch insert using the passed in array of {@link SqlParameterSource}
-	 *
 	 * @param batch array of SqlParameterSource with parameter names and values to be used in insert
 	 * @return array of number of rows affected
 	 */
+	@SuppressWarnings("unchecked")
 	protected int[] doExecuteBatch(SqlParameterSource[] batch) {
 		checkCompiled();
-		List[] batchValues = new ArrayList[batch.length];
+		List<Object>[] batchValues = new ArrayList[batch.length];
 		int i = 0;
 		for (SqlParameterSource parameterSource : batch) {
 			List<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);
@@ -581,27 +572,22 @@ protected int[] doExecuteBatch(SqlParameterSource[] batch) {
 	}
 
 	/**
-	 * Method to execute the batch insert
+	 * Method to execute the batch insert.
 	 */
-	//TODO synchronize parameter setters with the SimpleJdbcTemplate
 	private int[] executeBatchInternal(final List<Object>[] batchValues) {
 		if (logger.isDebugEnabled()) {
 			logger.debug("Executing statement " + getInsertString() + " with batch of size: " + batchValues.length);
 		}
-		int[] updateCounts = jdbcTemplate.batchUpdate(
-				getInsertString(),
+		return getJdbcTemplate().batchUpdate(getInsertString(),
 				new BatchPreparedStatementSetter() {
-
 					public void setValues(PreparedStatement ps, int i) throws SQLException {
 						List<Object> values = batchValues[i];
 						setParameterValues(ps, values, getInsertTypes());
 					}
-
 					public int getBatchSize() {
 						return batchValues.length;
 					}
 				});
-		return updateCounts;
 	}
 
 	/**
@@ -611,6 +597,7 @@ public int getBatchSize() {
 	 */
 	private void setParameterValues(PreparedStatement preparedStatement, List<Object> values, int[] columnTypes)
 			throws SQLException {
+
 		int colIndex = 0;
 		for (Object value : values) {
 			colIndex++;
@@ -624,25 +611,23 @@ private void setParameterValues(PreparedStatement preparedStatement, List<Object
 	}
 
 	/**
-	 * Match the provided in parameter values with regitered parameters and parameters defined via metedata
-	 * processing.
-	 *
+	 * Match the provided in parameter values with regitered parameters and parameters defined
+	 * via metadata processing.
 	 * @param parameterSource the parameter vakues provided as a {@link SqlParameterSource}
 	 * @return Map with parameter names and values
 	 */
 	protected List<Object> matchInParameterValuesWithInsertColumns(SqlParameterSource parameterSource) {
-		return tableMetaDataContext.matchInParameterValuesWithInsertColumns(parameterSource);
+		return this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(parameterSource);
 	}
 
 	/**
-	 * Match the provided in parameter values with regitered parameters and parameters defined via metedata
-	 * processing.
-	 *
+	 * Match the provided in parameter values with regitered parameters and parameters defined
+	 * via metadata processing.
 	 * @param args the parameter values provided in a Map
 	 * @return Map with parameter names and values
 	 */
 	protected List<Object> matchInParameterValuesWithInsertColumns(Map<String, Object> args) {
-		return tableMetaDataContext.matchInParameterValuesWithInsertColumns(args);
+		return this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(args);
 	}
 
 }
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcCall.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcCall.java
index d687dbc2f6ab..6ace2d863e8e 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcCall.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcCall.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -128,7 +128,7 @@ public SimpleJdbcCall returningResultSet(String parameterName, RowMapper rowMapp
 	/**
 	 * @deprecated in favor of {@link #returningResultSet(String, org.springframework.jdbc.core.RowMapper)}
 	 */
-   @Deprecated
+	@Deprecated
 	public SimpleJdbcCall returningResultSet(String parameterName, ParameterizedRowMapper rowMapper) {
 		addDeclaredRowMapper(parameterName, rowMapper);
 		return this;
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcInsert.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcInsert.java
index 7d29df830184..98b89e9f1f27 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcInsert.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/simple/SimpleJdbcInsert.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,9 +33,9 @@
  * name of the table and a Map containing the column names and the column values.
  *
  * <p>The meta data processing is based on the DatabaseMetaData provided by the
- * JDBC driver.  As long as the JBDC driver can provide the names of the columns
+ * JDBC driver. As long as the JBDC driver can provide the names of the columns
  * for a specified table than we can rely on this auto-detection feature. If that
- * is not the case then the column names must be specified explicitly.
+ * is not the case, then the column names must be specified explicitly.
  *
  * <p>The actual insert is being handled using Spring's
  * {@link org.springframework.jdbc.core.JdbcTemplate}.
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/core/support/AbstractLobCreatingPreparedStatementCallback.java b/spring-jdbc/src/main/java/org/springframework/jdbc/core/support/AbstractLobCreatingPreparedStatementCallback.java
index 7ef0b3258325..c106ad57f413 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/core/support/AbstractLobCreatingPreparedStatementCallback.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/core/support/AbstractLobCreatingPreparedStatementCallback.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,15 +23,16 @@
 import org.springframework.jdbc.core.PreparedStatementCallback;
 import org.springframework.jdbc.support.lob.LobCreator;
 import org.springframework.jdbc.support.lob.LobHandler;
+import org.springframework.util.Assert;
 
 /**
- * Abstract PreparedStatementCallback implementation that manages a LobCreator.
+ * Abstract {@link PreparedStatementCallback} implementation that manages a {@link LobCreator}.
  * Typically used as inner class, with access to surrounding method arguments.
  *
  * <p>Delegates to the {@code setValues} template method for setting values
  * on the PreparedStatement, using a given LobCreator for BLOB/CLOB arguments.
  *
- * <p>A usage example with JdbcTemplate:
+ * <p>A usage example with {@link org.springframework.jdbc.core.JdbcTemplate}:
  *
  * <pre class="code">JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);  // reusable object
  * LobHandler lobHandler = new DefaultLobHandler();  // reusable object
@@ -62,6 +63,7 @@ public abstract class AbstractLobCreatingPreparedStatementCallback implements Pr
 	 * @param lobHandler the LobHandler to create LobCreators with
 	 */
 	public AbstractLobCreatingPreparedStatementCallback(LobHandler lobHandler) {
+		Assert.notNull(lobHandler, "LobHandler must not be null");
 		this.lobHandler = lobHandler;
 	}
 
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceTransactionManager.java b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceTransactionManager.java
index 9c6ebcfde2c9..b0e9811e3a3b 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceTransactionManager.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceTransactionManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -348,10 +348,6 @@ public boolean isNewConnectionHolder() {
 			return this.newConnectionHolder;
 		}
 
-		public boolean hasTransaction() {
-			return (getConnectionHolder() != null && getConnectionHolder().isTransactionActive());
-		}
-
 		public void setMustRestoreAutoCommit(boolean mustRestoreAutoCommit) {
 			this.mustRestoreAutoCommit = mustRestoreAutoCommit;
 		}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.java b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.java
index f6ddc15b349f..5495aa68ce7c 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/LazyConnectionDataSourceProxy.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2010 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -66,18 +66,17 @@
  * You will get the same effect with non-transactional reads, but lazy fetching
  * of JDBC Connections allows you to still perform reads in transactions.
  *
- * <p><b>NOTE:</b> This DataSource proxy needs to return wrapped Connections to
- * handle lazy fetching of an actual JDBC Connection. Therefore, the returned
- * Connections cannot be cast to a native JDBC Connection type like OracleConnection,
- * or to a connection pool implementation type. Use a corresponding
- * NativeJdbcExtractor to retrieve the native JDBC Connection.
+ * <p><b>NOTE:</b> This DataSource proxy needs to return wrapped Connections
+ * (which implement the {@link ConnectionProxy} interface) in order to handle
+ * lazy fetching of an actual JDBC Connection. Therefore, the returned Connections
+ * cannot be cast to a native JDBC Connection type such as OracleConnection or
+ * to a connection pool implementation type. Use a corresponding
+ * {@link org.springframework.jdbc.support.nativejdbc.NativeJdbcExtractor}
+ * or JDBC 4's {@link Connection#unwrap} to retrieve the native JDBC Connection.
  *
  * @author Juergen Hoeller
  * @since 1.1.4
- * @see ConnectionProxy
  * @see DataSourceTransactionManager
- * @see org.springframework.orm.hibernate3.HibernateTransactionManager
- * @see org.springframework.jdbc.support.nativejdbc.NativeJdbcExtractor
  */
 public class LazyConnectionDataSourceProxy extends DelegatingDataSource {
 
@@ -407,7 +406,13 @@ private Connection getTargetConnection(Method operation) throws SQLException {
 
 				// Apply kept transaction settings, if any.
 				if (this.readOnly) {
-					this.target.setReadOnly(this.readOnly);
+					try {
+						this.target.setReadOnly(this.readOnly);
+					}
+					catch (Exception ex) {
+						// "read-only not supported" -> ignore, it's just a hint anyway
+						logger.debug("Could not set JDBC Connection read-only", ex);
+					}
 				}
 				if (this.transactionIsolation != null &&
 						!this.transactionIsolation.equals(defaultTransactionIsolation())) {
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.java b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.java
index 1321c8166273..3bde77765d11 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,10 +64,10 @@
  * <p><b>NOTE:</b> This DataSource proxy needs to return wrapped Connections
  * (which implement the {@link ConnectionProxy} interface) in order to handle
  * close calls properly. Therefore, the returned Connections cannot be cast
- * to a native JDBC Connection type like OracleConnection or to a connection
+ * to a native JDBC Connection type such as OracleConnection or to a connection
  * pool implementation type. Use a corresponding
  * {@link org.springframework.jdbc.support.nativejdbc.NativeJdbcExtractor}
- * to retrieve the native JDBC Connection.
+ * or JDBC 4's {@link Connection#unwrap} to retrieve the native JDBC Connection.
  *
  * @author Juergen Hoeller
  * @since 1.1
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseFactory.java b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseFactory.java
index 5e3db7cff474..20a5bfdf6174 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseFactory.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseFactory.java
@@ -205,7 +205,6 @@ public boolean isWrapperFor(Class<?> iface) throws SQLException {
 		}
 
 		// getParentLogger() is required for JDBC 4.1 compatibility
-		@SuppressWarnings("unused")
 		public Logger getParentLogger() {
 			return Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
 		}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/embedded/HsqlEmbeddedDatabaseConfigurer.java b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/embedded/HsqlEmbeddedDatabaseConfigurer.java
index 298cf37db001..07670934c7fe 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/embedded/HsqlEmbeddedDatabaseConfigurer.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/embedded/HsqlEmbeddedDatabaseConfigurer.java
@@ -59,4 +59,4 @@ public void configureConnectionProperties(ConnectionProperties properties, Strin
 		properties.setPassword("");
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java b/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java
index a3290b882519..3bf52d3f7164 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,7 +20,6 @@
 import java.sql.BatchUpdateException;
 import java.sql.SQLException;
 import java.util.Arrays;
-
 import javax.sql.DataSource;
 
 import org.springframework.core.JdkVersion;
@@ -30,9 +29,9 @@
 import org.springframework.dao.DataAccessResourceFailureException;
 import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.dao.DeadlockLoserDataAccessException;
+import org.springframework.dao.DuplicateKeyException;
 import org.springframework.dao.PermissionDeniedDataAccessException;
 import org.springframework.dao.TransientDataAccessResourceException;
-import org.springframework.dao.DuplicateKeyException;
 import org.springframework.jdbc.BadSqlGrammarException;
 import org.springframework.jdbc.InvalidResultSetAccessException;
 
@@ -201,20 +200,25 @@ protected DataAccessException doTranslate(String task, String sql, SQLException
 
 		// Check SQLErrorCodes with corresponding error code, if available.
 		if (this.sqlErrorCodes != null) {
-			String errorCode = null;
+			String errorCode;
 			if (this.sqlErrorCodes.isUseSqlStateForTranslation()) {
 				errorCode = sqlEx.getSQLState();
 			}
 			else {
-				errorCode = Integer.toString(sqlEx.getErrorCode());
+				// Try to find SQLException with actual error code, looping through the causes.
+				// E.g. applicable to java.sql.DataTruncation as of JDK 1.6.
+				SQLException current = sqlEx;
+				while (current.getErrorCode() == 0 && current.getCause() instanceof SQLException) {
+					current = (SQLException) current.getCause();
+				}
+				errorCode = Integer.toString(current.getErrorCode());
 			}
 
 			if (errorCode != null) {
 				// Look for defined custom translations first.
 				CustomSQLErrorCodesTranslation[] customTranslations = this.sqlErrorCodes.getCustomTranslations();
 				if (customTranslations != null) {
-					for (int i = 0; i < customTranslations.length; i++) {
-						CustomSQLErrorCodesTranslation customTranslation = customTranslations[i];
+					for (CustomSQLErrorCodesTranslation customTranslation : customTranslations) {
 						if (Arrays.binarySearch(customTranslation.getErrorCodes(), errorCode) >= 0) {
 							if (customTranslation.getExceptionClass() != null) {
 								DataAccessException customException = createCustomException(
@@ -273,7 +277,7 @@ else if (Arrays.binarySearch(this.sqlErrorCodes.getCannotSerializeTransactionCod
 
 		// We couldn't identify it more precisely - let's hand it over to the SQLState fallback translator.
 		if (logger.isDebugEnabled()) {
-			String codes = null;
+			String codes;
 			if (this.sqlErrorCodes != null && this.sqlErrorCodes.isUseSqlStateForTranslation()) {
 				codes = "SQL state '" + sqlEx.getSQLState() + "', error code '" + sqlEx.getErrorCode();
 			}
@@ -321,8 +325,8 @@ protected DataAccessException createCustomException(
 		try {
 			int constructorType = 0;
 			Constructor[] constructors = exceptionClass.getConstructors();
-			for (int i = 0; i < constructors.length; i++) {
-				Class[] parameterTypes = constructors[i].getParameterTypes();
+			for (Constructor constructor : constructors) {
+				Class[] parameterTypes = constructor.getParameterTypes();
 				if (parameterTypes.length == 1 && parameterTypes[0].equals(String.class)) {
 					if (constructorType < MESSAGE_ONLY_CONSTRUCTOR)
 						constructorType = MESSAGE_ONLY_CONSTRUCTOR;
@@ -350,7 +354,7 @@ protected DataAccessException createCustomException(
 			}
 
 			// invoke constructor
-			Constructor exceptionConstructor = null;
+			Constructor exceptionConstructor;
 			switch (constructorType) {
 				case MESSAGE_SQL_SQLEX_CONSTRUCTOR:
 					Class[] messageAndSqlAndSqlExArgsClass = new Class[] {String.class, String.class, SQLException.class};
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/AbstractLobHandler.java b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/AbstractLobHandler.java
index 737a58245927..4da40d61faaf 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/AbstractLobHandler.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/AbstractLobHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2005 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@
 import java.sql.SQLException;
 
 /**
- * Abstract base class for LobHandler implementations.
+ * Abstract base class for {@link LobHandler} implementations.
  *
  * <p>Implements all accessor methods for column names through a column lookup
  * and delegating to the corresponding accessor that takes a column index.
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/DefaultLobHandler.java b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/DefaultLobHandler.java
index 6964172e962f..e570be24f03c 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/DefaultLobHandler.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/DefaultLobHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,18 +32,20 @@
 import org.apache.commons.logging.LogFactory;
 
 /**
- * Default implementation of the {@link LobHandler} interface. Invokes
- * the direct accessor methods that {@code java.sql.ResultSet}
+ * Default implementation of the {@link LobHandler} interface.
+ * Invokes the direct accessor methods that {@code java.sql.ResultSet}
  * and {@code java.sql.PreparedStatement} offer.
  *
  * <p>This LobHandler should work for any JDBC driver that is JDBC compliant
  * in terms of the spec's suggestions regarding simple BLOB and CLOB handling.
- * This does not apply to Oracle 9i, and only to a limited degree to Oracle 10g!
- * As a consequence, use {@link OracleLobHandler} for accessing Oracle BLOBs/CLOBs.
+ * This does not apply to Oracle 9i's drivers at all; as of Oracle 10g,
+ * it does work but may still come with LOB size limitations. Consider using
+ * recent Oracle drivers even when working against an older database server.
+ * See the {@link LobHandler} javadoc for the full set of recommendations.
  *
  * <p>Some JDBC drivers require values with a BLOB/CLOB target column to be
- * explicitly set through the JDBC {@code setBlob} / {@code setClob}
- * API: for example, PostgreSQL's driver. Switch the {@link #setWrapAsLob "wrapAsLob"}
+ * explicitly set through the JDBC {@code setBlob} / {@code setClob} API:
+ * for example, PostgreSQL's driver. Switch the {@link #setWrapAsLob "wrapAsLob"}
  * property to "true" when operating against such a driver.
  *
  * <p>On JDBC 4.0, this LobHandler also supports streaming the BLOB/CLOB content
@@ -51,11 +53,15 @@
  * argument directly. Consider switching the {@link #setStreamAsLob "streamAsLob"}
  * property to "true" when operating against a fully compliant JDBC 4.0 driver.
  *
- * <p>See the {@link LobHandler} javadoc for a summary of recommendations.
+ * <p>Finally, primarily as a direct equivalent to {@link OracleLobHandler},
+ * this LobHandler also supports the creation of temporary BLOB/CLOB objects.
+ * Consider switching the {@link #setCreateTemporaryLob "createTemporaryLob"}
+ * property to "true" when "streamAsLob" happens to run into LOB size limitations.
+ *
+ * <p>See the {@link LobHandler} interface javadoc for a summary of recommendations.
  *
  * @author Juergen Hoeller
  * @since 04.12.2003
- * @see #setStreamAsLob
  * @see java.sql.ResultSet#getBytes
  * @see java.sql.ResultSet#getBinaryStream
  * @see java.sql.ResultSet#getString
@@ -75,15 +81,18 @@ public class DefaultLobHandler extends AbstractLobHandler {
 
 	private boolean streamAsLob = false;
 
+	private boolean createTemporaryLob = false;
+
 
 	/**
 	 * Specify whether to submit a byte array / String to the JDBC driver
 	 * wrapped in a JDBC Blob / Clob object, using the JDBC {@code setBlob} /
 	 * {@code setClob} method with a Blob / Clob argument.
 	 * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}
-	 * / {@code setCharacterStream} method for setting the content.
-	 * Switch this to "true" for explicit Blob / Clob wrapping against
-	 * JDBC drivers that are known to require such wrapping (e.g. PostgreSQL's).
+	 * / {@code setCharacterStream} method for setting the content. Switch this
+	 * to "true" for explicit Blob / Clob wrapping against JDBC drivers that
+	 * are known to require such wrapping (e.g. PostgreSQL's for access to OID
+	 * columns, whereas BYTEA columns need to be accessed the standard way).
 	 * <p>This setting affects byte array / String arguments as well as stream
 	 * arguments, unless {@link #setStreamAsLob "streamAsLob"} overrides this
 	 * handling to use JDBC 4.0's new explicit streaming support (if available).
@@ -100,7 +109,7 @@ public void setWrapAsLob(boolean wrapAsLob) {
 	 * {@code setClob} method with a stream argument.
 	 * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}
 	 * / {@code setCharacterStream} method for setting the content.
-	 * Switch this to "true" for explicit JDBC 4.0 usage, provided that your
+	 * Switch this to "true" for explicit JDBC 4.0 streaming, provided that your
 	 * JDBC driver actually supports those JDBC 4.0 operations (e.g. Derby's).
 	 * <p>This setting affects stream arguments as well as byte array / String
 	 * arguments, requiring JDBC 4.0 support. For supporting LOB content against
@@ -112,6 +121,23 @@ public void setStreamAsLob(boolean streamAsLob) {
 		this.streamAsLob = streamAsLob;
 	}
 
+	/**
+	 * Specify whether to copy a byte array / String into a temporary JDBC
+	 * Blob / Clob object created through the JDBC 4.0 {@code createBlob} /
+	 * {@code createClob} methods.
+	 * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}
+	 * / {@code setCharacterStream} method for setting the content. Switch this
+	 * to "true" for explicit Blob / Clob creation using JDBC 4.0.
+	 * <p>This setting affects stream arguments as well as byte array / String
+	 * arguments, requiring JDBC 4.0 support. For supporting LOB content against
+	 * JDBC 3.0, check out the {@link #setWrapAsLob "wrapAsLob"} setting.
+	 * @see java.sql.Connection#createBlob()
+	 * @see java.sql.Connection#createClob()
+	 */
+	public void setCreateTemporaryLob(boolean createTemporaryLob) {
+		this.createTemporaryLob = createTemporaryLob;
+	}
+
 
 	public byte[] getBlobAsBytes(ResultSet rs, int columnIndex) throws SQLException {
 		logger.debug("Returning BLOB as bytes");
@@ -169,12 +195,12 @@ public Reader getClobAsCharacterStream(ResultSet rs, int columnIndex) throws SQL
 	}
 
 	public LobCreator getLobCreator() {
-		return new DefaultLobCreator();
+		return (this.createTemporaryLob ? new TemporaryLobCreator() : new DefaultLobCreator());
 	}
 
 
 	/**
-	 * Default LobCreator implementation as inner class.
+	 * Default LobCreator implementation as an inner class.
 	 * Can be subclassed in DefaultLobHandler extensions.
 	 */
 	protected class DefaultLobCreator implements LobCreator {
@@ -268,15 +294,10 @@ public void setClobAsAsciiStream(
 				PreparedStatement ps, int paramIndex, InputStream asciiStream, int contentLength)
 				throws SQLException {
 
-			if (streamAsLob || wrapAsLob) {
+			if (streamAsLob) {
 				if (asciiStream != null) {
 					try {
-						if (streamAsLob) {
-							ps.setClob(paramIndex, new InputStreamReader(asciiStream, "US-ASCII"), contentLength);
-						}
-						else {
-							ps.setClob(paramIndex, new PassThroughClob(asciiStream, contentLength));
-						}
+						ps.setClob(paramIndex, new InputStreamReader(asciiStream, "US-ASCII"), contentLength);
 					}
 					catch (UnsupportedEncodingException ex) {
 						throw new SQLException("US-ASCII encoding not supported: " + ex);
@@ -286,6 +307,14 @@ public void setClobAsAsciiStream(
 					ps.setClob(paramIndex, (Clob) null);
 				}
 			}
+			else if (wrapAsLob) {
+				if (asciiStream != null) {
+					ps.setClob(paramIndex, new PassThroughClob(asciiStream, contentLength));
+				}
+				else {
+					ps.setClob(paramIndex, (Clob) null);
+				}
+			}
 			else {
 				ps.setAsciiStream(paramIndex, asciiStream, contentLength);
 			}
@@ -325,7 +354,7 @@ else if (wrapAsLob) {
 		}
 
 		public void close() {
-			// nothing to do here
+			// nothing to do when not creating temporary LOBs
 		}
 	}
 
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/LobHandler.java b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/LobHandler.java
index 251a63a0e8d9..07e1847e4f56 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/LobHandler.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/LobHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,7 +24,7 @@
 /**
  * Abstraction for handling large binary fields and large text fields in
  * specific databases, no matter if represented as simple types or Large OBjects.
- * Its main purpose is to isolate Oracle's peculiar handling of LOBs in
+ * Its main purpose is to isolate Oracle 9i's peculiar handling of LOBs in
  * {@link OracleLobHandler}; most other databases should be able to work
  * with the provided {@link DefaultLobHandler}.
  *
@@ -45,8 +45,10 @@
  * proprietary BLOB/CLOB API, and additionally doesn't accept large streams for
  * PreparedStatement's corresponding setter methods. Therefore, you need to use
  * {@link OracleLobHandler} there, which uses Oracle's BLOB/CLOB API for both types
- * of access. The Oracle 10g JDBC driver should basically work with
- * {@link DefaultLobHandler} as well, with some limitations in terms of LOB sizes.
+ * of access. The Oracle 10g+ JDBC driver will work with {@link DefaultLobHandler}
+ * as well, with some limitations in terms of LOB sizes depending on DBMS setup;
+ * as of Oracle 11g (or actually, using the 11g driver even against older databases),
+ * there should be no need to use {@link OracleLobHandler} at all anymore.
  *
  * <p>Of course, you need to declare different field types for each database.
  * In Oracle, any binary content needs to go into a BLOB, and all character content
@@ -57,12 +59,20 @@
  *
  * <p><b>Summarizing the recommended options (for actual LOB fields):</b>
  * <ul>
- * <li><b>JDBC 4.0 driver:</b> {@link DefaultLobHandler} with {@code streamAsLob=true}.
- * <li><b>PostgreSQL:</b> {@link DefaultLobHandler} with {@code wrapAsLob=true}.
- * <li><b>Oracle 9i/10g:</b> {@link OracleLobHandler} with a connection-pool-specific
+ * <li><b>JDBC 4.0 driver (including Oracle 11g driver):</b> Use {@link DefaultLobHandler},
+ * potentially with {@code streamAsLob=true} if your database driver requires that
+ * hint when populating a LOB field. Fall back to {@code createTemporaryLob=true}
+ * if you happen to run into LOB size limitations with your (Oracle) database setup.
+ * <li><b>Oracle 10g driver:</b> Use {@link DefaultLobHandler} with standard setup.
+ * On Oracle 10.1, set the "SetBigStringTryClob" connection property; as of Oracle 10.2,
+ * DefaultLobHandler should work with standard setup out of the box. Alternatively,
+ * consider using the proprietary {@link OracleLobHandler} (see below).
+ * <li><b>Oracle 9i driver:</b> Use {@link OracleLobHandler} with a connection-pool-specific
  * {@link OracleLobHandler#setNativeJdbcExtractor NativeJdbcExtractor}.
+ * <li><b>PostgreSQL:</b> Configure {@link DefaultLobHandler} with {@code wrapAsLob=true},
+ * and use that LobHandler to access OID columns (but not BYTEA) in your database tables.
  * <li>For all other database drivers (and for non-LOB fields that might potentially
- * turn into LOBs on some databases): a plain {@link DefaultLobHandler}.
+ * turn into LOBs on some databases): Simply use a plain {@link DefaultLobHandler}.
  * </ul>
  *
  * @author Juergen Hoeller
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/OracleLobHandler.java b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/OracleLobHandler.java
index 5399cf9c9103..2b239b3504d8 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/OracleLobHandler.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/OracleLobHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -49,14 +49,23 @@
  * Note that this LobHandler requires Oracle JDBC driver 9i or higher!
  *
  * <p>While most databases are able to work with {@link DefaultLobHandler},
- * Oracle just accepts Blob/Clob instances created via its own proprietary
- * BLOB/CLOB API, and additionally doesn't accept large streams for
- * PreparedStatement's corresponding setter methods. Therefore, you need
- * to use a strategy like this LobHandler implementation.
+ * Oracle 9i (or more specifically, the Oracle 9i JDBC driver) just accepts
+ * Blob/Clob instances created via its own proprietary BLOB/CLOB API,
+ * and additionally doesn't accept large streams for PreparedStatement's
+ * corresponding setter methods. Therefore, you need to use a strategy like
+ * this LobHandler implementation, or upgrade to the Oracle 10g/11g driver
+ * (which still supports access to Oracle 9i databases).
+ *
+ * <p><b>NOTE: As of Oracle 10.2, {@link DefaultLobHandler} should work equally
+ * well out of the box. On Oracle 11g, JDBC 4.0 based options such as
+ * {@link DefaultLobHandler#setStreamAsLob} and {@link DefaultLobHandler#setCreateTemporaryLob}
+ * are available as well, rendering this proprietary OracleLobHandler obsolete.</b>
+ * Also, consider upgrading to a new driver even when accessing an older database.
+ * See the {@link LobHandler} interface javadoc for a summary of recommendations.
  *
  * <p>Needs to work on a native JDBC Connection, to be able to cast it to
  * {@code oracle.jdbc.OracleConnection}. If you pass in Connections from a
- * connection pool (the usual case in a J2EE environment), you need to set an
+ * connection pool (the usual case in a Java EE environment), you need to set an
  * appropriate {@link org.springframework.jdbc.support.nativejdbc.NativeJdbcExtractor}
  * to allow for automatic retrieval of the underlying native JDBC Connection.
  * LobHandler and NativeJdbcExtractor are separate concerns, therefore they
@@ -72,8 +81,15 @@
  * @author Juergen Hoeller
  * @author Thomas Risberg
  * @since 04.12.2003
+ * @see DefaultLobHandler
  * @see #setNativeJdbcExtractor
+ * @deprecated in favor of {@link DefaultLobHandler} for the Oracle 10g driver and
+ * higher. Consider using the 10g/11g driver even against an Oracle 9i database!
+ * {@link DefaultLobHandler#setCreateTemporaryLob} is the direct equivalent of this
+ * OracleLobHandler's implementation strategy, just using standard JDBC 4.0 API.
+ * That said, in most cases, regular DefaultLobHandler setup will work fine as well.
  */
+@Deprecated
 public class OracleLobHandler extends AbstractLobHandler {
 
 	private static final String BLOB_CLASS_NAME = "oracle.sql.BLOB";
@@ -143,7 +159,7 @@ public void setCache(boolean cache) {
 	}
 
 	/**
-	 * Set whether to agressively release any resources used by the LOB. If set to {@code true}
+	 * Set whether to aggressively release any resources used by the LOB. If set to {@code true}
 	 * then you can only read the LOB values once. Any subsequent reads will fail since the resources
 	 * have been closed.
 	 * <p>Setting this property to {@code true} can be useful when your queries generates large
@@ -283,7 +299,7 @@ protected void initializeResourcesBeforeRead(Connection con, Object lob) {
 					((BLOB) lob).open(BLOB.MODE_READONLY);
 					*/
 					Method open = lob.getClass().getMethod("open", int.class);
-					open.invoke(lob, modeReadOnlyConstants.get(lob.getClass()));
+					open.invoke(lob, this.modeReadOnlyConstants.get(lob.getClass()));
 				}
 			}
 			catch (InvocationTargetException ex) {
@@ -366,7 +382,7 @@ protected void releaseResourcesAfterRead(Connection con, Object lob) {
 	 */
 	protected class OracleLobCreator implements LobCreator {
 
-		private final List createdLobs = new LinkedList();
+		private final List<Object> temporaryLobs = new LinkedList<Object>();
 
 		public void setBlobAsBytes(PreparedStatement ps, int paramIndex, final byte[] content)
 				throws SQLException {
@@ -495,7 +511,7 @@ protected Object createLob(PreparedStatement ps, boolean clob, LobCallback callb
 				Object lob = prepareLob(con, clob ? clobClass : blobClass);
 				callback.populateLob(lob);
 				lob.getClass().getMethod("close", (Class[]) null).invoke(lob, (Object[]) null);
-				this.createdLobs.add(lob);
+				this.temporaryLobs.add(lob);
 				if (logger.isDebugEnabled()) {
 					logger.debug("Created new Oracle " + (clob ? "CLOB" : "BLOB"));
 				}
@@ -556,7 +572,7 @@ protected Object prepareLob(Connection con, Class lobClass) throws Exception {
 		 */
 		public void close() {
 			try {
-				for (Iterator it = this.createdLobs.iterator(); it.hasNext();) {
+				for (Iterator it = this.temporaryLobs.iterator(); it.hasNext();) {
 					/*
 					BLOB blob = (BLOB) it.next();
 					blob.freeTemporary();
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/TemporaryLobCreator.java b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/TemporaryLobCreator.java
new file mode 100644
index 000000000000..f8c52660cb7d
--- /dev/null
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/lob/TemporaryLobCreator.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.jdbc.support.lob;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.sql.Blob;
+import java.sql.Clob;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import org.springframework.dao.DataAccessResourceFailureException;
+import org.springframework.util.FileCopyUtils;
+
+/**
+ * {@link LobCreator} implementation based on temporary LOBs,
+ * using JDBC 4.0's {@link java.sql.Connection#createBlob()} /
+ * {@link java.sql.Connection#createClob()} mechanism.
+ *
+ * <p>Used by DefaultLobHandler's {@link DefaultLobHandler#setCreateTemporaryLob} mode.
+ * Can also be used directly to reuse the tracking and freeing of temporary LOBs.
+ *
+ * @author Juergen Hoeller
+ * @since 3.2.2
+ * @see DefaultLobHandler#setCreateTemporaryLob
+ * @see java.sql.Connection#createBlob()
+ * @see java.sql.Connection#createClob()
+ */
+public class TemporaryLobCreator implements LobCreator {
+
+	protected static final Log logger = LogFactory.getLog(TemporaryLobCreator.class);
+
+	private final Set<Blob> temporaryBlobs = new LinkedHashSet<Blob>(1);
+
+	private final Set<Clob> temporaryClobs = new LinkedHashSet<Clob>(1);
+
+
+	public void setBlobAsBytes(PreparedStatement ps, int paramIndex, byte[] content)
+			throws SQLException {
+
+		Blob blob = ps.getConnection().createBlob();
+		blob.setBytes(1, content);
+
+		this.temporaryBlobs.add(blob);
+		ps.setBlob(paramIndex, blob);
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(content != null ? "Copied bytes into temporary BLOB with length " + content.length :
+					"Set BLOB to null");
+		}
+	}
+
+	public void setBlobAsBinaryStream(
+			PreparedStatement ps, int paramIndex, InputStream binaryStream, int contentLength)
+			throws SQLException {
+
+		Blob blob = ps.getConnection().createBlob();
+		try {
+			FileCopyUtils.copy(binaryStream, blob.setBinaryStream(1));
+		}
+		catch (IOException ex) {
+			throw new DataAccessResourceFailureException("Could not copy into LOB stream", ex);
+		}
+
+		this.temporaryBlobs.add(blob);
+		ps.setBlob(paramIndex, blob);
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(binaryStream != null ?
+					"Copied binary stream into temporary BLOB with length " + contentLength :
+					"Set BLOB to null");
+		}
+	}
+
+	public void setClobAsString(PreparedStatement ps, int paramIndex, String content)
+			throws SQLException {
+
+		Clob clob = ps.getConnection().createClob();
+		clob.setString(1, content);
+
+		this.temporaryClobs.add(clob);
+		ps.setClob(paramIndex, clob);
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(content != null ? "Copied string into temporary CLOB with length " + content.length() :
+					"Set CLOB to null");
+		}
+	}
+
+	public void setClobAsAsciiStream(
+			PreparedStatement ps, int paramIndex, InputStream asciiStream, int contentLength)
+			throws SQLException {
+
+		Clob clob = ps.getConnection().createClob();
+		try {
+			FileCopyUtils.copy(asciiStream, clob.setAsciiStream(1));
+		}
+		catch (IOException ex) {
+			throw new DataAccessResourceFailureException("Could not copy into LOB stream", ex);
+		}
+
+		this.temporaryClobs.add(clob);
+		ps.setClob(paramIndex, clob);
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(asciiStream != null ?
+					"Copied ASCII stream into temporary CLOB with length " + contentLength :
+					"Set CLOB to null");
+		}
+	}
+
+	public void setClobAsCharacterStream(
+			PreparedStatement ps, int paramIndex, Reader characterStream, int contentLength)
+			throws SQLException {
+
+		Clob clob = ps.getConnection().createClob();
+		try {
+			FileCopyUtils.copy(characterStream, clob.setCharacterStream(1));
+		}
+		catch (IOException ex) {
+			throw new DataAccessResourceFailureException("Could not copy into LOB stream", ex);
+		}
+
+		this.temporaryClobs.add(clob);
+		ps.setClob(paramIndex, clob);
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(characterStream != null ?
+					"Copied character stream into temporary CLOB with length " + contentLength :
+					"Set CLOB to null");
+		}
+	}
+
+	public void close() {
+		try {
+			for (Blob blob : this.temporaryBlobs) {
+				blob.free();
+			}
+			for (Clob clob : this.temporaryClobs) {
+				clob.free();
+			}
+		}
+		catch (SQLException ex) {
+			logger.error("Could not free LOB", ex);
+		}
+	}
+}
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/support/nativejdbc/WebLogicNativeJdbcExtractor.java b/spring-jdbc/src/main/java/org/springframework/jdbc/support/nativejdbc/WebLogicNativeJdbcExtractor.java
index e967966aee5c..09129320e5b9 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/support/nativejdbc/WebLogicNativeJdbcExtractor.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/nativejdbc/WebLogicNativeJdbcExtractor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,7 +24,7 @@
 
 /**
  * Implementation of the {@link NativeJdbcExtractor} interface for WebLogic,
- * supporting WebLogic Server 8.1 and higher.
+ * supporting WebLogic Server 9.0 and higher.
  *
  * <p>Returns the underlying native Connection to application code instead
  * of WebLogic's wrapper implementation; unwraps the Connection for native
diff --git a/spring-jdbc/src/main/java/org/springframework/jdbc/support/nativejdbc/WebSphereNativeJdbcExtractor.java b/spring-jdbc/src/main/java/org/springframework/jdbc/support/nativejdbc/WebSphereNativeJdbcExtractor.java
index d40a575c7a87..b225ea19d229 100644
--- a/spring-jdbc/src/main/java/org/springframework/jdbc/support/nativejdbc/WebSphereNativeJdbcExtractor.java
+++ b/spring-jdbc/src/main/java/org/springframework/jdbc/support/nativejdbc/WebSphereNativeJdbcExtractor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,7 +24,7 @@
 
 /**
  * Implementation of the {@link NativeJdbcExtractor} interface for WebSphere,
- * supporting WebSphere Application Server 5.1 and higher.
+ * supporting WebSphere Application Server 6.1 and higher.
  *
  * <p>Returns the underlying native Connection to application code instead
  * of WebSphere's wrapper implementation; unwraps the Connection for
@@ -40,14 +40,14 @@
  */
 public class WebSphereNativeJdbcExtractor extends NativeJdbcExtractorAdapter {
 
-	private static final String JDBC_ADAPTER_CONNECTION_NAME_5 = "com.ibm.ws.rsadapter.jdbc.WSJdbcConnection";
+	private static final String JDBC_ADAPTER_CONNECTION_NAME = "com.ibm.ws.rsadapter.jdbc.WSJdbcConnection";
 
-	private static final String JDBC_ADAPTER_UTIL_NAME_5 = "com.ibm.ws.rsadapter.jdbc.WSJdbcUtil";
+	private static final String JDBC_ADAPTER_UTIL_NAME = "com.ibm.ws.rsadapter.jdbc.WSJdbcUtil";
 
 
-	private Class webSphere5ConnectionClass;
+	private Class webSphereConnectionClass;
 
-	private Method webSphere5NativeConnectionMethod;
+	private Method webSphereNativeConnectionMethod;
 
 
 	/**
@@ -56,10 +56,10 @@ public class WebSphereNativeJdbcExtractor extends NativeJdbcExtractorAdapter {
 	 */
 	public WebSphereNativeJdbcExtractor() {
 		try {
-			this.webSphere5ConnectionClass = getClass().getClassLoader().loadClass(JDBC_ADAPTER_CONNECTION_NAME_5);
-			Class jdbcAdapterUtilClass = getClass().getClassLoader().loadClass(JDBC_ADAPTER_UTIL_NAME_5);
-			this.webSphere5NativeConnectionMethod =
-					jdbcAdapterUtilClass.getMethod("getNativeConnection", new Class[] {this.webSphere5ConnectionClass});
+			this.webSphereConnectionClass = getClass().getClassLoader().loadClass(JDBC_ADAPTER_CONNECTION_NAME);
+			Class jdbcAdapterUtilClass = getClass().getClassLoader().loadClass(JDBC_ADAPTER_UTIL_NAME);
+			this.webSphereNativeConnectionMethod =
+					jdbcAdapterUtilClass.getMethod("getNativeConnection", new Class[] {this.webSphereConnectionClass});
 		}
 		catch (Exception ex) {
 			throw new IllegalStateException(
@@ -97,9 +97,8 @@ public boolean isNativeConnectionNecessaryForNativeCallableStatements() {
 	 */
 	@Override
 	protected Connection doGetNativeConnection(Connection con) throws SQLException {
-		if (this.webSphere5ConnectionClass.isAssignableFrom(con.getClass())) {
-			return (Connection) ReflectionUtils.invokeJdbcMethod(
-					this.webSphere5NativeConnectionMethod, null, new Object[] {con});
+		if (this.webSphereConnectionClass.isAssignableFrom(con.getClass())) {
+			return (Connection) ReflectionUtils.invokeJdbcMethod(this.webSphereNativeConnectionMethod, null, con);
 		}
 		return con;
 	}
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/AbstractRowMapperTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/AbstractRowMapperTests.java
index 98016c611349..e6e2121c8d1c 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/AbstractRowMapperTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/AbstractRowMapperTests.java
@@ -16,12 +16,6 @@
 
 package org.springframework.jdbc.core;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.math.BigDecimal;
 import java.sql.Connection;
 import java.sql.ResultSet;
@@ -35,6 +29,9 @@
 import org.springframework.jdbc.datasource.SingleConnectionDataSource;
 import org.springframework.jdbc.support.SQLStateSQLExceptionTranslator;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Mock object based abstract class for RowMapper tests.
  * Initializes mock objects and verifies results.
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/JdbcTemplateQueryTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/JdbcTemplateQueryTests.java
index 86518a5f8769..f9963c11233f 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/JdbcTemplateQueryTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/JdbcTemplateQueryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,6 @@
 
 package org.springframework.jdbc.core;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.sql.Connection;
@@ -43,6 +35,9 @@
 import org.junit.rules.ExpectedException;
 import org.springframework.dao.IncorrectResultSizeDataAccessException;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/JdbcTemplateTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/JdbcTemplateTests.java
index 3c4e1bc73ae6..ffa2d74ddfcf 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/JdbcTemplateTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/JdbcTemplateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,26 +16,6 @@
 
 package org.springframework.jdbc.core;
 
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.instanceOf;
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.springframework.tests.Matchers.exceptionCause;
-
 import java.sql.CallableStatement;
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
@@ -71,6 +51,11 @@
 import org.springframework.jdbc.support.nativejdbc.NativeJdbcExtractorAdapter;
 import org.springframework.util.LinkedCaseInsensitiveMap;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+import static org.springframework.tests.Matchers.*;
+
 /**
  * Mock object based tests for JdbcTemplate.
  *
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/RowMapperTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/RowMapperTests.java
index 60a4b4b3499b..a44686f3a617 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/RowMapperTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/RowMapperTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.jdbc.core;
 
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
@@ -34,9 +29,11 @@
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.jdbc.datasource.SingleConnectionDataSource;
 import org.springframework.jdbc.support.SQLStateSQLExceptionTranslator;
+import org.springframework.tests.sample.beans.TestBean;
+
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Juergen Hoeller
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/StatementCreatorUtilsTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/StatementCreatorUtilsTests.java
index 00e229ba9dc6..694c3c65fad6 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/StatementCreatorUtilsTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/StatementCreatorUtilsTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,6 @@
 
 package org.springframework.jdbc.core;
 
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.PreparedStatement;
@@ -30,6 +26,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 31.08.2004
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/BeanPropertySqlParameterSourceTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/BeanPropertySqlParameterSourceTests.java
index a684629973a9..15b0e2193389 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/BeanPropertySqlParameterSourceTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/BeanPropertySqlParameterSourceTests.java
@@ -81,6 +81,8 @@ public void hasValueWhereTheUnderlyingBeanPropertyIsNotReadable() throws Excepti
 		assertFalse(source.hasValue("noOp"));
 	}
 
+
+	@SuppressWarnings("unused")
 	private static final class NoReadableProperties {
 
 		public void setNoOp(String noOp) {
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplateTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplateTests.java
index 6564fe5ee7a9..a8c27275e817 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplateTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/NamedParameterJdbcTemplateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,6 @@
 
 package org.springframework.jdbc.core.namedparam;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.PreparedStatement;
@@ -53,6 +44,9 @@
 import org.springframework.jdbc.core.RowMapper;
 import org.springframework.jdbc.core.SqlParameterValue;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
@@ -64,6 +58,8 @@ public class NamedParameterJdbcTemplateTests {
 		"select id, forename from custmr where id = :id and country = :country";
 	private static final String SELECT_NAMED_PARAMETERS_PARSED =
 		"select id, forename from custmr where id = ? and country = ?";
+	private static final String SELECT_NO_PARAMETERS =
+			"select id, forename from custmr";
 
 	private static final String UPDATE_NAMED_PARAMETERS =
 		"update seat_status set booking_id = null where performance_id = :perfId and price_band_id = :priceId";
@@ -161,33 +157,23 @@ public Object doInPreparedStatement(PreparedStatement ps)
 		verify(connection).close();
 	}
 
-	@Test public void testUpdate() throws SQLException {
-		given(preparedStatement.executeUpdate()).willReturn(1);
-
-		params.put("perfId", 1);
-		params.put("priceId", 1);
-		int rowsAffected = namedParameterTemplate.update(UPDATE_NAMED_PARAMETERS, params);
-
-		assertEquals(1, rowsAffected);
-		verify(connection).prepareStatement(UPDATE_NAMED_PARAMETERS_PARSED);
-		verify(preparedStatement).setObject(1, 1);
-		verify(preparedStatement).setObject(2, 1);
-		verify(preparedStatement).close();
-		verify(connection).close();
-	}
-
 	@Test
-	public void testUpdateWithTypedParameters() throws SQLException {
+	public void testExecuteNoParameters() throws SQLException {
 		given(preparedStatement.executeUpdate()).willReturn(1);
 
-		params.put("perfId", new SqlParameterValue(Types.DECIMAL, 1));
-		params.put("priceId", new SqlParameterValue(Types.INTEGER, 1));
-		int rowsAffected = namedParameterTemplate.update(UPDATE_NAMED_PARAMETERS, params);
+		Object result = namedParameterTemplate.execute(SELECT_NO_PARAMETERS,
+				new PreparedStatementCallback<Object>() {
+					@Override
+					public Object doInPreparedStatement(PreparedStatement ps)
+							throws SQLException {
+						assertEquals(preparedStatement, ps);
+						ps.executeQuery();
+						return "result";
+					}
+				});
 
-		assertEquals(1, rowsAffected);
-		verify(connection).prepareStatement(UPDATE_NAMED_PARAMETERS_PARSED);
-		verify(preparedStatement).setObject(1, 1, Types.DECIMAL);
-		verify(preparedStatement).setObject(2, 1, Types.INTEGER);
+		assertEquals("result", result);
+		verify(connection).prepareStatement(SELECT_NO_PARAMETERS);
 		verify(preparedStatement).close();
 		verify(connection).close();
 	}
@@ -222,6 +208,32 @@ public Customer extractData(ResultSet rs) throws SQLException,
 		verify(connection).close();
 	}
 
+	@Test
+	public void testQueryWithResultSetExtractorNoParameters() throws SQLException {
+		given(resultSet.next()).willReturn(true);
+		given(resultSet.getInt("id")).willReturn(1);
+		given(resultSet.getString("forename")).willReturn("rod");
+
+		Customer cust = namedParameterTemplate.query(SELECT_NO_PARAMETERS,
+				new ResultSetExtractor<Customer>() {
+					@Override
+					public Customer extractData(ResultSet rs) throws SQLException,
+							DataAccessException {
+						rs.next();
+						Customer cust = new Customer();
+						cust.setId(rs.getInt(COLUMN_NAMES[0]));
+						cust.setForename(rs.getString(COLUMN_NAMES[1]));
+						return cust;
+					}
+				});
+
+		assertTrue("Customer id was assigned correctly", cust.getId() == 1);
+		assertTrue("Customer forename was assigned correctly", cust.getForename().equals("rod"));
+		verify(connection).prepareStatement(SELECT_NO_PARAMETERS);
+		verify(preparedStatement).close();
+		verify(connection).close();
+	}
+
 	@Test
 	public void testQueryWithRowCallbackHandler() throws SQLException {
 		given(resultSet.next()).willReturn(true, false);
@@ -251,6 +263,31 @@ public void processRow(ResultSet rs) throws SQLException {
 		verify(connection).close();
 	}
 
+	@Test
+	public void testQueryWithRowCallbackHandlerNoParameters() throws SQLException {
+		given(resultSet.next()).willReturn(true, false);
+		given(resultSet.getInt("id")).willReturn(1);
+		given(resultSet.getString("forename")).willReturn("rod");
+
+		final List<Customer> customers = new LinkedList<Customer>();
+		namedParameterTemplate.query(SELECT_NO_PARAMETERS, new RowCallbackHandler() {
+			@Override
+			public void processRow(ResultSet rs) throws SQLException {
+				Customer cust = new Customer();
+				cust.setId(rs.getInt(COLUMN_NAMES[0]));
+				cust.setForename(rs.getString(COLUMN_NAMES[1]));
+				customers.add(cust);
+			}
+		});
+
+		assertEquals(1, customers.size());
+		assertTrue("Customer id was assigned correctly", customers.get(0).getId() == 1);
+		assertTrue("Customer forename was assigned correctly", customers.get(0).getForename().equals("rod"));
+		verify(connection).prepareStatement(SELECT_NO_PARAMETERS);
+		verify(preparedStatement).close();
+		verify(connection).close();
+	}
+
 	@Test
 	public void testQueryWithRowMapper() throws SQLException {
 		given(resultSet.next()).willReturn(true, false);
@@ -279,6 +316,30 @@ public Customer mapRow(ResultSet rs, int rownum) throws SQLException {
 		verify(connection).close();
 	}
 
+	@Test
+	public void testQueryWithRowMapperNoParameters() throws SQLException {
+		given(resultSet.next()).willReturn(true, false);
+		given(resultSet.getInt("id")).willReturn(1);
+		given(resultSet.getString("forename")).willReturn("rod");
+
+		List<Customer> customers = namedParameterTemplate.query(SELECT_NO_PARAMETERS,
+				new RowMapper<Customer>() {
+					@Override
+					public Customer mapRow(ResultSet rs, int rownum) throws SQLException {
+						Customer cust = new Customer();
+						cust.setId(rs.getInt(COLUMN_NAMES[0]));
+						cust.setForename(rs.getString(COLUMN_NAMES[1]));
+						return cust;
+					}
+				});
+		assertEquals(1, customers.size());
+		assertTrue("Customer id was assigned correctly", customers.get(0).getId() == 1);
+		assertTrue("Customer forename was assigned correctly", customers.get(0).getForename().equals("rod"));
+		verify(connection).prepareStatement(SELECT_NO_PARAMETERS);
+		verify(preparedStatement).close();
+		verify(connection).close();
+	}
+
 	@Test
 	public void testQueryForObjectWithRowMapper() throws SQLException {
 		given(resultSet.next()).willReturn(true, false);
@@ -307,8 +368,39 @@ public Customer mapRow(ResultSet rs, int rownum) throws SQLException {
 	}
 
 	@Test
-	public void testBatchUpdateWithPlainMap() throws Exception {
+	public void testUpdate() throws SQLException {
+		given(preparedStatement.executeUpdate()).willReturn(1);
 
+		params.put("perfId", 1);
+		params.put("priceId", 1);
+		int rowsAffected = namedParameterTemplate.update(UPDATE_NAMED_PARAMETERS, params);
+
+		assertEquals(1, rowsAffected);
+		verify(connection).prepareStatement(UPDATE_NAMED_PARAMETERS_PARSED);
+		verify(preparedStatement).setObject(1, 1);
+		verify(preparedStatement).setObject(2, 1);
+		verify(preparedStatement).close();
+		verify(connection).close();
+	}
+
+	@Test
+	public void testUpdateWithTypedParameters() throws SQLException {
+		given(preparedStatement.executeUpdate()).willReturn(1);
+
+		params.put("perfId", new SqlParameterValue(Types.DECIMAL, 1));
+		params.put("priceId", new SqlParameterValue(Types.INTEGER, 1));
+		int rowsAffected = namedParameterTemplate.update(UPDATE_NAMED_PARAMETERS, params);
+
+		assertEquals(1, rowsAffected);
+		verify(connection).prepareStatement(UPDATE_NAMED_PARAMETERS_PARSED);
+		verify(preparedStatement).setObject(1, 1, Types.DECIMAL);
+		verify(preparedStatement).setObject(2, 1, Types.INTEGER);
+		verify(preparedStatement).close();
+		verify(connection).close();
+	}
+
+	@Test
+	public void testBatchUpdateWithPlainMap() throws Exception {
 		@SuppressWarnings("unchecked")
 		final Map<String, Integer>[] ids = new Map[2];
 		ids[0] = Collections.singletonMap("id", 100);
@@ -335,7 +427,7 @@ public void testBatchUpdateWithPlainMap() throws Exception {
 
 	@Test
 	public void testBatchUpdateWithSqlParameterSource() throws Exception {
-		final SqlParameterSource[] ids = new SqlParameterSource[2];
+		SqlParameterSource[] ids = new SqlParameterSource[2];
 		ids[0] = new MapSqlParameterSource("id", 100);
 		ids[1] = new MapSqlParameterSource("id", 200);
 		final int[] rowsAffected = new int[] { 1, 2 };
@@ -360,8 +452,7 @@ public void testBatchUpdateWithSqlParameterSource() throws Exception {
 
 	@Test
 	public void testBatchUpdateWithSqlParameterSourcePlusTypeInfo() throws Exception {
-
-		final SqlParameterSource[] ids = new SqlParameterSource[2];
+		SqlParameterSource[] ids = new SqlParameterSource[2];
 		ids[0] = new MapSqlParameterSource().addValue("id", 100, Types.NUMERIC);
 		ids[1] = new MapSqlParameterSource().addValue("id", 200, Types.NUMERIC);
 		final int[] rowsAffected = new int[] { 1, 2 };
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/NamedParameterQueryTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/NamedParameterQueryTests.java
index 80c7a07f2e2f..73e9b46ff59f 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/NamedParameterQueryTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/namedparam/NamedParameterQueryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,13 +16,6 @@
 
 package org.springframework.jdbc.core.namedparam;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
@@ -42,6 +35,9 @@
 import org.junit.Test;
 import org.springframework.jdbc.core.RowMapper;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Thomas Risberg
  * @author Phillip Webb
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/CallMetaDataContextTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/CallMetaDataContextTests.java
index 0b09e04dc3f6..22498510c746 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/CallMetaDataContextTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/CallMetaDataContextTests.java
@@ -1,11 +1,5 @@
 package org.springframework.jdbc.core.simple;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.Types;
@@ -24,6 +18,9 @@
 import org.springframework.jdbc.core.metadata.CallMetaDataContext;
 import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Mock object based tests for CallMetaDataContext.
  *
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcCallTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcCallTests.java
index 9779c29d65da..0559f34b8c84 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcCallTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcCallTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,6 @@
 
 package org.springframework.jdbc.core.simple;
 
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.springframework.tests.Matchers.exceptionCause;
-
 import java.sql.CallableStatement;
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
@@ -43,6 +35,11 @@
 import org.springframework.jdbc.core.SqlParameter;
 import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+import static org.springframework.tests.Matchers.*;
+
 /**
  * Mock object based tests for SimpleJdbcCall.
  *
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcInsertTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcInsertTests.java
index 85b6263e47fa..9d76aeebd49a 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcInsertTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcInsertTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,6 @@
 
 package org.springframework.jdbc.core.simple;
 
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.ResultSet;
@@ -34,6 +30,8 @@
 import org.junit.rules.ExpectedException;
 import org.springframework.dao.InvalidDataAccessApiUsageException;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * Mock object based tests for SimpleJdbcInsert.
  *
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcTemplateTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcTemplateTests.java
index 05f289076ba6..8c5a2024df0e 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcTemplateTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/SimpleJdbcTemplateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,6 @@
 
 package org.springframework.jdbc.core.simple;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.PreparedStatement;
@@ -48,6 +39,9 @@
 import org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;
 import org.springframework.jdbc.core.namedparam.SqlParameterSource;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Rob Harrop
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/TableMetaDataContextTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/TableMetaDataContextTests.java
index 34572961a808..968883fd6a28 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/TableMetaDataContextTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/simple/TableMetaDataContextTests.java
@@ -16,12 +16,6 @@
 
 package org.springframework.jdbc.core.simple;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.ResultSet;
@@ -38,6 +32,9 @@
 import org.springframework.jdbc.core.metadata.TableMetaDataContext;
 import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Mock object based tests for TableMetaDataContext.
  *
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/JdbcBeanDefinitionReaderTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/JdbcBeanDefinitionReaderTests.java
index 664c2ff24b14..6e5779c26a40 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/JdbcBeanDefinitionReaderTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/JdbcBeanDefinitionReaderTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.jdbc.core.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.ResultSet;
 import java.sql.Statement;
@@ -28,8 +23,11 @@
 import javax.sql.DataSource;
 
 import org.junit.Test;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
+import org.springframework.tests.sample.beans.TestBean;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Rod Johnson
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/JdbcDaoSupportTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/JdbcDaoSupportTests.java
index 1aefee1e9464..45e11b3c2522 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/JdbcDaoSupportTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/JdbcDaoSupportTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,6 @@
 
 package org.springframework.jdbc.core.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -27,6 +24,9 @@
 import org.junit.Test;
 import org.springframework.jdbc.core.JdbcTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 30.07.2003
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/LobSupportTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/LobSupportTests.java
index feba295516b3..a243d59ba42a 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/LobSupportTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/LobSupportTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,6 @@
 
 package org.springframework.jdbc.core.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.IOException;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
@@ -36,6 +30,9 @@
 import org.springframework.jdbc.support.lob.LobCreator;
 import org.springframework.jdbc.support.lob.LobHandler;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Alef Arendsen
  */
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/SqlLobValueTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/SqlLobValueTests.java
index 8a7cc6454695..d0003d4f56f4 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/SqlLobValueTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/core/support/SqlLobValueTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,14 +15,6 @@
  */
 package org.springframework.jdbc.core.support;
 
-import static org.hamcrest.Matchers.equalTo;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -40,6 +32,10 @@
 import org.springframework.jdbc.support.lob.LobCreator;
 import org.springframework.jdbc.support.lob.LobHandler;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test cases for the sql lob value:
  *
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceJtaTransactionTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceJtaTransactionTests.java
index 3d6d4d4d1770..4563a2b197ec 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceJtaTransactionTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceJtaTransactionTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,19 +16,6 @@
 
 package org.springframework.jdbc.datasource;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.HashMap;
@@ -59,6 +46,9 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 17.10.2005
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceTransactionManagerTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceTransactionManagerTests.java
index c02dcbf02de8..3c29aa3ae89c 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceTransactionManagerTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DataSourceTransactionManagerTests.java
@@ -16,14 +16,6 @@
 
 package org.springframework.jdbc.datasource;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.PreparedStatement;
@@ -55,6 +47,9 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 04.07.2003
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DelegatingDataSourceTest.java b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DelegatingDataSourceTest.java
index de22e56058e6..05295b56dde3 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DelegatingDataSourceTest.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DelegatingDataSourceTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,6 @@
 
 package org.springframework.jdbc.datasource;
 
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertThat;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.ByteArrayOutputStream;
 import java.io.PrintWriter;
 import java.sql.Connection;
@@ -31,6 +25,10 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Tests for {@link DelegatingDataSource}.
  *
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DriverManagerDataSourceTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DriverManagerDataSourceTests.java
index ec33bdeaf1e5..d4c1be90262c 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DriverManagerDataSourceTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/DriverManagerDataSourceTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,14 @@
 
 package org.springframework.jdbc.datasource;
 
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.mock;
-
 import java.sql.Connection;
 import java.util.Properties;
 
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  */
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/UserCredentialsDataSourceAdapterTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/UserCredentialsDataSourceAdapterTests.java
index 221a9e59fbcd..0a9f8b7df18c 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/UserCredentialsDataSourceAdapterTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/UserCredentialsDataSourceAdapterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,6 @@
 
 package org.springframework.jdbc.datasource;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import java.sql.Connection;
 import java.sql.SQLException;
 
@@ -27,6 +23,9 @@
 
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 28.05.2004
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/init/DatabasePopulatorTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/init/DatabasePopulatorTests.java
index 2e5c67d0f2b9..64f09cc77cc9 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/init/DatabasePopulatorTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/init/DatabasePopulatorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,6 @@
 
 package org.springframework.jdbc.datasource.init;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.SQLException;
 
@@ -32,6 +28,9 @@
 import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Dave Syer
  * @author Sam Brannen
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/lookup/BeanFactoryDataSourceLookupTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/lookup/BeanFactoryDataSourceLookupTests.java
index 1ad38f1457c0..ec2e2b4d0d7b 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/lookup/BeanFactoryDataSourceLookupTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/datasource/lookup/BeanFactoryDataSourceLookupTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,18 +16,15 @@
 
 package org.springframework.jdbc.datasource.lookup;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import javax.sql.DataSource;
 
 import org.junit.Test;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanNotOfRequiredTypeException;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/object/BatchSqlUpdateTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/object/BatchSqlUpdateTests.java
index f325d4891f3c..e0352b941c82 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/object/BatchSqlUpdateTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/object/BatchSqlUpdateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
  * use this file except in compliance with the License. You may obtain a copy of
@@ -16,13 +16,6 @@
 
 package org.springframework.jdbc.object;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.PreparedStatement;
@@ -33,6 +26,9 @@
 import org.junit.Test;
 import org.springframework.jdbc.core.SqlParameter;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 22.02.2005
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/object/GenericSqlQueryTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/object/GenericSqlQueryTests.java
index 6f17fc2044ec..b43b68957255 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/object/GenericSqlQueryTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/object/GenericSqlQueryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,11 +17,6 @@
 package org.springframework.jdbc.object;
 
 
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
@@ -43,6 +38,9 @@
 import org.springframework.jdbc.Customer;
 import org.springframework.jdbc.datasource.TestDataSourceWrapper;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Thomas Risberg
  */
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/object/GenericStoredProcedureTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/object/GenericStoredProcedureTests.java
index 4a5c78738250..c7260f2bd3d7 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/object/GenericStoredProcedureTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/object/GenericStoredProcedureTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,6 @@
 
 package org.springframework.jdbc.object;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.CallableStatement;
 import java.sql.Connection;
 import java.sql.Types;
@@ -37,6 +32,9 @@
 import org.springframework.jdbc.core.JdbcTemplate;
 import org.springframework.jdbc.datasource.TestDataSourceWrapper;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Thomas Risberg
  */
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/object/SqlQueryTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/object/SqlQueryTests.java
index 10a2248c374a..3dc5c36d89b9 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/object/SqlQueryTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/object/SqlQueryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,18 +16,6 @@
 
 package org.springframework.jdbc.object;
 
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
@@ -51,6 +39,10 @@
 import org.springframework.jdbc.Customer;
 import org.springframework.jdbc.core.SqlParameter;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Trevor Cook
  * @author Thomas Risberg
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/object/SqlUpdateTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/object/SqlUpdateTests.java
index c57e430f67b2..718f085b29e5 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/object/SqlUpdateTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/object/SqlUpdateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,6 @@
 
 package org.springframework.jdbc.object;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
@@ -42,6 +37,9 @@
 import org.springframework.jdbc.support.GeneratedKeyHolder;
 import org.springframework.jdbc.support.KeyHolder;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Trevor Cook
  * @author Thomas Risberg
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/object/StoredProcedureTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/object/StoredProcedureTests.java
index 6d2ce8106fe5..d31f74315725 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/object/StoredProcedureTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/object/StoredProcedureTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,17 +16,6 @@
 
 package org.springframework.jdbc.object;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.startsWith;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
 import java.math.BigDecimal;
 import java.sql.CallableStatement;
 import java.sql.Connection;
@@ -62,6 +51,9 @@
 import org.springframework.jdbc.support.SQLStateSQLExceptionTranslator;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Thomas Risberg
  * @author Trevor Cook
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/support/DataFieldMaxValueIncrementerTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/support/DataFieldMaxValueIncrementerTests.java
index 6d23a8e8284e..b1e021d2e3f5 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/support/DataFieldMaxValueIncrementerTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/support/DataFieldMaxValueIncrementerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,12 +16,6 @@
 
 package org.springframework.jdbc.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -35,6 +29,9 @@
 import org.springframework.jdbc.support.incrementer.OracleSequenceMaxValueIncrementer;
 import org.springframework.jdbc.support.incrementer.PostgreSQLSequenceMaxValueIncrementer;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 27.02.2004
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/support/DefaultLobHandlerTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/support/DefaultLobHandlerTests.java
index 14e4d5bf682b..1426ade1044a 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/support/DefaultLobHandlerTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/support/DefaultLobHandlerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,6 @@
 
 package org.springframework.jdbc.support;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -33,6 +30,8 @@
 import org.springframework.jdbc.support.lob.LobCreator;
 import org.springframework.jdbc.support.lob.LobHandler;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 17.12.2003
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/support/NativeJdbcExtractorTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/support/NativeJdbcExtractorTests.java
index f99ae954ddee..d70991e608d1 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/support/NativeJdbcExtractorTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/support/NativeJdbcExtractorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,6 @@
 
 package org.springframework.jdbc.support;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import java.sql.CallableStatement;
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
@@ -32,6 +28,9 @@
 import org.springframework.jdbc.support.nativejdbc.CommonsDbcpNativeJdbcExtractor;
 import org.springframework.jdbc.support.nativejdbc.SimpleNativeJdbcExtractor;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Andre Biryukov
  * @author Juergen Hoeller
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslatorTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslatorTests.java
index c2e07ec7653e..f7a23fa2e0ea 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslatorTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLErrorCodeSQLExceptionTranslatorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,9 @@
 
 package org.springframework.jdbc.support;
 
-import java.sql.SQLException;
 import java.sql.BatchUpdateException;
+import java.sql.DataTruncation;
+import java.sql.SQLException;
 
 import junit.framework.TestCase;
 
@@ -33,6 +34,7 @@
 
 /**
  * @author Rod Johnson
+ * @author Juergen Hoeller
  */
 public class SQLErrorCodeSQLExceptionTranslatorTests extends TestCase {
 
@@ -92,13 +94,21 @@ public void testBatchExceptionTranslation() {
 		SQLExceptionTranslator sext = new SQLErrorCodeSQLExceptionTranslator(ERROR_CODES);
 
 		SQLException badSqlEx = new SQLException("", "", 1);
-		BatchUpdateException batchUdateEx = new BatchUpdateException();
-		batchUdateEx.setNextException(badSqlEx);
-		BadSqlGrammarException bsgex = (BadSqlGrammarException) sext.translate("task", "SQL", batchUdateEx);
+		BatchUpdateException batchUpdateEx = new BatchUpdateException();
+		batchUpdateEx.setNextException(badSqlEx);
+		BadSqlGrammarException bsgex = (BadSqlGrammarException) sext.translate("task", "SQL", batchUpdateEx);
 		assertEquals("SQL", bsgex.getSql());
 		assertEquals(badSqlEx, bsgex.getSQLException());
 	}
 
+	public void testDataTruncationTranslation() {
+		SQLExceptionTranslator sext = new SQLErrorCodeSQLExceptionTranslator(ERROR_CODES);
+
+		SQLException dataAccessEx = new SQLException("", "", 5);
+		DataTruncation dataTruncation = new DataTruncation(1, true, true, 1, 1, dataAccessEx);
+		DataAccessResourceFailureException daex = (DataAccessResourceFailureException) sext.translate("task", "SQL", dataTruncation);
+		assertEquals(dataTruncation, daex.getCause());
+	}
 
 	@SuppressWarnings("serial")
 	public void testCustomTranslateMethodTranslation() {
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLErrorCodesFactoryTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLErrorCodesFactoryTests.java
index e118d922ff8a..944b77c5dc02 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLErrorCodesFactoryTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLErrorCodesFactoryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,16 +16,6 @@
 
 package org.springframework.jdbc.support;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
@@ -37,6 +27,10 @@
 import org.springframework.core.io.ClassPathResource;
 import org.springframework.core.io.Resource;
 
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Tests for SQLErrorCodes loading.
  *
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLStateExceptionTranslatorTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLStateExceptionTranslatorTests.java
index 3578c1e93b97..0aad57f96dc2 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLStateExceptionTranslatorTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/support/SQLStateExceptionTranslatorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -67,7 +67,6 @@ public void testInvalidSqlStateCode() {
 	 * Bug 729170
 	 */
 	public void testMalformedSqlStateCodes() {
-		String sql = "SELECT FOO FROM BAR";
 		SQLException sex = new SQLException("Message", null, 1);
 		testMalformedSqlStateCode(sex);
 
diff --git a/spring-jdbc/src/test/java/org/springframework/jdbc/support/rowset/ResultSetWrappingRowSetTests.java b/spring-jdbc/src/test/java/org/springframework/jdbc/support/rowset/ResultSetWrappingRowSetTests.java
index 0594fec1cb4a..27e1d96fb773 100644
--- a/spring-jdbc/src/test/java/org/springframework/jdbc/support/rowset/ResultSetWrappingRowSetTests.java
+++ b/spring-jdbc/src/test/java/org/springframework/jdbc/support/rowset/ResultSetWrappingRowSetTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,6 @@
 
 package org.springframework.jdbc.support.rowset;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.math.BigDecimal;
@@ -34,6 +29,9 @@
 import org.junit.Test;
 import org.springframework.jdbc.InvalidResultSetAccessException;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Thomas Risberg
  */
diff --git a/spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java b/spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java
index 91b15c319df2..de0132dae168 100644
--- a/spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java
+++ b/spring-jms/src/main/java/org/springframework/jms/listener/DefaultMessageListenerContainer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -183,6 +183,8 @@ public class DefaultMessageListenerContainer extends AbstractPollingMessageListe
 
 	private int registeredWithDestination = 0;
 
+	private volatile boolean recovering = false;
+
 	private Runnable stopCallback;
 
 	private Object currentRecoveryMarker = new Object();
@@ -758,6 +760,9 @@ protected void establishSharedConnection() {
 			super.establishSharedConnection();
 		}
 		catch (Exception ex) {
+			if (ex instanceof JMSException) {
+				invokeExceptionListener((JMSException) ex);
+			}
 			logger.debug("Could not establish shared JMS Connection - " +
 					"leaving it up to asynchronous invokers to establish a Connection as soon as possible", ex);
 		}
@@ -796,7 +801,7 @@ protected void stopSharedConnection() {
 	/**
 	 * Handle the given exception that arose during setup of a listener.
 	 * Called for every such exception in every concurrent listener.
-	 * <p>The default implementation logs the exception at info level
+	 * <p>The default implementation logs the exception at warn level
 	 * if not recovered yet, and at debug level if already recovered.
 	 * Can be overridden in subclasses.
 	 * @param ex the exception to handle
@@ -837,7 +842,7 @@ protected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered
 
 	/**
 	 * Recover this listener container after a listener failed to set itself up,
-	 * for example reestablishing the underlying Connection.
+	 * for example re-establishing the underlying Connection.
 	 * <p>The default implementation delegates to DefaultMessageListenerContainer's
 	 * recovery-capable {@link #refreshConnectionUntilSuccessful()} method, which will
 	 * try to re-establish a Connection to the JMS provider both for the shared
@@ -846,8 +851,14 @@ protected void handleListenerSetupFailure(Throwable ex, boolean alreadyRecovered
 	 * @see #refreshDestination()
 	 */
 	protected void recoverAfterListenerSetupFailure() {
-		refreshConnectionUntilSuccessful();
-		refreshDestination();
+		this.recovering = true;
+		try {
+			refreshConnectionUntilSuccessful();
+			refreshDestination();
+		}
+		finally {
+			this.recovering = false;
+		}
 	}
 
 	/**
@@ -856,9 +867,11 @@ protected void recoverAfterListenerSetupFailure() {
 	 * Connection, so either needs to operate on the shared Connection or on a
 	 * temporary Connection that just gets established for validation purposes.
 	 * <p>The default implementation retries until it successfully established a
-	 * Connection, for as long as this message listener container is active.
+	 * Connection, for as long as this message listener container is running.
 	 * Applies the specified recovery interval between retries.
 	 * @see #setRecoveryInterval
+	 * @see #start()
+	 * @see #stop()
 	 */
 	protected void refreshConnectionUntilSuccessful() {
 		while (isRunning()) {
@@ -874,16 +887,19 @@ protected void refreshConnectionUntilSuccessful() {
 				break;
 			}
 			catch (Exception ex) {
+				if (ex instanceof JMSException) {
+					invokeExceptionListener((JMSException) ex);
+				}
 				StringBuilder msg = new StringBuilder();
 				msg.append("Could not refresh JMS Connection for destination '");
 				msg.append(getDestinationDescription()).append("' - retrying in ");
 				msg.append(this.recoveryInterval).append(" ms. Cause: ");
 				msg.append(ex instanceof JMSException ? JmsUtils.buildExceptionMessage((JMSException) ex) : ex.getMessage());
 				if (logger.isDebugEnabled()) {
-					logger.warn(msg, ex);
+					logger.error(msg, ex);
 				}
 				else {
-					logger.warn(msg);
+					logger.error(msg);
 				}
 			}
 			sleepInbetweenRecoveryAttempts();
@@ -925,6 +941,17 @@ protected void sleepInbetweenRecoveryAttempts() {
 		}
 	}
 
+	/**
+	 * Return whether this listener container is currently in a recovery attempt.
+	 * <p>May be used to detect recovery phases but also the end of a recovery phase,
+	 * with {@code isRecovering()} switching to {@code false} after having been found
+	 * to return {@code true} before.
+	 * @see #recoverAfterListenerSetupFailure()
+	 */
+	public final boolean isRecovering() {
+		return this.recovering;
+	}
+
 
 	//-------------------------------------------------------------------------
 	// Inner classes used as internal adapters
diff --git a/spring-jms/src/main/java/org/springframework/jms/listener/endpoint/JmsMessageEndpointFactory.java b/spring-jms/src/main/java/org/springframework/jms/listener/endpoint/JmsMessageEndpointFactory.java
index 392d02b1fa70..954dd4982ee9 100644
--- a/spring-jms/src/main/java/org/springframework/jms/listener/endpoint/JmsMessageEndpointFactory.java
+++ b/spring-jms/src/main/java/org/springframework/jms/listener/endpoint/JmsMessageEndpointFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -109,11 +109,11 @@ protected ClassLoader getEndpointClassLoader() {
 
 
 	/**
-	 * Internal exception thrown when a ResourceExeption has been encountered
+	 * Internal exception thrown when a ResourceException has been encountered
 	 * during the endpoint invocation.
 	 * <p>Will only be used if the ResourceAdapter does not invoke the
 	 * endpoint's {@code beforeDelivery} and {@code afterDelivery}
-	 * directly, leavng it up to the concrete endpoint to apply those -
+	 * directly, leaving it up to the concrete endpoint to apply those -
 	 * and to handle any ResourceExceptions thrown from them.
 	 */
 	@SuppressWarnings("serial")
diff --git a/spring-jms/src/test/java/org/springframework/jms/config/JmsNamespaceHandlerTests.java b/spring-jms/src/test/java/org/springframework/jms/config/JmsNamespaceHandlerTests.java
index 49cf841b4ea9..fd7dbf89390b 100644
--- a/spring-jms/src/test/java/org/springframework/jms/config/JmsNamespaceHandlerTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/config/JmsNamespaceHandlerTests.java
@@ -20,16 +20,16 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
+
 import javax.jms.ConnectionFactory;
 import javax.jms.Message;
 import javax.jms.MessageListener;
 import javax.jms.TextMessage;
 
-import junit.framework.TestCase;
-import org.easymock.MockControl;
-
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 import org.springframework.beans.DirectFieldAccessor;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.beans.factory.config.BeanDefinition;
 import org.springframework.beans.factory.parsing.ComponentDefinition;
 import org.springframework.beans.factory.parsing.CompositeComponentDefinition;
@@ -42,14 +42,18 @@
 import org.springframework.jca.endpoint.GenericMessageEndpointManager;
 import org.springframework.jms.listener.DefaultMessageListenerContainer;
 import org.springframework.jms.listener.endpoint.JmsMessageEndpointManager;
+import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.util.ErrorHandler;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Mark Fisher
  * @author Juergen Hoeller
  * @author Christian Dupuis
  */
-public class JmsNamespaceHandlerTests extends TestCase {
+public class JmsNamespaceHandlerTests {
 
 	private static final String DEFAULT_CONNECTION_FACTORY = "connectionFactory";
 
@@ -58,17 +62,18 @@ public class JmsNamespaceHandlerTests extends TestCase {
 	private ToolingTestApplicationContext context;
 
 
-	@Override
-	protected void setUp() throws Exception {
+	@Before
+	public void setUp() throws Exception {
 		this.context = new ToolingTestApplicationContext("jmsNamespaceHandlerTests.xml", getClass());
 	}
 
-	@Override
-	protected void tearDown() throws Exception {
+	@After
+	public void tearDown() throws Exception {
 		this.context.close();
 	}
 
 
+	@Test
 	public void testBeansCreated() {
 		Map containers = context.getBeansOfType(DefaultMessageListenerContainer.class);
 		assertEquals("Context should contain 3 JMS listener containers", 3, containers.size());
@@ -77,6 +82,7 @@ public void testBeansCreated() {
 		assertEquals("Context should contain 3 JCA endpoint containers", 3, containers.size());
 	}
 
+	@Test
 	public void testContainerConfiguration() throws Exception {
 		Map<String, DefaultMessageListenerContainer> containers = context.getBeansOfType(DefaultMessageListenerContainer.class);
 		ConnectionFactory defaultConnectionFactory = context.getBean(DEFAULT_CONNECTION_FACTORY, ConnectionFactory.class);
@@ -102,6 +108,7 @@ else if (container.getConnectionFactory().equals(explicitConnectionFactory)) {
 		assertEquals("2 containers should have the explicit connectionFactory", 2, explicitConnectionFactoryCount);
 	}
 
+	@Test
 	public void testListeners() throws Exception {
 		TestBean testBean1 = context.getBean("testBean1", TestBean.class);
 		TestBean testBean2 = context.getBean("testBean2", TestBean.class);
@@ -111,36 +118,28 @@ public void testListeners() throws Exception {
 		assertNull(testBean2.getName());
 		assertNull(testBean3.message);
 
-		MockControl control1 = MockControl.createControl(TextMessage.class);
-		TextMessage message1 = (TextMessage) control1.getMock();
-		control1.expectAndReturn(message1.getText(), "Test1");
-		control1.replay();
+		TextMessage message1 = mock(TextMessage.class);
+		given(message1.getText()).willReturn("Test1");
 
 		MessageListener listener1 = getListener("listener1");
 		listener1.onMessage(message1);
 		assertEquals("Test1", testBean1.getName());
-		control1.verify();
 
-		MockControl control2 = MockControl.createControl(TextMessage.class);
-		TextMessage message2 = (TextMessage) control2.getMock();
-		control2.expectAndReturn(message2.getText(), "Test2");
-		control2.replay();
+		TextMessage message2 = mock(TextMessage.class);
+		given(message2.getText()).willReturn("Test2");
 
 		MessageListener listener2 = getListener("listener2");
 		listener2.onMessage(message2);
 		assertEquals("Test2", testBean2.getName());
-		control2.verify();
 
-		MockControl control3 = MockControl.createControl(TextMessage.class);
-		TextMessage message3 = (TextMessage) control3.getMock();
-		control3.replay();
+		TextMessage message3 = mock(TextMessage.class);
 
 		MessageListener listener3 = getListener(DefaultMessageListenerContainer.class.getName() + "#0");
 		listener3.onMessage(message3);
 		assertSame(message3, testBean3.message);
-		control3.verify();
 	}
 
+	@Test
 	public void testErrorHandlers() {
 		ErrorHandler expected = this.context.getBean("testErrorHandler", ErrorHandler.class);
 		ErrorHandler errorHandler1 = getErrorHandler("listener1");
@@ -151,6 +150,7 @@ public void testErrorHandlers() {
 		assertNull(defaultErrorHandler);
 	}
 
+	@Test
 	public void testPhases() {
 		int phase1 = getPhase("listener1");
 		int phase2 = getPhase("listener2");
@@ -182,6 +182,7 @@ public int getPhase(String containerBeanName) {
 		return ((Phased) container).getPhase();
 	}
 
+	@Test
 	public void testComponentRegistration() {
 		assertTrue("Parser should have registered a component named 'listener1'", context.containsComponentDefinition("listener1"));
 		assertTrue("Parser should have registered a component named 'listener2'", context.containsComponentDefinition("listener2"));
@@ -192,6 +193,7 @@ public void testComponentRegistration() {
 			context.containsComponentDefinition(JmsMessageEndpointManager.class.getName() + "#0"));
 	}
 
+	@Test
 	public void testSourceExtraction() {
 		Iterator iterator = context.getRegisteredComponents();
 		while (iterator.hasNext()) {
diff --git a/spring-jms/src/test/java/org/springframework/jms/connection/JmsTransactionManagerTests.java b/spring-jms/src/test/java/org/springframework/jms/connection/JmsTransactionManagerTests.java
index 78c0de6e9fda..77353d24dab2 100644
--- a/spring-jms/src/test/java/org/springframework/jms/connection/JmsTransactionManagerTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/connection/JmsTransactionManagerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,9 +30,8 @@
 import javax.jms.TopicConnectionFactory;
 import javax.jms.TopicSession;
 
-import junit.framework.TestCase;
-import org.easymock.MockControl;
-
+import org.junit.After;
+import org.junit.Test;
 import org.springframework.jms.StubQueue;
 import org.springframework.jms.core.JmsTemplate;
 import org.springframework.jms.core.JmsTemplate102;
@@ -46,34 +45,30 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 26.07.2004
  */
-public class JmsTransactionManagerTests extends TestCase {
+public class JmsTransactionManagerTests {
+
+	@After
+	public void verifyTransactionSynchronizationManager() {
+		assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty());
+		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
+	}
 
+
+	@Test
 	public void testTransactionCommit() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		final Session session = (Session) sessionControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		session.commit();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+		final Session session = mock(Session.class);
+
+		given(cf.createConnection()).willReturn(con);
+		given(con.createSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session);
 
 		JmsTransactionManager tm = new JmsTransactionManager(cf);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -87,33 +82,19 @@ public Object doInJms(Session sess) {
 		});
 		tm.commit(ts);
 
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(session).commit();
+		verify(session).close();
+		verify(con).close();
 	}
 
+	@Test
 	public void testTransactionRollback() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		final Session session = (Session) sessionControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		session.rollback();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+		final Session session = mock(Session.class);
+
+		given(cf.createConnection()).willReturn(con);
+		given(con.createSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session);
 
 		JmsTransactionManager tm = new JmsTransactionManager(cf);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -127,33 +108,19 @@ public Object doInJms(Session sess) {
 		});
 		tm.rollback(ts);
 
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(session).rollback();
+		verify(session).close();
+		verify(con).close();
 	}
 
+	@Test
 	public void testParticipatingTransactionWithCommit() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		final ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		final Session session = (Session) sessionControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		session.commit();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+		final Session session = mock(Session.class);
+
+		given(cf.createConnection()).willReturn(con);
+		given(con.createSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session);
 
 		JmsTransactionManager tm = new JmsTransactionManager(cf);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -180,33 +147,19 @@ public Object doInJms(Session sess) {
 		});
 		tm.commit(ts);
 
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(session).commit();
+		verify(session).close();
+		verify(con).close();
 	}
 
+	@Test
 	public void testParticipatingTransactionWithRollbackOnly() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		final ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		final Session session = (Session) sessionControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		session.rollback();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+		final Session session = mock(Session.class);
+
+		given(cf.createConnection()).willReturn(con);
+		given(con.createSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session);
 
 		JmsTransactionManager tm = new JmsTransactionManager(cf);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -240,39 +193,21 @@ public Object doInJms(Session sess) {
 			// expected
 		}
 
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(session).rollback();
+		verify(session).close();
+		verify(con).close();
 	}
 
+	@Test
 	public void testSuspendedTransaction() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		final ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		final Session session = (Session) sessionControl.getMock();
-		MockControl session2Control = MockControl.createControl(Session.class);
-		final Session session2 = (Session) session2Control.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 2);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		con.createSession(false, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session2, 1);
-		session.commit();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		session2.close();
-		session2Control.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(2);
-
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		final ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+		final Session session = mock(Session.class);
+		final Session session2 = mock(Session.class);
+
+		given(cf.createConnection()).willReturn(con);
+		given(con.createSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session);
+		given(con.createSession(false, Session.AUTO_ACKNOWLEDGE)).willReturn(session2);
 
 		JmsTransactionManager tm = new JmsTransactionManager(cf);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -307,41 +242,21 @@ public Object doInJms(Session sess) {
 		});
 		tm.commit(ts);
 
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(session).commit();
+		verify(session).close();
+		verify(session2).close();
+		verify(con, times(2)).close();
 	}
 
+	@Test
 	public void testTransactionSuspension() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		final ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		final Session session = (Session) sessionControl.getMock();
-		MockControl session2Control = MockControl.createControl(Session.class);
-		final Session session2 = (Session) session2Control.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 2);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session2, 1);
-		session.commit();
-		sessionControl.setVoidCallable(1);
-		session2.commit();
-		session2Control.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		session2.close();
-		session2Control.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(2);
-
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		final ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+		final Session session = mock(Session.class);
+		final Session session2 = mock(Session.class);
+
+		given(cf.createConnection()).willReturn(con);
+		given(con.createSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session, session2);
 
 		JmsTransactionManager tm = new JmsTransactionManager(cf);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -376,48 +291,27 @@ public Object doInJms(Session sess) {
 		});
 		tm.commit(ts);
 
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(session).commit();
+		verify(session2).commit();
+		verify(session).close();
+		verify(session2).close();
+		verify(con, times(2)).close();
 	}
 
+	@Test
 	public void testTransactionCommitWithMessageProducer() throws JMSException {
 		Destination dest = new StubQueue();
 
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		Session session = (Session) sessionControl.getMock();
-		MockControl producerControl = MockControl.createControl(MessageProducer.class);
-		MessageProducer producer = (MessageProducer) producerControl.getMock();
-		MockControl messageControl = MockControl.createControl(Message.class);
-		final Message message = (Message) messageControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		session.createProducer(dest);
-		sessionControl.setReturnValue(producer, 1);
-		producer.send(message);
-		producerControl.setVoidCallable(1);
-		session.getTransacted();
-		sessionControl.setReturnValue(true, 1);
-		session.commit();
-		sessionControl.setVoidCallable(1);
-		producer.close();
-		producerControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		producerControl.replay();
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+		Session session = mock(Session.class);
+		MessageProducer producer = mock(MessageProducer.class);
+		final Message message = mock(Message.class);
+
+		given(cf.createConnection()).willReturn(con);
+		given(con.createSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session);
+		given(session.createProducer(dest)).willReturn(producer);
+		given(session.getTransacted()).willReturn(true);
 
 		JmsTransactionManager tm = new JmsTransactionManager(cf);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -430,34 +324,22 @@ public Message createMessage(Session session) throws JMSException {
 		});
 		tm.commit(ts);
 
-		producerControl.verify();
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(producer).send(message);
+		verify(session).commit();
+		verify(producer).close();
+		verify(session).close();
+		verify(con).close();
 	}
 
+	@Test
+	@Deprecated
 	public void testTransactionCommit102WithQueue() throws JMSException {
-		MockControl cfControl = MockControl.createControl(QueueConnectionFactory.class);
-		QueueConnectionFactory cf = (QueueConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(QueueConnection.class);
-		QueueConnection con = (QueueConnection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(QueueSession.class);
-		final QueueSession session = (QueueSession) sessionControl.getMock();
-
-		cf.createQueueConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createQueueSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		session.commit();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		QueueConnectionFactory cf = mock(QueueConnectionFactory.class);
+		QueueConnection con = mock(QueueConnection.class);
+		final QueueSession session = mock(QueueSession.class);
+
+		given(cf.createQueueConnection()).willReturn(con);
+		given(con.createQueueSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session);
 
 		JmsTransactionManager tm = new JmsTransactionManager102(cf, false);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -471,33 +353,20 @@ public Object doInJms(Session sess) {
 		});
 		tm.commit(ts);
 
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(session).commit();
+		verify(session).close();
+		verify(con).close();
 	}
 
+	@Test
+	@Deprecated
 	public void testTransactionCommit102WithTopic() throws JMSException {
-		MockControl cfControl = MockControl.createControl(TopicConnectionFactory.class);
-		TopicConnectionFactory cf = (TopicConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(TopicConnection.class);
-		TopicConnection con = (TopicConnection) conControl.getMock();
-		MockControl sessionControl = MockControl.createControl(TopicSession.class);
-		final TopicSession session = (TopicSession) sessionControl.getMock();
-
-		cf.createTopicConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createTopicSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(session, 1);
-		session.commit();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		sessionControl.replay();
-		conControl.replay();
-		cfControl.replay();
+		TopicConnectionFactory cf = mock(TopicConnectionFactory.class);
+		TopicConnection con = mock(TopicConnection.class);
+		final TopicSession session = mock(TopicSession.class);
+
+		given(cf.createTopicConnection()).willReturn(con);
+		given(con.createTopicSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(session);
 
 		JmsTransactionManager tm = new JmsTransactionManager102(cf, true);
 		TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition());
@@ -511,15 +380,8 @@ public Object doInJms(Session sess) {
 		});
 		tm.commit(ts);
 
-		sessionControl.verify();
-		conControl.verify();
-		cfControl.verify();
+		verify(session).commit();
+		verify(session).close();
+		verify(con).close();
 	}
-
-	@Override
-	protected void tearDown() {
-		assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty());
-		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
-	}
-
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/connection/SingleConnectionFactoryTests.java b/spring-jms/src/test/java/org/springframework/jms/connection/SingleConnectionFactoryTests.java
index 19912ccc3958..3f323ec8b151 100644
--- a/spring-jms/src/test/java/org/springframework/jms/connection/SingleConnectionFactoryTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/connection/SingleConnectionFactoryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,27 +28,20 @@
 import javax.jms.TopicConnectionFactory;
 import javax.jms.TopicSession;
 
-import junit.framework.TestCase;
-import org.easymock.MockControl;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Juergen Hoeller
  * @since 26.07.2004
  */
-public class SingleConnectionFactoryTests extends TestCase {
+public class SingleConnectionFactoryTests {
 
+	@Test
 	public void testWithConnection() throws JMSException {
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		conControl.replay();
+		Connection con = mock(Connection.class);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(con);
 		Connection con1 = scf.createConnection();
@@ -61,21 +54,15 @@ public void testWithConnection() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithQueueConnection() throws JMSException {
-		MockControl conControl = MockControl.createControl(QueueConnection.class);
-		Connection con = (QueueConnection) conControl.getMock();
-
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		conControl.replay();
+		Connection con = mock(QueueConnection.class);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(con);
 		QueueConnection con1 = scf.createQueueConnection();
@@ -88,21 +75,15 @@ public void testWithQueueConnection() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithTopicConnection() throws JMSException {
-		MockControl conControl = MockControl.createControl(TopicConnection.class);
-		Connection con = (TopicConnection) conControl.getMock();
-
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		conControl.replay();
+		Connection con = mock(TopicConnection.class);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(con);
 		TopicConnection con1 = scf.createTopicConnection();
@@ -115,26 +96,18 @@ public void testWithTopicConnection() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithConnectionFactory() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+
+		given(cf.createConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		Connection con1 = scf.createConnection();
@@ -145,27 +118,18 @@ public void testWithConnectionFactory() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithQueueConnectionFactoryAndJms11Usage() throws JMSException {
-		MockControl cfControl = MockControl.createControl(QueueConnectionFactory.class);
-		QueueConnectionFactory cf = (QueueConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(QueueConnection.class);
-		QueueConnection con = (QueueConnection) conControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		QueueConnectionFactory cf = mock(QueueConnectionFactory.class);
+		QueueConnection con = mock(QueueConnection.class);
+
+		given(cf.createConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		Connection con1 = scf.createConnection();
@@ -176,27 +140,18 @@ public void testWithQueueConnectionFactoryAndJms11Usage() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithQueueConnectionFactoryAndJms102Usage() throws JMSException {
-		MockControl cfControl = MockControl.createControl(QueueConnectionFactory.class);
-		QueueConnectionFactory cf = (QueueConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(QueueConnection.class);
-		QueueConnection con = (QueueConnection) conControl.getMock();
-
-		cf.createQueueConnection();
-		cfControl.setReturnValue(con, 1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		QueueConnectionFactory cf = mock(QueueConnectionFactory.class);
+		QueueConnection con = mock(QueueConnection.class);
+
+		given(cf.createQueueConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		Connection con1 = scf.createQueueConnection();
@@ -207,27 +162,18 @@ public void testWithQueueConnectionFactoryAndJms102Usage() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithTopicConnectionFactoryAndJms11Usage() throws JMSException {
-		MockControl cfControl = MockControl.createControl(TopicConnectionFactory.class);
-		TopicConnectionFactory cf = (TopicConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(TopicConnection.class);
-		TopicConnection con = (TopicConnection) conControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		TopicConnectionFactory cf = mock(TopicConnectionFactory.class);
+		TopicConnection con = mock(TopicConnection.class);
+
+		given(cf.createConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		Connection con1 = scf.createConnection();
@@ -238,27 +184,18 @@ public void testWithTopicConnectionFactoryAndJms11Usage() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithTopicConnectionFactoryAndJms102Usage() throws JMSException {
-		MockControl cfControl = MockControl.createControl(TopicConnectionFactory.class);
-		TopicConnectionFactory cf = (TopicConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(TopicConnection.class);
-		TopicConnection con = (TopicConnection) conControl.getMock();
-
-		cf.createTopicConnection();
-		cfControl.setReturnValue(con, 1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		TopicConnectionFactory cf = mock(TopicConnectionFactory.class);
+		TopicConnection con = mock(TopicConnection.class);
+
+		given(cf.createTopicConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		Connection con1 = scf.createTopicConnection();
@@ -269,29 +206,18 @@ public void testWithTopicConnectionFactoryAndJms102Usage() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithConnectionFactoryAndClientId() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.setClientID("myId");
-		conControl.setVoidCallable(1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+
+		given(cf.createConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		scf.setClientId("myId");
@@ -303,32 +229,21 @@ public void testWithConnectionFactoryAndClientId() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).setClientID("myId");
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testWithConnectionFactoryAndExceptionListener() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
 
 		ExceptionListener listener = new ChainedExceptionListener();
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.setExceptionListener(listener);
-		conControl.setVoidCallable(1);
-		con.getExceptionListener();
-		conControl.setReturnValue(listener, 1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		given(cf.createConnection()).willReturn(con);
+		given(con.getExceptionListener()).willReturn(listener);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		scf.setExceptionListener(listener);
@@ -343,18 +258,18 @@ public void testWithConnectionFactoryAndExceptionListener() throws JMSException
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).setExceptionListener(listener);
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
 	}
 
+	@Test
 	public void testWithConnectionFactoryAndReconnectOnException() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
 		TestConnection con = new TestConnection();
 
-		cf.createConnection();
-		cfControl.setReturnValue(con, 2);
-		cfControl.replay();
+		given(cf.createConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		scf.setReconnectOnException(true);
@@ -366,21 +281,18 @@ public void testWithConnectionFactoryAndReconnectOnException() throws JMSExcepti
 		con2.start();
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
 		assertEquals(2, con.getStartCount());
 		assertEquals(2, con.getCloseCount());
 	}
 
+	@Test
 	public void testWithConnectionFactoryAndExceptionListenerAndReconnectOnException() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
 		TestConnection con = new TestConnection();
 
-		TestExceptionListener listener = new TestExceptionListener();
-		cf.createConnection();
-		cfControl.setReturnValue(con, 2);
-		cfControl.replay();
+		given(cf.createConnection()).willReturn(con);
 
+		TestExceptionListener listener = new TestExceptionListener();
 		SingleConnectionFactory scf = new SingleConnectionFactory(cf);
 		scf.setExceptionListener(listener);
 		scf.setReconnectOnException(true);
@@ -392,29 +304,17 @@ public void testWithConnectionFactoryAndExceptionListenerAndReconnectOnException
 		con2.start();
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
 		assertEquals(2, con.getStartCount());
 		assertEquals(2, con.getCloseCount());
 		assertEquals(1, listener.getCount());
 	}
 
+	@Test
 	public void testConnectionFactory102WithQueue() throws JMSException {
-		MockControl cfControl = MockControl.createControl(QueueConnectionFactory.class);
-		QueueConnectionFactory cf = (QueueConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(QueueConnection.class);
-		QueueConnection con = (QueueConnection) conControl.getMock();
-
-		cf.createQueueConnection();
-		cfControl.setReturnValue(con, 1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		QueueConnectionFactory cf = mock(QueueConnectionFactory.class);
+		QueueConnection con = mock(QueueConnection.class);
+
+		given(cf.createQueueConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory102(cf, false);
 		QueueConnection con1 = scf.createQueueConnection();
@@ -425,27 +325,18 @@ public void testConnectionFactory102WithQueue() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testConnectionFactory102WithTopic() throws JMSException {
-		MockControl cfControl = MockControl.createControl(TopicConnectionFactory.class);
-		TopicConnectionFactory cf = (TopicConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(TopicConnection.class);
-		TopicConnection con = (TopicConnection) conControl.getMock();
-
-		cf.createTopicConnection();
-		cfControl.setReturnValue(con, 1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
+		TopicConnectionFactory cf = mock(TopicConnectionFactory.class);
+		TopicConnection con = mock(TopicConnection.class);
+
+		given(cf.createTopicConnection()).willReturn(con);
 
 		SingleConnectionFactory scf = new SingleConnectionFactory102(cf, true);
 		TopicConnection con1 = scf.createTopicConnection();
@@ -456,45 +347,23 @@ public void testConnectionFactory102WithTopic() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
+		verifyNoMoreInteractions(con);
 	}
 
+	@Test
 	public void testCachingConnectionFactory() throws JMSException {
-		MockControl cfControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory cf = (ConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl txSessionControl = MockControl.createControl(Session.class);
-		Session txSession = (Session) txSessionControl.getMock();
-		MockControl nonTxSessionControl = MockControl.createControl(Session.class);
-		Session nonTxSession = (Session) nonTxSessionControl.getMock();
-
-		cf.createConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(txSession, 1);
-		txSession.getTransacted();
-		txSessionControl.setReturnValue(true, 1);
-		txSession.commit();
-		txSessionControl.setVoidCallable(1);
-		txSession.close();
-		txSessionControl.setVoidCallable(1);
-		con.createSession(false, Session.CLIENT_ACKNOWLEDGE);
-		conControl.setReturnValue(nonTxSession, 1);
-		nonTxSession.close();
-		nonTxSessionControl.setVoidCallable(1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
-		txSessionControl.replay();
-		nonTxSessionControl.replay();
+		ConnectionFactory cf = mock(ConnectionFactory.class);
+		Connection con = mock(Connection.class);
+		Session txSession = mock(Session.class);
+		Session nonTxSession = mock(Session.class);
+
+		given(cf.createConnection()).willReturn(con);
+		given(con.createSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(txSession);
+		given(txSession.getTransacted()).willReturn(true);
+		given(con.createSession(false, Session.CLIENT_ACKNOWLEDGE)).willReturn(nonTxSession);
 
 		CachingConnectionFactory scf = new CachingConnectionFactory(cf);
 		scf.setReconnectOnException(false);
@@ -516,47 +385,25 @@ public void testCachingConnectionFactory() throws JMSException {
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
-		txSessionControl.verify();
-		nonTxSessionControl.verify();
+		verify(txSession).commit();
+		verify(txSession).close();
+		verify(nonTxSession).close();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
 	}
 
+	@Test
 	public void testCachingConnectionFactoryWithQueueConnectionFactoryAndJms102Usage() throws JMSException {
-		MockControl cfControl = MockControl.createControl(QueueConnectionFactory.class);
-		QueueConnectionFactory cf = (QueueConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(QueueConnection.class);
-		QueueConnection con = (QueueConnection) conControl.getMock();
-		MockControl txSessionControl = MockControl.createControl(QueueSession.class);
-		QueueSession txSession = (QueueSession) txSessionControl.getMock();
-		MockControl nonTxSessionControl = MockControl.createControl(QueueSession.class);
-		QueueSession nonTxSession = (QueueSession) nonTxSessionControl.getMock();
-
-		cf.createQueueConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createQueueSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(txSession, 1);
-		txSession.getTransacted();
-		txSessionControl.setReturnValue(true, 1);
-		txSession.rollback();
-		txSessionControl.setVoidCallable(1);
-		txSession.close();
-		txSessionControl.setVoidCallable(1);
-		con.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);
-		conControl.setReturnValue(nonTxSession, 1);
-		nonTxSession.close();
-		nonTxSessionControl.setVoidCallable(1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
-		txSessionControl.replay();
-		nonTxSessionControl.replay();
+		QueueConnectionFactory cf = mock(QueueConnectionFactory.class);
+		QueueConnection con = mock(QueueConnection.class);
+		QueueSession txSession = mock(QueueSession.class);
+		QueueSession nonTxSession = mock(QueueSession.class);
+
+		given(cf.createQueueConnection()).willReturn(con);
+		given(con.createQueueSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(txSession);
+		given(txSession.getTransacted()).willReturn(true);
+		given(con.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE)).willReturn(nonTxSession);
 
 		CachingConnectionFactory scf = new CachingConnectionFactory(cf);
 		scf.setReconnectOnException(false);
@@ -578,45 +425,25 @@ public void testCachingConnectionFactoryWithQueueConnectionFactoryAndJms102Usage
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
-		txSessionControl.verify();
-		nonTxSessionControl.verify();
+		verify(txSession).rollback();
+		verify(txSession).close();
+		verify(nonTxSession).close();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
 	}
 
+	@Test
 	public void testCachingConnectionFactoryWithTopicConnectionFactoryAndJms102Usage() throws JMSException {
-		MockControl cfControl = MockControl.createControl(TopicConnectionFactory.class);
-		TopicConnectionFactory cf = (TopicConnectionFactory) cfControl.getMock();
-		MockControl conControl = MockControl.createControl(TopicConnection.class);
-		TopicConnection con = (TopicConnection) conControl.getMock();
-		MockControl txSessionControl = MockControl.createControl(TopicSession.class);
-		TopicSession txSession = (TopicSession) txSessionControl.getMock();
-		MockControl nonTxSessionControl = MockControl.createControl(TopicSession.class);
-		TopicSession nonTxSession = (TopicSession) nonTxSessionControl.getMock();
-
-		cf.createTopicConnection();
-		cfControl.setReturnValue(con, 1);
-		con.createTopicSession(true, Session.AUTO_ACKNOWLEDGE);
-		conControl.setReturnValue(txSession, 1);
-		txSession.getTransacted();
-		txSessionControl.setReturnValue(true, 2);
-		txSession.close();
-		txSessionControl.setVoidCallable(1);
-		con.createTopicSession(false, Session.CLIENT_ACKNOWLEDGE);
-		conControl.setReturnValue(nonTxSession, 1);
-		nonTxSession.close();
-		nonTxSessionControl.setVoidCallable(1);
-		con.start();
-		conControl.setVoidCallable(1);
-		con.stop();
-		conControl.setVoidCallable(1);
-		con.close();
-		conControl.setVoidCallable(1);
-
-		cfControl.replay();
-		conControl.replay();
-		txSessionControl.replay();
-		nonTxSessionControl.replay();
+		TopicConnectionFactory cf = mock(TopicConnectionFactory.class);
+		TopicConnection con = mock(TopicConnection.class);
+		TopicSession txSession = mock(TopicSession.class);
+		TopicSession nonTxSession = mock(TopicSession.class);
+
+		given(cf.createTopicConnection()).willReturn(con);
+		given(con.createTopicSession(true, Session.AUTO_ACKNOWLEDGE)).willReturn(txSession);
+		given(txSession.getTransacted()).willReturn(true);
+		given(con.createTopicSession(false, Session.CLIENT_ACKNOWLEDGE)).willReturn(nonTxSession);
 
 		CachingConnectionFactory scf = new CachingConnectionFactory(cf);
 		scf.setReconnectOnException(false);
@@ -638,10 +465,11 @@ public void testCachingConnectionFactoryWithTopicConnectionFactoryAndJms102Usage
 		con2.close();  // should be ignored
 		scf.destroy();  // should trigger actual close
 
-		cfControl.verify();
-		conControl.verify();
-		txSessionControl.verify();
-		nonTxSessionControl.verify();
+		verify(txSession).close();
+		verify(nonTxSession).close();
+		verify(con).start();
+		verify(con).stop();
+		verify(con).close();
 	}
 
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/core/JmsTemplate102Tests.java b/spring-jms/src/test/java/org/springframework/jms/core/JmsTemplate102Tests.java
index abcb7a7e663b..6b9e83581ed0 100644
--- a/spring-jms/src/test/java/org/springframework/jms/core/JmsTemplate102Tests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/core/JmsTemplate102Tests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -39,9 +39,8 @@
 import javax.naming.Context;
 import javax.naming.NamingException;
 
-import junit.framework.TestCase;
-import org.easymock.MockControl;
-
+import org.junit.Before;
+import org.junit.Test;
 import org.springframework.jms.InvalidClientIDException;
 import org.springframework.jms.InvalidDestinationException;
 import org.springframework.jms.InvalidSelectorException;
@@ -59,111 +58,63 @@
 import org.springframework.jms.support.destination.JndiDestinationResolver;
 import org.springframework.jndi.JndiTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for the JmsTemplate implemented using JMS 1.0.2.
  *
  * @author Andre Biryukov
  * @author Mark Pollack
  */
-public class JmsTemplate102Tests extends TestCase {
-
-	private Context mockJndiContext;
-	private MockControl mockJndiControl;
-
-	private MockControl queueConnectionFactoryControl;
-	private QueueConnectionFactory mockQueueConnectionFactory;
-
-	private MockControl queueConnectionControl;
-	private QueueConnection mockQueueConnection;
-
-	private MockControl queueSessionControl;
-	private QueueSession mockQueueSession;
-
-	private MockControl queueControl;
-	private Queue mockQueue;
-
-	private MockControl topicConnectionFactoryControl;
-	private TopicConnectionFactory mockTopicConnectionFactory;
-
-	private MockControl topicConnectionControl;
-	private TopicConnection mockTopicConnection;
-
-	private MockControl topicSessionControl;
-	private TopicSession mockTopicSession;
-
-	private MockControl topicControl;
-	private Topic mockTopic;
+public class JmsTemplate102Tests {
+
+	private Context jndiContext;
+	private QueueConnectionFactory queueConnectionFactory;
+	private QueueConnection queueConnection;
+	private QueueSession queueSession;
+	private Queue queue;
+	private TopicConnectionFactory topicConnectionFactory;
+	private TopicConnection topicConnection;
+	private TopicSession topicSession;
+	private Topic topic;
 
 	private int deliveryMode = DeliveryMode.PERSISTENT;
 	private int priority = 9;
 	private int timeToLive = 10000;
 
 
-	/**
-	 * Create the mock objects for testing.
-	 */
-	@Override
-	protected void setUp() throws Exception {
-		mockJndiControl = MockControl.createControl(Context.class);
-		mockJndiContext = (Context) this.mockJndiControl.getMock();
-
+	@Before
+	public void setUpMocks() throws Exception {
+		jndiContext = mock(Context.class);
 		createMockForQueues();
 		createMockForTopics();
-
-		mockJndiContext.close();
-		mockJndiControl.replay();
 	}
 
 	private void createMockForTopics() throws JMSException, NamingException {
-		topicConnectionFactoryControl = MockControl.createControl(TopicConnectionFactory.class);
-		mockTopicConnectionFactory = (TopicConnectionFactory) topicConnectionFactoryControl.getMock();
-
-		topicConnectionControl = MockControl.createControl(TopicConnection.class);
-		mockTopicConnection = (TopicConnection) topicConnectionControl.getMock();
-
-		topicControl = MockControl.createControl(Topic.class);
-		mockTopic = (Topic) topicControl.getMock();
+		topicConnectionFactory = mock(TopicConnectionFactory.class);
+		topicConnection = mock(TopicConnection.class);
+		topic = mock(Topic.class);
+		topicSession = mock(TopicSession.class);
 
-		topicSessionControl = MockControl.createControl(TopicSession.class);
-		mockTopicSession = (TopicSession) topicSessionControl.getMock();
-
-		mockTopicConnectionFactory.createTopicConnection();
-		topicConnectionFactoryControl.setReturnValue(mockTopicConnection);
-		topicConnectionFactoryControl.replay();
-
-		mockTopicConnection.createTopicSession(useTransactedTemplate(), Session.AUTO_ACKNOWLEDGE);
-		topicConnectionControl.setReturnValue(mockTopicSession);
-		mockTopicSession.getTransacted();
-		topicSessionControl.setReturnValue(useTransactedSession());
-
-		mockJndiContext.lookup("testTopic");
-		mockJndiControl.setReturnValue(mockTopic);
+		given(topicConnectionFactory.createTopicConnection()).willReturn(topicConnection);
+		given(topicConnection.createTopicSession(useTransactedTemplate(),
+				Session.AUTO_ACKNOWLEDGE)).willReturn(topicSession);
+		given(topicSession.getTransacted()).willReturn(useTransactedSession());
+		given(jndiContext.lookup("testTopic")).willReturn(topic);
 	}
 
 	private void createMockForQueues() throws JMSException, NamingException {
-		queueConnectionFactoryControl = MockControl.createControl(QueueConnectionFactory.class);
-		mockQueueConnectionFactory = (QueueConnectionFactory) queueConnectionFactoryControl.getMock();
-
-		queueConnectionControl = MockControl.createControl(QueueConnection.class);
-		mockQueueConnection = (QueueConnection) queueConnectionControl.getMock();
-
-		queueControl = MockControl.createControl(Queue.class);
-		mockQueue = (Queue) queueControl.getMock();
-
-		queueSessionControl = MockControl.createControl(QueueSession.class);
-		mockQueueSession = (QueueSession) queueSessionControl.getMock();
-
-		mockQueueConnectionFactory.createQueueConnection();
-		queueConnectionFactoryControl.setReturnValue(mockQueueConnection);
-		queueConnectionFactoryControl.replay();
-
-		mockQueueConnection.createQueueSession(useTransactedTemplate(), Session.AUTO_ACKNOWLEDGE);
-		queueConnectionControl.setReturnValue(mockQueueSession);
-		mockQueueSession.getTransacted();
-		queueSessionControl.setReturnValue(useTransactedSession());
+		queueConnectionFactory = mock(QueueConnectionFactory.class);
+		queueConnection = mock(QueueConnection.class);
+		queue = mock(Queue.class);
+		queueSession = mock(QueueSession.class);
 
-		mockJndiContext.lookup("testQueue");
-		mockJndiControl.setReturnValue(mockQueue);
+		given(queueConnectionFactory.createQueueConnection()).willReturn(queueConnection);
+		given(queueConnection.createQueueSession(useTransactedTemplate(),
+				Session.AUTO_ACKNOWLEDGE)).willReturn(queueSession);
+		given(queueSession.getTransacted()).willReturn(useTransactedSession());
+		given(jndiContext.lookup("testQueue")).willReturn(queue);
 	}
 
 	private JmsTemplate102 createTemplate() {
@@ -172,7 +123,7 @@ private JmsTemplate102 createTemplate() {
 		destMan.setJndiTemplate(new JndiTemplate() {
 			@Override
 			protected Context createInitialContext() {
-				return mockJndiContext;
+				return jndiContext;
 			}
 		});
 		template.setDestinationResolver(destMan);
@@ -189,111 +140,70 @@ protected boolean useTransactedTemplate() {
 	}
 
 
+	@Test
 	public void testTopicSessionCallback() throws Exception {
 		JmsTemplate102 template = createTemplate();
 		template.setPubSubDomain(true);
-		template.setConnectionFactory(mockTopicConnectionFactory);
+		template.setConnectionFactory(topicConnectionFactory);
 		template.afterPropertiesSet();
 
-		mockTopicSession.close();
-		topicSessionControl.setVoidCallable(1);
-
-		mockTopicConnection.close();
-		topicConnectionControl.setVoidCallable(1);
-
-		topicSessionControl.replay();
-		topicConnectionControl.replay();
-
 		template.execute(new SessionCallback() {
 			@Override
 			public Object doInJms(Session session) throws JMSException {
-				boolean b = session.getTransacted();
+				session.getTransacted();
 				return null;
 			}
 		});
 
-		topicConnectionFactoryControl.verify();
-		topicConnectionControl.verify();
-		topicSessionControl.verify();
+		verify(topicSession).close();
+		verify(topicConnection).close();
 	}
 
 	/**
 	 * Test the execute(ProducerCallback) using a topic.
 	 */
+	@Test
 	public void testTopicProducerCallback() throws Exception {
 		JmsTemplate102 template = createTemplate();
 		template.setPubSubDomain(true);
-		template.setConnectionFactory(mockTopicConnectionFactory);
+		template.setConnectionFactory(topicConnectionFactory);
 		template.afterPropertiesSet();
 
-		MockControl topicPublisherControl = MockControl.createControl(TopicPublisher.class);
-		TopicPublisher mockTopicPublisher = (TopicPublisher) topicPublisherControl.getMock();
+		TopicPublisher topicPublisher = mock(TopicPublisher.class);
 
-		mockTopicSession.createPublisher(null);
-		topicSessionControl.setReturnValue(mockTopicPublisher);
-
-		mockTopicPublisher.getPriority();
-		topicPublisherControl.setReturnValue(4);
-
-		mockTopicPublisher.close();
-		topicPublisherControl.setVoidCallable(1);
-		mockTopicSession.close();
-		topicSessionControl.setVoidCallable(1);
-		mockTopicConnection.close();
-		topicConnectionControl.setVoidCallable(1);
-
-		topicPublisherControl.replay();
-		topicSessionControl.replay();
-		topicConnectionControl.replay();
+		given(topicSession.createPublisher(null)).willReturn(topicPublisher);
+		given(topicPublisher.getPriority()).willReturn(4);
 
 		template.execute(new ProducerCallback() {
 			@Override
 			public Object doInJms(Session session, MessageProducer producer) throws JMSException {
-				boolean b = session.getTransacted();
-				int i = producer.getPriority();
+				session.getTransacted();
+				producer.getPriority();
 				return null;
 			}
 		});
 
-		topicConnectionFactoryControl.verify();
-		topicConnectionControl.verify();
-		topicSessionControl.verify();
+		verify(topicPublisher).close();
+		verify(topicSession).close();
+		verify(topicConnection).close();
 	}
 
 	/**
 	 * Test the execute(ProducerCallback) using a topic.
 	 */
+	@Test
 	public void testTopicProducerCallbackWithIdAndTimestampDisabled() throws Exception {
 		JmsTemplate102 template = createTemplate();
 		template.setPubSubDomain(true);
-		template.setConnectionFactory(mockTopicConnectionFactory);
+		template.setConnectionFactory(topicConnectionFactory);
 		template.setMessageIdEnabled(false);
 		template.setMessageTimestampEnabled(false);
 		template.afterPropertiesSet();
 
-		MockControl topicPublisherControl = MockControl.createControl(TopicPublisher.class);
-		TopicPublisher mockTopicPublisher = (TopicPublisher) topicPublisherControl.getMock();
-
-		mockTopicSession.createPublisher(null);
-		topicSessionControl.setReturnValue(mockTopicPublisher);
-
-		mockTopicPublisher.setDisableMessageID(true);
-		topicPublisherControl.setVoidCallable(1);
-		mockTopicPublisher.setDisableMessageTimestamp(true);
-		topicPublisherControl.setVoidCallable(1);
-		mockTopicPublisher.getPriority();
-		topicPublisherControl.setReturnValue(4);
+		TopicPublisher topicPublisher = mock(TopicPublisher.class);
 
-		mockTopicPublisher.close();
-		topicPublisherControl.setVoidCallable(1);
-		mockTopicSession.close();
-		topicSessionControl.setVoidCallable(1);
-		mockTopicConnection.close();
-		topicConnectionControl.setVoidCallable(1);
-
-		topicPublisherControl.replay();
-		topicSessionControl.replay();
-		topicConnectionControl.replay();
+		given(topicSession.createPublisher(null)).willReturn(topicPublisher);
+		given(topicPublisher.getPriority()).willReturn(4);
 
 		template.execute(new ProducerCallback() {
 			@Override
@@ -304,30 +214,24 @@ public Object doInJms(Session session, MessageProducer producer) throws JMSExcep
 			}
 		});
 
-		topicConnectionFactoryControl.verify();
-		topicConnectionControl.verify();
-		topicSessionControl.verify();
+		verify(topicPublisher).setDisableMessageID(true);
+		verify(topicPublisher).setDisableMessageTimestamp(true);
+		verify(topicPublisher).close();
+		verify(topicSession).close();
+		verify(topicConnection).close();
 	}
 
 	/**
 	 * Test the method execute(SessionCallback action) with using the
 	 * point to point domain as specified by the value of isPubSubDomain = false.
 	 */
+	@Test
 	public void testQueueSessionCallback() throws Exception {
 		JmsTemplate102 template = createTemplate();
 		// Point-to-Point (queues) are the default domain
-		template.setConnectionFactory(mockQueueConnectionFactory);
+		template.setConnectionFactory(queueConnectionFactory);
 		template.afterPropertiesSet();
 
-		mockQueueSession.close();
-		queueSessionControl.setVoidCallable(1);
-
-		mockQueueConnection.close();
-		queueConnectionControl.setVoidCallable(1);
-
-		queueSessionControl.replay();
-		queueConnectionControl.replay();
-
 		template.execute(new SessionCallback() {
 			@Override
 			public Object doInJms(Session session) throws JMSException {
@@ -336,39 +240,24 @@ public Object doInJms(Session session) throws JMSException {
 			}
 		});
 
-		queueConnectionFactoryControl.verify();
-		queueConnectionControl.verify();
-		queueSessionControl.verify();
+		verify(queueSession).close();
+		verify(queueConnection).close();
 	}
 
 	/**
 	 * Test the method execute(ProducerCallback) with a Queue.
 	 */
+	@Test
 	public void testQueueProducerCallback() throws Exception {
 		JmsTemplate102 template = createTemplate();
 		// Point-to-Point (queues) are the default domain.
-		template.setConnectionFactory(mockQueueConnectionFactory);
+		template.setConnectionFactory(queueConnectionFactory);
 		template.afterPropertiesSet();
 
-		MockControl queueSenderControl = MockControl.createControl(QueueSender.class);
-		QueueSender mockQueueSender = (QueueSender) queueSenderControl.getMock();
-
-		mockQueueSession.createSender(null);
-		queueSessionControl.setReturnValue(mockQueueSender);
-
-		mockQueueSender.getPriority();
-		queueSenderControl.setReturnValue(4);
+		QueueSender queueSender = mock(QueueSender.class);
 
-		mockQueueSender.close();
-		queueSenderControl.setVoidCallable(1);
-		mockQueueSession.close();
-		queueSessionControl.setVoidCallable(1);
-		mockQueueConnection.close();
-		queueConnectionControl.setVoidCallable(1);
-
-		queueSenderControl.replay();
-		queueSessionControl.replay();
-		queueConnectionControl.replay();
+		given(queueSession.createSender(null)).willReturn(queueSender);
+		given(queueSender.getPriority()).willReturn(4);
 
 		template.execute(new ProducerCallback() {
 			@Override
@@ -380,42 +269,24 @@ public Object doInJms(Session session, MessageProducer producer)
 			}
 		});
 
-		queueConnectionFactoryControl.verify();
-		queueConnectionControl.verify();
-		queueSessionControl.verify();
+		verify(queueSender).close();
+		verify(queueSession).close();
+		verify(queueConnection).close();
 	}
 
+	@Test
 	public void testQueueProducerCallbackWithIdAndTimestampDisabled() throws Exception {
 		JmsTemplate102 template = createTemplate();
 		// Point-to-Point (queues) are the default domain.
-		template.setConnectionFactory(mockQueueConnectionFactory);
+		template.setConnectionFactory(queueConnectionFactory);
 		template.setMessageIdEnabled(false);
 		template.setMessageTimestampEnabled(false);
 		template.afterPropertiesSet();
 
-		MockControl queueSenderControl = MockControl.createControl(QueueSender.class);
-		QueueSender mockQueueSender = (QueueSender) queueSenderControl.getMock();
-
-		mockQueueSession.createSender(null);
-		queueSessionControl.setReturnValue(mockQueueSender);
-
-		mockQueueSender.setDisableMessageID(true);
-		queueSenderControl.setVoidCallable(1);
-		mockQueueSender.setDisableMessageTimestamp(true);
-		queueSenderControl.setVoidCallable(1);
-		mockQueueSender.getPriority();
-		queueSenderControl.setReturnValue(4);
-
-		mockQueueSender.close();
-		queueSenderControl.setVoidCallable(1);
-		mockQueueSession.close();
-		queueSessionControl.setVoidCallable(1);
-		mockQueueConnection.close();
-		queueConnectionControl.setVoidCallable(1);
+		QueueSender queueSender = mock(QueueSender.class);
 
-		queueSenderControl.replay();
-		queueSessionControl.replay();
-		queueConnectionControl.replay();
+		given(queueSession.createSender(null)).willReturn(queueSender);
+		given(queueSender.getPriority()).willReturn(4);
 
 		template.execute(new ProducerCallback() {
 			@Override
@@ -426,19 +297,22 @@ public Object doInJms(Session session, MessageProducer producer) throws JMSExcep
 			}
 		});
 
-		queueConnectionFactoryControl.verify();
-		queueConnectionControl.verify();
-		queueSessionControl.verify();
+		verify(queueSender).setDisableMessageID(true);
+		verify(queueSender).setDisableMessageTimestamp(true);
+		verify(queueSender).close();
+		verify(queueSession).close();
+		verify(queueConnection).close();
 	}
 
 	/**
 	 * Test the setting of the JmsTemplate properties.
 	 */
+	@Test
 	public void testBeanProperties() throws Exception {
 		JmsTemplate102 template = createTemplate();
-		template.setConnectionFactory(mockQueueConnectionFactory);
+		template.setConnectionFactory(queueConnectionFactory);
 
-		assertTrue("connection factory ok", template.getConnectionFactory() == mockQueueConnectionFactory);
+		assertTrue("connection factory ok", template.getConnectionFactory() == queueConnectionFactory);
 
 		JmsTemplate102 s102 = createTemplate();
 		try {
@@ -452,7 +326,7 @@ public void testBeanProperties() throws Exception {
 		// The default is for the JmsTemplate102 to send to queues.
 		// Test to make sure exeception is thrown and has reasonable message.
 		s102 = createTemplate();
-		s102.setConnectionFactory(mockTopicConnectionFactory);
+		s102.setConnectionFactory(topicConnectionFactory);
 		try {
 			s102.afterPropertiesSet();
 			fail("IllegalArgumentException not thrown. Mismatch of Destination and ConnectionFactory types.");
@@ -462,7 +336,7 @@ public void testBeanProperties() throws Exception {
 		}
 
 		s102 = createTemplate();
-		s102.setConnectionFactory(mockQueueConnectionFactory);
+		s102.setConnectionFactory(queueConnectionFactory);
 		s102.setPubSubDomain(true);
 		try {
 			s102.afterPropertiesSet();
@@ -477,6 +351,7 @@ public void testBeanProperties() throws Exception {
 	 * Test the method send(String destination, MessgaeCreator c) using
 	 * a queue and default QOS values.
 	 */
+	@Test
 	public void testSendStringQueue() throws Exception {
 		sendQueue(true, false, false, true);
 	}
@@ -485,6 +360,7 @@ public void testSendStringQueue() throws Exception {
 	 * Test the method send(String destination, MessageCreator c) when
 	 * explicit QOS parameters are enabled, using a queue.
 	 */
+	@Test
 	public void testSendStringQueueWithQOS() throws Exception {
 		sendQueue(false, false, false, false);
 	}
@@ -492,6 +368,7 @@ public void testSendStringQueueWithQOS() throws Exception {
 	/**
 	 * Test the method send(MessageCreator c) using default QOS values.
 	 */
+	@Test
 	public void testSendDefaultDestinationQueue() throws Exception {
 		sendQueue(true, false, true, true);
 	}
@@ -499,6 +376,7 @@ public void testSendDefaultDestinationQueue() throws Exception {
 	/**
 	 * Test the method send(MessageCreator c) using explicit QOS values.
 	 */
+	@Test
 	public void testSendDefaultDestinationQueueWithQOS() throws Exception {
 		sendQueue(false, false, true, false);
 	}
@@ -507,6 +385,7 @@ public void testSendDefaultDestinationQueueWithQOS() throws Exception {
 	 * Test the method send(String destination, MessageCreator c) using
 	 * a topic and default QOS values.
 	 */
+	@Test
 	public void testSendStringTopic() throws Exception {
 		sendTopic(true, false);
 	}
@@ -515,6 +394,7 @@ public void testSendStringTopic() throws Exception {
 	 * Test the method send(String destination, MessageCreator c) using explicit
 	 * QOS values.
 	 */
+	@Test
 	public void testSendStringTopicWithQOS() throws Exception {
 		sendTopic(false, false);
 	}
@@ -523,6 +403,7 @@ public void testSendStringTopicWithQOS() throws Exception {
 	 * Test the method send(Destination queue, MessgaeCreator c) using
 	 * a queue and default QOS values.
 	 */
+	@Test
 	public void testSendQueue() throws Exception {
 		sendQueue(true, false, false, true);
 	}
@@ -531,6 +412,7 @@ public void testSendQueue() throws Exception {
 	 * Test the method send(Destination queue, MessageCreator c) sing explicit
 	 * QOS values.
 	 */
+	@Test
 	public void testSendQueueWithQOS() throws Exception {
 		sendQueue(false, false, false, false);
 	}
@@ -539,6 +421,7 @@ public void testSendQueueWithQOS() throws Exception {
 	 * Test the method send(Destination queue, MessgaeCreator c) using
 	 * a topic and default QOS values.
 	 */
+	@Test
 	public void testSendTopic() throws Exception {
 		sendTopic(true, false);
 	}
@@ -547,6 +430,7 @@ public void testSendTopic() throws Exception {
 	 * Test the method send(Destination queue, MessageCreator c) using explicity
 	 * QOS values.
 	 */
+	@Test
 	public void testSendTopicWithQOS() throws Exception {
 		sendQueue(false, false, false, true);
 	}
@@ -560,62 +444,30 @@ private void sendQueue(
 			throws Exception {
 
 		JmsTemplate102 template = createTemplate();
-		template.setConnectionFactory(mockQueueConnectionFactory);
+		template.setConnectionFactory(queueConnectionFactory);
 		template.afterPropertiesSet();
 
 		if (useDefaultDestination) {
-			template.setDefaultDestination(mockQueue);
+			template.setDefaultDestination(queue);
 		}
 		if (disableIdAndTimestamp) {
 			template.setMessageIdEnabled(false);
 			template.setMessageTimestampEnabled(false);
 		}
 
-		MockControl queueSenderControl = MockControl.createControl(QueueSender.class);
-		QueueSender mockQueueSender = (QueueSender) queueSenderControl.getMock();
+		QueueSender queueSender = mock(QueueSender.class);
+		TextMessage message = mock(TextMessage.class);
 
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
 
-		if (disableIdAndTimestamp) {
-			mockQueueSender.setDisableMessageID(true);
-			queueSenderControl.setVoidCallable(1);
-			mockQueueSender.setDisableMessageTimestamp(true);
-			queueSenderControl.setVoidCallable(1);
-		}
+		given(queueSession.createSender(this.queue)).willReturn(queueSender);
+		given(queueSession.createTextMessage("just testing")).willReturn(message);
 
-		mockQueueSession.createSender(this.mockQueue);
-		queueSessionControl.setReturnValue(mockQueueSender);
-		mockQueueSession.createTextMessage("just testing");
-		queueSessionControl.setReturnValue(mockMessage);
-
-		if (useTransactedTemplate()) {
-			mockQueueSession.commit();
-			queueSessionControl.setVoidCallable(1);
-		}
-
-		if (ignoreQOS) {
-			mockQueueSender.send(mockMessage);
-		}
-		else {
+		if (!ignoreQOS) {
 			template.setExplicitQosEnabled(true);
 			template.setDeliveryMode(deliveryMode);
 			template.setPriority(priority);
 			template.setTimeToLive(timeToLive);
-			mockQueueSender.send(mockMessage, deliveryMode, priority, timeToLive);
 		}
-		queueSenderControl.setVoidCallable(1);
-
-		mockQueueSender.close();
-		queueSenderControl.setVoidCallable(1);
-		mockQueueSession.close();
-		queueSessionControl.setVoidCallable(1);
-		mockQueueConnection.close();
-		queueConnectionControl.setVoidCallable(1);
-
-		queueSenderControl.replay();
-		queueSessionControl.replay();
-		queueConnectionControl.replay();
 
 		if (useDefaultDestination) {
 			template.send(new MessageCreator() {
@@ -627,7 +479,7 @@ public Message createMessage(Session session) throws JMSException {
 		}
 		else {
 			if (explicitQueue) {
-				template.send(mockQueue, new MessageCreator() {
+				template.send(queue, new MessageCreator() {
 					@Override
 					public Message createMessage(Session session) throws JMSException {
 						return session.createTextMessage("just testing");
@@ -645,61 +497,54 @@ public Message createMessage(Session session)
 			}
 		}
 
-		queueConnectionFactoryControl.verify();
-		queueConnectionControl.verify();
-		queueSessionControl.verify();
-		queueSenderControl.verify();
+		if (disableIdAndTimestamp) {
+			verify(queueSender).setDisableMessageID(true);
+			verify(queueSender).setDisableMessageTimestamp(true);
+		}
+
+		if (useTransactedTemplate()) {
+			verify(queueSession).commit();
+		}
+
+		if (ignoreQOS) {
+			verify(queueSender).send(message);
+		}
+		else {
+			verify(queueSender).send(message, deliveryMode, priority, timeToLive);
+		}
+
+		verify(queueSender).close();
+		verify(queueSession).close();
+		verify(queueConnection).close();
 	}
 
 	private void sendTopic(boolean ignoreQOS, boolean explicitTopic) throws Exception {
 		JmsTemplate102 template = createTemplate();
 		template.setPubSubDomain(true);
-		template.setConnectionFactory(mockTopicConnectionFactory);
+		template.setConnectionFactory(topicConnectionFactory);
 		template.afterPropertiesSet();
 
-		MockControl topicPublisherControl = MockControl.createControl(TopicPublisher.class);
-		TopicPublisher mockTopicPublisher = (TopicPublisher) topicPublisherControl.getMock();
-
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
-
-		mockTopicSession.createPublisher(this.mockTopic);
-		topicSessionControl.setReturnValue(mockTopicPublisher);
-		mockTopicSession.createTextMessage("just testing");
-		topicSessionControl.setReturnValue(mockMessage);
-
-		if (useTransactedTemplate()) {
-			mockTopicSession.commit();
-			topicSessionControl.setVoidCallable(1);
-		}
-
-		mockTopicPublisher.close();
-		topicPublisherControl.setVoidCallable(1);
-		mockTopicSession.close();
-		topicSessionControl.setVoidCallable(1);
-		mockTopicConnection.close();
-		topicConnectionControl.setVoidCallable(1);
-
+		TopicPublisher topicPublisher = mock(TopicPublisher.class);
+		TextMessage message = mock(TextMessage.class);
 
-		topicSessionControl.replay();
-		topicConnectionControl.replay();
+		given(topicSession.createPublisher(this.topic)).willReturn(topicPublisher);
+		given(topicSession.createTextMessage("just testing")).willReturn(message);
 
 		if (ignoreQOS) {
-			mockTopicPublisher.publish(mockMessage);
+			topicPublisher.publish(message);
 		}
 		else {
 			template.setExplicitQosEnabled(true);
 			template.setDeliveryMode(deliveryMode);
 			template.setPriority(priority);
 			template.setTimeToLive(timeToLive);
-			mockTopicPublisher.publish(mockMessage, deliveryMode, priority, timeToLive);
+			topicPublisher.publish(message, deliveryMode, priority, timeToLive);
 		}
-		topicPublisherControl.replay();
 
 		template.setPubSubDomain(true);
 
 		if (explicitTopic) {
-			template.send(mockTopic, new MessageCreator() {
+			template.send(topic, new MessageCreator() {
 				@Override
 				public Message createMessage(Session session)
 					throws JMSException {
@@ -717,163 +562,175 @@ public Message createMessage(Session session)
 			});
 		}
 
-		topicConnectionFactoryControl.verify();
-		topicConnectionControl.verify();
-		topicSessionControl.verify();
-		topicPublisherControl.verify();
+		if (useTransactedTemplate()) {
+			verify(topicSession).commit();
+		}
+		verify(topicPublisher).close();
+		verify(topicSession).close();
+		verify(topicConnection).close();
+		verify(jndiContext).close();
 	}
 
+	@Test
 	public void testConverter() throws Exception {
 		JmsTemplate102 template = createTemplate();
-		template.setConnectionFactory(mockQueueConnectionFactory);
+		template.setConnectionFactory(queueConnectionFactory);
 		template.setMessageConverter(new SimpleMessageConverter());
 		String s = "Hello world";
 
-		MockControl queueSenderControl = MockControl.createControl(QueueSender.class);
-		QueueSender mockQueueSender = (QueueSender) queueSenderControl.getMock();
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
+		QueueSender queueSender = mock(QueueSender.class);
+		TextMessage message = mock(TextMessage.class);
 
-		mockQueueSession.createSender(this.mockQueue);
-		queueSessionControl.setReturnValue(mockQueueSender);
-		mockQueueSession.createTextMessage("Hello world");
-		queueSessionControl.setReturnValue(mockMessage);
+		given(queueSession.createSender(this.queue)).willReturn(queueSender);
+		given(queueSession.createTextMessage("Hello world")).willReturn(message);
+
+		template.convertAndSend(queue, s);
 
 		if (useTransactedTemplate()) {
-			mockQueueSession.commit();
-			queueSessionControl.setVoidCallable(1);
+			verify(queueSession).commit();
 		}
-
-		mockQueueSender.send(mockMessage);
-		queueSenderControl.setVoidCallable(1);
-
-		mockQueueSender.close();
-		queueSenderControl.setVoidCallable(1);
-		mockQueueSession.close();
-		queueSessionControl.setVoidCallable(1);
-		mockQueueConnection.close();
-		queueConnectionControl.setVoidCallable(1);
-
-		queueSenderControl.replay();
-		queueSessionControl.replay();
-		queueConnectionControl.replay();
-
-		template.convertAndSend(mockQueue, s);
-
-		queueConnectionFactoryControl.verify();
-		queueConnectionControl.verify();
-		queueSessionControl.verify();
-		queueSenderControl.verify();
+		verify(queueSender).send(message);
+		verify(queueSender).close();
+		verify(queueSession).close();
+		verify(queueConnection).close();
 	}
 
+	@Test
 	public void testQueueReceiveDefaultDestination() throws Exception {
 		doTestReceive(false, false, true, false, false, false, false, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveDestination() throws Exception {
 		doTestReceive(false, true, false, false, false, false, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveDestinationWithClientAcknowledge() throws Exception {
 		doTestReceive(false, true, false, false, true, false, false, 1000);
 	}
 
+	@Test
 	public void testQueueReceiveStringDestination() throws Exception {
 		doTestReceive(false, false, false, false, false, false, true, JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveDefaultDestinationWithSelector() throws Exception {
 		doTestReceive(false, false, true, false, false, true, true, 1000);
 	}
 
+	@Test
 	public void testQueueReceiveDestinationWithSelector() throws Exception {
 		doTestReceive(false, true, false, false, false, true, false, JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveDestinationWithClientAcknowledgeWithSelector() throws Exception {
 		doTestReceive(false, true, false, false, true, true, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveStringDestinationWithSelector() throws Exception {
 		doTestReceive(false, false, false, false, false, true, false, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveAndConvertDefaultDestination() throws Exception {
 		doTestReceive(false, false, true, true, false, false, false, 1000);
 	}
 
+	@Test
 	public void testQueueReceiveAndConvertStringDestination() throws Exception {
 		doTestReceive(false, false, false, true, false, false, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveAndConvertDestination() throws Exception {
 		doTestReceive(false, true, false, true, false, false, true, 1000);
 	}
 
+	@Test
 	public void testQueueReceiveAndConvertDefaultDestinationWithSelector() throws Exception {
 		doTestReceive(false, false, true, true, false, true, true, JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveAndConvertStringDestinationWithSelector() throws Exception {
 		doTestReceive(false, false, false, true, false, true, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testQueueReceiveAndConvertDestinationWithSelector() throws Exception {
 		doTestReceive(false, true, false, true, false, true, false, 1000);
 	}
 
+	@Test
 	public void testTopicReceiveDefaultDestination() throws Exception {
 		doTestReceive(true, false, true, false, false, false, false, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testTopicReceiveDestination() throws Exception {
 		doTestReceive(true, true, false, false, false, false, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testTopicReceiveDestinationWithClientAcknowledge() throws Exception {
 		doTestReceive(true, true, false, false, true, false, false, 1000);
 	}
 
+	@Test
 	public void testTopicReceiveStringDestination() throws Exception {
 		doTestReceive(true, false, false, false, false, false, true, JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT);
 	}
 
+	@Test
 	public void testTopicReceiveDefaultDestinationWithSelector() throws Exception {
 		doTestReceive(true, false, true, false, false, true, true, 1000);
 	}
 
+	@Test
 	public void testTopicReceiveDestinationWithSelector() throws Exception {
 		doTestReceive(true, true, false, false, false, true, false, 1000);
 	}
 
+	@Test
 	public void testTopicReceiveDestinationWithClientAcknowledgeWithSelector() throws Exception {
 		doTestReceive(true, true, false, false, true, true, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testTopicReceiveStringDestinationWithSelector() throws Exception {
 		doTestReceive(true, false, false, false, false, true, false, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testTopicReceiveAndConvertDefaultDestination() throws Exception {
 		doTestReceive(true, false, true, true, false, false, false, 1000);
 	}
 
+	@Test
 	public void testTopicReceiveAndConvertStringDestination() throws Exception {
 		doTestReceive(true, false, false, true, false, false, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testTopicReceiveAndConvertDestination() throws Exception {
 		doTestReceive(true, true, false, true, false, false, true, 1000);
 	}
 
+	@Test
 	public void testTopicReceiveAndConvertDefaultDestinationWithSelector() throws Exception {
 		doTestReceive(true, false, true, true, false, true, true, JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT);
 	}
 
+	@Test
 	public void testTopicReceiveAndConvertStringDestinationWithSelector() throws Exception {
 		doTestReceive(true, false, false, true, false, true, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testTopicReceiveAndConvertDestinationWithSelector() throws Exception {
 		doTestReceive(true, true, false, true, false, true, false, 1000);
 	}
@@ -886,41 +743,38 @@ private void doTestReceive(
 
 		JmsTemplate102 template = createTemplate();
 		template.setPubSubDomain(pubSub);
-		if (pubSub) {
-			template.setConnectionFactory(mockTopicConnectionFactory);
-		}
-		else {
-			template.setConnectionFactory(mockQueueConnectionFactory);
-		}
+		template.setConnectionFactory(pubSub ? topicConnectionFactory : queueConnectionFactory);
 
 		// Override the default settings for client ack used in the test setup.
 		// Can't use Session.getAcknowledgeMode()
 		if (pubSub) {
-			topicConnectionControl.reset();
+			reset(topicConnection);
 			if (clientAcknowledge) {
 				template.setSessionAcknowledgeMode(Session.CLIENT_ACKNOWLEDGE);
-				mockTopicConnection.createTopicSession(useTransactedTemplate(), Session.CLIENT_ACKNOWLEDGE);
+				given(topicConnection.createTopicSession(
+						useTransactedTemplate(), Session.CLIENT_ACKNOWLEDGE)).willReturn(topicSession);
 			}
 			else {
 				template.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
-				mockTopicConnection.createTopicSession(useTransactedTemplate(), Session.AUTO_ACKNOWLEDGE);
+				given(topicConnection.createTopicSession(
+						useTransactedTemplate(), Session.AUTO_ACKNOWLEDGE)).willReturn(topicSession);
 			}
-			topicConnectionControl.setReturnValue(mockTopicSession);
 		}
 		else {
-			queueConnectionControl.reset();
+			reset(queueConnection);
 			if (clientAcknowledge) {
 				template.setSessionAcknowledgeMode(Session.CLIENT_ACKNOWLEDGE);
-				mockQueueConnection.createQueueSession(useTransactedTemplate(), Session.CLIENT_ACKNOWLEDGE);
+				given(queueConnection.createQueueSession(
+						useTransactedTemplate(), Session.CLIENT_ACKNOWLEDGE)).willReturn(queueSession);
 			}
 			else {
 				template.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
-				mockQueueConnection.createQueueSession(useTransactedTemplate(), Session.AUTO_ACKNOWLEDGE);
+				given(queueConnection.createQueueSession(
+						useTransactedTemplate(), Session.AUTO_ACKNOWLEDGE)).willReturn(queueSession);
 			}
-			queueConnectionControl.setReturnValue(mockQueueSession);
 		}
 
-		Destination dest = pubSub ? (Destination) mockTopic : (Destination) mockQueue;
+		Destination dest = pubSub ? (Destination) topic : (Destination) queue;
 
 		if (useDefaultDestination) {
 			template.setDefaultDestination(dest);
@@ -930,94 +784,38 @@ private void doTestReceive(
 		}
 		template.setReceiveTimeout(timeout);
 
-		if (pubSub) {
-			mockTopicConnection.start();
-			topicConnectionControl.setVoidCallable(1);
-			mockTopicConnection.close();
-			topicConnectionControl.setVoidCallable(1);
-		}
-		else {
-			mockQueueConnection.start();
-			queueConnectionControl.setVoidCallable(1);
-			mockQueueConnection.close();
-			queueConnectionControl.setVoidCallable(1);
-		}
 
 		String selectorString = "selector";
-		MockControl messageConsumerControl = null;
-		MessageConsumer mockMessageConsumer = null;
+		MessageConsumer messageConsumer = null;
 
 		if (pubSub) {
-			messageConsumerControl = MockControl.createControl(TopicSubscriber.class);
-			TopicSubscriber mockTopicSubscriber = (TopicSubscriber) messageConsumerControl.getMock();
-			mockMessageConsumer = mockTopicSubscriber;
-			mockTopicSession.createSubscriber(mockTopic, messageSelector ? selectorString : null, noLocal);
-			topicSessionControl.setReturnValue(mockTopicSubscriber);
+			TopicSubscriber topicSubscriber = mock(TopicSubscriber.class);
+			messageConsumer = topicSubscriber;
+			given(topicSession.createSubscriber(topic,
+					messageSelector ? selectorString : null, noLocal)).willReturn(topicSubscriber);
 		}
 		else {
-			messageConsumerControl = MockControl.createControl(QueueReceiver.class);
-			QueueReceiver mockQueueReceiver = (QueueReceiver) messageConsumerControl.getMock();
-			mockMessageConsumer = mockQueueReceiver;
-			mockQueueSession.createReceiver(mockQueue, messageSelector ? selectorString : null);
-			queueSessionControl.setReturnValue(mockQueueReceiver);
+			QueueReceiver queueReceiver = mock(QueueReceiver.class);
+			messageConsumer = queueReceiver;
+			given(queueSession.createReceiver(queue,
+					messageSelector ? selectorString : null)).willReturn(queueReceiver);
 		}
 
-		if (useTransactedTemplate()) {
-			if (pubSub) {
-				mockTopicSession.commit();
-				topicSessionControl.setVoidCallable(1);
-			}
-			else {
-				mockQueueSession.commit();
-				queueSessionControl.setVoidCallable(1);
-			}
-		}
-
-		if (pubSub) {
-			mockTopicSession.close();
-			topicSessionControl.setVoidCallable(1);
-		}
-		else {
-			mockQueueSession.close();
-			queueSessionControl.setVoidCallable(1);
-		}
-
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
+		TextMessage textMessage = mock(TextMessage.class);
 
 		if (testConverter) {
-			mockMessage.getText();
-			messageControl.setReturnValue("Hello World!");
-		}
-		if (!useTransactedSession() && clientAcknowledge) {
-			mockMessage.acknowledge();
-			messageControl.setVoidCallable(1);
-		}
-
-		if (pubSub) {
-			topicSessionControl.replay();
-			topicConnectionControl.replay();
-		}
-		else {
-			queueSessionControl.replay();
-			queueConnectionControl.replay();
+			given(textMessage.getText()).willReturn("Hello World!");
 		}
-		messageControl.replay();
 
 		if (timeout == JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT) {
-			mockMessageConsumer.receiveNoWait();
+			given(messageConsumer.receiveNoWait()).willReturn(textMessage);
 		}
 		else if (timeout == JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT) {
-			mockMessageConsumer.receive();
+			given(messageConsumer.receive()).willReturn(textMessage);
 		}
 		else {
-			mockMessageConsumer.receive(timeout);
+			given(messageConsumer.receive(timeout)).willReturn(textMessage);
 		}
-		messageConsumerControl.setReturnValue(mockMessage);
-		mockMessageConsumer.close();
-		messageConsumerControl.setVoidCallable(1);
-
-		messageConsumerControl.replay();
 
 		Message message = null;
 		String textFromMessage = null;
@@ -1056,112 +854,123 @@ else if (explicitDestination) {
 			}
 		}
 
-		if (pubSub) {
-			topicConnectionFactoryControl.verify();
-			topicConnectionControl.verify();
-			topicSessionControl.verify();
+		if (testConverter) {
+			assertEquals("Message text should be equal", "Hello World!", textFromMessage);
 		}
 		else {
-			queueConnectionFactoryControl.verify();
-			queueConnectionControl.verify();
-			queueSessionControl.verify();
+			assertEquals("Messages should refer to the same object", message, textMessage);
 		}
-		messageConsumerControl.verify();
-		messageControl.verify();
 
-		if (testConverter) {
-			assertEquals("Message text should be equal", "Hello World!", textFromMessage);
+		if (pubSub) {
+			verify(topicConnection).start();
+			verify(topicConnection).close();
+			verify(topicSession).close();
 		}
 		else {
-			assertEquals("Messages should refer to the same object", message, mockMessage);
+			verify(queueConnection).start();
+			verify(queueConnection).close();
+			verify(queueSession).close();
+		}
+
+
+		if (useTransactedTemplate()) {
+			if (pubSub) {
+				verify(topicSession).commit();
+			}
+			else {
+				verify(queueSession).commit();
+			}
+		}
+
+		if (!useTransactedSession() && clientAcknowledge) {
+			verify(textMessage).acknowledge();
 		}
+
+		verify(messageConsumer).close();
 	}
 
+	@Test
 	public void testIllegalStateException() throws Exception {
 		doTestJmsException(new javax.jms.IllegalStateException(""), org.springframework.jms.IllegalStateException.class);
 	}
 
+	@Test
 	public void testInvalidClientIDException() throws Exception {
 		doTestJmsException(new javax.jms.InvalidClientIDException(""), InvalidClientIDException.class);
 	}
 
+	@Test
 	public void testInvalidDestinationException() throws Exception {
 		doTestJmsException(new javax.jms.InvalidDestinationException(""), InvalidDestinationException.class);
 	}
 
+	@Test
 	public void testInvalidSelectorException() throws Exception {
 		doTestJmsException(new javax.jms.InvalidSelectorException(""), InvalidSelectorException.class);
 	}
 
+	@Test
 	public void testJmsSecurityException() throws Exception {
 		doTestJmsException(new javax.jms.JMSSecurityException(""), JmsSecurityException.class);
 	}
 
+	@Test
 	public void testMessageEOFException() throws Exception {
 		doTestJmsException(new javax.jms.MessageEOFException(""), MessageEOFException.class);
 	}
 
+	@Test
 	public void testMessageFormatException() throws Exception {
 		doTestJmsException(new javax.jms.MessageFormatException(""), MessageFormatException.class);
 	}
 
+	@Test
 	public void testMessageNotReadableException() throws Exception {
 		doTestJmsException(new javax.jms.MessageNotReadableException(""), MessageNotReadableException.class);
 	}
 
+	@Test
 	public void testMessageNotWriteableException() throws Exception {
 		doTestJmsException(new javax.jms.MessageNotWriteableException(""), MessageNotWriteableException.class);
 	}
 
+	@Test
 	public void testResourceAllocationException() throws Exception {
 		doTestJmsException(new javax.jms.ResourceAllocationException(""), ResourceAllocationException.class);
 	}
 
+	@Test
 	public void testTransactionInProgressException() throws Exception {
 		doTestJmsException(new javax.jms.TransactionInProgressException(""), TransactionInProgressException.class);
 	}
 
+	@Test
 	public void testTransactionRolledBackException() throws Exception {
 		doTestJmsException(new javax.jms.TransactionRolledBackException(""), TransactionRolledBackException.class);
 	}
 
+	@Test
 	public void testUncategorizedJmsException() throws Exception {
 		doTestJmsException(new javax.jms.JMSException(""), UncategorizedJmsException.class);
 	}
 
 	protected void doTestJmsException(JMSException original, Class thrownExceptionClass) throws Exception {
 		JmsTemplate template = createTemplate();
-		template.setConnectionFactory(mockQueueConnectionFactory);
+		template.setConnectionFactory(queueConnectionFactory);
 		template.setMessageConverter(new SimpleMessageConverter());
 		String s = "Hello world";
 
-		MockControl queueSenderControl = MockControl.createControl(QueueSender.class);
-		QueueSender mockQueueSender = (QueueSender) queueSenderControl.getMock();
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
-
-		queueSessionControl.reset();
-		mockQueueSession.createSender(mockQueue);
-		queueSessionControl.setReturnValue(mockQueueSender);
-		mockQueueSession.createTextMessage("Hello world");
-		queueSessionControl.setReturnValue(mockMessage);
-
-		mockQueueSender.send(mockMessage);
-		queueSenderControl.setThrowable(original, 1);
-		mockQueueSender.close();
-		queueSenderControl.setVoidCallable(1);
+		QueueSender queueSender = mock(QueueSender.class);
+		TextMessage textMessage = mock(TextMessage.class);
 
-		mockQueueSession.close();
-		queueSessionControl.setVoidCallable(1);
-		mockQueueConnection.close();
-		queueConnectionControl.setVoidCallable(1);
+		reset(queueSession);
+		given(queueSession.createSender(queue)).willReturn(queueSender);
+		given(queueSession.createTextMessage("Hello world")).willReturn(textMessage);
 
-		queueSenderControl.replay();
-		queueSessionControl.replay();
-		queueConnectionControl.replay();
+		willThrow(original).given(queueSender).send(textMessage);
 
 		try {
-			template.convertAndSend(mockQueue, s);
+			template.convertAndSend(queue, s);
 			fail("Should have thrown JmsException");
 		}
 		catch (JmsException wrappedEx) {
@@ -1170,10 +979,9 @@ protected void doTestJmsException(JMSException original, Class thrownExceptionCl
 			assertEquals(original, wrappedEx.getCause());
 		}
 
-		queueSenderControl.verify();
-		queueSessionControl.verify();
-		queueConnectionControl.verify();
-		queueConnectionFactoryControl.verify();
+		verify(queueSender).close();
+		verify(queueSession).close();
+		verify(queueConnection).close();
 	}
 
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/core/JmsTemplateTests.java b/spring-jms/src/test/java/org/springframework/jms/core/JmsTemplateTests.java
index 500874d8a12f..937220108050 100644
--- a/spring-jms/src/test/java/org/springframework/jms/core/JmsTemplateTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/core/JmsTemplateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,11 +32,9 @@
 import javax.jms.Session;
 import javax.jms.TextMessage;
 import javax.naming.Context;
-import javax.naming.NamingException;
-
-import junit.framework.TestCase;
-import org.easymock.MockControl;
 
+import org.junit.Before;
+import org.junit.Test;
 import org.springframework.jms.InvalidClientIDException;
 import org.springframework.jms.InvalidDestinationException;
 import org.springframework.jms.InvalidSelectorException;
@@ -60,28 +58,22 @@
 import org.springframework.transaction.support.TransactionSynchronization;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for the JmsTemplate implemented using JMS 1.1.
  *
  * @author Andre Biryukov
  * @author Mark Pollack
  */
-public class JmsTemplateTests extends TestCase {
-
-	private Context mockJndiContext;
-	private MockControl mockJndiControl;
-
-	private MockControl connectionFactoryControl;
-	private ConnectionFactory mockConnectionFactory;
-
-	private MockControl connectionControl;
-	private Connection mockConnection;
+public class JmsTemplateTests {
 
-	private MockControl sessionControl;
-	private Session mockSession;
-
-	private MockControl queueControl;
-	private Destination mockQueue;
+	private Context jndiContext;
+	private ConnectionFactory connectionFactory;
+	private Connection connection;
+	private Session session;
+	private Destination queue;
 
 	private int deliveryMode = DeliveryMode.PERSISTENT;
 	private int priority = 9;
@@ -91,41 +83,19 @@ public class JmsTemplateTests extends TestCase {
 	/**
 	 * Create the mock objects for testing.
 	 */
-	@Override
-	protected void setUp() throws Exception {
-		mockJndiControl = MockControl.createControl(Context.class);
-		mockJndiContext = (Context) this.mockJndiControl.getMock();
-
-		createMockforDestination();
-
-		mockJndiContext.close();
-		mockJndiControl.replay();
-	}
-
-	private void createMockforDestination() throws JMSException, NamingException {
-		connectionFactoryControl = MockControl.createControl(ConnectionFactory.class);
-		mockConnectionFactory = (ConnectionFactory) connectionFactoryControl.getMock();
+	@Before
+	public void setupMocks() throws Exception {
+		jndiContext = mock(Context.class);
+		connectionFactory = mock(ConnectionFactory.class);
+		connection = mock(Connection.class);
+		session = mock(Session.class);
+		queue = mock(Queue.class);
 
-		connectionControl = MockControl.createControl(Connection.class);
-		mockConnection = (Connection) connectionControl.getMock();
-
-		sessionControl = MockControl.createControl(Session.class);
-		mockSession = (Session) sessionControl.getMock();
-
-		queueControl = MockControl.createControl(Queue.class);
-		mockQueue = (Queue) queueControl.getMock();
-
-		mockConnectionFactory.createConnection();
-		connectionFactoryControl.setReturnValue(mockConnection);
-		connectionFactoryControl.replay();
-
-		mockConnection.createSession(useTransactedTemplate(), Session.AUTO_ACKNOWLEDGE);
-		connectionControl.setReturnValue(mockSession);
-		mockSession.getTransacted();
-		sessionControl.setReturnValue(useTransactedSession());
-
-		mockJndiContext.lookup("testDestination");
-		mockJndiControl.setReturnValue(mockQueue);
+		given(connectionFactory.createConnection()).willReturn(connection);
+		given(connection.createSession(useTransactedTemplate(),
+				Session.AUTO_ACKNOWLEDGE)).willReturn(session);
+		given(session.getTransacted()).willReturn(useTransactedSession());
+		given(jndiContext.lookup("testDestination")).willReturn(queue);
 	}
 
 	private JmsTemplate createTemplate() {
@@ -134,7 +104,7 @@ private JmsTemplate createTemplate() {
 		destMan.setJndiTemplate(new JndiTemplate() {
 			@Override
 			protected Context createInitialContext() {
-				return mockJndiContext;
+				return jndiContext;
 			}
 		});
 		template.setDestinationResolver(destMan);
@@ -151,6 +121,7 @@ protected boolean useTransactedTemplate() {
 	}
 
 
+	@Test
 	public void testExceptionStackTrace() {
 		JMSException jmsEx = new JMSException("could not connect");
 		Exception innerEx = new Exception("host not found");
@@ -163,165 +134,106 @@ public void testExceptionStackTrace() {
 		assertTrue("inner jms exception not found", trace.indexOf("host not found") > 0);
 	}
 
+	@Test
 	public void testProducerCallback() throws Exception {
 		JmsTemplate template = createTemplate();
-		template.setConnectionFactory(mockConnectionFactory);
+		template.setConnectionFactory(connectionFactory);
 
-		MockControl messageProducerControl = MockControl.createControl(MessageProducer.class);
-		MessageProducer mockMessageProducer = (MessageProducer) messageProducerControl.getMock();
-
-		mockSession.createProducer(null);
-		sessionControl.setReturnValue(mockMessageProducer);
-
-		mockMessageProducer.getPriority();
-		messageProducerControl.setReturnValue(4);
-
-		mockMessageProducer.close();
-		messageProducerControl.setVoidCallable(1);
-		mockSession.close();
-		sessionControl.setVoidCallable(1);
-		mockConnection.close();
-		connectionControl.setVoidCallable(1);
-
-		messageProducerControl.replay();
-		sessionControl.replay();
-		connectionControl.replay();
+		MessageProducer messageProducer = mock(MessageProducer.class);
+		given(session.createProducer(null)).willReturn(messageProducer);
+		given(messageProducer.getPriority()).willReturn(4);
 
 		template.execute(new ProducerCallback() {
 			@Override
 			public Object doInJms(Session session, MessageProducer producer) throws JMSException {
-				boolean b = session.getTransacted();
-				int i = producer.getPriority();
+				session.getTransacted();
+				producer.getPriority();
 				return null;
 			}
 		});
 
-		connectionFactoryControl.verify();
-		connectionControl.verify();
-		sessionControl.verify();
+		verify(messageProducer).close();
+		verify(session).close();
+		verify(connection).close();
 	}
 
+	@Test
 	public void testProducerCallbackWithIdAndTimestampDisabled() throws Exception {
 		JmsTemplate template = createTemplate();
-		template.setConnectionFactory(mockConnectionFactory);
+		template.setConnectionFactory(connectionFactory);
 		template.setMessageIdEnabled(false);
 		template.setMessageTimestampEnabled(false);
 
-		MockControl messageProducerControl = MockControl.createControl(MessageProducer.class);
-		MessageProducer mockMessageProducer = (MessageProducer) messageProducerControl.getMock();
-
-		mockSession.createProducer(null);
-		sessionControl.setReturnValue(mockMessageProducer);
-
-		mockMessageProducer.setDisableMessageID(true);
-		messageProducerControl.setVoidCallable(1);
-		mockMessageProducer.setDisableMessageTimestamp(true);
-		messageProducerControl.setVoidCallable(1);
-		mockMessageProducer.getPriority();
-		messageProducerControl.setReturnValue(4);
-
-		mockMessageProducer.close();
-		messageProducerControl.setVoidCallable(1);
-		mockSession.close();
-		sessionControl.setVoidCallable(1);
-		mockConnection.close();
-		connectionControl.setVoidCallable(1);
-
-		messageProducerControl.replay();
-		sessionControl.replay();
-		connectionControl.replay();
+		MessageProducer messageProducer = mock(MessageProducer.class);
+		given(session.createProducer(null)).willReturn(messageProducer);
+		given(messageProducer.getPriority()).willReturn(4);
 
 		template.execute(new ProducerCallback() {
 			@Override
 			public Object doInJms(Session session, MessageProducer producer) throws JMSException {
-				boolean b = session.getTransacted();
-				int i = producer.getPriority();
+				session.getTransacted();
+				producer.getPriority();
 				return null;
 			}
 		});
 
-		connectionFactoryControl.verify();
-		connectionControl.verify();
-		sessionControl.verify();
+		verify(messageProducer).setDisableMessageID(true);
+		verify(messageProducer).setDisableMessageTimestamp(true);
+		verify(messageProducer).close();
+		verify(session).close();
+		verify(connection).close();
 	}
 
 	/**
 	 * Test the method execute(SessionCallback action).
 	 */
+	@Test
 	public void testSessionCallback() throws Exception {
 		JmsTemplate template = createTemplate();
-		template.setConnectionFactory(mockConnectionFactory);
-
-		mockSession.close();
-		sessionControl.setVoidCallable(1);
-
-		mockConnection.close();
-		connectionControl.setVoidCallable(1);
-
-		sessionControl.replay();
-		connectionControl.replay();
+		template.setConnectionFactory(connectionFactory);
 
 		template.execute(new SessionCallback() {
 			@Override
 			public Object doInJms(Session session) throws JMSException {
-				boolean b = session.getTransacted();
+				session.getTransacted();
 				return null;
 			}
 		});
 
-		connectionFactoryControl.verify();
-		connectionControl.verify();
-		sessionControl.verify();
+		verify(session).close();
+		verify(connection).close();
 	}
 
+	@Test
 	public void testSessionCallbackWithinSynchronizedTransaction() throws Exception {
-		SingleConnectionFactory scf = new SingleConnectionFactory(mockConnectionFactory);
+		SingleConnectionFactory scf = new SingleConnectionFactory(connectionFactory);
 		JmsTemplate template = createTemplate();
 		template.setConnectionFactory(scf);
 
-		mockConnection.start();
-		connectionControl.setVoidCallable(1);
-		// We're gonna call getTransacted 3 times, i.e. 2 more times.
-		mockSession.getTransacted();
-		sessionControl.setReturnValue(useTransactedSession(), 2);
-		if (useTransactedTemplate()) {
-			mockSession.commit();
-			sessionControl.setVoidCallable(1);
-		}
-		mockSession.close();
-		sessionControl.setVoidCallable(1);
-		mockConnection.stop();
-		connectionControl.setVoidCallable(1);
-		mockConnection.close();
-		connectionControl.setVoidCallable(1);
-
-		sessionControl.replay();
-		connectionControl.replay();
-
 		TransactionSynchronizationManager.initSynchronization();
 		try {
 			template.execute(new SessionCallback() {
 				@Override
 				public Object doInJms(Session session) throws JMSException {
-					boolean b = session.getTransacted();
+					session.getTransacted();
 					return null;
 				}
 			});
 			template.execute(new SessionCallback() {
 				@Override
 				public Object doInJms(Session session) throws JMSException {
-					boolean b = session.getTransacted();
+					session.getTransacted();
 					return null;
 				}
 			});
 
-			assertSame(mockSession, ConnectionFactoryUtils.getTransactionalSession(scf, null, false));
-			assertSame(mockSession, ConnectionFactoryUtils.getTransactionalSession(scf, scf.createConnection(), false));
+			assertSame(session, ConnectionFactoryUtils.getTransactionalSession(scf, null, false));
+			assertSame(session, ConnectionFactoryUtils.getTransactionalSession(scf, scf.createConnection(), false));
 
 			TransactionAwareConnectionFactoryProxy tacf = new TransactionAwareConnectionFactoryProxy(scf);
 			Connection tac = tacf.createConnection();
 			Session tas = tac.createSession(false, Session.AUTO_ACKNOWLEDGE);
-			boolean b = tas.getTransacted();
+			tas.getTransacted();
 			tas.close();
 			tac.close();
 
@@ -339,15 +251,20 @@ public Object doInJms(Session session) throws JMSException {
 		}
 		assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty());
 
-		connectionFactoryControl.verify();
-		connectionControl.verify();
-		sessionControl.verify();
+		verify(connection).start();
+		if (useTransactedTemplate()) {
+			verify(session).commit();
+		}
+		verify(session).close();
+		verify(connection).stop();
+		verify(connection).close();
 	}
 
 	/**
 	 * Test sending to a destination using the method
 	 * send(Destination d, MessageCreator messageCreator)
 	 */
+	@Test
 	public void testSendDestination() throws Exception {
 		doTestSendDestination(true, false, true, false);
 	}
@@ -356,6 +273,7 @@ public void testSendDestination() throws Exception {
 	 * Test seding to a destination using the method
 	 * send(String d, MessageCreator messageCreator)
 	 */
+	@Test
 	public void testSendDestinationName() throws Exception {
 		doTestSendDestination(false, false, true, false);
 	}
@@ -364,6 +282,7 @@ public void testSendDestinationName() throws Exception {
 	 * Test sending to a destination using the method
 	 * send(Destination d, MessageCreator messageCreator) using QOS parameters.
 	 */
+	@Test
 	public void testSendDestinationWithQOS() throws Exception {
 		doTestSendDestination(true, false, false, true);
 	}
@@ -372,6 +291,7 @@ public void testSendDestinationWithQOS() throws Exception {
 	 * Test sending to a destination using the method
 	 * send(String d, MessageCreator messageCreator) using QOS parameters.
 	 */
+	@Test
 	public void testSendDestinationNameWithQOS() throws Exception {
 		doTestSendDestination(false, false, false, true);
 	}
@@ -379,6 +299,7 @@ public void testSendDestinationNameWithQOS() throws Exception {
 	/**
 	 * Test sending to the default destination.
 	 */
+	@Test
 	public void testSendDefaultDestination() throws Exception {
 		doTestSendDestination(true, true, true, true);
 	}
@@ -386,6 +307,7 @@ public void testSendDefaultDestination() throws Exception {
 	/**
 	 * Test sending to the default destination name.
 	 */
+	@Test
 	public void testSendDefaultDestinationName() throws Exception {
 		doTestSendDestination(false, true, true, true);
 	}
@@ -393,6 +315,7 @@ public void testSendDefaultDestinationName() throws Exception {
 	/**
 	 * Test sending to the default destination using explicit QOS parameters.
 	 */
+	@Test
 	public void testSendDefaultDestinationWithQOS() throws Exception {
 		doTestSendDestination(true, true, false, false);
 	}
@@ -400,6 +323,7 @@ public void testSendDefaultDestinationWithQOS() throws Exception {
 	/**
 	 * Test sending to the default destination name using explicit QOS parameters.
 	 */
+	@Test
 	public void testSendDefaultDestinationNameWithQOS() throws Exception {
 		doTestSendDestination(false, true, false, false);
 	}
@@ -414,13 +338,13 @@ private void doTestSendDestination(
 			boolean ignoreQOS, boolean disableIdAndTimestamp) throws Exception {
 
 		JmsTemplate template = createTemplate();
-		template.setConnectionFactory(mockConnectionFactory);
+		template.setConnectionFactory(connectionFactory);
 
 		String destinationName = "testDestination";
 
 		if (useDefaultDestination) {
 			if (explicitDestination) {
-				template.setDefaultDestination(mockQueue);
+				template.setDefaultDestination(queue);
 			}
 			else {
 				template.setDefaultDestinationName(destinationName);
@@ -431,51 +355,18 @@ private void doTestSendDestination(
 			template.setMessageTimestampEnabled(false);
 		}
 
-		MockControl messageProducerControl = MockControl.createControl(MessageProducer.class);
-		MessageProducer mockMessageProducer = (MessageProducer) messageProducerControl.getMock();
-
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
+		MessageProducer messageProducer = mock(MessageProducer.class);
+		TextMessage textMessage = mock(TextMessage.class);
 
-		mockSession.createProducer(mockQueue);
-		sessionControl.setReturnValue(mockMessageProducer);
-		mockSession.createTextMessage("just testing");
-		sessionControl.setReturnValue(mockMessage);
-
-		if (useTransactedTemplate()) {
-			mockSession.commit();
-			sessionControl.setVoidCallable(1);
-		}
-
-		if (disableIdAndTimestamp) {
-			mockMessageProducer.setDisableMessageID(true);
-			messageProducerControl.setVoidCallable(1);
-			mockMessageProducer.setDisableMessageTimestamp(true);
-			messageProducerControl.setVoidCallable(1);
-		}
+		given(session.createProducer(queue)).willReturn(messageProducer);
+		given(session.createTextMessage("just testing")).willReturn(textMessage);
 
-		if (ignoreQOS) {
-			mockMessageProducer.send(mockMessage);
-		}
-		else {
+		if (!ignoreQOS) {
 			template.setExplicitQosEnabled(true);
 			template.setDeliveryMode(deliveryMode);
 			template.setPriority(priority);
 			template.setTimeToLive(timeToLive);
-			mockMessageProducer.send(mockMessage, deliveryMode, priority, timeToLive);
 		}
-		messageProducerControl.setVoidCallable(1);
-
-		mockMessageProducer.close();
-		messageProducerControl.setVoidCallable(1);
-		mockSession.close();
-		sessionControl.setVoidCallable(1);
-		mockConnection.close();
-		connectionControl.setVoidCallable(1);
-
-		messageProducerControl.replay();
-		sessionControl.replay();
-		connectionControl.replay();
 
 		if (useDefaultDestination) {
 			template.send(new MessageCreator() {
@@ -487,7 +378,7 @@ public Message createMessage(Session session) throws JMSException {
 		}
 		else {
 			if (explicitDestination) {
-				template.send(mockQueue, new MessageCreator() {
+				template.send(queue, new MessageCreator() {
 					@Override
 					public Message createMessage(Session session) throws JMSException {
 						return session.createTextMessage("just testing");
@@ -504,119 +395,131 @@ public Message createMessage(Session session) throws JMSException {
 			}
 		}
 
-		connectionFactoryControl.verify();
-		connectionControl.verify();
-		sessionControl.verify();
-		messageProducerControl.verify();
+		if (useTransactedTemplate()) {
+			verify(session).commit();
+		}
+
+		if (disableIdAndTimestamp) {
+			verify(messageProducer).setDisableMessageID(true);
+			verify(messageProducer).setDisableMessageTimestamp(true);
+		}
+
+		if (ignoreQOS) {
+			verify(messageProducer).send(textMessage);
+		}
+		else {
+			verify(messageProducer).send(textMessage, deliveryMode, priority, timeToLive);
+		}
+		verify(messageProducer).close();
+		verify(session).close();
+		verify(connection).close();
 	}
 
+	@Test
 	public void testConverter() throws Exception {
 		JmsTemplate template = createTemplate();
-		template.setConnectionFactory(mockConnectionFactory);
+		template.setConnectionFactory(connectionFactory);
 		template.setMessageConverter(new SimpleMessageConverter());
 		String s = "Hello world";
 
-		MockControl messageProducerControl = MockControl.createControl(MessageProducer.class);
-		MessageProducer mockMessageProducer = (MessageProducer) messageProducerControl.getMock();
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
+		MessageProducer messageProducer = mock(MessageProducer.class);
+		TextMessage textMessage = mock(TextMessage.class);
 
-		mockSession.createProducer(mockQueue);
-		sessionControl.setReturnValue(mockMessageProducer);
-		mockSession.createTextMessage("Hello world");
-		sessionControl.setReturnValue(mockMessage);
+		given(session.createProducer(queue)).willReturn(messageProducer);
+		given(session.createTextMessage("Hello world")).willReturn(textMessage);
 
-		mockMessageProducer.send(mockMessage);
-		messageProducerControl.setVoidCallable(1);
-		mockMessageProducer.close();
-		messageProducerControl.setVoidCallable(1);
+		template.convertAndSend(queue, s);
 
+		verify(messageProducer).send(textMessage);
+		verify(messageProducer).close();
 		if (useTransactedTemplate()) {
-			mockSession.commit();
-			sessionControl.setVoidCallable(1);
+			verify(session).commit();
 		}
-
-		mockSession.close();
-		sessionControl.setVoidCallable(1);
-		mockConnection.close();
-		connectionControl.setVoidCallable(1);
-
-		messageProducerControl.replay();
-		sessionControl.replay();
-		connectionControl.replay();
-
-		template.convertAndSend(mockQueue, s);
-
-		messageProducerControl.verify();
-		sessionControl.verify();
-		connectionControl.verify();
-		connectionFactoryControl.verify();
+		verify(session).close();
+		verify(connection).close();
 	}
 
+	@Test
 	public void testReceiveDefaultDestination() throws Exception {
 		doTestReceive(true, true, false, false, false, false, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testReceiveDefaultDestinationName() throws Exception {
 		doTestReceive(false, true, false, false, false, false, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testReceiveDestination() throws Exception {
 		doTestReceive(true, false, false, false, false, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testReceiveDestinationWithClientAcknowledge() throws Exception {
 		doTestReceive(true, false, false, true, false, false, 1000);
 	}
 
+	@Test
 	public void testReceiveDestinationName() throws Exception {
 		doTestReceive(false, false, false, false, false, true, 1000);
 	}
 
+	@Test
 	public void testReceiveDefaultDestinationWithSelector() throws Exception {
 		doTestReceive(true, true, false, false, true, true, 1000);
 	}
 
+	@Test
 	public void testReceiveDefaultDestinationNameWithSelector() throws Exception {
 		doTestReceive(false, true, false, false, true, true, JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT);
 	}
 
+	@Test
 	public void testReceiveDestinationWithSelector() throws Exception {
 		doTestReceive(true, false, false, false, true, false, 1000);
 	}
 
+	@Test
 	public void testReceiveDestinationWithClientAcknowledgeWithSelector() throws Exception {
 		doTestReceive(true, false, false, true, true, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testReceiveDestinationNameWithSelector() throws Exception {
 		doTestReceive(false, false, false, false, true, false, JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT);
 	}
 
+	@Test
 	public void testReceiveAndConvertDefaultDestination() throws Exception {
 		doTestReceive(true, true, true, false, false, false, 1000);
 	}
 
+	@Test
 	public void testReceiveAndConvertDefaultDestinationName() throws Exception {
 		doTestReceive(false, true, true, false, false, false, 1000);
 	}
 
+	@Test
 	public void testReceiveAndConvertDestinationName() throws Exception {
 		doTestReceive(false, false, true, false, false, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testReceiveAndConvertDestination() throws Exception {
 		doTestReceive(true, false, true, false, false, true, 1000);
 	}
 
+	@Test
 	public void testReceiveAndConvertDefaultDestinationWithSelector() throws Exception {
 		doTestReceive(true, true, true, false, true, true, JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT);
 	}
 
+	@Test
 	public void testReceiveAndConvertDestinationNameWithSelector() throws Exception {
 		doTestReceive(false, false, true, false, true, true, JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT);
 	}
 
+	@Test
 	public void testReceiveAndConvertDestinationWithSelector() throws Exception {
 		doTestReceive(true, false, true, false, true, false, 1000);
 	}
@@ -627,13 +530,13 @@ private void doTestReceive(
 			throws Exception {
 
 		JmsTemplate template = createTemplate();
-		template.setConnectionFactory(mockConnectionFactory);
+		template.setConnectionFactory(connectionFactory);
 
 		String destinationName = "testDestination";
 
 		if (useDefaultDestination) {
 			if (explicitDestination) {
-				template.setDefaultDestination(mockQueue);
+				template.setDefaultDestination(queue);
 			}
 			else {
 				template.setDefaultDestinationName(destinationName);
@@ -644,67 +547,34 @@ private void doTestReceive(
 		}
 		template.setReceiveTimeout(timeout);
 
-		mockConnection.start();
-		connectionControl.setVoidCallable(1);
-		mockConnection.close();
-		connectionControl.setVoidCallable(1);
-
-		MockControl messageConsumerControl = MockControl.createControl(MessageConsumer.class);
-		MessageConsumer mockMessageConsumer = (MessageConsumer) messageConsumerControl.getMock();
+		MessageConsumer messageConsumer = mock(MessageConsumer.class);
 
 		String selectorString = "selector";
-		mockSession.createConsumer(mockQueue, messageSelector ? selectorString : null);
-		sessionControl.setReturnValue(mockMessageConsumer);
+		given(session.createConsumer(queue,
+				messageSelector ? selectorString : null)).willReturn(messageConsumer);
 
-		if (useTransactedTemplate()) {
-			mockSession.commit();
-			sessionControl.setVoidCallable(1);
-		}
-		else if (!useTransactedSession()) {
-			mockSession.getAcknowledgeMode();
-			if (clientAcknowledge) {
-				sessionControl.setReturnValue(Session.CLIENT_ACKNOWLEDGE, 1);
-			}
-			else {
-				sessionControl.setReturnValue(Session.AUTO_ACKNOWLEDGE, 1);
-			}
+		if (!useTransactedTemplate() && !useTransactedSession()) {
+			given(session.getAcknowledgeMode()).willReturn(
+					clientAcknowledge ? Session.CLIENT_ACKNOWLEDGE
+							: Session.AUTO_ACKNOWLEDGE);
 		}
 
-		mockSession.close();
-		sessionControl.setVoidCallable(1);
-
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
+		TextMessage textMessage = mock(TextMessage.class);
 
 		if (testConverter) {
-			mockMessage.getText();
-			messageControl.setReturnValue("Hello World!");
-		}
-		if (!useTransactedSession() && clientAcknowledge) {
-			mockMessage.acknowledge();
-			messageControl.setVoidCallable(1);
+			given(textMessage.getText()).willReturn("Hello World!");
 		}
 
-		sessionControl.replay();
-		connectionControl.replay();
-		messageControl.replay();
-
 		if (timeout == JmsTemplate.RECEIVE_TIMEOUT_NO_WAIT) {
-			mockMessageConsumer.receiveNoWait();
+			given(messageConsumer.receiveNoWait()).willReturn(textMessage);
 		}
 		else if (timeout == JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT) {
-			mockMessageConsumer.receive();
+			given(messageConsumer.receive()).willReturn(textMessage);
 		}
 		else {
-			mockMessageConsumer.receive(timeout);
+			given(messageConsumer.receive(timeout)).willReturn(textMessage);
 		}
 
-		messageConsumerControl.setReturnValue(mockMessage);
-		mockMessageConsumer.close();
-		messageConsumerControl.setVoidCallable(1);
-
-		messageConsumerControl.replay();
-
 		Message message = null;
 		String textFromMessage = null;
 
@@ -721,12 +591,12 @@ else if (timeout == JmsTemplate.RECEIVE_TIMEOUT_INDEFINITE_WAIT) {
 		else if (explicitDestination) {
 			if (testConverter) {
 				textFromMessage = (String)
-						(messageSelector ? template.receiveSelectedAndConvert(mockQueue, selectorString) :
-						template.receiveAndConvert(mockQueue));
+						(messageSelector ? template.receiveSelectedAndConvert(queue, selectorString) :
+						template.receiveAndConvert(queue));
 			}
 			else {
-				message = (messageSelector ? template.receiveSelected(mockQueue, selectorString) :
-						template.receive(mockQueue));
+				message = (messageSelector ? template.receiveSelected(queue, selectorString) :
+						template.receive(queue));
 			}
 		}
 		else {
@@ -741,105 +611,107 @@ else if (explicitDestination) {
 			}
 		}
 
-		connectionFactoryControl.verify();
-		connectionControl.verify();
-		sessionControl.verify();
-		messageConsumerControl.verify();
-		messageControl.verify();
-
 		if (testConverter) {
 			assertEquals("Message text should be equal", "Hello World!", textFromMessage);
 		}
 		else {
-			assertEquals("Messages should refer to the same object", message, mockMessage);
+			assertEquals("Messages should refer to the same object", message, textMessage);
+		}
+
+		verify(connection).start();
+		verify(connection).close();
+		if (useTransactedTemplate()) {
+			verify(session).commit();
 		}
+		verify(session).close();
+		if (!useTransactedSession() && clientAcknowledge) {
+			verify(textMessage).acknowledge();
+		}
+		verify(messageConsumer).close();
 	}
 
+	@Test
 	public void testIllegalStateException() throws Exception {
 		doTestJmsException(new javax.jms.IllegalStateException(""), org.springframework.jms.IllegalStateException.class);
 	}
 
+	@Test
 	public void testInvalidClientIDException() throws Exception {
 		doTestJmsException(new javax.jms.InvalidClientIDException(""), InvalidClientIDException.class);
 	}
 
+	@Test
 	public void testInvalidDestinationException() throws Exception {
 		doTestJmsException(new javax.jms.InvalidDestinationException(""), InvalidDestinationException.class);
 	}
 
+	@Test
 	public void testInvalidSelectorException() throws Exception {
 		doTestJmsException(new javax.jms.InvalidSelectorException(""), InvalidSelectorException.class);
 	}
 
+	@Test
 	public void testJmsSecurityException() throws Exception {
 		doTestJmsException(new javax.jms.JMSSecurityException(""), JmsSecurityException.class);
 	}
 
+	@Test
 	public void testMessageEOFException() throws Exception {
 		doTestJmsException(new javax.jms.MessageEOFException(""), MessageEOFException.class);
 	}
 
+	@Test
 	public void testMessageFormatException() throws Exception {
 		doTestJmsException(new javax.jms.MessageFormatException(""), MessageFormatException.class);
 	}
 
+	@Test
 	public void testMessageNotReadableException() throws Exception {
 		doTestJmsException(new javax.jms.MessageNotReadableException(""), MessageNotReadableException.class);
 	}
 
+	@Test
 	public void testMessageNotWriteableException() throws Exception {
 		doTestJmsException(new javax.jms.MessageNotWriteableException(""), MessageNotWriteableException.class);
 	}
 
+	@Test
 	public void testResourceAllocationException() throws Exception {
 		doTestJmsException(new javax.jms.ResourceAllocationException(""), ResourceAllocationException.class);
 	}
 
+	@Test
 	public void testTransactionInProgressException() throws Exception {
 		doTestJmsException(new javax.jms.TransactionInProgressException(""), TransactionInProgressException.class);
 	}
 
+	@Test
 	public void testTransactionRolledBackException() throws Exception {
 		doTestJmsException(new javax.jms.TransactionRolledBackException(""), TransactionRolledBackException.class);
 	}
 
+	@Test
 	public void testUncategorizedJmsException() throws Exception {
 		doTestJmsException(new javax.jms.JMSException(""), UncategorizedJmsException.class);
 	}
 
 	protected void doTestJmsException(JMSException original, Class thrownExceptionClass) throws Exception {
 		JmsTemplate template = createTemplate();
-		template.setConnectionFactory(mockConnectionFactory);
+		template.setConnectionFactory(connectionFactory);
 		template.setMessageConverter(new SimpleMessageConverter());
 		String s = "Hello world";
 
-		MockControl messageProducerControl = MockControl.createControl(MessageProducer.class);
-		MessageProducer mockMessageProducer = (MessageProducer) messageProducerControl.getMock();
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage mockMessage = (TextMessage) messageControl.getMock();
-
-		sessionControl.reset();
-		mockSession.createProducer(mockQueue);
-		sessionControl.setReturnValue(mockMessageProducer);
-		mockSession.createTextMessage("Hello world");
-		sessionControl.setReturnValue(mockMessage);
-
-		mockMessageProducer.send(mockMessage);
-		messageProducerControl.setThrowable(original, 1);
-		mockMessageProducer.close();
-		messageProducerControl.setVoidCallable(1);
+		MessageProducer messageProducer = mock(MessageProducer.class);
+		TextMessage textMessage = mock(TextMessage.class);
 
-		mockSession.close();
-		sessionControl.setVoidCallable(1);
-		mockConnection.close();
-		connectionControl.setVoidCallable(1);
+		reset(session);
+		given(session.createProducer(queue)).willReturn(messageProducer);
+		given(session.createTextMessage("Hello world")).willReturn(textMessage);
 
-		messageProducerControl.replay();
-		sessionControl.replay();
-		connectionControl.replay();
+		willThrow(original).given(messageProducer).send(textMessage);
 
 		try {
-			template.convertAndSend(mockQueue, s);
+			template.convertAndSend(queue, s);
 			fail("Should have thrown JmsException");
 		}
 		catch (JmsException wrappedEx) {
@@ -848,10 +720,9 @@ protected void doTestJmsException(JMSException original, Class thrownExceptionCl
 			assertEquals(original, wrappedEx.getCause());
 		}
 
-		messageProducerControl.verify();
-		sessionControl.verify();
-		connectionControl.verify();
-		connectionFactoryControl.verify();
+		verify(messageProducer).close();
+		verify(session).close();
+		verify(connection).close();
 	}
 
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/core/support/JmsGatewaySupportTests.java b/spring-jms/src/test/java/org/springframework/jms/core/support/JmsGatewaySupportTests.java
index 30b71cf18235..570a7abc87a1 100644
--- a/spring-jms/src/test/java/org/springframework/jms/core/support/JmsGatewaySupportTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/core/support/JmsGatewaySupportTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,21 +20,21 @@
 
 import javax.jms.ConnectionFactory;
 
-import junit.framework.TestCase;
-import org.easymock.MockControl;
-
+import org.junit.Test;
 import org.springframework.jms.core.JmsTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Mark Pollack
  * @since 24.9.2004
  */
-public class JmsGatewaySupportTests extends TestCase {
+public class JmsGatewaySupportTests {
 
+	@Test
 	public void testJmsGatewaySupportWithConnectionFactory() throws Exception {
-		MockControl connectionFactoryControl = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory mockConnectionFactory = (ConnectionFactory) connectionFactoryControl.getMock();
-		connectionFactoryControl.replay();
+		ConnectionFactory mockConnectionFactory = mock(ConnectionFactory.class);
 		final List test = new ArrayList();
 		JmsGatewaySupport gateway = new JmsGatewaySupport() {
 			@Override
@@ -47,9 +47,9 @@ protected void initGateway() {
 		assertEquals("Correct ConnectionFactory", mockConnectionFactory, gateway.getConnectionFactory());
 		assertEquals("Correct JmsTemplate", mockConnectionFactory, gateway.getJmsTemplate().getConnectionFactory());
 		assertEquals("initGatway called", test.size(), 1);
-		connectionFactoryControl.verify();
-
 	}
+
+	@Test
 	public void testJmsGatewaySupportWithJmsTemplate() throws Exception {
 		JmsTemplate template = new JmsTemplate();
 		final List test = new ArrayList();
diff --git a/spring-jms/src/test/java/org/springframework/jms/listener/SimpleMessageListenerContainerTests.java b/spring-jms/src/test/java/org/springframework/jms/listener/SimpleMessageListenerContainerTests.java
index 6bd5c5712364..2dda59ceb137 100644
--- a/spring-jms/src/test/java/org/springframework/jms/listener/SimpleMessageListenerContainerTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/listener/SimpleMessageListenerContainerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,6 @@
 
 package org.springframework.jms.listener;
 
-import static org.junit.Assert.*;
-
 import java.util.HashSet;
 
 import javax.jms.Connection;
@@ -29,17 +27,16 @@
 import javax.jms.MessageListener;
 import javax.jms.Session;
 
-import org.easymock.EasyMock;
-import org.easymock.MockControl;
-import org.easymock.internal.AlwaysMatcher;
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.context.support.GenericApplicationContext;
 import org.springframework.core.task.TaskExecutor;
 import org.springframework.jms.StubQueue;
 import org.springframework.util.ErrorHandler;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
@@ -91,38 +88,20 @@ public void testSettingConcurrentConsumersToANegativeValueIsNotAllowed() throws
 
 	@Test
 	public void testContextRefreshedEventDoesNotStartTheConnectionIfAutoStartIsSetToFalse() throws Exception {
-		MockControl mockMessageConsumer = MockControl.createControl(MessageConsumer.class);
-		MessageConsumer messageConsumer = (MessageConsumer) mockMessageConsumer.getMock();
-		messageConsumer.setMessageListener(null);
-		// anon. inner class passed in, so just expect a call...
-		mockMessageConsumer.setMatcher(new AlwaysMatcher());
-		mockMessageConsumer.setVoidCallable();
-		mockMessageConsumer.replay();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
+		MessageConsumer messageConsumer = mock(MessageConsumer.class);
+		Session session = mock(Session.class);
 		// Queue gets created in order to create MessageConsumer for that Destination...
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(QUEUE_DESTINATION);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
 		// and then the MessageConsumer gets created...
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		mockSession.setReturnValue(messageConsumer);
-		mockSession.replay();
-
-		MockControl mockConnection = MockControl.createControl(Connection.class);
-		Connection connection = (Connection) mockConnection.getMock();
-		connection.setExceptionListener(this.container);
-		mockConnection.setVoidCallable();
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
+
+		Connection connection = mock(Connection.class);
 		// session gets created in order to register MessageListener...
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		mockConnection.setReturnValue(session);
-		mockConnection.replay();
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
 
-		MockControl mockConnectionFactory = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory connectionFactory = (ConnectionFactory) mockConnectionFactory.getMock();
-		connectionFactory.createConnection();
-		mockConnectionFactory.setReturnValue(connection);
-		mockConnectionFactory.replay();
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		this.container.setConnectionFactory(connectionFactory);
 		this.container.setDestinationName(DESTINATION_NAME);
@@ -134,49 +113,26 @@ public void testContextRefreshedEventDoesNotStartTheConnectionIfAutoStartIsSetTo
 		context.getBeanFactory().registerSingleton("messageListenerContainer", this.container);
 		context.refresh();
 
-		mockMessageConsumer.verify();
-		mockSession.verify();
-		mockConnection.verify();
-		mockConnectionFactory.verify();
+		verify(connection).setExceptionListener(this.container);
 	}
 
 	@Test
 	public void testContextRefreshedEventStartsTheConnectionByDefault() throws Exception {
-		MockControl mockMessageConsumer = MockControl.createControl(MessageConsumer.class);
-		MessageConsumer messageConsumer = (MessageConsumer) mockMessageConsumer.getMock();
-		messageConsumer.setMessageListener(null);
-		// anon. inner class passed in, so just expect a call...
-		mockMessageConsumer.setMatcher(new AlwaysMatcher());
-		mockMessageConsumer.setVoidCallable();
-		mockMessageConsumer.replay();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
+		MessageConsumer messageConsumer = mock(MessageConsumer.class);
+		Session session = mock(Session.class);
 		// Queue gets created in order to create MessageConsumer for that Destination...
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(QUEUE_DESTINATION);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
 		// and then the MessageConsumer gets created...
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		mockSession.setReturnValue(messageConsumer);
-		mockSession.replay();
-
-		MockControl mockConnection = MockControl.createControl(Connection.class);
-		Connection connection = (Connection) mockConnection.getMock();
-		connection.setExceptionListener(this.container);
-		mockConnection.setVoidCallable();
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
+
+		Connection connection = mock(Connection.class);
 		// session gets created in order to register MessageListener...
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		mockConnection.setReturnValue(session);
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
 		// and the connection is start()ed after the listener is registered...
-		connection.start();
-		mockConnection.setVoidCallable();
-		mockConnection.replay();
 
-		MockControl mockConnectionFactory = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory connectionFactory = (ConnectionFactory) mockConnectionFactory.getMock();
-		connectionFactory.createConnection();
-		mockConnectionFactory.setReturnValue(connection);
-		mockConnectionFactory.replay();
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		this.container.setConnectionFactory(connectionFactory);
 		this.container.setDestinationName(DESTINATION_NAME);
@@ -187,48 +143,31 @@ public void testContextRefreshedEventStartsTheConnectionByDefault() throws Excep
 		context.getBeanFactory().registerSingleton("messageListenerContainer", this.container);
 		context.refresh();
 
-		mockMessageConsumer.verify();
-		mockSession.verify();
-		mockConnection.verify();
-		mockConnectionFactory.verify();
+		verify(connection).setExceptionListener(this.container);
+		verify(connection).start();
 	}
 
 	@Test
 	public void testCorrectSessionExposedForSessionAwareMessageListenerInvocation() throws Exception {
 		final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer();
 
-		MockControl mockSession = MockControl.createControl(Session.class);
-		final Session session = (Session) mockSession.getMock();
+		final Session session = mock(Session.class);
 		// Queue gets created in order to create MessageConsumer for that Destination...
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(QUEUE_DESTINATION);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
 		// and then the MessageConsumer gets created...
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		mockSession.setReturnValue(messageConsumer);
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
 		// an exception is thrown, so the rollback logic is being applied here...
-		session.getTransacted();
-		mockSession.setReturnValue(false);
-		session.getAcknowledgeMode();
-		mockSession.setReturnValue(Session.AUTO_ACKNOWLEDGE);
-		mockSession.replay();
-
-		MockControl mockConnection = MockControl.createControl(Connection.class);
-		Connection connection = (Connection) mockConnection.getMock();
-		connection.setExceptionListener(this.container);
-		mockConnection.setVoidCallable();
+		given(session.getTransacted()).willReturn(false);
+		given(session.getAcknowledgeMode()).willReturn(Session.AUTO_ACKNOWLEDGE);
+
+		Connection connection = mock(Connection.class);
 		// session gets created in order to register MessageListener...
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		mockConnection.setReturnValue(session);
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
 		// and the connection is start()ed after the listener is registered...
-		connection.start();
-		mockConnection.setVoidCallable();
-		mockConnection.replay();
 
-		MockControl mockConnectionFactory = MockControl.createControl(ConnectionFactory.class);
-		final ConnectionFactory connectionFactory = (ConnectionFactory) mockConnectionFactory.getMock();
-		connectionFactory.createConnection();
-		mockConnectionFactory.setReturnValue(connection);
-		mockConnectionFactory.replay();
+		final ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		final HashSet failure = new HashSet();
 
@@ -250,52 +189,33 @@ public void onMessage(Message message, Session sess) {
 		this.container.afterPropertiesSet();
 		this.container.start();
 
-		MockControl mockMessage = MockControl.createControl(Message.class);
-		final Message message = (Message) mockMessage.getMock();
-		mockMessage.replay();
+		final Message message = mock(Message.class);
 		messageConsumer.sendMessage(message);
 
 		if (!failure.isEmpty()) {
 			fail(failure.iterator().next().toString());
 		}
 
-		mockMessage.verify();
-		mockSession.verify();
-		mockConnection.verify();
-		mockConnectionFactory.verify();
+		verify(connection).setExceptionListener(this.container);
+		verify(connection).start();
 	}
 
 	@Test
 	public void testTaskExecutorCorrectlyInvokedWhenSpecified() throws Exception {
 		final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer();
 
-		MockControl mockSession = MockControl.createControl(Session.class);
-		final Session session = (Session) mockSession.getMock();
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(QUEUE_DESTINATION);
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		mockSession.setReturnValue(messageConsumer);
-		session.getTransacted();
-		mockSession.setReturnValue(false);
-		session.getAcknowledgeMode();
-		mockSession.setReturnValue(Session.AUTO_ACKNOWLEDGE);
-		mockSession.replay();
-
-		MockControl mockConnection = MockControl.createControl(Connection.class);
-		Connection connection = (Connection) mockConnection.getMock();
-		connection.setExceptionListener(this.container);
-		mockConnection.setVoidCallable();
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		mockConnection.setReturnValue(session);
-		connection.start();
-		mockConnection.setVoidCallable();
-		mockConnection.replay();
-
-		MockControl mockConnectionFactory = MockControl.createControl(ConnectionFactory.class);
-		final ConnectionFactory connectionFactory = (ConnectionFactory) mockConnectionFactory.getMock();
-		connectionFactory.createConnection();
-		mockConnectionFactory.setReturnValue(connection);
-		mockConnectionFactory.replay();
+		final Session session = mock(Session.class);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
+		given(session.getTransacted()).willReturn(false);
+		given(session.getAcknowledgeMode()).willReturn(Session.AUTO_ACKNOWLEDGE);
+
+		Connection connection = mock(Connection.class);
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
+
+		final ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		final TestMessageListener listener = new TestMessageListener();
 
@@ -314,53 +234,36 @@ public void execute(Runnable task) {
 		this.container.afterPropertiesSet();
 		this.container.start();
 
-		MockControl mockMessage = MockControl.createControl(Message.class);
-		final Message message = (Message) mockMessage.getMock();
-		mockMessage.replay();
+		final Message message = mock(Message.class);
 		messageConsumer.sendMessage(message);
 
 		assertTrue(listener.executorInvoked);
 		assertTrue(listener.listenerInvoked);
-		mockMessage.verify();
-		mockSession.verify();
-		mockConnection.verify();
-		mockConnectionFactory.verify();
+
+		verify(connection).setExceptionListener(this.container);
+		verify(connection).start();
 	}
 
 	@Test
 	public void testRegisteredExceptionListenerIsInvokedOnException() throws Exception {
 		final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer();
 
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
+		Session session = mock(Session.class);
 		// Queue gets created in order to create MessageConsumer for that Destination...
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(QUEUE_DESTINATION);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
 		// and then the MessageConsumer gets created...
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		mockSession.setReturnValue(messageConsumer);
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
 		// an exception is thrown, so the rollback logic is being applied here...
-		session.getTransacted();
-		mockSession.setReturnValue(false);
-		mockSession.replay();
-
-		MockControl mockConnection = MockControl.createControl(Connection.class);
-		Connection connection = (Connection) mockConnection.getMock();
-		connection.setExceptionListener(this.container);
-		mockConnection.setVoidCallable();
+		given(session.getTransacted()).willReturn(false);
+
+		Connection connection = mock(Connection.class);
 		// session gets created in order to register MessageListener...
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		mockConnection.setReturnValue(session);
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
 		// and the connection is start()ed after the listener is registered...
-		connection.start();
-		mockConnection.setVoidCallable();
-		mockConnection.replay();
 
-		MockControl mockConnectionFactory = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory connectionFactory = (ConnectionFactory) mockConnectionFactory.getMock();
-		connectionFactory.createConnection();
-		mockConnectionFactory.setReturnValue(connection);
-		mockConnectionFactory.replay();
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		final JMSException theException = new JMSException(EXCEPTION_MESSAGE);
 
@@ -373,61 +276,44 @@ public void onMessage(Message message, Session session) throws JMSException {
 			}
 		});
 
-		MockControl mockExceptionListener = MockControl.createControl(ExceptionListener.class);
-		ExceptionListener exceptionListener = (ExceptionListener) mockExceptionListener.getMock();
-		exceptionListener.onException(theException);
-		mockExceptionListener.setVoidCallable();
-		mockExceptionListener.replay();
+		ExceptionListener exceptionListener = mock(ExceptionListener.class);
 
 		this.container.setExceptionListener(exceptionListener);
 		this.container.afterPropertiesSet();
 		this.container.start();
 
 		// manually trigger an Exception with the above bad MessageListener...
-		MockControl mockMessage = MockControl.createControl(Message.class);
-		final Message message = (Message) mockMessage.getMock();
-		mockMessage.replay();
+		final Message message = mock(Message.class);
 
 		// a Throwable from a MessageListener MUST simply be swallowed...
 		messageConsumer.sendMessage(message);
 
-		mockExceptionListener.verify();
-		mockMessage.verify();
-		mockSession.verify();
-		mockConnection.verify();
-		mockConnectionFactory.verify();
+
+		verify(connection).setExceptionListener(this.container);
+		verify(connection).start();
+		verify(exceptionListener).onException(theException);
 	}
 
 	@Test
 	public void testRegisteredErrorHandlerIsInvokedOnException() throws Exception {
 		final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer();
 
-		Session session = EasyMock.createMock(Session.class);
+		Session session = mock(Session.class);
 
 		// Queue gets created in order to create MessageConsumer for that Destination...
-		session.createQueue(DESTINATION_NAME);
-		EasyMock.expectLastCall().andReturn(QUEUE_DESTINATION);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
 		// and then the MessageConsumer gets created...
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		EasyMock.expectLastCall().andReturn(messageConsumer);
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
 		// an exception is thrown, so the rollback logic is being applied here...
-		session.getTransacted();
-		EasyMock.expectLastCall().andReturn(false);
-		EasyMock.replay(session);
+		given(session.getTransacted()).willReturn(false);
 
-		Connection connection = EasyMock.createMock(Connection.class);
-		connection.setExceptionListener(this.container);
+		Connection connection = mock(Connection.class);
 		// session gets created in order to register MessageListener...
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		EasyMock.expectLastCall().andReturn(session);
-		// and the connection is start()ed after the listener is registered...
-		connection.start();
-		EasyMock.replay(connection);
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
 
-		ConnectionFactory connectionFactory = EasyMock.createMock(ConnectionFactory.class);
-		connectionFactory.createConnection();
-		EasyMock.expectLastCall().andReturn(connection);
-		EasyMock.replay(connectionFactory);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		final IllegalStateException theException = new IllegalStateException("intentional test failure");
 
@@ -440,58 +326,42 @@ public void onMessage(Message message, Session session) throws JMSException {
 			}
 		});
 
-		ErrorHandler errorHandler = EasyMock.createMock(ErrorHandler.class);
-		errorHandler.handleError(theException);
-		EasyMock.expectLastCall();
-		EasyMock.replay(errorHandler);
+		ErrorHandler errorHandler = mock(ErrorHandler.class);
 		this.container.setErrorHandler(errorHandler);
 		this.container.afterPropertiesSet();
 		this.container.start();
 
 		// manually trigger an Exception with the above bad MessageListener...
-		Message message = EasyMock.createMock(Message.class);
-		EasyMock.replay(message);
+		Message message = mock(Message.class);
 
 		// a Throwable from a MessageListener MUST simply be swallowed...
 		messageConsumer.sendMessage(message);
 
-		EasyMock.verify(errorHandler, message, session, connection, connectionFactory);
+		verify(connection).setExceptionListener(this.container);
+		verify(connection).start();
+		verify(errorHandler).handleError(theException);
 	}
 
 	@Test
 	public void testNoRollbackOccursIfSessionIsNotTransactedAndThatExceptionsDo_NOT_Propagate() throws Exception {
 		final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer();
 
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
+		Session session = mock(Session.class);
 		// Queue gets created in order to create MessageConsumer for that Destination...
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(QUEUE_DESTINATION);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
 		// and then the MessageConsumer gets created...
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		mockSession.setReturnValue(messageConsumer);
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
 		// an exception is thrown, so the rollback logic is being applied here...
-		session.getTransacted();
-		mockSession.setReturnValue(false);
-		mockSession.replay();
-
-		MockControl mockConnection = MockControl.createControl(Connection.class);
-		Connection connection = (Connection) mockConnection.getMock();
-		connection.setExceptionListener(this.container);
-		mockConnection.setVoidCallable();
+		given(session.getTransacted()).willReturn(false);
+
+		Connection connection = mock(Connection.class);
 		// session gets created in order to register MessageListener...
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		mockConnection.setReturnValue(session);
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
 		// and the connection is start()ed after the listener is registered...
-		connection.start();
-		mockConnection.setVoidCallable();
-		mockConnection.replay();
 
-		MockControl mockConnectionFactory = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory connectionFactory = (ConnectionFactory) mockConnectionFactory.getMock();
-		connectionFactory.createConnection();
-		mockConnectionFactory.setReturnValue(connection);
-		mockConnectionFactory.replay();
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		this.container.setConnectionFactory(connectionFactory);
 		this.container.setDestinationName(DESTINATION_NAME);
@@ -505,17 +375,13 @@ public void onMessage(Message message) {
 		this.container.start();
 
 		// manually trigger an Exception with the above bad MessageListener...
-		MockControl mockMessage = MockControl.createControl(Message.class);
-		final Message message = (Message) mockMessage.getMock();
-		mockMessage.replay();
+		final Message message = mock(Message.class);
 
 		// a Throwable from a MessageListener MUST simply be swallowed...
 		messageConsumer.sendMessage(message);
 
-		mockMessage.verify();
-		mockSession.verify();
-		mockConnection.verify();
-		mockConnectionFactory.verify();
+		verify(connection).setExceptionListener(this.container);
+		verify(connection).start();
 	}
 
 	@Test
@@ -524,39 +390,22 @@ public void testTransactedSessionsGetRollbackLogicAppliedAndThatExceptionsStillD
 
 		final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer();
 
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
+		Session session = mock(Session.class);
 		// Queue gets created in order to create MessageConsumer for that Destination...
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(QUEUE_DESTINATION);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
 		// and then the MessageConsumer gets created...
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		mockSession.setReturnValue(messageConsumer);
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
 		// an exception is thrown, so the rollback logic is being applied here...
-		session.getTransacted();
-		mockSession.setReturnValue(true);
-		// Session is rolled back 'cos it is transacted...
-		session.rollback();
-		mockSession.setVoidCallable();
-		mockSession.replay();
-
-		MockControl mockConnection = MockControl.createControl(Connection.class);
-		Connection connection = (Connection) mockConnection.getMock();
-		connection.setExceptionListener(this.container);
-		mockConnection.setVoidCallable();
+		given(session.getTransacted()).willReturn(true);
+
+		Connection connection = mock(Connection.class);
 		// session gets created in order to register MessageListener...
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		mockConnection.setReturnValue(session);
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
 		// and the connection is start()ed after the listener is registered...
-		connection.start();
-		mockConnection.setVoidCallable();
-		mockConnection.replay();
 
-		MockControl mockConnectionFactory = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory connectionFactory = (ConnectionFactory) mockConnectionFactory.getMock();
-		connectionFactory.createConnection();
-		mockConnectionFactory.setReturnValue(connection);
-		mockConnectionFactory.replay();
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		this.container.setConnectionFactory(connectionFactory);
 		this.container.setDestinationName(DESTINATION_NAME);
@@ -570,65 +419,34 @@ public void onMessage(Message message) {
 		this.container.start();
 
 		// manually trigger an Exception with the above bad MessageListener...
-		MockControl mockMessage = MockControl.createControl(Message.class);
-		final Message message = (Message) mockMessage.getMock();
-		mockMessage.replay();
+		final Message message = mock(Message.class);
 
 		// a Throwable from a MessageListener MUST simply be swallowed...
 		messageConsumer.sendMessage(message);
 
-		mockMessage.verify();
-		mockSession.verify();
-		mockConnection.verify();
-		mockConnectionFactory.verify();
+		// Session is rolled back 'cos it is transacted...
+		verify(session).rollback();
+		verify(connection).setExceptionListener(this.container);
+		verify(connection).start();
 	}
 
 	@Test
 	public void testDestroyClosesConsumersSessionsAndConnectionInThatOrder() throws Exception {
-		MockControl mockMessageConsumer = MockControl.createControl(MessageConsumer.class);
-		MessageConsumer messageConsumer = (MessageConsumer) mockMessageConsumer.getMock();
-		messageConsumer.setMessageListener(null);
-		// anon. inner class passed in, so just expect a call...
-		mockMessageConsumer.setMatcher(new AlwaysMatcher());
-		mockMessageConsumer.setVoidCallable();
-		// closing down...
-		messageConsumer.close();
-		mockMessageConsumer.setVoidCallable();
-		mockMessageConsumer.replay();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
+		MessageConsumer messageConsumer = mock(MessageConsumer.class);
+		Session session = mock(Session.class);
 		// Queue gets created in order to create MessageConsumer for that Destination...
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(QUEUE_DESTINATION);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION);
 		// and then the MessageConsumer gets created...
-		session.createConsumer(QUEUE_DESTINATION, null); // no MessageSelector...
-		mockSession.setReturnValue(messageConsumer);
-		// closing down...
-		session.close();
-		mockSession.setVoidCallable();
-		mockSession.replay();
-
-		MockControl mockConnection = MockControl.createControl(Connection.class);
-		Connection connection = (Connection) mockConnection.getMock();
-		connection.setExceptionListener(this.container);
-		mockConnection.setVoidCallable();
+		given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer); // no MessageSelector...
+
+		Connection connection = mock(Connection.class);
 		// session gets created in order to register MessageListener...
-		connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode());
-		mockConnection.setReturnValue(session);
+		given(connection.createSession(this.container.isSessionTransacted(),
+				this.container.getSessionAcknowledgeMode())).willReturn(session);
 		// and the connection is start()ed after the listener is registered...
-		connection.start();
-		mockConnection.setVoidCallable();
-		// closing down...
-		connection.close();
-		mockConnection.setVoidCallable();
-		mockConnection.replay();
-
-		MockControl mockConnectionFactory = MockControl.createControl(ConnectionFactory.class);
-		ConnectionFactory connectionFactory = (ConnectionFactory) mockConnectionFactory.getMock();
-		connectionFactory.createConnection();
-		mockConnectionFactory.setReturnValue(connection);
-		mockConnectionFactory.replay();
+
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		given(connectionFactory.createConnection()).willReturn(connection);
 
 		this.container.setConnectionFactory(connectionFactory);
 		this.container.setDestinationName(DESTINATION_NAME);
@@ -638,10 +456,11 @@ public void testDestroyClosesConsumersSessionsAndConnectionInThatOrder() throws
 		this.container.start();
 		this.container.destroy();
 
-		mockMessageConsumer.verify();
-		mockSession.verify();
-		mockConnection.verify();
-		mockConnectionFactory.verify();
+		verify(messageConsumer).close();
+		verify(session).close();
+		verify(connection).setExceptionListener(this.container);
+		verify(connection).start();
+		verify(connection).close();
 	}
 
 
diff --git a/spring-jms/src/test/java/org/springframework/jms/listener/adapter/MessageListenerAdapter102Tests.java b/spring-jms/src/test/java/org/springframework/jms/listener/adapter/MessageListenerAdapter102Tests.java
index a41851b5ecfa..1d633b4e5f46 100644
--- a/spring-jms/src/test/java/org/springframework/jms/listener/adapter/MessageListenerAdapter102Tests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/listener/adapter/MessageListenerAdapter102Tests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,7 @@
 
 package org.springframework.jms.listener.adapter;
 
-import static org.junit.Assert.*;
+import java.io.ByteArrayInputStream;
 
 import javax.jms.BytesMessage;
 import javax.jms.InvalidDestinationException;
@@ -30,16 +30,21 @@
 import javax.jms.TopicPublisher;
 import javax.jms.TopicSession;
 
-import org.easymock.MockControl;
 import org.junit.Test;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.springframework.jms.support.converter.SimpleMessageConverter102;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for the {@link MessageListenerAdapter102} class.
  *
  * @author Rick Evans
  * @author Chris Beams
  */
+@Deprecated
 public final class MessageListenerAdapter102Tests {
 
 	private static final String TEXT = "The Runaways";
@@ -50,48 +55,36 @@ public final class MessageListenerAdapter102Tests {
 	@Test
 	public void testWithMessageContentsDelegateForBytesMessage() throws Exception {
 
-		MockControl mockBytesMessage = MockControl.createControl(BytesMessage.class);
-		BytesMessage bytesMessage = (BytesMessage) mockBytesMessage.getMock();
+		BytesMessage bytesMessage = mock(BytesMessage.class);
 		// BytesMessage contents must be unwrapped...
-		bytesMessage.readBytes(null);
-		mockBytesMessage.setMatcher(MockControl.ALWAYS_MATCHER);
-		mockBytesMessage.setReturnValue(TEXT.getBytes().length);
-		mockBytesMessage.replay();
-
-		MockControl mockDelegate = MockControl.createControl(MessageContentsDelegate.class);
-		MessageContentsDelegate delegate = (MessageContentsDelegate) mockDelegate.getMock();
-		delegate.handleMessage(TEXT.getBytes());
-		mockDelegate.setMatcher(MockControl.ALWAYS_MATCHER);
-		mockDelegate.setVoidCallable();
-		mockDelegate.replay();
+		given(bytesMessage.readBytes(any(byte[].class))).willAnswer(new Answer<Integer>() {
+			@Override
+			public Integer answer(InvocationOnMock invocation) throws Throwable {
+				byte[] bytes = (byte[]) invocation.getArguments()[0];
+				ByteArrayInputStream inputStream = new ByteArrayInputStream(TEXT.getBytes());
+				return inputStream.read(bytes);
+			}
+		});
+		MessageContentsDelegate delegate = mock(MessageContentsDelegate.class);
 
 		MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate);
 		adapter.onMessage(bytesMessage);
 
-		mockDelegate.verify();
-		mockBytesMessage.verify();
+		verify(delegate).handleMessage(TEXT.getBytes());
 	}
 
 	@Test
 	public void testWithMessageDelegate() throws Exception {
 
-		MockControl mockTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage textMessage = (TextMessage) mockTextMessage.getMock();
-		mockTextMessage.replay();
-
-		MockControl mockDelegate = MockControl.createControl(MessageDelegate.class);
-		MessageDelegate delegate = (MessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(textMessage);
-		mockDelegate.setVoidCallable();
-		mockDelegate.replay();
+		TextMessage textMessage = mock(TextMessage.class);
+		MessageDelegate delegate = mock(MessageDelegate.class);
 
 		MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate);
 		// we DON'T want the default SimpleMessageConversion happening...
 		adapter.setMessageConverter(null);
 		adapter.onMessage(textMessage);
 
-		mockDelegate.verify();
-		mockTextMessage.verify();
+		verify(delegate).handleMessage(textMessage);
 	}
 
 	@Test
@@ -104,69 +97,38 @@ public void testThatTheDefaultMessageConverterisIndeedTheSimpleMessageConverter1
 	@Test
 	public void testWithResponsiveMessageDelegate_DoesNotSendReturnTextMessageIfNoSessionSupplied() throws Exception {
 
-		MockControl mockTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage textMessage = (TextMessage) mockTextMessage.getMock();
-		mockTextMessage.replay();
+		TextMessage textMessage = mock(TextMessage.class);
 
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(textMessage);
-		mockDelegate.setReturnValue(TEXT);
-		mockDelegate.replay();
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(textMessage)).willReturn(TEXT);
 
 		MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate);
 		// we DON'T want the default SimpleMessageConversion happening...
 		adapter.setMessageConverter(null);
 		adapter.onMessage(textMessage);
 
-		mockDelegate.verify();
-		mockTextMessage.verify();
+		verify(delegate).handleMessage(textMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateWithDefaultDestination_SendsReturnTextMessageWhenSessionSuppliedForQueue() throws Exception {
 
-		MockControl mockDestination = MockControl.createControl(Queue.class);
-		Queue destination = (Queue) mockDestination.getMock();
-		mockDestination.replay();
+		Queue destination = mock(Queue.class);
 
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(null); // we want to fall back to the default...
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockQueueSender = MockControl.createControl(QueueSender.class);
-		QueueSender queueSender = (QueueSender) mockQueueSender.getMock();
-		queueSender.send(responseTextMessage);
-		mockQueueSender.setVoidCallable();
-		queueSender.close();
-		mockQueueSender.setVoidCallable();
-		mockQueueSender.replay();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		QueueSession session = (QueueSession) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		session.createSender(destination);
-		mockSession.setReturnValue(queueSender);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(null);
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+		QueueSender queueSender = mock(QueueSender.class);
+		QueueSession session = mock(QueueSession.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+		given(session.createSender(destination)).willReturn(queueSender);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate) {
 			@Override
@@ -177,58 +139,30 @@ protected Object extractMessage(Message message) {
 		adapter.setDefaultResponseDestination(destination);
 		adapter.onMessage(sentTextMessage, session);
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
-		mockDestination.verify();
-		mockQueueSender.verify();
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(queueSender).send(responseTextMessage);
+		verify(queueSender).close();
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateWithDefaultDestination_SendsReturnTextMessageWhenSessionSuppliedForTopic() throws Exception {
 
-		MockControl mockDestination = MockControl.createControl(Topic.class);
-		Topic destination = (Topic) mockDestination.getMock();
-		mockDestination.replay();
-
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		Topic destination = mock(Topic.class);
+		TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(null); // we want to fall back to the default...
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockTopicPublisher = MockControl.createControl(TopicPublisher.class);
-		TopicPublisher topicPublisher = (TopicPublisher) mockTopicPublisher.getMock();
-		topicPublisher.publish(responseTextMessage);
-		mockTopicPublisher.setVoidCallable();
-		topicPublisher.close();
-		mockTopicPublisher.setVoidCallable();
-		mockTopicPublisher.replay();
-
-		MockControl mockSession = MockControl.createControl(TopicSession.class);
-		TopicSession session = (TopicSession) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		session.createPublisher(destination);
-		mockSession.setReturnValue(topicPublisher);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(null); // we want to fall back to the default...
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+		TopicPublisher topicPublisher = mock(TopicPublisher.class);
+		TopicSession session = mock(TopicSession.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+		given(session.createPublisher(destination)).willReturn(topicPublisher);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate) {
 			@Override
@@ -239,58 +173,30 @@ protected Object extractMessage(Message message) {
 		adapter.setDefaultResponseDestination(destination);
 		adapter.onMessage(sentTextMessage, session);
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
-		mockDestination.verify();
-		mockTopicPublisher.verify();
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(topicPublisher).publish(responseTextMessage);
+		verify(topicPublisher).close();
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateNoDefaultDestination_SendsReturnTextMessageWhenSessionSupplied() throws Exception {
 
-		MockControl mockDestination = MockControl.createControl(Queue.class);
-		Queue destination = (Queue) mockDestination.getMock();
-		mockDestination.replay();
-
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		Queue destination = mock(Queue.class);
+		TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(destination);
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockQueueSender = MockControl.createControl(QueueSender.class);
-		QueueSender queueSender = (QueueSender) mockQueueSender.getMock();
-		queueSender.send(responseTextMessage);
-		mockQueueSender.setVoidCallable();
-		queueSender.close();
-		mockQueueSender.setVoidCallable();
-		mockQueueSender.replay();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		QueueSession session = (QueueSession) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		session.createSender(destination);
-		mockSession.setReturnValue(queueSender);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(destination);
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+		QueueSender queueSender = mock(QueueSender.class);
+		QueueSession session = mock(QueueSession.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+		given(session.createSender(destination)).willReturn(queueSender);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate) {
 			@Override
@@ -300,44 +206,29 @@ protected Object extractMessage(Message message) {
 		};
 		adapter.onMessage(sentTextMessage, session);
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
-		mockDestination.verify();
-		mockQueueSender.verify();
+
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(queueSender).send(responseTextMessage);
+		verify(queueSender).close();
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateNoDefaultDestinationAndNoReplyToDestination_SendsReturnTextMessageWhenSessionSupplied() throws Exception {
 
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		final TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(null);
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		final QueueSession session = (QueueSession) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(null);
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+
+		final QueueSession session = mock(QueueSession.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		final MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate) {
 			@Override
@@ -350,57 +241,31 @@ protected Object extractMessage(Message message) {
 			fail("expected InvalidDestinationException");
 		} catch (InvalidDestinationException ex) { /* expected */ }
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateNoDefaultDestination_SendsReturnTextMessageWhenSessionSupplied_AndSendingThrowsJMSException() throws Exception {
 
-		MockControl mockDestination = MockControl.createControl(Queue.class);
-		Queue destination = (Queue) mockDestination.getMock();
-		mockDestination.replay();
-
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		Queue destination = mock(Queue.class);
+		final TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(destination);
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockQueueSender = MockControl.createControl(QueueSender.class);
-		QueueSender queueSender = (QueueSender) mockQueueSender.getMock();
-		queueSender.send(responseTextMessage);
-		mockQueueSender.setThrowable(new JMSException("Dow!"));
+		given(sentTextMessage.getJMSReplyTo()).willReturn(destination);
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+		QueueSender queueSender = mock(QueueSender.class);
+		willThrow(new JMSException("Doe!")).given(queueSender).send(responseTextMessage);
 		// ensure that regardless of a JMSException the producer is closed...
-		queueSender.close();
-		mockQueueSender.setVoidCallable();
-		mockQueueSender.replay();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		final QueueSession session = (QueueSession) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		session.createSender(destination);
-		mockSession.setReturnValue(queueSender);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+
+		final QueueSession session = mock(QueueSession.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+		given(session.createSender(destination)).willReturn(queueSender);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		final MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate) {
 			@Override
@@ -413,30 +278,20 @@ protected Object extractMessage(Message message) {
 			fail("expected JMSException");
 		} catch (JMSException ex) { /* expected */ }
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
-		mockDestination.verify();
-		mockQueueSender.verify();
+
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(queueSender).close();
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateDoesNotSendReturnTextMessageWhenSessionSupplied_AndListenerMethodThrowsException() throws Exception {
 
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
-		mockSentTextMessage.replay();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		final QueueSession session = (QueueSession) mockSession.getMock();
-		mockSession.replay();
+		final TextMessage sentTextMessage = mock(TextMessage.class);
+		final QueueSession session = mock(QueueSession.class);
 
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setThrowable(new IllegalArgumentException("Dow!"));
-		mockDelegate.replay();
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		willThrow(new IllegalArgumentException("Doe!")).given(delegate).handleMessage(sentTextMessage);
 
 		final MessageListenerAdapter102 adapter = new MessageListenerAdapter102(delegate) {
 			@Override
@@ -448,10 +303,6 @@ protected Object extractMessage(Message message) {
 			adapter.onMessage(sentTextMessage, session);
 			fail("expected ListenerExecutionFailedException");
 		} catch (ListenerExecutionFailedException ex) { /* expected */ }
-
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockSession.verify();
 	}
 
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/listener/adapter/MessageListenerAdapterTests.java b/spring-jms/src/test/java/org/springframework/jms/listener/adapter/MessageListenerAdapterTests.java
index 8fdf93910883..3fa9fe313a00 100644
--- a/spring-jms/src/test/java/org/springframework/jms/listener/adapter/MessageListenerAdapterTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/listener/adapter/MessageListenerAdapterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,7 @@
 
 package org.springframework.jms.listener.adapter;
 
-import static org.junit.Assert.*;
-
+import java.io.ByteArrayInputStream;
 import java.io.Serializable;
 
 import javax.jms.BytesMessage;
@@ -33,12 +32,15 @@
 import javax.jms.Session;
 import javax.jms.TextMessage;
 
-import org.easymock.MockControl;
 import org.junit.Test;
-
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.springframework.jms.support.converter.MessageConversionException;
 import org.springframework.jms.support.converter.SimpleMessageConverter;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
@@ -59,161 +61,110 @@ public class MessageListenerAdapterTests {
 
 	@Test
 	public void testWithMessageContentsDelegateForTextMessage() throws Exception {
-		MockControl mockTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage textMessage = (TextMessage) mockTextMessage.getMock();
+		TextMessage textMessage = mock(TextMessage.class);
 		// TextMessage contents must be unwrapped...
-		textMessage.getText();
-		mockTextMessage.setReturnValue(TEXT);
-		mockTextMessage.replay();
+		given(textMessage.getText()).willReturn(TEXT);
 
-		MockControl mockDelegate = MockControl.createControl(MessageContentsDelegate.class);
-		MessageContentsDelegate delegate = (MessageContentsDelegate) mockDelegate.getMock();
-		delegate.handleMessage(TEXT);
-		mockDelegate.setVoidCallable();
-		mockDelegate.replay();
+		MessageContentsDelegate delegate = mock(MessageContentsDelegate.class);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate);
 		adapter.onMessage(textMessage);
 
-		mockDelegate.verify();
-		mockTextMessage.verify();
+		verify(delegate).handleMessage(TEXT);
 	}
 
 	@Test
 	public void testWithMessageContentsDelegateForBytesMessage() throws Exception {
-		MockControl mockBytesMessage = MockControl.createControl(BytesMessage.class);
-		BytesMessage bytesMessage = (BytesMessage) mockBytesMessage.getMock();
+		BytesMessage bytesMessage = mock(BytesMessage.class);
 		// BytesMessage contents must be unwrapped...
-		bytesMessage.getBodyLength();
-		mockBytesMessage.setReturnValue(TEXT.getBytes().length);
-		bytesMessage.readBytes(null);
-		mockBytesMessage.setMatcher(MockControl.ALWAYS_MATCHER);
-		mockBytesMessage.setReturnValue(TEXT.getBytes().length);
-		mockBytesMessage.replay();
-
-		MockControl mockDelegate = MockControl.createControl(MessageContentsDelegate.class);
-		MessageContentsDelegate delegate = (MessageContentsDelegate) mockDelegate.getMock();
-		delegate.handleMessage(TEXT.getBytes());
-		mockDelegate.setMatcher(MockControl.ALWAYS_MATCHER);
-		mockDelegate.setVoidCallable();
-		mockDelegate.replay();
+		given(bytesMessage.getBodyLength()).willReturn(new Long(TEXT.getBytes().length));
+		given(bytesMessage.readBytes(any(byte[].class))).willAnswer(new Answer<Integer>() {
+			@Override
+			public Integer answer(InvocationOnMock invocation) throws Throwable {
+				byte[] bytes = (byte[]) invocation.getArguments()[0];
+				ByteArrayInputStream inputStream = new ByteArrayInputStream(TEXT.getBytes());
+				return inputStream.read(bytes);
+			}
+		});
+
+		MessageContentsDelegate delegate = mock(MessageContentsDelegate.class);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate);
 		adapter.onMessage(bytesMessage);
 
-		mockDelegate.verify();
-		mockBytesMessage.verify();
+		verify(delegate).handleMessage(TEXT.getBytes());
 	}
 
 	@Test
 	public void testWithMessageContentsDelegateForObjectMessage() throws Exception {
-		MockControl mockObjectMessage = MockControl.createControl(ObjectMessage.class);
-		ObjectMessage objectMessage = (ObjectMessage) mockObjectMessage.getMock();
-		objectMessage.getObject();
-		mockObjectMessage.setReturnValue(NUMBER);
-		mockObjectMessage.replay();
-
-		MockControl mockDelegate = MockControl.createControl(MessageContentsDelegate.class);
-		MessageContentsDelegate delegate = (MessageContentsDelegate) mockDelegate.getMock();
-		delegate.handleMessage(NUMBER);
-		mockDelegate.setVoidCallable();
-		mockDelegate.replay();
+		ObjectMessage objectMessage = mock(ObjectMessage.class);
+		given(objectMessage.getObject()).willReturn(NUMBER);
+
+		MessageContentsDelegate delegate = mock(MessageContentsDelegate.class);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate);
 		adapter.onMessage(objectMessage);
 
-		mockDelegate.verify();
-		mockObjectMessage.verify();
+		verify(delegate).handleMessage(NUMBER);
 	}
 
 	@Test
 	public void testWithMessageContentsDelegateForObjectMessageWithPlainObject() throws Exception {
-		MockControl mockObjectMessage = MockControl.createControl(ObjectMessage.class);
-		ObjectMessage objectMessage = (ObjectMessage) mockObjectMessage.getMock();
-		objectMessage.getObject();
-		mockObjectMessage.setReturnValue(OBJECT);
-		mockObjectMessage.replay();
-
-		MockControl mockDelegate = MockControl.createControl(MessageContentsDelegate.class);
-		MessageContentsDelegate delegate = (MessageContentsDelegate) mockDelegate.getMock();
-		delegate.handleMessage(OBJECT);
-		mockDelegate.setVoidCallable();
-		mockDelegate.replay();
+		ObjectMessage objectMessage = mock(ObjectMessage.class);
+		given(objectMessage.getObject()).willReturn(OBJECT);
+
+		MessageContentsDelegate delegate = mock(MessageContentsDelegate.class);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate);
 		adapter.onMessage(objectMessage);
 
-		mockDelegate.verify();
-		mockObjectMessage.verify();
+		verify(delegate).handleMessage(OBJECT);
 	}
 
 	@Test
 	public void testWithMessageDelegate() throws Exception {
-		MockControl mockTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage textMessage = (TextMessage) mockTextMessage.getMock();
-		mockTextMessage.replay();
+		TextMessage textMessage = mock(TextMessage.class);
 
-		MockControl mockDelegate = MockControl.createControl(MessageDelegate.class);
-		MessageDelegate delegate = (MessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(textMessage);
-		mockDelegate.setVoidCallable();
-		mockDelegate.replay();
+		MessageDelegate delegate = mock(MessageDelegate.class);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate);
 		// we DON'T want the default SimpleMessageConversion happening...
 		adapter.setMessageConverter(null);
 		adapter.onMessage(textMessage);
 
-		mockDelegate.verify();
-		mockTextMessage.verify();
+		verify(delegate).handleMessage(textMessage);
 	}
 
 	@Test
 	public void testWhenTheAdapterItselfIsTheDelegate() throws Exception {
-		MockControl mockTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage textMessage = (TextMessage) mockTextMessage.getMock();
+		TextMessage textMessage = mock(TextMessage.class);
 		// TextMessage contents must be unwrapped...
-		textMessage.getText();
-		mockTextMessage.setReturnValue(TEXT);
-		mockTextMessage.replay();
+		given(textMessage.getText()).willReturn(TEXT);
 
 		StubMessageListenerAdapter adapter = new StubMessageListenerAdapter();
 		adapter.onMessage(textMessage);
 		assertTrue(adapter.wasCalled());
-
-		mockTextMessage.verify();
 	}
 
 	@Test
 	public void testRainyDayWithNoApplicableHandlingMethods() throws Exception {
-		MockControl mockTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage textMessage = (TextMessage) mockTextMessage.getMock();
+		TextMessage textMessage = mock(TextMessage.class);
 		// TextMessage contents must be unwrapped...
-		textMessage.getText();
-		mockTextMessage.setReturnValue(TEXT);
-		mockTextMessage.replay();
+		given(textMessage.getText()).willReturn(TEXT);
 
 		StubMessageListenerAdapter adapter = new StubMessageListenerAdapter();
 		adapter.setDefaultListenerMethod("walnutsRock");
 		adapter.onMessage(textMessage);
 		assertFalse(adapter.wasCalled());
-
-		mockTextMessage.verify();
 	}
 
 	@Test
 	public void testThatAnExceptionThrownFromTheHandlingMethodIsSimplySwallowedByDefault() throws Exception {
 		final IllegalArgumentException exception = new IllegalArgumentException();
 
-		MockControl mockTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage textMessage = (TextMessage) mockTextMessage.getMock();
-		mockTextMessage.replay();
-
-		MockControl mockDelegate = MockControl.createControl(MessageDelegate.class);
-		MessageDelegate delegate = (MessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(textMessage);
-		mockDelegate.setThrowable(exception);
-		mockDelegate.replay();
+		TextMessage textMessage = mock(TextMessage.class);
+		MessageDelegate delegate = mock(MessageDelegate.class);
+		willThrow(exception).given(delegate).handleMessage(textMessage);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {
 			@Override
@@ -230,9 +181,6 @@ protected void handleListenerException(Throwable ex) {
 		// we DON'T want the default SimpleMessageConversion happening...
 		adapter.setMessageConverter(null);
 		adapter.onMessage(textMessage);
-
-		mockDelegate.verify();
-		mockTextMessage.verify();
 	}
 
 	@Test
@@ -257,68 +205,35 @@ public void testThatTheDefaultMessageHandlingMethodNameIsTheConstantDefault() th
 
 	@Test
 	public void testWithResponsiveMessageDelegate_DoesNotSendReturnTextMessageIfNoSessionSupplied() throws Exception {
-		MockControl mockTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage textMessage = (TextMessage) mockTextMessage.getMock();
-		mockTextMessage.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(textMessage);
-		mockDelegate.setReturnValue(TEXT);
-		mockDelegate.replay();
+		TextMessage textMessage = mock(TextMessage.class);
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(textMessage)).willReturn(TEXT);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate);
 		// we DON'T want the default SimpleMessageConversion happening...
 		adapter.setMessageConverter(null);
 		adapter.onMessage(textMessage);
-
-		mockDelegate.verify();
-		mockTextMessage.verify();
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateWithDefaultDestination_SendsReturnTextMessageWhenSessionSupplied() throws Exception {
-		MockControl mockDestination = MockControl.createControl(Queue.class);
-		Queue destination = (Queue) mockDestination.getMock();
-		mockDestination.replay();
-
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		Queue destination = mock(Queue.class);
+		TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(
+				CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(null); // we want to fall back to the default...
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockQueueSender = MockControl.createControl(QueueSender.class);
-		QueueSender queueSender = (QueueSender) mockQueueSender.getMock();
-		queueSender.send(responseTextMessage);
-		mockQueueSender.setVoidCallable();
-		queueSender.close();
-		mockQueueSender.setVoidCallable();
-		mockQueueSender.replay();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		session.createProducer(destination);
-		mockSession.setReturnValue(queueSender);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(null); // we want to fall back to the default...
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+
+		QueueSender queueSender = mock(QueueSender.class);
+		Session session = mock(Session.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+		given(session.createProducer(destination)).willReturn(queueSender);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {
 			@Override
@@ -329,59 +244,30 @@ protected Object extractMessage(Message message) {
 		adapter.setDefaultResponseDestination(destination);
 		adapter.onMessage(sentTextMessage, session);
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
-		mockDestination.verify();
-		mockQueueSender.verify();
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(queueSender).send(responseTextMessage);
+		verify(queueSender).close();
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateNoDefaultDestination_SendsReturnTextMessageWhenSessionSupplied() throws Exception {
-		MockControl mockDestination = MockControl.createControl(Queue.class);
-		Queue destination = (Queue) mockDestination.getMock();
-		mockDestination.replay();
-
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		Queue destination = mock(Queue.class);
+		TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(null);
-		sentTextMessage.getJMSMessageID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(null);
+		given(sentTextMessage.getJMSMessageID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(destination);
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockMessageProducer = MockControl.createControl(MessageProducer.class);
-		MessageProducer messageProducer = (MessageProducer) mockMessageProducer.getMock();
-		messageProducer.send(responseTextMessage);
-		mockMessageProducer.setVoidCallable();
-		messageProducer.close();
-		mockMessageProducer.setVoidCallable();
-		mockMessageProducer.replay();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		session.createProducer(destination);
-		mockSession.setReturnValue(messageProducer);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(destination);
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+		MessageProducer messageProducer = mock(MessageProducer.class);
+		Session session = mock(Session.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+		given(session.createProducer(destination)).willReturn(messageProducer);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {
 			@Override
@@ -391,43 +277,26 @@ protected Object extractMessage(Message message) {
 		};
 		adapter.onMessage(sentTextMessage, session);
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
-		mockDestination.verify();
-		mockMessageProducer.verify();
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(messageProducer).send(responseTextMessage);
+		verify(messageProducer).close();
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateNoDefaultDestinationAndNoReplyToDestination_SendsReturnTextMessageWhenSessionSupplied() throws Exception {
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		final TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(null);
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		final QueueSession session = (QueueSession) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(null);
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+		final QueueSession session = mock(QueueSession.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {
 			@Override
@@ -440,56 +309,30 @@ protected Object extractMessage(Message message) {
 			fail("expected InvalidDestinationException");
 		} catch(InvalidDestinationException ex) { /* expected */ }
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateNoDefaultDestination_SendsReturnTextMessageWhenSessionSupplied_AndSendingThrowsJMSException() throws Exception {
-		MockControl mockDestination = MockControl.createControl(Queue.class);
-		Queue destination = (Queue) mockDestination.getMock();
-		mockDestination.replay();
+		Queue destination = mock(Queue.class);
 
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		final TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(destination);
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseTextMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseTextMessage = (TextMessage) mockResponseTextMessage.getMock();
-		responseTextMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseTextMessage.setVoidCallable();
-		mockResponseTextMessage.replay();
-
-		MockControl mockMessageProducer = MockControl.createControl(MessageProducer.class);
-		MessageProducer messageProducer = (MessageProducer) mockMessageProducer.getMock();
-		messageProducer.send(responseTextMessage);
-		mockMessageProducer.setThrowable(new JMSException("Dow!"));
-		// ensure that regardless of a JMSException the producer is closed...
-		messageProducer.close();
-		mockMessageProducer.setVoidCallable();
-		mockMessageProducer.replay();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		final QueueSession session = (QueueSession) mockSession.getMock();
-		session.createTextMessage(RESPONSE_TEXT);
-		mockSession.setReturnValue(responseTextMessage);
-		session.createProducer(destination);
-		mockSession.setReturnValue(messageProducer);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(destination);
+
+		TextMessage responseTextMessage = mock(TextMessage.class);
+		MessageProducer messageProducer = mock(MessageProducer.class);
+		willThrow(new JMSException("Doe!")).given(messageProducer).send(responseTextMessage);
+
+		final QueueSession session = mock(QueueSession.class);
+		given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage);
+		given(session.createProducer(destination)).willReturn(messageProducer);
+
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {
 			@Override
@@ -502,29 +345,18 @@ protected Object extractMessage(Message message) {
 			fail("expected JMSException");
 		} catch(JMSException ex) { /* expected */ }
 
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockResponseTextMessage.verify();
-		mockSession.verify();
-		mockDestination.verify();
-		mockMessageProducer.verify();
+		verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(messageProducer).close();
+		verify(delegate).handleMessage(sentTextMessage);
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateDoesNotSendReturnTextMessageWhenSessionSupplied_AndListenerMethodThrowsException() throws Exception {
-		MockControl mockMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage message = (TextMessage) mockMessage.getMock();
-		mockMessage.replay();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		final QueueSession session = (QueueSession) mockSession.getMock();
-		mockSession.replay();
+		final TextMessage message = mock(TextMessage.class);
+		final QueueSession session = mock(QueueSession.class);
 
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(message);
-		mockDelegate.setThrowable(new IllegalArgumentException("Dow!"));
-		mockDelegate.replay();
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		willThrow(new IllegalArgumentException("Doe!")).given(delegate).handleMessage(message);
 
 		final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {
 			@Override
@@ -536,20 +368,12 @@ protected Object extractMessage(Message message) {
 			adapter.onMessage(message, session);
 			fail("expected ListenerExecutionFailedException");
 		} catch(ListenerExecutionFailedException ex) { /* expected */ }
-
-		mockDelegate.verify();
-		mockMessage.verify();
-		mockSession.verify();
 	}
 
 	@Test
 	public void testFailsIfNoDefaultListenerMethodNameIsSupplied() throws Exception {
-		MockControl mockMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage message = (TextMessage) mockMessage.getMock();
-		message.getText();
-		mockMessage.setReturnValue(TEXT);
-
-		mockMessage.replay();
+		final TextMessage message = mock(TextMessage.class);
+		given(message.getText()).willReturn(TEXT);
 
 		final MessageListenerAdapter adapter = new MessageListenerAdapter() {
 			@Override
@@ -559,18 +383,12 @@ protected void handleListenerException(Throwable ex) {
 		};
 		adapter.setDefaultListenerMethod(null);
 		adapter.onMessage(message);
-
-		mockMessage.verify();
 	}
 
 	@Test
 	public void testFailsWhenOverriddenGetListenerMethodNameReturnsNull() throws Exception {
-		MockControl mockMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage message = (TextMessage) mockMessage.getMock();
-		message.getText();
-		mockMessage.setReturnValue(TEXT);
-
-		mockMessage.replay();
+		final TextMessage message = mock(TextMessage.class);
+		given(message.getText()).willReturn(TEXT);
 
 		final MessageListenerAdapter adapter = new MessageListenerAdapter() {
 			@Override
@@ -584,25 +402,14 @@ protected String getListenerMethodName(Message originalMessage, Object extracted
 		};
 		adapter.setDefaultListenerMethod(null);
 		adapter.onMessage(message);
-
-		mockMessage.verify();
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateWhenReturnTypeIsNotAJMSMessageAndNoMessageConverterIsSupplied() throws Exception {
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
-		mockSentTextMessage.replay();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		final Session session = (Session) mockSession.getMock();
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveMessageDelegate.class);
-		ResponsiveMessageDelegate delegate = (ResponsiveMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(RESPONSE_TEXT);
-		mockDelegate.replay();
+		final TextMessage sentTextMessage = mock(TextMessage.class);
+		final Session session = mock(Session.class);
+		ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT);
 
 		final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {
 			@Override
@@ -615,53 +422,25 @@ protected Object extractMessage(Message message) {
 			adapter.onMessage(sentTextMessage, session);
 			fail("expected MessageConversionException");
 		} catch(MessageConversionException ex) { /* expected */ }
-
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockSession.verify();
 	}
 
 	@Test
 	public void testWithResponsiveMessageDelegateWhenReturnTypeIsAJMSMessageAndNoMessageConverterIsSupplied() throws Exception {
-		MockControl mockDestination = MockControl.createControl(Queue.class);
-		Queue destination = (Queue) mockDestination.getMock();
-		mockDestination.replay();
-
-		MockControl mockSentTextMessage = MockControl.createControl(TextMessage.class);
-		final TextMessage sentTextMessage = (TextMessage) mockSentTextMessage.getMock();
+		Queue destination = mock(Queue.class);
+		final TextMessage sentTextMessage = mock(TextMessage.class);
 		// correlation ID is queried when response is being created...
-		sentTextMessage.getJMSCorrelationID();
-		mockSentTextMessage.setReturnValue(CORRELATION_ID);
+		given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID);
 		// Reply-To is queried when response is being created...
-		sentTextMessage.getJMSReplyTo();
-		mockSentTextMessage.setReturnValue(destination);
-		mockSentTextMessage.replay();
-
-		MockControl mockResponseMessage = MockControl.createControl(TextMessage.class);
-		TextMessage responseMessage = (TextMessage) mockResponseMessage.getMock();
-		responseMessage.setJMSCorrelationID(CORRELATION_ID);
-		mockResponseMessage.setVoidCallable();
-		mockResponseMessage.replay();
-
-		MockControl mockQueueSender = MockControl.createControl(QueueSender.class);
-		QueueSender queueSender = (QueueSender) mockQueueSender.getMock();
-		queueSender.send(responseMessage);
-		mockQueueSender.setVoidCallable();
-		queueSender.close();
-		mockQueueSender.setVoidCallable();
-		mockQueueSender.replay();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
-		session.createProducer(destination);
-		mockSession.setReturnValue(queueSender);
-		mockSession.replay();
-
-		MockControl mockDelegate = MockControl.createControl(ResponsiveJmsTextMessageReturningMessageDelegate.class);
-		ResponsiveJmsTextMessageReturningMessageDelegate delegate = (ResponsiveJmsTextMessageReturningMessageDelegate) mockDelegate.getMock();
-		delegate.handleMessage(sentTextMessage);
-		mockDelegate.setReturnValue(responseMessage);
-		mockDelegate.replay();
+		given(sentTextMessage.getJMSReplyTo()).willReturn(destination);
+
+		TextMessage responseMessage = mock(TextMessage.class);
+		QueueSender queueSender = mock(QueueSender.class);
+
+		Session session = mock(Session.class);
+		given(session.createProducer(destination)).willReturn(queueSender);
+
+		ResponsiveJmsTextMessageReturningMessageDelegate delegate = mock(ResponsiveJmsTextMessageReturningMessageDelegate.class);
+		given(delegate.handleMessage(sentTextMessage)).willReturn(responseMessage);
 
 		final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {
 			@Override
@@ -672,12 +451,9 @@ protected Object extractMessage(Message message) {
 		adapter.setMessageConverter(null);
 		adapter.onMessage(sentTextMessage, session);
 
-		mockDestination.verify();
-		mockDelegate.verify();
-		mockSentTextMessage.verify();
-		mockSession.verify();
-		mockQueueSender.verify();
-		mockResponseMessage.verify();
+		verify(responseMessage).setJMSCorrelationID(CORRELATION_ID);
+		verify(queueSender).send(responseMessage);
+		verify(queueSender).close();
 	}
 
 
diff --git a/spring-jms/src/test/java/org/springframework/jms/listener/endpoint/DefaultJmsActivationSpecFactoryTests.java b/spring-jms/src/test/java/org/springframework/jms/listener/endpoint/DefaultJmsActivationSpecFactoryTests.java
index 598c5ada2936..1a78ba5f7918 100644
--- a/spring-jms/src/test/java/org/springframework/jms/listener/endpoint/DefaultJmsActivationSpecFactoryTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/listener/endpoint/DefaultJmsActivationSpecFactoryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,12 +20,13 @@
 import javax.jms.Session;
 
 import junit.framework.TestCase;
-import org.easymock.MockControl;
 
 import org.springframework.jca.StubResourceAdapter;
 import org.springframework.jms.StubQueue;
 import org.springframework.jms.support.destination.DestinationResolver;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Agim Emruli
  * @author Juergen Hoeller
@@ -60,12 +61,10 @@ public void testActiveMQResourceAdapterSetup() {
 	public void testWebSphereResourceAdapterSetup() throws Exception {
 		Destination destination = new StubQueue();
 
-		MockControl control = MockControl.createControl(DestinationResolver.class);
-		DestinationResolver destinationResolver = (DestinationResolver) control.getMock();
+		DestinationResolver destinationResolver = mock(DestinationResolver.class);
 
-		destinationResolver.resolveDestinationName(null, "destinationname", false);
-		control.setReturnValue(destination);
-		control.replay();
+		given(destinationResolver.resolveDestinationName(null, "destinationname",
+				false)).willReturn(destination);
 
 		DefaultJmsActivationSpecFactory activationSpecFactory = new DefaultJmsActivationSpecFactory();
 		activationSpecFactory.setDestinationResolver(destinationResolver);
@@ -73,8 +72,6 @@ public void testWebSphereResourceAdapterSetup() throws Exception {
 		StubWebSphereActivationSpecImpl spec = (StubWebSphereActivationSpecImpl) activationSpecFactory
 				.createActivationSpec(new StubWebSphereResourceAdapterImpl(), activationSpecConfig);
 
-		control.verify();
-
 		assertEquals(destination, spec.getDestination());
 		assertEquals(5, spec.getMaxConcurrency());
 		assertEquals(3, spec.getMaxBatchSize());
@@ -89,6 +86,7 @@ private static class StubWebSphereResourceAdapterImpl extends StubResourceAdapte
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class StubActiveMQActivationSpec extends StubJmsActivationSpec {
 
 		private int maxSessions;
@@ -133,6 +131,7 @@ public void setUseRAManagedTransaction(boolean useRAManagedTransaction) {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class StubWebSphereActivationSpecImpl extends StubJmsActivationSpec {
 
 		private Destination destination;
diff --git a/spring-jms/src/test/java/org/springframework/jms/remoting/JmsInvokerTests.java b/spring-jms/src/test/java/org/springframework/jms/remoting/JmsInvokerTests.java
index 55736c4d2a9b..4913da3e9026 100644
--- a/spring-jms/src/test/java/org/springframework/jms/remoting/JmsInvokerTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/remoting/JmsInvokerTests.java
@@ -19,6 +19,7 @@
 import java.io.Serializable;
 import java.util.Arrays;
 import java.util.Enumeration;
+
 import javax.jms.Destination;
 import javax.jms.JMSException;
 import javax.jms.Message;
@@ -30,71 +31,50 @@
 import javax.jms.QueueSession;
 import javax.jms.Session;
 
-import junit.framework.TestCase;
-import org.easymock.MockControl;
-
-import org.springframework.tests.sample.beans.ITestBean;
-import org.springframework.tests.sample.beans.TestBean;
+import org.junit.Before;
+import org.junit.Test;
 import org.springframework.jms.support.converter.MessageConversionException;
 import org.springframework.jms.support.converter.SimpleMessageConverter;
+import org.springframework.tests.sample.beans.ITestBean;
+import org.springframework.tests.sample.beans.TestBean;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Juergen Hoeller
  */
-public class JmsInvokerTests extends TestCase {
+public class JmsInvokerTests {
 
-	private MockControl connectionFactoryControl;
 	private QueueConnectionFactory mockConnectionFactory;
 
-	private MockControl connectionControl;
 	private QueueConnection mockConnection;
 
-	private MockControl sessionControl;
 	private QueueSession mockSession;
 
-	private MockControl queueControl;
 	private Queue mockQueue;
 
 
-	@Override
-	protected void setUp() throws Exception {
-		connectionFactoryControl = MockControl.createControl(QueueConnectionFactory.class);
-		mockConnectionFactory = (QueueConnectionFactory) connectionFactoryControl.getMock();
-
-		connectionControl = MockControl.createControl(QueueConnection.class);
-		mockConnection = (QueueConnection) connectionControl.getMock();
+	@Before
+	public void setUpMocks() throws Exception {
+		mockConnectionFactory = mock(QueueConnectionFactory.class);
+		mockConnection = mock(QueueConnection.class);
+		mockSession = mock(QueueSession.class);
+		mockQueue = mock(Queue.class);
 
-		sessionControl = MockControl.createControl(QueueSession.class);
-		mockSession = (QueueSession) sessionControl.getMock();
-
-		queueControl = MockControl.createControl(Queue.class);
-		mockQueue = (Queue) queueControl.getMock();
-
-		mockConnectionFactory.createConnection();
-		connectionFactoryControl.setReturnValue(mockConnection, 8);
-
-		mockConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);
-		connectionControl.setReturnValue(mockSession, 8);
-
-		mockConnection.start();
-		connectionControl.setVoidCallable(8);
-
-		connectionFactoryControl.replay();
-		connectionControl.replay();
+		given(mockConnectionFactory.createConnection()).willReturn(mockConnection);
+		given(mockConnection.createSession(false, Session.AUTO_ACKNOWLEDGE)).willReturn(mockSession);
 	}
 
 
+	@Test
 	public void testJmsInvokerProxyFactoryBeanAndServiceExporter() throws Throwable {
-		sessionControl.replay();
-
 		doTestJmsInvokerProxyFactoryBeanAndServiceExporter(false);
 	}
 
+	@Test
 	public void testJmsInvokerProxyFactoryBeanAndServiceExporterWithDynamicQueue() throws Throwable {
-		mockSession.createQueue("myQueue");
-		sessionControl.setReturnValue(mockQueue, 8);
-		sessionControl.replay();
-
+		given(mockSession.createQueue("myQueue")).willReturn(mockQueue);
 		doTestJmsInvokerProxyFactoryBeanAndServiceExporter(true);
 	}
 
@@ -110,14 +90,10 @@ private void doTestJmsInvokerProxyFactoryBeanAndServiceExporter(boolean dynamicQ
 		JmsInvokerProxyFactoryBean pfb = new JmsInvokerProxyFactoryBean() {
 			@Override
 			protected Message doExecuteRequest(Session session, Queue queue, Message requestMessage) throws JMSException {
-				MockControl exporterSessionControl = MockControl.createControl(Session.class);
-				Session mockExporterSession = (Session) exporterSessionControl.getMock();
+				Session mockExporterSession = mock(Session.class);
 				ResponseStoringProducer mockProducer = new ResponseStoringProducer();
-				mockExporterSession.createProducer(requestMessage.getJMSReplyTo());
-				exporterSessionControl.setReturnValue(mockProducer);
-				exporterSessionControl.replay();
+				given(mockExporterSession.createProducer(requestMessage.getJMSReplyTo())).willReturn(mockProducer);
 				exporter.onMessage(requestMessage, mockExporterSession);
-				exporterSessionControl.verify();
 				assertTrue(mockProducer.closed);
 				return mockProducer.response;
 			}
@@ -156,10 +132,6 @@ protected Message doExecuteRequest(Session session, Queue queue, Message request
 		catch (IllegalAccessException ex) {
 			// expected
 		}
-
-		connectionFactoryControl.verify();
-		connectionControl.verify();
-		sessionControl.verify();
 	}
 
 
diff --git a/spring-jms/src/test/java/org/springframework/jms/support/SimpleMessageConverter102Tests.java b/spring-jms/src/test/java/org/springframework/jms/support/SimpleMessageConverter102Tests.java
index 7d4663a2859c..153cf0dd7a92 100644
--- a/spring-jms/src/test/java/org/springframework/jms/support/SimpleMessageConverter102Tests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/support/SimpleMessageConverter102Tests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,16 +16,22 @@
 
 package org.springframework.jms.support;
 
-import junit.framework.TestCase;
-import org.easymock.ArgumentsMatcher;
-import org.easymock.MockControl;
-import org.springframework.jms.support.converter.SimpleMessageConverter102;
+import java.io.ByteArrayInputStream;
+import java.util.Random;
 
 import javax.jms.BytesMessage;
 import javax.jms.JMSException;
 import javax.jms.Message;
 import javax.jms.Session;
-import java.util.Arrays;
+
+import org.junit.Test;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.springframework.jms.support.converter.SimpleMessageConverter102;
+
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * Unit tests for the {@link SimpleMessageConverter102} class.
@@ -33,46 +39,28 @@
  * @author Juergen Hoeller
  * @author Rick Evans
  */
-public final class SimpleMessageConverter102Tests extends TestCase {
+public final class SimpleMessageConverter102Tests {
 
+	@Test
 	public void testByteArrayConversion102() throws JMSException {
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		Session session = (Session) sessionControl.getMock();
-		MockControl messageControl = MockControl.createControl(BytesMessage.class);
-		BytesMessage message = (BytesMessage) messageControl.getMock();
+		Session session = mock(Session.class);
+		BytesMessage message = mock(BytesMessage.class);
 
 		byte[] content = new byte[5000];
+		new Random().nextBytes(content);
 
-		session.createBytesMessage();
-		sessionControl.setReturnValue(message, 1);
-		message.writeBytes(content);
-		messageControl.setVoidCallable(1);
-		message.readBytes(new byte[SimpleMessageConverter102.BUFFER_SIZE]);
-		messageControl.setMatcher(new ArgumentsMatcher() {
+		final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(content);
+		given(session.createBytesMessage()).willReturn(message);
+		given(message.readBytes((byte[]) anyObject())).willAnswer(new Answer<Integer>() {
 			@Override
-			public boolean matches(Object[] arg0, Object[] arg1) {
-				byte[] one = (byte[]) arg0[0];
-				byte[] two = (byte[]) arg1[0];
-				return Arrays.equals(one, two);
-			}
-
-			@Override
-			public String toString(Object[] arg0) {
-				return "bla";
+			public Integer answer(InvocationOnMock invocation) throws Throwable {
+				return byteArrayInputStream.read((byte[])invocation.getArguments()[0]);
 			}
 		});
-		messageControl.setReturnValue(SimpleMessageConverter102.BUFFER_SIZE, 1);
-		message.readBytes(new byte[SimpleMessageConverter102.BUFFER_SIZE]);
-		messageControl.setReturnValue(5000 - SimpleMessageConverter102.BUFFER_SIZE, 1);
-		sessionControl.replay();
-		messageControl.replay();
 
 		SimpleMessageConverter102 converter = new SimpleMessageConverter102();
 		Message msg = converter.toMessage(content, session);
-		assertEquals(content.length, ((byte[]) converter.fromMessage(msg)).length);
-
-		sessionControl.verify();
-		messageControl.verify();
+		assertThat((byte[])converter.fromMessage(msg), equalTo(content));
 	}
 
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/support/SimpleMessageConverterTests.java b/spring-jms/src/test/java/org/springframework/jms/support/SimpleMessageConverterTests.java
index 147987430b39..3ea917f017c0 100644
--- a/spring-jms/src/test/java/org/springframework/jms/support/SimpleMessageConverterTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/support/SimpleMessageConverterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,7 @@
 
 package org.springframework.jms.support;
 
-import static org.junit.Assert.*;
-
-import java.util.Arrays;
+import java.io.ByteArrayInputStream;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
@@ -31,12 +29,15 @@
 import javax.jms.Session;
 import javax.jms.TextMessage;
 
-import org.easymock.ArgumentsMatcher;
-import org.easymock.MockControl;
 import org.junit.Test;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.springframework.jms.support.converter.MessageConversionException;
 import org.springframework.jms.support.converter.SimpleMessageConverter;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for the {@link SimpleMessageConverter} class.
  *
@@ -48,127 +49,79 @@ public final class SimpleMessageConverterTests {
 
 	@Test
 	public void testStringConversion() throws JMSException {
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		Session session = (Session) sessionControl.getMock();
-		MockControl messageControl = MockControl.createControl(TextMessage.class);
-		TextMessage message = (TextMessage) messageControl.getMock();
+		Session session = mock(Session.class);
+		TextMessage message = mock(TextMessage.class);
 
 		String content = "test";
 
-		session.createTextMessage(content);
-		sessionControl.setReturnValue(message, 1);
-		message.getText();
-		messageControl.setReturnValue(content, 1);
-		sessionControl.replay();
-		messageControl.replay();
+		given(session.createTextMessage(content)).willReturn(message);
+		given(message.getText()).willReturn(content);
 
 		SimpleMessageConverter converter = new SimpleMessageConverter();
 		Message msg = converter.toMessage(content, session);
 		assertEquals(content, converter.fromMessage(msg));
-
-		sessionControl.verify();
-		messageControl.verify();
 	}
 
 	@Test
 	public void testByteArrayConversion() throws JMSException {
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		Session session = (Session) sessionControl.getMock();
-		MockControl messageControl = MockControl.createControl(BytesMessage.class);
-		BytesMessage message = (BytesMessage) messageControl.getMock();
+		Session session = mock(Session.class);
+		BytesMessage message = mock(BytesMessage.class);
 
 		byte[] content = "test".getBytes();
+		final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(content);
 
-		session.createBytesMessage();
-		sessionControl.setReturnValue(message, 1);
-		message.writeBytes(content);
-		messageControl.setVoidCallable(1);
-		message.getBodyLength();
-		messageControl.setReturnValue(content.length, 1);
-		message.readBytes(new byte[content.length]);
-		messageControl.setMatcher(new ArgumentsMatcher() {
+		given(session.createBytesMessage()).willReturn(message);
+		given(message.getBodyLength()).willReturn((long) content.length);
+		given(message.readBytes(any(byte[].class))).willAnswer(new Answer<Integer>() {
 			@Override
-			public boolean matches(Object[] arg0, Object[] arg1) {
-				byte[] one = (byte[]) arg0[0];
-				byte[] two = (byte[]) arg1[0];
-				return Arrays.equals(one, two);
-			}
-
-			@Override
-			public String toString(Object[] arg0) {
-				return "bla";
+			public Integer answer(InvocationOnMock invocation) throws Throwable {
+				return byteArrayInputStream.read((byte[]) invocation.getArguments()[0]);
 			}
 		});
-		messageControl.setReturnValue(content.length, 1);
-		sessionControl.replay();
-		messageControl.replay();
 
 		SimpleMessageConverter converter = new SimpleMessageConverter();
 		Message msg = converter.toMessage(content, session);
 		assertEquals(content.length, ((byte[]) converter.fromMessage(msg)).length);
 
-		sessionControl.verify();
-		messageControl.verify();
+		verify(message).writeBytes(content);
 	}
 
 	@Test
 	public void testMapConversion() throws JMSException {
 
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		Session session = (Session) sessionControl.getMock();
-		MockControl messageControl = MockControl.createControl(MapMessage.class);
-		MapMessage message = (MapMessage) messageControl.getMock();
+		Session session = mock(Session.class);
+		MapMessage message = mock(MapMessage.class);
 
 		Map content = new HashMap();
 		content.put("key1", "value1");
 		content.put("key2", "value2");
 
-		session.createMapMessage();
-		sessionControl.setReturnValue(message, 1);
-		message.setObject("key1", "value1");
-		messageControl.setVoidCallable(1);
-		message.setObject("key2", "value2");
-		messageControl.setVoidCallable(1);
-		message.getMapNames();
-		messageControl.setReturnValue(Collections.enumeration(content.keySet()));
-		message.getObject("key1");
-		messageControl.setReturnValue("value1", 1);
-		message.getObject("key2");
-		messageControl.setReturnValue("value2", 1);
-
-		sessionControl.replay();
-		messageControl.replay();
+		given(session.createMapMessage()).willReturn(message);
+		given(message.getMapNames()).willReturn(Collections.enumeration(content.keySet()));
+		given(message.getObject("key1")).willReturn("value1");
+		given(message.getObject("key2")).willReturn("value2");
 
 		SimpleMessageConverter converter = new SimpleMessageConverter();
 		Message msg = converter.toMessage(content, session);
 		assertEquals(content, converter.fromMessage(msg));
 
-		sessionControl.verify();
-		messageControl.verify();
+		verify(message).setObject("key1", "value1");
+		verify(message).setObject("key2", "value2");
 	}
 
 	@Test
 	public void testSerializableConversion() throws JMSException {
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		Session session = (Session) sessionControl.getMock();
-		MockControl messageControl = MockControl.createControl(ObjectMessage.class);
-		ObjectMessage message = (ObjectMessage) messageControl.getMock();
+		Session session = mock(Session.class);
+		ObjectMessage message = mock(ObjectMessage.class);
 
 		Integer content = new Integer(5);
 
-		session.createObjectMessage(content);
-		sessionControl.setReturnValue(message, 1);
-		message.getObject();
-		messageControl.setReturnValue(content, 1);
-		sessionControl.replay();
-		messageControl.replay();
+		given(session.createObjectMessage(content)).willReturn(message);
+		given(message.getObject()).willReturn(content);
 
 		SimpleMessageConverter converter = new SimpleMessageConverter();
 		Message msg = converter.toMessage(content, session);
 		assertEquals(content, converter.fromMessage(msg));
-
-		sessionControl.verify();
-		messageControl.verify();
 	}
 
 	@Test(expected=MessageConversionException.class)
@@ -184,50 +137,30 @@ public void testToMessageThrowsExceptionIfGivenIncompatibleObjectToConvert() thr
 	@Test
 	public void testToMessageSimplyReturnsMessageAsIsIfSuppliedWithMessage() throws JMSException {
 
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		Session session = (Session) sessionControl.getMock();
-
-		MockControl messageControl = MockControl.createControl(ObjectMessage.class);
-		ObjectMessage message = (ObjectMessage) messageControl.getMock();
-
-		sessionControl.replay();
-		messageControl.replay();
+		Session session = mock(Session.class);
+		ObjectMessage message = mock(ObjectMessage.class);
 
 		SimpleMessageConverter converter = new SimpleMessageConverter();
 		Message msg = converter.toMessage(message, session);
 		assertSame(message, msg);
-
-		sessionControl.verify();
-		messageControl.verify();
 	}
 
 	@Test
 	public void testFromMessageSimplyReturnsMessageAsIsIfSuppliedWithMessage() throws JMSException {
 
-		MockControl messageControl = MockControl.createControl(Message.class);
-		Message message = (Message) messageControl.getMock();
-
-		messageControl.replay();
+		Message message = mock(Message.class);
 
 		SimpleMessageConverter converter = new SimpleMessageConverter();
 		Object msg = converter.fromMessage(message);
 		assertSame(message, msg);
-
-		messageControl.verify();
 	}
 
 	@Test
 	public void testMapConversionWhereMapHasNonStringTypesForKeys() throws JMSException {
 
-		MockControl messageControl = MockControl.createControl(MapMessage.class);
-		MapMessage message = (MapMessage) messageControl.getMock();
-		messageControl.replay();
-
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		final Session session = (Session) sessionControl.getMock();
-		session.createMapMessage();
-		sessionControl.setReturnValue(message);
-		sessionControl.replay();
+		MapMessage message = mock(MapMessage.class);
+		final Session session = mock(Session.class);
+		given(session.createMapMessage()).willReturn(message);
 
 		final Map content = new HashMap();
 		content.put(new Integer(1), "value1");
@@ -237,22 +170,14 @@ public void testMapConversionWhereMapHasNonStringTypesForKeys() throws JMSExcept
 			converter.toMessage(content, session);
 			fail("expected MessageConversionException");
 		} catch (MessageConversionException ex) { /* expected */ }
-
-		sessionControl.verify();
 	}
 
 	@Test
 	public void testMapConversionWhereMapHasNNullForKey() throws JMSException {
 
-		MockControl messageControl = MockControl.createControl(MapMessage.class);
-		MapMessage message = (MapMessage) messageControl.getMock();
-		messageControl.replay();
-
-		MockControl sessionControl = MockControl.createControl(Session.class);
-		final Session session = (Session) sessionControl.getMock();
-		session.createMapMessage();
-		sessionControl.setReturnValue(message);
-		sessionControl.replay();
+		MapMessage message = mock(MapMessage.class);
+		final Session session = mock(Session.class);
+		given(session.createMapMessage()).willReturn(message);
 
 		final Map content = new HashMap();
 		content.put(null, "value1");
@@ -262,8 +187,6 @@ public void testMapConversionWhereMapHasNNullForKey() throws JMSException {
 			converter.toMessage(content, session);
 			fail("expected MessageConversionException");
 		} catch (MessageConversionException ex) { /* expected */ }
-
-		sessionControl.verify();
 	}
 
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/support/converter/MappingJackson2MessageConverterTests.java b/spring-jms/src/test/java/org/springframework/jms/support/converter/MappingJackson2MessageConverterTests.java
index 025ba22fc790..bbb59cde21ec 100644
--- a/spring-jms/src/test/java/org/springframework/jms/support/converter/MappingJackson2MessageConverterTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/support/converter/MappingJackson2MessageConverterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,21 +16,23 @@
 
 package org.springframework.jms.support.converter;
 
+import java.io.ByteArrayInputStream;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.Map;
+
 import javax.jms.BytesMessage;
 import javax.jms.Session;
 import javax.jms.TextMessage;
 
-import org.easymock.Capture;
-import org.easymock.EasyMock;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 
-import static org.easymock.EasyMock.*;
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Arjen Poutsma
@@ -44,7 +46,7 @@ public class MappingJackson2MessageConverterTests {
 
 	@Before
 	public void setUp() throws Exception {
-		sessionMock = createMock(Session.class);
+		sessionMock = mock(Session.class);
 		converter = new MappingJackson2MessageConverter();
 		converter.setEncodingPropertyName("__encoding__");
 		converter.setTypeIdPropertyName("__typeid__");
@@ -52,128 +54,94 @@ public void setUp() throws Exception {
 
 	@Test
 	public void toBytesMessage() throws Exception {
-		BytesMessage bytesMessageMock = createMock(BytesMessage.class);
+		BytesMessage bytesMessageMock = mock(BytesMessage.class);
 		Date toBeMarshalled = new Date();
 
-		expect(sessionMock.createBytesMessage()).andReturn(bytesMessageMock);
-		bytesMessageMock.setStringProperty("__encoding__", "UTF-8");
-		bytesMessageMock.setStringProperty("__typeid__", Date.class.getName());
-		bytesMessageMock.writeBytes(isA(byte[].class));
-
-		replay(sessionMock, bytesMessageMock);
+		given(sessionMock.createBytesMessage()).willReturn(bytesMessageMock);
 
 		converter.toMessage(toBeMarshalled, sessionMock);
 
-		verify(sessionMock, bytesMessageMock);
+		verify(bytesMessageMock).setStringProperty("__encoding__", "UTF-8");
+		verify(bytesMessageMock).setStringProperty("__typeid__", Date.class.getName());
+		verify(bytesMessageMock).writeBytes(isA(byte[].class));
 	}
 
 	@Test
 	public void fromBytesMessage() throws Exception {
-		BytesMessage bytesMessageMock = createMock(BytesMessage.class);
-		Map<String, String> unmarshalled = Collections.singletonMap("foo",
-				"bar");
-
-		final byte[] bytes = "{\"foo\":\"bar\"}".getBytes();
-		@SuppressWarnings("serial")
-		Capture<byte[]> captured = new Capture<byte[]>() {
-			@Override
-			public void setValue(byte[] value) {
-				super.setValue(value);
-				System.arraycopy(bytes, 0, value, 0, bytes.length);
-			}
-		};
-
-		expect(
-				bytesMessageMock.getStringProperty("__typeid__"))
-				.andReturn(Object.class.getName());
-		expect(
-				bytesMessageMock.propertyExists("__encoding__"))
-				.andReturn(false);
-		expect(bytesMessageMock.getBodyLength()).andReturn(
-				new Long(bytes.length));
-		expect(bytesMessageMock.readBytes(EasyMock.capture(captured)))
-				.andReturn(bytes.length);
-
-		replay(sessionMock, bytesMessageMock);
+		BytesMessage bytesMessageMock = mock(BytesMessage.class);
+		Map<String, String> unmarshalled = Collections.singletonMap("foo", "bar");
+
+		byte[] bytes = "{\"foo\":\"bar\"}".getBytes();
+		final ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);
+
+		given(bytesMessageMock.getStringProperty("__typeid__")).willReturn(
+				Object.class.getName());
+		given(bytesMessageMock.propertyExists("__encoding__")).willReturn(false);
+		given(bytesMessageMock.getBodyLength()).willReturn(new Long(bytes.length));
+		given(bytesMessageMock.readBytes(any(byte[].class))).willAnswer(
+				new Answer<Integer>() {
+					@Override
+					public Integer answer(InvocationOnMock invocation) throws Throwable {
+						return byteStream.read((byte[]) invocation.getArguments()[0]);
+					}
+				});
 
 		Object result = converter.fromMessage(bytesMessageMock);
 		assertEquals("Invalid result", result, unmarshalled);
-
-		verify(sessionMock, bytesMessageMock);
 	}
 
 	@Test
 	public void toTextMessageWithObject() throws Exception {
 		converter.setTargetType(MessageType.TEXT);
-		TextMessage textMessageMock = createMock(TextMessage.class);
+		TextMessage textMessageMock = mock(TextMessage.class);
 		Date toBeMarshalled = new Date();
 
-		textMessageMock.setStringProperty("__typeid__", Date.class.getName());
-		expect(sessionMock.createTextMessage(isA(String.class))).andReturn( textMessageMock);
-
-		replay(sessionMock, textMessageMock);
+		given(sessionMock.createTextMessage(isA(String.class))).willReturn(
+				textMessageMock);
 
 		converter.toMessage(toBeMarshalled, sessionMock);
-
-		verify(sessionMock, textMessageMock);
+		verify(textMessageMock).setStringProperty("__typeid__", Date.class.getName());
 	}
 
 	@Test
 	public void toTextMessageWithMap() throws Exception {
 		converter.setTargetType(MessageType.TEXT);
-		TextMessage textMessageMock = createMock(TextMessage.class);
+		TextMessage textMessageMock = mock(TextMessage.class);
 		Map<String, String> toBeMarshalled = new HashMap<String, String>();
 		toBeMarshalled.put("foo", "bar");
 
-		textMessageMock.setStringProperty("__typeid__", HashMap.class.getName());
-		expect(sessionMock.createTextMessage(isA(String.class))).andReturn(
+		given(sessionMock.createTextMessage(isA(String.class))).willReturn(
 				textMessageMock);
 
-		replay(sessionMock, textMessageMock);
-
 		converter.toMessage(toBeMarshalled, sessionMock);
-
-		verify(sessionMock, textMessageMock);
+		verify(textMessageMock).setStringProperty("__typeid__", HashMap.class.getName());
 	}
 
 	@Test
 	public void fromTextMessageAsObject() throws Exception {
-		TextMessage textMessageMock = createMock(TextMessage.class);
-		Map<String, String> unmarshalled = Collections.singletonMap("foo",
-				"bar");
+		TextMessage textMessageMock = mock(TextMessage.class);
+		Map<String, String> unmarshalled = Collections.singletonMap("foo", "bar");
 
 		String text = "{\"foo\":\"bar\"}";
-		expect(
-				textMessageMock.getStringProperty("__typeid__"))
-				.andReturn(Object.class.getName());
-		expect(textMessageMock.getText()).andReturn(text);
-
-		replay(sessionMock, textMessageMock);
+		given(textMessageMock.getStringProperty("__typeid__")).willReturn(
+				Object.class.getName());
+		given(textMessageMock.getText()).willReturn(text);
 
 		Object result = converter.fromMessage(textMessageMock);
 		assertEquals("Invalid result", result, unmarshalled);
-
-		verify(sessionMock, textMessageMock);
 	}
 
 	@Test
 	public void fromTextMessageAsMap() throws Exception {
-		TextMessage textMessageMock = createMock(TextMessage.class);
-		Map<String, String> unmarshalled = Collections.singletonMap("foo",
-				"bar");
+		TextMessage textMessageMock = mock(TextMessage.class);
+		Map<String, String> unmarshalled = Collections.singletonMap("foo", "bar");
 
 		String text = "{\"foo\":\"bar\"}";
-		expect(
-				textMessageMock.getStringProperty("__typeid__"))
-				.andReturn(HashMap.class.getName());
-		expect(textMessageMock.getText()).andReturn(text);
-
-		replay(sessionMock, textMessageMock);
+		given(textMessageMock.getStringProperty("__typeid__")).willReturn(
+				HashMap.class.getName());
+		given(textMessageMock.getText()).willReturn(text);
 
 		Object result = converter.fromMessage(textMessageMock);
 		assertEquals("Invalid result", result, unmarshalled);
-
-		verify(sessionMock, textMessageMock);
 	}
-
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/support/converter/MappingJacksonMessageConverterTests.java b/spring-jms/src/test/java/org/springframework/jms/support/converter/MappingJacksonMessageConverterTests.java
index 54ca352ea0d4..190d55cf5e7c 100644
--- a/spring-jms/src/test/java/org/springframework/jms/support/converter/MappingJacksonMessageConverterTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/support/converter/MappingJacksonMessageConverterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,20 +16,22 @@
 
 package org.springframework.jms.support.converter;
 
+import java.io.ByteArrayInputStream;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+
 import javax.jms.BytesMessage;
 import javax.jms.Session;
 import javax.jms.TextMessage;
 
-import org.easymock.Capture;
-import org.easymock.EasyMock;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 
-import static org.easymock.EasyMock.*;
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Arjen Poutsma
@@ -43,7 +45,7 @@ public class MappingJacksonMessageConverterTests {
 
 	@Before
 	public void setUp() throws Exception {
-		sessionMock = createMock(Session.class);
+		sessionMock = mock(Session.class);
 		converter = new MappingJacksonMessageConverter();
 		converter.setEncodingPropertyName("__encoding__");
 		converter.setTypeIdPropertyName("__typeid__");
@@ -51,128 +53,96 @@ public void setUp() throws Exception {
 
 	@Test
 	public void toBytesMessage() throws Exception {
-		BytesMessage bytesMessageMock = createMock(BytesMessage.class);
+		BytesMessage bytesMessageMock = mock(BytesMessage.class);
 		Object toBeMarshalled = new Object();
 
-		expect(sessionMock.createBytesMessage()).andReturn(bytesMessageMock);
-		bytesMessageMock.setStringProperty("__encoding__", "UTF-8");
-		bytesMessageMock.setStringProperty("__typeid__", Object.class.getName());
-		bytesMessageMock.writeBytes(isA(byte[].class));
-
-		replay(sessionMock, bytesMessageMock);
+		given(sessionMock.createBytesMessage()).willReturn(bytesMessageMock);
 
 		converter.toMessage(toBeMarshalled, sessionMock);
 
-		verify(sessionMock, bytesMessageMock);
+		verify(bytesMessageMock).setStringProperty("__encoding__", "UTF-8");
+		verify(bytesMessageMock).setStringProperty("__typeid__", Object.class.getName());
+		verify(bytesMessageMock).writeBytes(isA(byte[].class));
 	}
 
 	@Test
 	@SuppressWarnings("serial")
 	public void fromBytesMessage() throws Exception {
-		BytesMessage bytesMessageMock = createMock(BytesMessage.class);
-		Map<String, String> unmarshalled = Collections.singletonMap("foo",
-				"bar");
-
-		final byte[] bytes = "{\"foo\":\"bar\"}".getBytes();
-		Capture<byte[]> captured = new Capture<byte[]>() {
-			@Override
-			public void setValue(byte[] value) {
-				super.setValue(value);
-				System.arraycopy(bytes, 0, value, 0, bytes.length);
-			}
-		};
-
-		expect(
-				bytesMessageMock.getStringProperty("__typeid__"))
-				.andReturn(Object.class.getName());
-		expect(
-				bytesMessageMock.propertyExists("__encoding__"))
-				.andReturn(false);
-		expect(bytesMessageMock.getBodyLength()).andReturn(
-				new Long(bytes.length));
-		expect(bytesMessageMock.readBytes(EasyMock.capture(captured)))
-				.andReturn(bytes.length);
-
-		replay(sessionMock, bytesMessageMock);
+		BytesMessage bytesMessageMock = mock(BytesMessage.class);
+		Map<String, String> unmarshalled = Collections.singletonMap("foo", "bar");
+
+		byte[] bytes = "{\"foo\":\"bar\"}".getBytes();
+		final ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);
+
+		given(bytesMessageMock.getStringProperty("__typeid__")).willReturn(
+				Object.class.getName());
+		given(bytesMessageMock.propertyExists("__encoding__")).willReturn(false);
+		given(bytesMessageMock.getBodyLength()).willReturn(new Long(bytes.length));
+		given(bytesMessageMock.readBytes(any(byte[].class))).willAnswer(
+				new Answer<Integer>() {
+
+					@Override
+					public Integer answer(InvocationOnMock invocation) throws Throwable {
+						return byteStream.read((byte[]) invocation.getArguments()[0]);
+					}
+				});
 
 		Object result = converter.fromMessage(bytesMessageMock);
 		assertEquals("Invalid result", result, unmarshalled);
-
-		verify(sessionMock, bytesMessageMock);
 	}
 
 	@Test
 	public void toTextMessageWithObject() throws Exception {
 		converter.setTargetType(MessageType.TEXT);
-		TextMessage textMessageMock = createMock(TextMessage.class);
+		TextMessage textMessageMock = mock(TextMessage.class);
 		Object toBeMarshalled = new Object();
 
-		textMessageMock.setStringProperty("__typeid__", Object.class.getName());
-		expect(sessionMock.createTextMessage(isA(String.class))).andReturn( textMessageMock);
-
-		replay(sessionMock, textMessageMock);
+		given(sessionMock.createTextMessage(isA(String.class))).willReturn(
+				textMessageMock);
 
 		converter.toMessage(toBeMarshalled, sessionMock);
-
-		verify(sessionMock, textMessageMock);
+		verify(textMessageMock).setStringProperty("__typeid__", Object.class.getName());
 	}
 
 	@Test
 	public void toTextMessageWithMap() throws Exception {
 		converter.setTargetType(MessageType.TEXT);
-		TextMessage textMessageMock = createMock(TextMessage.class);
+		TextMessage textMessageMock = mock(TextMessage.class);
 		Map<String, String> toBeMarshalled = new HashMap<String, String>();
 		toBeMarshalled.put("foo", "bar");
-
-		textMessageMock.setStringProperty("__typeid__", HashMap.class.getName());
-		expect(sessionMock.createTextMessage(isA(String.class))).andReturn(
+		given(sessionMock.createTextMessage(isA(String.class))).willReturn(
 				textMessageMock);
 
-		replay(sessionMock, textMessageMock);
-
 		converter.toMessage(toBeMarshalled, sessionMock);
 
-		verify(sessionMock, textMessageMock);
+		verify(textMessageMock).setStringProperty("__typeid__", HashMap.class.getName());
 	}
 
 	@Test
 	public void fromTextMessageAsObject() throws Exception {
-		TextMessage textMessageMock = createMock(TextMessage.class);
-		Map<String, String> unmarshalled = Collections.singletonMap("foo",
-				"bar");
+		TextMessage textMessageMock = mock(TextMessage.class);
+		Map<String, String> unmarshalled = Collections.singletonMap("foo", "bar");
 
 		String text = "{\"foo\":\"bar\"}";
-		expect(
-				textMessageMock.getStringProperty("__typeid__"))
-				.andReturn(Object.class.getName());
-		expect(textMessageMock.getText()).andReturn(text);
-
-		replay(sessionMock, textMessageMock);
+		given(textMessageMock.getStringProperty("__typeid__")).willReturn(
+				Object.class.getName());
+		given(textMessageMock.getText()).willReturn(text);
 
 		Object result = converter.fromMessage(textMessageMock);
 		assertEquals("Invalid result", result, unmarshalled);
-
-		verify(sessionMock, textMessageMock);
 	}
 
 	@Test
 	public void fromTextMessageAsMap() throws Exception {
-		TextMessage textMessageMock = createMock(TextMessage.class);
-		Map<String, String> unmarshalled = Collections.singletonMap("foo",
-				"bar");
+		TextMessage textMessageMock = mock(TextMessage.class);
+		Map<String, String> unmarshalled = Collections.singletonMap("foo", "bar");
 
 		String text = "{\"foo\":\"bar\"}";
-		expect(
-				textMessageMock.getStringProperty("__typeid__"))
-				.andReturn(HashMap.class.getName());
-		expect(textMessageMock.getText()).andReturn(text);
-
-		replay(sessionMock, textMessageMock);
+		given(textMessageMock.getStringProperty("__typeid__")).willReturn(
+				HashMap.class.getName());
+		given(textMessageMock.getText()).willReturn(text);
 
 		Object result = converter.fromMessage(textMessageMock);
 		assertEquals("Invalid result", result, unmarshalled);
-
-		verify(sessionMock, textMessageMock);
 	}
-
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/support/converter/MarshallingMessageConverterTests.java b/spring-jms/src/test/java/org/springframework/jms/support/converter/MarshallingMessageConverterTests.java
index 861179583d7b..65ed03ab2b25 100644
--- a/spring-jms/src/test/java/org/springframework/jms/support/converter/MarshallingMessageConverterTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/support/converter/MarshallingMessageConverterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2009 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,14 +22,14 @@
 import javax.xml.transform.Result;
 import javax.xml.transform.Source;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.oxm.Marshaller;
 import org.springframework.oxm.Unmarshaller;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Arjen Poutsma
  */
@@ -45,76 +45,60 @@ public class MarshallingMessageConverterTests {
 
 	@Before
 	public void setUp() throws Exception {
-		marshallerMock = createMock(Marshaller.class);
-		unmarshallerMock = createMock(Unmarshaller.class);
-		sessionMock = createMock(Session.class);
+		marshallerMock = mock(Marshaller.class);
+		unmarshallerMock = mock(Unmarshaller.class);
+		sessionMock = mock(Session.class);
 		converter = new MarshallingMessageConverter(marshallerMock, unmarshallerMock);
 	}
 
 	@Test
 	public void toBytesMessage() throws Exception {
-		BytesMessage bytesMessageMock = createMock(BytesMessage.class);
+		BytesMessage bytesMessageMock = mock(BytesMessage.class);
 		Object toBeMarshalled = new Object();
-
-		expect(sessionMock.createBytesMessage()).andReturn(bytesMessageMock);
-		marshallerMock.marshal(eq(toBeMarshalled), isA(Result.class));
-		bytesMessageMock.writeBytes(isA(byte[].class));
-
-		replay(marshallerMock, unmarshallerMock, sessionMock, bytesMessageMock);
+		given(sessionMock.createBytesMessage()).willReturn(bytesMessageMock);
 
 		converter.toMessage(toBeMarshalled, sessionMock);
 
-		verify(marshallerMock, unmarshallerMock, sessionMock, bytesMessageMock);
+		verify(marshallerMock).marshal(eq(toBeMarshalled), isA(Result.class));
+		verify(bytesMessageMock).writeBytes(isA(byte[].class));
 	}
 
 	@Test
 	public void fromBytesMessage() throws Exception {
-		BytesMessage bytesMessageMock = createMock(BytesMessage.class);
+		BytesMessage bytesMessageMock = mock(BytesMessage.class);
 		Object unmarshalled = new Object();
 
-		expect(bytesMessageMock.getBodyLength()).andReturn(10L);
-		expect(bytesMessageMock.readBytes(isA(byte[].class))).andReturn(0);
-		expect(unmarshallerMock.unmarshal(isA(Source.class))).andReturn(unmarshalled);
-
-		replay(marshallerMock, unmarshallerMock, sessionMock, bytesMessageMock);
+		given(bytesMessageMock.getBodyLength()).willReturn(10L);
+		given(bytesMessageMock.readBytes(isA(byte[].class))).willReturn(0);
+		given(unmarshallerMock.unmarshal(isA(Source.class))).willReturn(unmarshalled);
 
 		Object result = converter.fromMessage(bytesMessageMock);
 		assertEquals("Invalid result", result, unmarshalled);
-
-		verify(marshallerMock, unmarshallerMock, sessionMock, bytesMessageMock);
 	}
 
 	@Test
 	public void toTextMessage() throws Exception {
 		converter.setTargetType(MessageType.TEXT);
-		TextMessage textMessageMock = createMock(TextMessage.class);
+		TextMessage textMessageMock = mock(TextMessage.class);
 		Object toBeMarshalled = new Object();
 
-		expect(sessionMock.createTextMessage(isA(String.class))).andReturn(textMessageMock);
-		marshallerMock.marshal(eq(toBeMarshalled), isA(Result.class));
-
-		replay(marshallerMock, unmarshallerMock, sessionMock, textMessageMock);
+		given(sessionMock.createTextMessage(isA(String.class))).willReturn(textMessageMock);
 
 		converter.toMessage(toBeMarshalled, sessionMock);
 
-		verify(marshallerMock, unmarshallerMock, sessionMock, textMessageMock);
+		verify(marshallerMock).marshal(eq(toBeMarshalled), isA(Result.class));
 	}
 
 	@Test
 	public void fromTextMessage() throws Exception {
-		TextMessage textMessageMock = createMock(TextMessage.class);
+		TextMessage textMessageMock = mock(TextMessage.class);
 		Object unmarshalled = new Object();
 
 		String text = "foo";
-		expect(textMessageMock.getText()).andReturn(text);
-		expect(unmarshallerMock.unmarshal(isA(Source.class))).andReturn(unmarshalled);
-
-		replay(marshallerMock, unmarshallerMock, sessionMock, textMessageMock);
+		given(textMessageMock.getText()).willReturn(text);
+		given(unmarshallerMock.unmarshal(isA(Source.class))).willReturn(unmarshalled);
 
 		Object result = converter.fromMessage(textMessageMock);
 		assertEquals("Invalid result", result, unmarshalled);
-
-		verify(marshallerMock, unmarshallerMock, sessionMock, textMessageMock);
 	}
-
 }
diff --git a/spring-jms/src/test/java/org/springframework/jms/support/destination/DynamicDestinationResolverTests.java b/spring-jms/src/test/java/org/springframework/jms/support/destination/DynamicDestinationResolverTests.java
index e968d8cf28b9..aba6c9dee78f 100644
--- a/spring-jms/src/test/java/org/springframework/jms/support/destination/DynamicDestinationResolverTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/support/destination/DynamicDestinationResolverTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2008 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,11 +25,12 @@
 import javax.jms.TopicSession;
 
 import junit.framework.TestCase;
-import org.easymock.MockControl;
 
 import org.springframework.jms.StubQueue;
 import org.springframework.jms.StubTopic;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  */
@@ -39,63 +40,31 @@ public class DynamicDestinationResolverTests extends TestCase {
 
 
 	public void testResolveWithPubSubTopicSession() throws Exception {
-
 		Topic expectedDestination = new StubTopic();
-
-		MockControl mockSession = MockControl.createControl(TopicSession.class);
-		TopicSession session = (TopicSession) mockSession.getMock();
-		session.createTopic(DESTINATION_NAME);
-		mockSession.setReturnValue(expectedDestination);
-		mockSession.replay();
-
+		TopicSession session = mock(TopicSession.class);
+		given(session.createTopic(DESTINATION_NAME)).willReturn(expectedDestination);
 		testResolveDestination(session, expectedDestination, true);
-
-		mockSession.verify();
 	}
 
 	public void testResolveWithPubSubVanillaSession() throws Exception {
-
 		Topic expectedDestination = new StubTopic();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
-		session.createTopic(DESTINATION_NAME);
-		mockSession.setReturnValue(expectedDestination);
-		mockSession.replay();
-
+		Session session = mock(Session.class);
+		given(session.createTopic(DESTINATION_NAME)).willReturn(expectedDestination);
 		testResolveDestination(session, expectedDestination, true);
-
-		mockSession.verify();
 	}
 
 	public void testResolveWithPointToPointQueueSession() throws Exception {
-
 		Queue expectedDestination = new StubQueue();
-
-		MockControl mockSession = MockControl.createControl(QueueSession.class);
-		Session session = (Session) mockSession.getMock();
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(expectedDestination);
-		mockSession.replay();
-
+		Session session = mock(QueueSession.class);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(expectedDestination);
 		testResolveDestination(session, expectedDestination, false);
-
-		mockSession.verify();
 	}
 
 	public void testResolveWithPointToPointVanillaSession() throws Exception {
-
 		Queue expectedDestination = new StubQueue();
-
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
-		session.createQueue(DESTINATION_NAME);
-		mockSession.setReturnValue(expectedDestination);
-		mockSession.replay();
-
+		Session session = mock(Session.class);
+		given(session.createQueue(DESTINATION_NAME)).willReturn(expectedDestination);
 		testResolveDestination(session, expectedDestination, false);
-
-		mockSession.verify();
 	}
 
 	private static void testResolveDestination(Session session, Destination expectedDestination, boolean isPubSub) throws JMSException {
diff --git a/spring-jms/src/test/java/org/springframework/jms/support/destination/JmsDestinationAccessorTests.java b/spring-jms/src/test/java/org/springframework/jms/support/destination/JmsDestinationAccessorTests.java
index 133602bcbd86..dd44cf3994be 100644
--- a/spring-jms/src/test/java/org/springframework/jms/support/destination/JmsDestinationAccessorTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/support/destination/JmsDestinationAccessorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2008 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,13 +16,13 @@
 
 package org.springframework.jms.support.destination;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
-
 import javax.jms.ConnectionFactory;
 
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Chris Beams
@@ -31,8 +31,7 @@ public class JmsDestinationAccessorTests {
 
 	@Test
 	public void testChokesIfDestinationResolverIsetToNullExplcitly() throws Exception {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		replay(connectionFactory);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
 
 		try {
 			JmsDestinationAccessor accessor = new StubJmsDestinationAccessor();
@@ -40,9 +39,11 @@ public void testChokesIfDestinationResolverIsetToNullExplcitly() throws Exceptio
 			accessor.setDestinationResolver(null);
 			accessor.afterPropertiesSet();
 			fail("expected IllegalArgumentException");
-		} catch (IllegalArgumentException ex) { /* expected */ }
+		}
+		catch (IllegalArgumentException ex) {
+			// expected
+		}
 
-		verify(connectionFactory);
 	}
 
 	@Test
diff --git a/spring-jms/src/test/java/org/springframework/jms/support/destination/JndiDestinationResolverTests.java b/spring-jms/src/test/java/org/springframework/jms/support/destination/JndiDestinationResolverTests.java
index 9cdf36ef45dd..9d54247d86a5 100644
--- a/spring-jms/src/test/java/org/springframework/jms/support/destination/JndiDestinationResolverTests.java
+++ b/spring-jms/src/test/java/org/springframework/jms/support/destination/JndiDestinationResolverTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,16 +16,16 @@
 
 package org.springframework.jms.support.destination;
 
-import static org.junit.Assert.*;
-
 import javax.jms.Destination;
 import javax.jms.Session;
 import javax.naming.NamingException;
 
-import org.easymock.MockControl;
 import org.junit.Test;
 import org.springframework.jms.StubTopic;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Chris Beams
@@ -40,24 +40,18 @@ public class JndiDestinationResolverTests {
 	@Test
 	public void testHitsCacheSecondTimeThrough() throws Exception {
 
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
-		mockSession.replay();
+		Session session = mock(Session.class);
 
 		JndiDestinationResolver resolver = new OneTimeLookupJndiDestinationResolver();
 		Destination destination = resolver.resolveDestinationName(session, DESTINATION_NAME, true);
 		assertNotNull(destination);
 		assertSame(DESTINATION, destination);
-
-		mockSession.verify();
 	}
 
 	@Test
 	public void testDoesNotUseCacheIfCachingIsTurnedOff() throws Exception {
 
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
-		mockSession.replay();
+		Session session = mock(Session.class);
 
 		CountingCannedJndiDestinationResolver resolver
 				= new CountingCannedJndiDestinationResolver();
@@ -71,21 +65,15 @@ public void testDoesNotUseCacheIfCachingIsTurnedOff() throws Exception {
 		assertNotNull(destination);
 		assertSame(DESTINATION, destination);
 		assertEquals(2, resolver.getCallCount());
-
-		mockSession.verify();
 	}
 
 	@Test
 	public void testDelegatesToFallbackIfNotResolvedInJndi() throws Exception {
-		MockControl mockSession = MockControl.createControl(Session.class);
-		Session session = (Session) mockSession.getMock();
-		mockSession.replay();
+		Session session = mock(Session.class);
 
-		MockControl mockDestinationResolver = MockControl.createControl(DestinationResolver.class);
-		DestinationResolver dynamicResolver = (DestinationResolver) mockDestinationResolver.getMock();
-		dynamicResolver.resolveDestinationName(session, DESTINATION_NAME, true);
-		mockDestinationResolver.setReturnValue(DESTINATION);
-		mockDestinationResolver.replay();
+		DestinationResolver dynamicResolver = mock(DestinationResolver.class);
+		given(dynamicResolver.resolveDestinationName(session, DESTINATION_NAME,
+				true)).willReturn(DESTINATION);
 
 		JndiDestinationResolver resolver = new JndiDestinationResolver() {
 			@Override
@@ -99,20 +87,12 @@ protected Object lookup(String jndiName, Class requiredClass) throws NamingExcep
 
 		assertNotNull(destination);
 		assertSame(DESTINATION, destination);
-
-		mockSession.verify();
-		mockDestinationResolver.verify();
 	}
 
 	@Test
 	public void testDoesNotDelegateToFallbackIfNotResolvedInJndi() throws Exception {
-		MockControl mockSession = MockControl.createControl(Session.class);
-		final Session session = (Session) mockSession.getMock();
-		mockSession.replay();
-
-		MockControl mockDestinationResolver = MockControl.createControl(DestinationResolver.class);
-		DestinationResolver dynamicResolver = (DestinationResolver) mockDestinationResolver.getMock();
-		mockDestinationResolver.replay();
+		final Session session = mock(Session.class);
+		DestinationResolver dynamicResolver = mock(DestinationResolver.class);
 
 		final JndiDestinationResolver resolver = new JndiDestinationResolver() {
 			@Override
@@ -125,10 +105,10 @@ protected Object lookup(String jndiName, Class requiredClass) throws NamingExcep
 		try {
 			resolver.resolveDestinationName(session, DESTINATION_NAME, true);
 			fail("expected DestinationResolutionException");
-		} catch (DestinationResolutionException ex) { /* expected */ }
-
-		mockSession.verify();
-		mockDestinationResolver.verify();
+		}
+		catch (DestinationResolutionException ex) {
+			// expected
+		}
 	}
 
 
diff --git a/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/HibernateTransactionManager.java b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/HibernateTransactionManager.java
index ddde103c1d43..5871bb8a87e9 100644
--- a/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/HibernateTransactionManager.java
+++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/HibernateTransactionManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,12 +22,16 @@
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
+import org.hibernate.Interceptor;
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.Transaction;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 
+import org.springframework.beans.BeansException;
+import org.springframework.beans.factory.BeanFactory;
+import org.springframework.beans.factory.BeanFactoryAware;
 import org.springframework.beans.factory.InitializingBean;
 import org.springframework.dao.DataAccessException;
 import org.springframework.dao.DataAccessResourceFailureException;
@@ -100,7 +104,7 @@
  */
 @SuppressWarnings("serial")
 public class HibernateTransactionManager extends AbstractPlatformTransactionManager
-		implements ResourceTransactionManager, InitializingBean {
+		implements ResourceTransactionManager, BeanFactoryAware, InitializingBean {
 
 	private SessionFactory sessionFactory;
 
@@ -112,6 +116,14 @@ public class HibernateTransactionManager extends AbstractPlatformTransactionMana
 
 	private boolean hibernateManagedSession = false;
 
+	private Object entityInterceptor;
+
+	/**
+	 * Just needed for entityInterceptorBeanName.
+	 * @see #setEntityInterceptorBeanName
+	 */
+	private BeanFactory beanFactory;
+
 
 	/**
 	 * Create a new HibernateTransactionManager instance.
@@ -150,8 +162,8 @@ public SessionFactory getSessionFactory() {
 	 * The DataSource should match the one used by the Hibernate SessionFactory:
 	 * for example, you could specify the same JNDI DataSource for both.
 	 * <p>If the SessionFactory was configured with LocalDataSourceConnectionProvider,
-	 * i.e. by Spring's SessionFactoryBuilder with a specified "dataSource",
-	 * the DataSource will be auto-detected: You can still explictly specify the
+	 * i.e. by Spring's LocalSessionFactoryBean with a specified "dataSource",
+	 * the DataSource will be auto-detected: You can still explicitly specify the
 	 * DataSource, but you don't need to in this case.
 	 * <p>A transactional JDBC Connection for this DataSource will be provided to
 	 * application code accessing this DataSource directly via DataSourceUtils
@@ -188,7 +200,7 @@ public DataSource getDataSource() {
 
 	/**
 	 * Set whether to autodetect a JDBC DataSource used by the Hibernate SessionFactory,
-	 * if set via SessionFactoryBuilder's {@code setDataSource}. Default is "true".
+	 * if set via LocalSessionFactoryBean's {@code setDataSource}. Default is "true".
 	 * <p>Can be turned off to deliberately ignore an available DataSource, in order
 	 * to not expose Hibernate transactions as JDBC transactions for that DataSource.
 	 * @see #setDataSource
@@ -229,7 +241,7 @@ public void setPrepareConnection(boolean prepareConnection) {
 	 * to always return a proper Session when called for a Spring-managed transaction;
 	 * transaction begin will fail if the {@code getCurrentSession()} call fails.
 	 * <p>This mode will typically be used in combination with a custom Hibernate
-	 * {@link org.hibernate.context.CurrentSessionContext} implementation that stores
+	 * {@link org.hibernate.context.spi.CurrentSessionContext} implementation that stores
 	 * Sessions in a place other than Spring's TransactionSynchronizationManager.
 	 * It may also be used in combination with Spring's Open-Session-in-View support
 	 * (using Spring's default {@link SpringSessionContext}), in which case it subtly
@@ -242,10 +254,81 @@ public void setHibernateManagedSession(boolean hibernateManagedSession) {
 		this.hibernateManagedSession = hibernateManagedSession;
 	}
 
+	/**
+	 * Set the bean name of a Hibernate entity interceptor that allows to inspect
+	 * and change property values before writing to and reading from the database.
+	 * Will get applied to any new Session created by this transaction manager.
+	 * <p>Requires the bean factory to be known, to be able to resolve the bean
+	 * name to an interceptor instance on session creation. Typically used for
+	 * prototype interceptors, i.e. a new interceptor instance per session.
+	 * <p>Can also be used for shared interceptor instances, but it is recommended
+	 * to set the interceptor reference directly in such a scenario.
+	 * @param entityInterceptorBeanName the name of the entity interceptor in
+	 * the bean factory
+	 * @see #setBeanFactory
+	 * @see #setEntityInterceptor
+	 */
+	public void setEntityInterceptorBeanName(String entityInterceptorBeanName) {
+		this.entityInterceptor = entityInterceptorBeanName;
+	}
+
+	/**
+	 * Set a Hibernate entity interceptor that allows to inspect and change
+	 * property values before writing to and reading from the database.
+	 * Will get applied to any new Session created by this transaction manager.
+	 * <p>Such an interceptor can either be set at the SessionFactory level,
+	 * i.e. on LocalSessionFactoryBean, or at the Session level, i.e. on
+	 * HibernateTemplate, HibernateInterceptor, and HibernateTransactionManager.
+	 * It's preferable to set it on LocalSessionFactoryBean or HibernateTransactionManager
+	 * to avoid repeated configuration and guarantee consistent behavior in transactions.
+	 * @see LocalSessionFactoryBean#setEntityInterceptor
+	 */
+	public void setEntityInterceptor(Interceptor entityInterceptor) {
+		this.entityInterceptor = entityInterceptor;
+	}
+
+	/**
+	 * Return the current Hibernate entity interceptor, or {@code null} if none.
+	 * Resolves an entity interceptor bean name via the bean factory,
+	 * if necessary.
+	 * @throws IllegalStateException if bean name specified but no bean factory set
+	 * @throws BeansException if bean name resolution via the bean factory failed
+	 * @see #setEntityInterceptor
+	 * @see #setEntityInterceptorBeanName
+	 * @see #setBeanFactory
+	 */
+	public Interceptor getEntityInterceptor() throws IllegalStateException, BeansException {
+		if (this.entityInterceptor instanceof Interceptor) {
+			return (Interceptor) entityInterceptor;
+		}
+		else if (this.entityInterceptor instanceof String) {
+			if (this.beanFactory == null) {
+				throw new IllegalStateException("Cannot get entity interceptor via bean name if no bean factory set");
+			}
+			String beanName = (String) this.entityInterceptor;
+			return this.beanFactory.getBean(beanName, Interceptor.class);
+		}
+		else {
+			return null;
+		}
+	}
+
+	/**
+	 * The bean factory just needs to be known for resolving entity interceptor
+	 * bean names. It does not need to be set for any other mode of operation.
+	 * @see #setEntityInterceptorBeanName
+	 */
+	public void setBeanFactory(BeanFactory beanFactory) {
+		this.beanFactory = beanFactory;
+	}
+
 	public void afterPropertiesSet() {
 		if (getSessionFactory() == null) {
 			throw new IllegalArgumentException("Property 'sessionFactory' is required");
 		}
+		if (this.entityInterceptor instanceof String && this.beanFactory == null) {
+			throw new IllegalArgumentException("Property 'beanFactory' is required for 'entityInterceptorBeanName'");
+		}
 
 		// Check for SessionFactory's DataSource.
 		if (this.autodetectDataSource && getDataSource() == null) {
@@ -325,7 +408,10 @@ protected void doBegin(Object transaction, TransactionDefinition definition) {
 
 		try {
 			if (txObject.getSessionHolder() == null || txObject.getSessionHolder().isSynchronizedWithTransaction()) {
-				Session newSession = getSessionFactory().openSession();
+				Interceptor entityInterceptor = getEntityInterceptor();
+				Session newSession = (entityInterceptor != null ?
+						getSessionFactory().withOptions().interceptor(entityInterceptor).openSession() :
+						getSessionFactory().openSession());
 				if (logger.isDebugEnabled()) {
 					logger.debug("Opened new Session [" + newSession + "] for Hibernate transaction");
 				}
@@ -358,7 +444,7 @@ protected void doBegin(Object transaction, TransactionDefinition definition) {
 			}
 
 			if (definition.isReadOnly() && txObject.isNewSession()) {
-				// Just set to NEVER in case of a new Session for this transaction.
+				// Just set to MANUAL in case of a new Session for this transaction.
 				session.setFlushMode(FlushMode.MANUAL);
 			}
 
@@ -586,7 +672,7 @@ protected boolean isSameConnectionForEntireSession(Session session) {
 	 * from the {@code org.springframework.dao} hierarchy.
 	 * <p>Will automatically apply a specified SQLExceptionTranslator to a
 	 * Hibernate JDBCException, else rely on Hibernate's default translation.
-	 * @param ex HibernateException that occured
+	 * @param ex HibernateException that occurred
 	 * @return a corresponding DataAccessException
 	 * @see SessionFactoryUtils#convertHibernateAccessException
 	 */
diff --git a/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBean.java b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBean.java
index dea7f1a13939..f28141500875 100644
--- a/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBean.java
+++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -58,6 +58,7 @@
  * @since 3.1
  * @see #setDataSource
  * @see #setPackagesToScan
+ * @see LocalSessionFactoryBuilder
  */
 public class LocalSessionFactoryBean extends HibernateExceptionTranslator
 		implements FactoryBean<SessionFactory>, ResourceLoaderAware, InitializingBean, DisposableBean {
diff --git a/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBuilder.java b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBuilder.java
index e125abf2b71b..b0aac2d2bbe6 100644
--- a/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBuilder.java
+++ b/spring-orm-hibernate4/src/main/java/org/springframework/orm/hibernate4/LocalSessionFactoryBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -68,6 +68,8 @@ public class LocalSessionFactoryBuilder extends Configuration {
 
 	private static final String RESOURCE_PATTERN = "/**/*.class";
 
+	private static final String PACKAGE_INFO_SUFFIX = ".package-info";
+
 	private static final TypeFilter[] ENTITY_TYPE_FILTERS = new TypeFilter[] {
 			new AnnotationTypeFilter(Entity.class, false),
 			new AnnotationTypeFilter(Embeddable.class, false),
@@ -194,8 +196,11 @@ public LocalSessionFactoryBuilder scanPackages(String... packagesToScan) throws
 					if (resource.isReadable()) {
 						MetadataReader reader = readerFactory.getMetadataReader(resource);
 						String className = reader.getClassMetadata().getClassName();
-						if (matchesFilter(reader, readerFactory)) {
-							addAnnotatedClasses(this.resourcePatternResolver.getClassLoader().loadClass(className));
+						if (matchesEntityTypeFilter(reader, readerFactory)) {
+							addAnnotatedClass(this.resourcePatternResolver.getClassLoader().loadClass(className));
+						}
+						else if (className.endsWith(PACKAGE_INFO_SUFFIX)) {
+							addPackage(className.substring(0, className.length() - PACKAGE_INFO_SUFFIX.length()));
 						}
 					}
 				}
@@ -214,7 +219,7 @@ public LocalSessionFactoryBuilder scanPackages(String... packagesToScan) throws
 	 * Check whether any of the configured entity type filters matches
 	 * the current class descriptor contained in the metadata reader.
 	 */
-	private boolean matchesFilter(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {
+	private boolean matchesEntityTypeFilter(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {
 		for (TypeFilter filter : ENTITY_TYPE_FILTERS) {
 			if (filter.match(reader, readerFactory)) {
 				return true;
diff --git a/spring-orm-hibernate4/src/test/java/org/springframework/orm/hibernate4/HibernateTransactionManagerTests.java b/spring-orm-hibernate4/src/test/java/org/springframework/orm/hibernate4/HibernateTransactionManagerTests.java
index 26bdd97e2922..f235fc196e0d 100644
--- a/spring-orm-hibernate4/src/test/java/org/springframework/orm/hibernate4/HibernateTransactionManagerTests.java
+++ b/spring-orm-hibernate4/src/test/java/org/springframework/orm/hibernate4/HibernateTransactionManagerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,17 +25,21 @@
 import java.util.Properties;
 import javax.sql.DataSource;
 
-import junit.framework.TestCase;
-import org.easymock.MockControl;
 import org.hibernate.FlushMode;
+import org.hibernate.Interceptor;
 import org.hibernate.Query;
 import org.hibernate.Session;
+import org.hibernate.SessionBuilder;
 import org.hibernate.SessionFactory;
 import org.hibernate.Transaction;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.exception.ConstraintViolationException;
+import org.junit.After;
+import org.junit.Test;
+import org.mockito.InOrder;
 
+import org.springframework.beans.factory.BeanFactory;
 import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.jdbc.datasource.ConnectionHolder;
 import org.springframework.jdbc.datasource.DriverManagerDataSource;
@@ -50,63 +54,42 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 3.2
  */
-public class HibernateTransactionManagerTests extends TestCase {
+public class HibernateTransactionManagerTests {
+
+	@After
+	public void tearDown() {
+		assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty());
+		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
+		assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly());
+		assertFalse(TransactionSynchronizationManager.isActualTransactionActive());
+	}
 
+	@Test
 	public void testTransactionCommit() throws Exception {
-		MockControl dsControl = MockControl.createControl(DataSource.class);
-		final DataSource ds = (DataSource) dsControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-		MockControl queryControl = MockControl.createControl(Query.class);
-		Query query = (Query) queryControl.getMock();
+		final DataSource ds = mock(DataSource.class);
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		final ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+		Query query = mock(Query.class);
 
 		final List list = new ArrayList();
 		list.add("test");
-		con.getTransactionIsolation();
-		conControl.setReturnValue(Connection.TRANSACTION_READ_COMMITTED);
-		con.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
-		conControl.setVoidCallable(1);
-		con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
-		conControl.setVoidCallable(1);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.getTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		tx.setTimeout(10);
-		txControl.setVoidCallable(1);
-		tx.begin();
-		txControl.setVoidCallable(1);
-		session.connection();
-		sessionControl.setReturnValue(con, 3);
-		session.createQuery("some query string");
-		sessionControl.setReturnValue(query, 1);
-		query.list();
-		queryControl.setReturnValue(list, 1);
-		tx.commit();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-
-		dsControl.replay();
-		conControl.replay();
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
-		queryControl.replay();
+		given(con.getTransactionIsolation()).willReturn(Connection.TRANSACTION_READ_COMMITTED);
+		given(sf.openSession()).willReturn(session);
+		given(session.getTransaction()).willReturn(tx);
+		given(session.connection()).willReturn(con);
+		given(session.isOpen()).willReturn(true);
+		given(session.createQuery("some query string")).willReturn(query);
+		given(query.list()).willReturn(list);
+		given(session.isConnected()).willReturn(true);
 
 		LocalSessionFactoryBean lsfb = new LocalSessionFactoryBean() {
 			@Override
@@ -143,42 +126,27 @@ public Object doInTransaction(TransactionStatus status) {
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sfProxy));
 		assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds));
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
-		dsControl.verify();
-		conControl.verify();
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
-		queryControl.verify();
+
+		verify(con).setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
+		verify(con).setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
+		verify(tx).setTimeout(10);
+		verify(tx).begin();
+		verify(tx).commit();
+		verify(session).close();
 	}
 
+	@Test
 	public void testTransactionRollback() throws Exception {
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		tx.rollback();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 2);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
 
 		PlatformTransactionManager tm = new HibernateTransactionManager(sf);
 		TransactionTemplate tt = new TransactionTemplate(tm);
@@ -201,40 +169,23 @@ public Object doInTransaction(TransactionStatus status) {
 
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
+		verify(session).close();
+		verify(tx).rollback();
 	}
 
+	@Test
 	public void testTransactionRollbackOnly() throws Exception {
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.flush();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		tx.rollback();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 2);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.getFlushMode()).willReturn(FlushMode.AUTO);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
 
 		PlatformTransactionManager tm = new HibernateTransactionManager(sf);
 		TransactionTemplate tt = new TransactionTemplate(tm);
@@ -252,40 +203,24 @@ public Object doInTransaction(TransactionStatus status) {
 		});
 
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
+		verify(session).flush();
+		verify(session).close();
+		verify(tx).rollback();
 	}
 
+	@Test
 	public void testParticipatingTransactionWithCommit() throws Exception {
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.flush();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		tx.commit();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 2);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		final ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.getFlushMode()).willReturn(FlushMode.AUTO);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
 
 		LocalSessionFactoryBean lsfb = new LocalSessionFactoryBean() {
 			@Override
@@ -316,38 +251,24 @@ public Object doInTransaction(TransactionStatus status) {
 		});
 		assertTrue("Correct result list", result == l);
 
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
+		verify(session).flush();
+		verify(session).close();
+		verify(tx).commit();
 	}
 
+	@Test
 	public void testParticipatingTransactionWithRollback() throws Exception {
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		tx.rollback();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 2);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.getFlushMode()).willReturn(FlushMode.AUTO);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
 
 		PlatformTransactionManager tm = new HibernateTransactionManager(sf);
 		final TransactionTemplate tt = new TransactionTemplate(tm);
@@ -369,41 +290,27 @@ public Object doInTransaction(TransactionStatus status) {
 			// expected
 		}
 
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
+		verify(session).close();
+		verify(tx).rollback();
 	}
 
+	@Test
 	public void testParticipatingTransactionWithRollbackOnly() throws Exception {
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		tx.rollback();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 2);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
 
 		PlatformTransactionManager tm = new HibernateTransactionManager(sf);
 		final TransactionTemplate tt = new TransactionTemplate(tm);
+		final List l = new ArrayList();
+		l.add("test");
 
 		try {
 			tt.execute(new TransactionCallback() {
@@ -424,55 +331,28 @@ public Object doInTransaction(TransactionStatus status) {
 			// expected
 		}
 
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
+		verify(session).close();
+		verify(tx).rollback();
 	}
 
-	public void testParticipatingTransactionWithWithRequiresNew() throws Exception {
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl session1Control = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session1 = (ImplementingSession) session1Control.getMock();
-		MockControl session2Control = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session2 = (ImplementingSession) session2Control.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session1, 1);
-		sf.openSession();
-		sfControl.setReturnValue(session2, 1);
-		session1.beginTransaction();
-		session1Control.setReturnValue(tx, 1);
-		session2.beginTransaction();
-		session2Control.setReturnValue(tx, 1);
-		session2.flush();
-		session2Control.setVoidCallable(1);
-		session1.close();
-		session1Control.setReturnValue(null, 1);
-		session2.close();
-		session2Control.setReturnValue(null, 1);
-		tx.commit();
-		txControl.setVoidCallable(2);
-		session1.isConnected();
-		session1Control.setReturnValue(true, 1);
-		session1.connection();
-		session1Control.setReturnValue(con, 2);
-		session2.isConnected();
-		session2Control.setReturnValue(true, 1);
-		session2.connection();
-		session2Control.setReturnValue(con, 2);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 2);
-
-		sfControl.replay();
-		session1Control.replay();
-		session2Control.replay();
-		conControl.replay();
-		txControl.replay();
+	@Test
+	public void testParticipatingTransactionWithRequiresNew() throws Exception {
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session1 = mock(ImplementingSession.class);
+		ImplementingSession session2 = mock(ImplementingSession.class);
+		Connection con = mock(Connection.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session1, session2);
+		given(session1.beginTransaction()).willReturn(tx);
+		given(session1.isOpen()).willReturn(true);
+		given(session2.beginTransaction()).willReturn(tx);
+		given(session2.isOpen()).willReturn(true);
+		given(session2.getFlushMode()).willReturn(FlushMode.AUTO);
+		given(session1.isConnected()).willReturn(true);
+		given(session1.connection()).willReturn(con);
+		given(session2.isConnected()).willReturn(true);
+		given(session2.connection()).willReturn(con);
 
 		PlatformTransactionManager tm = new HibernateTransactionManager(sf);
 		final TransactionTemplate tt = new TransactionTemplate(tm);
@@ -506,42 +386,26 @@ public Object doInTransaction(TransactionStatus status) {
 		});
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
 
-		sfControl.verify();
-		session1Control.verify();
-		session2Control.verify();
-		conControl.verify();
-		txControl.verify();
+		verify(session2).flush();
+		verify(session1).close();
+		verify(session2).close();
+		verify(tx, times(2)).commit();
 	}
 
-	public void testParticipatingTransactionWithWithNotSupported() throws Exception {
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		tx.commit();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 2);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-
-		sfControl.replay();
-		sessionControl.replay();
-		conControl.replay();
-		txControl.replay();
+	@Test
+	public void testParticipatingTransactionWithNotSupported() throws Exception {
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		Connection con = mock(Connection.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.getSessionFactory()).willReturn(sf);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.getFlushMode()).willReturn(FlushMode.AUTO);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
 
 		HibernateTransactionManager tm = new HibernateTransactionManager(sf);
 		final TransactionTemplate tt = new TransactionTemplate(tm);
@@ -574,25 +438,18 @@ public Object doInTransaction(TransactionStatus status) {
 		});
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
 
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
+		verify(session).close();
+		verify(tx).commit();
 	}
 
+	@Test
 	public void testTransactionWithPropagationSupports() throws Exception {
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.flush();
-		sessionControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		sfControl.replay();
-		sessionControl.replay();
+		final SessionFactory sf = mock(SessionFactory.class);
+		final Session session = mock(Session.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.getSessionFactory()).willReturn(sf);
+		given(session.getFlushMode()).willReturn(FlushMode.MANUAL);
 
 		LocalSessionFactoryBean lsfb = new LocalSessionFactoryBean() {
 			@Override
@@ -623,47 +480,27 @@ public Object doInTransaction(TransactionStatus status) {
 		});
 
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sfProxy));
-		sfControl.verify();
-		sessionControl.verify();
+		InOrder ordered = inOrder(session);
+		ordered.verify(session).flush();
+		ordered.verify(session).close();
 	}
 
+	@Test
 	public void testTransactionWithPropagationSupportsAndInnerTransaction() throws Exception {
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl session1Control = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session1 = (ImplementingSession) session1Control.getMock();
-		MockControl session2Control = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session2 = (ImplementingSession) session2Control.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session1, 1);
-		session1.flush();
-		session1Control.setVoidCallable(1);
-		session1.close();
-		session1Control.setReturnValue(null, 1);
-
-		sf.openSession();
-		sfControl.setReturnValue(session2, 1);
-		session2.beginTransaction();
-		session2Control.setReturnValue(tx, 1);
-		session2.connection();
-		session2Control.setReturnValue(con, 2);
-		session2.flush();
-		session2Control.setVoidCallable(1);
-		tx.commit();
-		txControl.setVoidCallable(1);
-		session2.isConnected();
-		session2Control.setReturnValue(true, 1);
-		session2.close();
-		session2Control.setReturnValue(null, 1);
-		sfControl.replay();
-		session1Control.replay();
-		session2Control.replay();
-		txControl.replay();
+		final SessionFactory sf = mock(SessionFactory.class);
+		final ImplementingSession session1 = mock(ImplementingSession.class);
+		final ImplementingSession session2 = mock(ImplementingSession.class);
+		Connection con = mock(Connection.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session1, session2);
+		given(session1.getSessionFactory()).willReturn(sf);
+		given(session1.getFlushMode()).willReturn(FlushMode.AUTO);
+		given(session2.beginTransaction()).willReturn(tx);
+		given(session2.connection()).willReturn(con);
+		given(session2.getFlushMode()).willReturn(FlushMode.AUTO);
+		given(session2.isOpen()).willReturn(true);
+		given(session2.isConnected()).willReturn(true);
 
 		LocalSessionFactoryBean lsfb = new LocalSessionFactoryBean() {
 			@Override
@@ -710,56 +547,117 @@ public Object doInTransaction(TransactionStatus status) {
 		});
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
 
-		sfControl.verify();
-		session1Control.verify();
-		session2Control.verify();
-		txControl.verify();
+		verify(session1).flush();
+		verify(session1).close();
+		verify(session2).flush();
+		verify(session2).close();
+		verify(tx).commit();
+	}
+
+	@Test
+	public void testTransactionCommitWithEntityInterceptor() throws Exception {
+		Interceptor entityInterceptor = mock(Interceptor.class);
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		SessionBuilder options = mock(SessionBuilder.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.withOptions()).willReturn(options);
+		given(options.interceptor(entityInterceptor)).willReturn(options);
+		given(options.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
+
+		HibernateTransactionManager tm = new HibernateTransactionManager(sf);
+		tm.setEntityInterceptor(entityInterceptor);
+		TransactionTemplate tt = new TransactionTemplate(tm);
+		tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
+		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
+		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
+
+		Object result = tt.execute(new TransactionCallbackWithoutResult() {
+			@Override
+			public void doInTransactionWithoutResult(TransactionStatus status) {
+				assertTrue("Has thread session", TransactionSynchronizationManager.hasResource(sf));
+			}
+		});
+
+		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
+		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
+
+		verify(session).close();
+		verify(tx).commit();
 	}
 
+	@Test
+	public void testTransactionCommitWithEntityInterceptorBeanName() throws Exception {
+		Interceptor entityInterceptor = mock(Interceptor.class);
+		Interceptor entityInterceptor2 = mock(Interceptor.class);
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		SessionBuilder options = mock(SessionBuilder.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.withOptions()).willReturn(options);
+		given(options.interceptor(entityInterceptor)).willReturn(options);
+		given(options.interceptor(entityInterceptor2)).willReturn(options);
+		given(options.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
+
+		BeanFactory beanFactory = mock(BeanFactory.class);
+		given(beanFactory.getBean("entityInterceptor", Interceptor.class)).willReturn(
+				entityInterceptor, entityInterceptor2);
+
+		HibernateTransactionManager tm = new HibernateTransactionManager(sf);
+		tm.setEntityInterceptorBeanName("entityInterceptor");
+		tm.setBeanFactory(beanFactory);
+
+		TransactionTemplate tt = new TransactionTemplate(tm);
+		tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
+		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
+		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
+
+		for (int i = 0; i < 2; i++) {
+			tt.execute(new TransactionCallbackWithoutResult() {
+				@Override
+				public void doInTransactionWithoutResult(TransactionStatus status) {
+					assertTrue("Has thread session", TransactionSynchronizationManager.hasResource(sf));
+				}
+			});
+		}
+
+		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
+		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
+
+		verify(session, times(2)).close();
+		verify(tx, times(2)).commit();
+	}
+
+	@Test
 	public void testTransactionCommitWithReadOnly() throws Exception {
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-		MockControl queryControl = MockControl.createControl(Query.class);
-		Query query = (Query) queryControl.getMock();
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+		Query query = mock(Query.class);
 
 		final List list = new ArrayList();
 		list.add("test");
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.setFlushMode(FlushMode.MANUAL);
-		sessionControl.setVoidCallable(1);
-		session.connection();
-		sessionControl.setReturnValue(con, 2);
-		con.setReadOnly(true);
-		conControl.setVoidCallable(1);
-		session.createQuery("some query string");
-		sessionControl.setReturnValue(query, 1);
-		query.list();
-		queryControl.setReturnValue(list, 1);
-		tx.commit();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		con.isReadOnly();
-		conControl.setReturnValue(true, 1);
-		con.setReadOnly(false);
-		conControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-
-		conControl.replay();
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
-		queryControl.replay();
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.connection()).willReturn(con);
+		given(session.isOpen()).willReturn(true);
+		given(session.createQuery("some query string")).willReturn(query);
+		given(query.list()).willReturn(list);
+		given(session.isConnected()).willReturn(true);
+		given(con.isReadOnly()).willReturn(true);
 
 		HibernateTransactionManager tm = new HibernateTransactionManager(sf);
 		TransactionTemplate tt = new TransactionTemplate(tm);
@@ -782,48 +680,30 @@ public Object doInTransaction(TransactionStatus status) {
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
 
-		conControl.verify();
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
-		queryControl.verify();
+		verify(session).setFlushMode(FlushMode.MANUAL);
+		verify(con).setReadOnly(true);
+		verify(tx).commit();
+		verify(con).setReadOnly(false);
+		verify(session).close();
 	}
 
+	@Test
 	public void testTransactionCommitWithFlushFailure() throws Exception {
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		tx.commit();
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
 		SQLException sqlEx = new SQLException("argh", "27");
 		Exception rootCause = null;
 		ConstraintViolationException jdbcEx = new ConstraintViolationException("mymsg", sqlEx, null);
-		txControl.setThrowable(jdbcEx, 1);
 		rootCause = jdbcEx;
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		tx.rollback();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 2);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
-		conControl.replay();
+		willThrow(jdbcEx).given(tx).commit();
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
 
 		HibernateTransactionManager tm = new HibernateTransactionManager(sf);
 		TransactionTemplate tt = new TransactionTemplate(tm);
@@ -850,50 +730,25 @@ public Object doInTransaction(TransactionStatus status) {
 
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
-		conControl.verify();
+
+		verify(session).close();
+		verify(tx).rollback();
 	}
 
+	@Test
 	public void testTransactionCommitWithPreBound() throws Exception {
-		MockControl dsControl = MockControl.createControl(DataSource.class);
-		final DataSource ds = (DataSource) dsControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		session.getFlushMode();
-		sessionControl.setReturnValue(FlushMode.AUTO, 2);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 3);
-		con.getTransactionIsolation();
-		conControl.setReturnValue(Connection.TRANSACTION_READ_COMMITTED);
-		con.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
-		conControl.setVoidCallable(1);
-		con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
-		conControl.setVoidCallable(1);
-		tx.commit();
-		txControl.setVoidCallable(1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-		session.disconnect();
-		sessionControl.setReturnValue(null, 1);
-
-		dsControl.replay();
-		conControl.replay();
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
+		final DataSource ds = mock(DataSource.class);
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		final ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.isOpen()).willReturn(true);
+		given(session.getFlushMode()).willReturn(FlushMode.MANUAL);
+		given(session.connection()).willReturn(con);
+		given(con.getTransactionIsolation()).willReturn(Connection.TRANSACTION_READ_COMMITTED);
+		given(session.isConnected()).willReturn(true);
 
 		HibernateTransactionManager tm = new HibernateTransactionManager();
 		tm.setSessionFactory(sf);
@@ -928,55 +783,29 @@ public Object doInTransaction(TransactionStatus status) {
 		assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds));
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
 
-		dsControl.verify();
-		conControl.verify();
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
+		InOrder ordered = inOrder(session, con);
+		ordered.verify(con).setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
+		ordered.verify(session).setFlushMode(FlushMode.AUTO);
+		ordered.verify(con).setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
+		ordered.verify(session).setFlushMode(FlushMode.MANUAL);
+		verify(tx).commit();
+		verify(session).disconnect();
 	}
 
+	@Test
 	public void testTransactionRollbackWithPreBound() throws Exception {
-		MockControl dsControl = MockControl.createControl(DataSource.class);
-		final DataSource ds = (DataSource) dsControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl tx1Control = MockControl.createControl(Transaction.class);
-		final Transaction tx1 = (Transaction) tx1Control.getMock();
-		MockControl tx2Control = MockControl.createControl(Transaction.class);
-		final Transaction tx2 = (Transaction) tx2Control.getMock();
-
-		session.getFlushMode();
-		sessionControl.setReturnValue(FlushMode.AUTO, 4);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx1, 1);
-		tx1.rollback();
-		tx1Control.setVoidCallable(1);
-		session.clear();
-		sessionControl.setVoidCallable(1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx2, 1);
-		tx2.commit();
-		tx2Control.setVoidCallable(1);
-
-		session.isConnected();
-		sessionControl.setReturnValue(true, 2);
-		session.connection();
-		sessionControl.setReturnValue(con, 6);
-		con.isReadOnly();
-		conControl.setReturnValue(false, 2);
-		session.disconnect();
-		sessionControl.setReturnValue(null, 2);
-
-		dsControl.replay();
-		conControl.replay();
-		sfControl.replay();
-		sessionControl.replay();
-		tx1Control.replay();
-		tx2Control.replay();
+		final DataSource ds = mock(DataSource.class);
+		Connection con = mock(Connection.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		final ImplementingSession session = mock(ImplementingSession.class);
+		final Transaction tx1 = mock(Transaction.class);
+		final Transaction tx2 = mock(Transaction.class);
+
+		given(session.beginTransaction()).willReturn(tx1, tx2);
+		given(session.isOpen()).willReturn(true);
+		given(session.getFlushMode()).willReturn(FlushMode.MANUAL);
+		given(session.isConnected()).willReturn(true);
+		given(session.connection()).willReturn(con);
 
 		HibernateTransactionManager tm = new HibernateTransactionManager();
 		tm.setSessionFactory(sf);
@@ -1034,49 +863,27 @@ public void doInTransactionWithoutResult(TransactionStatus status) {
 		assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds));
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
 
-		dsControl.verify();
-		conControl.verify();
-		sfControl.verify();
-		sessionControl.verify();
-		tx1Control.verify();
-		tx2Control.verify();
+		verify(tx1).rollback();
+		verify(tx2).commit();
+		InOrder ordered = inOrder(session);
+		ordered.verify(session).clear();
+		ordered.verify(session).setFlushMode(FlushMode.AUTO);
+		ordered.verify(session).setFlushMode(FlushMode.MANUAL);
+		ordered.verify(session).disconnect();
 	}
 
+	@Test
 	public void testTransactionRollbackWithHibernateManagedSession() throws Exception {
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl tx1Control = MockControl.createControl(Transaction.class);
-		final Transaction tx1 = (Transaction) tx1Control.getMock();
-		MockControl tx2Control = MockControl.createControl(Transaction.class);
-		final Transaction tx2 = (Transaction) tx2Control.getMock();
-
-		sf.getCurrentSession();
-		sfControl.setReturnValue(session, 2);
-		session.getFlushMode();
-		sessionControl.setReturnValue(FlushMode.AUTO, 4);
-		session.getTransaction();
-		sessionControl.setReturnValue(tx1, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx1, 1);
-		tx1.isActive();
-		tx1Control.setReturnValue(false, 1);
-		tx1.rollback();
-		tx1Control.setVoidCallable(1);
-		session.getTransaction();
-		sessionControl.setReturnValue(tx2, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx2, 1);
-		tx2.isActive();
-		tx2Control.setReturnValue(false, 1);
-		tx2.commit();
-		tx2Control.setVoidCallable(1);
-
-		sfControl.replay();
-		sessionControl.replay();
-		tx1Control.replay();
-		tx2Control.replay();
+		final SessionFactory sf = mock(SessionFactory.class);
+		final Session session = mock(Session.class);
+		final Transaction tx1 = mock(Transaction.class);
+		final Transaction tx2 = mock(Transaction.class);
+
+		given(sf.getCurrentSession()).willReturn(session);
+		given(session.isOpen()).willReturn(true);
+		given(session.getTransaction()).willReturn(tx1, tx2);
+		given(session.beginTransaction()).willReturn(tx1, tx2);
+		given(session.getFlushMode()).willReturn(FlushMode.MANUAL);
 
 		HibernateTransactionManager tm = new HibernateTransactionManager();
 		tm.setSessionFactory(sf);
@@ -1118,16 +925,19 @@ public void doInTransactionWithoutResult(TransactionStatus status) {
 			}
 		});
 
-		sfControl.verify();
-		sessionControl.verify();
-		tx1Control.verify();
-		tx2Control.verify();
+		verify(tx1).rollback();
+		verify(tx2).commit();
+		InOrder ordered = inOrder(session);
+		ordered.verify(session).setFlushMode(FlushMode.AUTO);
+		ordered.verify(session).setFlushMode(FlushMode.MANUAL);
 	}
 
+	@Test
 	public void testExistingTransactionWithPropagationNestedAndRollback() throws Exception {
 		doTestExistingTransactionWithPropagationNestedAndRollback(false);
 	}
 
+	@Test
 	public void testExistingTransactionWithManualSavepointAndRollback() throws Exception {
 		doTestExistingTransactionWithPropagationNestedAndRollback(true);
 	}
@@ -1135,60 +945,27 @@ public void testExistingTransactionWithManualSavepointAndRollback() throws Excep
 	private void doTestExistingTransactionWithPropagationNestedAndRollback(final boolean manualSavepoint)
 			throws Exception {
 
-		MockControl dsControl = MockControl.createControl(DataSource.class);
-		final DataSource ds = (DataSource) dsControl.getMock();
-		MockControl conControl = MockControl.createControl(Connection.class);
-		Connection con = (Connection) conControl.getMock();
-		MockControl mdControl = MockControl.createControl(DatabaseMetaData.class);
-		DatabaseMetaData md = (DatabaseMetaData) mdControl.getMock();
-		MockControl spControl = MockControl.createControl(Savepoint.class);
-		Savepoint sp = (Savepoint) spControl.getMock();
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-		MockControl queryControl = MockControl.createControl(Query.class);
-		Query query = (Query) queryControl.getMock();
+		final DataSource ds = mock(DataSource.class);
+		Connection con = mock(Connection.class);
+		DatabaseMetaData md = mock(DatabaseMetaData.class);
+		Savepoint sp = mock(Savepoint.class);
+		final SessionFactory sf = mock(SessionFactory.class);
+		ImplementingSession session = mock(ImplementingSession.class);
+		Transaction tx = mock(Transaction.class);
+		Query query = mock(Query.class);
 
 		final List list = new ArrayList();
 		list.add("test");
-		con.isReadOnly();
-		conControl.setReturnValue(false, 1);
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.connection();
-		sessionControl.setReturnValue(con, 3);
-		md.supportsSavepoints();
-		mdControl.setReturnValue(true, 1);
-		con.getMetaData();
-		conControl.setReturnValue(md, 1);
-		con.setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1);
-		conControl.setReturnValue(sp, 1);
-		con.rollback(sp);
-		conControl.setVoidCallable(1);
-		session.createQuery("some query string");
-		sessionControl.setReturnValue(query, 1);
-		query.list();
-		queryControl.setReturnValue(list, 1);
-		session.isConnected();
-		sessionControl.setReturnValue(true, 1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-		tx.commit();
-		txControl.setVoidCallable(1);
-
-		dsControl.replay();
-		conControl.replay();
-		mdControl.replay();
-		spControl.replay();
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
-		queryControl.replay();
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
+		given(session.connection()).willReturn(con);
+		given(session.isOpen()).willReturn(true);
+		given(md.supportsSavepoints()).willReturn(true);
+		given(con.getMetaData()).willReturn(md);
+		given(con.setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1)).willReturn(sp);
+		given(session.createQuery("some query string")).willReturn(query);
+		given(query.list()).willReturn(list);
+		given(session.isConnected()).willReturn(true);
 
 		HibernateTransactionManager tm = new HibernateTransactionManager();
 		tm.setNestedTransactionAllowed(true);
@@ -1228,16 +1005,14 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
 		assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds));
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
-		dsControl.verify();
-		conControl.verify();
-		mdControl.verify();
-		spControl.verify();
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
-		queryControl.verify();
+
+		verify(con).setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + 1);
+		verify(con).rollback(sp);
+		verify(session).close();
+		verify(tx).commit();
 	}
 
+	@Test
 	public void testTransactionCommitWithNonExistingDatabase() throws Exception {
 		final DriverManagerDataSource ds = new DriverManagerDataSource();
 		LocalSessionFactoryBean lsfb = new LocalSessionFactoryBean();
@@ -1279,6 +1054,7 @@ public Object doInTransaction(TransactionStatus status) {
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
 	}
 
+	@Test
 	public void testTransactionCommitWithPreBoundSessionAndNonExistingDatabase() throws Exception {
 		final DriverManagerDataSource ds = new DriverManagerDataSource();
 		LocalSessionFactoryBean lsfb = new LocalSessionFactoryBean();
@@ -1328,6 +1104,7 @@ public Object doInTransaction(TransactionStatus status) {
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
 	}
 
+	@Test
 	public void testTransactionCommitWithNonExistingDatabaseAndLazyConnection() throws Exception {
 		DriverManagerDataSource dsTarget = new DriverManagerDataSource();
 		final LazyConnectionDataSourceProxy ds = new LazyConnectionDataSourceProxy();
@@ -1370,28 +1147,14 @@ public Object doInTransaction(TransactionStatus status) {
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
 	}
 
+	@Test
 	public void testTransactionFlush() throws Exception {
-		MockControl sfControl = MockControl.createControl(SessionFactory.class);
-		final SessionFactory sf = (SessionFactory) sfControl.getMock();
-		MockControl sessionControl = MockControl.createControl(ImplementingSession.class);
-		final ImplementingSession session = (ImplementingSession) sessionControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-
-		sf.openSession();
-		sfControl.setReturnValue(session, 1);
-		session.beginTransaction();
-		sessionControl.setReturnValue(tx, 1);
-		session.flush();
-		sessionControl.setVoidCallable(1);
-		tx.commit();
-		txControl.setVoidCallable(1);
-		session.close();
-		sessionControl.setReturnValue(null, 1);
-
-		sfControl.replay();
-		sessionControl.replay();
-		txControl.replay();
+		final SessionFactory sf = mock(SessionFactory.class);
+		final Session session = mock(Session.class);
+		Transaction tx = mock(Transaction.class);
+
+		given(sf.openSession()).willReturn(session);
+		given(session.beginTransaction()).willReturn(tx);
 
 		HibernateTransactionManager tm = new HibernateTransactionManager(sf);
 		tm.setPrepareConnection(false);
@@ -1411,17 +1174,10 @@ public void doInTransactionWithoutResult(TransactionStatus status) {
 
 		assertTrue("Hasn't thread session", !TransactionSynchronizationManager.hasResource(sf));
 		assertTrue("JTA synchronizations not active", !TransactionSynchronizationManager.isSynchronizationActive());
-		sfControl.verify();
-		sessionControl.verify();
-		txControl.verify();
-	}
 
-	@Override
-	protected void tearDown() {
-		assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty());
-		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
-		assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly());
-		assertFalse(TransactionSynchronizationManager.isActualTransactionActive());
+		verify(session).flush();
+		verify(tx).commit();
+		verify(session).close();
 	}
 
 
diff --git a/spring-orm/src/main/java/org/springframework/orm/hibernate3/HibernateTransactionManager.java b/spring-orm/src/main/java/org/springframework/orm/hibernate3/HibernateTransactionManager.java
index d3d1e137339e..abd06c801ac2 100644
--- a/spring-orm/src/main/java/org/springframework/orm/hibernate3/HibernateTransactionManager.java
+++ b/spring-orm/src/main/java/org/springframework/orm/hibernate3/HibernateTransactionManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -196,7 +196,7 @@ public SessionFactory getSessionFactory() {
 	 * for example, you could specify the same JNDI DataSource for both.
 	 * <p>If the SessionFactory was configured with LocalDataSourceConnectionProvider,
 	 * i.e. by Spring's LocalSessionFactoryBean with a specified "dataSource",
-	 * the DataSource will be auto-detected: You can still explictly specify the
+	 * the DataSource will be auto-detected: You can still explicitly specify the
 	 * DataSource, but you don't need to in this case.
 	 * <p>A transactional JDBC Connection for this DataSource will be provided to
 	 * application code accessing this DataSource directly via DataSourceUtils
@@ -527,7 +527,7 @@ protected void doBegin(Object transaction, TransactionDefinition definition) {
 			}
 
 			if (definition.isReadOnly() && txObject.isNewSession()) {
-				// Just set to NEVER in case of a new Session for this transaction.
+				// Just set to MANUAL in case of a new Session for this transaction.
 				session.setFlushMode(FlushMode.MANUAL);
 			}
 
@@ -779,7 +779,7 @@ protected boolean isSameConnectionForEntireSession(Session session) {
 	 * from the {@code org.springframework.dao} hierarchy.
 	 * <p>Will automatically apply a specified SQLExceptionTranslator to a
 	 * Hibernate JDBCException, else rely on Hibernate's default translation.
-	 * @param ex HibernateException that occured
+	 * @param ex HibernateException that occurred
 	 * @return a corresponding DataAccessException
 	 * @see SessionFactoryUtils#convertHibernateAccessException
 	 * @see #setJdbcExceptionTranslator
@@ -798,7 +798,7 @@ else if (GenericJDBCException.class.equals(ex.getClass())) {
 	 * Convert the given Hibernate JDBCException to an appropriate exception
 	 * from the {@code org.springframework.dao} hierarchy, using the
 	 * given SQLExceptionTranslator.
-	 * @param ex Hibernate JDBCException that occured
+	 * @param ex Hibernate JDBCException that occurred
 	 * @param translator the SQLExceptionTranslator to use
 	 * @return a corresponding DataAccessException
 	 */
@@ -887,6 +887,7 @@ public boolean isRollbackOnly() {
 					(hasConnectionHolder() && getConnectionHolder().isRollbackOnly());
 		}
 
+		@Override
 		public void flush() {
 			try {
 				this.sessionHolder.getSession().flush();
diff --git a/spring-orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryUtils.java b/spring-orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryUtils.java
index 49c49a697607..a6e13b673da3 100644
--- a/spring-orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryUtils.java
+++ b/spring-orm/src/main/java/org/springframework/orm/hibernate3/SessionFactoryUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -621,7 +621,7 @@ public static void applyTransactionTimeout(Criteria criteria, SessionFactory ses
 	/**
 	 * Convert the given HibernateException to an appropriate exception
 	 * from the {@code org.springframework.dao} hierarchy.
-	 * @param ex HibernateException that occured
+	 * @param ex HibernateException that occurred
 	 * @return the corresponding DataAccessException instance
 	 * @see HibernateAccessor#convertHibernateAccessException
 	 * @see HibernateTransactionManager#convertHibernateAccessException
diff --git a/spring-orm/src/main/java/org/springframework/orm/hibernate3/annotation/AnnotationSessionFactoryBean.java b/spring-orm/src/main/java/org/springframework/orm/hibernate3/annotation/AnnotationSessionFactoryBean.java
index d944ef497dc4..72f5ee42ea7d 100644
--- a/spring-orm/src/main/java/org/springframework/orm/hibernate3/annotation/AnnotationSessionFactoryBean.java
+++ b/spring-orm/src/main/java/org/springframework/orm/hibernate3/annotation/AnnotationSessionFactoryBean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -79,6 +79,8 @@ public class AnnotationSessionFactoryBean extends LocalSessionFactoryBean implem
 
 	private static final String RESOURCE_PATTERN = "/**/*.class";
 
+	private static final String PACKAGE_INFO_SUFFIX = ".package-info";
+
 
 	private Class[] annotatedClasses;
 
@@ -101,7 +103,7 @@ public AnnotationSessionFactoryBean() {
 
 
 	@Override
-	public void setConfigurationClass(Class configurationClass) {
+	public void setConfigurationClass(Class<?> configurationClass) {
 		if (configurationClass == null || !AnnotationConfiguration.class.isAssignableFrom(configurationClass)) {
 			throw new IllegalArgumentException(
 					"AnnotationSessionFactoryBean only supports AnnotationConfiguration or subclasses");
@@ -191,9 +193,12 @@ protected void scanPackages(AnnotationConfiguration config) {
 						if (resource.isReadable()) {
 							MetadataReader reader = readerFactory.getMetadataReader(resource);
 							String className = reader.getClassMetadata().getClassName();
-							if (matchesFilter(reader, readerFactory)) {
+							if (matchesEntityTypeFilter(reader, readerFactory)) {
 								config.addAnnotatedClass(this.resourcePatternResolver.getClassLoader().loadClass(className));
 							}
+							else if (className.endsWith(PACKAGE_INFO_SUFFIX)) {
+								config.addPackage(className.substring(0, className.length() - PACKAGE_INFO_SUFFIX.length()));
+							}
 						}
 					}
 				}
@@ -211,7 +216,7 @@ protected void scanPackages(AnnotationConfiguration config) {
 	 * Check whether any of the configured entity type filters matches
 	 * the current class descriptor contained in the metadata reader.
 	 */
-	private boolean matchesFilter(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {
+	private boolean matchesEntityTypeFilter(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {
 		if (this.entityTypeFilters != null) {
 			for (TypeFilter filter : this.entityTypeFilters) {
 				if (filter.match(reader, readerFactory)) {
diff --git a/spring-orm/src/main/java/org/springframework/orm/jdo/DefaultJdoDialect.java b/spring-orm/src/main/java/org/springframework/orm/jdo/DefaultJdoDialect.java
index 38d0f7263a4c..9d058158b91d 100644
--- a/spring-orm/src/main/java/org/springframework/orm/jdo/DefaultJdoDialect.java
+++ b/spring-orm/src/main/java/org/springframework/orm/jdo/DefaultJdoDialect.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 import java.lang.reflect.Method;
 import java.sql.Connection;
 import java.sql.SQLException;
+import javax.jdo.Constants;
 import javax.jdo.JDOException;
 import javax.jdo.PersistenceManager;
 import javax.jdo.Query;
@@ -32,7 +33,6 @@
 import org.springframework.jdbc.datasource.ConnectionHandle;
 import org.springframework.jdbc.support.JdbcUtils;
 import org.springframework.jdbc.support.SQLExceptionTranslator;
-import org.springframework.transaction.InvalidIsolationLevelException;
 import org.springframework.transaction.TransactionDefinition;
 import org.springframework.transaction.TransactionException;
 import org.springframework.util.ClassUtils;
@@ -40,13 +40,13 @@
 
 /**
  * Default implementation of the {@link JdoDialect} interface.
- * Updated to build on JDO 2.0 or higher, as of Spring 2.5.
+ * Requires JDO 2.0; explicitly supports JDO API features up until 3.0.
  * Used as default dialect by {@link JdoAccessor} and {@link JdoTransactionManager}.
  *
  * <p>Simply begins a standard JDO transaction in {@code beginTransaction}.
  * Returns a handle for a JDO2 DataStoreConnection on {@code getJdbcConnection}.
  * Calls the corresponding JDO2 PersistenceManager operation on {@code flush}
- * Ignores a given query timeout in {@code applyQueryTimeout}.
+ * Translates {@code applyQueryTimeout} to JDO 3.0's {@code setTimeoutMillis}.
  * Uses a Spring SQLExceptionTranslator for exception translation, if applicable.
  *
  * <p>Note that, even with JDO2, vendor-specific subclasses are still necessary
@@ -122,24 +122,49 @@ public SQLExceptionTranslator getJdbcExceptionTranslator() {
 	//-------------------------------------------------------------------------
 
 	/**
-	 * This implementation invokes the standard JDO {@code Transaction.begin}
-	 * method. Throws an InvalidIsolationLevelException if a non-default isolation
-	 * level is set.
+	 * This implementation invokes the standard JDO {@link Transaction#begin()}
+	 * method and also {@link Transaction#setIsolationLevel(String)} if necessary.
 	 * @see javax.jdo.Transaction#begin
 	 * @see org.springframework.transaction.InvalidIsolationLevelException
 	 */
 	public Object beginTransaction(Transaction transaction, TransactionDefinition definition)
 			throws JDOException, SQLException, TransactionException {
 
-		if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {
-			throw new InvalidIsolationLevelException(
-					"Standard JDO does not support custom isolation levels: " +
-					"use a special JdoDialect implementation for your JDO provider");
+		String jdoIsolationLevel = getJdoIsolationLevel(definition);
+		if (jdoIsolationLevel != null) {
+			transaction.setIsolationLevel(jdoIsolationLevel);
 		}
 		transaction.begin();
 		return null;
 	}
 
+	/**
+	 * Determine the JDO isolation level String to use for the given
+	 * Spring transaction definition.
+	 * @param definition the Spring transaction definition
+	 * @return the corresponding JDO isolation level String, or {@code null}
+	 * to indicate that no isolation level should be set explicitly
+	 * @see Transaction#setIsolationLevel(String)
+	 * @see Constants#TX_SERIALIZABLE
+	 * @see Constants#TX_REPEATABLE_READ
+	 * @see Constants#TX_READ_COMMITTED
+	 * @see Constants#TX_READ_UNCOMMITTED
+	 */
+	protected String getJdoIsolationLevel(TransactionDefinition definition) {
+		switch (definition.getIsolationLevel()) {
+			case TransactionDefinition.ISOLATION_SERIALIZABLE:
+				return Constants.TX_SERIALIZABLE;
+			case TransactionDefinition.ISOLATION_REPEATABLE_READ:
+				return Constants.TX_REPEATABLE_READ;
+			case TransactionDefinition.ISOLATION_READ_COMMITTED:
+				return Constants.TX_READ_COMMITTED;
+			case TransactionDefinition.ISOLATION_READ_UNCOMMITTED:
+				return Constants.TX_READ_UNCOMMITTED;
+			default:
+				return null;
+		}
+	}
+
 	/**
 	 * This implementation does nothing, as the default beginTransaction implementation
 	 * does not require any cleanup.
diff --git a/spring-orm/src/main/java/org/springframework/orm/jdo/JdoTemplate.java b/spring-orm/src/main/java/org/springframework/orm/jdo/JdoTemplate.java
index ce0f61aefcba..6ed2028384fd 100644
--- a/spring-orm/src/main/java/org/springframework/orm/jdo/JdoTemplate.java
+++ b/spring-orm/src/main/java/org/springframework/orm/jdo/JdoTemplate.java
@@ -481,7 +481,6 @@ public Collection doInJdo(PersistenceManager pm) throws JDOException {
 
 	public Collection find(final String queryString) throws DataAccessException {
 		return execute(new JdoCallback<Collection>() {
-			@SuppressWarnings("unchecked")
 			public Collection doInJdo(PersistenceManager pm) throws JDOException {
 				Query query = pm.newQuery(queryString);
 				prepareQuery(query);
diff --git a/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateInterceptorTests.java b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateInterceptorTests.java
index 498005295ea0..16a7ed030cfb 100644
--- a/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateInterceptorTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateInterceptorTests.java
@@ -16,18 +16,6 @@
 
 package org.springframework.orm.hibernate3;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.SQLException;
 
 import org.aopalliance.intercept.MethodInvocation;
@@ -46,6 +34,9 @@
 import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateJtaTransactionTests.java b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateJtaTransactionTests.java
index 6f5ef6d62d2d..ff9c053d8191 100644
--- a/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateJtaTransactionTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateJtaTransactionTests.java
@@ -16,20 +16,6 @@
 
 package org.springframework.orm.hibernate3;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willDoNothing;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -62,6 +48,9 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateTemplateTests.java b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateTemplateTests.java
index fd1ae832b38f..07fdf5e6b8e8 100644
--- a/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateTemplateTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateTemplateTests.java
@@ -16,20 +16,6 @@
 
 package org.springframework.orm.hibernate3;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.same;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.verify;
-
 import java.lang.reflect.Proxy;
 import java.sql.Connection;
 import java.sql.SQLException;
@@ -79,6 +65,9 @@
 import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateTransactionManagerTests.java b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateTransactionManagerTests.java
index 534beea65664..d4d12ba036ba 100644
--- a/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateTransactionManagerTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/HibernateTransactionManagerTests.java
@@ -16,18 +16,6 @@
 
 package org.springframework.orm.hibernate3;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
@@ -35,7 +23,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Properties;
-
 import javax.sql.DataSource;
 
 import org.hibernate.FlushMode;
@@ -53,6 +40,7 @@
 import org.junit.After;
 import org.junit.Test;
 import org.mockito.InOrder;
+
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.jdbc.datasource.ConnectionHolder;
@@ -69,6 +57,9 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
@@ -450,7 +441,7 @@ public Object doInHibernate(org.hibernate.Session session) {
 	}
 
 	@Test
-	public void testParticipatingTransactionWithWithRequiresNew() throws Exception {
+	public void testParticipatingTransactionWithRequiresNew() throws Exception {
 		final SessionFactory sf = mock(SessionFactory.class);
 		Session session1 = mock(Session.class);
 		Session session2 = mock(Session.class);
@@ -512,7 +503,7 @@ public Object doInHibernate(org.hibernate.Session session) {
 	}
 
 	@Test
-	public void testParticipatingTransactionWithWithNotSupported() throws Exception {
+	public void testParticipatingTransactionWithNotSupported() throws Exception {
 		final SessionFactory sf = mock(SessionFactory.class);
 		Session session = mock(Session.class);
 		Connection con = mock(Connection.class);
@@ -1399,4 +1390,5 @@ public void doInTransactionWithoutResult(TransactionStatus status) {
 		verify(tx).commit();
 		verify(session).close();
 	}
+
 }
diff --git a/spring-orm/src/test/java/org/springframework/orm/hibernate3/LocalSessionFactoryBeanTests.java b/spring-orm/src/test/java/org/springframework/orm/hibernate3/LocalSessionFactoryBeanTests.java
index 0b61d5916031..91972e57b093 100644
--- a/spring-orm/src/test/java/org/springframework/orm/hibernate3/LocalSessionFactoryBeanTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/LocalSessionFactoryBeanTests.java
@@ -16,13 +16,6 @@
 
 package org.springframework.orm.hibernate3;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -63,6 +56,9 @@
 import org.springframework.core.io.Resource;
 import org.springframework.jdbc.datasource.DriverManagerDataSource;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/HibernateDaoSupportTests.java b/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/HibernateDaoSupportTests.java
index 8aa465e0e82f..85aa8db363ff 100644
--- a/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/HibernateDaoSupportTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/HibernateDaoSupportTests.java
@@ -16,9 +16,6 @@
 
 package org.springframework.orm.hibernate3.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -26,6 +23,9 @@
 import org.junit.Test;
 import org.springframework.orm.hibernate3.HibernateTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/LobTypeTests.java b/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/LobTypeTests.java
index ab82cbcf6382..f8b5d81194b8 100644
--- a/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/LobTypeTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/LobTypeTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.orm.hibernate3.support;
 
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectOutputStream;
@@ -48,6 +43,9 @@
 import org.springframework.transaction.support.TransactionSynchronization;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/OpenSessionInViewTests.java b/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/OpenSessionInViewTests.java
index a51fc633e9b0..0777c3ae11c2 100644
--- a/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/OpenSessionInViewTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/hibernate3/support/OpenSessionInViewTests.java
@@ -16,16 +16,6 @@
 
 package org.springframework.orm.hibernate3.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.io.IOException;
 import java.sql.Connection;
 import java.util.concurrent.Callable;
@@ -64,6 +54,9 @@
 import org.springframework.web.context.request.async.WebAsyncUtils;
 import org.springframework.web.context.support.StaticWebApplicationContext;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 
 /**
  * @author Juergen Hoeller
diff --git a/spring-orm/src/test/java/org/springframework/orm/ibatis/SqlMapClientTests.java b/spring-orm/src/test/java/org/springframework/orm/ibatis/SqlMapClientTests.java
index 91a7277e7832..802c0a2fa4c9 100644
--- a/spring-orm/src/test/java/org/springframework/orm/ibatis/SqlMapClientTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/ibatis/SqlMapClientTests.java
@@ -16,13 +16,6 @@
 
 package org.springframework.orm.ibatis;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.ArrayList;
@@ -42,6 +35,9 @@
 import com.ibatis.sqlmap.client.SqlMapSession;
 import com.ibatis.sqlmap.client.event.RowHandler;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Alef Arendsen
diff --git a/spring-orm/src/test/java/org/springframework/orm/ibatis/support/LobTypeHandlerTests.java b/spring-orm/src/test/java/org/springframework/orm/ibatis/support/LobTypeHandlerTests.java
index 948c4e7ec26a..0eb1a5124389 100644
--- a/spring-orm/src/test/java/org/springframework/orm/ibatis/support/LobTypeHandlerTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/ibatis/support/LobTypeHandlerTests.java
@@ -16,13 +16,6 @@
 
 package org.springframework.orm.ibatis.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
@@ -47,6 +40,9 @@
 import org.springframework.transaction.support.TransactionSynchronization;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jdo/JdoInterceptorTests.java b/spring-orm/src/test/java/org/springframework/orm/jdo/JdoInterceptorTests.java
index c88e58cd07dd..0174445df2cf 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jdo/JdoInterceptorTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jdo/JdoInterceptorTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.orm.jdo;
 
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Method;
 
@@ -33,6 +28,9 @@
 import org.junit.Test;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
@@ -77,6 +75,7 @@ public void testInterceptorWithPrebound() {
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class TestInvocation implements MethodInvocation {
 
 		private PersistenceManagerFactory persistenceManagerFactory;
diff --git a/spring-orm/src/test/java/org/springframework/orm/jdo/JdoTemplateTests.java b/spring-orm/src/test/java/org/springframework/orm/jdo/JdoTemplateTests.java
index 29c882b2b638..de3c4d05fe32 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jdo/JdoTemplateTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jdo/JdoTemplateTests.java
@@ -16,13 +16,6 @@
 
 package org.springframework.orm.jdo;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -41,12 +34,14 @@
 import javax.jdo.PersistenceManagerFactory;
 import javax.jdo.Query;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jdo/JdoTransactionManagerTests.java b/spring-orm/src/test/java/org/springframework/orm/jdo/JdoTransactionManagerTests.java
index 538ce2572bad..f5fb828e49d3 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jdo/JdoTransactionManagerTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jdo/JdoTransactionManagerTests.java
@@ -16,17 +16,6 @@
 
 package org.springframework.orm.jdo;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.lang.reflect.Proxy;
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
@@ -35,6 +24,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import javax.jdo.Constants;
 import javax.jdo.JDOFatalDataStoreException;
 import javax.jdo.PersistenceManager;
 import javax.jdo.PersistenceManagerFactory;
@@ -55,7 +45,6 @@
 import org.springframework.orm.jdo.support.StandardPersistenceManagerProxyBean;
 import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.tests.transaction.MockJtaTransaction;
-import org.springframework.transaction.InvalidIsolationLevelException;
 import org.springframework.transaction.PlatformTransactionManager;
 import org.springframework.transaction.TransactionDefinition;
 import org.springframework.transaction.TransactionStatus;
@@ -65,6 +54,9 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
@@ -620,24 +612,19 @@ public Object doInJdo(PersistenceManager pm) {
 	}
 
 	@Test
-	public void testInvalidIsolation() {
+	public void testIsolationLevel() {
 		given(pmf.getPersistenceManager()).willReturn(pm);
 		given(pm.currentTransaction()).willReturn(tx);
 
 		PlatformTransactionManager tm = new JdoTransactionManager(pmf);
 		TransactionTemplate tt = new TransactionTemplate(tm);
 		tt.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
-		try {
-			tt.execute(new TransactionCallbackWithoutResult() {
-				@Override
-				protected void doInTransactionWithoutResult(TransactionStatus status) {
-				}
-			});
-			fail("Should have thrown InvalidIsolationLevelException");
-		}
-		catch (InvalidIsolationLevelException ex) {
-			// expected
-		}
+		tt.execute(new TransactionCallbackWithoutResult() {
+			@Override
+			protected void doInTransactionWithoutResult(TransactionStatus status) {
+			}
+		});
+		verify(tx).setIsolationLevel(Constants.TX_SERIALIZABLE);
 		verify(pm).close();
 	}
 
diff --git a/spring-orm/src/test/java/org/springframework/orm/jdo/LocalPersistenceManagerFactoryTests.java b/spring-orm/src/test/java/org/springframework/orm/jdo/LocalPersistenceManagerFactoryTests.java
index 4b16a589caf5..8f4c921adfb6 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jdo/LocalPersistenceManagerFactoryTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jdo/LocalPersistenceManagerFactoryTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.orm.jdo;
 
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.mock;
-
 import java.io.IOException;
 import java.util.Map;
 import java.util.Properties;
@@ -31,6 +26,9 @@
 import org.junit.Test;
 import org.springframework.core.io.ClassPathResource;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jdo/support/JdoDaoSupportTests.java b/spring-orm/src/test/java/org/springframework/orm/jdo/support/JdoDaoSupportTests.java
index 529bdcabf1bd..d11d147ab174 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jdo/support/JdoDaoSupportTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jdo/support/JdoDaoSupportTests.java
@@ -16,9 +16,6 @@
 
 package org.springframework.orm.jdo.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -27,6 +24,9 @@
 import org.junit.Test;
 import org.springframework.orm.jdo.JdoTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jdo/support/OpenPersistenceManagerInViewTests.java b/spring-orm/src/test/java/org/springframework/orm/jdo/support/OpenPersistenceManagerInViewTests.java
index 2736e3b6da42..a3b75526d168 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jdo/support/OpenPersistenceManagerInViewTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jdo/support/OpenPersistenceManagerInViewTests.java
@@ -16,13 +16,6 @@
 
 package org.springframework.orm.jdo.support;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.io.IOException;
 
 import javax.jdo.PersistenceManager;
@@ -43,6 +36,9 @@
 import org.springframework.web.context.request.ServletWebRequest;
 import org.springframework.web.context.support.StaticWebApplicationContext;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @author Chris Beams
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/AbstractEntityManagerFactoryBeanTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/AbstractEntityManagerFactoryBeanTests.java
index cefae3bdf2ff..353ba458fa98 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/AbstractEntityManagerFactoryBeanTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/AbstractEntityManagerFactoryBeanTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.orm.jpa;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.PersistenceException;
 import javax.persistence.spi.PersistenceUnitInfo;
@@ -29,6 +24,9 @@
 import org.junit.Before;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Superclass for unit tests for EntityManagerFactory-creating beans.
  * Note: Subclasses must set expectations on the mock EntityManagerFactory.
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/ApplicationManagedEntityManagerIntegrationTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/ApplicationManagedEntityManagerIntegrationTests.java
index 23f241e5ab10..920099caf9cb 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/ApplicationManagedEntityManagerIntegrationTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/ApplicationManagedEntityManagerIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -48,6 +48,7 @@ public void testEntityManagerProxyIsProxy() {
 		assertTrue(Proxy.isProxyClass(em.getClass()));
 		Query q = em.createQuery("select p from Person as p");
 		List<Person> people = q.getResultList();
+		assertNotNull(people);
 
 		assertTrue("Should be open to start with", em.isOpen());
 		em.close();
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/DefaultJpaDialectTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/DefaultJpaDialectTests.java
index 9102cd8645aa..f84155ecc6f8 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/DefaultJpaDialectTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/DefaultJpaDialectTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.orm.jpa;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import javax.persistence.EntityManager;
 import javax.persistence.EntityTransaction;
 import javax.persistence.OptimisticLockException;
@@ -30,6 +25,9 @@
 import org.springframework.transaction.TransactionException;
 import org.springframework.transaction.support.DefaultTransactionDefinition;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Costin Leau
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/EntityManagerFactoryBeanSupportTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/EntityManagerFactoryBeanSupportTests.java
index 0f21f02ea853..0380650be6d1 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/EntityManagerFactoryBeanSupportTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/EntityManagerFactoryBeanSupportTests.java
@@ -16,10 +16,10 @@
 
 package org.springframework.orm.jpa;
 
-import static org.mockito.Mockito.verify;
-
 import org.junit.Test;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/EntityManagerFactoryUtilsTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/EntityManagerFactoryUtilsTests.java
index 437713666367..7edab0c0ce1e 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/EntityManagerFactoryUtilsTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/EntityManagerFactoryUtilsTests.java
@@ -16,13 +16,6 @@
 
 package org.springframework.orm.jpa;
 
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-
 import javax.persistence.EntityExistsException;
 import javax.persistence.EntityManager;
 import javax.persistence.EntityManagerFactory;
@@ -41,6 +34,9 @@
 import org.springframework.dao.InvalidDataAccessApiUsageException;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Costin Leau
  * @author Rod Johnson
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/JpaInterceptorTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/JpaInterceptorTests.java
index acc8f3b5559e..6e4eabe20642 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/JpaInterceptorTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/JpaInterceptorTests.java
@@ -16,15 +16,6 @@
 
 package org.springframework.orm.jpa;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Method;
 
@@ -40,6 +31,9 @@
 import org.junit.Test;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Costin Leau
  * @author Phillip Webb
@@ -198,6 +192,7 @@ public void testInterceptorWithFlushFailureWithoutConversion() throws Throwable
 	}
 
 
+	@SuppressWarnings("unused")
 	private static class TestInvocation implements MethodInvocation {
 
 		private EntityManagerFactory entityManagerFactory;
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/JpaTemplateTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/JpaTemplateTests.java
index 64828a431907..697cc6389b90 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/JpaTemplateTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/JpaTemplateTests.java
@@ -16,14 +16,6 @@
 
 package org.springframework.orm.jpa;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -39,6 +31,9 @@
 import org.springframework.dao.DataAccessException;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Costin Leau
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/JpaTransactionManagerTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/JpaTransactionManagerTests.java
index a343d215372a..f81d97dc2ea5 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/JpaTransactionManagerTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/JpaTransactionManagerTests.java
@@ -16,17 +16,6 @@
 
 package org.springframework.orm.jpa;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
@@ -51,6 +40,9 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Costin Leau
  * @author Juergen Hoeller
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBeanTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBeanTests.java
index 5f20a375d4be..7ab71bc860a0 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBeanTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBeanTests.java
@@ -16,19 +16,6 @@
 
 package org.springframework.orm.jpa;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.willThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import java.util.Map;
 import java.util.Properties;
 
@@ -51,6 +38,9 @@
 import org.springframework.transaction.interceptor.DefaultTransactionAttribute;
 import org.springframework.util.SerializationTestUtils;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/LocalEntityManagerFactoryBeanTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/LocalEntityManagerFactoryBeanTests.java
index de6667f543f1..bbf407b38075 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/LocalEntityManagerFactoryBeanTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/LocalEntityManagerFactoryBeanTests.java
@@ -16,10 +16,6 @@
 
 package org.springframework.orm.jpa;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
-import static org.mockito.Mockito.verify;
-
 import java.util.Map;
 import java.util.Properties;
 
@@ -30,6 +26,9 @@
 import org.junit.After;
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/openjpa/OpenJpaEntityManagerFactoryWithAspectJWeavingIntegrationTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/openjpa/OpenJpaEntityManagerFactoryWithAspectJWeavingIntegrationTests.java
index 20d9e5f029bc..a35fdac8cadb 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/openjpa/OpenJpaEntityManagerFactoryWithAspectJWeavingIntegrationTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/openjpa/OpenJpaEntityManagerFactoryWithAspectJWeavingIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,17 +19,13 @@
 import org.junit.Ignore;
 
 /**
- * Test that AspectJ weaving (in particular the currently shipped aspects) work with JPA (see SPR-3873 for more details).
+ * Test that AspectJ weaving (in particular the currently shipped aspects) work with JPA
+ * (see SPR-3873 for more details).
  *
  * @author Ramnivas Laddad
+ * @author Chris Beams
  */
-// TODO [SPR-10074] this test causes gradle to hang.
-// When run independently e.g. `./gradlew :spring-orm:test -Dtest.single=OpenJpaEntity...`
-// it works fine. When run together with all other tests e.g. `./gradlew :spring-orm:test`
-// it hangs on the 'testCanSerializeProxies' test method. Note that this test DOES pass in
-// Eclipse, even when the entire 'spring-orm' module is run. Run gradle with '-i' to
-// get more details when reproducing the hanging test.
-@Ignore("this test causes gradle to hang")
+@Ignore("This test causes gradle to hang. See SPR-10333.")
 public class OpenJpaEntityManagerFactoryWithAspectJWeavingIntegrationTests extends OpenJpaEntityManagerFactoryIntegrationTests {
 
 	@Override
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/support/JpaDaoSupportTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/support/JpaDaoSupportTests.java
index 4925258a6693..acb86b597a28 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/support/JpaDaoSupportTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/support/JpaDaoSupportTests.java
@@ -16,11 +16,6 @@
 
 package org.springframework.orm.jpa.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.mock;
-
 import java.util.ArrayList;
 import java.util.List;
 
@@ -30,6 +25,9 @@
 import org.junit.Test;
 import org.springframework.orm.jpa.JpaTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Costin Leau
  * @author Phillip Webb
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/support/OpenEntityManagerInViewTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/support/OpenEntityManagerInViewTests.java
index 8dd05c32b3d0..1859fd3acad3 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/support/OpenEntityManagerInViewTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/support/OpenEntityManagerInViewTests.java
@@ -16,17 +16,6 @@
 
 package org.springframework.orm.jpa.support;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.reset;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
 import java.io.IOException;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -56,6 +45,9 @@
 import org.springframework.web.context.request.async.WebAsyncUtils;
 import org.springframework.web.context.support.StaticWebApplicationContext;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Costin Leau
  * @author Juergen Hoeller
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/support/PersistenceInjectionTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/support/PersistenceInjectionTests.java
index f7a26112fc51..9833c7146d7b 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/support/PersistenceInjectionTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/support/PersistenceInjectionTests.java
@@ -16,15 +16,6 @@
 
 package org.springframework.orm.jpa.support;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.withSettings;
-
 import java.io.Serializable;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
@@ -57,6 +48,9 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.util.SerializationTestUtils;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for persistence context and persistence unit injection.
  *
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/support/SharedEntityManagerFactoryTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/support/SharedEntityManagerFactoryTests.java
index 4a783c7d5d59..d185546a802c 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/support/SharedEntityManagerFactoryTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/support/SharedEntityManagerFactoryTests.java
@@ -16,14 +16,6 @@
 
 package org.springframework.orm.jpa.support;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
 import javax.persistence.EntityManager;
 import javax.persistence.EntityManagerFactory;
 
@@ -32,6 +24,9 @@
 import org.springframework.orm.jpa.EntityManagerProxy;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
diff --git a/spring-orm/src/test/java/org/springframework/orm/jpa/toplink/TopLinkMultiEntityManagerFactoryIntegrationTests.java b/spring-orm/src/test/java/org/springframework/orm/jpa/toplink/TopLinkMultiEntityManagerFactoryIntegrationTests.java
index 78e8f86af5bd..7b7431311435 100644
--- a/spring-orm/src/test/java/org/springframework/orm/jpa/toplink/TopLinkMultiEntityManagerFactoryIntegrationTests.java
+++ b/spring-orm/src/test/java/org/springframework/orm/jpa/toplink/TopLinkMultiEntityManagerFactoryIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,9 +26,9 @@
  * Toplink-specific JPA tests with multiple EntityManagerFactory instances.
  *
  * @author Costin Leau
+ * @author Chris Beams
  */
-// TODO [SPR-10074] this test causes gradle to hang. See OJEMFWAJWIT.
-@Ignore("this test causes gradle to hang. See OJEMFWAJWIT.")
+@Ignore("This test causes gradle to hang. See SPR-10333.")
 public class TopLinkMultiEntityManagerFactoryIntegrationTests extends
 		AbstractContainerEntityManagerFactoryIntegrationTests {
 
diff --git a/spring-oxm/src/main/java/org/springframework/oxm/GenericUnmarshaller.java b/spring-oxm/src/main/java/org/springframework/oxm/GenericUnmarshaller.java
index fab56e5e5aad..0f23da93c4d0 100644
--- a/spring-oxm/src/main/java/org/springframework/oxm/GenericUnmarshaller.java
+++ b/spring-oxm/src/main/java/org/springframework/oxm/GenericUnmarshaller.java
@@ -34,4 +34,4 @@ public interface GenericUnmarshaller extends Unmarshaller {
 	 */
 	boolean supports(Type genericType);
 
-}
\ No newline at end of file
+}
diff --git a/spring-oxm/src/main/java/org/springframework/oxm/castor/CastorMarshaller.java b/spring-oxm/src/main/java/org/springframework/oxm/castor/CastorMarshaller.java
index 0405e8272e74..131b782c876a 100644
--- a/spring-oxm/src/main/java/org/springframework/oxm/castor/CastorMarshaller.java
+++ b/spring-oxm/src/main/java/org/springframework/oxm/castor/CastorMarshaller.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,16 +30,20 @@
 
 import org.exolab.castor.mapping.Mapping;
 import org.exolab.castor.mapping.MappingException;
+import org.exolab.castor.util.ObjectFactory;
+import org.exolab.castor.xml.IDResolver;
 import org.exolab.castor.xml.MarshalException;
 import org.exolab.castor.xml.Marshaller;
 import org.exolab.castor.xml.ResolverException;
 import org.exolab.castor.xml.UnmarshalHandler;
 import org.exolab.castor.xml.Unmarshaller;
 import org.exolab.castor.xml.ValidationException;
+import org.exolab.castor.xml.XMLClassDescriptorResolver;
 import org.exolab.castor.xml.XMLContext;
 import org.exolab.castor.xml.XMLException;
 import org.w3c.dom.Node;
 import org.xml.sax.ContentHandler;
+import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.XMLReader;
@@ -56,30 +60,30 @@
 import org.springframework.oxm.support.AbstractMarshaller;
 import org.springframework.oxm.support.SaxResourceUtils;
 import org.springframework.util.ObjectUtils;
-import org.springframework.util.StringUtils;
 import org.springframework.util.xml.DomUtils;
 import org.springframework.util.xml.StaxUtils;
 
 /**
- * Implementation of the {@code Marshaller} interface for Castor. By default, Castor does not require any further
- * configuration, though setting target classes, target packages or providing a mapping file can be used to have more
- * control over the behavior of Castor.
+ * Implementation of the {@code Marshaller} interface for Castor. By default, Castor does
+ * not require any further configuration, though setting target classes, target packages or
+ * providing a mapping file can be used to have more control over the behavior of Castor.
  *
- * <p>If a target class is specified using {@code setTargetClass}, the {@code CastorMarshaller} can only be
- * used to unmarshal XML that represents that specific class. If you want to unmarshal multiple classes, you have to
- * provide a mapping file using {@code setMappingLocations}.
+ * <p>If a target class is specified using {@code setTargetClass}, the {@code CastorMarshaller}
+ * can only be used to unmarshal XML that represents that specific class. If you want to unmarshal
+ * multiple classes, you have to provide a mapping file using {@code setMappingLocations}.
  *
- * <p>Due to limitations of Castor's API, it is required to set the encoding used for writing to output streams. It
- * defaults to {@code UTF-8}.
+ * <p>Due to limitations of Castor's API, it is required to set the encoding used for
+ * writing to output streams. It defaults to {@code UTF-8}.
  *
  * @author Arjen Poutsma
  * @author Jakub Narloch
+ * @author Juergen Hoeller
+ * @since 3.0
  * @see #setEncoding(String)
  * @see #setTargetClass(Class)
  * @see #setTargetPackages(String[])
  * @see #setMappingLocation(Resource)
  * @see #setMappingLocations(Resource[])
- * @since 3.0
  */
 public class CastorMarshaller extends AbstractMarshaller implements InitializingBean, BeanClassLoaderAware {
 
@@ -88,6 +92,7 @@ public class CastorMarshaller extends AbstractMarshaller implements Initializing
 	 */
 	public static final String DEFAULT_ENCODING = "UTF-8";
 
+
 	private Resource[] mappingLocations;
 
 	private String encoding = DEFAULT_ENCODING;
@@ -98,47 +103,59 @@ public class CastorMarshaller extends AbstractMarshaller implements Initializing
 
 	private boolean validating = false;
 
-	private boolean whitespacePreserve = false;
-
-	private boolean ignoreExtraAttributes = true;
-
-	private boolean ignoreExtraElements = false;
-
-	private Map<String, String> namespaceMappings;
-
-	private XMLContext xmlContext;
-
 	private boolean suppressNamespaces = false;
 
 	private boolean suppressXsiType = false;
 
 	private boolean marshalAsDocument = true;
 
-	private String rootElement;
-
 	private boolean marshalExtendedType = true;
 
+	private String rootElement;
+
 	private String noNamespaceSchemaLocation;
 
 	private String schemaLocation;
 
 	private boolean useXSITypeAtRoot = false;
 
-	private Map<String, String> processingInstructions;
+	private boolean whitespacePreserve = false;
 
-	private Map<String, String> namespaceToPackageMapping;
+	private boolean ignoreExtraAttributes = true;
 
-	private ClassLoader classLoader;
+	private boolean ignoreExtraElements = false;
 
-	private Object root;
+	private Object rootObject;
 
 	private boolean reuseObjects = false;
 
 	private boolean clearCollections = false;
 
+	private Map<String, String> castorProperties;
+
+	private Map<String, String> doctypes;
+
+	private Map<String, String> processingInstructions;
+
+	private Map<String, String> namespaceMappings;
+
+	private Map<String, String> namespaceToPackageMapping;
+
+	private EntityResolver entityResolver;
+
+	private XMLClassDescriptorResolver classDescriptorResolver;
+
+	private IDResolver idResolver;
+
+	private ObjectFactory objectFactory;
+
+	private ClassLoader beanClassLoader;
+
+	private XMLContext xmlContext;
+
+
 	/**
 	 * Set the encoding to be used for stream access.
-	 *
 	 * @see #DEFAULT_ENCODING
 	 */
 	public void setEncoding(String encoding) {
@@ -146,7 +163,7 @@ public void setEncoding(String encoding) {
 	}
 
 	/**
-	 * Set the locations of the Castor XML Mapping files.
+	 * Set the locations of the Castor XML mapping files.
 	 */
 	public void setMappingLocation(Resource mappingLocation) {
 		this.mappingLocations = new Resource[]{mappingLocation};
@@ -190,8 +207,8 @@ public void setTargetPackages(String[] targetPackages) {
 	}
 
 	/**
-	 * Set whether this marshaller should validate in- and outgoing documents. <p>Default is {@code false}.
-	 *
+	 * Set whether this marshaller should validate in- and outgoing documents.
+	 * <p>Default is {@code false}.
 	 * @see Marshaller#setValidation(boolean)
 	 */
 	public void setValidating(boolean validating) {
@@ -199,152 +216,180 @@ public void setValidating(boolean validating) {
 	}
 
 	/**
-	 * Set whether the Castor {@link Unmarshaller} should preserve "ignorable" whitespace. <p>Default is
-	 * {@code false}.
-	 *
-	 * @see org.exolab.castor.xml.Unmarshaller#setWhitespacePreserve(boolean)
+	 * Sets whether this marshaller should output namespaces.
+	 * <p>The default is {@code false}, i.e. namespaces are written.
+	 * @see org.exolab.castor.xml.Marshaller#setSuppressNamespaces(boolean)
 	 */
-	public void setWhitespacePreserve(boolean whitespacePreserve) {
-		this.whitespacePreserve = whitespacePreserve;
+	public void setSuppressNamespaces(boolean suppressNamespaces) {
+		this.suppressNamespaces = suppressNamespaces;
 	}
 
 	/**
-	 * Set whether the Castor {@link Unmarshaller} should ignore attributes that do not match a specific field. <p>Default
-	 * is {@code true}: extra attributes are ignored.
-	 *
-	 * @see org.exolab.castor.xml.Unmarshaller#setIgnoreExtraAttributes(boolean)
+	 * Set whether this marshaller should output the {@code xsi:type} attribute.
+	 * <p>The default is {@code false}, i.e. the {@code xsi:type} is written.
+	 * @see org.exolab.castor.xml.Marshaller#setSuppressXSIType(boolean)
 	 */
-	public void setIgnoreExtraAttributes(boolean ignoreExtraAttributes) {
-		this.ignoreExtraAttributes = ignoreExtraAttributes;
+	public void setSuppressXsiType(boolean suppressXsiType) {
+		this.suppressXsiType = suppressXsiType;
 	}
 
 	/**
-	 * Set whether the Castor {@link Unmarshaller} should ignore elements that do not match a specific field. <p>Default
-	 * is
-	 * {@code false}, extra attributes are flagged as an error.
-	 *
-	 * @see org.exolab.castor.xml.Unmarshaller#setIgnoreExtraElements(boolean)
+	 * Set whether this marshaller should output the xml declaration.
+	 * <p>The default is {@code true}, the XML declaration will be written.
+	 * @see org.exolab.castor.xml.Marshaller#setMarshalAsDocument(boolean)
 	 */
-	public void setIgnoreExtraElements(boolean ignoreExtraElements) {
-		this.ignoreExtraElements = ignoreExtraElements;
+	public void setMarshalAsDocument(boolean marshalAsDocument) {
+		this.marshalAsDocument = marshalAsDocument;
 	}
 
 	/**
-	 * Set the namespace mappings. Property names are interpreted as namespace prefixes; values are namespace URIs.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setNamespaceMapping(String, String)
+	 * Set whether this marshaller should output for given type the {@code xsi:type} attribute.
+	 * <p>The default is {@code true}, the {@code xsi:type} attribute will be written.
+	 * @see org.exolab.castor.xml.Marshaller#setMarshalExtendedType(boolean)
 	 */
-	public void setNamespaceMappings(Map<String, String> namespaceMappings) {
-		this.namespaceMappings = namespaceMappings;
+	public void setMarshalExtendedType(boolean marshalExtendedType) {
+		this.marshalExtendedType = marshalExtendedType;
 	}
 
 	/**
-	 * Returns whether this marshaller should output namespaces.
+	 * Set the name of the root element.
+	 * @see org.exolab.castor.xml.Marshaller#setRootElement(String)
 	 */
-	public boolean isSuppressNamespaces() {
-		return suppressNamespaces;
+	public void setRootElement(String rootElement) {
+		this.rootElement = rootElement;
 	}
 
 	/**
-	 * Sets whether this marshaller should output namespaces. The default is {@code false}, i.e. namespaces are written.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setSuppressNamespaces(boolean)
+	 * Set the value of {@code xsi:noNamespaceSchemaLocation} attribute. When set, the
+	 * {@code xsi:noNamespaceSchemaLocation} attribute will be written for the root element.
+	 * @see org.exolab.castor.xml.Marshaller#setNoNamespaceSchemaLocation(String)
 	 */
-	public void setSuppressNamespaces(boolean suppressNamespaces) {
-		this.suppressNamespaces = suppressNamespaces;
+	public void setNoNamespaceSchemaLocation(String noNamespaceSchemaLocation) {
+		this.noNamespaceSchemaLocation = noNamespaceSchemaLocation;
 	}
 
 	/**
-	 * Sets whether this marshaller should output the xsi:type attribute.
+	 * Set the value of {@code xsi:schemaLocation} attribute. When set, the
+	 * {@code xsi:schemaLocation} attribute will be written for the root element.
+	 * @see org.exolab.castor.xml.Marshaller#setSchemaLocation(String)
 	 */
-	public boolean isSuppressXsiType() {
-		return suppressXsiType;
+	public void setSchemaLocation(String schemaLocation) {
+		this.schemaLocation = schemaLocation;
 	}
 
 	/**
-	 * Sets whether this marshaller should output the {@code xsi:type} attribute. The default is {@code false}, i.e. the
-	 * {@code xsi:type} is written.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setSuppressXSIType(boolean)
+	 * Sets whether this marshaller should output the {@code xsi:type} attribute for the root element.
+	 * This can be useful when the type of the element can not be simply determined from the element name.
+	 * <p>The default is {@code false}: The {@code xsi:type} attribute for the root element won't be written.
+	 * @see org.exolab.castor.xml.Marshaller#setUseXSITypeAtRoot(boolean)
 	 */
-	public void setSuppressXsiType(boolean suppressXsiType) {
-		this.suppressXsiType = suppressXsiType;
+	public void setUseXSITypeAtRoot(boolean useXSITypeAtRoot) {
+		this.useXSITypeAtRoot = useXSITypeAtRoot;
 	}
 
 	/**
-	 * Sets whether this marshaller should output the xml declaration. </p> The default is {@code true}, the xml
-	 * declaration will be written.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setMarshalAsDocument(boolean)
+	 * Set whether the Castor {@link Unmarshaller} should preserve "ignorable" whitespace.
+	 * <p>Default is {@code false}.
+	 * @see org.exolab.castor.xml.Unmarshaller#setWhitespacePreserve(boolean)
 	 */
-	public void setMarshalAsDocument(boolean marshalAsDocument) {
-		this.marshalAsDocument = marshalAsDocument;
+	public void setWhitespacePreserve(boolean whitespacePreserve) {
+		this.whitespacePreserve = whitespacePreserve;
 	}
 
 	/**
-	 * Sets the name of the root element.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setRootElement(String)
+	 * Set whether the Castor {@link Unmarshaller} should ignore attributes that do not match a specific field.
+	 * <p>Default is {@code true}: Extra attributes are ignored.
+	 * @see org.exolab.castor.xml.Unmarshaller#setIgnoreExtraAttributes(boolean)
 	 */
-	public void setRootElement(String rootElement) {
-		this.rootElement = rootElement;
+	public void setIgnoreExtraAttributes(boolean ignoreExtraAttributes) {
+		this.ignoreExtraAttributes = ignoreExtraAttributes;
 	}
 
 	/**
-	 * Sets whether this marshaller should output for given type the {@code xsi:type} attribute.</p> The default is {@code
-	 * true}, the {@code xsi:type} attribute will be written.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setMarshalExtendedType(boolean)
+	 * Set whether the Castor {@link Unmarshaller} should ignore elements that do not match a specific field.
+	 * <p>Default is {@code false}: Extra elements are flagged as an error.
+	 * @see org.exolab.castor.xml.Unmarshaller#setIgnoreExtraElements(boolean)
 	 */
-	public void setMarshalExtendedType(boolean marshalExtendedType) {
-		this.marshalExtendedType = marshalExtendedType;
+	public void setIgnoreExtraElements(boolean ignoreExtraElements) {
+		this.ignoreExtraElements = ignoreExtraElements;
 	}
 
 	/**
-	 * Sets the value of {@code xsi:noNamespaceSchemaLocation} attribute. When set, the {@code
-	 * xsi:noNamespaceSchemaLocation} attribute will be written for the root element.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setNoNamespaceSchemaLocation(String)
+	 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
+	 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
+	 * @deprecated in favor of {@link #setRootObject}
 	 */
-	public void setNoNamespaceSchemaLocation(String noNamespaceSchemaLocation) {
-		this.noNamespaceSchemaLocation = noNamespaceSchemaLocation;
+	@Deprecated
+	public void setObject(Object root) {
+		this.rootObject = root;
 	}
 
 	/**
-	 * Sets the value of {@code xsi:schemaLocation} attribute.When set, the {@code xsi:schemaLocation} attribute will be
-	 * written for the root element.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setSchemaLocation(String)
+	 * Set the expected root object for the unmarshaller, into which the source will be unmarshalled.
+	 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
 	 */
-	public void setSchemaLocation(String schemaLocation) {
-		this.schemaLocation = schemaLocation;
+	public void setRootObject(Object root) {
+		this.rootObject = root;
 	}
 
 	/**
-	 * Sets whether this marshaller should output the {@code xsi:type} attribute for the root element. This can be useful
-	 * when the type of the element can not be simply determined from the element name. </p> The default is {@code false},
-	 * the {@code xsi:type} attribute for the root element won't be written.
-	 *
-	 * @see org.exolab.castor.xml.Marshaller#setUseXSITypeAtRoot(boolean)
+	 * Set whether this unmarshaller should re-use objects.
+	 * This will be only used when unmarshalling to an existing object.
+	 * <p>The default is {@code false}, which means that the objects won't be re-used.
+	 * @see org.exolab.castor.xml.Unmarshaller#setReuseObjects(boolean)
 	 */
-	public void setUseXSITypeAtRoot(boolean useXSITypeAtRoot) {
-		this.useXSITypeAtRoot = useXSITypeAtRoot;
+	public void setReuseObjects(boolean reuseObjects) {
+		this.reuseObjects = reuseObjects;
 	}
 
 	/**
-	 * Sets the processing instructions that will be used by during marshalling. Keys are the processing targets and
-	 * values
-	 * contain the processing data.
-	 *
+	 * Sets whether this unmarshaller should clear collections upon the first use.
+	 * <p>The default is {@code false} which means that marshaller won't clear collections.
+	 * @see org.exolab.castor.xml.Unmarshaller#setClearCollections(boolean)
+	 */
+	public void setClearCollections(boolean clearCollections) {
+		this.clearCollections = clearCollections;
+	}
+
+	/**
+	 * Set Castor-specific properties for marshalling and unmarshalling.
+	 * Each entry key is considered the property name and each value the property value.
+	 * @see org.exolab.castor.xml.Marshaller#setProperty(String, String)
+	 * @see org.exolab.castor.xml.Unmarshaller#setProperty(String, String)
+	 */
+	public void setCastorProperties(Map<String, String> castorProperties) {
+		this.castorProperties = castorProperties;
+	}
+
+	/**
+	 * Set the map containing document type definition for the marshaller.
+	 * Each entry has system id as key and public id as value.
+	 * @see org.exolab.castor.xml.Marshaller#setDoctype(String, String)
+	 */
+	public void setDoctypes(Map<String, String> doctypes) {
+		this.doctypes = doctypes;
+	}
+
+	/**
+	 * Sets the processing instructions that will be used by during marshalling.
+	 * Keys are the processing targets and values contain the processing data.
 	 * @see org.exolab.castor.xml.Marshaller#addProcessingInstruction(String, String)
 	 */
 	public void setProcessingInstructions(Map<String, String> processingInstructions) {
 		this.processingInstructions = processingInstructions;
 	}
 
+	/**
+	 * Set the namespace mappings.
+	 * Property names are interpreted as namespace prefixes; values are namespace URIs.
+	 * @see org.exolab.castor.xml.Marshaller#setNamespaceMapping(String, String)
+	 */
+	public void setNamespaceMappings(Map<String, String> namespaceMappings) {
+		this.namespaceMappings = namespaceMappings;
+	}
+
 	/**
 	 * Set the namespace to package mappings. Property names are represents the namespaces URI, values are packages.
-	 *
 	 * @see org.exolab.castor.xml.Marshaller#setNamespaceMapping(String, String)
 	 */
 	public void setNamespaceToPackageMapping(Map<String, String> namespaceToPackageMapping) {
@@ -352,58 +397,45 @@ public void setNamespaceToPackageMapping(Map<String, String> namespaceToPackageM
 	}
 
 	/**
-	 * Sets the expected object for the unmarshaller, into which the source will be unmarshalled.
-	 *
-	 * @see org.exolab.castor.xml.Unmarshaller#setObject(Object)
+	 * Set the {@link EntityResolver} to be used during unmarshalling.
+	 * This resolver will used to resolve system and public ids.
+	 * @see org.exolab.castor.xml.Unmarshaller#setEntityResolver(EntityResolver)
 	 */
-	public void setObject(Object root) {
-		this.root = root;
+	public void setEntityResolver(EntityResolver entityResolver) {
+		this.entityResolver = entityResolver;
 	}
 
 	/**
-	 * Sets whether this unmarshaller should re-use objects. This will be only used when unmarshalling to existing
-	 * object. </p> The default is {@code false}, which means that the objects won't be re-used.
-	 *
-	 * @see org.exolab.castor.xml.Unmarshaller#setReuseObjects(boolean)
+	 * Set the {@link XMLClassDescriptorResolver} to be used during unmarshalling.
+	 * This resolver will used to resolve class descriptors.
+	 * @see org.exolab.castor.xml.Unmarshaller#setResolver(XMLClassDescriptorResolver)
 	 */
-	public void setReuseObjects(boolean reuseObjects) {
-		this.reuseObjects = reuseObjects;
+	public void setClassDescriptorResolver(XMLClassDescriptorResolver classDescriptorResolver) {
+		this.classDescriptorResolver = classDescriptorResolver;
 	}
 
 	/**
-	 * Sets whether this unmarshaller should clear collections upon the first use. </p> The default is {@code false},
-	 * which means that marshaller won't clear collections.
-	 *
-	 * @see org.exolab.castor.xml.Unmarshaller#setClearCollections(boolean)
+	 * Set the Castor {@link IDResolver} to be used during unmarshalling.
+	 * @see org.exolab.castor.xml.Unmarshaller#setIDResolver(IDResolver)
 	 */
-	public void setClearCollections(boolean clearCollections) {
-		this.clearCollections = clearCollections;
+	public void setIdResolver(IDResolver idResolver) {
+		this.idResolver = idResolver;
+	}
+
+	/**
+	 * Set the Castor {@link ObjectFactory} to be used during unmarshalling.
+	 * @see org.exolab.castor.xml.Unmarshaller#setObjectFactory(ObjectFactory)
+	 */
+	public void setObjectFactory(ObjectFactory objectFactory) {
+		this.objectFactory = objectFactory;
 	}
 
 	public void setBeanClassLoader(ClassLoader classLoader) {
-		this.classLoader = classLoader;
+		this.beanClassLoader = classLoader;
 	}
 
-	public final void afterPropertiesSet() throws CastorMappingException, IOException {
-		if (logger.isInfoEnabled()) {
-			if (!ObjectUtils.isEmpty(this.mappingLocations)) {
-				logger.info(
-						"Configured using [" + StringUtils.arrayToCommaDelimitedString(this.mappingLocations) + "]");
-			}
-			if (!ObjectUtils.isEmpty(this.targetClasses)) {
-				logger.info("Configured for target classes " + StringUtils.arrayToCommaDelimitedString(targetClasses) +
-						"]");
-			}
-			if (!ObjectUtils.isEmpty(this.targetPackages)) {
-				logger.info(
-						"Configured for target packages [" + StringUtils.arrayToCommaDelimitedString(targetPackages) +
-								"]");
-			}
-			if (ObjectUtils.isEmpty(this.mappingLocations) && ObjectUtils.isEmpty(this.targetClasses) &&
-					ObjectUtils.isEmpty(this.targetPackages)) {
-				logger.info("Using default configuration");
-			}
-		}
+
+	public void afterPropertiesSet() throws CastorMappingException, IOException {
 		try {
 			this.xmlContext = createXMLContext(this.mappingLocations, this.targetClasses, this.targetPackages);
 		}
@@ -416,9 +448,8 @@ public final void afterPropertiesSet() throws CastorMappingException, IOExceptio
 	}
 
 	/**
-	 * Create the Castor {@code XMLContext}. Subclasses can override this to create a custom context. <p> The default
-	 * implementation loads mapping files if defined, or the target class or packages if defined.
-	 *
+	 * Create the Castor {@code XMLContext}. Subclasses can override this to create a custom context.
+	 * <p>The default implementation loads mapping files if defined, or the target class or packages if defined.
 	 * @return the created resolver
 	 * @throws MappingException when the mapping file cannot be loaded
 	 * @throws IOException in case of I/O errors
@@ -442,9 +473,15 @@ protected XMLContext createXMLContext(Resource[] mappingLocations, Class[] targe
 		if (!ObjectUtils.isEmpty(targetPackages)) {
 			context.addPackages(targetPackages);
 		}
+		if (this.castorProperties != null) {
+			for (Map.Entry<String, String> property : this.castorProperties.entrySet()) {
+				context.setProperty(property.getKey(), property.getValue());
+			}
+		}
 		return context;
 	}
 
+
 	/**
 	 * Returns {@code true} for all classes, i.e. Castor supports arbitrary classes.
 	 */
@@ -462,6 +499,7 @@ protected final void marshalDomNode(Object graph, Node node) throws XmlMappingEx
 	@Override
 	protected final void marshalSaxHandlers(Object graph, ContentHandler contentHandler, LexicalHandler lexicalHandler)
 			throws XmlMappingException {
+
 		Marshaller marshaller = xmlContext.createMarshaller();
 		marshaller.setContentHandler(contentHandler);
 		marshal(graph, marshaller);
@@ -470,6 +508,7 @@ protected final void marshalSaxHandlers(Object graph, ContentHandler contentHand
 	@Override
 	protected final void marshalOutputStream(Object graph, OutputStream outputStream)
 			throws XmlMappingException, IOException {
+
 		marshalWriter(graph, new OutputStreamWriter(outputStream, encoding));
 	}
 
@@ -502,42 +541,29 @@ private void marshal(Object graph, Marshaller marshaller) {
 
 	/**
 	 * Template method that allows for customizing of the given Castor {@link Marshaller}.
-	 *
-	 * </p>The default implementation invokes
-	 * <ol>
-	 * <li>{@link Marshaller#setValidation(boolean)},</li>
-	 * <li>{@link Marshaller#setSuppressNamespaces(boolean)},</li>
-	 * <li>{@link Marshaller#setSuppressXSIType(boolean)}, </li>
-	 * <li>{@link Marshaller#setMarshalAsDocument(boolean)}, </li>
-	 * <li>{@link Marshaller#setRootElement(String)},</li>
-	 * <li>{@link Marshaller#setMarshalExtendedType(boolean)},</li>
-	 * <li>{@link Marshaller#setNoNamespaceSchemaLocation(String)},</li>
-	 * <li>{@link Marshaller#setSchemaLocation(String)} and</li>
-	 * <li>{@link Marshaller#setUseXSITypeAtRoot(boolean)}.</li>
-	 * </ol>
-	 * with the property set on this marshaller.
-	 * It also calls {@link Marshaller#setNamespaceMapping(String, String)}
-	 * with the {@linkplain #setNamespaceMappings(java.util.Map) namespace mappings} and
-	 * {@link Marshaller#addProcessingInstruction(String, String)} with the
-	 * {@linkplain #setProcessingInstructions(java.util.Map) processing instructions}.
 	 */
 	protected void customizeMarshaller(Marshaller marshaller) {
 		marshaller.setValidation(this.validating);
-		marshaller.setSuppressNamespaces(isSuppressNamespaces());
-		marshaller.setSuppressXSIType(isSuppressXsiType());
-		marshaller.setMarshalAsDocument(marshalAsDocument);
-		marshaller.setRootElement(rootElement);
-		marshaller.setMarshalExtendedType(marshalExtendedType);
-		marshaller.setNoNamespaceSchemaLocation(noNamespaceSchemaLocation);
-		marshaller.setSchemaLocation(schemaLocation);
-		marshaller.setUseXSITypeAtRoot(useXSITypeAtRoot);
-		if (processingInstructions != null) {
-			for (Map.Entry<String, String> processingInstruction : processingInstructions.entrySet()) {
+		marshaller.setSuppressNamespaces(this.suppressNamespaces);
+		marshaller.setSuppressXSIType(this.suppressXsiType);
+		marshaller.setMarshalAsDocument(this.marshalAsDocument);
+		marshaller.setMarshalExtendedType(this.marshalExtendedType);
+		marshaller.setRootElement(this.rootElement);
+		marshaller.setNoNamespaceSchemaLocation(this.noNamespaceSchemaLocation);
+		marshaller.setSchemaLocation(this.schemaLocation);
+		marshaller.setUseXSITypeAtRoot(this.useXSITypeAtRoot);
+		if (this.doctypes != null) {
+			for (Map.Entry<String, String> doctype : this.doctypes.entrySet()) {
+				marshaller.setDoctype(doctype.getKey(), doctype.getValue());
+			}
+		}
+		if (this.processingInstructions != null) {
+			for (Map.Entry<String, String> processingInstruction : this.processingInstructions.entrySet()) {
 				marshaller.addProcessingInstruction(processingInstruction.getKey(), processingInstruction.getValue());
 			}
 		}
 		if (this.namespaceMappings != null) {
-			for (Map.Entry<String, String> entry : namespaceMappings.entrySet()) {
+			for (Map.Entry<String, String> entry : this.namespaceMappings.entrySet()) {
 				marshaller.setNamespaceMapping(entry.getKey(), entry.getValue());
 			}
 		}
@@ -619,48 +645,45 @@ private Unmarshaller createUnmarshaller() {
 
 	/**
 	 * Template method that allows for customizing of the given Castor {@link Unmarshaller}.
-	 *
-	 * </p> The default implementation invokes
-	 * <ol>
-	 * <li>{@link Unmarshaller#setValidation(boolean)},
-	 * <li>{@link Unmarshaller#setWhitespacePreserve(boolean)},
-	 * <li>{@link Unmarshaller#setIgnoreExtraAttributes(boolean)},
-	 * <li>{@link Unmarshaller#setIgnoreExtraElements(boolean)},
-	 * <li>{@link Unmarshaller#setClassLoader(ClassLoader)},
-	 * <li>{@link Unmarshaller#setObject(Object)},
-	 * <li>{@link Unmarshaller#setReuseObjects(boolean)} and
-	 * <li>{@link Unmarshaller#setClearCollections(boolean)}
-	 * </ol>
-	 * with the properties set on this marshaller.
-	 * It also calls {@link Unmarshaller#addNamespaceToPackageMapping(String, String)} with the
-	 * {@linkplain #setNamespaceMappings(java.util.Map) namespace to package mapping}.
 	 */
 	protected void customizeUnmarshaller(Unmarshaller unmarshaller) {
 		unmarshaller.setValidation(this.validating);
 		unmarshaller.setWhitespacePreserve(this.whitespacePreserve);
 		unmarshaller.setIgnoreExtraAttributes(this.ignoreExtraAttributes);
 		unmarshaller.setIgnoreExtraElements(this.ignoreExtraElements);
-		unmarshaller.setClassLoader(classLoader);
-		unmarshaller.setObject(root);
-		unmarshaller.setReuseObjects(reuseObjects);
-		unmarshaller.setClearCollections(clearCollections);
-		if (namespaceToPackageMapping != null) {
-			for (Map.Entry<String, String> mapping : namespaceToPackageMapping.entrySet()) {
+		unmarshaller.setObject(this.rootObject);
+		unmarshaller.setReuseObjects(this.reuseObjects);
+		unmarshaller.setClearCollections(this.clearCollections);
+		if (this.namespaceToPackageMapping != null) {
+			for (Map.Entry<String, String> mapping : this.namespaceToPackageMapping.entrySet()) {
 				unmarshaller.addNamespaceToPackageMapping(mapping.getKey(), mapping.getValue());
 			}
 		}
-
+		if (this.entityResolver != null) {
+			unmarshaller.setEntityResolver(this.entityResolver);
+		}
+		if (this.classDescriptorResolver != null) {
+			unmarshaller.setResolver(this.classDescriptorResolver);
+		}
+		if (this.idResolver != null) {
+			unmarshaller.setIDResolver(this.idResolver);
+		}
+		if (this.objectFactory != null) {
+			unmarshaller.setObjectFactory(this.objectFactory);
+		}
+		if (this.beanClassLoader != null) {
+			unmarshaller.setClassLoader(this.beanClassLoader);
+		}
 	}
 
 	/**
 	 * Convert the given {@code XMLException} to an appropriate exception from the
-	 * {@code org.springframework.oxm} hierarchy. <p> A boolean flag is used to indicate whether this exception
-	 * occurs
-	 * during marshalling or unmarshalling, since Castor itself does not make this distinction in its exception hierarchy.
-	 *
+	 * {@code org.springframework.oxm} hierarchy.
+	 * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or
+	 * unmarshalling, since Castor itself does not make this distinction in its exception hierarchy.
 	 * @param ex Castor {@code XMLException} that occurred
-	 * @param marshalling indicates whether the exception occurs during marshalling ({@code true}), or unmarshalling
-	 * ({@code false})
+	 * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),
+	 * or unmarshalling ({@code false})
 	 * @return the corresponding {@code XmlMappingException}
 	 */
 	protected XmlMappingException convertCastorException(XMLException ex, boolean marshalling) {
diff --git a/spring-oxm/src/main/java/org/springframework/oxm/jaxb/Jaxb2Marshaller.java b/spring-oxm/src/main/java/org/springframework/oxm/jaxb/Jaxb2Marshaller.java
index 956c00323339..4ffd0c495d62 100644
--- a/spring-oxm/src/main/java/org/springframework/oxm/jaxb/Jaxb2Marshaller.java
+++ b/spring-oxm/src/main/java/org/springframework/oxm/jaxb/Jaxb2Marshaller.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -155,14 +155,16 @@ public class Jaxb2Marshaller
 
 	private LSResourceResolver schemaResourceResolver;
 
-	private boolean mtomEnabled = false;
-
 	private boolean lazyInit = false;
 
+	private boolean mtomEnabled = false;
+
 	private boolean supportJaxbElementClass = false;
 
 	private boolean checkForXmlRootElement = true;
 
+	private Class<?> mappedClass;
+
 	private ClassLoader beanClassLoader;
 
 	private ResourceLoader resourceLoader;
@@ -329,14 +331,6 @@ public void setSchemaResourceResolver(LSResourceResolver schemaResourceResolver)
 		this.schemaResourceResolver = schemaResourceResolver;
 	}
 
-	/**
-	 * Specify whether MTOM support should be enabled or not.
-	 * Default is {@code false}: marshalling using XOP/MTOM not being enabled.
-	 */
-	public void setMtomEnabled(boolean mtomEnabled) {
-		this.mtomEnabled = mtomEnabled;
-	}
-
 	/**
 	 * Set whether to lazily initialize the {@link JAXBContext} for this marshaller.
 	 * Default is {@code false} to initialize on startup; can be switched to {@code true}.
@@ -346,14 +340,22 @@ public void setLazyInit(boolean lazyInit) {
 		this.lazyInit = lazyInit;
 	}
 
+	/**
+	 * Specify whether MTOM support should be enabled or not.
+	 * Default is {@code false}: marshalling using XOP/MTOM not being enabled.
+	 */
+	public void setMtomEnabled(boolean mtomEnabled) {
+		this.mtomEnabled = mtomEnabled;
+	}
+
 	/**
 	 * Specify whether the {@link #supports(Class)} returns {@code true} for the {@link JAXBElement} class.
 	 * <p>Default is {@code false}, meaning that {@code supports(Class)} always returns {@code false} for
-	 * {@code JAXBElement} classes (though {@link #supports(Type)} can return {@code true}, since it can obtain the
-	 * type parameters of {@code JAXBElement}).
+	 * {@code JAXBElement} classes (though {@link #supports(Type)} can return {@code true}, since it can
+	 * obtain the type parameters of {@code JAXBElement}).
 	 * <p>This property is typically enabled in combination with usage of classes like
-	 * {@link org.springframework.web.servlet.view.xml.MarshallingView MarshallingView}, since the {@code ModelAndView}
-	 * does not offer type parameter information at runtime.
+	 * {@link org.springframework.web.servlet.view.xml.MarshallingView MarshallingView},
+	 * since the {@code ModelAndView} does not offer type parameter information at runtime.
 	 * @see #supports(Class)
 	 * @see #supports(Type)
 	 */
@@ -376,6 +378,14 @@ public void setCheckForXmlRootElement(boolean checkForXmlRootElement) {
 		this.checkForXmlRootElement = checkForXmlRootElement;
 	}
 
+	/**
+	 * Specify a JAXB mapped class for partial unmarshalling.
+	 * @see javax.xml.bind.Unmarshaller#unmarshal(javax.xml.transform.Source, Class)
+	 */
+	public void setMappedClass(Class<?> mappedClass) {
+		this.mappedClass = mappedClass;
+	}
+
 	public void setBeanClassLoader(ClassLoader classLoader) {
 		this.beanClassLoader = classLoader;
 	}
@@ -384,6 +394,7 @@ public void setResourceLoader(ResourceLoader resourceLoader) {
 		this.resourceLoader = resourceLoader;
 	}
 
+
 	public final void afterPropertiesSet() throws Exception {
 		boolean hasContextPath = StringUtils.hasLength(this.contextPath);
 		boolean hasClassesToBeBound = !ObjectUtils.isEmpty(this.classesToBeBound);
@@ -406,7 +417,10 @@ public final void afterPropertiesSet() throws Exception {
 		}
 	}
 
-	protected JAXBContext getJaxbContext() {
+	/**
+	 * Return the JAXBContext used by this marshaller, lazily building it if necessary.
+	 */
+	public JAXBContext getJaxbContext() {
 		if (this.jaxbContext != null) {
 			return this.jaxbContext;
 		}
@@ -514,10 +528,8 @@ private Schema loadSchema(Resource[] resources, String schemaLanguage) throws IO
 
 
 	public boolean supports(Class<?> clazz) {
-		if (this.supportJaxbElementClass && JAXBElement.class.isAssignableFrom(clazz)) {
-			return true;
-		}
-		return supportsInternal(clazz, this.checkForXmlRootElement);
+		return ((this.supportJaxbElementClass && JAXBElement.class.isAssignableFrom(clazz)) ||
+				supportsInternal(clazz, this.checkForXmlRootElement));
 	}
 
 	public boolean supports(Type genericType) {
@@ -707,6 +719,9 @@ public Object unmarshal(Source source, MimeContainer mimeContainer) throws XmlMa
 			if (StaxUtils.isStaxSource(source)) {
 				return unmarshalStaxSource(unmarshaller, source);
 			}
+			else if (this.mappedClass != null) {
+				return unmarshaller.unmarshal(source, this.mappedClass);
+			}
 			else {
 				return unmarshaller.unmarshal(source);
 			}
@@ -716,7 +731,7 @@ public Object unmarshal(Source source, MimeContainer mimeContainer) throws XmlMa
 		}
 	}
 
-	private Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource) throws JAXBException {
+	protected Object unmarshalStaxSource(Unmarshaller jaxbUnmarshaller, Source staxSource) throws JAXBException {
 		XMLStreamReader streamReader = StaxUtils.getXMLStreamReader(staxSource);
 		if (streamReader != null) {
 			return jaxbUnmarshaller.unmarshal(streamReader);
diff --git a/spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java b/spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java
index b53c20a5b92a..dd36d17b8bfd 100644
--- a/spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java
+++ b/spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamMarshaller.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -114,7 +114,7 @@ public class XStreamMarshaller extends AbstractMarshaller implements Initializin
 	/**
 	 * Returns the XStream instance used by this marshaller.
 	 */
-	public XStream getXStream() {
+	public final XStream getXStream() {
 		return this.xstream;
 	}
 
@@ -125,7 +125,7 @@ public XStream getXStream() {
 	 * @see XStream#NO_REFERENCES
 	 */
 	public void setMode(int mode) {
-		this.getXStream().setMode(mode);
+		this.xstream.setMode(mode);
 	}
 
 	/**
@@ -137,10 +137,10 @@ public void setMode(int mode) {
 	public void setConverters(ConverterMatcher[] converters) {
 		for (int i = 0; i < converters.length; i++) {
 			if (converters[i] instanceof Converter) {
-				this.getXStream().registerConverter((Converter) converters[i], i);
+				this.xstream.registerConverter((Converter) converters[i], i);
 			}
 			else if (converters[i] instanceof SingleValueConverter) {
-				this.getXStream().registerConverter((SingleValueConverter) converters[i], i);
+				this.xstream.registerConverter((SingleValueConverter) converters[i], i);
 			}
 			else {
 				throw new IllegalArgumentException("Invalid ConverterMatcher [" + converters[i] + "]");
@@ -155,9 +155,8 @@ else if (converters[i] instanceof SingleValueConverter) {
 	 */
 	public void setAliases(Map<String, ?> aliases) throws ClassNotFoundException {
 		Map<String, Class<?>> classMap = toClassMap(aliases);
-
 		for (Map.Entry<String, Class<?>> entry : classMap.entrySet()) {
-			this.getXStream().alias(entry.getKey(), entry.getValue());
+			this.xstream.alias(entry.getKey(), entry.getValue());
 		}
 	}
 
@@ -169,15 +168,13 @@ public void setAliases(Map<String, ?> aliases) throws ClassNotFoundException {
 	 */
 	public void setAliasesByType(Map<String, ?> aliases) throws ClassNotFoundException {
 		Map<String, Class<?>> classMap = toClassMap(aliases);
-
 		for (Map.Entry<String, Class<?>> entry : classMap.entrySet()) {
-			this.getXStream().aliasType(entry.getKey(), entry.getValue());
+			this.xstream.aliasType(entry.getKey(), entry.getValue());
 		}
 	}
 
 	private Map<String, Class<?>> toClassMap(Map<String, ?> map) throws ClassNotFoundException {
 		Map<String, Class<?>> result = new LinkedHashMap<String, Class<?>>(map.size());
-
 		for (Map.Entry<String, ?> entry : map.entrySet()) {
 			String key = entry.getKey();
 			Object value = entry.getValue();
@@ -198,10 +195,7 @@ else if (value instanceof String) {
 	}
 
 	/**
-	 * Sets a field alias/type map, consiting of field names
-	 * @param aliases
-	 * @throws ClassNotFoundException
-	 * @throws NoSuchFieldException
+	 * Set a field alias/type map, consiting of field names.
 	 * @see XStream#aliasField(String, Class, String)
 	 */
 	public void setFieldAliases(Map<String, String> aliases) throws ClassNotFoundException, NoSuchFieldException {
@@ -213,8 +207,9 @@ public void setFieldAliases(Map<String, String> aliases) throws ClassNotFoundExc
 				String className = field.substring(0, idx);
 				Class clazz = ClassUtils.forName(className, classLoader);
 				String fieldName = field.substring(idx + 1);
-				this.getXStream().aliasField(alias, clazz, fieldName);
-			} else {
+				this.xstream.aliasField(alias, clazz, fieldName);
+			}
+			else {
 				throw new IllegalArgumentException("Field name [" + field + "] does not contain '.'");
 			}
 		}
@@ -226,7 +221,7 @@ public void setFieldAliases(Map<String, String> aliases) throws ClassNotFoundExc
 	 */
 	public void setUseAttributeForTypes(Class[] types) {
 		for (Class type : types) {
-			this.getXStream().useAttributeFor(type);
+			this.xstream.useAttributeFor(type);
 		}
 	}
 
@@ -242,7 +237,7 @@ public void setUseAttributeFor(Map<?, ?> attributes) {
 		for (Map.Entry<?, ?> entry : attributes.entrySet()) {
 			if (entry.getKey() instanceof String) {
 				if (entry.getValue() instanceof Class) {
-					this.getXStream().useAttributeFor((String) entry.getKey(), (Class) entry.getValue());
+					this.xstream.useAttributeFor((String) entry.getKey(), (Class) entry.getValue());
 				}
 				else {
 					throw new IllegalArgumentException(
@@ -253,14 +248,14 @@ public void setUseAttributeFor(Map<?, ?> attributes) {
 			else if (entry.getKey() instanceof Class) {
 				Class<?> key = (Class<?>) entry.getKey();
 				if (entry.getValue() instanceof String) {
-					this.getXStream().useAttributeFor(key, (String) entry.getValue());
+					this.xstream.useAttributeFor(key, (String) entry.getValue());
 				}
 				else if (entry.getValue() instanceof List) {
 					List list = (List) entry.getValue();
 
 					for (Object o : list) {
 						if (o instanceof String) {
-							this.getXStream().useAttributeFor(key, (String) o);
+							this.xstream.useAttributeFor(key, (String) o);
 						}
 					}
 				}
@@ -286,7 +281,7 @@ public void setImplicitCollections(Map<Class<?>, String> implicitCollections) {
 		for (Map.Entry<Class<?>, String> entry : implicitCollections.entrySet()) {
 			String[] collectionFields = StringUtils.commaDelimitedListToStringArray(entry.getValue());
 			for (String collectionField : collectionFields) {
-				this.getXStream().addImplicitCollection(entry.getKey(), collectionField);
+				this.xstream.addImplicitCollection(entry.getKey(), collectionField);
 			}
 		}
 	}
@@ -300,7 +295,7 @@ public void setOmittedFields(Map<Class<?>, String> omittedFields) {
 		for (Map.Entry<Class<?>, String> entry : omittedFields.entrySet()) {
 			String[] fields = StringUtils.commaDelimitedListToStringArray(entry.getValue());
 			for (String field : fields) {
-				this.getXStream().omitField(entry.getKey(), field);
+				this.xstream.omitField(entry.getKey(), field);
 			}
 		}
 	}
@@ -311,7 +306,7 @@ public void setOmittedFields(Map<Class<?>, String> omittedFields) {
 	 */
 	public void setAnnotatedClass(Class<?> annotatedClass) {
 		Assert.notNull(annotatedClass, "'annotatedClass' must not be null");
-		this.getXStream().processAnnotations(annotatedClass);
+		this.xstream.processAnnotations(annotatedClass);
 	}
 
 	/**
@@ -320,7 +315,7 @@ public void setAnnotatedClass(Class<?> annotatedClass) {
 	 */
 	public void setAnnotatedClasses(Class<?>[] annotatedClasses) {
 		Assert.notEmpty(annotatedClasses, "'annotatedClasses' must not be empty");
-		this.getXStream().processAnnotations(annotatedClasses);
+		this.xstream.processAnnotations(annotatedClasses);
 	}
 
 	/**
@@ -330,7 +325,7 @@ public void setAnnotatedClasses(Class<?>[] annotatedClasses) {
 	 * @see XStream#autodetectAnnotations(boolean)
 	 */
 	public void setAutodetectAnnotations(boolean autodetectAnnotations) {
-		this.getXStream().autodetectAnnotations(autodetectAnnotations);
+		this.xstream.autodetectAnnotations(autodetectAnnotations);
 	}
 
 	/**
@@ -363,7 +358,7 @@ public void setBeanClassLoader(ClassLoader classLoader) {
 
 
 	public final void afterPropertiesSet() throws Exception {
-		customizeXStream(getXStream());
+		customizeXStream(this.xstream);
 	}
 
 	/**
@@ -458,7 +453,7 @@ protected void marshalWriter(Object graph, Writer writer) throws XmlMappingExcep
 	 */
 	private void marshal(Object graph, HierarchicalStreamWriter streamWriter) {
 		try {
-			getXStream().marshal(graph, streamWriter);
+			this.xstream.marshal(graph, streamWriter);
 		}
 		catch (Exception ex) {
 			throw convertXStreamException(ex, true);
@@ -541,7 +536,7 @@ protected Object unmarshalSaxReader(XMLReader xmlReader, InputSource inputSource
      */
     private Object unmarshal(HierarchicalStreamReader streamReader) {
         try {
-            return getXStream().unmarshal(streamReader);
+            return this.xstream.unmarshal(streamReader);
         }
         catch (Exception ex) {
             throw convertXStreamException(ex, false);
@@ -574,4 +569,5 @@ protected XmlMappingException convertXStreamException(Exception ex, boolean mars
 			return new UncategorizedMappingException("Unknown XStream exception", ex);
 		}
 	}
+
 }
diff --git a/spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamUtils.java b/spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamUtils.java
deleted file mode 100644
index 04f53b6973b5..000000000000
--- a/spring-oxm/src/main/java/org/springframework/oxm/xstream/XStreamUtils.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2002-2012 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.oxm.xstream;
-
-import com.thoughtworks.xstream.converters.ConversionException;
-import com.thoughtworks.xstream.io.StreamException;
-import com.thoughtworks.xstream.mapper.CannotResolveClassException;
-
-import org.springframework.oxm.MarshallingFailureException;
-import org.springframework.oxm.UncategorizedMappingException;
-import org.springframework.oxm.UnmarshallingFailureException;
-import org.springframework.oxm.XmlMappingException;
-
-/**
- * Generic utility methods for working with XStream. Mainly for internal use within the framework.
- *
- * @author Arjen Poutsma
- * @author Juergen Hoeller
- * @since 3.0
- */
-abstract class XStreamUtils {
-
-	/**
-	 * Convert the given XStream exception to an appropriate exception from the
-	 * {@code org.springframework.oxm} hierarchy.
-	 * <p>A boolean flag is used to indicate whether this exception occurs during marshalling or
-	 * unmarshalling, since XStream itself does not make this distinction in its exception hierarchy.
-	 * @param ex XStream exception that occured
-	 * @param marshalling indicates whether the exception occurs during marshalling ({@code true}),
-	 * or unmarshalling ({@code false})
-	 * @return the corresponding {@code XmlMappingException}
-	 */
-	public static XmlMappingException convertXStreamException(Exception ex, boolean marshalling) {
-		if (ex instanceof StreamException || ex instanceof CannotResolveClassException ||
-				ex instanceof ConversionException) {
-			if (marshalling) {
-				return new MarshallingFailureException("XStream marshalling exception",  ex);
-			}
-			else {
-				return new UnmarshallingFailureException("XStream unmarshalling exception", ex);
-			}
-		}
-		else {
-			// fallback
-			return new UncategorizedMappingException("Unknown XStream exception", ex);
-		}
-	}
-
-}
diff --git a/spring-oxm/src/test/java/org/springframework/oxm/castor/CastorMarshallerTests.java b/spring-oxm/src/test/java/org/springframework/oxm/castor/CastorMarshallerTests.java
index 1ffc53630447..8178d7045225 100644
--- a/spring-oxm/src/test/java/org/springframework/oxm/castor/CastorMarshallerTests.java
+++ b/spring-oxm/src/test/java/org/springframework/oxm/castor/CastorMarshallerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,6 @@
 
 package org.springframework.oxm.castor;
 
-import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
-import static org.easymock.EasyMock.aryEq;
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.isA;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-
 import java.io.StringWriter;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -39,6 +30,7 @@
 import org.custommonkey.xmlunit.XpathEngine;
 import org.junit.Assert;
 import org.junit.Test;
+import org.mockito.InOrder;
 import org.springframework.core.io.ClassPathResource;
 import org.springframework.oxm.AbstractMarshallerTests;
 import org.springframework.oxm.Marshaller;
@@ -47,6 +39,11 @@
 import org.xml.sax.Attributes;
 import org.xml.sax.ContentHandler;
 
+import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Tests the {@link CastorMarshaller} class.
  *
@@ -126,26 +123,21 @@ protected Object createFlights() {
 
 	@Test
 	public void marshalSaxResult() throws Exception {
-		ContentHandler handlerMock = createMock(ContentHandler.class);
-		handlerMock.startDocument();
-		handlerMock.startPrefixMapping("tns", "http://samples.springframework.org/flight");
-		handlerMock.startElement(eq("http://samples.springframework.org/flight"), eq("flights"), eq("tns:flights"),
-				isA(Attributes.class));
-		handlerMock.startElement(eq("http://samples.springframework.org/flight"), eq("flight"), eq("tns:flight"),
-				isA(Attributes.class));
-		handlerMock.startElement(eq("http://samples.springframework.org/flight"), eq("number"), eq("tns:number"),
-				isA(Attributes.class));
-		handlerMock.characters(aryEq(new char[]{'4', '2'}), eq(0), eq(2));
-		handlerMock.endElement("http://samples.springframework.org/flight", "number", "tns:number");
-		handlerMock.endElement("http://samples.springframework.org/flight", "flight", "tns:flight");
-		handlerMock.endElement("http://samples.springframework.org/flight", "flights", "tns:flights");
-		handlerMock.endPrefixMapping("tns");
-		handlerMock.endDocument();
-
-		replay(handlerMock);
-		SAXResult result = new SAXResult(handlerMock);
+		ContentHandler contentHandler = mock(ContentHandler.class);
+		SAXResult result = new SAXResult(contentHandler);
 		marshaller.marshal(flights, result);
-		verify(handlerMock);
+		InOrder ordered = inOrder(contentHandler);
+		ordered.verify(contentHandler).startDocument();
+		ordered.verify(contentHandler).startPrefixMapping("tns", "http://samples.springframework.org/flight");
+		ordered.verify(contentHandler).startElement(eq("http://samples.springframework.org/flight"), eq("flights"), eq("tns:flights"), isA(Attributes.class));
+		ordered.verify(contentHandler).startElement(eq("http://samples.springframework.org/flight"), eq("flight"), eq("tns:flight"), isA(Attributes.class));
+		ordered.verify(contentHandler).startElement(eq("http://samples.springframework.org/flight"), eq("number"), eq("tns:number"), isA(Attributes.class));
+		ordered.verify(contentHandler).characters(eq(new char[]{'4', '2'}), eq(0), eq(2));
+		ordered.verify(contentHandler).endElement("http://samples.springframework.org/flight", "number", "tns:number");
+		ordered.verify(contentHandler).endElement("http://samples.springframework.org/flight", "flight", "tns:flight");
+		ordered.verify(contentHandler).endElement("http://samples.springframework.org/flight", "flights", "tns:flights");
+		ordered.verify(contentHandler).endPrefixMapping("tns");
+		ordered.verify(contentHandler).endDocument();
 	}
 
 	@Test
@@ -300,7 +292,6 @@ private void assertXpathEvaluatesTo(String msg, String expected, String xpath, S
 
 		Document doc = XMLUnit.buildControlDocument(xmlDoc);
 		NodeList node = engine.getMatchingNodes(xpath, doc);
-
 		assertEquals(msg, expected, node.item(0).getNodeValue());
 	}
 
diff --git a/spring-oxm/src/test/java/org/springframework/oxm/castor/CastorUnmarshallerTests.java b/spring-oxm/src/test/java/org/springframework/oxm/castor/CastorUnmarshallerTests.java
index 367b4aa5c15e..585640893be5 100644
--- a/spring-oxm/src/test/java/org/springframework/oxm/castor/CastorUnmarshallerTests.java
+++ b/spring-oxm/src/test/java/org/springframework/oxm/castor/CastorUnmarshallerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,12 +30,9 @@
 import org.springframework.oxm.Unmarshaller;
 
 import static org.hamcrest.CoreMatchers.*;
-
 import static org.junit.Assert.*;
 
 /**
- * Tests the {@link CastorMarshaller} class.
- *
  * @author Arjen Poutsma
  * @author Jakub Narloch
  */
@@ -114,7 +111,6 @@ public void testSetBothTargetClassesAndMapping() throws IOException {
 
 	@Test
 	public void testWhitespacePreserveTrue() throws Exception {
-
 		getCastorUnmarshaller().setWhitespacePreserve(true);
 		Object result = unmarshalFlights();
 		testFlights(result);
@@ -122,7 +118,6 @@ public void testWhitespacePreserveTrue() throws Exception {
 
 	@Test
 	public void testWhitespacePreserveFalse() throws Exception {
-
 		getCastorUnmarshaller().setWhitespacePreserve(false);
 		Object result = unmarshalFlights();
 		testFlights(result);
@@ -130,7 +125,6 @@ public void testWhitespacePreserveFalse() throws Exception {
 
 	@Test
 	public void testIgnoreExtraAttributesTrue() throws Exception {
-
 		getCastorUnmarshaller().setIgnoreExtraAttributes(true);
 		Object result = unmarshal(EXTRA_ATTRIBUTES_STRING);
 		testFlights(result);
@@ -146,7 +140,6 @@ public void testIgnoreExtraAttributesFalse() throws Exception {
 	@Test
 	@Ignore("Not working yet")
 	public void testIgnoreExtraElementsTrue() throws Exception {
-
 		getCastorUnmarshaller().setIgnoreExtraElements(true);
 		getCastorUnmarshaller().setValidating(false);
 		Object result = unmarshal(EXTRA_ELEMENTS_STRING);
@@ -161,22 +154,19 @@ public void testIgnoreExtraElementsFalse() throws Exception {
 	}
 
 	@Test
-	public void testObject() throws Exception {
-
+	public void testRootObject() throws Exception {
 		Flights flights = new Flights();
-		getCastorUnmarshaller().setObject(flights);
+		getCastorUnmarshaller().setRootObject(flights);
 		Object result = unmarshalFlights();
-
 		testFlights(result);
 		assertSame("Result Flights is different object.", flights, result);
 	}
 
 	@Test
 	public void testClearCollectionsTrue() throws Exception {
-
 		Flights flights = new Flights();
 		flights.setFlight(new Flight[]{new Flight()});
-		getCastorUnmarshaller().setObject(flights);
+		getCastorUnmarshaller().setRootObject(flights);
 		getCastorUnmarshaller().setClearCollections(true);
 		Object result = unmarshalFlights();
 
@@ -188,10 +178,9 @@ public void testClearCollectionsTrue() throws Exception {
 	@Test
 	@Ignore("Fails on the builder server for some reason")
 	public void testClearCollectionsFalse() throws Exception {
-
 		Flights flights = new Flights();
 		flights.setFlight(new Flight[]{new Flight(), null});
-		getCastorUnmarshaller().setObject(flights);
+		getCastorUnmarshaller().setRootObject(flights);
 		getCastorUnmarshaller().setClearCollections(false);
 		Object result = unmarshalFlights();
 
diff --git a/spring-oxm/src/test/java/org/springframework/oxm/jaxb/Jaxb2MarshallerTests.java b/spring-oxm/src/test/java/org/springframework/oxm/jaxb/Jaxb2MarshallerTests.java
index 3d7a49786715..aa3eca07778f 100644
--- a/spring-oxm/src/test/java/org/springframework/oxm/jaxb/Jaxb2MarshallerTests.java
+++ b/spring-oxm/src/test/java/org/springframework/oxm/jaxb/Jaxb2MarshallerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,19 +16,6 @@
 
 package org.springframework.oxm.jaxb;
 
-import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.createStrictMock;
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.expectLastCall;
-import static org.easymock.EasyMock.isA;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.io.ByteArrayOutputStream;
 import java.io.StringWriter;
 import java.lang.reflect.InvocationTargetException;
@@ -47,6 +34,7 @@
 import javax.xml.transform.stream.StreamResult;
 
 import org.junit.Test;
+import org.mockito.InOrder;
 import org.springframework.core.io.ClassPathResource;
 import org.springframework.core.io.Resource;
 import org.springframework.oxm.AbstractMarshallerTests;
@@ -63,6 +51,10 @@
 import org.xml.sax.ContentHandler;
 import org.xml.sax.Locator;
 
+import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 public class Jaxb2MarshallerTests extends AbstractMarshallerTests {
 
 	private static final String CONTEXT_PATH = "org.springframework.oxm.jaxb.test";
@@ -90,27 +82,22 @@ protected Object createFlights() {
 
 	@Test
 	public void marshalSAXResult() throws Exception {
-		ContentHandler handlerMock = createStrictMock(ContentHandler.class);
-		handlerMock.setDocumentLocator(isA(Locator.class));
-		handlerMock.startDocument();
-		handlerMock.startPrefixMapping("", "http://samples.springframework.org/flight");
-		handlerMock.startElement(eq("http://samples.springframework.org/flight"), eq("flights"), eq("flights"),
-				isA(Attributes.class));
-		handlerMock.startElement(eq("http://samples.springframework.org/flight"), eq("flight"), eq("flight"),
-				isA(Attributes.class));
-		handlerMock.startElement(eq("http://samples.springframework.org/flight"), eq("number"), eq("number"),
-				isA(Attributes.class));
-		handlerMock.characters(isA(char[].class), eq(0), eq(2));
-		handlerMock.endElement("http://samples.springframework.org/flight", "number", "number");
-		handlerMock.endElement("http://samples.springframework.org/flight", "flight", "flight");
-		handlerMock.endElement("http://samples.springframework.org/flight", "flights", "flights");
-		handlerMock.endPrefixMapping("");
-		handlerMock.endDocument();
-		replay(handlerMock);
-
-		SAXResult result = new SAXResult(handlerMock);
+		ContentHandler contentHandler = mock(ContentHandler.class);
+		SAXResult result = new SAXResult(contentHandler);
 		marshaller.marshal(flights, result);
-		verify(handlerMock);
+		InOrder ordered = inOrder(contentHandler);
+		ordered.verify(contentHandler).setDocumentLocator(isA(Locator.class));
+		ordered.verify(contentHandler).startDocument();
+		ordered.verify(contentHandler).startPrefixMapping("", "http://samples.springframework.org/flight");
+		ordered.verify(contentHandler).startElement(eq("http://samples.springframework.org/flight"), eq("flights"), eq("flights"), isA(Attributes.class));
+		ordered.verify(contentHandler).startElement(eq("http://samples.springframework.org/flight"), eq("flight"), eq("flight"), isA(Attributes.class));
+		ordered.verify(contentHandler).startElement(eq("http://samples.springframework.org/flight"), eq("number"), eq("number"), isA(Attributes.class));
+		ordered.verify(contentHandler).characters(isA(char[].class), eq(0), eq(2));
+		ordered.verify(contentHandler).endElement("http://samples.springframework.org/flight", "number", "number");
+		ordered.verify(contentHandler).endElement("http://samples.springframework.org/flight", "flight", "flight");
+		ordered.verify(contentHandler).endElement("http://samples.springframework.org/flight", "flights", "flights");
+		ordered.verify(contentHandler).endPrefixMapping("");
+		ordered.verify(contentHandler).endDocument();
 	}
 
 	@Test
@@ -280,25 +267,22 @@ public void marshalAttachments() throws Exception {
 		marshaller.setClassesToBeBound(BinaryObject.class);
 		marshaller.setMtomEnabled(true);
 		marshaller.afterPropertiesSet();
-		MimeContainer mimeContainer = createMock(MimeContainer.class);
+		MimeContainer mimeContainer = mock(MimeContainer.class);
 
 		Resource logo = new ClassPathResource("spring-ws.png", getClass());
 		DataHandler dataHandler = new DataHandler(new FileDataSource(logo.getFile()));
 
-		expect(mimeContainer.convertToXopPackage()).andReturn(true);
-		mimeContainer.addAttachment(isA(String.class), isA(DataHandler.class));
-		expectLastCall().times(3);
-
-		replay(mimeContainer);
+		given(mimeContainer.convertToXopPackage()).willReturn(true);
 		byte[] bytes = FileCopyUtils.copyToByteArray(logo.getInputStream());
 		BinaryObject object = new BinaryObject(bytes, dataHandler);
 		StringWriter writer = new StringWriter();
 		marshaller.marshal(object, new StreamResult(writer), mimeContainer);
-		verify(mimeContainer);
 		assertTrue("No XML written", writer.toString().length() > 0);
+		verify(mimeContainer, times(3)).addAttachment(isA(String.class), isA(DataHandler.class));
 	}
 
 	@XmlRootElement
+	@SuppressWarnings("unused")
 	public static class DummyRootElement {
 
 		private DummyType t = new DummyType();
@@ -306,15 +290,19 @@ public static class DummyRootElement {
 	}
 
 	@XmlType
+	@SuppressWarnings("unused")
 	public static class DummyType {
 
 		private String s = "Hello";
+
 	}
 
+	@SuppressWarnings("unused")
 	private JAXBElement<DummyRootElement> createDummyRootElement() {
 		return null;
 	}
 
+	@SuppressWarnings("unused")
 	private JAXBElement<DummyType> createDummyType() {
 		return null;
 	}
diff --git a/spring-oxm/src/test/java/org/springframework/oxm/jaxb/Jaxb2UnmarshallerTests.java b/spring-oxm/src/test/java/org/springframework/oxm/jaxb/Jaxb2UnmarshallerTests.java
index 8b4ce76a802e..55a3f8d22649 100644
--- a/spring-oxm/src/test/java/org/springframework/oxm/jaxb/Jaxb2UnmarshallerTests.java
+++ b/spring-oxm/src/test/java/org/springframework/oxm/jaxb/Jaxb2UnmarshallerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2010 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package org.springframework.oxm.jaxb;
 
 import java.io.StringReader;
+
 import javax.activation.DataHandler;
 import javax.activation.FileDataSource;
 import javax.xml.bind.JAXBElement;
@@ -25,10 +26,7 @@
 import javax.xml.transform.Source;
 import javax.xml.transform.stream.StreamSource;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
 import org.junit.Test;
-
 import org.springframework.core.io.ClassPathResource;
 import org.springframework.core.io.Resource;
 import org.springframework.oxm.AbstractUnmarshallerTests;
@@ -38,6 +36,9 @@
 import org.springframework.oxm.mime.MimeContainer;
 import org.springframework.util.xml.StaxUtils;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 public class Jaxb2UnmarshallerTests extends AbstractUnmarshallerTests {
 
 	private static final String INPUT_STRING = "<tns:flights xmlns:tns=\"http://samples.springframework.org/flight\">" +
@@ -60,19 +61,15 @@ public void marshalAttachments() throws Exception {
 		unmarshaller.setClassesToBeBound(BinaryObject.class);
 		unmarshaller.setMtomEnabled(true);
 		unmarshaller.afterPropertiesSet();
-		MimeContainer mimeContainer = createMock(MimeContainer.class);
+		MimeContainer mimeContainer = mock(MimeContainer.class);
 
 		Resource logo = new ClassPathResource("spring-ws.png", getClass());
 		DataHandler dataHandler = new DataHandler(new FileDataSource(logo.getFile()));
 
-		expect(mimeContainer.isXopPackage()).andReturn(true);
-		expect(mimeContainer.getAttachment(
-				"<6b76528d-7a9c-4def-8e13-095ab89e9bb7@http://springframework.org/spring-ws>")).andReturn(dataHandler);
-		expect(mimeContainer.getAttachment(
-				"<99bd1592-0521-41a2-9688-a8bfb40192fb@http://springframework.org/spring-ws>")).andReturn(dataHandler);
-		expect(mimeContainer.getAttachment("696cfb9a-4d2d-402f-bb5c-59fa69e7f0b3@spring-ws.png"))
-				.andReturn(dataHandler);
-		replay(mimeContainer);
+		given(mimeContainer.isXopPackage()).willReturn(true);
+		given(mimeContainer.getAttachment("<6b76528d-7a9c-4def-8e13-095ab89e9bb7@http://springframework.org/spring-ws>")).willReturn(dataHandler);
+		given(mimeContainer.getAttachment("<99bd1592-0521-41a2-9688-a8bfb40192fb@http://springframework.org/spring-ws>")).willReturn(dataHandler);
+		given(mimeContainer.getAttachment("696cfb9a-4d2d-402f-bb5c-59fa69e7f0b3@spring-ws.png")).willReturn(dataHandler);
 		String content = "<binaryObject xmlns='http://springframework.org/spring-ws'>" + "<bytes>" +
 				"<xop:Include href='cid:6b76528d-7a9c-4def-8e13-095ab89e9bb7@http://springframework.org/spring-ws' xmlns:xop='http://www.w3.org/2004/08/xop/include'/>" +
 				"</bytes>" + "<dataHandler>" +
@@ -84,7 +81,6 @@ public void marshalAttachments() throws Exception {
 		StringReader reader = new StringReader(content);
 		Object result = unmarshaller.unmarshal(new StreamSource(reader), mimeContainer);
 		assertTrue("Result is not a BinaryObject", result instanceof BinaryObject);
-		verify(mimeContainer);
 		BinaryObject object = (BinaryObject) result;
 		assertNotNull("bytes property not set", object.getBytes());
 		assertTrue("bytes property not set", object.getBytes().length > 0);
diff --git a/spring-oxm/src/test/java/org/springframework/oxm/xstream/XStreamMarshallerTests.java b/spring-oxm/src/test/java/org/springframework/oxm/xstream/XStreamMarshallerTests.java
index 7979e4d5c523..ce49ce166d79 100644
--- a/spring-oxm/src/test/java/org/springframework/oxm/xstream/XStreamMarshallerTests.java
+++ b/spring-oxm/src/test/java/org/springframework/oxm/xstream/XStreamMarshallerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,6 +25,7 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.stream.XMLEventWriter;
@@ -36,26 +37,28 @@
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 
-import com.thoughtworks.xstream.converters.Converter;
-import com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;
-import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
-import com.thoughtworks.xstream.io.json.JettisonMappedXmlDriver;
-import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;
-import com.thoughtworks.xstream.io.json.JsonWriter;
-import static org.custommonkey.xmlunit.XMLAssert.*;
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.InOrder;
+import org.springframework.util.xml.StaxUtils;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Text;
 import org.xml.sax.Attributes;
 import org.xml.sax.ContentHandler;
 
-import org.springframework.util.xml.StaxUtils;
+import com.thoughtworks.xstream.converters.Converter;
+import com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;
+import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
+import com.thoughtworks.xstream.io.json.JettisonMappedXmlDriver;
+import com.thoughtworks.xstream.io.json.JsonHierarchicalStreamDriver;
+import com.thoughtworks.xstream.io.json.JsonWriter;
+
+import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
+import static org.custommonkey.xmlunit.XMLAssert.assertXpathExists;
+import static org.custommonkey.xmlunit.XMLAssert.assertXpathNotExists;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Arjen Poutsma
@@ -143,19 +146,17 @@ public void marshalStreamResultOutputStream() throws Exception {
 
 	@Test
 	public void marshalSaxResult() throws Exception {
-		ContentHandler handlerMock = createStrictMock(ContentHandler.class);
-		handlerMock.startDocument();
-		handlerMock.startElement(eq(""), eq("flight"), eq("flight"), isA(Attributes.class));
-		handlerMock.startElement(eq(""), eq("flightNumber"), eq("flightNumber"), isA(Attributes.class));
-		handlerMock.characters(isA(char[].class), eq(0), eq(2));
-		handlerMock.endElement("", "flightNumber", "flightNumber");
-		handlerMock.endElement("", "flight", "flight");
-		handlerMock.endDocument();
-
-		replay(handlerMock);
-		SAXResult result = new SAXResult(handlerMock);
+		ContentHandler contentHandler = mock(ContentHandler.class);
+		SAXResult result = new SAXResult(contentHandler);
 		marshaller.marshal(flight, result);
-		verify(handlerMock);
+		InOrder ordered = inOrder(contentHandler);
+		ordered.verify(contentHandler).startDocument();
+		ordered.verify(contentHandler).startElement(eq(""), eq("flight"), eq("flight"), isA(Attributes.class));
+		ordered.verify(contentHandler).startElement(eq(""), eq("flightNumber"), eq("flightNumber"), isA(Attributes.class));
+		ordered.verify(contentHandler).characters(isA(char[].class), eq(0), eq(2));
+		ordered.verify(contentHandler).endElement("", "flightNumber", "flightNumber");
+		ordered.verify(contentHandler).endElement("", "flight", "flight");
+		ordered.verify(contentHandler).endDocument();
 	}
 
 	@Test
diff --git a/spring-struts/src/main/java/org/springframework/web/struts/package-info.java b/spring-struts/src/main/java/org/springframework/web/struts/package-info.java
index b299f31263d4..33fe62fa5298 100644
--- a/spring-struts/src/main/java/org/springframework/web/struts/package-info.java
+++ b/spring-struts/src/main/java/org/springframework/web/struts/package-info.java
@@ -25,4 +25,4 @@
  * </ul>
  */
 @Deprecated
-package org.springframework.web.struts;
\ No newline at end of file
+package org.springframework.web.struts;
diff --git a/spring-struts/src/test/java/org/springframework/web/struts/StrutsSupportTests.java b/spring-struts/src/test/java/org/springframework/web/struts/StrutsSupportTests.java
index ad97b300b558..22db7be93aac 100644
--- a/spring-struts/src/test/java/org/springframework/web/struts/StrutsSupportTests.java
+++ b/spring-struts/src/test/java/org/springframework/web/struts/StrutsSupportTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
+
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 
@@ -26,16 +27,16 @@
 import org.apache.struts.action.ActionMapping;
 import org.apache.struts.action.ActionServlet;
 import org.apache.struts.config.ModuleConfig;
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
 import org.junit.Test;
-
 import org.springframework.mock.web.MockHttpServletRequest;
 import org.springframework.mock.web.MockHttpServletResponse;
 import org.springframework.mock.web.MockServletContext;
 import org.springframework.web.context.WebApplicationContext;
 import org.springframework.web.context.support.StaticWebApplicationContext;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 09.04.2004
@@ -228,9 +229,8 @@ public ServletContext getServletContext() {
 			}
 		};
 
-		ModuleConfig moduleConfig = createMock(ModuleConfig.class);
-		expect(moduleConfig.getPrefix()).andReturn("").anyTimes();
-		replay(moduleConfig);
+		ModuleConfig moduleConfig = mock(ModuleConfig.class);
+		given(moduleConfig.getPrefix()).willReturn("");
 
 		plugin.init(actionServlet, moduleConfig);
 		assertTrue(servletContext.getAttribute(ContextLoaderPlugIn.SERVLET_CONTEXT_PREFIX) != null);
@@ -249,8 +249,6 @@ public ServletContext getServletContext() {
 		proxy.setServlet(null);
 		plugin.destroy();
 		assertTrue(testAction.getServlet() == null);
-
-		verify(moduleConfig);
 	}
 
 	@Test
@@ -270,9 +268,8 @@ public ServletContext getServletContext() {
 			}
 		};
 
-		ModuleConfig moduleConfig = createMock(ModuleConfig.class);
-		expect(moduleConfig.getPrefix()).andReturn("/module").anyTimes();
-		replay(moduleConfig);
+		ModuleConfig moduleConfig = mock(ModuleConfig.class);
+		given(moduleConfig.getPrefix()).willReturn("/module");
 
 		plugin.init(actionServlet, moduleConfig);
 		assertTrue(servletContext.getAttribute(ContextLoaderPlugIn.SERVLET_CONTEXT_PREFIX) == null);
@@ -313,13 +310,12 @@ public ServletContext getServletContext() {
 			}
 		};
 
-		ModuleConfig defaultModuleConfig = createMock(ModuleConfig.class);
-		expect(defaultModuleConfig.getPrefix()).andReturn("").anyTimes();
+		ModuleConfig defaultModuleConfig = mock(ModuleConfig.class);
+		given(defaultModuleConfig.getPrefix()).willReturn("");
 
-		ModuleConfig moduleConfig = createMock(ModuleConfig.class);
-		expect(moduleConfig.getPrefix()).andReturn("/module").anyTimes();
+		ModuleConfig moduleConfig = mock(ModuleConfig.class);
+		given(moduleConfig.getPrefix()).willReturn("/module");
 
-		replay(defaultModuleConfig, moduleConfig);
 
 		plugin.init(actionServlet, defaultModuleConfig);
 		assertTrue(servletContext.getAttribute(ContextLoaderPlugIn.SERVLET_CONTEXT_PREFIX) != null);
@@ -339,8 +335,6 @@ public ServletContext getServletContext() {
 		proxy.setServlet(null);
 		plugin.destroy();
 		assertTrue(testAction.getServlet() == null);
-
-		verify(defaultModuleConfig, moduleConfig);
 	}
 
 }
diff --git a/spring-test-mvc/src/main/java/org/springframework/test/util/JsonPathExpectationsHelper.java b/spring-test-mvc/src/main/java/org/springframework/test/util/JsonPathExpectationsHelper.java
index 054e3b18c9aa..87608730ad30 100644
--- a/spring-test-mvc/src/main/java/org/springframework/test/util/JsonPathExpectationsHelper.java
+++ b/spring-test-mvc/src/main/java/org/springframework/test/util/JsonPathExpectationsHelper.java
@@ -17,7 +17,8 @@
 package org.springframework.test.util;
 
 import static org.springframework.test.util.AssertionErrors.assertEquals;
-import static org.springframework.test.util.AssertionErrors.*;
+import static org.springframework.test.util.AssertionErrors.assertTrue;
+import static org.springframework.test.util.AssertionErrors.fail;
 import static org.springframework.test.util.MatcherAssertionErrors.assertThat;
 
 import java.text.ParseException;
@@ -96,6 +97,10 @@ public void assertValue(String responseContent, Object expectedValue) throws Par
 			}
 			actualValue = actualValueList.get(0);
 		}
+		else if (actualValue != null && expectedValue != null) {
+			assertEquals("For JSON path " + this.expression + " type of value",
+					expectedValue.getClass(), actualValue.getClass());
+		}
 		assertEquals("JSON path" + this.expression, expectedValue, actualValue);
 	}
 
diff --git a/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilder.java b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilder.java
index 8be3cf86ea46..78ff9d2d565c 100644
--- a/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilder.java
+++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilder.java
@@ -84,15 +84,16 @@ public Object merge(Object parent) {
 		if (parent == null) {
 			return this;
 		}
-		if (!(parent instanceof MockMultipartHttpServletRequestBuilder)) {
+		if (parent instanceof MockHttpServletRequestBuilder) {
+			super.merge(parent);
+			if (parent instanceof MockMultipartHttpServletRequestBuilder) {
+				MockMultipartHttpServletRequestBuilder parentBuilder = (MockMultipartHttpServletRequestBuilder) parent;
+				this.files.addAll(parentBuilder.files);
+			}
+		}
+		else {
 			throw new IllegalArgumentException("Cannot merge with [" + parent.getClass().getName() + "]");
 		}
-
-		super.merge(parent);
-
-		MockMultipartHttpServletRequestBuilder parentBuilder = (MockMultipartHttpServletRequestBuilder) parent;
-		this.files.addAll(parentBuilder.files);
-
 		return this;
 	}
 
diff --git a/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/result/FlashAttributeResultMatchers.java b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/result/FlashAttributeResultMatchers.java
index 61c2f37df67f..a2747bb102d9 100644
--- a/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/result/FlashAttributeResultMatchers.java
+++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/result/FlashAttributeResultMatchers.java
@@ -57,7 +57,6 @@ public void match(MvcResult result) throws Exception {
 	 */
 	public <T> ResultMatcher attribute(final String name, final Object value) {
 		return new ResultMatcher() {
-			@SuppressWarnings("unchecked")
 			public void match(MvcResult result) throws Exception {
 				assertEquals("Flash attribute", value, result.getFlashMap().get(name));
 			}
diff --git a/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/setup/DefaultMockMvcBuilder.java b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/setup/DefaultMockMvcBuilder.java
index a44f43a816ce..7e8b7afd6355 100644
--- a/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/setup/DefaultMockMvcBuilder.java
+++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/setup/DefaultMockMvcBuilder.java
@@ -42,7 +42,7 @@
  * @author Rob Winch
  * @since 3.2
  */
-public class DefaultMockMvcBuilder<Self extends MockMvcBuilder> extends MockMvcBuilderSupport
+public class DefaultMockMvcBuilder<Self extends DefaultMockMvcBuilder> extends MockMvcBuilderSupport
 		implements MockMvcBuilder {
 
 	private final WebApplicationContext webAppContext;
diff --git a/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/setup/StandaloneMockMvcBuilder.java b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/setup/StandaloneMockMvcBuilder.java
index b9597c196e8b..079a42fc012a 100644
--- a/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/setup/StandaloneMockMvcBuilder.java
+++ b/spring-test-mvc/src/main/java/org/springframework/test/web/servlet/setup/StandaloneMockMvcBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -201,15 +201,22 @@ public StandaloneMockMvcBuilder setCustomReturnValueHandlers(HandlerMethodReturn
 		return this;
 	}
 
-
 	/**
-	 * Set the HandlerExceptionResolver types to use.
+	 * Set the HandlerExceptionResolver types to use as a list.
 	 */
 	public StandaloneMockMvcBuilder setHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {
 		this.handlerExceptionResolvers = exceptionResolvers;
 		return this;
 	}
 
+	/**
+	 * Set the HandlerExceptionResolver types to use as an array.
+	 */
+	public StandaloneMockMvcBuilder setHandlerExceptionResolvers(HandlerExceptionResolver... exceptionResolvers) {
+		this.handlerExceptionResolvers = Arrays.asList(exceptionResolvers);
+		return this;
+	}
+
 	/**
 	 * Set up view resolution with the given {@link ViewResolver}s.
 	 * If not set, an {@link InternalResourceViewResolver} is used by default.
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/util/JsonPathExpectationsHelperTests.java b/spring-test-mvc/src/test/java/org/springframework/test/util/JsonPathExpectationsHelperTests.java
new file mode 100644
index 000000000000..b3f42091ef4e
--- /dev/null
+++ b/spring-test-mvc/src/test/java/org/springframework/test/util/JsonPathExpectationsHelperTests.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2004-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import org.junit.Test;
+
+
+/**
+ * Test fixture for {@link JsonPathExpectationsHelper}.
+ *
+ * @author Rossen Stoyanchev
+ */
+public class JsonPathExpectationsHelperTests {
+
+
+	@Test
+	public void test() throws Exception {
+		try {
+			new JsonPathExpectationsHelper("$.nr").assertValue("{ \"nr\" : 5 }", "5");
+			fail("Expected exception");
+		}
+		catch (AssertionError ex) {
+			assertEquals("For JSON path $.nr type of value expected:<class java.lang.String> but was:<class java.lang.Integer>",
+					ex.getMessage());
+		}
+	}
+
+}
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/DefaultMvcResultTests.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/DefaultMvcResultTests.java
index 56d4c5b40ddd..b0488791f9f5 100644
--- a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/DefaultMvcResultTests.java
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/DefaultMvcResultTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,20 +15,17 @@
  */
 package org.springframework.test.web.servlet;
 
-import static org.easymock.EasyMock.expect;
-import static org.easymock.classextension.EasyMock.replay;
-import static org.easymock.classextension.EasyMock.verify;
-
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 import javax.servlet.AsyncContext;
 
-import org.easymock.classextension.EasyMock;
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.mock.web.MockHttpServletRequest;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test fixture for {@link DefaultMvcResult}.
  *
@@ -48,7 +45,7 @@ public void setup() {
 		ExtendedMockHttpServletRequest request = new ExtendedMockHttpServletRequest();
 		request.setAsyncStarted(true);
 
-		this.countDownLatch = EasyMock.createMock(CountDownLatch.class);
+		this.countDownLatch = mock(CountDownLatch.class);
 
 		this.mvcResult = new DefaultMvcResult(request, null);
 		this.mvcResult.setAsyncResultLatch(this.countDownLatch);
@@ -57,50 +54,35 @@ public void setup() {
 	@Test
 	public void getAsyncResultWithTimeout() throws Exception {
 		long timeout = 1234L;
-
-		expect(this.countDownLatch.await(timeout, TimeUnit.MILLISECONDS)).andReturn(true);
-		replay(this.countDownLatch);
-
+		given(this.countDownLatch.await(timeout, TimeUnit.MILLISECONDS)).willReturn(true);
 		this.mvcResult.getAsyncResult(timeout);
-
-		verify(this.countDownLatch);
+		verify(this.countDownLatch).await(timeout, TimeUnit.MILLISECONDS);
 	}
 
 	@Test
 	public void getAsyncResultWithTimeoutNegativeOne() throws Exception {
-		expect(this.countDownLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)).andReturn(true);
-		replay(this.countDownLatch);
-
+		given(this.countDownLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)).willReturn(true);
 		this.mvcResult.getAsyncResult(-1);
-
-		verify(this.countDownLatch);
+		verify(this.countDownLatch).await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
 	}
 
 	@Test
 	public void getAsyncResultWithoutTimeout() throws Exception {
-		expect(this.countDownLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)).andReturn(true);
-		replay(this.countDownLatch);
-
+		given(this.countDownLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)).willReturn(true);
 		this.mvcResult.getAsyncResult();
-
-		verify(this.countDownLatch);
+		verify(this.countDownLatch).await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
 	}
 
 	@Test
 	public void getAsyncResultWithTimeoutZero() throws Exception {
-		replay(this.countDownLatch);
-
 		this.mvcResult.getAsyncResult(0);
-
-		verify(this.countDownLatch);
+		verifyZeroInteractions(this.countDownLatch);
 	}
 
 	@Test(expected=IllegalStateException.class)
 	public void getAsyncResultAndTimeOut() throws Exception {
-		expect(this.countDownLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)).andReturn(false);
-		replay(this.countDownLatch);
-
 		this.mvcResult.getAsyncResult(-1);
+		verify(this.countDownLatch).await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
 	}
 
 
@@ -111,9 +93,8 @@ private static class ExtendedMockHttpServletRequest extends MockHttpServletReque
 
 		public ExtendedMockHttpServletRequest() {
 			super();
-			this.asyncContext = EasyMock.createMock(AsyncContext.class);
-			expect(this.asyncContext.getTimeout()).andReturn(new Long(DEFAULT_TIMEOUT));
-			replay(this.asyncContext);
+			this.asyncContext = mock(AsyncContext.class);
+			given(this.asyncContext.getTimeout()).willReturn(new Long(DEFAULT_TIMEOUT));
 		}
 
 		public void setAsyncStarted(boolean asyncStarted) {
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilderTests.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilderTests.java
new file mode 100644
index 000000000000..e73e3dd4c334
--- /dev/null
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilderTests.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2004-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.web.servlet.request;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import org.junit.Test;
+import org.springframework.http.HttpMethod;
+import org.springframework.mock.web.MockHttpServletRequest;
+import org.springframework.mock.web.MockServletContext;
+
+
+/**
+ * Test fixture for {@link MockMultipartHttpServletRequestBuilder}.
+ *
+ * @author Rossen Stoyanchev
+ */
+public class MockMultipartHttpServletRequestBuilderTests {
+
+
+	@Test
+	public void test() {
+		MockHttpServletRequestBuilder parent = new MockHttpServletRequestBuilder(HttpMethod.GET, "/");
+		parent.characterEncoding("UTF-8");
+		Object result = new MockMultipartHttpServletRequestBuilder("/fileUpload").merge(parent);
+
+		assertNotNull(result);
+		assertEquals(MockMultipartHttpServletRequestBuilder.class, result.getClass());
+
+		MockMultipartHttpServletRequestBuilder builder = (MockMultipartHttpServletRequestBuilder) result;
+		MockHttpServletRequest request = builder.buildRequest(new MockServletContext());
+
+		assertEquals("UTF-8", request.getCharacterEncoding());
+	}
+
+}
\ No newline at end of file
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/JavaConfigTests.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/JavaConfigTests.java
index fb75d1048f6c..63ee9376bf9f 100644
--- a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/JavaConfigTests.java
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/JavaConfigTests.java
@@ -16,20 +16,21 @@
 
 package org.springframework.test.web.servlet.samples.context;
 
-import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
-import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.forwardedUrl;
-import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.Mockito;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.http.MediaType;
 import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 import org.springframework.test.context.web.WebAppConfiguration;
+import org.springframework.test.web.Person;
 import org.springframework.test.web.servlet.MockMvc;
+import org.springframework.test.web.servlet.samples.context.JavaConfigTests.RootConfig;
 import org.springframework.test.web.servlet.samples.context.JavaConfigTests.WebConfig;
 import org.springframework.test.web.servlet.setup.MockMvcBuilders;
 import org.springframework.web.context.WebApplicationContext;
@@ -42,6 +43,13 @@
 import org.springframework.web.servlet.view.tiles3.TilesConfigurer;
 import org.springframework.web.servlet.view.tiles3.TilesView;
 
+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;
+
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
+import static org.mockito.Mockito.*;
+
+
 /**
  * Tests with Java configuration.
  *
@@ -50,18 +58,33 @@
  */
 @RunWith(SpringJUnit4ClassRunner.class)
 @WebAppConfiguration("src/test/resources/META-INF/web-resources")
-@ContextConfiguration(classes = WebConfig.class)
+@ContextHierarchy({
+	@ContextConfiguration(classes = RootConfig.class),
+	@ContextConfiguration(classes = WebConfig.class)
+})
 public class JavaConfigTests {
 
 	@Autowired
 	private WebApplicationContext wac;
 
+	@Autowired
+	private PersonDao personDao;
+
 	private MockMvc mockMvc;
 
 
 	@Before
 	public void setup() {
 		this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
+		when(this.personDao.getPerson(5L)).thenReturn(new Person("Joe"));
+	}
+
+	@Test
+	public void person() throws Exception {
+		this.mockMvc.perform(get("/person/5").accept(MediaType.APPLICATION_JSON))
+			.andDo(print())
+			.andExpect(status().isOk())
+			.andExpect(content().string("{\"name\":\"Joe\",\"someDouble\":0.0,\"someBoolean\":false}"));
 	}
 
 	@Test
@@ -72,10 +95,27 @@ public void tilesDefinitions() throws Exception {
 	}
 
 
+	@Configuration
+	static class RootConfig {
+
+		@Bean
+		public PersonDao personDao() {
+			return Mockito.mock(PersonDao.class);
+		}
+	}
+
 	@Configuration
 	@EnableWebMvc
 	static class WebConfig extends WebMvcConfigurerAdapter {
 
+		@Autowired
+		private RootConfig rootConfig;
+
+		@Bean
+		public PersonController personController() {
+			return new PersonController(this.rootConfig.personDao());
+		}
+
 		@Override
 		public void addResourceHandlers(ResourceHandlerRegistry registry) {
 			registry.addResourceHandler("/resources/**").addResourceLocations("/resources/");
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/PersonController.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/PersonController.java
new file mode 100644
index 000000000000..ffeea88e449f
--- /dev/null
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/PersonController.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.web.servlet.samples.context;
+
+import org.springframework.stereotype.Controller;
+import org.springframework.test.web.Person;
+import org.springframework.web.bind.annotation.PathVariable;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestMethod;
+import org.springframework.web.bind.annotation.ResponseBody;
+
+@Controller
+public class PersonController {
+
+	private final PersonDao personDao;
+
+
+	public PersonController(PersonDao personDao) {
+		this.personDao = personDao;
+	}
+
+	@RequestMapping(value="/person/{id}", method=RequestMethod.GET)
+	@ResponseBody
+	public Person getPerson(@PathVariable long id) {
+		return this.personDao.getPerson(id);
+	}
+
+}
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/PersonDao.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/PersonDao.java
new file mode 100644
index 000000000000..035b9595d4c4
--- /dev/null
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/PersonDao.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.web.servlet.samples.context;
+
+import org.springframework.test.web.Person;
+
+public interface PersonDao {
+
+	Person getPerson(Long id);
+
+}
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/WebAppResourceTests.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/WebAppResourceTests.java
index 2fb361f9154e..23cd46d5c34f 100644
--- a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/WebAppResourceTests.java
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/WebAppResourceTests.java
@@ -28,6 +28,7 @@
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 import org.springframework.test.context.web.WebAppConfiguration;
 import org.springframework.test.web.servlet.MockMvc;
@@ -42,7 +43,10 @@
  */
 @RunWith(SpringJUnit4ClassRunner.class)
 @WebAppConfiguration("src/test/resources/META-INF/web-resources")
-@ContextConfiguration("servlet-context.xml")
+@ContextHierarchy({
+	@ContextConfiguration("root-context.xml"),
+	@ContextConfiguration("servlet-context.xml")
+})
 public class WebAppResourceTests {
 
 	@Autowired
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/XmlConfigTests.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/XmlConfigTests.java
index 73ab1ab0a95c..e9091ef5b08d 100644
--- a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/XmlConfigTests.java
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/context/XmlConfigTests.java
@@ -16,20 +16,26 @@
 
 package org.springframework.test.web.servlet.samples.context;
 
-import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
-import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.http.MediaType;
 import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
 import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
 import org.springframework.test.context.web.WebAppConfiguration;
+import org.springframework.test.web.Person;
 import org.springframework.test.web.servlet.MockMvc;
 import org.springframework.test.web.servlet.setup.MockMvcBuilders;
 import org.springframework.web.context.WebApplicationContext;
 
+import static org.mockito.Mockito.*;
+
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
+
 /**
  * Tests with XML configuration.
  *
@@ -38,18 +44,33 @@
  */
 @RunWith(SpringJUnit4ClassRunner.class)
 @WebAppConfiguration("src/test/resources/META-INF/web-resources")
-@ContextConfiguration("servlet-context.xml")
+@ContextHierarchy({
+	@ContextConfiguration("root-context.xml"),
+	@ContextConfiguration("servlet-context.xml")
+})
 public class XmlConfigTests {
 
 	@Autowired
 	private WebApplicationContext wac;
 
+	@Autowired
+	private PersonDao personDao;
+
 	private MockMvc mockMvc;
 
 
 	@Before
 	public void setup() {
 		this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
+		when(this.personDao.getPerson(5L)).thenReturn(new Person("Joe"));
+	}
+
+	@Test
+	public void person() throws Exception {
+		this.mockMvc.perform(get("/person/5").accept(MediaType.APPLICATION_JSON))
+			.andDo(print())
+			.andExpect(status().isOk())
+			.andExpect(content().string("{\"name\":\"Joe\",\"someDouble\":0.0,\"someBoolean\":false}"));
 	}
 
 	@Test
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/standalone/AsyncTests.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/standalone/AsyncTests.java
index f021e1355a24..a3640dd6fad1 100644
--- a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/standalone/AsyncTests.java
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/samples/standalone/AsyncTests.java
@@ -28,6 +28,7 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.springframework.http.MediaType;
 import org.springframework.stereotype.Controller;
@@ -58,6 +59,7 @@ public void setup() {
 	}
 
 	@Test
+	@Ignore
 	public void testCallable() throws Exception {
 		MvcResult mvcResult = this.mockMvc.perform(get("/1").param("callable", "true"))
 			.andDo(print())
@@ -73,6 +75,7 @@ public void testCallable() throws Exception {
 	}
 
 	@Test
+	@Ignore
 	public void testDeferredResult() throws Exception {
 		MvcResult mvcResult = this.mockMvc.perform(get("/1").param("deferredResult", "true"))
 			.andExpect(request().asyncStarted())
diff --git a/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/setup/Spr10277Tests.java b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/setup/Spr10277Tests.java
new file mode 100644
index 000000000000..101285c5201a
--- /dev/null
+++ b/spring-test-mvc/src/test/java/org/springframework/test/web/servlet/setup/Spr10277Tests.java
@@ -0,0 +1,43 @@
+package org.springframework.test.web.servlet.setup;
+
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+import org.springframework.test.context.web.WebAppConfiguration;
+import org.springframework.web.context.WebApplicationContext;
+import org.springframework.web.filter.CharacterEncodingFilter;
+import org.springframework.web.servlet.config.annotation.EnableWebMvc;
+import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
+
+/**
+ * Test for SPR-10277 (Multiple method chaining when building MockMvc).
+ *
+ * @author Wesley Hall
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@WebAppConfiguration
+@ContextConfiguration
+public class Spr10277Tests {
+
+    @Autowired
+    private WebApplicationContext wac;
+
+    @Test
+    public void chainMultiple() {
+        MockMvcBuilders
+                .webAppContextSetup(wac)
+                .addFilter(new CharacterEncodingFilter() )
+                .defaultRequest(get("/").contextPath("/mywebapp"))
+                .build();
+    }
+
+    @Configuration
+    @EnableWebMvc
+    static class WebConfig extends WebMvcConfigurerAdapter {
+    }
+}
diff --git a/spring-test-mvc/src/test/resources/org/springframework/test/web/servlet/samples/context/root-context.xml b/spring-test-mvc/src/test/resources/org/springframework/test/web/servlet/samples/context/root-context.xml
new file mode 100644
index 000000000000..6456a634caeb
--- /dev/null
+++ b/spring-test-mvc/src/test/resources/org/springframework/test/web/servlet/samples/context/root-context.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="
+		http://www.springframework.org/schema/beans
+		http://www.springframework.org/schema/beans/spring-beans-3.1.xsd">
+
+	<bean id="personDao" class="org.mockito.Mockito" factory-method="mock">
+		<constructor-arg value="org.springframework.test.web.servlet.samples.context.PersonDao" />
+	</bean>
+
+</beans>
\ No newline at end of file
diff --git a/spring-test-mvc/src/test/resources/org/springframework/test/web/servlet/samples/context/servlet-context.xml b/spring-test-mvc/src/test/resources/org/springframework/test/web/servlet/samples/context/servlet-context.xml
index 4e567b1a843d..615534d26d6c 100644
--- a/spring-test-mvc/src/test/resources/org/springframework/test/web/servlet/samples/context/servlet-context.xml
+++ b/spring-test-mvc/src/test/resources/org/springframework/test/web/servlet/samples/context/servlet-context.xml
@@ -7,6 +7,10 @@
 
     <mvc:annotation-driven />
 
+    <bean class="org.springframework.test.web.servlet.samples.context.PersonController">
+        <constructor-arg ref="personDao"/>
+    </bean>
+
     <mvc:view-controller path="/" view-name="home" />
 
     <mvc:resources mapping="/resources/**" location="/resources/" />
diff --git a/spring-test/.springBeans b/spring-test/.springBeans
index 656622651c9d..aa53e0e65889 100644
--- a/spring-test/.springBeans
+++ b/spring-test/.springBeans
@@ -10,6 +10,7 @@
 		<config>src/test/java/org/springframework/test/context/junit4/profile/xml/DefaultProfileXmlConfigTests-context.xml</config>
 		<config>src/test/java/org/springframework/test/context/junit4/aci/xml/MultipleInitializersXmlConfigTests-context.xml</config>
 		<config>src/test/resources/org/springframework/test/context/web/RequestAndSessionScopedBeansWacTests-context.xml</config>
+		<config>src/test/resources/org/springframework/test/context/hierarchies/web/DispatcherWacRootWacEarTests-context.xml</config>
 	</configs>
 	<configSets>
 	</configSets>
diff --git a/spring-test/src/main/java/org/springframework/mock/jndi/SimpleNamingContextBuilder.java b/spring-test/src/main/java/org/springframework/mock/jndi/SimpleNamingContextBuilder.java
index 449c45facaf2..5d2f70d51983 100644
--- a/spring-test/src/main/java/org/springframework/mock/jndi/SimpleNamingContextBuilder.java
+++ b/spring-test/src/main/java/org/springframework/mock/jndi/SimpleNamingContextBuilder.java
@@ -40,9 +40,9 @@
  *
  * <p>There are various choices for DataSource implementations:
  * <ul>
- * <li>SingleConnectionDataSource (using the same Connection for all getConnection calls);
- * <li>DriverManagerDataSource (creating a new Connection on each getConnection call);
- * <li>Apache's Jakarta Commons DBCP offers BasicDataSource (a real pool).
+ * <li>{@code SingleConnectionDataSource} (using the same Connection for all getConnection calls)
+ * <li>{@code DriverManagerDataSource} (creating a new Connection on each getConnection call)
+ * <li>Apache's Jakarta Commons DBCP offers {@code org.apache.commons.dbcp.BasicDataSource} (a real pool)
  * </ul>
  *
  * <p>Typical usage in bootstrap code:
@@ -77,7 +77,6 @@
  * @see SimpleNamingContext
  * @see org.springframework.jdbc.datasource.SingleConnectionDataSource
  * @see org.springframework.jdbc.datasource.DriverManagerDataSource
- * @see org.apache.commons.dbcp.BasicDataSource
  */
 public class SimpleNamingContextBuilder implements InitialContextFactoryBuilder {
 
diff --git a/spring-test/src/main/java/org/springframework/mock/web/MockHttpServletRequest.java b/spring-test/src/main/java/org/springframework/mock/web/MockHttpServletRequest.java
index d609f39e8fcb..0d29289c77ed 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/MockHttpServletRequest.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/MockHttpServletRequest.java
@@ -30,6 +30,7 @@
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
@@ -294,7 +295,7 @@ public Object getAttribute(String name) {
 
 	public Enumeration<String> getAttributeNames() {
 		checkActive();
-		return Collections.enumeration(this.attributes.keySet());
+		return Collections.enumeration(new LinkedHashSet<String>(this.attributes.keySet()));
 	}
 
 	public String getCharacterEncoding() {
diff --git a/spring-test/src/main/java/org/springframework/mock/web/MockHttpSession.java b/spring-test/src/main/java/org/springframework/mock/web/MockHttpSession.java
index 1855230d2c57..548c2016d153 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/MockHttpSession.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/MockHttpSession.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,7 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import javax.servlet.ServletContext;
 import javax.servlet.http.HttpSession;
@@ -50,6 +51,7 @@ public class MockHttpSession implements HttpSession {
 
 	public static final String SESSION_COOKIE_NAME = "JSESSION";
 
+
 	private static int nextId = 1;
 
 	private final String id;
@@ -141,7 +143,7 @@ public Object getValue(String name) {
 	}
 
 	public Enumeration<String> getAttributeNames() {
-		return Collections.enumeration(this.attributes.keySet());
+		return Collections.enumeration(new LinkedHashSet<String>(this.attributes.keySet()));
 	}
 
 	public String[] getValueNames() {
diff --git a/spring-test/src/main/java/org/springframework/mock/web/MockPageContext.java b/spring-test/src/main/java/org/springframework/mock/web/MockPageContext.java
index b492c1fa9805..2c5d07e8e3c5 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/MockPageContext.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/MockPageContext.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import javax.el.ELContext;
 import javax.servlet.Servlet;
@@ -249,7 +250,7 @@ else if (getAttribute(name, APPLICATION_SCOPE) != null) {
 	}
 
 	public Enumeration<String> getAttributeNames() {
-		return Collections.enumeration(this.attributes.keySet());
+		return Collections.enumeration(new LinkedHashSet<String>(this.attributes.keySet()));
 	}
 
 	@SuppressWarnings("unchecked")
diff --git a/spring-test/src/main/java/org/springframework/mock/web/MockServletContext.java b/spring-test/src/main/java/org/springframework/mock/web/MockServletContext.java
index 562179ceac89..7575d118631f 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/MockServletContext.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/MockServletContext.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -29,7 +29,6 @@
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
-
 import javax.activation.FileTypeMap;
 import javax.servlet.RequestDispatcher;
 import javax.servlet.Servlet;
@@ -164,6 +163,7 @@ public MockServletContext(ResourceLoader resourceLoader) {
 	 * @param resourceLoader the ResourceLoader to use (or null for the default)
 	 * @see #registerNamedDispatcher
 	 */
+	@SuppressWarnings("javadoc")
 	public MockServletContext(String resourceBasePath, ResourceLoader resourceLoader) {
 		this.resourceLoader = (resourceLoader != null ? resourceLoader : new DefaultResourceLoader());
 		this.resourceBasePath = (resourceBasePath != null ? resourceBasePath : "");
@@ -242,8 +242,16 @@ public int getEffectiveMinorVersion() {
 		return this.effectiveMinorVersion;
 	}
 
+	/**
+	 * This method uses the Java Activation framework, which returns
+	 * "application/octet-stream" when the mime type is unknown (i.e. it never returns
+	 * {@code null}). In order to maintain the {@link ServletContext#getMimeType(String)
+	 * contract, as of version 3.2.2, this method returns null if the mimeType is
+	 * "application/octet-stream".
+	 */
 	public String getMimeType(String filePath) {
-		return MimeTypeResolver.getMimeType(filePath);
+		String mimeType = MimeTypeResolver.getMimeType(filePath);
+		return ("application/octet-stream".equals(mimeType)) ? null : mimeType;
 	}
 
 	public Set<String> getResourcePaths(String path) {
@@ -345,6 +353,7 @@ public void unregisterNamedDispatcher(String name) {
 	 * <p>Defaults to {@linkplain #COMMON_DEFAULT_SERVLET_NAME "default"}.
 	 * @see #setDefaultServletName
 	 */
+	@SuppressWarnings("javadoc")
 	public String getDefaultServletName() {
 		return this.defaultServletName;
 	}
@@ -434,7 +443,7 @@ public Object getAttribute(String name) {
 	}
 
 	public Enumeration<String> getAttributeNames() {
-		return Collections.enumeration(this.attributes.keySet());
+		return Collections.enumeration(new LinkedHashSet<String>(this.attributes.keySet()));
 	}
 
 	public void setAttribute(String name, Object value) {
diff --git a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockClientDataRequest.java b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockClientDataRequest.java
index 8f36c3a76405..406c263e9f9a 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockClientDataRequest.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockClientDataRequest.java
@@ -125,4 +125,4 @@ public String getMethod() {
 		return this.method;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockEvent.java b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockEvent.java
index 0dc7efaba8dd..41e72da9a9a6 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockEvent.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockEvent.java
@@ -85,4 +85,4 @@ public Serializable getValue() {
 		return this.value;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockEventRequest.java b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockEventRequest.java
index 2406f18d01ca..a2850e3c1f7f 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockEventRequest.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockEventRequest.java
@@ -85,4 +85,4 @@ public String getMethod() {
 		return this.method;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletContext.java b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletContext.java
index b1193ff5e1ed..39dc9f5b294b 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletContext.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletContext.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,7 +28,6 @@
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
-import java.util.Vector;
 import javax.activation.FileTypeMap;
 import javax.portlet.PortletContext;
 import javax.portlet.PortletRequestDispatcher;
@@ -210,7 +209,7 @@ public Object getAttribute(String name) {
 	}
 
 	public Enumeration<String> getAttributeNames() {
-		return new Vector<String>(this.attributes.keySet()).elements();
+		return Collections.enumeration(new LinkedHashSet<String>(this.attributes.keySet()));
 	}
 
 	public void setAttribute(String name, Object value) {
diff --git a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletRequest.java b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletRequest.java
index 70e90567b0c0..38b517351a78 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletRequest.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletRequest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,13 +21,12 @@
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
-import java.util.Vector;
-
 import javax.portlet.PortalContext;
 import javax.portlet.PortletContext;
 import javax.portlet.PortletMode;
@@ -332,7 +331,7 @@ public Object getAttribute(String name) {
 
 	public Enumeration<String> getAttributeNames() {
 		checkActive();
-		return new Vector<String>(this.attributes.keySet()).elements();
+		return Collections.enumeration(new LinkedHashSet<String>(this.attributes.keySet()));
 	}
 
 	public void setParameters(Map<String, String[]> parameters) {
diff --git a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletSession.java b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletSession.java
index 93800340b857..5eaec799063e 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletSession.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockPortletSession.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,10 +18,10 @@
 
 import java.util.Collections;
 import java.util.Enumeration;
-import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.Map;
-import java.util.Vector;
 import javax.portlet.PortletContext;
 import javax.portlet.PortletSession;
 import javax.servlet.http.HttpSessionBindingEvent;
@@ -51,9 +51,9 @@ public class MockPortletSession implements PortletSession {
 
 	private final PortletContext portletContext;
 
-	private final Map<String, Object> portletAttributes = new HashMap<String, Object>();
+	private final Map<String, Object> portletAttributes = new LinkedHashMap<String, Object>();
 
-	private final Map<String, Object> applicationAttributes = new HashMap<String, Object>();
+	private final Map<String, Object> applicationAttributes = new LinkedHashMap<String, Object>();
 
 	private boolean invalid = false;
 
@@ -92,15 +92,15 @@ else if (scope == PortletSession.APPLICATION_SCOPE) {
 	}
 
 	public Enumeration<String> getAttributeNames() {
-		return new Vector<String>(this.portletAttributes.keySet()).elements();
+		return Collections.enumeration(new LinkedHashSet<String>(this.portletAttributes.keySet()));
 	}
 
 	public Enumeration<String> getAttributeNames(int scope) {
 		if (scope == PortletSession.PORTLET_SCOPE) {
-			return new Vector<String>(this.portletAttributes.keySet()).elements();
+			return Collections.enumeration(new LinkedHashSet<String>(this.portletAttributes.keySet()));
 		}
 		else if (scope == PortletSession.APPLICATION_SCOPE) {
-			return new Vector<String>(this.applicationAttributes.keySet()).elements();
+			return Collections.enumeration(new LinkedHashSet<String>(this.applicationAttributes.keySet()));
 		}
 		return null;
 	}
diff --git a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockStateAwareResponse.java b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockStateAwareResponse.java
index 685365844719..95df6ed01669 100644
--- a/spring-test/src/main/java/org/springframework/mock/web/portlet/MockStateAwareResponse.java
+++ b/spring-test/src/main/java/org/springframework/mock/web/portlet/MockStateAwareResponse.java
@@ -151,4 +151,4 @@ public Serializable getEvent(String name) {
 		return this.events.get(new QName(name));
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-test/src/main/java/org/springframework/test/AbstractDependencyInjectionSpringContextTests.java b/spring-test/src/main/java/org/springframework/test/AbstractDependencyInjectionSpringContextTests.java
index 0ef706abe11d..6229a8d38415 100644
--- a/spring-test/src/main/java/org/springframework/test/AbstractDependencyInjectionSpringContextTests.java
+++ b/spring-test/src/main/java/org/springframework/test/AbstractDependencyInjectionSpringContextTests.java
@@ -197,6 +197,7 @@ protected void prepareTestInstance() throws Exception {
 	 * test instance has not been configured
 	 * @see #populateProtectedVariables()
 	 */
+	@SuppressWarnings("javadoc")
 	protected void injectDependencies() throws Exception {
 		Assert.state(getApplicationContext() != null,
 				"injectDependencies() called without first configuring an ApplicationContext");
diff --git a/spring-test/src/main/java/org/springframework/test/annotation/DirtiesContext.java b/spring-test/src/main/java/org/springframework/test/annotation/DirtiesContext.java
index 53a9b877e642..aa6ed211370b 100644
--- a/spring-test/src/main/java/org/springframework/test/annotation/DirtiesContext.java
+++ b/spring-test/src/main/java/org/springframework/test/annotation/DirtiesContext.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,13 +36,13 @@
  * mode set to {@link ClassMode#AFTER_CLASS AFTER_CLASS}</li>
  * </ul>
  * <p>
- * Use this annotation if a test has modified the context (for example, by
- * replacing a bean definition). Subsequent tests will be supplied a new
- * context.
+ * Use this annotation if a test has modified the context &mdash; for example, by
+ * replacing a bean definition or changing the state of a singleton bean.
+ * Subsequent tests will be supplied a new context.
  * </p>
  * <p>
- * {@code &#064;DirtiesContext} may be used as a class-level and
- * method-level annotation within the same class. In such scenarios, the
+ * {@code @DirtiesContext} may be used as a class-level and method-level
+ * annotation within the same class. In such scenarios, the
  * {@code ApplicationContext} will be marked as <em>dirty</em> after any
  * such annotated method as well as after the entire class. If the
  * {@link ClassMode} is set to {@link ClassMode#AFTER_EACH_TEST_METHOD
@@ -53,16 +53,19 @@
  * @author Sam Brannen
  * @author Rod Johnson
  * @since 2.0
+ * @see org.springframework.test.context.ContextConfiguration
  */
 @Documented
 @Inherited
 @Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.TYPE, ElementType.METHOD})
+@Target({ ElementType.TYPE, ElementType.METHOD })
 public @interface DirtiesContext {
 
 	/**
-	 * Defines <i>modes</i> which determine how {@code &#064;DirtiesContext}
-	 * is interpreted when used to annotate a test class.
+	 * Defines <i>modes</i> which determine how {@code @DirtiesContext} is
+	 * interpreted when used to annotate a test class.
+	 *
+	 * @since 3.0
 	 */
 	static enum ClassMode {
 
@@ -76,18 +79,64 @@ static enum ClassMode {
 		 * The associated {@code ApplicationContext} will be marked as
 		 * <em>dirty</em> after each test method in the class.
 		 */
-		AFTER_EACH_TEST_METHOD
+		AFTER_EACH_TEST_METHOD;
+	}
+
+	/**
+	 * Defines <i>modes</i> which determine how the context cache is cleared
+	 * when {@code @DirtiesContext} is used in a test whose context is
+	 * configured as part of a hierarchy via
+	 * {@link org.springframework.test.context.ContextHierarchy @ContextHierarchy}.
+	 *
+	 * @since 3.2.2
+	 */
+	static enum HierarchyMode {
+
+		/**
+		 * The context cache will be cleared using an <em>exhaustive</em> algorithm
+		 * that includes not only the {@linkplain HierarchyMode#CURRENT_LEVEL current level}
+		 * but also all other context hierarchies that share an ancestor context
+		 * common to the current test.
+		 *
+		 * <p>All {@code ApplicationContexts} that reside in a subhierarchy of
+		 * the common ancestor context will be removed from the context cache and
+		 * closed.
+		 */
+		EXHAUSTIVE,
+
+		/**
+		 * The {@code ApplicationContext} for the <em>current level</em> in the
+		 * context hierarchy and all contexts in subhierarchies of the current
+		 * level will be removed from the context cache and closed.
+		 *
+		 * <p>The <em>current level</em> refers to the {@code ApplicationContext}
+		 * at the lowest level in the context hierarchy that is visible from the
+		 * current test.
+		 */
+		CURRENT_LEVEL;
 	}
 
 
 	/**
 	 * The <i>mode</i> to use when a test class is annotated with
-	 * {@code &#064;DirtiesContext}.
+	 * {@code @DirtiesContext}.
 	 * <p>Defaults to {@link ClassMode#AFTER_CLASS AFTER_CLASS}.
 	 * <p>Note: Setting the class mode on an annotated test method has no meaning,
-	 * since the mere presence of the {@code &#064;DirtiesContext}
-	 * annotation on a test method is sufficient.
+	 * since the mere presence of the {@code @DirtiesContext} annotation on a
+	 * test method is sufficient.
+	 *
+	 * @since 3.0
 	 */
 	ClassMode classMode() default ClassMode.AFTER_CLASS;
 
+	/**
+	 * The context cache clearing <em>mode</em> to use when a context is
+	 * configured as part of a hierarchy via
+	 * {@link org.springframework.test.context.ContextHierarchy @ContextHierarchy}.
+	 * <p>Defaults to {@link HierarchyMode#EXHAUSTIVE EXHAUSTIVE}.
+	 *
+	 * @since 3.2.2
+	 */
+	HierarchyMode hierarchyMode() default HierarchyMode.EXHAUSTIVE;
+
 }
diff --git a/spring-test/src/main/java/org/springframework/test/context/CacheAwareContextLoaderDelegate.java b/spring-test/src/main/java/org/springframework/test/context/CacheAwareContextLoaderDelegate.java
new file mode 100644
index 000000000000..f7375def0357
--- /dev/null
+++ b/spring-test/src/main/java/org/springframework/test/context/CacheAwareContextLoaderDelegate.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.springframework.context.ApplicationContext;
+import org.springframework.util.Assert;
+
+/**
+ * {@code CacheAwareContextLoaderDelegate} loads application contexts from
+ * {@link MergedContextConfiguration} by delegating to the
+ * {@link ContextLoader} configured in the {@code MergedContextConfiguration}
+ * and interacting transparently with the {@link ContextCache} behind the scenes.
+ *
+ * <p>Note: {@code CacheAwareContextLoaderDelegate} does not implement the
+ * {@link ContextLoader} or {@link SmartContextLoader} interface.
+ *
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+public class CacheAwareContextLoaderDelegate {
+
+	private static final Log logger = LogFactory.getLog(CacheAwareContextLoaderDelegate.class);
+
+	private final ContextCache contextCache;
+
+
+	CacheAwareContextLoaderDelegate(ContextCache contextCache) {
+		Assert.notNull(contextCache, "ContextCache must not be null");
+		this.contextCache = contextCache;
+	}
+
+	/**
+	 * Load the {@code ApplicationContext} for the supplied merged context
+	 * configuration. Supports both the {@link SmartContextLoader} and
+	 * {@link ContextLoader} SPIs.
+	 * @throws Exception if an error occurs while loading the application context
+	 */
+	private ApplicationContext loadContextInternal(MergedContextConfiguration mergedContextConfiguration)
+			throws Exception {
+		ContextLoader contextLoader = mergedContextConfiguration.getContextLoader();
+		Assert.notNull(contextLoader, "Cannot load an ApplicationContext with a NULL 'contextLoader'. "
+				+ "Consider annotating your test class with @ContextConfiguration or @ContextHierarchy.");
+
+		ApplicationContext applicationContext;
+
+		if (contextLoader instanceof SmartContextLoader) {
+			SmartContextLoader smartContextLoader = (SmartContextLoader) contextLoader;
+			applicationContext = smartContextLoader.loadContext(mergedContextConfiguration);
+		}
+		else {
+			String[] locations = mergedContextConfiguration.getLocations();
+			Assert.notNull(locations, "Cannot load an ApplicationContext with a NULL 'locations' array. "
+					+ "Consider annotating your test class with @ContextConfiguration or @ContextHierarchy.");
+			applicationContext = contextLoader.loadContext(locations);
+		}
+
+		return applicationContext;
+	}
+
+	/**
+	 * Load the {@link ApplicationContext application context} for the supplied
+	 * merged context configuration.
+	 *
+	 * <p>If the context is present in the cache it will simply be returned;
+	 * otherwise, it will be loaded, stored in the cache, and returned.
+	 * @return the application context
+	 * @throws IllegalStateException if an error occurs while retrieving or
+	 * loading the application context
+	 */
+	public ApplicationContext loadContext(MergedContextConfiguration mergedContextConfiguration) {
+		synchronized (contextCache) {
+			ApplicationContext context = contextCache.get(mergedContextConfiguration);
+			if (context == null) {
+				try {
+					context = loadContextInternal(mergedContextConfiguration);
+					if (logger.isDebugEnabled()) {
+						logger.debug(String.format("Storing ApplicationContext in cache under key [%s].",
+							mergedContextConfiguration));
+					}
+					contextCache.put(mergedContextConfiguration, context);
+				}
+				catch (Exception ex) {
+					throw new IllegalStateException("Failed to load ApplicationContext", ex);
+				}
+			}
+			else {
+				if (logger.isDebugEnabled()) {
+					logger.debug(String.format("Retrieved ApplicationContext from cache with key [%s].",
+						mergedContextConfiguration));
+				}
+			}
+			return context;
+		}
+	}
+
+}
diff --git a/spring-test/src/main/java/org/springframework/test/context/ContextCache.java b/spring-test/src/main/java/org/springframework/test/context/ContextCache.java
index 32851cf5ed3d..3a5a5b1adbd6 100644
--- a/spring-test/src/main/java/org/springframework/test/context/ContextCache.java
+++ b/spring-test/src/main/java/org/springframework/test/context/ContextCache.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,24 +16,30 @@
 
 package org.springframework.test.context;
 
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.core.style.ToStringCreator;
+import org.springframework.test.annotation.DirtiesContext.HierarchyMode;
 import org.springframework.util.Assert;
 
 /**
  * Cache for Spring {@link ApplicationContext ApplicationContexts} in a test environment.
  *
- * <p>Maintains a cache of {@link ApplicationContext contexts} keyed by
- * {@link MergedContextConfiguration} instances. This has significant performance
- * benefits if initializing the context would take time. While initializing a
- * Spring context itself is very quick, some beans in a context, such as a
- * {@code LocalSessionFactoryBean} for working with Hibernate, may take some time
- * to initialize. Hence it often makes sense to perform that initialization only
- * once per test suite.
+ * <p>Maintains a cache of {@code ApplicationContexts} keyed by
+ * {@link MergedContextConfiguration} instances.
+ *
+ * <p>This has significant performance benefits if initializing the context would take time.
+ * While initializing a Spring context itself is very quick, some beans in a context, such
+ * as a {@code LocalSessionFactoryBean} for working with Hibernate, may take some time to
+ * initialize. Hence it often makes sense to perform that initialization only once per
+ * test suite.
  *
  * @author Sam Brannen
  * @author Juergen Hoeller
@@ -41,11 +47,22 @@
  */
 class ContextCache {
 
+	private final Object monitor = new Object();
+
+	/**
+	 * Map of context keys to Spring {@code ApplicationContext} instances.
+	 */
+	private final Map<MergedContextConfiguration, ApplicationContext> contextMap = new ConcurrentHashMap<MergedContextConfiguration, ApplicationContext>(
+		64);
+
 	/**
-	 * Map of context keys to Spring ApplicationContext instances.
+	 * Map of parent keys to sets of children keys, representing a top-down <em>tree</em>
+	 * of context hierarchies. This information is used for determining which subtrees
+	 * need to be recursively removed and closed when removing a context that is a parent
+	 * of other contexts.
 	 */
-	private final Map<MergedContextConfiguration, ApplicationContext> contextMap =
-			new ConcurrentHashMap<MergedContextConfiguration, ApplicationContext>(64);
+	private final Map<MergedContextConfiguration, Set<MergedContextConfiguration>> hierarchyMap = new ConcurrentHashMap<MergedContextConfiguration, Set<MergedContextConfiguration>>(
+		64);
 
 	private int hitCount;
 
@@ -53,15 +70,18 @@ class ContextCache {
 
 
 	/**
-	 * Clears all contexts from the cache.
+	 * Clears all contexts from the cache and clears context hierarchy information as
+	 * well.
 	 */
 	void clear() {
-		this.contextMap.clear();
+		synchronized (monitor) {
+			this.contextMap.clear();
+			this.hierarchyMap.clear();
+		}
 	}
 
 	/**
-	 * Clears hit and miss count statistics for the cache (i.e., resets counters
-	 * to zero).
+	 * Clears hit and miss count statistics for the cache (i.e., resets counters to zero).
 	 */
 	void clearStatistics() {
 		this.hitCount = 0;
@@ -70,124 +90,210 @@ void clearStatistics() {
 
 	/**
 	 * Return whether there is a cached context for the given key.
+	 *
 	 * @param key the context key (never {@code null})
 	 */
 	boolean contains(MergedContextConfiguration key) {
 		Assert.notNull(key, "Key must not be null");
-		return this.contextMap.containsKey(key);
+		synchronized (monitor) {
+			return this.contextMap.containsKey(key);
+		}
 	}
 
 	/**
-	 * Obtain a cached ApplicationContext for the given key.
-	 * <p>The {@link #getHitCount() hit} and {@link #getMissCount() miss}
-	 * counts will be updated accordingly.
+	 * Obtain a cached {@code ApplicationContext} for the given key.
+	 *
+	 * <p>The {@link #getHitCount() hit} and {@link #getMissCount() miss} counts will be
+	 * updated accordingly.
+	 *
 	 * @param key the context key (never {@code null})
-	 * @return the corresponding ApplicationContext instance,
-	 * or {@code null} if not found in the cache.
+	 * @return the corresponding {@code ApplicationContext} instance, or {@code null} if
+	 * not found in the cache.
 	 * @see #remove
 	 */
 	ApplicationContext get(MergedContextConfiguration key) {
 		Assert.notNull(key, "Key must not be null");
-		ApplicationContext context = this.contextMap.get(key);
-		if (context == null) {
-			incrementMissCount();
+		synchronized (monitor) {
+			ApplicationContext context = this.contextMap.get(key);
+			if (context == null) {
+				incrementMissCount();
+			}
+			else {
+				incrementHitCount();
+			}
+			return context;
 		}
-		else {
-			incrementHitCount();
-		}
-		return context;
 	}
 
 	/**
-	 * Increment the hit count by one. A <em>hit</em> is an access to the
-	 * cache, which returned a non-null context for a queried key.
+	 * Increment the hit count by one. A <em>hit</em> is an access to the cache, which
+	 * returned a non-null context for a queried key.
 	 */
 	private void incrementHitCount() {
 		this.hitCount++;
 	}
 
 	/**
-	 * Increment the miss count by one. A <em>miss</em> is an access to the
-	 * cache, which returned a {@code null} context for a queried key.
+	 * Increment the miss count by one. A <em>miss</em> is an access to the cache, which
+	 * returned a {@code null} context for a queried key.
 	 */
 	private void incrementMissCount() {
 		this.missCount++;
 	}
 
 	/**
-	 * Get the overall hit count for this cache. A <em>hit</em> is an access
-	 * to the cache, which returned a non-null context for a queried key.
+	 * Get the overall hit count for this cache. A <em>hit</em> is an access to the cache,
+	 * which returned a non-null context for a queried key.
 	 */
 	int getHitCount() {
 		return this.hitCount;
 	}
 
 	/**
-	 * Get the overall miss count for this cache. A <em>miss</em> is an
-	 * access to the cache, which returned a {@code null} context for a
-	 * queried key.
+	 * Get the overall miss count for this cache. A <em>miss</em> is an access to the
+	 * cache, which returned a {@code null} context for a queried key.
 	 */
 	int getMissCount() {
 		return this.missCount;
 	}
 
 	/**
-	 * Explicitly add an ApplicationContext instance to the cache under the given key.
+	 * Explicitly add an {@code ApplicationContext} instance to the cache under the given
+	 * key.
+	 *
 	 * @param key the context key (never {@code null})
-	 * @param context the ApplicationContext instance (never {@code null})
+	 * @param context the {@code ApplicationContext} instance (never {@code null})
 	 */
 	void put(MergedContextConfiguration key, ApplicationContext context) {
 		Assert.notNull(key, "Key must not be null");
 		Assert.notNull(context, "ApplicationContext must not be null");
-		this.contextMap.put(key, context);
-	}
 
-	/**
-	 * Remove the context with the given key.
-	 * @param key the context key (never {@code null})
-	 * @return the corresponding ApplicationContext instance, or {@code null}
-	 * if not found in the cache.
-	 * @see #setDirty
-	 */
-	ApplicationContext remove(MergedContextConfiguration key) {
-		return this.contextMap.remove(key);
+		synchronized (monitor) {
+			this.contextMap.put(key, context);
+
+			MergedContextConfiguration child = key;
+			MergedContextConfiguration parent = child.getParent();
+			while (parent != null) {
+				Set<MergedContextConfiguration> list = hierarchyMap.get(parent);
+				if (list == null) {
+					list = new HashSet<MergedContextConfiguration>();
+					hierarchyMap.put(parent, list);
+				}
+				list.add(child);
+				child = parent;
+				parent = child.getParent();
+			}
+		}
 	}
 
 	/**
-	 * Mark the context with the given key as dirty, effectively
-	 * {@link #remove removing} the context from the cache and explicitly
-	 * {@link ConfigurableApplicationContext#close() closing} it if it is an
+	 * Remove the context with the given key from the cache and explicitly
+	 * {@linkplain ConfigurableApplicationContext#close() close} it if it is an
 	 * instance of {@link ConfigurableApplicationContext}.
+	 *
 	 * <p>Generally speaking, you would only call this method if you change the
 	 * state of a singleton bean, potentially affecting future interaction with
 	 * the context.
-	 * @param key the context key (never {@code null})
-	 * @see #remove
+	 *
+	 * <p>In addition, the semantics of the supplied {@code HierarchyMode} will
+	 * be honored. See the Javadoc for {@link HierarchyMode} for details.
+	 *
+	 * @param key the context key; never {@code null}
+	 * @param hierarchyMode the hierarchy mode; may be {@code null} if the context
+	 * is not part of a hierarchy
 	 */
-	void setDirty(MergedContextConfiguration key) {
+	void remove(MergedContextConfiguration key, HierarchyMode hierarchyMode) {
 		Assert.notNull(key, "Key must not be null");
-		ApplicationContext context = remove(key);
-		if (context instanceof ConfigurableApplicationContext) {
-			((ConfigurableApplicationContext) context).close();
+
+		// startKey is the level at which to begin clearing the cache, depending
+		// on the configured hierarchy mode.
+		MergedContextConfiguration startKey = key;
+		if (hierarchyMode == HierarchyMode.EXHAUSTIVE) {
+			while (startKey.getParent() != null) {
+				startKey = startKey.getParent();
+			}
+		}
+
+		synchronized (monitor) {
+			final List<MergedContextConfiguration> removedContexts = new ArrayList<MergedContextConfiguration>();
+
+			remove(removedContexts, startKey);
+
+			// Remove all remaining references to any removed contexts from the
+			// hierarchy map.
+			for (MergedContextConfiguration currentKey : removedContexts) {
+				for (Set<MergedContextConfiguration> children : hierarchyMap.values()) {
+					children.remove(currentKey);
+				}
+			}
+
+			// Remove empty entries from the hierarchy map.
+			for (MergedContextConfiguration currentKey : hierarchyMap.keySet()) {
+				if (hierarchyMap.get(currentKey).isEmpty()) {
+					hierarchyMap.remove(currentKey);
+				}
+			}
+		}
+	}
+
+	private void remove(List<MergedContextConfiguration> removedContexts, MergedContextConfiguration key) {
+		Assert.notNull(key, "Key must not be null");
+
+		synchronized (monitor) {
+			Set<MergedContextConfiguration> children = hierarchyMap.get(key);
+			if (children != null) {
+				for (MergedContextConfiguration child : children) {
+					// Recurse through lower levels
+					remove(removedContexts, child);
+				}
+				// Remove the set of children for the current context from the
+				// hierarchy map.
+				hierarchyMap.remove(key);
+			}
+
+			// Physically remove and close leaf nodes first (i.e., on the way back up the
+			// stack as opposed to prior to the recursive call).
+			ApplicationContext context = contextMap.remove(key);
+			if (context instanceof ConfigurableApplicationContext) {
+				((ConfigurableApplicationContext) context).close();
+			}
+			removedContexts.add(key);
 		}
 	}
 
 	/**
-	 * Determine the number of contexts currently stored in the cache. If the
-	 * cache contains more than <tt>Integer.MAX_VALUE</tt> elements, returns
+	 * Determine the number of contexts currently stored in the cache. If the cache
+	 * contains more than <tt>Integer.MAX_VALUE</tt> elements, returns
 	 * <tt>Integer.MAX_VALUE</tt>.
 	 */
 	int size() {
-		return this.contextMap.size();
+		synchronized (monitor) {
+			return this.contextMap.size();
+		}
+	}
+
+	/**
+	 * Determine the number of parent contexts currently tracked within the cache.
+	 */
+	int getParentContextCount() {
+		synchronized (monitor) {
+			return this.hierarchyMap.size();
+		}
 	}
 
 	/**
-	 * Generates a text string, which contains the {@link #size() size} as well
-	 * as the {@link #hitCount hit} and {@link #missCount miss} counts.
+	 * Generates a text string, which contains the {@linkplain #size() size} as well
+	 * as the {@linkplain #getHitCount() hit}, {@linkplain #getMissCount() miss}, and
+	 * {@linkplain #getParentContextCount() parent context} counts.
 	 */
+	@Override
 	public String toString() {
-		return new ToStringCreator(this).append("size", size()).append("hitCount", getHitCount()).
-				append("missCount", getMissCount()).toString();
+		return new ToStringCreator(this)//
+		.append("size", size())//
+		.append("hitCount", getHitCount())//
+		.append("missCount", getMissCount())//
+		.append("parentContextCount", getParentContextCount())//
+		.toString();
 	}
 
 }
diff --git a/spring-test/src/main/java/org/springframework/test/context/ContextConfiguration.java b/spring-test/src/main/java/org/springframework/test/context/ContextConfiguration.java
index a23aed849c74..7033765c0b38 100644
--- a/spring-test/src/main/java/org/springframework/test/context/ContextConfiguration.java
+++ b/spring-test/src/main/java/org/springframework/test/context/ContextConfiguration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -58,7 +58,7 @@
  * {@link org.springframework.context.annotation.Bean @Bean}-methods</li>
  * </ul>
  *
- * Consult the Javadoc for
+ * <p>Consult the Javadoc for
  * {@link org.springframework.context.annotation.Configuration @Configuration} and
  * {@link org.springframework.context.annotation.Bean @Bean}
  * for further information regarding the configuration and semantics of
@@ -66,11 +66,12 @@
  *
  * @author Sam Brannen
  * @since 2.5
+ * @see ContextHierarchy
+ * @see ActiveProfiles
  * @see ContextLoader
  * @see SmartContextLoader
  * @see ContextConfigurationAttributes
  * @see MergedContextConfiguration
- * @see ActiveProfiles
  * @see org.springframework.context.ApplicationContext
  */
 @Documented
@@ -269,18 +270,43 @@
 	 * explicit loader. If no class in the hierarchy specifies an explicit
 	 * loader, a default loader will be used instead.
 	 *
-	 * <p>The default concrete implementation chosen at runtime will be
+	 * <p>The default concrete implementation chosen at runtime will be either
 	 * {@link org.springframework.test.context.support.DelegatingSmartContextLoader
-	 * DelegatingSmartContextLoader}. For further details on the default behavior
-	 * of various concrete {@code ContextLoaders}, check out the Javadoc for
+	 * DelegatingSmartContextLoader} or
+	 * {@link org.springframework.test.context.web.WebDelegatingSmartContextLoader
+	 * WebDelegatingSmartContextLoader} depending on the absence or presence of
+	 * {@link org.springframework.test.context.web.WebAppConfiguration
+	 * &#064;WebAppConfiguration}. For further details on the default behavior
+	 * of various concrete {@code SmartContextLoaders}, check out the Javadoc for
 	 * {@link org.springframework.test.context.support.AbstractContextLoader
 	 * AbstractContextLoader},
 	 * {@link org.springframework.test.context.support.GenericXmlContextLoader
-	 * GenericXmlContextLoader}, and
+	 * GenericXmlContextLoader},
 	 * {@link org.springframework.test.context.support.AnnotationConfigContextLoader
-	 * AnnotationConfigContextLoader}.
+	 * AnnotationConfigContextLoader},
+	 * {@link org.springframework.test.context.web.GenericXmlWebContextLoader
+	 * GenericXmlWebContextLoader}, and
+	 * {@link org.springframework.test.context.web.AnnotationConfigWebContextLoader
+	 * AnnotationConfigWebContextLoader}.
+	 *
 	 * @since 2.5
 	 */
 	Class<? extends ContextLoader> loader() default ContextLoader.class;
 
+	/**
+	 * The name of the context hierarchy level represented by this configuration.
+	 *
+	 * <p>If not specified the name will be inferred based on the numerical level
+	 * within all declared contexts within the hierarchy.
+	 *
+	 * <p>This attribute is only applicable when used within a test class hierarchy
+	 * that is configured using {@code @ContextHierarchy}, in which case the name
+	 * can be used for <em>merging</em> or <em>overriding</em> this configuration
+	 * with configuration of the same name in hierarchy levels defined in superclasses.
+	 * See the Javadoc for {@link ContextHierarchy @ContextHierarchy} for details.
+	 *
+	 * @since 3.2.2
+	 */
+	String name() default "";
+
 }
diff --git a/spring-test/src/main/java/org/springframework/test/context/ContextConfigurationAttributes.java b/spring-test/src/main/java/org/springframework/test/context/ContextConfigurationAttributes.java
index 5a481c190dea..035483a71e0a 100644
--- a/spring-test/src/main/java/org/springframework/test/context/ContextConfigurationAttributes.java
+++ b/spring-test/src/main/java/org/springframework/test/context/ContextConfigurationAttributes.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,8 @@
 
 package org.springframework.test.context;
 
+import java.util.Arrays;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -24,6 +26,7 @@
 import org.springframework.core.style.ToStringCreator;
 import org.springframework.util.Assert;
 import org.springframework.util.ObjectUtils;
+import org.springframework.util.StringUtils;
 
 /**
  * {@code ContextConfigurationAttributes} encapsulates the context
@@ -54,6 +57,8 @@ public class ContextConfigurationAttributes {
 
 	private final boolean inheritInitializers;
 
+	private final String name;
+
 
 	/**
 	 * Resolve resource locations from the {@link ContextConfiguration#locations() locations}
@@ -75,7 +80,8 @@ private static String[] resolveLocations(Class<?> declaringClass, ContextConfigu
 				ObjectUtils.nullSafeToString(valueLocations), ObjectUtils.nullSafeToString(locations));
 			logger.error(msg);
 			throw new IllegalStateException(msg);
-		} else if (!ObjectUtils.isEmpty(valueLocations)) {
+		}
+		else if (!ObjectUtils.isEmpty(valueLocations)) {
 			locations = valueLocations;
 		}
 
@@ -92,7 +98,7 @@ private static String[] resolveLocations(Class<?> declaringClass, ContextConfigu
 	public ContextConfigurationAttributes(Class<?> declaringClass, ContextConfiguration contextConfiguration) {
 		this(declaringClass, resolveLocations(declaringClass, contextConfiguration), contextConfiguration.classes(),
 			contextConfiguration.inheritLocations(), contextConfiguration.initializers(),
-			contextConfiguration.inheritInitializers(), contextConfiguration.loader());
+			contextConfiguration.inheritInitializers(), contextConfiguration.name(), contextConfiguration.loader());
 	}
 
 	/**
@@ -109,13 +115,13 @@ public ContextConfigurationAttributes(Class<?> declaringClass, ContextConfigurat
 	 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is
 	 * {@code null}, or if the {@code locations} and {@code classes} are both non-empty
 	 * @deprecated as of Spring 3.2, use
-	 * {@link #ContextConfigurationAttributes(Class, String[], Class[], boolean, Class[], boolean, Class)}
+	 * {@link #ContextConfigurationAttributes(Class, String[], Class[], boolean, Class[], boolean, String, Class)}
 	 * instead
 	 */
 	@Deprecated
 	public ContextConfigurationAttributes(Class<?> declaringClass, String[] locations, Class<?>[] classes,
 			boolean inheritLocations, Class<? extends ContextLoader> contextLoaderClass) {
-		this(declaringClass, locations, classes, inheritLocations, null, true, contextLoaderClass);
+		this(declaringClass, locations, classes, inheritLocations, null, true, null, contextLoaderClass);
 	}
 
 	/**
@@ -138,6 +144,31 @@ public ContextConfigurationAttributes(Class<?> declaringClass, String[] location
 			boolean inheritLocations,
 			Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>[] initializers,
 			boolean inheritInitializers, Class<? extends ContextLoader> contextLoaderClass) {
+		this(declaringClass, locations, classes, inheritLocations, initializers, inheritInitializers, null,
+			contextLoaderClass);
+	}
+
+	/**
+	 * Construct a new {@link ContextConfigurationAttributes} instance for the
+	 * {@linkplain Class test class} that declared the
+	 * {@link ContextConfiguration @ContextConfiguration} annotation and its
+	 * corresponding attributes.
+	 *
+	 * @param declaringClass the test class that declared {@code @ContextConfiguration}
+	 * @param locations the resource locations declared via {@code @ContextConfiguration}
+	 * @param classes the annotated classes declared via {@code @ContextConfiguration}
+	 * @param inheritLocations the {@code inheritLocations} flag declared via {@code @ContextConfiguration}
+	 * @param initializers the context initializers declared via {@code @ContextConfiguration}
+	 * @param inheritInitializers the {@code inheritInitializers} flag declared via {@code @ContextConfiguration}
+	 * @param name the name of level in the context hierarchy, or {@code null} if not applicable
+	 * @param contextLoaderClass the {@code ContextLoader} class declared via {@code @ContextConfiguration}
+	 * @throws IllegalArgumentException if the {@code declaringClass} or {@code contextLoaderClass} is
+	 * {@code null}, or if the {@code locations} and {@code classes} are both non-empty
+	 */
+	public ContextConfigurationAttributes(Class<?> declaringClass, String[] locations, Class<?>[] classes,
+			boolean inheritLocations,
+			Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>[] initializers,
+			boolean inheritInitializers, String name, Class<? extends ContextLoader> contextLoaderClass) {
 
 		Assert.notNull(declaringClass, "declaringClass must not be null");
 		Assert.notNull(contextLoaderClass, "contextLoaderClass must not be null");
@@ -158,6 +189,7 @@ public ContextConfigurationAttributes(Class<?> declaringClass, String[] location
 		this.inheritLocations = inheritLocations;
 		this.initializers = initializers;
 		this.inheritInitializers = inheritInitializers;
+		this.name = StringUtils.hasText(name) ? name : null;
 		this.contextLoaderClass = contextLoaderClass;
 	}
 
@@ -305,6 +337,101 @@ public Class<? extends ContextLoader> getContextLoaderClass() {
 		return contextLoaderClass;
 	}
 
+	/**
+	 * Get the name of the context hierarchy level that was declared via
+	 * {@link ContextConfiguration @ContextConfiguration}.
+	 *
+	 * @return the name of the context hierarchy level or {@code null} if not applicable
+	 * @see ContextConfiguration#name()
+	 * @since 3.2.2
+	 */
+	public String getName() {
+		return this.name;
+	}
+
+	/**
+	 * Generate a unique hash code for all properties of this
+	 * {@code ContextConfigurationAttributes} instance excluding the
+	 * {@linkplain #getName() name}.
+	 */
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + declaringClass.hashCode();
+		result = prime * result + Arrays.hashCode(locations);
+		result = prime * result + Arrays.hashCode(classes);
+		result = prime * result + (inheritLocations ? 1231 : 1237);
+		result = prime * result + Arrays.hashCode(initializers);
+		result = prime * result + (inheritInitializers ? 1231 : 1237);
+		result = prime * result + contextLoaderClass.hashCode();
+		return result;
+	}
+
+	/**
+	 * Determine if the supplied object is equal to this
+	 * {@code ContextConfigurationAttributes} instance by comparing both object's
+	 * {@linkplain #getDeclaringClass() declaring class},
+	 * {@linkplain #getLocations() locations},
+	 * {@linkplain #getClasses() annotated classes},
+	 * {@linkplain #isInheritLocations() inheritLocations flag},
+	 * {@linkplain #getInitializers() context initializer classes},
+	 * {@linkplain #isInheritInitializers() inheritInitializers flag}, and the
+	 * {@link #getContextLoaderClass() ContextLoader class}.
+	 */
+	@Override
+	public boolean equals(Object obj) {
+
+		if (this == obj) {
+			return true;
+		}
+		if (!(obj instanceof ContextConfigurationAttributes)) {
+			return false;
+		}
+
+		final ContextConfigurationAttributes that = (ContextConfigurationAttributes) obj;
+
+		if (this.declaringClass == null) {
+			if (that.declaringClass != null) {
+				return false;
+			}
+		}
+		else if (!this.declaringClass.equals(that.declaringClass)) {
+			return false;
+		}
+
+		if (!Arrays.equals(this.locations, that.locations)) {
+			return false;
+		}
+
+		if (!Arrays.equals(this.classes, that.classes)) {
+			return false;
+		}
+
+		if (this.inheritLocations != that.inheritLocations) {
+			return false;
+		}
+
+		if (!Arrays.equals(this.initializers, that.initializers)) {
+			return false;
+		}
+
+		if (this.inheritInitializers != that.inheritInitializers) {
+			return false;
+		}
+
+		if (this.contextLoaderClass == null) {
+			if (that.contextLoaderClass != null) {
+				return false;
+			}
+		}
+		else if (!this.contextLoaderClass.equals(that.contextLoaderClass)) {
+			return false;
+		}
+
+		return true;
+	}
+
 	/**
 	 * Provide a String representation of the context configuration attributes
 	 * and declaring class.
@@ -318,6 +445,7 @@ public String toString() {
 		.append("inheritLocations", inheritLocations)//
 		.append("initializers", ObjectUtils.nullSafeToString(initializers))//
 		.append("inheritInitializers", inheritInitializers)//
+		.append("name", name)//
 		.append("contextLoaderClass", contextLoaderClass.getName())//
 		.toString();
 	}
diff --git a/spring-test/src/main/java/org/springframework/test/context/ContextHierarchy.java b/spring-test/src/main/java/org/springframework/test/context/ContextHierarchy.java
new file mode 100644
index 000000000000..7eac62d6e5dc
--- /dev/null
+++ b/spring-test/src/main/java/org/springframework/test/context/ContextHierarchy.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * {@code @ContextHierarchy} is a class-level annotation that is used to define
+ * a hierarchy of {@link org.springframework.context.ApplicationContext
+ * ApplicationContexts} for integration tests.
+ *
+ * <h3>Examples</h3>
+ * <p>The following JUnit-based examples demonstrate common configuration
+ * scenarios for integration tests that require the use of context hierarchies.
+ *
+ * <h4>Single Test Class with Context Hierarchy</h4>
+ * <p>{@code ControllerIntegrationTests} represents a typical integration testing
+ * scenario for a Spring MVC web application by declaring a context hierarchy
+ * consisting of two levels, one for the <em>root</em> {@code WebApplicationContext}
+ * (with {@code TestAppConfig}) and one for the <em>dispatcher servlet</em>
+ * {@code WebApplicationContext} (with {@code WebConfig}). The {@code
+ * WebApplicationContext} that is <em>autowired</em> into the test instance is
+ * the one for the child context (i.e., the lowest context in the hierarchy).
+ *
+ * <pre class="code">
+ * &#064;RunWith(SpringJUnit4ClassRunner.class)
+ * &#064;WebAppConfiguration
+ * &#064;ContextHierarchy({
+ *     &#064;ContextConfiguration(classes = TestAppConfig.class),
+ *     &#064;ContextConfiguration(classes = WebConfig.class)
+ * })
+ * public class ControllerIntegrationTests {
+ *
+ *     &#064;Autowired
+ *     private WebApplicationContext wac;
+ *
+ *     // ...
+ * }</pre>
+ *
+ * <h4>Class Hierarchy with Implicit Parent Context</h4>
+ * <p>The following test classes define a context hierarchy within a test class
+ * hierarchy. {@code AbstractWebTests} declares the configuration for a root
+ * {@code WebApplicationContext} in a Spring-powered web application. Note,
+ * however, that {@code AbstractWebTests} does not declare {@code @ContextHierarchy};
+ * consequently, subclasses of {@code AbstractWebTests} can optionally participate
+ * in a context hierarchy or follow the standard semantics for {@code @ContextConfiguration}.
+ * {@code SoapWebServiceTests} and {@code RestWebServiceTests} both extend
+ * {@code AbstractWebTests} and define a context hierarchy via {@code @ContextHierarchy}.
+ * The result is that three application contexts will be loaded (one for each
+ * declaration of {@code @ContextConfiguration}, and the application context
+ * loaded based on the configuration in {@code AbstractWebTests} will be set as
+ * the parent context for each of the contexts loaded for the concrete subclasses. 
+ *
+ * <pre class="code">
+ * &#064;RunWith(SpringJUnit4ClassRunner.class)
+ * &#064;WebAppConfiguration
+ * &#064;ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
+ * public abstract class AbstractWebTests {}
+ *
+ * &#064;ContextHierarchy(&#064;ContextConfiguration("/spring/soap-ws-config.xml")
+ * public class SoapWebServiceTests extends AbstractWebTests {}
+ *
+ * &#064;ContextHierarchy(&#064;ContextConfiguration("/spring/rest-ws-config.xml")
+ * public class RestWebServiceTests extends AbstractWebTests {}</pre>
+ *
+ * <h4>Class Hierarchy with Merged Context Hierarchy Configuration</h4>
+ * <p>The following classes demonstrate the use of <em>named</em> hierarchy levels
+ * in order to <em>merge</em> the configuration for specific levels in a context
+ * hierarchy. {@code BaseTests} defines two levels in the hierarchy, {@code parent}
+ * and {@code child}. {@code ExtendedTests} extends {@code BaseTests} and instructs
+ * the Spring TestContext Framework to merge the context configuration for the
+ * {@code child} hierarchy level, simply by ensuring that the names declared via
+ * {@link ContextConfiguration#name} are both {@code "child"}. The result is that
+ * three application contexts will be loaded: one for {@code "/app-config.xml"},
+ * one for {@code "/user-config.xml"}, and one for <code>{"/user-config.xml",
+ * "/order-config.xml"}</code>. As with the previous example, the application
+ * context loaded from {@code "/app-config.xml"} will be set as the parent context
+ * for the contexts loaded from {@code "/user-config.xml"} and <code>{"/user-config.xml",
+ * "/order-config.xml"}</code>.
+ *
+ * <pre class="code">
+ * &#064;RunWith(SpringJUnit4ClassRunner.class)
+ * &#064;ContextHierarchy({
+ *     &#064;ContextConfiguration(name = "parent", locations = "/app-config.xml"),
+ *     &#064;ContextConfiguration(name = "child",  locations = "/user-config.xml")
+ * })
+ * public class BaseTests {}
+ * 
+ * &#064;ContextHierarchy(
+ *     &#064;ContextConfiguration(name = "child",  locations = "/order-config.xml")
+ * )
+ * public class ExtendedTests extends BaseTests {}</pre>
+ *
+ * <h4>Class Hierarchy with Overridden Context Hierarchy Configuration</h4>
+ * <p>In contrast to the previous example, this example demonstrates how to
+ * <em>override</em> the configuration for a given named level in a context hierarchy
+ * by setting the {@link ContextConfiguration#inheritLocations} flag to {@code false}.
+ * Consequently, the application context for {@code ExtendedTests} will be loaded
+ * only from {@code "/test-user-config.xml"} and will have its parent set to the
+ * context loaded from {@code "/app-config.xml"}. 
+ *
+ * <pre class="code">
+ * &#064;RunWith(SpringJUnit4ClassRunner.class)
+ * &#064;ContextHierarchy({
+ *     &#064;ContextConfiguration(name = "parent", locations = "/app-config.xml"),
+ *     &#064;ContextConfiguration(name = "child",  locations = "/user-config.xml")
+ * })
+ * public class BaseTests {}
+ * 
+ * &#064;ContextHierarchy(
+ *     &#064;ContextConfiguration(name = "child",  locations = "/test-user-config.xml", inheritLocations=false)
+ * )
+ * public class ExtendedTests extends BaseTests {}</pre>
+ *
+ * @author Sam Brannen
+ * @since 3.2.2
+ * @see ContextConfiguration
+ * @see org.springframework.context.ApplicationContext
+ */
+@Documented
+@Inherited
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface ContextHierarchy {
+
+	/**
+	 * A list of {@link ContextConfiguration @ContextConfiguration} instances,
+	 * each of which defines a level in the context hierarchy.
+	 *
+	 * <p>If you need to merge or override the configuration for a given level
+	 * of the context hierarchy within a test class hierarchy, you must explicitly
+	 * name that level by supplying the same value to the {@link ContextConfiguration#name
+	 * name} attribute in {@code @ContextConfiguration} at each level in the
+	 * class hierarchy. See the class-level Javadoc for examples.
+	 */
+	ContextConfiguration[] value();
+
+}
diff --git a/spring-test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java b/spring-test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java
index 47ee0c78cf0e..a43897eb0b6e 100644
--- a/spring-test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java
+++ b/spring-test/src/main/java/org/springframework/test/context/ContextLoaderUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,20 +16,24 @@
 
 package org.springframework.test.context;
 
-import static org.springframework.beans.BeanUtils.*;
-import static org.springframework.core.annotation.AnnotationUtils.*;
+import static org.springframework.beans.BeanUtils.instantiateClass;
+import static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClass;
+import static org.springframework.core.annotation.AnnotationUtils.findAnnotationDeclaringClassForTypes;
+import static org.springframework.core.annotation.AnnotationUtils.isAnnotationDeclaredLocally;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
 import org.springframework.context.ApplicationContextInitializer;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.core.annotation.AnnotationUtils;
@@ -41,7 +45,8 @@
 /**
  * Utility methods for working with {@link ContextLoader ContextLoaders} and
  * {@link SmartContextLoader SmartContextLoaders} and resolving resource locations,
- * annotated classes, and active bean definition profiles.
+ * annotated classes, active bean definition profiles, and application context
+ * initializers.
  *
  * @author Sam Brannen
  * @since 3.1
@@ -50,10 +55,14 @@
  * @see ContextConfiguration
  * @see ContextConfigurationAttributes
  * @see ActiveProfiles
+ * @see ApplicationContextInitializer
+ * @see ContextHierarchy
  * @see MergedContextConfiguration
  */
 abstract class ContextLoaderUtils {
 
+	static final String GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX = "ContextHierarchyLevel#";
+
 	private static final Log logger = LogFactory.getLog(ContextLoaderUtils.class);
 
 	private static final String DEFAULT_CONTEXT_LOADER_CLASS_NAME = "org.springframework.test.context.support.DelegatingSmartContextLoader";
@@ -68,28 +77,28 @@ private ContextLoaderUtils() {
 	}
 
 	/**
-	 * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the
-	 * supplied list of {@link ContextConfigurationAttributes} and then
-	 * instantiate and return that {@code ContextLoader}.
+	 * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the supplied
+	 * list of {@link ContextConfigurationAttributes} and then instantiate and return that
+	 * {@code ContextLoader}.
 	 *
-	 * <p>If the supplied {@code defaultContextLoaderClassName} is
-	 * {@code null} or <em>empty</em>, depending on the absence or presence
-	 * of {@link org.springframework.test.context.web.WebAppConfiguration @WebAppConfiguration}
-	 * either {@value #DEFAULT_CONTEXT_LOADER_CLASS_NAME}
-	 * or {@value #DEFAULT_WEB_CONTEXT_LOADER_CLASS_NAME} will be used as the
-	 * default context loader class name. For details on the class resolution
-	 * process, see {@link #resolveContextLoaderClass()}.
+	 * <p>If the supplied {@code defaultContextLoaderClassName} is {@code null} or
+	 * <em>empty</em>, depending on the absence or presence of
+	 * {@link org.springframework.test.context.web.WebAppConfiguration @WebAppConfiguration} either
+	 * {@code "org.springframework.test.context.support.DelegatingSmartContextLoader"} or
+	 * {@code "org.springframework.test.context.web.WebDelegatingSmartContextLoader"} will
+	 * be used as the default context loader class name. For details on the class
+	 * resolution process, see {@link #resolveContextLoaderClass}.
 	 *
-	 * @param testClass the test class for which the {@code ContextLoader}
-	 * should be resolved; must not be {@code null}
-	 * @param configAttributesList the list of configuration attributes to process;
-	 * must not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>
+	 * @param testClass the test class for which the {@code ContextLoader} should be
+	 * resolved; must not be {@code null}
+	 * @param configAttributesList the list of configuration attributes to process; must
+	 * not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>
 	 * (i.e., as if we were traversing up the class hierarchy)
-	 * @param defaultContextLoaderClassName the name of the default
-	 * {@code ContextLoader} class to use; may be {@code null} or <em>empty</em>
-	 * @return the resolved {@code ContextLoader} for the supplied
-	 * {@code testClass} (never {@code null})
-	 * @see #resolveContextLoaderClass()
+	 * @param defaultContextLoaderClassName the name of the default {@code ContextLoader}
+	 * class to use; may be {@code null} or <em>empty</em>
+	 * @return the resolved {@code ContextLoader} for the supplied {@code testClass}
+	 * (never {@code null})
+	 * @see #resolveContextLoaderClass
 	 */
 	static ContextLoader resolveContextLoader(Class<?> testClass,
 			List<ContextConfigurationAttributes> configAttributesList, String defaultContextLoaderClassName) {
@@ -110,36 +119,35 @@ static ContextLoader resolveContextLoader(Class<?> testClass,
 	}
 
 	/**
-	 * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the
-	 * supplied list of {@link ContextConfigurationAttributes}.
+	 * Resolve the {@link ContextLoader} {@linkplain Class class} to use for the supplied
+	 * list of {@link ContextConfigurationAttributes}.
 	 *
-	 * <p>Beginning with the first level in the context configuration attributes
-	 * hierarchy:
+	 * <p>Beginning with the first level in the context configuration attributes hierarchy:
 	 *
 	 * <ol>
 	 * <li>If the {@link ContextConfigurationAttributes#getContextLoaderClass()
 	 * contextLoaderClass} property of {@link ContextConfigurationAttributes} is
 	 * configured with an explicit class, that class will be returned.</li>
-	 * <li>If an explicit {@code ContextLoader} class is not specified at the
-	 * current level in the hierarchy, traverse to the next level in the hierarchy
-	 * and return to step #1.</li>
-	 * <li>If no explicit {@code ContextLoader} class is found after traversing
-	 * the hierarchy, an attempt will be made to load and return the class
-	 * with the supplied {@code defaultContextLoaderClassName}.</li>
+	 * <li>If an explicit {@code ContextLoader} class is not specified at the current
+	 * level in the hierarchy, traverse to the next level in the hierarchy and return to
+	 * step #1.</li>
+	 * <li>If no explicit {@code ContextLoader} class is found after traversing the
+	 * hierarchy, an attempt will be made to load and return the class with the supplied
+	 * {@code defaultContextLoaderClassName}.</li>
 	 * </ol>
 	 *
-	 * @param testClass the class for which to resolve the {@code ContextLoader}
-	 * class; must not be {@code null}; only used for logging purposes
-	 * @param configAttributesList the list of configuration attributes to process;
-	 * must not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>
+	 * @param testClass the class for which to resolve the {@code ContextLoader} class;
+	 * must not be {@code null}; only used for logging purposes
+	 * @param configAttributesList the list of configuration attributes to process; must
+	 * not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>
 	 * (i.e., as if we were traversing up the class hierarchy)
-	 * @param defaultContextLoaderClassName the name of the default
-	 * {@code ContextLoader} class to use; must not be {@code null} or empty
+	 * @param defaultContextLoaderClassName the name of the default {@code ContextLoader}
+	 * class to use; must not be {@code null} or empty
 	 * @return the {@code ContextLoader} class to use for the supplied test class
 	 * @throws IllegalArgumentException if {@code @ContextConfiguration} is not
 	 * <em>present</em> on the supplied test class
-	 * @throws IllegalStateException if the default {@code ContextLoader} class
-	 * could not be loaded
+	 * @throws IllegalStateException if the default {@code ContextLoader} class could not
+	 * be loaded
 	 */
 	@SuppressWarnings("unchecked")
 	static Class<? extends ContextLoader> resolveContextLoaderClass(Class<?> testClass,
@@ -181,22 +189,201 @@ static Class<? extends ContextLoader> resolveContextLoaderClass(Class<?> testCla
 	}
 
 	/**
-	 * Resolve the list of {@link ContextConfigurationAttributes configuration
-	 * attributes} for the supplied {@link Class class} and its superclasses.
+	 * Convenience method for creating a {@link ContextConfigurationAttributes} instance
+	 * from the supplied {@link ContextConfiguration} and declaring class and then adding
+	 * the attributes to the supplied list.
+	 */
+	private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,
+			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {
+		if (logger.isTraceEnabled()) {
+			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",
+				contextConfiguration, declaringClass.getName()));
+		}
+
+		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass,
+			contextConfiguration);
+		if (logger.isTraceEnabled()) {
+			logger.trace("Resolved context configuration attributes: " + attributes);
+		}
+		attributesList.add(attributes);
+	}
+
+	/**
+	 * Resolve the list of lists of {@linkplain ContextConfigurationAttributes context
+	 * configuration attributes} for the supplied {@linkplain Class test class} and its
+	 * superclasses, taking into account context hierarchies declared via
+	 * {@link ContextHierarchy @ContextHierarchy} and
+	 * {@link ContextConfiguration @ContextConfiguration}.
+	 *
+	 * <p>The outer list represents a top-down ordering of context configuration
+	 * attributes, where each element in the list represents the context configuration
+	 * declared on a given test class in the class hierarchy. Each nested list
+	 * contains the context configuration attributes declared either via a single
+	 * instance of {@code @ContextConfiguration} on the particular class or via
+	 * multiple instances of {@code @ContextConfiguration} declared within a
+	 * single {@code @ContextHierarchy} instance on the particular class.
+	 * Furthermore, each nested list maintains the order in which
+	 * {@code @ContextConfiguration} instances are declared.
+	 *
+	 * <p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and
+	 * {@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of
+	 * {@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>
+	 * be taken into consideration. If these flags need to be honored, that must be
+	 * handled manually when traversing the nested lists returned by this method.
+	 *
+	 * @param testClass the class for which to resolve the context hierarchy attributes
+	 * (must not be {@code null})
+	 * @return the list of lists of configuration attributes for the specified class;
+	 * never {@code null}
+	 * @throws IllegalArgumentException if the supplied class is {@code null}; if
+	 * neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is
+	 * <em>present</em> on the supplied class; if a given class in the class hierarchy
+	 * declares both {@code @ContextConfiguration} and {@code @ContextHierarchy} as
+	 * top-level annotations; or if individual {@code @ContextConfiguration}
+	 * elements within a {@code @ContextHierarchy} declaration on a given class
+	 * in the class hierarchy do not define unique context configuration.
+	 *
+	 * @since 3.2.2
+	 * @see #buildContextHierarchyMap(Class)
+	 * @see #resolveContextConfigurationAttributes(Class)
+	 */
+	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {
+		Assert.notNull(testClass, "Class must not be null");
+
+		final Class<ContextConfiguration> contextConfigType = ContextConfiguration.class;
+		final Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class;
+		final List<Class<? extends Annotation>> annotationTypes = Arrays.asList(contextConfigType, contextHierarchyType);
+
+		final List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>();
+
+		Class<?> declaringClass = findAnnotationDeclaringClassForTypes(annotationTypes, testClass);
+		Assert.notNull(declaringClass, String.format(
+			"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",
+			contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()));
+
+		while (declaringClass != null) {
+
+			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass);
+			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass);
+
+			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {
+				String msg = String.format("Test class [%s] has been configured with both @ContextConfiguration "
+						+ "and @ContextHierarchy as class-level annotations. Only one of these annotations may "
+						+ "be declared as a top-level annotation per test class.", declaringClass.getName());
+				logger.error(msg);
+				throw new IllegalStateException(msg);
+			}
+
+			final List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>();
+
+			if (contextConfigDeclaredLocally) {
+				ContextConfiguration contextConfiguration = declaringClass.getAnnotation(contextConfigType);
+				convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, declaringClass,
+					configAttributesList);
+			}
+			else if (contextHierarchyDeclaredLocally) {
+				ContextHierarchy contextHierarchy = declaringClass.getAnnotation(contextHierarchyType);
+				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {
+					convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, declaringClass,
+						configAttributesList);
+				}
+
+				// Check for uniqueness
+				Set<ContextConfigurationAttributes> configAttributesSet = new HashSet<ContextConfigurationAttributes>(
+					configAttributesList);
+				if (configAttributesSet.size() != configAttributesList.size()) {
+					String msg = String.format("The @ContextConfiguration elements configured via "
+							+ "@ContextHierarchy in test class [%s] must define unique contexts to load.",
+						declaringClass.getName());
+					logger.error(msg);
+					throw new IllegalStateException(msg);
+				}
+			}
+			else {
+				// This should theoretically actually never happen...
+				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration "
+						+ "nor @ContextHierarchy as a class-level annotation.", declaringClass.getName());
+				logger.error(msg);
+				throw new IllegalStateException(msg);
+			}
+
+			hierarchyAttributes.add(0, configAttributesList);
+
+			declaringClass = findAnnotationDeclaringClassForTypes(annotationTypes, declaringClass.getSuperclass());
+		}
+
+		return hierarchyAttributes;
+	}
+
+	/**
+	 * Build a <em>context hierarchy map</em> for the supplied {@linkplain Class
+	 * test class} and its superclasses, taking into account context hierarchies
+	 * declared via {@link ContextHierarchy @ContextHierarchy} and
+	 * {@link ContextConfiguration @ContextConfiguration}.
+	 *
+	 * <p>Each value in the map represents the consolidated list of {@linkplain
+	 * ContextConfigurationAttributes context configuration attributes} for a
+	 * given level in the context hierarchy (potentially across the test class
+	 * hierarchy), keyed by the {@link ContextConfiguration#name() name} of the
+	 * context hierarchy level.
+	 *
+	 * <p>If a given level in the context hierarchy does not have an explicit
+	 * name (i.e., configured via {@link ContextConfiguration#name}), a name will
+	 * be generated for that hierarchy level by appending the numerical level to
+	 * the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}.
+	 *
+	 * @param testClass the class for which to resolve the context hierarchy map
+	 * (must not be {@code null})
+	 * @return a map of context configuration attributes for the context hierarchy,
+	 * keyed by context hierarchy level name; never {@code null}
+	 *
+	 * @since 3.2.2
+	 * @see #resolveContextHierarchyAttributes(Class)
+	 */
+	static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {
+		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>();
+		int hierarchyLevel = 1;
+
+		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {
+			for (ContextConfigurationAttributes configAttributes : configAttributesList) {
+				String name = configAttributes.getName();
+
+				// Assign a generated name?
+				if (!StringUtils.hasText(name)) {
+					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel;
+				}
+
+				// Encountered a new context hierarchy level?
+				if (!map.containsKey(name)) {
+					hierarchyLevel++;
+					map.put(name, new ArrayList<ContextConfigurationAttributes>());
+				}
+
+				map.get(name).add(configAttributes);
+			}
+		}
+
+		return map;
+	}
+
+	/**
+	 * Resolve the list of {@linkplain ContextConfigurationAttributes context
+	 * configuration attributes} for the supplied {@linkplain Class test class} and its
+	 * superclasses.
 	 *
-	 * <p>Note that the {@link ContextConfiguration#inheritLocations
-	 * inheritLocations} and {@link ContextConfiguration#inheritInitializers()
-	 * inheritInitializers} flags of {@link ContextConfiguration
-	 * &#064;ContextConfiguration} will <strong>not</strong> be taken into
-	 * consideration. If these flags need to be honored, that must be handled
-	 * manually when traversing the list returned by this method.
+	 * <p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and
+	 * {@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of
+	 * {@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>
+	 * be taken into consideration. If these flags need to be honored, that must be
+	 * handled manually when traversing the list returned by this method.
 	 *
 	 * @param testClass the class for which to resolve the configuration attributes (must
 	 * not be {@code null})
-	 * @return the list of configuration attributes for the specified class, ordered <em>bottom-up</em>
-	 * (i.e., as if we were traversing up the class hierarchy); never {@code null}
-	 * @throws IllegalArgumentException if the supplied class is {@code null} or
-	 * if {@code @ContextConfiguration} is not <em>present</em> on the supplied class
+	 * @return the list of configuration attributes for the specified class, ordered
+	 * <em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy);
+	 * never {@code null}
+	 * @throws IllegalArgumentException if the supplied class is {@code null} or if
+	 * {@code @ContextConfiguration} is not <em>present</em> on the supplied class
 	 */
 	static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {
 		Assert.notNull(testClass, "Class must not be null");
@@ -211,19 +398,7 @@ static List<ContextConfigurationAttributes> resolveContextConfigurationAttribute
 
 		while (declaringClass != null) {
 			ContextConfiguration contextConfiguration = declaringClass.getAnnotation(annotationType);
-			if (logger.isTraceEnabled()) {
-				logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",
-					contextConfiguration, declaringClass.getName()));
-			}
-
-			ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass,
-				contextConfiguration);
-			if (logger.isTraceEnabled()) {
-				logger.trace("Resolved context configuration attributes: " + attributes);
-			}
-
-			attributesList.add(attributes);
-
+			convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, declaringClass, attributesList);
 			declaringClass = findAnnotationDeclaringClass(annotationType, declaringClass.getSuperclass());
 		}
 
@@ -231,22 +406,21 @@ static List<ContextConfigurationAttributes> resolveContextConfigurationAttribute
 	}
 
 	/**
-	 * Resolve the list of merged {@code ApplicationContextInitializer} classes
-	 * for the supplied list of {@code ContextConfigurationAttributes}.
+	 * Resolve the list of merged {@code ApplicationContextInitializer} classes for the
+	 * supplied list of {@code ContextConfigurationAttributes}.
 	 *
 	 * <p>Note that the {@link ContextConfiguration#inheritInitializers inheritInitializers}
 	 * flag of {@link ContextConfiguration @ContextConfiguration} will be taken into
-	 * consideration. Specifically, if the {@code inheritInitializers} flag is
-	 * set to {@code true} for a given level in the class hierarchy represented by
-	 * the provided configuration attributes, context initializer classes defined
-	 * at the given level will be merged with those defined in higher levels
-	 * of the class hierarchy.
+	 * consideration. Specifically, if the {@code inheritInitializers} flag is set to
+	 * {@code true} for a given level in the class hierarchy represented by the provided
+	 * configuration attributes, context initializer classes defined at the given level
+	 * will be merged with those defined in higher levels of the class hierarchy.
 	 *
-	 * @param configAttributesList the list of configuration attributes to process;
-	 * must not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>
+	 * @param configAttributesList the list of configuration attributes to process; must
+	 * not be {@code null} or <em>empty</em>; must be ordered <em>bottom-up</em>
 	 * (i.e., as if we were traversing up the class hierarchy)
-	 * @return the set of merged context initializer classes, including those
-	 * from superclasses if appropriate (never {@code null})
+	 * @return the set of merged context initializer classes, including those from
+	 * superclasses if appropriate (never {@code null})
 	 * @since 3.2
 	 */
 	static Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> resolveInitializerClasses(
@@ -275,16 +449,15 @@ static Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableA
 	/**
 	 * Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.
 	 *
-	 * <p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles}
-	 * flag of {@link ActiveProfiles &#064;ActiveProfiles} will be taken into
-	 * consideration. Specifically, if the {@code inheritProfiles} flag is
-	 * set to {@code true}, profiles defined in the test class will be
-	 * merged with those defined in superclasses.
+	 * <p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of
+	 * {@link ActiveProfiles @ActiveProfiles} will be taken into consideration.
+	 * Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles
+	 * defined in the test class will be merged with those defined in superclasses.
 	 *
-	 * @param testClass the class for which to resolve the active profiles (must
-	 * not be {@code null})
-	 * @return the set of active profiles for the specified class, including
-	 * active profiles from superclasses if appropriate (never {@code null})
+	 * @param testClass the class for which to resolve the active profiles (must not be
+	 * {@code null})
+	 * @return the set of active profiles for the specified class, including active
+	 * profiles from superclasses if appropriate (never {@code null})
 	 * @see ActiveProfiles
 	 * @see org.springframework.context.annotation.Profile
 	 */
@@ -339,26 +512,85 @@ else if (!ObjectUtils.isEmpty(valueProfiles)) {
 	}
 
 	/**
-	 * Build the {@link MergedContextConfiguration merged context configuration}
-	 * for the supplied {@link Class testClass} and
-	 * {@code defaultContextLoaderClassName}.
+	 * Build the {@link MergedContextConfiguration merged context configuration} for
+	 * the supplied {@link Class testClass} and {@code defaultContextLoaderClassName},
+	 * taking into account context hierarchies declared via
+	 * {@link ContextHierarchy @ContextHierarchy} and
+	 * {@link ContextConfiguration @ContextConfiguration}.
 	 *
 	 * @param testClass the test class for which the {@code MergedContextConfiguration}
 	 * should be built (must not be {@code null})
-	 * @param defaultContextLoaderClassName the name of the default
-	 * {@code ContextLoader} class to use (may be {@code null})
+	 * @param defaultContextLoaderClassName the name of the default {@code ContextLoader}
+	 * class to use (may be {@code null})
+	 * @param cacheAwareContextLoaderDelegate the cache-aware context loader delegate to
+	 * be passed to the {@code MergedContextConfiguration} constructor
 	 * @return the merged context configuration
-	 * @see #resolveContextLoader()
-	 * @see #resolveContextConfigurationAttributes()
-	 * @see SmartContextLoader#processContextConfiguration()
-	 * @see ContextLoader#processLocations()
-	 * @see #resolveActiveProfiles()
-	 * @see MergedContextConfiguration
+	 * @see #buildContextHierarchyMap(Class)
+	 * @see #buildMergedContextConfiguration(Class, List, String, MergedContextConfiguration, CacheAwareContextLoaderDelegate)
 	 */
+	@SuppressWarnings("javadoc")
 	static MergedContextConfiguration buildMergedContextConfiguration(Class<?> testClass,
-			String defaultContextLoaderClassName) {
+			String defaultContextLoaderClassName, CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate) {
+
+		if (testClass.isAnnotationPresent(ContextHierarchy.class)) {
+			Map<String, List<ContextConfigurationAttributes>> hierarchyMap = buildContextHierarchyMap(testClass);
+
+			MergedContextConfiguration parentConfig = null;
+			MergedContextConfiguration mergedConfig = null;
+
+			for (List<ContextConfigurationAttributes> list : hierarchyMap.values()) {
+				List<ContextConfigurationAttributes> reversedList = new ArrayList<ContextConfigurationAttributes>(list);
+				Collections.reverse(reversedList);
+
+				// Don't use the supplied testClass; instead ensure that we are
+				// building the MCC for the actual test class that declared the
+				// configuration for the current level in the context hierarchy.
+				Assert.notEmpty(reversedList, "ContextConfigurationAttributes list must not be empty");
+				Class<?> declaringClass = reversedList.get(0).getDeclaringClass();
+
+				mergedConfig = buildMergedContextConfiguration(declaringClass, reversedList,
+					defaultContextLoaderClassName, parentConfig, cacheAwareContextLoaderDelegate);
+				parentConfig = mergedConfig;
+			}
+
+			// Return the last level in the context hierarchy
+			return mergedConfig;
+		}
+		else {
+			return buildMergedContextConfiguration(testClass, resolveContextConfigurationAttributes(testClass),
+				defaultContextLoaderClassName, null, cacheAwareContextLoaderDelegate);
+		}
+	}
+
+	/**
+	 * Build the {@link MergedContextConfiguration merged context configuration} for the
+	 * supplied {@link Class testClass}, context configuration attributes,
+	 * {@code defaultContextLoaderClassName}, and parent context configuration.
+	 *
+	 * @param testClass the test class for which the {@code MergedContextConfiguration}
+	 * should be built (must not be {@code null})
+	 * @param configAttributesList the list of context configuration attributes for the
+	 * specified test class, ordered <em>bottom-up</em> (i.e., as if we were
+	 * traversing up the class hierarchy); never {@code null} or empty
+	 * @param defaultContextLoaderClassName the name of the default {@code ContextLoader}
+	 * class to use (may be {@code null})
+	 * @param parentConfig the merged context configuration for the parent application
+	 * context in a context hierarchy, or {@code null} if there is no parent
+	 * @param cacheAwareContextLoaderDelegate the cache-aware context loader delegate to
+	 * be passed to the {@code MergedContextConfiguration} constructor
+	 * @return the merged context configuration
+	 * @see #resolveContextLoader
+	 * @see #resolveContextConfigurationAttributes
+	 * @see SmartContextLoader#processContextConfiguration
+	 * @see ContextLoader#processLocations
+	 * @see #resolveActiveProfiles
+	 * @see MergedContextConfiguration
+	 */
+	private static MergedContextConfiguration buildMergedContextConfiguration(final Class<?> testClass,
+			final List<ContextConfigurationAttributes> configAttributesList,
+			final String defaultContextLoaderClassName, MergedContextConfiguration parentConfig,
+			CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate) {
 
-		final List<ContextConfigurationAttributes> configAttributesList = resolveContextConfigurationAttributes(testClass);
 		final ContextLoader contextLoader = resolveContextLoader(testClass, configAttributesList,
 			defaultContextLoaderClassName);
 		final List<String> locationsList = new ArrayList<String>();
@@ -394,22 +626,21 @@ static MergedContextConfiguration buildMergedContextConfiguration(Class<?> testC
 		String[] activeProfiles = resolveActiveProfiles(testClass);
 
 		MergedContextConfiguration mergedConfig = buildWebMergedContextConfiguration(testClass, locations, classes,
-			initializerClasses, activeProfiles, contextLoader);
+			initializerClasses, activeProfiles, contextLoader, cacheAwareContextLoaderDelegate, parentConfig);
 
 		if (mergedConfig == null) {
 			mergedConfig = new MergedContextConfiguration(testClass, locations, classes, initializerClasses,
-				activeProfiles, contextLoader);
+				activeProfiles, contextLoader, cacheAwareContextLoaderDelegate, parentConfig);
 		}
 
 		return mergedConfig;
 	}
 
 	/**
-	 * Load the {@link org.springframework.test.context.web.WebAppConfiguration @WebAppConfiguration}
+	 * Load the {@link org.springframework.test.context.web.WebAppConfiguration}
 	 * class, using reflection in order to avoid package cycles.
 	 *
-	 * @return the {@code @WebAppConfiguration} class or {@code null} if it
-	 * cannot be loaded
+	 * @return the {@code @WebAppConfiguration} class or {@code null} if it cannot be loaded
 	 * @since 3.2
 	 */
 	@SuppressWarnings("unchecked")
@@ -428,12 +659,10 @@ private static Class<? extends Annotation> loadWebAppConfigurationClass() {
 	}
 
 	/**
-	 * Attempt to build a {@link org.springframework.test.context.web.WebMergedContextConfiguration
-	 * WebMergedContextConfiguration} from the supplied arguments, using reflection
-	 * in order to avoid package cycles.
+	 * Attempt to build a {@link org.springframework.test.context.web.WebMergedContextConfiguration}
+	 * from the supplied arguments, using reflection in order to avoid package cycles.
 	 *
-	 * @return the {@code WebMergedContextConfiguration} or {@code null} if
-	 * it could not be built
+	 * @return the {@code WebMergedContextConfiguration} or {@code null} if it could not be built
 	 * @since 3.2
 	 */
 	@SuppressWarnings("unchecked")
@@ -442,7 +671,8 @@ private static MergedContextConfiguration buildWebMergedContextConfiguration(
 			String[] locations,
 			Class<?>[] classes,
 			Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> initializerClasses,
-			String[] activeProfiles, ContextLoader contextLoader) {
+			String[] activeProfiles, ContextLoader contextLoader,
+			CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, MergedContextConfiguration parentConfig) {
 
 		Class<? extends Annotation> webAppConfigClass = loadWebAppConfigurationClass();
 
@@ -456,11 +686,12 @@ private static MergedContextConfiguration buildWebMergedContextConfiguration(
 
 				Constructor<? extends MergedContextConfiguration> constructor = ClassUtils.getConstructorIfAvailable(
 					webMergedConfigClass, Class.class, String[].class, Class[].class, Set.class, String[].class,
-					String.class, ContextLoader.class);
+					String.class, ContextLoader.class, CacheAwareContextLoaderDelegate.class,
+					MergedContextConfiguration.class);
 
 				if (constructor != null) {
 					return instantiateClass(constructor, testClass, locations, classes, initializerClasses,
-						activeProfiles, resourceBasePath, contextLoader);
+						activeProfiles, resourceBasePath, contextLoader, cacheAwareContextLoaderDelegate, parentConfig);
 				}
 			}
 			catch (Throwable t) {
diff --git a/spring-test/src/main/java/org/springframework/test/context/MergedContextConfiguration.java b/spring-test/src/main/java/org/springframework/test/context/MergedContextConfiguration.java
index b4c1f683a2c8..befe85c7cba6 100644
--- a/spring-test/src/main/java/org/springframework/test/context/MergedContextConfiguration.java
+++ b/spring-test/src/main/java/org/springframework/test/context/MergedContextConfiguration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,9 +23,11 @@
 import java.util.SortedSet;
 import java.util.TreeSet;
 
+import org.springframework.context.ApplicationContext;
 import org.springframework.context.ApplicationContextInitializer;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.core.style.ToStringCreator;
+import org.springframework.util.Assert;
 import org.springframework.util.ObjectUtils;
 import org.springframework.util.StringUtils;
 
@@ -72,6 +74,8 @@ public class MergedContextConfiguration implements Serializable {
 	private final Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses;
 	private final String[] activeProfiles;
 	private final ContextLoader contextLoader;
+	private final CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate;
+	private final MergedContextConfiguration parent;
 
 
 	private static String[] processLocations(String[] locations) {
@@ -149,6 +153,7 @@ public MergedContextConfiguration(Class<?> testClass, String[] locations, Class<
 	 * @param contextInitializerClasses the merged context initializer classes
 	 * @param activeProfiles the merged active bean definition profiles
 	 * @param contextLoader the resolved {@code ContextLoader}
+	 * @see #MergedContextConfiguration(Class, String[], Class[], Set, String[], ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)
 	 */
 	public MergedContextConfiguration(
 			Class<?> testClass,
@@ -156,12 +161,48 @@ public MergedContextConfiguration(
 			Class<?>[] classes,
 			Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,
 			String[] activeProfiles, ContextLoader contextLoader) {
+		this(testClass, locations, classes, contextInitializerClasses, activeProfiles, contextLoader, null, null);
+	}
+
+	/**
+	 * Create a new {@code MergedContextConfiguration} instance for the
+	 * supplied test class, resource locations, annotated classes, context
+	 * initializers, active profiles, {@code ContextLoader}, and parent
+	 * configuration.
+	 *
+	 * <p>If a {@code null} value is supplied for {@code locations},
+	 * {@code classes}, or {@code activeProfiles} an empty array will
+	 * be stored instead. If a {@code null} value is supplied for the
+	 * {@code contextInitializerClasses} an empty set will be stored instead.
+	 * Furthermore, active profiles will be sorted, and duplicate profiles will
+	 * be removed.
+	 *
+	 * @param testClass the test class for which the configuration was merged
+	 * @param locations the merged resource locations
+	 * @param classes the merged annotated classes
+	 * @param contextInitializerClasses the merged context initializer classes
+	 * @param activeProfiles the merged active bean definition profiles
+	 * @param contextLoader the resolved {@code ContextLoader}
+	 * @param cacheAwareContextLoaderDelegate a cache-aware context loader
+	 * delegate with which to retrieve the parent context
+	 * @param parent the parent configuration or {@code null} if there is no parent
+	 * @since 3.2.2
+	 */
+	public MergedContextConfiguration(
+			Class<?> testClass,
+			String[] locations,
+			Class<?>[] classes,
+			Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,
+			String[] activeProfiles, ContextLoader contextLoader,
+			CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, MergedContextConfiguration parent) {
 		this.testClass = testClass;
 		this.locations = processLocations(locations);
 		this.classes = processClasses(classes);
 		this.contextInitializerClasses = processContextInitializerClasses(contextInitializerClasses);
 		this.activeProfiles = processActiveProfiles(activeProfiles);
 		this.contextLoader = contextLoader;
+		this.cacheAwareContextLoaderDelegate = cacheAwareContextLoaderDelegate;
+		this.parent = parent;
 	}
 
 	/**
@@ -207,6 +248,39 @@ public ContextLoader getContextLoader() {
 		return contextLoader;
 	}
 
+	/**
+	 * Get the {@link MergedContextConfiguration} for the parent application context in a
+	 * context hierarchy.
+	 *
+	 * @return the parent configuration or {@code null} if there is no parent
+	 * @see #getParentApplicationContext()
+	 * @since 3.2.2
+	 */
+	public MergedContextConfiguration getParent() {
+		return this.parent;
+	}
+
+	/**
+	 * Get the parent {@link ApplicationContext} for the context defined by this
+	 * {@code MergedContextConfiguration} from the context cache.
+	 * <p>
+	 * If the parent context has not yet been loaded, it will be loaded, stored in the
+	 * cache, and then returned.
+	 *
+	 * @return the parent {@code ApplicationContext} or {@code null} if there is no parent
+	 * @see #getParent()
+	 * @since 3.2.2
+	 */
+	public ApplicationContext getParentApplicationContext() {
+		if (parent == null) {
+			return null;
+		}
+
+		Assert.state(cacheAwareContextLoaderDelegate != null,
+			"Cannot retrieve a parent application context without access to the CacheAwareContextLoaderDelegate.");
+		return cacheAwareContextLoaderDelegate.loadContext(parent);
+	}
+
 	/**
 	 * Generate a unique hash code for all properties of this
 	 * {@code MergedContextConfiguration} excluding the
@@ -220,6 +294,7 @@ public int hashCode() {
 		result = prime * result + Arrays.hashCode(classes);
 		result = prime * result + contextInitializerClasses.hashCode();
 		result = prime * result + Arrays.hashCode(activeProfiles);
+		result = prime * result + (parent == null ? 0 : parent.hashCode());
 		result = prime * result + nullSafeToString(contextLoader).hashCode();
 		return result;
 	}
@@ -229,8 +304,9 @@ public int hashCode() {
 	 * instance by comparing both object's {@linkplain #getLocations() locations},
 	 * {@linkplain #getClasses() annotated classes},
 	 * {@linkplain #getContextInitializerClasses() context initializer classes},
-	 * {@linkplain #getActiveProfiles() active profiles}, and the fully qualified
-	 * names of their {@link #getContextLoader() ContextLoaders}.
+	 * {@linkplain #getActiveProfiles() active profiles},
+	 * {@linkplain #getParent() parents}, and the fully qualified names of their
+	 * {@link #getContextLoader() ContextLoaders}.
 	 */
 	@Override
 	public boolean equals(Object obj) {
@@ -247,15 +323,28 @@ public boolean equals(Object obj) {
 		if (!Arrays.equals(this.locations, that.locations)) {
 			return false;
 		}
+
 		if (!Arrays.equals(this.classes, that.classes)) {
 			return false;
 		}
+
 		if (!this.contextInitializerClasses.equals(that.contextInitializerClasses)) {
 			return false;
 		}
+
 		if (!Arrays.equals(this.activeProfiles, that.activeProfiles)) {
 			return false;
 		}
+
+		if (this.parent == null) {
+			if (that.parent != null) {
+				return false;
+			}
+		}
+		else if (!this.parent.equals(that.parent)) {
+			return false;
+		}
+
 		if (!nullSafeToString(this.contextLoader).equals(nullSafeToString(that.contextLoader))) {
 			return false;
 		}
@@ -267,8 +356,9 @@ public boolean equals(Object obj) {
 	 * Provide a String representation of the {@linkplain #getTestClass() test class},
 	 * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},
 	 * {@linkplain #getContextInitializerClasses() context initializer classes},
-	 * {@linkplain #getActiveProfiles() active profiles}, and the name of the
-	 * {@link #getContextLoader() ContextLoader}.
+	 * {@linkplain #getActiveProfiles() active profiles}, the name of the
+	 * {@link #getContextLoader() ContextLoader}, and the
+	 * {@linkplain #getParent() parent configuration}.
 	 */
 	@Override
 	public String toString() {
@@ -279,6 +369,7 @@ public String toString() {
 		.append("contextInitializerClasses", ObjectUtils.nullSafeToString(contextInitializerClasses))//
 		.append("activeProfiles", ObjectUtils.nullSafeToString(activeProfiles))//
 		.append("contextLoader", nullSafeToString(contextLoader))//
+		.append("parent", parent)//
 		.toString();
 	}
 
diff --git a/spring-test/src/main/java/org/springframework/test/context/SmartContextLoader.java b/spring-test/src/main/java/org/springframework/test/context/SmartContextLoader.java
index 8d069c85e918..d0495ca010b3 100644
--- a/spring-test/src/main/java/org/springframework/test/context/SmartContextLoader.java
+++ b/spring-test/src/main/java/org/springframework/test/context/SmartContextLoader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -29,8 +29,7 @@
  * context that it loads (see {@link MergedContextConfiguration#getActiveProfiles()}
  * and {@link #loadContext(MergedContextConfiguration)}).
  *
- * <p>See the Javadoc for
- * {@link ContextConfiguration @ContextConfiguration}
+ * <p>See the Javadoc for {@link ContextConfiguration @ContextConfiguration}
  * for a definition of <em>annotated class</em>.
  *
  * <p>Clients of a {@code SmartContextLoader} should call
@@ -48,8 +47,8 @@
  * <p>Even though {@code SmartContextLoader} extends {@code ContextLoader},
  * clients should favor {@code SmartContextLoader}-specific methods over those
  * defined in {@code ContextLoader}, particularly because a
- * {@code SmartContextLoader} may choose not to support methods defined in
- * the {@code ContextLoader} SPI.
+ * {@code SmartContextLoader} may choose not to support methods defined in the
+ * {@code ContextLoader} SPI.
  *
  * <p>Concrete implementations must provide a {@code public} no-args constructor.
  *
@@ -59,6 +58,9 @@
  * <li>{@link org.springframework.test.context.support.AnnotationConfigContextLoader AnnotationConfigContextLoader}</li>
  * <li>{@link org.springframework.test.context.support.GenericXmlContextLoader GenericXmlContextLoader}</li>
  * <li>{@link org.springframework.test.context.support.GenericPropertiesContextLoader GenericPropertiesContextLoader}</li>
+ * <li>{@link org.springframework.test.context.web.WebDelegatingSmartContextLoader WebDelegatingSmartContextLoader}</li>
+ * <li>{@link org.springframework.test.context.web.AnnotationConfigWebContextLoader AnnotationConfigWebContextLoader}</li>
+ * <li>{@link org.springframework.test.context.web.GenericXmlWebContextLoader GenericXmlWebContextLoader}</li>
  * </ul>
  *
  * @author Sam Brannen
diff --git a/spring-test/src/main/java/org/springframework/test/context/TestContext.java b/spring-test/src/main/java/org/springframework/test/context/TestContext.java
index 27100be94c18..d2719b50a0ae 100644
--- a/spring-test/src/main/java/org/springframework/test/context/TestContext.java
+++ b/spring-test/src/main/java/org/springframework/test/context/TestContext.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,9 +20,11 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+
 import org.springframework.context.ApplicationContext;
 import org.springframework.core.AttributeAccessorSupport;
 import org.springframework.core.style.ToStringCreator;
+import org.springframework.test.annotation.DirtiesContext.HierarchyMode;
 import org.springframework.util.Assert;
 
 /**
@@ -41,6 +43,8 @@ public class TestContext extends AttributeAccessorSupport {
 
 	private final ContextCache contextCache;
 
+	private final CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate;
+
 	private final MergedContextConfiguration mergedContextConfiguration;
 
 	private final Class<?> testClass;
@@ -61,16 +65,17 @@ public class TestContext extends AttributeAccessorSupport {
 	}
 
 	/**
-	 * Construct a new test context for the supplied {@link Class test class}
-	 * and {@link ContextCache context cache} and parse the corresponding
-	 * {@link ContextConfiguration &#064;ContextConfiguration} annotation, if
-	 * present.
+	 * Construct a new test context for the supplied {@linkplain Class test class}
+	 * and {@linkplain ContextCache context cache} and parse the corresponding
+	 * {@link ContextConfiguration &#064;ContextConfiguration} or
+	 * {@link ContextHierarchy &#064;ContextHierarchy} annotation, if present.
 	 * <p>If the supplied class name for the default {@code ContextLoader}
 	 * is {@code null} or <em>empty</em> and no concrete {@code ContextLoader}
-	 * class is explicitly supplied via the {@code @ContextConfiguration}
-	 * annotation, a
+	 * class is explicitly supplied via {@code @ContextConfiguration}, a
 	 * {@link org.springframework.test.context.support.DelegatingSmartContextLoader
-	 * DelegatingSmartContextLoader} will be used instead.
+	 * DelegatingSmartContextLoader} or
+	 * {@link org.springframework.test.context.web.WebDelegatingSmartContextLoader
+	 * WebDelegatingSmartContextLoader} will be used instead.
 	 * @param testClass the test class for which the test context should be
 	 * constructed (must not be {@code null})
 	 * @param contextCache the context cache from which the constructed test
@@ -83,54 +88,27 @@ public class TestContext extends AttributeAccessorSupport {
 		Assert.notNull(testClass, "Test class must not be null");
 		Assert.notNull(contextCache, "ContextCache must not be null");
 
+		this.testClass = testClass;
+		this.contextCache = contextCache;
+		this.cacheAwareContextLoaderDelegate = new CacheAwareContextLoaderDelegate(contextCache);
+
 		MergedContextConfiguration mergedContextConfiguration;
-		ContextConfiguration contextConfiguration = testClass.getAnnotation(ContextConfiguration.class);
 
-		if (contextConfiguration == null) {
-			if (logger.isInfoEnabled()) {
-				logger.info(String.format("@ContextConfiguration not found for class [%s]", testClass));
-			}
-			mergedContextConfiguration = new MergedContextConfiguration(testClass, null, null, null, null);
+		if (testClass.isAnnotationPresent(ContextConfiguration.class)
+				|| testClass.isAnnotationPresent(ContextHierarchy.class)) {
+			mergedContextConfiguration = ContextLoaderUtils.buildMergedContextConfiguration(testClass,
+				defaultContextLoaderClassName, cacheAwareContextLoaderDelegate);
 		}
 		else {
-			if (logger.isTraceEnabled()) {
-				logger.trace(String.format("Retrieved @ContextConfiguration [%s] for class [%s]", contextConfiguration,
-					testClass));
+			if (logger.isInfoEnabled()) {
+				logger.info(String.format(
+					"Neither @ContextConfiguration nor @ContextHierarchy found for test class [%s]",
+					testClass.getName()));
 			}
-			mergedContextConfiguration = ContextLoaderUtils.buildMergedContextConfiguration(testClass,
-				defaultContextLoaderClassName);
+			mergedContextConfiguration = new MergedContextConfiguration(testClass, null, null, null, null);
 		}
 
-		this.contextCache = contextCache;
 		this.mergedContextConfiguration = mergedContextConfiguration;
-		this.testClass = testClass;
-	}
-
-	/**
-	 * Load an {@code ApplicationContext} for this test context using the
-	 * configured {@code ContextLoader} and merged context configuration. Supports
-	 * both the {@link SmartContextLoader} and {@link ContextLoader} SPIs.
-	 * @throws Exception if an error occurs while loading the application context
-	 */
-	private ApplicationContext loadApplicationContext() throws Exception {
-		ContextLoader contextLoader = mergedContextConfiguration.getContextLoader();
-		Assert.notNull(contextLoader, "Cannot load an ApplicationContext with a NULL 'contextLoader'. "
-				+ "Consider annotating your test class with @ContextConfiguration.");
-
-		ApplicationContext applicationContext;
-
-		if (contextLoader instanceof SmartContextLoader) {
-			SmartContextLoader smartContextLoader = (SmartContextLoader) contextLoader;
-			applicationContext = smartContextLoader.loadContext(mergedContextConfiguration);
-		}
-		else {
-			String[] locations = mergedContextConfiguration.getLocations();
-			Assert.notNull(locations, "Cannot load an ApplicationContext with a NULL 'locations' array. "
-					+ "Consider annotating your test class with @ContextConfiguration.");
-			applicationContext = contextLoader.loadContext(locations);
-		}
-
-		return applicationContext;
 	}
 
 	/**
@@ -141,31 +119,7 @@ private ApplicationContext loadApplicationContext() throws Exception {
 	 * application context
 	 */
 	public ApplicationContext getApplicationContext() {
-		synchronized (contextCache) {
-			ApplicationContext context = contextCache.get(mergedContextConfiguration);
-			if (context == null) {
-				try {
-					context = loadApplicationContext();
-					if (logger.isDebugEnabled()) {
-						logger.debug(String.format(
-							"Storing ApplicationContext for test class [%s] in cache under key [%s].", testClass,
-							mergedContextConfiguration));
-					}
-					contextCache.put(mergedContextConfiguration, context);
-				}
-				catch (Exception ex) {
-					throw new IllegalStateException("Failed to load ApplicationContext", ex);
-				}
-			}
-			else {
-				if (logger.isDebugEnabled()) {
-					logger.debug(String.format(
-						"Retrieved ApplicationContext for test class [%s] from cache with key [%s].", testClass,
-						mergedContextConfiguration));
-				}
-			}
-			return context;
-		}
+		return cacheAwareContextLoaderDelegate.loadContext(mergedContextConfiguration);
 	}
 
 	/**
@@ -209,15 +163,27 @@ public final Throwable getTestException() {
 	}
 
 	/**
-	 * Call this method to signal that the {@link ApplicationContext application
-	 * context} associated with this test context is <em>dirty</em> and should
-	 * be reloaded. Do this if a test has modified the context (for example, by
-	 * replacing a bean definition).
+	 * Call this method to signal that the {@linkplain ApplicationContext application
+	 * context} associated with this test context is <em>dirty</em> and should be
+	 * discarded. Do this if a test has modified the context &mdash; for example,
+	 * by replacing a bean definition or modifying the state of a singleton bean.
+	 * @deprecated As of Spring 3.2.2, use {@link #markApplicationContextDirty(HierarchyMode)} instead.
 	 */
+	@Deprecated
 	public void markApplicationContextDirty() {
-		synchronized (contextCache) {
-			contextCache.setDirty(mergedContextConfiguration);
-		}
+		markApplicationContextDirty((HierarchyMode) null);
+	}
+
+	/**
+	 * Call this method to signal that the {@linkplain ApplicationContext application
+	 * context} associated with this test context is <em>dirty</em> and should be
+	 * discarded. Do this if a test has modified the context &mdash; for example,
+	 * by replacing a bean definition or modifying the state of a singleton bean.
+	 * @param hierarchyMode the context cache clearing mode to be applied if the
+	 * context is part of a hierarchy (may be {@code null})
+	 */
+	public void markApplicationContextDirty(HierarchyMode hierarchyMode) {
+		contextCache.remove(mergedContextConfiguration, hierarchyMode);
 	}
 
 	/**
diff --git a/spring-test/src/main/java/org/springframework/test/context/TestContextManager.java b/spring-test/src/main/java/org/springframework/test/context/TestContextManager.java
index d138484c8a71..aabdf33dfb76 100644
--- a/spring-test/src/main/java/org/springframework/test/context/TestContextManager.java
+++ b/spring-test/src/main/java/org/springframework/test/context/TestContextManager.java
@@ -104,15 +104,14 @@ public TestContextManager(Class<?> testClass) {
 	}
 
 	/**
-	 * Constructs a new {@code TestContextManager} for the specified {@link Class test class}
-	 * and automatically {@link #registerTestExecutionListeners registers} the
+	 * Constructs a new {@code TestContextManager} for the specified {@linkplain Class
+	 * test class} and automatically {@link #registerTestExecutionListeners registers} the
 	 * {@link TestExecutionListener TestExecutionListeners} configured for the test class
 	 * via the {@link TestExecutionListeners &#064;TestExecutionListeners} annotation.
 	 * @param testClass the test class to be managed
-	 * @param defaultContextLoaderClassName the name of the default
-	 * {@code ContextLoader} class to use (may be {@code null})
+	 * @param defaultContextLoaderClassName the name of the default {@code ContextLoader}
+	 * class to use (may be {@code null})
 	 * @see #registerTestExecutionListeners(TestExecutionListener...)
-	 * @see #retrieveTestExecutionListeners(Class)
 	 */
 	public TestContextManager(Class<?> testClass, String defaultContextLoaderClassName) {
 		this.testContext = new TestContext(testClass, contextCache, defaultContextLoaderClassName);
@@ -448,4 +447,4 @@ public void afterTestClass() throws Exception {
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-test/src/main/java/org/springframework/test/context/TestExecutionListener.java b/spring-test/src/main/java/org/springframework/test/context/TestExecutionListener.java
index 0f2ceb73a48f..a052523fc901 100644
--- a/spring-test/src/main/java/org/springframework/test/context/TestExecutionListener.java
+++ b/spring-test/src/main/java/org/springframework/test/context/TestExecutionListener.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,29 +17,24 @@
 package org.springframework.test.context;
 
 /**
+ * {@code TestExecutionListener} defines a <em>listener</em> API for reacting to
+ * test execution events published by the {@link TestContextManager} with which
+ * the listener is registered.
  * <p>
- * {@code TestExecutionListener} defines a <em>listener</em> API for
- * reacting to test execution events published by the {@link TestContextManager}
- * with which the listener is registered.
- * </p>
- * <p>
- * Concrete implementations must provide a {@code public} no-args
- * constructor, so that listeners can be instantiated transparently by tools and
- * configuration mechanisms.
- * </p>
+ * Concrete implementations must provide a {@code public} no-args constructor,
+ * so that listeners can be instantiated transparently by tools and configuration
+ * mechanisms.
  * <p>
  * Spring provides the following out-of-the-box implementations:
- * </p>
  * <ul>
- * <li>
- * {@link org.springframework.test.context.support.DependencyInjectionTestExecutionListener
+ * <li>{@link org.springframework.test.context.support.DependencyInjectionTestExecutionListener
  * DependencyInjectionTestExecutionListener}</li>
- * <li>
- * {@link org.springframework.test.context.support.DirtiesContextTestExecutionListener
+ * <li>{@link org.springframework.test.context.support.DirtiesContextTestExecutionListener
  * DirtiesContextTestExecutionListener}</li>
- * <li>
- * {@link org.springframework.test.context.transaction.TransactionalTestExecutionListener
+ * <li>{@link org.springframework.test.context.transaction.TransactionalTestExecutionListener
  * TransactionalTestExecutionListener}</li>
+ * <li>{@link org.springframework.test.context.web.ServletTestExecutionListener
+ * ServletTestExecutionListener}</li>
  * </ul>
  *
  * @author Sam Brannen
diff --git a/spring-test/src/main/java/org/springframework/test/context/TestExecutionListeners.java b/spring-test/src/main/java/org/springframework/test/context/TestExecutionListeners.java
index 50cfa74474ec..388f66b5c8eb 100644
--- a/spring-test/src/main/java/org/springframework/test/context/TestExecutionListeners.java
+++ b/spring-test/src/main/java/org/springframework/test/context/TestExecutionListeners.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,9 +26,10 @@
 /**
  * {@code TestExecutionListeners} defines class-level metadata for
  * configuring which {@link TestExecutionListener TestExecutionListeners} should
- * be registered with a {@link TestContextManager}. Typically,
- * {@code &#064;TestExecutionListeners} will be used in conjunction with
- * {@link ContextConfiguration &#064;ContextConfiguration}.
+ * be registered with a {@link TestContextManager}.
+ *
+ * <p>Typically, {@code @TestExecutionListeners} will be used in conjunction with
+ * {@link ContextConfiguration @ContextConfiguration}.
  *
  * @author Sam Brannen
  * @since 2.5
@@ -43,11 +44,10 @@
 public @interface TestExecutionListeners {
 
 	/**
-	 * <p>
 	 * The {@link TestExecutionListener TestExecutionListeners} to register with
 	 * a {@link TestContextManager}.
-	 * </p>
 	 *
+	 * @see org.springframework.test.context.web.ServletTestExecutionListener
 	 * @see org.springframework.test.context.support.DependencyInjectionTestExecutionListener
 	 * @see org.springframework.test.context.support.DirtiesContextTestExecutionListener
 	 * @see org.springframework.test.context.transaction.TransactionalTestExecutionListener
@@ -60,10 +60,8 @@
 	Class<? extends TestExecutionListener>[] value() default {};
 
 	/**
-	 * <p>
 	 * Whether or not {@link #value() TestExecutionListeners} from superclasses
 	 * should be <em>inherited</em>.
-	 * </p>
 	 * <p>
 	 * The default value is {@code true}, which means that an annotated
 	 * class will <em>inherit</em> the listeners defined by an annotated
@@ -77,11 +75,12 @@
 	 * {@code DependencyInjectionTestExecutionListener},
 	 * {@code DirtiesContextTestExecutionListener}, <strong>and</strong>
 	 * {@code TransactionalTestExecutionListener}, in that order.
-	 * </p>
 	 *
 	 * <pre class="code">
-	 * &#064;TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
-	 *    DirtiesContextTestExecutionListener.class })
+	 * &#064;TestExecutionListeners({
+	 *    DependencyInjectionTestExecutionListener.class,
+	 *    DirtiesContextTestExecutionListener.class
+	 * })
 	 * public abstract class AbstractBaseTest {
 	 * 	// ...
 	 * }
@@ -89,14 +88,12 @@
 	 * &#064;TestExecutionListeners(TransactionalTestExecutionListener.class)
 	 * public class TransactionalTest extends AbstractBaseTest {
 	 * 	// ...
-	 * }
-	 * </pre>
+	 * }</pre>
 	 *
 	 * <p>
-	 * If {@code inheritListeners} is set to {@code false}, the
-	 * listeners for the annotated class will <em>shadow</em> and effectively
-	 * replace any listeners defined by a superclass.
-	 * </p>
+	 * If {@code inheritListeners} is set to {@code false}, the listeners for the
+	 * annotated class will <em>shadow</em> and effectively replace any listeners
+	 * defined by a superclass.
 	 */
 	boolean inheritListeners() default true;
 
diff --git a/spring-test/src/main/java/org/springframework/test/context/support/AbstractGenericContextLoader.java b/spring-test/src/main/java/org/springframework/test/context/support/AbstractGenericContextLoader.java
index c4b9b4dca7e5..bd84068ac78b 100644
--- a/spring-test/src/main/java/org/springframework/test/context/support/AbstractGenericContextLoader.java
+++ b/spring-test/src/main/java/org/springframework/test/context/support/AbstractGenericContextLoader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,13 @@
 
 package org.springframework.test.context.support;
 
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+
 import org.springframework.beans.factory.support.BeanDefinitionReader;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
+import org.springframework.context.ApplicationContext;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigUtils;
 import org.springframework.context.support.GenericApplicationContext;
@@ -66,6 +69,12 @@ public abstract class AbstractGenericContextLoader extends AbstractContextLoader
 	 *
 	 * <ul>
 	 * <li>Creates a {@link GenericApplicationContext} instance.</li>
+	 * <li>If the supplied {@code MergedContextConfiguration} references a
+	 * {@linkplain MergedContextConfiguration#getParent() parent configuration},
+	 * the corresponding {@link MergedContextConfiguration#getParentApplicationContext()
+	 * ApplicationContext} will be retrieved and
+	 * {@linkplain GenericApplicationContext#setParent(ApplicationContext) set as the parent}
+	 * for the context created by this method.</li>
 	 * <li>Calls {@link #prepareContext(GenericApplicationContext)} for backwards
 	 * compatibility with the {@link org.springframework.test.context.ContextLoader
 	 * ContextLoader} SPI.</li>
@@ -97,6 +106,11 @@ public final ConfigurableApplicationContext loadContext(MergedContextConfigurati
 		}
 
 		GenericApplicationContext context = new GenericApplicationContext();
+
+		ApplicationContext parent = mergedConfig.getParentApplicationContext();
+		if (parent != null) {
+			context.setParent(parent);
+		}
 		prepareContext(context);
 		prepareContext(context, mergedConfig);
 		customizeBeanFactory(context.getDefaultListableBeanFactory());
diff --git a/spring-test/src/main/java/org/springframework/test/context/support/DirtiesContextTestExecutionListener.java b/spring-test/src/main/java/org/springframework/test/context/support/DirtiesContextTestExecutionListener.java
index 7c7847418993..f865d532daef 100644
--- a/spring-test/src/main/java/org/springframework/test/context/support/DirtiesContextTestExecutionListener.java
+++ b/spring-test/src/main/java/org/springframework/test/context/support/DirtiesContextTestExecutionListener.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,6 +23,7 @@
 import org.springframework.context.ApplicationContext;
 import org.springframework.test.annotation.DirtiesContext;
 import org.springframework.test.annotation.DirtiesContext.ClassMode;
+import org.springframework.test.annotation.DirtiesContext.HierarchyMode;
 import org.springframework.test.context.TestContext;
 import org.springframework.util.Assert;
 
@@ -43,26 +44,47 @@ public class DirtiesContextTestExecutionListener extends AbstractTestExecutionLi
 
 
 	/**
-	 * Marks the {@link ApplicationContext application context} of the supplied
-	 * {@link TestContext test context} as
-	 * {@link TestContext#markApplicationContextDirty() dirty}, and sets the
+	 * Marks the {@linkplain ApplicationContext application context} of the supplied
+	 * {@linkplain TestContext test context} as
+	 * {@linkplain TestContext#markApplicationContextDirty() dirty}, and sets the
 	 * {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE
 	 * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context to {@code true}.
+	 * @param testContext the test context whose application context should
+	 * marked as dirty
+	 * @deprecated as of Spring 3.2.2, use {@link #dirtyContext(TestContext, HierarchyMode)} instead.
 	 */
+	@Deprecated
 	protected void dirtyContext(TestContext testContext) {
 		testContext.markApplicationContextDirty();
 		testContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);
 	}
 
 	/**
-	 * If the current test method of the supplied {@link TestContext test
+	 * Marks the {@linkplain ApplicationContext application context} of the supplied
+	 * {@linkplain TestContext test context} as {@linkplain
+	 * TestContext#markApplicationContextDirty(HierarchyMode) dirty} and sets the
+	 * {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE
+	 * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context to {@code true}.
+	 * @param testContext the test context whose application context should
+	 * marked as dirty
+	 * @param hierarchyMode the context cache clearing mode to be applied if the
+	 * context is part of a hierarchy; may be {@code null}
+	 * @since 3.2.2
+	 */
+	protected void dirtyContext(TestContext testContext, HierarchyMode hierarchyMode) {
+		testContext.markApplicationContextDirty(hierarchyMode);
+		testContext.setAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE, Boolean.TRUE);
+	}
+
+	/**
+	 * If the current test method of the supplied {@linkplain TestContext test
 	 * context} is annotated with {@link DirtiesContext &#064;DirtiesContext},
 	 * or if the test class is annotated with {@link DirtiesContext
-	 * &#064;DirtiesContext} and the {@link DirtiesContext#classMode() class
+	 * &#064;DirtiesContext} and the {@linkplain DirtiesContext#classMode() class
 	 * mode} is set to {@link ClassMode#AFTER_EACH_TEST_METHOD
-	 * AFTER_EACH_TEST_METHOD}, the {@link ApplicationContext application
+	 * AFTER_EACH_TEST_METHOD}, the {@linkplain ApplicationContext application
 	 * context} of the test context will be
-	 * {@link TestContext#markApplicationContextDirty() marked as dirty} and the
+	 * {@linkplain TestContext#markApplicationContextDirty() marked as dirty} and the
 	 * {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE
 	 * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context will be set to
 	 * {@code true}.
@@ -88,15 +110,17 @@ public void afterTestMethod(TestContext testContext) throws Exception {
 		}
 
 		if (methodDirtiesContext || (classDirtiesContext && classMode == ClassMode.AFTER_EACH_TEST_METHOD)) {
-			dirtyContext(testContext);
+			HierarchyMode hierarchyMode = methodDirtiesContext ? testMethod.getAnnotation(annotationType).hierarchyMode()
+					: classDirtiesContextAnnotation.hierarchyMode();
+			dirtyContext(testContext, hierarchyMode);
 		}
 	}
 
 	/**
-	 * If the test class of the supplied {@link TestContext test context} is
+	 * If the test class of the supplied {@linkplain TestContext test context} is
 	 * annotated with {@link DirtiesContext &#064;DirtiesContext}, the
-	 * {@link ApplicationContext application context} of the test context will
-	 * be {@link TestContext#markApplicationContextDirty() marked as dirty} ,
+	 * {@linkplain ApplicationContext application context} of the test context will
+	 * be {@linkplain TestContext#markApplicationContextDirty() marked as dirty} ,
 	 * and the
 	 * {@link DependencyInjectionTestExecutionListener#REINJECT_DEPENDENCIES_ATTRIBUTE
 	 * REINJECT_DEPENDENCIES_ATTRIBUTE} in the test context will be set to
@@ -107,12 +131,15 @@ public void afterTestClass(TestContext testContext) throws Exception {
 		Class<?> testClass = testContext.getTestClass();
 		Assert.notNull(testClass, "The test class of the supplied TestContext must not be null");
 
-		boolean dirtiesContext = testClass.isAnnotationPresent(DirtiesContext.class);
+		final Class<DirtiesContext> annotationType = DirtiesContext.class;
+
+		boolean dirtiesContext = testClass.isAnnotationPresent(annotationType);
 		if (logger.isDebugEnabled()) {
 			logger.debug("After test class: context [" + testContext + "], dirtiesContext [" + dirtiesContext + "].");
 		}
 		if (dirtiesContext) {
-			dirtyContext(testContext);
+			HierarchyMode hierarchyMode = testClass.getAnnotation(annotationType).hierarchyMode();
+			dirtyContext(testContext, hierarchyMode);
 		}
 	}
 
diff --git a/spring-test/src/main/java/org/springframework/test/context/web/AbstractGenericWebContextLoader.java b/spring-test/src/main/java/org/springframework/test/context/web/AbstractGenericWebContextLoader.java
index f344ae2eeef0..75c363dd188c 100644
--- a/spring-test/src/main/java/org/springframework/test/context/web/AbstractGenericWebContextLoader.java
+++ b/spring-test/src/main/java/org/springframework/test/context/web/AbstractGenericWebContextLoader.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,6 +31,7 @@
 import org.springframework.mock.web.MockServletContext;
 import org.springframework.test.context.MergedContextConfiguration;
 import org.springframework.test.context.support.AbstractContextLoader;
+import org.springframework.util.Assert;
 import org.springframework.web.context.WebApplicationContext;
 import org.springframework.web.context.support.GenericWebApplicationContext;
 
@@ -71,6 +72,12 @@ public abstract class AbstractGenericWebContextLoader extends AbstractContextLoa
 	 *
 	 * <ul>
 	 * <li>Creates a {@link GenericWebApplicationContext} instance.</li>
+	 * <li>If the supplied {@code MergedContextConfiguration} references a
+	 * {@linkplain MergedContextConfiguration#getParent() parent configuration},
+	 * the corresponding {@link MergedContextConfiguration#getParentApplicationContext()
+	 * ApplicationContext} will be retrieved and
+	 * {@linkplain GenericWebApplicationContext#setParent(ApplicationContext) set as the parent}
+	 * for the context created by this method.</li>
 	 * <li>Delegates to {@link #configureWebResources} to create the
 	 * {@link MockServletContext} and set it in the {@code WebApplicationContext}.</li>
 	 * <li>Calls {@link #prepareContext} to allow for customizing the context
@@ -107,6 +114,11 @@ public final ConfigurableApplicationContext loadContext(MergedContextConfigurati
 		}
 
 		GenericWebApplicationContext context = new GenericWebApplicationContext();
+
+		ApplicationContext parent = mergedConfig.getParentApplicationContext();
+		if (parent != null) {
+			context.setParent(parent);
+		}
 		configureWebResources(context, webMergedConfig);
 		prepareContext(context, webMergedConfig);
 		customizeBeanFactory(context.getDefaultListableBeanFactory(), webMergedConfig);
@@ -119,9 +131,20 @@ public final ConfigurableApplicationContext loadContext(MergedContextConfigurati
 	}
 
 	/**
-	 * Configures web resources for the supplied web application context.
+	 * Configures web resources for the supplied web application context (WAC).
 	 *
-	 * <p>Implementation details:
+	 * <h4>Implementation Details</h4>
+	 *
+	 * <p>If the supplied WAC has no parent or its parent is not a WAC, the
+	 * supplied WAC will be configured as the Root WAC (see "<em>Root WAC
+	 * Configuration</em>" below).
+	 *
+	 * <p>Otherwise the context hierarchy of the supplied WAC will be traversed
+	 * to find the top-most WAC (i.e., the root); and the {@link ServletContext}
+	 * of the Root WAC will be set as the {@code ServletContext} for the supplied
+	 * WAC.
+	 *
+	 * <h4>Root WAC Configuration</h4>
 	 *
 	 * <ul>
 	 * <li>The resource base path is retrieved from the supplied
@@ -146,13 +169,33 @@ public final ConfigurableApplicationContext loadContext(MergedContextConfigurati
 	protected void configureWebResources(GenericWebApplicationContext context,
 			WebMergedContextConfiguration webMergedConfig) {
 
-		String resourceBasePath = webMergedConfig.getResourceBasePath();
-		ResourceLoader resourceLoader = resourceBasePath.startsWith(ResourceLoader.CLASSPATH_URL_PREFIX) ? new DefaultResourceLoader()
-				: new FileSystemResourceLoader();
+		ApplicationContext parent = context.getParent();
+
+		// if the WAC has no parent or the parent is not a WAC, set the WAC as
+		// the Root WAC:
+		if (parent == null || (!(parent instanceof WebApplicationContext))) {
+			String resourceBasePath = webMergedConfig.getResourceBasePath();
+			ResourceLoader resourceLoader = resourceBasePath.startsWith(ResourceLoader.CLASSPATH_URL_PREFIX) ? new DefaultResourceLoader()
+					: new FileSystemResourceLoader();
 
-		ServletContext servletContext = new MockServletContext(resourceBasePath, resourceLoader);
-		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);
-		context.setServletContext(servletContext);
+			ServletContext servletContext = new MockServletContext(resourceBasePath, resourceLoader);
+			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);
+			context.setServletContext(servletContext);
+		}
+		else {
+			ServletContext servletContext = null;
+
+			// find the Root WAC
+			while (parent != null) {
+				if (parent instanceof WebApplicationContext && !(parent.getParent() instanceof WebApplicationContext)) {
+					servletContext = ((WebApplicationContext) parent).getServletContext();
+					break;
+				}
+				parent = parent.getParent();
+			}
+			Assert.state(servletContext != null, "Failed to find Root WebApplicationContext in the context hierarchy");
+			context.setServletContext(servletContext);
+		}
 	}
 
 	/**
diff --git a/spring-test/src/main/java/org/springframework/test/context/web/ServletTestExecutionListener.java b/spring-test/src/main/java/org/springframework/test/context/web/ServletTestExecutionListener.java
index 01302bb11008..7858d9201f78 100644
--- a/spring-test/src/main/java/org/springframework/test/context/web/ServletTestExecutionListener.java
+++ b/spring-test/src/main/java/org/springframework/test/context/web/ServletTestExecutionListener.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -69,6 +69,7 @@ public class ServletTestExecutionListener extends AbstractTestExecutionListener
 	 * @see TestExecutionListener#prepareTestInstance(TestContext)
 	 * @see #setUpRequestContextIfNecessary(TestContext)
 	 */
+	@SuppressWarnings("javadoc")
 	public void prepareTestInstance(TestContext testContext) throws Exception {
 		setUpRequestContextIfNecessary(testContext);
 	}
@@ -80,6 +81,7 @@ public void prepareTestInstance(TestContext testContext) throws Exception {
 	 * @see TestExecutionListener#beforeTestMethod(TestContext)
 	 * @see #setUpRequestContextIfNecessary(TestContext)
 	 */
+	@SuppressWarnings("javadoc")
 	public void beforeTestMethod(TestContext testContext) throws Exception {
 		setUpRequestContextIfNecessary(testContext);
 	}
@@ -126,6 +128,7 @@ private void setUpRequestContextIfNecessary(TestContext testContext) {
 				RequestContextHolder.setRequestAttributes(servletWebRequest);
 
 				if (wac instanceof ConfigurableApplicationContext) {
+					@SuppressWarnings("resource")
 					ConfigurableApplicationContext configurableApplicationContext = (ConfigurableApplicationContext) wac;
 					ConfigurableListableBeanFactory bf = configurableApplicationContext.getBeanFactory();
 					bf.registerResolvableDependency(MockHttpServletResponse.class, response);
diff --git a/spring-test/src/main/java/org/springframework/test/context/web/WebMergedContextConfiguration.java b/spring-test/src/main/java/org/springframework/test/context/web/WebMergedContextConfiguration.java
index 8e0e0494ad79..58e8b38607a1 100644
--- a/spring-test/src/main/java/org/springframework/test/context/web/WebMergedContextConfiguration.java
+++ b/spring-test/src/main/java/org/springframework/test/context/web/WebMergedContextConfiguration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 import org.springframework.context.ApplicationContextInitializer;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.core.style.ToStringCreator;
+import org.springframework.test.context.CacheAwareContextLoaderDelegate;
 import org.springframework.test.context.ContextLoader;
 import org.springframework.test.context.MergedContextConfiguration;
 import org.springframework.util.ObjectUtils;
@@ -77,7 +78,11 @@ public class WebMergedContextConfiguration extends MergedContextConfiguration {
 	 * @param activeProfiles the merged active bean definition profiles
 	 * @param resourceBasePath the resource path to the root directory of the web application
 	 * @param contextLoader the resolved {@code ContextLoader}
+	 * @see #WebMergedContextConfiguration(Class, String[], Class[], Set, String[], String, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)
+	 * @deprecated as of Spring 3.2.2, use
+	 * {@link #WebMergedContextConfiguration(Class, String[], Class[], Set, String[], String, ContextLoader, CacheAwareContextLoaderDelegate, MergedContextConfiguration)} instead.
 	 */
+	@Deprecated
 	public WebMergedContextConfiguration(
 			Class<?> testClass,
 			String[] locations,
@@ -85,7 +90,45 @@ public WebMergedContextConfiguration(
 			Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,
 			String[] activeProfiles, String resourceBasePath, ContextLoader contextLoader) {
 
-		super(testClass, locations, classes, contextInitializerClasses, activeProfiles, contextLoader);
+		this(testClass, locations, classes, contextInitializerClasses, activeProfiles, resourceBasePath, contextLoader,
+			null, null);
+	}
+
+	/**
+	 * Create a new {@code WebMergedContextConfiguration} instance for the
+	 * supplied test class, resource locations, annotated classes, context
+	 * initializers, active profiles, resource base path, and {@code ContextLoader}.
+	 *
+	 * <p>If a {@code null} value is supplied for {@code locations},
+	 * {@code classes}, or {@code activeProfiles} an empty array will
+	 * be stored instead. If a {@code null} value is supplied for the
+	 * {@code contextInitializerClasses} an empty set will be stored instead.
+	 * If an <em>empty</em> value is supplied for the {@code resourceBasePath}
+	 * an empty string will be used. Furthermore, active profiles will be sorted,
+	 * and duplicate profiles will be removed.
+	 *
+	 * @param testClass the test class for which the configuration was merged
+	 * @param locations the merged resource locations
+	 * @param classes the merged annotated classes
+	 * @param contextInitializerClasses the merged context initializer classes
+	 * @param activeProfiles the merged active bean definition profiles
+	 * @param resourceBasePath the resource path to the root directory of the web application
+	 * @param contextLoader the resolved {@code ContextLoader}
+	 * @param cacheAwareContextLoaderDelegate a cache-aware context loader
+	 * delegate with which to retrieve the parent context
+	 * @param parent the parent configuration or {@code null} if there is no parent
+	 * @since 3.2.2
+	 */
+	public WebMergedContextConfiguration(
+			Class<?> testClass,
+			String[] locations,
+			Class<?>[] classes,
+			Set<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>> contextInitializerClasses,
+			String[] activeProfiles, String resourceBasePath, ContextLoader contextLoader,
+			CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, MergedContextConfiguration parent) {
+
+		super(testClass, locations, classes, contextInitializerClasses, activeProfiles, contextLoader,
+			cacheAwareContextLoaderDelegate, parent);
 
 		this.resourceBasePath = !StringUtils.hasText(resourceBasePath) ? "" : resourceBasePath;
 	}
@@ -118,8 +161,9 @@ public int hashCode() {
 	 * {@linkplain #getClasses() annotated classes},
 	 * {@linkplain #getContextInitializerClasses() context initializer classes},
 	 * {@linkplain #getActiveProfiles() active profiles},
-	 * {@linkplain #getResourceBasePath() resource base path}, and the fully
-	 * qualified names of their {@link #getContextLoader() ContextLoaders}.
+	 * {@linkplain #getResourceBasePath() resource base path},
+	 * {@linkplain #getParent() parents}, and the fully qualified names of their
+	 * {@link #getContextLoader() ContextLoaders}.
 	 */
 	@Override
 	public boolean equals(Object obj) {
@@ -141,8 +185,9 @@ public boolean equals(Object obj) {
 	 * {@linkplain #getLocations() locations}, {@linkplain #getClasses() annotated classes},
 	 * {@linkplain #getContextInitializerClasses() context initializer classes},
 	 * {@linkplain #getActiveProfiles() active profiles},
-	 * {@linkplain #getResourceBasePath() resource base path}, and the name of the
-	 * {@link #getContextLoader() ContextLoader}.
+	 * {@linkplain #getResourceBasePath() resource base path}, the name of the
+	 * {@link #getContextLoader() ContextLoader}, and the
+	 * {@linkplain #getParent() parent configuration}.
 	 */
 	@Override
 	public String toString() {
@@ -154,6 +199,7 @@ public String toString() {
 		.append("activeProfiles", ObjectUtils.nullSafeToString(getActiveProfiles()))//
 		.append("resourceBasePath", getResourceBasePath())//
 		.append("contextLoader", nullSafeToString(getContextLoader()))//
+		.append("parent", getParent())//
 		.toString();
 	}
 
diff --git a/spring-test/src/main/java/org/springframework/test/jdbc/JdbcTestUtils.java b/spring-test/src/main/java/org/springframework/test/jdbc/JdbcTestUtils.java
index 532a82c01fb1..383b20dff901 100644
--- a/spring-test/src/main/java/org/springframework/test/jdbc/JdbcTestUtils.java
+++ b/spring-test/src/main/java/org/springframework/test/jdbc/JdbcTestUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,13 +23,13 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
 import org.springframework.core.io.Resource;
 import org.springframework.core.io.ResourceLoader;
 import org.springframework.core.io.support.EncodedResource;
 import org.springframework.dao.DataAccessException;
 import org.springframework.dao.DataAccessResourceFailureException;
 import org.springframework.jdbc.core.JdbcTemplate;
+import org.springframework.jdbc.core.SqlParameterValue;
 import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;
 import org.springframework.util.StringUtils;
 
@@ -42,6 +42,7 @@
  * @author Thomas Risberg
  * @author Sam Brannen
  * @author Juergen Hoeller
+ * @author Phillip Webb
  * @since 2.5.4
  */
 public class JdbcTestUtils {
@@ -60,7 +61,7 @@ public class JdbcTestUtils {
 	 * @return the number of rows in the table
 	 */
 	public static int countRowsInTable(JdbcTemplate jdbcTemplate, String tableName) {
-		return jdbcTemplate.queryForInt("SELECT COUNT(0) FROM " + tableName);
+		return jdbcTemplate.queryForObject("SELECT COUNT(0) FROM " + tableName, Integer.class);
 	}
 
 	/**
@@ -82,7 +83,7 @@ public static int countRowsInTableWhere(JdbcTemplate jdbcTemplate, String tableN
 		if (StringUtils.hasText(whereClause)) {
 			sql += " WHERE " + whereClause;
 		}
-		return jdbcTemplate.queryForInt(sql);
+		return jdbcTemplate.queryForObject(sql, Integer.class);
 	}
 
 	/**
@@ -103,6 +104,39 @@ public static int deleteFromTables(JdbcTemplate jdbcTemplate, String... tableNam
 		return totalRowCount;
 	}
 
+	/**
+	 * Delete rows from the given table, using the provided {@code WHERE} clause.
+	 * <p>If the provided {@code WHERE} clause contains text, it will be prefixed
+	 * with {@code " WHERE "} and then appended to the generated {@code DELETE}
+	 * statement. For example, if the provided table name is {@code "person"} and
+	 * the provided where clause is {@code "name = 'Bob' and age > 25"}, the
+	 * resulting SQL statement to execute will be
+	 * {@code "DELETE FROM person WHERE name = 'Bob' and age > 25"}.
+	 * <p>As an alternative to hard-coded values, the {@code "?"} placeholder can
+	 * be used within the {@code WHERE} clause, binding to the given arguments.
+	 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
+	 * @param tableName the name of the table to delete rows from
+	 * @param whereClause the {@code WHERE} clause to append to the query
+	 * @param args arguments to bind to the query (leaving it to the PreparedStatement
+	 * to guess the corresponding SQL type); may also contain {@link SqlParameterValue}
+	 * objects which indicate not only the argument value but also the SQL type and
+	 * optionally the scale.
+	 * @return the number of rows deleted from the table
+	 */
+	public static int deleteFromTableWhere(JdbcTemplate jdbcTemplate, String tableName,
+			String whereClause, Object... args) {
+		String sql = "DELETE FROM " + tableName;
+		if (StringUtils.hasText(whereClause)) {
+			sql += " WHERE " + whereClause;
+		}
+		int rowCount = (args != null && args.length > 0 ? jdbcTemplate.update(sql, args)
+				: jdbcTemplate.update(sql));
+		if (logger.isInfoEnabled()) {
+			logger.info("Deleted " + rowCount + " rows from table " + tableName);
+		}
+		return rowCount;
+	}
+
 	/**
 	 * Drop the specified tables.
 	 * @param jdbcTemplate the JdbcTemplate with which to perform JDBC operations
diff --git a/spring-test/src/main/java/org/springframework/test/jpa/AbstractJpaTests.java b/spring-test/src/main/java/org/springframework/test/jpa/AbstractJpaTests.java
index ba959d162f28..005c19e3d840 100644
--- a/spring-test/src/main/java/org/springframework/test/jpa/AbstractJpaTests.java
+++ b/spring-test/src/main/java/org/springframework/test/jpa/AbstractJpaTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -326,6 +326,7 @@ private static class LoadTimeWeaverInjectingBeanPostProcessor extends Instantiat
 
 		private final LoadTimeWeaver ltw;
 
+		@SuppressWarnings("unused")
 		public LoadTimeWeaverInjectingBeanPostProcessor(LoadTimeWeaver ltw) {
 			this.ltw = ltw;
 		}
@@ -346,6 +347,7 @@ private static class ShadowingLoadTimeWeaver implements LoadTimeWeaver {
 
 		private final ClassLoader shadowingClassLoader;
 
+		@SuppressWarnings("unused")
 		public ShadowingLoadTimeWeaver(ClassLoader shadowingClassLoader) {
 			this.shadowingClassLoader = shadowingClassLoader;
 		}
diff --git a/spring-test/src/test/java/org/springframework/mock/web/MockFilterChainTests.java b/spring-test/src/test/java/org/springframework/mock/web/MockFilterChainTests.java
index a254398c4ed6..61240cb40216 100644
--- a/spring-test/src/test/java/org/springframework/mock/web/MockFilterChainTests.java
+++ b/spring-test/src/test/java/org/springframework/mock/web/MockFilterChainTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
@@ -12,10 +12,6 @@
  */
 package org.springframework.mock.web;
 
-import static org.easymock.EasyMock.*;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.*;
-
 import java.io.IOException;
 
 import javax.servlet.Filter;
@@ -29,6 +25,10 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test fixture for {@link MockFilterChain}.
  *
@@ -53,7 +53,7 @@ public void constructorNullServlet() {
 
 	@Test(expected=IllegalArgumentException.class)
 	public void constructorNullFilter() {
-		new MockFilterChain(createMock(Servlet.class), (Filter) null);
+		new MockFilterChain(mock(Servlet.class), (Filter) null);
 	}
 
 	@Test(expected = IllegalArgumentException.class)
@@ -87,16 +87,10 @@ public void doFilterEmptyChain() throws Exception {
 
 	@Test
 	public void doFilterWithServlet() throws Exception {
-		Servlet servlet = createMock(Servlet.class);
-
+		Servlet servlet = mock(Servlet.class);
 		MockFilterChain chain = new MockFilterChain(servlet);
-		servlet.service(this.request, this.response);
-		replay(servlet);
-
 		chain.doFilter(this.request, this.response);
-
-		verify(servlet);
-
+		verify(servlet).service(this.request, this.response);
 		try {
 			chain.doFilter(this.request, this.response);
 			fail("Expected Exception");
@@ -108,9 +102,7 @@ public void doFilterWithServlet() throws Exception {
 
 	@Test
 	public void doFilterWithServletAndFilters() throws Exception {
-		Servlet servlet = createMock(Servlet.class);
-		servlet.service(this.request, this.response);
-		replay(servlet);
+		Servlet servlet = mock(Servlet.class);
 
 		MockFilter filter2 = new MockFilter(servlet);
 		MockFilter filter1 = new MockFilter(null);
@@ -121,7 +113,7 @@ public void doFilterWithServletAndFilters() throws Exception {
 		assertTrue(filter1.invoked);
 		assertTrue(filter2.invoked);
 
-		verify(servlet);
+		verify(servlet).service(this.request, this.response);
 
 		try {
 			chain.doFilter(this.request, this.response);
diff --git a/spring-test/src/test/java/org/springframework/test/context/ContextCacheTests.java b/spring-test/src/test/java/org/springframework/test/context/ContextCacheTests.java
new file mode 100644
index 000000000000..eb1c39a908b8
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/ContextCacheTests.java
@@ -0,0 +1,329 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.annotation.DirtiesContext.HierarchyMode;
+import org.springframework.test.context.support.AnnotationConfigContextLoader;
+import org.springframework.test.util.ReflectionTestUtils;
+
+import static org.junit.Assert.*;
+import static org.springframework.test.context.SpringRunnerContextCacheTests.*;
+
+/**
+ * Integration tests for verifying proper behavior of the {@link ContextCache} in
+ * conjunction with cache keys used in {@link TestContext}.
+ *
+ * @author Sam Brannen
+ * @since 3.1
+ * @see SpringRunnerContextCacheTests
+ */
+public class ContextCacheTests {
+
+	private ContextCache contextCache = new ContextCache();
+
+
+	@Before
+	public void initialCacheState() {
+		assertContextCacheStatistics(contextCache, "initial state", 0, 0, 0);
+		assertParentContextCount(0);
+	}
+
+	private void assertParentContextCount(int expected) {
+		assertEquals("parent context count", expected, contextCache.getParentContextCount());
+	}
+
+	private MergedContextConfiguration getMergedContextConfiguration(TestContext testContext) {
+		return (MergedContextConfiguration) ReflectionTestUtils.getField(testContext, "mergedContextConfiguration");
+	}
+
+	private ApplicationContext loadContext(Class<?> testClass) {
+		TestContext testContext = new TestContext(testClass, contextCache);
+		return testContext.getApplicationContext();
+	}
+
+	private void loadCtxAndAssertStats(Class<?> testClass, int expectedSize, int expectedHitCount, int expectedMissCount) {
+		assertNotNull(loadContext(testClass));
+		assertContextCacheStatistics(contextCache, testClass.getName(), expectedSize, expectedHitCount,
+			expectedMissCount);
+	}
+
+	@Test
+	public void verifyCacheKeyIsBasedOnContextLoader() {
+		loadCtxAndAssertStats(AnnotationConfigContextLoaderTestCase.class, 1, 0, 1);
+		loadCtxAndAssertStats(AnnotationConfigContextLoaderTestCase.class, 1, 1, 1);
+		loadCtxAndAssertStats(CustomAnnotationConfigContextLoaderTestCase.class, 2, 1, 2);
+		loadCtxAndAssertStats(CustomAnnotationConfigContextLoaderTestCase.class, 2, 2, 2);
+		loadCtxAndAssertStats(AnnotationConfigContextLoaderTestCase.class, 2, 3, 2);
+		loadCtxAndAssertStats(CustomAnnotationConfigContextLoaderTestCase.class, 2, 4, 2);
+	}
+
+	@Test
+	public void verifyCacheKeyIsBasedOnActiveProfiles() {
+		loadCtxAndAssertStats(FooBarProfilesTestCase.class, 1, 0, 1);
+		loadCtxAndAssertStats(FooBarProfilesTestCase.class, 1, 1, 1);
+		// Profiles {foo, bar} should hash to the same as {bar,foo}
+		loadCtxAndAssertStats(BarFooProfilesTestCase.class, 1, 2, 1);
+		loadCtxAndAssertStats(FooBarProfilesTestCase.class, 1, 3, 1);
+		loadCtxAndAssertStats(FooBarProfilesTestCase.class, 1, 4, 1);
+		loadCtxAndAssertStats(BarFooProfilesTestCase.class, 1, 5, 1);
+	}
+
+	@Test
+	public void verifyCacheBehaviorForContextHierarchies() {
+		int size = 0;
+		int hits = 0;
+		int misses = 0;
+
+		// Level 1
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel1TestCase.class, ++size, hits, ++misses);
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel1TestCase.class, size, ++hits, misses);
+
+		// Level 2
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel2TestCase.class, ++size /* L2 */, ++hits /* L1 */,
+			++misses /* L2 */);
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel2TestCase.class, size, ++hits /* L2 */, misses);
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel2TestCase.class, size, ++hits /* L2 */, misses);
+
+		// Level 3-A
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel3aTestCase.class, ++size /* L3A */, ++hits /* L2 */,
+			++misses /* L3A */);
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel3aTestCase.class, size, ++hits /* L3A */, misses);
+
+		// Level 3-B
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel3bTestCase.class, ++size /* L3B */, ++hits /* L2 */,
+			++misses /* L3B */);
+		loadCtxAndAssertStats(ClassHierarchyContextHierarchyLevel3bTestCase.class, size, ++hits /* L3B */, misses);
+	}
+
+	@Test
+	public void removeContextHierarchyCacheLevel1() {
+
+		// Load Level 3-A
+		TestContext testContext3a = new TestContext(ClassHierarchyContextHierarchyLevel3aTestCase.class, contextCache);
+		testContext3a.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A", 3, 0, 3);
+		assertParentContextCount(2);
+
+		// Load Level 3-B
+		TestContext testContext3b = new TestContext(ClassHierarchyContextHierarchyLevel3bTestCase.class, contextCache);
+		testContext3b.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A and B", 4, 1, 4);
+		assertParentContextCount(2);
+
+		// Remove Level 1
+		// Should also remove Levels 2, 3-A, and 3-B, leaving nothing.
+		contextCache.remove(getMergedContextConfiguration(testContext3a).getParent().getParent(),
+			HierarchyMode.CURRENT_LEVEL);
+		assertContextCacheStatistics(contextCache, "removed level 1", 0, 1, 4);
+		assertParentContextCount(0);
+	}
+
+	@Test
+	public void removeContextHierarchyCacheLevel1WithExhaustiveMode() {
+
+		// Load Level 3-A
+		TestContext testContext3a = new TestContext(ClassHierarchyContextHierarchyLevel3aTestCase.class, contextCache);
+		testContext3a.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A", 3, 0, 3);
+		assertParentContextCount(2);
+
+		// Load Level 3-B
+		TestContext testContext3b = new TestContext(ClassHierarchyContextHierarchyLevel3bTestCase.class, contextCache);
+		testContext3b.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A and B", 4, 1, 4);
+		assertParentContextCount(2);
+
+		// Remove Level 1
+		// Should also remove Levels 2, 3-A, and 3-B, leaving nothing.
+		contextCache.remove(getMergedContextConfiguration(testContext3a).getParent().getParent(),
+			HierarchyMode.EXHAUSTIVE);
+		assertContextCacheStatistics(contextCache, "removed level 1", 0, 1, 4);
+		assertParentContextCount(0);
+	}
+
+	@Test
+	public void removeContextHierarchyCacheLevel2() {
+
+		// Load Level 3-A
+		TestContext testContext3a = new TestContext(ClassHierarchyContextHierarchyLevel3aTestCase.class, contextCache);
+		testContext3a.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A", 3, 0, 3);
+		assertParentContextCount(2);
+
+		// Load Level 3-B
+		TestContext testContext3b = new TestContext(ClassHierarchyContextHierarchyLevel3bTestCase.class, contextCache);
+		testContext3b.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A and B", 4, 1, 4);
+		assertParentContextCount(2);
+
+		// Remove Level 2
+		// Should also remove Levels 3-A and 3-B, leaving only Level 1 as a context in the
+		// cache but also removing the Level 1 hierarchy since all children have been
+		// removed.
+		contextCache.remove(getMergedContextConfiguration(testContext3a).getParent(), HierarchyMode.CURRENT_LEVEL);
+		assertContextCacheStatistics(contextCache, "removed level 2", 1, 1, 4);
+		assertParentContextCount(0);
+	}
+
+	@Test
+	public void removeContextHierarchyCacheLevel2WithExhaustiveMode() {
+
+		// Load Level 3-A
+		TestContext testContext3a = new TestContext(ClassHierarchyContextHierarchyLevel3aTestCase.class, contextCache);
+		testContext3a.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A", 3, 0, 3);
+		assertParentContextCount(2);
+
+		// Load Level 3-B
+		TestContext testContext3b = new TestContext(ClassHierarchyContextHierarchyLevel3bTestCase.class, contextCache);
+		testContext3b.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A and B", 4, 1, 4);
+		assertParentContextCount(2);
+
+		// Remove Level 2
+		// Should wipe the cache
+		contextCache.remove(getMergedContextConfiguration(testContext3a).getParent(), HierarchyMode.EXHAUSTIVE);
+		assertContextCacheStatistics(contextCache, "removed level 2", 0, 1, 4);
+		assertParentContextCount(0);
+	}
+
+	@Test
+	public void removeContextHierarchyCacheLevel3Then2() {
+
+		// Load Level 3-A
+		TestContext testContext3a = new TestContext(ClassHierarchyContextHierarchyLevel3aTestCase.class, contextCache);
+		testContext3a.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A", 3, 0, 3);
+		assertParentContextCount(2);
+
+		// Load Level 3-B
+		TestContext testContext3b = new TestContext(ClassHierarchyContextHierarchyLevel3bTestCase.class, contextCache);
+		testContext3b.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A and B", 4, 1, 4);
+		assertParentContextCount(2);
+
+		// Remove Level 3-A
+		contextCache.remove(getMergedContextConfiguration(testContext3a), HierarchyMode.CURRENT_LEVEL);
+		assertContextCacheStatistics(contextCache, "removed level 3-A", 3, 1, 4);
+		assertParentContextCount(2);
+
+		// Remove Level 2
+		// Should also remove Level 3-B, leaving only Level 1.
+		contextCache.remove(getMergedContextConfiguration(testContext3b).getParent(), HierarchyMode.CURRENT_LEVEL);
+		assertContextCacheStatistics(contextCache, "removed level 2", 1, 1, 4);
+		assertParentContextCount(0);
+	}
+
+	@Test
+	public void removeContextHierarchyCacheLevel3Then2WithExhaustiveMode() {
+
+		// Load Level 3-A
+		TestContext testContext3a = new TestContext(ClassHierarchyContextHierarchyLevel3aTestCase.class, contextCache);
+		testContext3a.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A", 3, 0, 3);
+		assertParentContextCount(2);
+
+		// Load Level 3-B
+		TestContext testContext3b = new TestContext(ClassHierarchyContextHierarchyLevel3bTestCase.class, contextCache);
+		testContext3b.getApplicationContext();
+		assertContextCacheStatistics(contextCache, "level 3, A and B", 4, 1, 4);
+		assertParentContextCount(2);
+
+		// Remove Level 3-A
+		// Should wipe the cache.
+		contextCache.remove(getMergedContextConfiguration(testContext3a), HierarchyMode.EXHAUSTIVE);
+		assertContextCacheStatistics(contextCache, "removed level 3-A", 0, 1, 4);
+		assertParentContextCount(0);
+
+		// Remove Level 2
+		// Should not actually do anything since the cache was cleared in the
+		// previous step. So the stats should remain the same.
+		contextCache.remove(getMergedContextConfiguration(testContext3b).getParent(), HierarchyMode.EXHAUSTIVE);
+		assertContextCacheStatistics(contextCache, "removed level 2", 0, 1, 4);
+		assertParentContextCount(0);
+	}
+
+
+	@Configuration
+	static class Config {
+	}
+
+	@ContextConfiguration(classes = Config.class, loader = AnnotationConfigContextLoader.class)
+	private static class AnnotationConfigContextLoaderTestCase {
+	}
+
+	@ContextConfiguration(classes = Config.class, loader = CustomAnnotationConfigContextLoader.class)
+	private static class CustomAnnotationConfigContextLoaderTestCase {
+	}
+
+	private static class CustomAnnotationConfigContextLoader extends AnnotationConfigContextLoader {
+	}
+
+	@ActiveProfiles({ "foo", "bar" })
+	@ContextConfiguration(classes = Config.class, loader = AnnotationConfigContextLoader.class)
+	private static class FooBarProfilesTestCase {
+	}
+
+	@ActiveProfiles({ "bar", "foo" })
+	@ContextConfiguration(classes = Config.class, loader = AnnotationConfigContextLoader.class)
+	private static class BarFooProfilesTestCase {
+	}
+
+	@ContextHierarchy({ @ContextConfiguration })
+	private static class ClassHierarchyContextHierarchyLevel1TestCase {
+
+		@Configuration
+		static class Level1Config {
+
+		}
+	}
+
+	@ContextHierarchy({ @ContextConfiguration })
+	private static class ClassHierarchyContextHierarchyLevel2TestCase extends
+			ClassHierarchyContextHierarchyLevel1TestCase {
+
+		@Configuration
+		static class Level2Config {
+
+		}
+	}
+
+	@ContextHierarchy({ @ContextConfiguration })
+	private static class ClassHierarchyContextHierarchyLevel3aTestCase extends
+			ClassHierarchyContextHierarchyLevel2TestCase {
+
+		@Configuration
+		static class Level3aConfig {
+
+		}
+	}
+
+	@ContextHierarchy({ @ContextConfiguration })
+	private static class ClassHierarchyContextHierarchyLevel3bTestCase extends
+			ClassHierarchyContextHierarchyLevel2TestCase {
+
+		@Configuration
+		static class Level3bConfig {
+
+		}
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/ContextHierarchyDirtiesContextTests.java b/spring-test/src/test/java/org/springframework/test/context/ContextHierarchyDirtiesContextTests.java
new file mode 100644
index 000000000000..3026e3a0a9bd
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/ContextHierarchyDirtiesContextTests.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context;
+
+import org.junit.After;
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.JUnitCore;
+import org.junit.runner.Result;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+import org.springframework.beans.BeansException;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.ApplicationContextAware;
+import org.springframework.context.ConfigurableApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.annotation.DirtiesContext;
+import org.springframework.test.annotation.DirtiesContext.HierarchyMode;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+/**
+ * Integration tests that verify proper behavior of {@link DirtiesContext @DirtiesContext}
+ * in conjunction with context hierarchies configured via {@link ContextHierarchy @ContextHierarchy}.
+ *
+ * @author Sam Brannen
+ * @author Tadaya Tsuyukubo
+ * @since 3.2.2
+ */
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
+public class ContextHierarchyDirtiesContextTests {
+
+	private static ApplicationContext context;
+
+
+	@After
+	public void cleanUp() {
+		ContextHierarchyDirtiesContextTests.context = null;
+	}
+
+	@Test
+	public void classLevelDirtiesContextWithCurrentLevelHierarchyMode() {
+		runTestAndVerifyHierarchies(ClassLevelDirtiesContextWithCurrentLevelModeTestCase.class, true, true, false);
+	}
+
+	@Test
+	public void classLevelDirtiesContextWithExhaustiveHierarchyMode() {
+		runTestAndVerifyHierarchies(ClassLevelDirtiesContextWithExhaustiveModeTestCase.class, false, false, false);
+	}
+
+	@Test
+	public void methodLevelDirtiesContextWithCurrentLevelHierarchyMode() {
+		runTestAndVerifyHierarchies(MethodLevelDirtiesContextWithCurrentLevelModeTestCase.class, true, true, false);
+	}
+
+	@Test
+	public void methodLevelDirtiesContextWithExhaustiveHierarchyMode() {
+		runTestAndVerifyHierarchies(MethodLevelDirtiesContextWithExhaustiveModeTestCase.class, false, false, false);
+	}
+
+	private void runTestAndVerifyHierarchies(Class<? extends FooTestCase> testClass, boolean isFooContextActive,
+			boolean isBarContextActive, boolean isBazContextActive) {
+
+		JUnitCore jUnitCore = new JUnitCore();
+		Result result = jUnitCore.run(testClass);
+		assertTrue("all tests passed", result.wasSuccessful());
+
+		assertThat(ContextHierarchyDirtiesContextTests.context, notNullValue());
+
+		ConfigurableApplicationContext bazContext = (ConfigurableApplicationContext) ContextHierarchyDirtiesContextTests.context;
+		assertEquals("baz", bazContext.getBean("bean", String.class));
+		assertThat("bazContext#isActive()", bazContext.isActive(), is(isBazContextActive));
+
+		ConfigurableApplicationContext barContext = (ConfigurableApplicationContext) bazContext.getParent();
+		assertThat(barContext, notNullValue());
+		assertEquals("bar", barContext.getBean("bean", String.class));
+		assertThat("barContext#isActive()", barContext.isActive(), is(isBarContextActive));
+
+		ConfigurableApplicationContext fooContext = (ConfigurableApplicationContext) barContext.getParent();
+		assertThat(fooContext, notNullValue());
+		assertEquals("foo", fooContext.getBean("bean", String.class));
+		assertThat("fooContext#isActive()", fooContext.isActive(), is(isFooContextActive));
+	}
+
+
+	// -------------------------------------------------------------------------
+
+	@RunWith(SpringJUnit4ClassRunner.class)
+	@ContextHierarchy(@ContextConfiguration(name = "foo"))
+	static abstract class FooTestCase implements ApplicationContextAware {
+
+		@Configuration
+		static class Config {
+
+			@Bean
+			public String bean() {
+				return "foo";
+			}
+		}
+
+
+		public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
+			ContextHierarchyDirtiesContextTests.context = applicationContext;
+		}
+	}
+
+	@ContextHierarchy(@ContextConfiguration(name = "bar"))
+	static abstract class BarTestCase extends FooTestCase {
+
+		@Configuration
+		static class Config {
+
+			@Bean
+			public String bean() {
+				return "bar";
+			}
+		}
+	}
+
+	@ContextHierarchy(@ContextConfiguration(name = "baz"))
+	static abstract class BazTestCase extends BarTestCase {
+
+		@Configuration
+		static class Config {
+
+			@Bean
+			public String bean() {
+				return "baz";
+			}
+		}
+	}
+
+	// -------------------------------------------------------------------------
+
+	/**
+	 * {@link DirtiesContext} is declared at the class level, without specifying
+	 * the {@link DirtiesContext.HierarchyMode}.
+	 * <p>After running this test class, the context cache should be <em>exhaustively</em>
+	 * cleared beginning from the current context hierarchy, upwards to the highest
+	 * parent context, and then back down through all subhierarchies of the parent
+	 * context.
+	 */
+	@DirtiesContext
+	public static class ClassLevelDirtiesContextWithExhaustiveModeTestCase extends BazTestCase {
+
+		@Test
+		public void test() {
+		}
+	}
+
+	/**
+	 * {@link DirtiesContext} is declared at the class level, specifying the
+	 * {@link DirtiesContext.HierarchyMode#CURRENT_LEVEL CURRENT_LEVEL} hierarchy mode.
+	 * <p>After running this test class, the context cache should be cleared
+	 * beginning from the current context hierarchy and down through all subhierarchies.
+	 */
+	@DirtiesContext(hierarchyMode = HierarchyMode.CURRENT_LEVEL)
+	public static class ClassLevelDirtiesContextWithCurrentLevelModeTestCase extends BazTestCase {
+
+		@Test
+		public void test() {
+		}
+	}
+
+	/**
+	 * {@link DirtiesContext} is declared at the method level, without specifying
+	 * the {@link DirtiesContext.HierarchyMode}.
+	 * <p>After running this test class, the context cache should be <em>exhaustively</em>
+	 * cleared beginning from the current context hierarchy, upwards to the highest
+	 * parent context, and then back down through all subhierarchies of the parent
+	 * context.
+	 */
+	public static class MethodLevelDirtiesContextWithExhaustiveModeTestCase extends BazTestCase {
+
+		@Test
+		@DirtiesContext
+		public void test() {
+		}
+	}
+
+	/**
+	 * {@link DirtiesContext} is declared at the method level, specifying the
+	 * {@link DirtiesContext.HierarchyMode#CURRENT_LEVEL CURRENT_LEVEL} hierarchy mode.
+	 * <p>After running this test class, the context cache should be cleared
+	 * beginning from the current context hierarchy and down through all subhierarchies.
+	 */
+	public static class MethodLevelDirtiesContextWithCurrentLevelModeTestCase extends BazTestCase {
+
+		@Test
+		@DirtiesContext(hierarchyMode = HierarchyMode.CURRENT_LEVEL)
+		public void test() {
+		}
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/ContextLoaderUtilsTests.java b/spring-test/src/test/java/org/springframework/test/context/ContextLoaderUtilsTests.java
index fdfa4eb4ac83..ecedda4ddf9f 100644
--- a/spring-test/src/test/java/org/springframework/test/context/ContextLoaderUtilsTests.java
+++ b/spring-test/src/test/java/org/springframework/test/context/ContextLoaderUtilsTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,13 +16,16 @@
 
 package org.springframework.test.context;
 
+import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
 import static org.springframework.test.context.ContextLoaderUtils.*;
 
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import org.junit.Test;
@@ -105,6 +108,233 @@ private void assertMergedConfig(
 		assertEquals(expectedInitializerClasses, mergedConfig.getContextInitializerClasses());
 	}
 
+	private void debugConfigAttributes(List<ContextConfigurationAttributes> configAttributesList) {
+		// for (ContextConfigurationAttributes configAttributes : configAttributesList) {
+		// System.err.println(configAttributes);
+		// }
+	}
+
+	@Test(expected = IllegalStateException.class)
+	public void resolveContextHierarchyAttributesForSingleTestClassWithContextConfigurationAndContextHierarchy() {
+		resolveContextHierarchyAttributes(SingleTestClassWithContextConfigurationAndContextHierarchy.class);
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForSingleTestClassWithImplicitSingleLevelContextHierarchy() {
+		List<List<ContextConfigurationAttributes>> hierarchyAttributes = resolveContextHierarchyAttributes(BareAnnotations.class);
+		assertEquals(1, hierarchyAttributes.size());
+		List<ContextConfigurationAttributes> configAttributesList = hierarchyAttributes.get(0);
+		assertEquals(1, configAttributesList.size());
+		debugConfigAttributes(configAttributesList);
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForSingleTestClassWithSingleLevelContextHierarchy() {
+		List<List<ContextConfigurationAttributes>> hierarchyAttributes = resolveContextHierarchyAttributes(SingleTestClassWithSingleLevelContextHierarchy.class);
+		assertEquals(1, hierarchyAttributes.size());
+		List<ContextConfigurationAttributes> configAttributesList = hierarchyAttributes.get(0);
+		assertEquals(1, configAttributesList.size());
+		debugConfigAttributes(configAttributesList);
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForSingleTestClassWithTripleLevelContextHierarchy() {
+		List<List<ContextConfigurationAttributes>> hierarchyAttributes = resolveContextHierarchyAttributes(SingleTestClassWithTripleLevelContextHierarchy.class);
+		assertEquals(1, hierarchyAttributes.size());
+		List<ContextConfigurationAttributes> configAttributesList = hierarchyAttributes.get(0);
+		assertEquals(3, configAttributesList.size());
+		debugConfigAttributes(configAttributesList);
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForTestClassHierarchyWithSingleLevelContextHierarchies() {
+		List<List<ContextConfigurationAttributes>> hierarchyAttributes = resolveContextHierarchyAttributes(TestClass3WithSingleLevelContextHierarchy.class);
+		assertEquals(3, hierarchyAttributes.size());
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel1 = hierarchyAttributes.get(0);
+		debugConfigAttributes(configAttributesListClassLevel1);
+		assertEquals(1, configAttributesListClassLevel1.size());
+		assertThat(configAttributesListClassLevel1.get(0).getLocations()[0], equalTo("one.xml"));
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel2 = hierarchyAttributes.get(1);
+		debugConfigAttributes(configAttributesListClassLevel2);
+		assertEquals(1, configAttributesListClassLevel2.size());
+		assertArrayEquals(new String[] { "two-A.xml", "two-B.xml" },
+			configAttributesListClassLevel2.get(0).getLocations());
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel3 = hierarchyAttributes.get(2);
+		debugConfigAttributes(configAttributesListClassLevel3);
+		assertEquals(1, configAttributesListClassLevel3.size());
+		assertThat(configAttributesListClassLevel3.get(0).getLocations()[0], equalTo("three.xml"));
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForTestClassHierarchyWithBareContextConfigurationInSubclass() {
+		List<List<ContextConfigurationAttributes>> hierarchyAttributes = resolveContextHierarchyAttributes(TestClass2WithBareContextConfigurationInSubclass.class);
+		assertEquals(2, hierarchyAttributes.size());
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel1 = hierarchyAttributes.get(0);
+		debugConfigAttributes(configAttributesListClassLevel1);
+		assertEquals(1, configAttributesListClassLevel1.size());
+		assertThat(configAttributesListClassLevel1.get(0).getLocations()[0], equalTo("one.xml"));
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel2 = hierarchyAttributes.get(1);
+		debugConfigAttributes(configAttributesListClassLevel2);
+		assertEquals(1, configAttributesListClassLevel2.size());
+		assertThat(configAttributesListClassLevel2.get(0).getLocations()[0], equalTo("two.xml"));
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForTestClassHierarchyWithBareContextConfigurationInSuperclass() {
+		List<List<ContextConfigurationAttributes>> hierarchyAttributes = resolveContextHierarchyAttributes(TestClass2WithBareContextConfigurationInSuperclass.class);
+		assertEquals(2, hierarchyAttributes.size());
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel1 = hierarchyAttributes.get(0);
+		debugConfigAttributes(configAttributesListClassLevel1);
+		assertEquals(1, configAttributesListClassLevel1.size());
+		assertThat(configAttributesListClassLevel1.get(0).getLocations()[0], equalTo("one.xml"));
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel2 = hierarchyAttributes.get(1);
+		debugConfigAttributes(configAttributesListClassLevel2);
+		assertEquals(1, configAttributesListClassLevel2.size());
+		assertThat(configAttributesListClassLevel2.get(0).getLocations()[0], equalTo("two.xml"));
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForTestClassHierarchyWithMultiLevelContextHierarchies() {
+		List<List<ContextConfigurationAttributes>> hierarchyAttributes = resolveContextHierarchyAttributes(TestClass3WithMultiLevelContextHierarchy.class);
+		assertEquals(3, hierarchyAttributes.size());
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel1 = hierarchyAttributes.get(0);
+		debugConfigAttributes(configAttributesListClassLevel1);
+		assertEquals(2, configAttributesListClassLevel1.size());
+		assertThat(configAttributesListClassLevel1.get(0).getLocations()[0], equalTo("1-A.xml"));
+		assertThat(configAttributesListClassLevel1.get(1).getLocations()[0], equalTo("1-B.xml"));
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel2 = hierarchyAttributes.get(1);
+		debugConfigAttributes(configAttributesListClassLevel2);
+		assertEquals(2, configAttributesListClassLevel2.size());
+		assertThat(configAttributesListClassLevel2.get(0).getLocations()[0], equalTo("2-A.xml"));
+		assertThat(configAttributesListClassLevel2.get(1).getLocations()[0], equalTo("2-B.xml"));
+
+		List<ContextConfigurationAttributes> configAttributesListClassLevel3 = hierarchyAttributes.get(2);
+		debugConfigAttributes(configAttributesListClassLevel3);
+		assertEquals(3, configAttributesListClassLevel3.size());
+		assertThat(configAttributesListClassLevel3.get(0).getLocations()[0], equalTo("3-A.xml"));
+		assertThat(configAttributesListClassLevel3.get(1).getLocations()[0], equalTo("3-B.xml"));
+		assertThat(configAttributesListClassLevel3.get(2).getLocations()[0], equalTo("3-C.xml"));
+	}
+
+	private void assertContextConfigEntriesAreNotUnique(Class<?> testClass) {
+		try {
+			resolveContextHierarchyAttributes(testClass);
+			fail("Should throw an IllegalStateException");
+		}
+		catch (IllegalStateException e) {
+			String msg = String.format(
+				"The @ContextConfiguration elements configured via @ContextHierarchy in test class [%s] must define unique contexts to load.",
+				testClass.getName());
+			assertEquals(msg, e.getMessage());
+		}
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForSingleTestClassWithMultiLevelContextHierarchyWithEmptyContextConfig() {
+		assertContextConfigEntriesAreNotUnique(SingleTestClassWithMultiLevelContextHierarchyWithEmptyContextConfig.class);
+	}
+
+	@Test
+	public void resolveContextHierarchyAttributesForSingleTestClassWithMultiLevelContextHierarchyWithDuplicatedContextConfig() {
+		assertContextConfigEntriesAreNotUnique(SingleTestClassWithMultiLevelContextHierarchyWithDuplicatedContextConfig.class);
+	}
+
+	@Test
+	public void buildContextHierarchyMapForTestClassHierarchyWithMultiLevelContextHierarchies() {
+		Map<String, List<ContextConfigurationAttributes>> map = buildContextHierarchyMap(TestClass3WithMultiLevelContextHierarchy.class);
+
+		assertThat(map.size(), is(3));
+		assertThat(map.keySet(), hasItems("alpha", "beta", "gamma"));
+
+		List<ContextConfigurationAttributes> alphaConfig = map.get("alpha");
+		assertThat(alphaConfig.size(), is(3));
+		assertThat(alphaConfig.get(0).getLocations()[0], is("1-A.xml"));
+		assertThat(alphaConfig.get(1).getLocations()[0], is("2-A.xml"));
+		assertThat(alphaConfig.get(2).getLocations()[0], is("3-A.xml"));
+
+		List<ContextConfigurationAttributes> betaConfig = map.get("beta");
+		assertThat(betaConfig.size(), is(3));
+		assertThat(betaConfig.get(0).getLocations()[0], is("1-B.xml"));
+		assertThat(betaConfig.get(1).getLocations()[0], is("2-B.xml"));
+		assertThat(betaConfig.get(2).getLocations()[0], is("3-B.xml"));
+
+		List<ContextConfigurationAttributes> gammaConfig = map.get("gamma");
+		assertThat(gammaConfig.size(), is(1));
+		assertThat(gammaConfig.get(0).getLocations()[0], is("3-C.xml"));
+	}
+
+	@Test
+	public void buildContextHierarchyMapForTestClassHierarchyWithMultiLevelContextHierarchiesAndUnnamedConfig() {
+		Map<String, List<ContextConfigurationAttributes>> map = buildContextHierarchyMap(TestClass3WithMultiLevelContextHierarchyAndUnnamedConfig.class);
+
+		String level1 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 1;
+		String level2 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 2;
+		String level3 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 3;
+		String level4 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 4;
+		String level5 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 5;
+		String level6 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 6;
+		String level7 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 7;
+
+		assertThat(map.size(), is(7));
+		assertThat(map.keySet(), hasItems(level1, level2, level3, level4, level5, level6, level7));
+
+		List<ContextConfigurationAttributes> level1Config = map.get(level1);
+		assertThat(level1Config.size(), is(1));
+		assertThat(level1Config.get(0).getLocations()[0], is("1-A.xml"));
+
+		List<ContextConfigurationAttributes> level2Config = map.get(level2);
+		assertThat(level2Config.size(), is(1));
+		assertThat(level2Config.get(0).getLocations()[0], is("1-B.xml"));
+
+		List<ContextConfigurationAttributes> level3Config = map.get(level3);
+		assertThat(level3Config.size(), is(1));
+		assertThat(level3Config.get(0).getLocations()[0], is("2-A.xml"));
+
+		// ...
+
+		List<ContextConfigurationAttributes> level7Config = map.get(level7);
+		assertThat(level7Config.size(), is(1));
+		assertThat(level7Config.get(0).getLocations()[0], is("3-C.xml"));
+	}
+
+	@Test
+	public void buildContextHierarchyMapForTestClassHierarchyWithMultiLevelContextHierarchiesAndPartiallyNamedConfig() {
+		Map<String, List<ContextConfigurationAttributes>> map = buildContextHierarchyMap(TestClass2WithMultiLevelContextHierarchyAndPartiallyNamedConfig.class);
+
+		String level1 = "parent";
+		String level2 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 2;
+		String level3 = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + 3;
+
+		assertThat(map.size(), is(3));
+		assertThat(map.keySet(), hasItems(level1, level2, level3));
+		Iterator<String> levels = map.keySet().iterator();
+		assertThat(levels.next(), is(level1));
+		assertThat(levels.next(), is(level2));
+		assertThat(levels.next(), is(level3));
+
+		List<ContextConfigurationAttributes> level1Config = map.get(level1);
+		assertThat(level1Config.size(), is(2));
+		assertThat(level1Config.get(0).getLocations()[0], is("1-A.xml"));
+		assertThat(level1Config.get(1).getLocations()[0], is("2-A.xml"));
+
+		List<ContextConfigurationAttributes> level2Config = map.get(level2);
+		assertThat(level2Config.size(), is(1));
+		assertThat(level2Config.get(0).getLocations()[0], is("1-B.xml"));
+
+		List<ContextConfigurationAttributes> level3Config = map.get(level3);
+		assertThat(level3Config.size(), is(1));
+		assertThat(level3Config.get(0).getLocations()[0], is("2-C.xml"));
+	}
+
 	@Test(expected = IllegalStateException.class)
 	public void resolveConfigAttributesWithConflictingLocations() {
 		resolveContextConfigurationAttributes(ConflictingLocations.class);
@@ -155,13 +385,13 @@ public void resolveConfigAttributesWithLocalAndInheritedAnnotationsAndClasses()
 
 	@Test(expected = IllegalArgumentException.class)
 	public void buildMergedConfigWithoutAnnotation() {
-		buildMergedContextConfiguration(Enigma.class, null);
+		buildMergedContextConfiguration(Enigma.class, null, null);
 	}
 
 	@Test
 	public void buildMergedConfigWithBareAnnotations() {
 		Class<BareAnnotations> testClass = BareAnnotations.class;
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 
 		assertMergedConfig(
 			mergedConfig,
@@ -173,7 +403,7 @@ public void buildMergedConfigWithBareAnnotations() {
 	@Test
 	public void buildMergedConfigWithLocalAnnotationAndLocations() {
 		Class<?> testClass = LocationsFoo.class;
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 
 		assertMergedConfig(mergedConfig, testClass, new String[] { "classpath:/foo.xml" }, EMPTY_CLASS_ARRAY,
 			DelegatingSmartContextLoader.class);
@@ -182,7 +412,7 @@ public void buildMergedConfigWithLocalAnnotationAndLocations() {
 	@Test
 	public void buildMergedConfigWithLocalAnnotationAndClasses() {
 		Class<?> testClass = ClassesFoo.class;
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 
 		assertMergedConfig(mergedConfig, testClass, EMPTY_STRING_ARRAY, new Class<?>[] { FooConfig.class },
 			DelegatingSmartContextLoader.class);
@@ -193,7 +423,7 @@ public void buildMergedConfigWithLocalAnnotationAndOverriddenContextLoaderAndLoc
 		Class<?> testClass = LocationsFoo.class;
 		Class<? extends ContextLoader> expectedContextLoaderClass = GenericPropertiesContextLoader.class;
 		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass,
-			expectedContextLoaderClass.getName());
+			expectedContextLoaderClass.getName(), null);
 
 		assertMergedConfig(mergedConfig, testClass, new String[] { "classpath:/foo.xml" }, EMPTY_CLASS_ARRAY,
 			expectedContextLoaderClass);
@@ -204,7 +434,7 @@ public void buildMergedConfigWithLocalAnnotationAndOverriddenContextLoaderAndCla
 		Class<?> testClass = ClassesFoo.class;
 		Class<? extends ContextLoader> expectedContextLoaderClass = GenericPropertiesContextLoader.class;
 		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass,
-			expectedContextLoaderClass.getName());
+			expectedContextLoaderClass.getName(), null);
 
 		assertMergedConfig(mergedConfig, testClass, EMPTY_STRING_ARRAY, new Class<?>[] { FooConfig.class },
 			expectedContextLoaderClass);
@@ -215,7 +445,7 @@ public void buildMergedConfigWithLocalAndInheritedAnnotationsAndLocations() {
 		Class<?> testClass = LocationsBar.class;
 		String[] expectedLocations = new String[] { "/foo.xml", "/bar.xml" };
 
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 		assertMergedConfig(mergedConfig, testClass, expectedLocations, EMPTY_CLASS_ARRAY,
 			AnnotationConfigContextLoader.class);
 	}
@@ -225,7 +455,7 @@ public void buildMergedConfigWithLocalAndInheritedAnnotationsAndClasses() {
 		Class<?> testClass = ClassesBar.class;
 		Class<?>[] expectedClasses = new Class<?>[] { FooConfig.class, BarConfig.class };
 
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 		assertMergedConfig(mergedConfig, testClass, EMPTY_STRING_ARRAY, expectedClasses,
 			AnnotationConfigContextLoader.class);
 	}
@@ -235,7 +465,7 @@ public void buildMergedConfigWithAnnotationsAndOverriddenLocations() {
 		Class<?> testClass = OverriddenLocationsBar.class;
 		String[] expectedLocations = new String[] { "/bar.xml" };
 
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 		assertMergedConfig(mergedConfig, testClass, expectedLocations, EMPTY_CLASS_ARRAY,
 			AnnotationConfigContextLoader.class);
 	}
@@ -245,7 +475,7 @@ public void buildMergedConfigWithAnnotationsAndOverriddenClasses() {
 		Class<?> testClass = OverriddenClassesBar.class;
 		Class<?>[] expectedClasses = new Class<?>[] { BarConfig.class };
 
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 		assertMergedConfig(mergedConfig, testClass, EMPTY_STRING_ARRAY, expectedClasses,
 			AnnotationConfigContextLoader.class);
 	}
@@ -258,7 +488,7 @@ public void buildMergedConfigWithLocalInitializer() {
 		= new HashSet<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>>();
 		expectedInitializerClasses.add(FooInitializer.class);
 
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 		assertMergedConfig(mergedConfig, testClass, EMPTY_STRING_ARRAY, expectedClasses, expectedInitializerClasses,
 			DelegatingSmartContextLoader.class);
 	}
@@ -272,7 +502,7 @@ public void buildMergedConfigWithLocalAndInheritedInitializer() {
 		expectedInitializerClasses.add(FooInitializer.class);
 		expectedInitializerClasses.add(BarInitializer.class);
 
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 		assertMergedConfig(mergedConfig, testClass, EMPTY_STRING_ARRAY, expectedClasses, expectedInitializerClasses,
 			DelegatingSmartContextLoader.class);
 	}
@@ -285,7 +515,7 @@ public void buildMergedConfigWithOverriddenInitializers() {
 		= new HashSet<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>>();
 		expectedInitializerClasses.add(BarInitializer.class);
 
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 		assertMergedConfig(mergedConfig, testClass, EMPTY_STRING_ARRAY, expectedClasses, expectedInitializerClasses,
 			DelegatingSmartContextLoader.class);
 	}
@@ -298,7 +528,7 @@ public void buildMergedConfigWithOverriddenInitializersAndClasses() {
 		= new HashSet<Class<? extends ApplicationContextInitializer<? extends ConfigurableApplicationContext>>>();
 		expectedInitializerClasses.add(BarInitializer.class);
 
-		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null);
+		MergedContextConfiguration mergedConfig = buildMergedContextConfiguration(testClass, null, null);
 		assertMergedConfig(mergedConfig, testClass, EMPTY_STRING_ARRAY, expectedClasses, expectedInitializerClasses,
 			DelegatingSmartContextLoader.class);
 	}
@@ -377,6 +607,8 @@ public void resolveActiveProfilesWithOverriddenAnnotation() {
 	}
 
 
+	// -------------------------------------------------------------------------
+
 	private static class Enigma {
 	}
 
@@ -475,4 +707,140 @@ private static class OverriddenInitializersBar extends InitializersFoo {
 	private static class OverriddenInitializersAndClassesBar extends InitializersFoo {
 	}
 
+	@ContextConfiguration("foo.xml")
+	@ContextHierarchy(@ContextConfiguration("bar.xml"))
+	private static class SingleTestClassWithContextConfigurationAndContextHierarchy {
+	}
+
+	@ContextHierarchy(@ContextConfiguration("A.xml"))
+	private static class SingleTestClassWithSingleLevelContextHierarchy {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration("A.xml"),//
+		@ContextConfiguration("B.xml"),//
+		@ContextConfiguration("C.xml") //
+	})
+	private static class SingleTestClassWithTripleLevelContextHierarchy {
+	}
+
+	@ContextHierarchy(@ContextConfiguration("one.xml"))
+	private static class TestClass1WithSingleLevelContextHierarchy {
+	}
+
+	@ContextHierarchy(@ContextConfiguration({ "two-A.xml", "two-B.xml" }))
+	private static class TestClass2WithSingleLevelContextHierarchy extends TestClass1WithSingleLevelContextHierarchy {
+	}
+
+	@ContextHierarchy(@ContextConfiguration("three.xml"))
+	private static class TestClass3WithSingleLevelContextHierarchy extends TestClass2WithSingleLevelContextHierarchy {
+	}
+
+	@ContextConfiguration("one.xml")
+	private static class TestClass1WithBareContextConfigurationInSuperclass {
+	}
+
+	@ContextHierarchy(@ContextConfiguration("two.xml"))
+	private static class TestClass2WithBareContextConfigurationInSuperclass extends
+			TestClass1WithBareContextConfigurationInSuperclass {
+	}
+
+	@ContextHierarchy(@ContextConfiguration("one.xml"))
+	private static class TestClass1WithBareContextConfigurationInSubclass {
+	}
+
+	@ContextConfiguration("two.xml")
+	private static class TestClass2WithBareContextConfigurationInSubclass extends
+			TestClass1WithBareContextConfigurationInSuperclass {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration(locations = "1-A.xml", name = "alpha"),//
+		@ContextConfiguration(locations = "1-B.xml", name = "beta") //
+	})
+	private static class TestClass1WithMultiLevelContextHierarchy {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration(locations = "2-A.xml", name = "alpha"),//
+		@ContextConfiguration(locations = "2-B.xml", name = "beta") //
+	})
+	private static class TestClass2WithMultiLevelContextHierarchy extends TestClass1WithMultiLevelContextHierarchy {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration(locations = "3-A.xml", name = "alpha"),//
+		@ContextConfiguration(locations = "3-B.xml", name = "beta"),//
+		@ContextConfiguration(locations = "3-C.xml", name = "gamma") //
+	})
+	private static class TestClass3WithMultiLevelContextHierarchy extends TestClass2WithMultiLevelContextHierarchy {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration(locations = "1-A.xml"),//
+		@ContextConfiguration(locations = "1-B.xml") //
+	})
+	private static class TestClass1WithMultiLevelContextHierarchyAndUnnamedConfig {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration(locations = "2-A.xml"),//
+		@ContextConfiguration(locations = "2-B.xml") //
+	})
+	private static class TestClass2WithMultiLevelContextHierarchyAndUnnamedConfig extends
+			TestClass1WithMultiLevelContextHierarchyAndUnnamedConfig {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration(locations = "3-A.xml"),//
+		@ContextConfiguration(locations = "3-B.xml"),//
+		@ContextConfiguration(locations = "3-C.xml") //
+	})
+	private static class TestClass3WithMultiLevelContextHierarchyAndUnnamedConfig extends
+			TestClass2WithMultiLevelContextHierarchyAndUnnamedConfig {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration(locations = "1-A.xml", name = "parent"),//
+		@ContextConfiguration(locations = "1-B.xml") //
+	})
+	private static class TestClass1WithMultiLevelContextHierarchyAndPartiallyNamedConfig {
+	}
+
+	@ContextHierarchy({//
+	//
+		@ContextConfiguration(locations = "2-A.xml", name = "parent"),//
+		@ContextConfiguration(locations = "2-C.xml") //
+	})
+	private static class TestClass2WithMultiLevelContextHierarchyAndPartiallyNamedConfig extends
+			TestClass1WithMultiLevelContextHierarchyAndPartiallyNamedConfig {
+	}
+
+	@ContextHierarchy({
+		//
+		@ContextConfiguration,//
+		@ContextConfiguration //
+	})
+	private static class SingleTestClassWithMultiLevelContextHierarchyWithEmptyContextConfig {
+	}
+
+	@ContextHierarchy({
+		//
+		@ContextConfiguration("foo.xml"),//
+		@ContextConfiguration(classes = BarConfig.class),// duplicate!
+		@ContextConfiguration("baz.xml"),//
+		@ContextConfiguration(classes = BarConfig.class),// duplicate!
+		@ContextConfiguration(loader = AnnotationConfigContextLoader.class) //
+	})
+	private static class SingleTestClassWithMultiLevelContextHierarchyWithDuplicatedContextConfig {
+	}
+
 }
diff --git a/spring-test/src/test/java/org/springframework/test/context/MergedContextConfigurationTests.java b/spring-test/src/test/java/org/springframework/test/context/MergedContextConfigurationTests.java
index 35b64fa432b0..863fd9da868f 100644
--- a/spring-test/src/test/java/org/springframework/test/context/MergedContextConfigurationTests.java
+++ b/spring-test/src/test/java/org/springframework/test/context/MergedContextConfigurationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -76,7 +76,7 @@ public void hashCodeWithEmptyArraysAndDifferentLoaders() {
 			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
 			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, new AnnotationConfigContextLoader());
-		assertFalse(mergedConfig1.hashCode() == mergedConfig2.hashCode());
+		assertNotEquals(mergedConfig1.hashCode(), mergedConfig2.hashCode());
 	}
 
 	@Test
@@ -97,7 +97,7 @@ public void hashCodeWithDifferentLocations() {
 			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), locations2,
 			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
-		assertFalse(mergedConfig1.hashCode() == mergedConfig2.hashCode());
+		assertNotEquals(mergedConfig1.hashCode(), mergedConfig2.hashCode());
 	}
 
 	@Test
@@ -118,7 +118,7 @@ public void hashCodeWithDifferentConfigClasses() {
 			classes1, EMPTY_STRING_ARRAY, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
 			classes2, EMPTY_STRING_ARRAY, loader);
-		assertFalse(mergedConfig1.hashCode() == mergedConfig2.hashCode());
+		assertNotEquals(mergedConfig1.hashCode(), mergedConfig2.hashCode());
 	}
 
 	@Test
@@ -161,7 +161,7 @@ public void hashCodeWithDifferentProfiles() {
 			EMPTY_CLASS_ARRAY, activeProfiles1, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
 			EMPTY_CLASS_ARRAY, activeProfiles2, loader);
-		assertFalse(mergedConfig1.hashCode() == mergedConfig2.hashCode());
+		assertNotEquals(mergedConfig1.hashCode(), mergedConfig2.hashCode());
 	}
 
 	@Test
@@ -197,15 +197,47 @@ public void hashCodeWithDifferentInitializers() {
 			EMPTY_CLASS_ARRAY, initializerClasses1, EMPTY_STRING_ARRAY, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
 			EMPTY_CLASS_ARRAY, initializerClasses2, EMPTY_STRING_ARRAY, loader);
-		assertFalse(mergedConfig1.hashCode() == mergedConfig2.hashCode());
+		assertNotEquals(mergedConfig1.hashCode(), mergedConfig2.hashCode());
+	}
+
+	/**
+	 * @since 3.2.2
+	 */
+	@Test
+	public void hashCodeWithSameParent() {
+		MergedContextConfiguration parent = new MergedContextConfiguration(getClass(), new String[] { "foo", "bar}" },
+			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
+
+		MergedContextConfiguration mergedConfig1 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
+			EMPTY_CLASS_ARRAY, null, EMPTY_STRING_ARRAY, loader, null, parent);
+		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
+			EMPTY_CLASS_ARRAY, null, EMPTY_STRING_ARRAY, loader, null, parent);
+		assertEquals(mergedConfig1.hashCode(), mergedConfig2.hashCode());
+	}
+
+	/**
+	 * @since 3.2.2
+	 */
+	@Test
+	public void hashCodeWithDifferentParents() {
+		MergedContextConfiguration parent1 = new MergedContextConfiguration(getClass(), new String[] { "foo", "bar}" },
+			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
+		MergedContextConfiguration parent2 = new MergedContextConfiguration(getClass(), new String[] { "baz", "quux" },
+			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
+
+		MergedContextConfiguration mergedConfig1 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
+			EMPTY_CLASS_ARRAY, null, EMPTY_STRING_ARRAY, loader, null, parent1);
+		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
+			EMPTY_CLASS_ARRAY, null, EMPTY_STRING_ARRAY, loader, null, parent2);
+		assertNotEquals(mergedConfig1.hashCode(), mergedConfig2.hashCode());
 	}
 
 	@Test
 	public void equalsBasics() {
 		MergedContextConfiguration mergedConfig = new MergedContextConfiguration(null, null, null, null, null);
-		assertTrue(mergedConfig.equals(mergedConfig));
-		assertFalse(mergedConfig.equals(null));
-		assertFalse(mergedConfig.equals(new Integer(1)));
+		assertEquals(mergedConfig, mergedConfig);
+		assertNotEquals(mergedConfig, null);
+		assertNotEquals(mergedConfig, new Integer(1));
 	}
 
 	@Test
@@ -237,8 +269,8 @@ public void equalsWithEmptyArraysAndDifferentLoaders() {
 			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
 			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, new AnnotationConfigContextLoader());
-		assertFalse(mergedConfig1.equals(mergedConfig2));
-		assertFalse(mergedConfig2.equals(mergedConfig1));
+		assertNotEquals(mergedConfig1, mergedConfig2);
+		assertNotEquals(mergedConfig2, mergedConfig1);
 	}
 
 	@Test
@@ -259,8 +291,8 @@ public void equalsWithDifferentLocations() {
 			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), locations2,
 			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
-		assertFalse(mergedConfig1.equals(mergedConfig2));
-		assertFalse(mergedConfig2.equals(mergedConfig1));
+		assertNotEquals(mergedConfig1, mergedConfig2);
+		assertNotEquals(mergedConfig2, mergedConfig1);
 	}
 
 	@Test
@@ -281,8 +313,8 @@ public void equalsWithDifferentConfigClasses() {
 			classes1, EMPTY_STRING_ARRAY, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
 			classes2, EMPTY_STRING_ARRAY, loader);
-		assertFalse(mergedConfig1.equals(mergedConfig2));
-		assertFalse(mergedConfig2.equals(mergedConfig1));
+		assertNotEquals(mergedConfig1, mergedConfig2);
+		assertNotEquals(mergedConfig2, mergedConfig1);
 	}
 
 	@Test
@@ -325,8 +357,8 @@ public void equalsWithDifferentProfiles() {
 			EMPTY_CLASS_ARRAY, activeProfiles1, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
 			EMPTY_CLASS_ARRAY, activeProfiles2, loader);
-		assertFalse(mergedConfig1.equals(mergedConfig2));
-		assertFalse(mergedConfig2.equals(mergedConfig1));
+		assertNotEquals(mergedConfig1, mergedConfig2);
+		assertNotEquals(mergedConfig2, mergedConfig1);
 	}
 
 	@Test
@@ -362,8 +394,42 @@ public void equalsWithDifferentInitializers() {
 			EMPTY_CLASS_ARRAY, initializerClasses1, EMPTY_STRING_ARRAY, loader);
 		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
 			EMPTY_CLASS_ARRAY, initializerClasses2, EMPTY_STRING_ARRAY, loader);
-		assertFalse(mergedConfig1.equals(mergedConfig2));
-		assertFalse(mergedConfig2.equals(mergedConfig1));
+		assertNotEquals(mergedConfig1, mergedConfig2);
+		assertNotEquals(mergedConfig2, mergedConfig1);
+	}
+
+	/**
+	 * @since 3.2.2
+	 */
+	@Test
+	public void equalsWithSameParent() {
+		MergedContextConfiguration parent = new MergedContextConfiguration(getClass(), new String[] { "foo", "bar}" },
+			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
+
+		MergedContextConfiguration mergedConfig1 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
+			EMPTY_CLASS_ARRAY, null, EMPTY_STRING_ARRAY, loader, null, parent);
+		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
+			EMPTY_CLASS_ARRAY, null, EMPTY_STRING_ARRAY, loader, null, parent);
+		assertEquals(mergedConfig1, mergedConfig2);
+		assertEquals(mergedConfig2, mergedConfig1);
+	}
+
+	/**
+	 * @since 3.2.2
+	 */
+	@Test
+	public void equalsWithDifferentParents() {
+		MergedContextConfiguration parent1 = new MergedContextConfiguration(getClass(), new String[] { "foo", "bar}" },
+			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
+		MergedContextConfiguration parent2 = new MergedContextConfiguration(getClass(), new String[] { "baz", "quux" },
+			EMPTY_CLASS_ARRAY, EMPTY_STRING_ARRAY, loader);
+
+		MergedContextConfiguration mergedConfig1 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
+			EMPTY_CLASS_ARRAY, null, EMPTY_STRING_ARRAY, loader, null, parent1);
+		MergedContextConfiguration mergedConfig2 = new MergedContextConfiguration(getClass(), EMPTY_STRING_ARRAY,
+			EMPTY_CLASS_ARRAY, null, EMPTY_STRING_ARRAY, loader, null, parent2);
+		assertNotEquals(mergedConfig1, mergedConfig2);
+		assertNotEquals(mergedConfig2, mergedConfig1);
 	}
 
 
diff --git a/spring-test/src/test/java/org/springframework/test/context/SpringRunnerContextCacheTests.java b/spring-test/src/test/java/org/springframework/test/context/SpringRunnerContextCacheTests.java
index d27e3ca50d53..07f7383189cc 100644
--- a/spring-test/src/test/java/org/springframework/test/context/SpringRunnerContextCacheTests.java
+++ b/spring-test/src/test/java/org/springframework/test/context/SpringRunnerContextCacheTests.java
@@ -44,7 +44,7 @@
  * @author Sam Brannen
  * @author Juergen Hoeller
  * @since 2.5
- * @see TestContextCacheKeyTests
+ * @see ContextCacheTests
  */
 @RunWith(OrderedMethodsSpringJUnit4ClassRunner.class)
 @TestExecutionListeners({ DependencyInjectionTestExecutionListener.class, DirtiesContextTestExecutionListener.class })
diff --git a/spring-test/src/test/java/org/springframework/test/context/TestContextCacheKeyTests.java b/spring-test/src/test/java/org/springframework/test/context/TestContextCacheKeyTests.java
deleted file mode 100644
index d76593794098..000000000000
--- a/spring-test/src/test/java/org/springframework/test/context/TestContextCacheKeyTests.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright 2002-2012 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.test.context;
-
-import static org.junit.Assert.assertNotNull;
-import static org.springframework.test.context.SpringRunnerContextCacheTests.assertContextCacheStatistics;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.springframework.context.ApplicationContext;
-import org.springframework.context.annotation.Configuration;
-import org.springframework.test.context.support.AnnotationConfigContextLoader;
-
-/**
- * Unit tests for verifying proper behavior of the {@link ContextCache} in
- * conjunction with cache keys used in {@link TestContext}.
- *
- * @author Sam Brannen
- * @since 3.1
- * @see SpringRunnerContextCacheTests
- */
-public class TestContextCacheKeyTests {
-
-	private ContextCache contextCache = new ContextCache();
-
-
-	@Before
-	public void initialCacheState() {
-		assertContextCacheStatistics(contextCache, "initial state", 0, 0, 0);
-	}
-
-	private void loadAppCtxAndAssertCacheStats(Class<?> testClass, int expectedSize, int expectedHitCount,
-			int expectedMissCount) {
-		TestContext testContext = new TestContext(testClass, contextCache);
-		ApplicationContext context = testContext.getApplicationContext();
-		assertNotNull(context);
-		assertContextCacheStatistics(contextCache, testClass.getName(), expectedSize, expectedHitCount,
-			expectedMissCount);
-	}
-
-	@Test
-	public void verifyCacheKeyIsBasedOnContextLoader() {
-		loadAppCtxAndAssertCacheStats(AnnotationConfigContextLoaderTestCase.class, 1, 0, 1);
-		loadAppCtxAndAssertCacheStats(AnnotationConfigContextLoaderTestCase.class, 1, 1, 1);
-		loadAppCtxAndAssertCacheStats(CustomAnnotationConfigContextLoaderTestCase.class, 2, 1, 2);
-		loadAppCtxAndAssertCacheStats(CustomAnnotationConfigContextLoaderTestCase.class, 2, 2, 2);
-		loadAppCtxAndAssertCacheStats(AnnotationConfigContextLoaderTestCase.class, 2, 3, 2);
-		loadAppCtxAndAssertCacheStats(CustomAnnotationConfigContextLoaderTestCase.class, 2, 4, 2);
-	}
-
-	@Test
-	public void verifyCacheKeyIsBasedOnActiveProfiles() {
-		loadAppCtxAndAssertCacheStats(FooBarProfilesTestCase.class, 1, 0, 1);
-		loadAppCtxAndAssertCacheStats(FooBarProfilesTestCase.class, 1, 1, 1);
-		// Profiles {foo, bar} should hash to the same as {bar,foo}
-		loadAppCtxAndAssertCacheStats(BarFooProfilesTestCase.class, 1, 2, 1);
-		loadAppCtxAndAssertCacheStats(FooBarProfilesTestCase.class, 1, 3, 1);
-		loadAppCtxAndAssertCacheStats(FooBarProfilesTestCase.class, 1, 4, 1);
-		loadAppCtxAndAssertCacheStats(BarFooProfilesTestCase.class, 1, 5, 1);
-	}
-
-
-	@Configuration
-	static class Config {
-	}
-
-	@ContextConfiguration(classes = Config.class, loader = AnnotationConfigContextLoader.class)
-	private static class AnnotationConfigContextLoaderTestCase {
-	}
-
-	@ContextConfiguration(classes = Config.class, loader = CustomAnnotationConfigContextLoader.class)
-	private static class CustomAnnotationConfigContextLoaderTestCase {
-	}
-
-	private static class CustomAnnotationConfigContextLoader extends AnnotationConfigContextLoader {
-	}
-
-	@ActiveProfiles({ "foo", "bar" })
-	@ContextConfiguration(classes = Config.class, loader = AnnotationConfigContextLoader.class)
-	private static class FooBarProfilesTestCase {
-	}
-
-	@ActiveProfiles({ "bar", "foo" })
-	@ContextConfiguration(classes = Config.class, loader = AnnotationConfigContextLoader.class)
-	private static class BarFooProfilesTestCase {
-	}
-
-}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithMergedConfigLevelOneTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithMergedConfigLevelOneTests.java
new file mode 100644
index 000000000000..716228c7c354
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithMergedConfigLevelOneTests.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Qualifier;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy({
+//
+	@ContextConfiguration(name = "parent", classes = ClassHierarchyWithMergedConfigLevelOneTests.AppConfig.class),//
+	@ContextConfiguration(name = "child", classes = ClassHierarchyWithMergedConfigLevelOneTests.UserConfig.class) //
+})
+public class ClassHierarchyWithMergedConfigLevelOneTests {
+
+	@Configuration
+	static class AppConfig {
+
+		@Bean
+		public String parent() {
+			return "parent";
+		}
+	}
+
+	@Configuration
+	static class UserConfig {
+
+		@Autowired
+		private AppConfig appConfig;
+
+
+		@Bean
+		public String user() {
+			return appConfig.parent() + " + user";
+		}
+
+		@Bean
+		public String beanFromUserConfig() {
+			return "from UserConfig";
+		}
+	}
+
+
+	@Autowired
+	protected String parent;
+
+	@Autowired
+	protected String user;
+
+	@Autowired(required = false)
+	@Qualifier("beanFromUserConfig")
+	protected String beanFromUserConfig;
+
+	@Autowired
+	protected ApplicationContext context;
+
+
+	@Test
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertNull("grandparent ApplicationContext", context.getParent().getParent());
+		assertEquals("parent", parent);
+		assertEquals("parent + user", user);
+		assertEquals("from UserConfig", beanFromUserConfig);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithMergedConfigLevelTwoTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithMergedConfigLevelTwoTests.java
new file mode 100644
index 000000000000..42a63413d2be
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithMergedConfigLevelTwoTests.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy(@ContextConfiguration(name = "child", classes = ClassHierarchyWithMergedConfigLevelTwoTests.OrderConfig.class))
+public class ClassHierarchyWithMergedConfigLevelTwoTests extends ClassHierarchyWithMergedConfigLevelOneTests {
+
+	@Configuration
+	static class OrderConfig {
+
+		@Autowired
+		private ClassHierarchyWithMergedConfigLevelOneTests.UserConfig userConfig;
+
+		@Bean
+		public String order() {
+			return userConfig.user() + " + order";
+		}
+	}
+
+
+	@Autowired
+	private String order;
+
+
+	@Test
+	@Override
+	public void loadContextHierarchy() {
+		super.loadContextHierarchy();
+		assertEquals("parent + user + order", order);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithOverriddenConfigLevelTwoTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithOverriddenConfigLevelTwoTests.java
new file mode 100644
index 000000000000..1f5f69a02904
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/ClassHierarchyWithOverriddenConfigLevelTwoTests.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy(@ContextConfiguration(name = "child", classes = ClassHierarchyWithOverriddenConfigLevelTwoTests.TestUserConfig.class, inheritLocations = false))
+public class ClassHierarchyWithOverriddenConfigLevelTwoTests extends ClassHierarchyWithMergedConfigLevelOneTests {
+
+	@Configuration
+	static class TestUserConfig {
+
+		@Autowired
+		private ClassHierarchyWithMergedConfigLevelOneTests.AppConfig appConfig;
+
+
+		@Bean
+		public String user() {
+			return appConfig.parent() + " + test user";
+		}
+
+		@Bean
+		public String beanFromTestUserConfig() {
+			return "from TestUserConfig";
+		}
+	}
+
+
+	@Autowired
+	private String beanFromTestUserConfig;
+
+
+	@Test
+	@Override
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertNull("grandparent ApplicationContext", context.getParent().getParent());
+		assertEquals("parent", parent);
+		assertEquals("parent + test user", user);
+		assertEquals("from TestUserConfig", beanFromTestUserConfig);
+		assertNull("Bean from UserConfig should not be present.", beanFromUserConfig);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/DirtiesContextWithContextHierarchyTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/DirtiesContextWithContextHierarchyTests.java
new file mode 100644
index 000000000000..95757b2cd790
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/DirtiesContextWithContextHierarchyTests.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import org.junit.Before;
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.MethodSorters;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.annotation.DirtiesContext;
+import org.springframework.test.annotation.DirtiesContext.HierarchyMode;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+import static org.junit.Assert.*;
+
+/**
+ * Integration tests that verify support for {@link DirtiesContext.HierarchyMode}
+ * in conjunction with context hierarchies configured via {@link ContextHierarchy}.
+ *
+ * <p>Note that correct method execution order is essential, thus the use of
+ * {@link FixMethodOrder}.
+ * 
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy({ @ContextConfiguration(classes = DirtiesContextWithContextHierarchyTests.ParentConfig.class),
+	@ContextConfiguration(classes = DirtiesContextWithContextHierarchyTests.ChildConfig.class) })
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
+public class DirtiesContextWithContextHierarchyTests {
+
+	@Configuration
+	static class ParentConfig {
+
+		@Bean
+		public StringBuffer foo() {
+			return new StringBuffer("foo");
+		}
+
+		@Bean
+		public StringBuffer baz() {
+			return new StringBuffer("baz-parent");
+		}
+	}
+
+	@Configuration
+	static class ChildConfig {
+
+		@Bean
+		public StringBuffer baz() {
+			return new StringBuffer("baz-child");
+		}
+	}
+
+
+	@Autowired
+	private StringBuffer foo;
+
+	@Autowired
+	private StringBuffer baz;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	// -------------------------------------------------------------------------
+
+	private void reverseStringBuffers() {
+		foo.reverse();
+		baz.reverse();
+	}
+
+	private void assertOriginalState() {
+		assertCleanParentContext();
+		assertCleanChildContext();
+	}
+
+	private void assertCleanParentContext() {
+		assertEquals("foo", foo.toString());
+	}
+
+	private void assertCleanChildContext() {
+		assertEquals("baz-child", baz.toString());
+	}
+
+	private void assertDirtyParentContext() {
+		assertEquals("oof", foo.toString());
+	}
+
+	private void assertDirtyChildContext() {
+		assertEquals("dlihc-zab", baz.toString());
+	}
+
+	// -------------------------------------------------------------------------
+
+	@Before
+	public void verifyContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertNull("grandparent ApplicationContext", context.getParent().getParent());
+	}
+
+	@Test
+	public void test1_verifyOriginalStateAndDirtyContexts() {
+		assertOriginalState();
+		reverseStringBuffers();
+	}
+
+	@Test
+	@DirtiesContext
+	public void test2_verifyContextsWereDirtiedAndTriggerExhaustiveCacheClearing() {
+		assertDirtyParentContext();
+		assertDirtyChildContext();
+	}
+
+	@Test
+	@DirtiesContext(hierarchyMode = HierarchyMode.CURRENT_LEVEL)
+	public void test3_verifyOriginalStateWasReinstatedAndDirtyContextsAndTriggerCurrentLevelCacheClearing() {
+		assertOriginalState();
+		reverseStringBuffers();
+	}
+
+	@Test
+	public void test4_verifyParentContextIsStillDirtyButChildContextHasBeenReinstated() {
+		assertDirtyParentContext();
+		assertCleanChildContext();
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithSingleLevelContextHierarchyTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithSingleLevelContextHierarchyTests.java
new file mode 100644
index 000000000000..b111f1527054
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithSingleLevelContextHierarchyTests.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy(@ContextConfiguration)
+public class SingleTestClassWithSingleLevelContextHierarchyTests {
+
+	@Configuration
+	static class Config {
+
+		@Bean
+		public String foo() {
+			return "foo";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNull("parent ApplicationContext", context.getParent());
+		assertEquals("foo", foo);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests.java
new file mode 100644
index 000000000000..5591b915b435
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy({
+	@ContextConfiguration(classes = SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests.ParentConfig.class),
+	@ContextConfiguration("SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests-ChildConfig.xml") })
+public class SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests {
+
+	@Configuration
+	static class ParentConfig {
+
+		@Bean
+		public String foo() {
+			return "foo";
+		}
+
+		@Bean
+		public String baz() {
+			return "baz-parent";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private String baz;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertNull("grandparent ApplicationContext", context.getParent().getParent());
+		assertEquals("foo", foo);
+		assertEquals("bar", bar);
+		assertEquals("baz-child", baz);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyTests.java
new file mode 100644
index 000000000000..0333e5fb2d3f
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyTests.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy({
+	@ContextConfiguration(classes = SingleTestClassWithTwoLevelContextHierarchyTests.ParentConfig.class),
+	@ContextConfiguration(classes = SingleTestClassWithTwoLevelContextHierarchyTests.ChildConfig.class) })
+public class SingleTestClassWithTwoLevelContextHierarchyTests {
+
+	@Configuration
+	static class ParentConfig {
+
+		@Bean
+		public String foo() {
+			return "foo";
+		}
+
+		@Bean
+		public String baz() {
+			return "baz-parent";
+		}
+	}
+
+	@Configuration
+	static class ChildConfig {
+
+		@Bean
+		public String bar() {
+			return "bar";
+		}
+
+		@Bean
+		public String baz() {
+			return "baz-child";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private String baz;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertNull("grandparent ApplicationContext", context.getParent().getParent());
+		assertEquals("foo", foo);
+		assertEquals("bar", bar);
+		assertEquals("baz-child", baz);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithBareContextConfigurationInSubclassTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithBareContextConfigurationInSubclassTests.java
new file mode 100644
index 000000000000..3dbf5794759f
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithBareContextConfigurationInSubclassTests.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy(@ContextConfiguration)
+public class TestHierarchyLevelOneWithBareContextConfigurationInSubclassTests {
+
+	@Configuration
+	static class Config {
+
+		@Bean
+		public String foo() {
+			return "foo-level-1";
+		}
+
+		@Bean
+		public String bar() {
+			return "bar";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNull("parent ApplicationContext", context.getParent());
+		assertEquals("foo-level-1", foo);
+		assertEquals("bar", bar);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithBareContextConfigurationInSuperclassTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithBareContextConfigurationInSuperclassTests.java
new file mode 100644
index 000000000000..16b04c7f180c
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithBareContextConfigurationInSuperclassTests.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextConfiguration
+public class TestHierarchyLevelOneWithBareContextConfigurationInSuperclassTests {
+
+	@Configuration
+	static class Config {
+
+		@Bean
+		public String foo() {
+			return "foo-level-1";
+		}
+
+		@Bean
+		public String bar() {
+			return "bar";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNull("parent ApplicationContext", context.getParent());
+		assertEquals("foo-level-1", foo);
+		assertEquals("bar", bar);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithSingleLevelContextHierarchyTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithSingleLevelContextHierarchyTests.java
new file mode 100644
index 000000000000..3e91f375d9b0
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelOneWithSingleLevelContextHierarchyTests.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy(@ContextConfiguration)
+public class TestHierarchyLevelOneWithSingleLevelContextHierarchyTests {
+
+	@Configuration
+	static class Config {
+
+		@Bean
+		public String foo() {
+			return "foo-level-1";
+		}
+
+		@Bean
+		public String bar() {
+			return "bar";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNull("parent ApplicationContext", context.getParent());
+		assertEquals("foo-level-1", foo);
+		assertEquals("bar", bar);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithBareContextConfigurationInSubclassTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithBareContextConfigurationInSubclassTests.java
new file mode 100644
index 000000000000..2054f450b93f
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithBareContextConfigurationInSubclassTests.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextConfiguration
+public class TestHierarchyLevelTwoWithBareContextConfigurationInSubclassTests extends
+		TestHierarchyLevelOneWithBareContextConfigurationInSubclassTests {
+
+	@Configuration
+	static class Config {
+
+		@Bean
+		public String foo() {
+			return "foo-level-2";
+		}
+
+		@Bean
+		public String baz() {
+			return "baz";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private String baz;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	@Override
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertNull("grandparent ApplicationContext", context.getParent().getParent());
+		assertEquals("foo-level-2", foo);
+		assertEquals("bar", bar);
+		assertEquals("baz", baz);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithBareContextConfigurationInSuperclassTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithBareContextConfigurationInSuperclassTests.java
new file mode 100644
index 000000000000..bc38d2bb400a
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithBareContextConfigurationInSuperclassTests.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy(@ContextConfiguration)
+public class TestHierarchyLevelTwoWithBareContextConfigurationInSuperclassTests extends
+		TestHierarchyLevelOneWithBareContextConfigurationInSuperclassTests {
+
+	@Configuration
+	static class Config {
+
+		@Bean
+		public String foo() {
+			return "foo-level-2";
+		}
+
+		@Bean
+		public String baz() {
+			return "baz";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private String baz;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	@Override
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertNull("grandparent ApplicationContext", context.getParent().getParent());
+		assertEquals("foo-level-2", foo);
+		assertEquals("bar", bar);
+		assertEquals("baz", baz);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyAndMixedConfigTypesTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyAndMixedConfigTypesTests.java
new file mode 100644
index 000000000000..c6edd3af8b66
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyAndMixedConfigTypesTests.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy(@ContextConfiguration)
+public class TestHierarchyLevelTwoWithSingleLevelContextHierarchyAndMixedConfigTypesTests extends
+		TestHierarchyLevelOneWithSingleLevelContextHierarchyTests {
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private String baz;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	@Override
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertNull("grandparent ApplicationContext", context.getParent().getParent());
+		assertEquals("foo-level-2", foo);
+		assertEquals("bar", bar);
+		assertEquals("baz", baz);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyTests.java
new file mode 100644
index 000000000000..edc8fb339601
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyTests.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.standard;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy(@ContextConfiguration)
+public class TestHierarchyLevelTwoWithSingleLevelContextHierarchyTests extends
+		TestHierarchyLevelOneWithSingleLevelContextHierarchyTests {
+
+	@Configuration
+	static class Config {
+
+		@Bean
+		public String foo() {
+			return "foo-level-2";
+		}
+
+		@Bean
+		public String baz() {
+			return "baz";
+		}
+	}
+
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+	@Autowired
+	private String baz;
+
+	@Autowired
+	private ApplicationContext context;
+
+
+	@Test
+	@Override
+	public void loadContextHierarchy() {
+		assertNotNull("child ApplicationContext", context);
+		assertNotNull("parent ApplicationContext", context.getParent());
+		assertEquals("foo-level-2", foo);
+		assertEquals("bar", bar);
+		assertEquals("baz", baz);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/ControllerIntegrationTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/ControllerIntegrationTests.java
new file mode 100644
index 000000000000..a6282218f2b9
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/ControllerIntegrationTests.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.web;
+
+import javax.servlet.ServletContext;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.hierarchies.web.ControllerIntegrationTests.AppConfig;
+import org.springframework.test.context.hierarchies.web.ControllerIntegrationTests.WebConfig;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+import org.springframework.test.context.web.WebAppConfiguration;
+import org.springframework.web.context.WebApplicationContext;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@WebAppConfiguration
+@ContextHierarchy({
+	//
+	@ContextConfiguration(name = "root", classes = AppConfig.class),
+	@ContextConfiguration(name = "dispatcher", classes = WebConfig.class) //
+})
+public class ControllerIntegrationTests {
+
+	@Configuration
+	static class AppConfig {
+
+		@Bean
+		public String foo() {
+			return "foo";
+		}
+	}
+
+	@Configuration
+	static class WebConfig {
+
+		@Bean
+		public String bar() {
+			return "bar";
+		}
+	}
+
+
+	// -------------------------------------------------------------------------
+
+	@Autowired
+	private WebApplicationContext wac;
+
+	@Autowired
+	private String foo;
+
+	@Autowired
+	private String bar;
+
+
+	@Test
+	public void verifyRootWacSupport() {
+		assertEquals("foo", foo);
+		assertEquals("bar", bar);
+
+		ApplicationContext parent = wac.getParent();
+		assertNotNull(parent);
+		assertTrue(parent instanceof WebApplicationContext);
+		WebApplicationContext root = (WebApplicationContext) parent;
+		assertFalse(root.getBeansOfType(String.class).containsKey("bar"));
+
+		ServletContext childServletContext = wac.getServletContext();
+		assertNotNull(childServletContext);
+		ServletContext rootServletContext = root.getServletContext();
+		assertNotNull(rootServletContext);
+		assertSame(childServletContext, rootServletContext);
+
+		assertSame(root, rootServletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE));
+		assertSame(root, childServletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE));
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/DispatcherWacRootWacEarTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/DispatcherWacRootWacEarTests.java
new file mode 100644
index 000000000000..622547c48b85
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/DispatcherWacRootWacEarTests.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.web;
+
+import javax.servlet.ServletContext;
+
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.web.context.WebApplicationContext;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@ContextHierarchy(@ContextConfiguration)
+public class DispatcherWacRootWacEarTests extends RootWacEarTests {
+
+	@Autowired
+	private WebApplicationContext wac;
+
+	@Autowired
+	private String ear;
+
+	@Autowired
+	private String root;
+
+	@Autowired
+	private String dispatcher;
+
+
+	@Test
+	@Override
+	public void verifyEarConfig() {
+		/* no-op */
+	}
+
+	@Test
+	@Override
+	public void verifyRootWacConfig() {
+		/* no-op */
+	}
+
+	@Test
+	public void verifyDispatcherWacConfig() {
+		ApplicationContext parent = wac.getParent();
+		assertNotNull(parent);
+		assertTrue(parent instanceof WebApplicationContext);
+
+		ApplicationContext grandParent = parent.getParent();
+		assertNotNull(grandParent);
+		assertFalse(grandParent instanceof WebApplicationContext);
+
+		ServletContext dispatcherServletContext = wac.getServletContext();
+		assertNotNull(dispatcherServletContext);
+		ServletContext rootServletContext = ((WebApplicationContext) parent).getServletContext();
+		assertNotNull(rootServletContext);
+		assertSame(dispatcherServletContext, rootServletContext);
+
+		assertSame(parent,
+			rootServletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE));
+		assertSame(parent,
+			dispatcherServletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE));
+
+		assertEquals("ear", ear);
+		assertEquals("root", root);
+		assertEquals("dispatcher", dispatcher);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/EarTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/EarTests.java
new file mode 100644
index 000000000000..8cd7eaf1b4ee
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/EarTests.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.web;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
+import org.springframework.web.context.WebApplicationContext;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@RunWith(SpringJUnit4ClassRunner.class)
+@ContextConfiguration
+public class EarTests {
+
+	@Configuration
+	static class EarConfig {
+
+		@Bean
+		public String ear() {
+			return "ear";
+		}
+	}
+
+
+	// -------------------------------------------------------------------------
+
+	@Autowired
+	private ApplicationContext context;
+
+	@Autowired
+	private String ear;
+
+
+	@Test
+	public void verifyEarConfig() {
+		assertFalse(context instanceof WebApplicationContext);
+		assertNull(context.getParent());
+		assertEquals("ear", ear);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/RootWacEarTests.java b/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/RootWacEarTests.java
new file mode 100644
index 000000000000..dbd3e93aa859
--- /dev/null
+++ b/spring-test/src/test/java/org/springframework/test/context/hierarchies/web/RootWacEarTests.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.test.context.hierarchies.web;
+
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.ContextHierarchy;
+import org.springframework.test.context.web.WebAppConfiguration;
+import org.springframework.web.context.WebApplicationContext;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Sam Brannen
+ * @since 3.2.2
+ */
+@WebAppConfiguration
+@ContextHierarchy(@ContextConfiguration)
+public class RootWacEarTests extends EarTests {
+
+	@Configuration
+	static class RootWacConfig {
+
+		@Bean
+		public String root() {
+			return "root";
+		}
+	}
+
+
+	// -------------------------------------------------------------------------
+
+	@Autowired
+	private WebApplicationContext wac;
+
+	@Autowired
+	private String ear;
+
+	@Autowired
+	private String root;
+
+
+	@Test
+	@Override
+	public void verifyEarConfig() {
+		/* no-op */
+	}
+
+	@Test
+	public void verifyRootWacConfig() {
+		ApplicationContext parent = wac.getParent();
+		assertNotNull(parent);
+		assertFalse(parent instanceof WebApplicationContext);
+		assertEquals("ear", ear);
+		assertEquals("root", root);
+	}
+
+}
diff --git a/spring-test/src/test/java/org/springframework/test/context/junit4/PropertiesBasedSpringJUnit4ClassRunnerAppCtxTests.java b/spring-test/src/test/java/org/springframework/test/context/junit4/PropertiesBasedSpringJUnit4ClassRunnerAppCtxTests.java
index b5d74839f685..fd82c559b673 100644
--- a/spring-test/src/test/java/org/springframework/test/context/junit4/PropertiesBasedSpringJUnit4ClassRunnerAppCtxTests.java
+++ b/spring-test/src/test/java/org/springframework/test/context/junit4/PropertiesBasedSpringJUnit4ClassRunnerAppCtxTests.java
@@ -33,21 +33,21 @@
 /**
  * <p>
  * JUnit 4 based test class, which verifies the expected functionality of
- * {@link SpringJUnit4ClassRunner} in conjunction with support for application
- * contexts loaded from Java {@link Properties} files. Specifically, the
- * {@link ContextConfiguration#loader() loaderClass} and
- * {@link ContextConfiguration#resourceSuffix() resourceSuffix} attributes of
- * &#064;ContextConfiguration are tested.
+ * {@link SpringJUnit4ClassRunner} in conjunction with support for application contexts
+ * loaded from Java {@link Properties} files. Specifically, the
+ * {@link ContextConfiguration#loader() loader} attribute of {@code ContextConfiguration}
+ * and the
+ * {@link org.springframework.test.context.support.GenericPropertiesContextLoader#getResourceSuffix()
+ * resourceSuffix} property of {@code GenericPropertiesContextLoader} are tested.
  * </p>
  * <p>
- * Since no {@link ContextConfiguration#locations() locations} are explicitly
- * defined, the {@link ContextConfiguration#resourceSuffix() resourceSuffix} is
- * set to &quot;-context.properties&quot;, and
- * {@link ContextConfiguration#generateDefaultLocations() generateDefaultLocations}
- * is left set to its default value of {@code true}, this test class's
- * dependencies will be injected via
- * {@link Autowired annotation-based autowiring} from beans defined in the
- * {@link ApplicationContext} loaded from the default classpath resource: &quot;{@code /org/springframework/test/junit4/PropertiesBasedSpringJUnit4ClassRunnerAppCtxTests-context.properties}&quot;.
+ * Since no {@link ContextConfiguration#locations() locations} are explicitly defined, the
+ * {@code resourceSuffix} is set to &quot;-context.properties&quot;, and since default
+ * resource locations will be detected by default, this test class's dependencies will be
+ * injected via {@link Autowired annotation-based autowiring} from beans defined in the
+ * {@link ApplicationContext} loaded from the default classpath resource: &quot;
+ * {@code /org/springframework/test/junit4/PropertiesBasedSpringJUnit4ClassRunnerAppCtxTests-context.properties}
+ * &quot;.
  * </p>
  *
  * @author Sam Brannen
diff --git a/spring-test/src/test/java/org/springframework/test/context/junit4/spr8849/Spr8849Tests.java b/spring-test/src/test/java/org/springframework/test/context/junit4/spr8849/Spr8849Tests.java
index fa0412abc1b0..dd589867177c 100644
--- a/spring-test/src/test/java/org/springframework/test/context/junit4/spr8849/Spr8849Tests.java
+++ b/spring-test/src/test/java/org/springframework/test/context/junit4/spr8849/Spr8849Tests.java
@@ -38,6 +38,7 @@
  * @author Sam Brannen
  * @since 3.2
  */
+@SuppressWarnings("javadoc")
 @RunWith(Suite.class)
 @SuiteClasses({ TestClass1.class, TestClass2.class })
 public class Spr8849Tests {
diff --git a/spring-test/src/test/java/org/springframework/test/context/junit4/spr9051/AbstractTransactionalAnnotatedConfigClassTests.java b/spring-test/src/test/java/org/springframework/test/context/junit4/spr9051/AbstractTransactionalAnnotatedConfigClassTests.java
index 54b55c8c440e..59cef2c1dbe0 100644
--- a/spring-test/src/test/java/org/springframework/test/context/junit4/spr9051/AbstractTransactionalAnnotatedConfigClassTests.java
+++ b/spring-test/src/test/java/org/springframework/test/context/junit4/spr9051/AbstractTransactionalAnnotatedConfigClassTests.java
@@ -76,7 +76,7 @@ public void setDataSource(DataSource dataSource) {
 	}
 
 	private int countRowsInTable(String tableName) {
-		return jdbcTemplate.queryForInt("SELECT COUNT(0) FROM " + tableName);
+		return jdbcTemplate.queryForObject("SELECT COUNT(0) FROM " + tableName, Integer.class);
 	}
 
 	private int createPerson(String name) {
diff --git a/spring-test/src/test/java/org/springframework/test/context/testng/AnnotationConfigTransactionalTestNGSpringContextTests.java b/spring-test/src/test/java/org/springframework/test/context/testng/AnnotationConfigTransactionalTestNGSpringContextTests.java
index f20e466410f9..66ffc2026c50 100644
--- a/spring-test/src/test/java/org/springframework/test/context/testng/AnnotationConfigTransactionalTestNGSpringContextTests.java
+++ b/spring-test/src/test/java/org/springframework/test/context/testng/AnnotationConfigTransactionalTestNGSpringContextTests.java
@@ -43,10 +43,11 @@
 
 /**
  * Integration tests that verify support for
- * {@link import org.springframework.context.annotation.Configuration @Configuration}
- * classes with TestNG-based tests.
+ * {@link org.springframework.context.annotation.Configuration @Configuration} classes
+ * with TestNG-based tests.
  *
- * <p>Configuration will be loaded from
+ * <p>
+ * Configuration will be loaded from
  * {@link AnnotationConfigTransactionalTestNGSpringContextTests.ContextConfiguration}.
  *
  * @author Sam Brannen
diff --git a/spring-test/src/test/java/org/springframework/test/jdbc/JdbcTestUtilsTests.java b/spring-test/src/test/java/org/springframework/test/jdbc/JdbcTestUtilsTests.java
index d5fd1b68e4b7..6ebdf918192b 100644
--- a/spring-test/src/test/java/org/springframework/test/jdbc/JdbcTestUtilsTests.java
+++ b/spring-test/src/test/java/org/springframework/test/jdbc/JdbcTestUtilsTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,25 +16,38 @@
 
 package org.springframework.test.jdbc;
 
-import static org.junit.Assert.*;
+import static org.hamcrest.Matchers.equalTo;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.BDDMockito.given;
 
 import java.io.LineNumberReader;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.runners.MockitoJUnitRunner;
 import org.springframework.core.io.ClassPathResource;
 import org.springframework.core.io.support.EncodedResource;
+import org.springframework.jdbc.core.JdbcTemplate;
 
 /**
  * Unit tests for {@link JdbcTestUtils}.
  *
  * @author Thomas Risberg
  * @author Sam Brannen
+ * @author Phillip Webb
  * @since 2.5.4
  */
+@RunWith(MockitoJUnitRunner.class)
 public class JdbcTestUtilsTests {
 
+	@Mock
+	private JdbcTemplate jdbcTemplate;
+
 	@Test
 	public void containsDelimiters() {
 		assertTrue("test with ';' is wrong", !JdbcTestUtils.containsSqlScriptDelimiters("select 1\n select ';'", ';'));
@@ -104,4 +117,26 @@ public void readAndSplitScriptContainingComments() throws Exception {
 		assertEquals("statement 4 not split correctly", statement4, statements.get(3));
 	}
 
+	@Test
+	public void testDeleteNoWhere() throws Exception {
+		given(jdbcTemplate.update("DELETE FROM person")).willReturn(10);
+		int deleted = JdbcTestUtils.deleteFromTableWhere(jdbcTemplate, "person", null);
+		assertThat(deleted, equalTo(10));
+	}
+
+	@Test
+	public void testDeleteWhere() throws Exception {
+		given(jdbcTemplate.update("DELETE FROM person WHERE name = 'Bob' and age > 25")).willReturn(10);
+		int deleted = JdbcTestUtils.deleteFromTableWhere(jdbcTemplate, "person", "name = 'Bob' and age > 25");
+		assertThat(deleted, equalTo(10));
+	}
+
+	@Test
+	public void deleteWhereAndArguments() throws Exception {
+		given(jdbcTemplate.update("DELETE FROM person WHERE name = ? and age > ?", "Bob", 25)).willReturn(10);
+		int deleted = JdbcTestUtils.deleteFromTableWhere(jdbcTemplate, "person", "name = ? and age > ?", "Bob", 25);
+		assertThat(deleted, equalTo(10));
+	}
+
+
 }
diff --git a/spring-test/src/test/resources/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests-ChildConfig.xml b/spring-test/src/test/resources/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests-ChildConfig.xml
new file mode 100644
index 000000000000..2189b42feee5
--- /dev/null
+++ b/spring-test/src/test/resources/org/springframework/test/context/hierarchies/standard/SingleTestClassWithTwoLevelContextHierarchyAndMixedConfigTypesTests-ChildConfig.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
+
+	<bean id="bar" class="java.lang.String" c:_="bar" />
+
+	<bean id="baz" class="java.lang.String" c:_="baz-child" />
+
+</beans>
diff --git a/spring-test/src/test/resources/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyAndMixedConfigTypesTests-context.xml b/spring-test/src/test/resources/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyAndMixedConfigTypesTests-context.xml
new file mode 100644
index 000000000000..3abc44bda6a3
--- /dev/null
+++ b/spring-test/src/test/resources/org/springframework/test/context/hierarchies/standard/TestHierarchyLevelTwoWithSingleLevelContextHierarchyAndMixedConfigTypesTests-context.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
+
+	<bean id="foo" class="java.lang.String" c:_="foo-level-2" />
+
+	<bean id="baz" class="java.lang.String" c:_="baz" />
+
+</beans>
diff --git a/spring-test/src/test/resources/org/springframework/test/context/hierarchies/web/DispatcherWacRootWacEarTests-context.xml b/spring-test/src/test/resources/org/springframework/test/context/hierarchies/web/DispatcherWacRootWacEarTests-context.xml
new file mode 100644
index 000000000000..496fc0b08e4b
--- /dev/null
+++ b/spring-test/src/test/resources/org/springframework/test/context/hierarchies/web/DispatcherWacRootWacEarTests-context.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
+
+	<bean id="dispatcher" class="java.lang.String" c:_="dispatcher" />
+
+</beans>
diff --git a/spring-tx/src/main/java/org/springframework/jca/endpoint/GenericMessageEndpointFactory.java b/spring-tx/src/main/java/org/springframework/jca/endpoint/GenericMessageEndpointFactory.java
index fac5eba990cd..61f8db5b4e4a 100644
--- a/spring-tx/src/main/java/org/springframework/jca/endpoint/GenericMessageEndpointFactory.java
+++ b/spring-tx/src/main/java/org/springframework/jca/endpoint/GenericMessageEndpointFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -141,11 +141,11 @@ protected ClassLoader getEndpointClassLoader() {
 
 
 	/**
-	 * Internal exception thrown when a ResourceExeption has been encountered
+	 * Internal exception thrown when a ResourceException has been encountered
 	 * during the endpoint invocation.
 	 * <p>Will only be used if the ResourceAdapter does not invoke the
 	 * endpoint's {@code beforeDelivery} and {@code afterDelivery}
-	 * directly, leavng it up to the concrete endpoint to apply those -
+	 * directly, leaving it up to the concrete endpoint to apply those -
 	 * and to handle any ResourceExceptions thrown from them.
 	 */
 	@SuppressWarnings("serial")
diff --git a/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java b/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java
index 9f9b9503ddf2..bcd2c7788054 100644
--- a/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java
+++ b/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java
@@ -16,12 +16,8 @@
 
 package org.springframework.transaction.interceptor;
 
-import java.lang.reflect.Method;
-import java.util.Properties;
-
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.beans.factory.BeanFactoryAware;
 import org.springframework.beans.factory.InitializingBean;
@@ -31,8 +27,13 @@
 import org.springframework.transaction.PlatformTransactionManager;
 import org.springframework.transaction.TransactionStatus;
 import org.springframework.transaction.TransactionSystemException;
+import org.springframework.transaction.support.CallbackPreferringPlatformTransactionManager;
+import org.springframework.transaction.support.TransactionCallback;
 import org.springframework.util.StringUtils;
 
+import java.lang.reflect.Method;
+import java.util.Properties;
+
 /**
  * Base class for transactional aspects, such as the {@link TransactionInterceptor}
  * or an AspectJ aspect.
@@ -231,6 +232,90 @@ public void afterPropertiesSet() {
 	}
 
 
+	/**
+	 * General delegate for around-advice-based subclasses, delegating to several other template
+	 * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}
+	 * as well as regular {@link PlatformTransactionManager} implementations.
+	 * @param method the Method being invoked
+	 * @param targetClass the target class that we're invoking the method on
+	 * @param invocation the callback to use for proceeding with the target invocation
+	 * @return the return value of the method, if any
+	 * @throws Throwable propagated from the target invocation
+	 */
+	protected Object invokeWithinTransaction(Method method, Class targetClass, final InvocationCallback invocation)
+			throws Throwable {
+
+		// If the transaction attribute is null, the method is non-transactional.
+		final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);
+		final PlatformTransactionManager tm = determineTransactionManager(txAttr);
+		final String joinpointIdentification = methodIdentification(method, targetClass);
+
+		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
+			// Standard transaction demarcation with getTransaction and commit/rollback calls.
+			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
+			Object retVal = null;
+			try {
+				// This is an around advice: Invoke the next interceptor in the chain.
+				// This will normally result in a target object being invoked.
+				retVal = invocation.proceedWithInvocation();
+			}
+			catch (Throwable ex) {
+				// target invocation exception
+				completeTransactionAfterThrowing(txInfo, ex);
+				throw ex;
+			}
+			finally {
+				cleanupTransactionInfo(txInfo);
+			}
+			commitTransactionAfterReturning(txInfo);
+			return retVal;
+		}
+
+		else {
+			// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
+			try {
+				Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,
+						new TransactionCallback<Object>() {
+							public Object doInTransaction(TransactionStatus status) {
+								TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
+								try {
+									return invocation.proceedWithInvocation();
+								}
+								catch (Throwable ex) {
+									if (txAttr.rollbackOn(ex)) {
+										// A RuntimeException: will lead to a rollback.
+										if (ex instanceof RuntimeException) {
+											throw (RuntimeException) ex;
+										}
+										else {
+											throw new ThrowableHolderException(ex);
+										}
+									}
+									else {
+										// A normal return value: will lead to a commit.
+										return new ThrowableHolder(ex);
+									}
+								}
+								finally {
+									cleanupTransactionInfo(txInfo);
+								}
+							}
+						});
+
+				// Check result: It might indicate a Throwable to rethrow.
+				if (result instanceof ThrowableHolder) {
+					throw ((ThrowableHolder) result).getThrowable();
+				}
+				else {
+					return result;
+				}
+			}
+			catch (ThrowableHolderException ex) {
+				throw ex.getCause();
+			}
+		}
+	}
+
 	/**
 	 * Determine the specific transaction manager to use for the given transaction.
 	 */
@@ -250,23 +335,6 @@ else if (this.transactionManagerBeanName != null) {
 		}
 	}
 
-	/**
-	 * Create a transaction if necessary, based on the given method and class.
-	 * <p>Performs a default TransactionAttribute lookup for the given method.
-	 * @param method the method about to execute
-	 * @param targetClass the class that the method is being invoked on
-	 * @return a TransactionInfo object, whether or not a transaction was created.
-	 * The {@code hasTransaction()} method on TransactionInfo can be used to
-	 * tell if there was a transaction created.
-	 * @see #getTransactionAttributeSource()
-	 */
-	protected TransactionInfo createTransactionIfNecessary(Method method, Class targetClass) {
-		// If the transaction attribute is null, the method is non-transactional.
-		TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);
-		PlatformTransactionManager tm = determineTransactionManager(txAttr);
-		return createTransactionIfNecessary(tm, txAttr, methodIdentification(method, targetClass));
-	}
-
 	/**
 	 * Convenience method to return a String representation of this Method
 	 * for use in logging. Can be overridden in subclasses to provide a
@@ -297,6 +365,26 @@ protected String methodIdentification(Method method) {
 		return null;
 	}
 
+	/**
+	 * Create a transaction if necessary, based on the given method and class.
+	 * <p>Performs a default TransactionAttribute lookup for the given method.
+	 * @param method the method about to execute
+	 * @param targetClass the class that the method is being invoked on
+	 * @return a TransactionInfo object, whether or not a transaction was created.
+	 * The {@code hasTransaction()} method on TransactionInfo can be used to
+	 * tell if there was a transaction created.
+	 * @see #getTransactionAttributeSource()
+	 * @deprecated in favor of
+	 * {@link #createTransactionIfNecessary(PlatformTransactionManager, TransactionAttribute, String)}
+	 */
+	@Deprecated
+	protected TransactionInfo createTransactionIfNecessary(Method method, Class targetClass) {
+		// If the transaction attribute is null, the method is non-transactional.
+		TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);
+		PlatformTransactionManager tm = determineTransactionManager(txAttr);
+		return createTransactionIfNecessary(tm, txAttr, methodIdentification(method, targetClass));
+	}
+
 	/**
 	 * Create a transaction if necessary based on the given TransactionAttribute.
 	 * <p>Allows callers to perform custom TransactionAttribute lookups through
@@ -527,4 +615,50 @@ public String toString() {
 		}
 	}
 
+
+	/**
+	 * Simple callback interface for proceeding with the target invocation.
+	 * Concrete interceptors/aspects adapt this to their invocation mechanism.
+	 */
+	protected interface InvocationCallback {
+
+		Object proceedWithInvocation() throws Throwable;
+	}
+
+
+	/**
+	 * Internal holder class for a Throwable, used as a return value
+	 * from a TransactionCallback (to be subsequently unwrapped again).
+	 */
+	private static class ThrowableHolder {
+
+		private final Throwable throwable;
+
+		public ThrowableHolder(Throwable throwable) {
+			this.throwable = throwable;
+		}
+
+		public final Throwable getThrowable() {
+			return this.throwable;
+		}
+	}
+
+
+	/**
+	 * Internal holder class for a Throwable, used as a RuntimeException to be
+	 * thrown from a TransactionCallback (and subsequently unwrapped again).
+	 */
+	@SuppressWarnings("serial")
+	private static class ThrowableHolderException extends RuntimeException {
+
+		public ThrowableHolderException(Throwable throwable) {
+			super(throwable);
+		}
+
+		@Override
+		public String toString() {
+			return getCause().toString();
+		}
+	}
+
 }
diff --git a/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionInterceptor.java b/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionInterceptor.java
index 11f72759a7f6..db46387077c3 100644
--- a/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionInterceptor.java
+++ b/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionInterceptor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,21 +16,17 @@
 
 package org.springframework.transaction.interceptor;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.util.Properties;
-
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
-
 import org.springframework.aop.support.AopUtils;
 import org.springframework.beans.factory.BeanFactory;
 import org.springframework.transaction.PlatformTransactionManager;
-import org.springframework.transaction.TransactionStatus;
-import org.springframework.transaction.support.CallbackPreferringPlatformTransactionManager;
-import org.springframework.transaction.support.TransactionCallback;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.Properties;
 
 /**
  * AOP Alliance MethodInterceptor for declarative transaction
@@ -40,7 +36,7 @@
  * <p>Derives from the {@link TransactionAspectSupport} class which
  * contains the integration with Spring's underlying transaction API.
  * TransactionInterceptor simply calls the relevant superclass methods
- * such as {@link #createTransactionIfNecessary} in the correct order.
+ * such as {@link #invokeWithinTransaction} in the correct order.
  *
  * <p>TransactionInterceptors are thread-safe.
  *
@@ -94,76 +90,12 @@ public Object invoke(final MethodInvocation invocation) throws Throwable {
 		// as well as the method, which may be from an interface.
 		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);
 
-		// If the transaction attribute is null, the method is non-transactional.
-		final TransactionAttribute txAttr =
-				getTransactionAttributeSource().getTransactionAttribute(invocation.getMethod(), targetClass);
-		final PlatformTransactionManager tm = determineTransactionManager(txAttr);
-		final String joinpointIdentification = methodIdentification(invocation.getMethod(), targetClass);
-
-		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
-			// Standard transaction demarcation with getTransaction and commit/rollback calls.
-			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
-			Object retVal = null;
-			try {
-				// This is an around advice: Invoke the next interceptor in the chain.
-				// This will normally result in a target object being invoked.
-				retVal = invocation.proceed();
-			}
-			catch (Throwable ex) {
-				// target invocation exception
-				completeTransactionAfterThrowing(txInfo, ex);
-				throw ex;
-			}
-			finally {
-				cleanupTransactionInfo(txInfo);
-			}
-			commitTransactionAfterReturning(txInfo);
-			return retVal;
-		}
-
-		else {
-			// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
-			try {
-				Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,
-						new TransactionCallback<Object>() {
-							public Object doInTransaction(TransactionStatus status) {
-								TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
-								try {
-									return invocation.proceed();
-								}
-								catch (Throwable ex) {
-									if (txAttr.rollbackOn(ex)) {
-										// A RuntimeException: will lead to a rollback.
-										if (ex instanceof RuntimeException) {
-											throw (RuntimeException) ex;
-										}
-										else {
-											throw new ThrowableHolderException(ex);
-										}
-									}
-									else {
-										// A normal return value: will lead to a commit.
-										return new ThrowableHolder(ex);
-									}
-								}
-								finally {
-									cleanupTransactionInfo(txInfo);
-								}
-							}
-						});
-
-				// Check result: It might indicate a Throwable to rethrow.
-				if (result instanceof ThrowableHolder) {
-					throw ((ThrowableHolder) result).getThrowable();
-				}
-				else {
-					return result;
-				}
+		// Adapt to TransactionAspectSupport's invokeWithinTransaction...
+		return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {
+			public Object proceedWithInvocation() throws Throwable {
+				return invocation.proceed();
 			}
-			catch (ThrowableHolderException ex) {
-				throw ex.getCause();
-			}
-		}
+		});
 	}
 
 
@@ -195,39 +127,4 @@ private void readObject(ObjectInputStream ois) throws IOException, ClassNotFound
 		setBeanFactory((BeanFactory) ois.readObject());
 	}
 
-
-	/**
-	 * Internal holder class for a Throwable, used as a return value
-	 * from a TransactionCallback (to be subsequently unwrapped again).
-	 */
-	private static class ThrowableHolder {
-
-		private final Throwable throwable;
-
-		public ThrowableHolder(Throwable throwable) {
-			this.throwable = throwable;
-		}
-
-		public final Throwable getThrowable() {
-			return this.throwable;
-		}
-	}
-
-
-	/**
-	 * Internal holder class for a Throwable, used as a RuntimeException to be
-	 * thrown from a TransactionCallback (and subsequently unwrapped again).
-	 */
-	private static class ThrowableHolderException extends RuntimeException {
-
-		public ThrowableHolderException(Throwable throwable) {
-			super(throwable);
-		}
-
-		@Override
-		public String toString() {
-			return getCause().toString();
-		}
-	}
-
 }
diff --git a/spring-tx/src/test/java/org/springframework/jca/cci/CciLocalTransactionTests.java b/spring-tx/src/test/java/org/springframework/jca/cci/CciLocalTransactionTests.java
index 2038b8ecc074..9a5b2c1243e3 100644
--- a/spring-tx/src/test/java/org/springframework/jca/cci/CciLocalTransactionTests.java
+++ b/spring-tx/src/test/java/org/springframework/jca/cci/CciLocalTransactionTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,6 @@
 
 package org.springframework.jca.cci;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.assertTrue;
-
 import javax.resource.ResourceException;
 import javax.resource.cci.Connection;
 import javax.resource.cci.ConnectionFactory;
@@ -29,6 +26,7 @@
 
 import org.junit.Test;
 import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.jca.cci.connection.CciLocalTransactionManager;
 import org.springframework.jca.cci.core.CciTemplate;
 import org.springframework.transaction.TransactionStatus;
 import org.springframework.transaction.support.TransactionCallback;
@@ -36,6 +34,9 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Thierry Templier
  * @author Chris Beams
@@ -49,34 +50,20 @@ public class CciLocalTransactionTests {
 	 */
 	@Test
 	public void testLocalTransactionCommit() throws ResourceException {
-		final ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		LocalTransaction localTransaction = createMock(LocalTransaction.class);
-		final Record record = createMock(Record.class);
-		final InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.getLocalTransaction()).andReturn(localTransaction);
-
-		localTransaction.begin();
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(interaction.execute(interactionSpec, record, record)).andReturn(true);
-
-		interaction.close();
-
-		expect(connection.getLocalTransaction()).andReturn(localTransaction);
-
-		localTransaction.commit();
-
-		connection.close();
-
-		replay(connectionFactory, connection, localTransaction, interaction, record);
-
-		org.springframework.jca.cci.connection.CciLocalTransactionManager tm = new org.springframework.jca.cci.connection.CciLocalTransactionManager();
+		final ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		LocalTransaction localTransaction = mock(LocalTransaction.class);
+		final Record record = mock(Record.class);
+		final InteractionSpec interactionSpec = mock(InteractionSpec.class);
+
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.getLocalTransaction()).willReturn(localTransaction);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, record, record)).willReturn(true);
+		given(connection.getLocalTransaction()).willReturn(localTransaction);
+
+		CciLocalTransactionManager tm = new CciLocalTransactionManager();
 		tm.setConnectionFactory(connectionFactory);
 		TransactionTemplate tt = new TransactionTemplate(tm);
 
@@ -89,7 +76,10 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 			}
 		});
 
-		verify(connectionFactory, connection, localTransaction, interaction, record);
+		verify(localTransaction).begin();
+		verify(interaction).close();
+		verify(localTransaction).commit();
+		verify(connection).close();
 	}
 
 	/**
@@ -99,34 +89,20 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 	 */
 	@Test
 	public void testLocalTransactionRollback() throws ResourceException {
-		final ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		LocalTransaction localTransaction = createMock(LocalTransaction.class);
-		final Record record = createMock(Record.class);
-		final InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.getLocalTransaction()).andReturn(localTransaction);
-
-		localTransaction.begin();
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(interaction.execute(interactionSpec, record, record)).andReturn(true);
-
-		interaction.close();
-
-		expect(connection.getLocalTransaction()).andReturn(localTransaction);
-
-		localTransaction.rollback();
-
-		connection.close();
-
-		replay(connectionFactory, connection, localTransaction, interaction, record);
-
-		org.springframework.jca.cci.connection.CciLocalTransactionManager tm = new org.springframework.jca.cci.connection.CciLocalTransactionManager();
+		final ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		LocalTransaction localTransaction = mock(LocalTransaction.class);
+		final Record record = mock(Record.class);
+		final InteractionSpec interactionSpec = mock(InteractionSpec.class);
+
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.getLocalTransaction()).willReturn(localTransaction);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, record, record)).willReturn(true);
+		given(connection.getLocalTransaction()).willReturn(localTransaction);
+
+		CciLocalTransactionManager tm = new CciLocalTransactionManager();
 		tm.setConnectionFactory(connectionFactory);
 		TransactionTemplate tt = new TransactionTemplate(tm);
 
@@ -144,6 +120,9 @@ public Object doInTransaction(TransactionStatus status) {
 		catch (Exception ex) {
 		}
 
-		verify(connectionFactory, connection, localTransaction, interaction, record);
+		verify(localTransaction).begin();
+		verify(interaction).close();
+		verify(localTransaction).rollback();
+		verify(connection).close();
 	}
 }
diff --git a/spring-tx/src/test/java/org/springframework/jca/cci/CciTemplateTests.java b/spring-tx/src/test/java/org/springframework/jca/cci/CciTemplateTests.java
index ddbdc8006939..f934ebe7976d 100644
--- a/spring-tx/src/test/java/org/springframework/jca/cci/CciTemplateTests.java
+++ b/spring-tx/src/test/java/org/springframework/jca/cci/CciTemplateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,6 @@
 
 package org.springframework.jca.cci;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
 import java.sql.SQLException;
 
 import javax.resource.NotSupportedException;
@@ -48,6 +40,9 @@
 import org.springframework.jca.cci.core.RecordCreator;
 import org.springframework.jca.cci.core.RecordExtractor;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Thierry Templier
  * @author Juergen Hoeller
@@ -57,99 +52,73 @@ public class CciTemplateTests {
 
 	@Test
 	public void testCreateIndexedRecord() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		IndexedRecord indexedRecord = createMock(IndexedRecord.class);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(recordFactory.createIndexedRecord("name")).andReturn(
-				indexedRecord);
-
-		replay(connectionFactory, recordFactory);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		IndexedRecord indexedRecord = mock(IndexedRecord.class);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(recordFactory.createIndexedRecord("name")).willReturn(indexedRecord);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.createIndexedRecord("name");
 
-		verify(connectionFactory, recordFactory);
+		verify(recordFactory).createIndexedRecord("name");
 	}
 
 	@Test
 	public void testCreateMappedRecord() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		MappedRecord mappedRecord = createMock(MappedRecord.class);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		MappedRecord mappedRecord = mock(MappedRecord.class);
 
-		expect(recordFactory.createMappedRecord("name"))
-				.andReturn(mappedRecord);
-
-		replay(connectionFactory, recordFactory);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(recordFactory.createMappedRecord("name")).willReturn(mappedRecord);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.createMappedRecord("name");
 
-		verify(connectionFactory, recordFactory);
+		verify(recordFactory).createMappedRecord("name");
 	}
 
 	@Test
 	public void testTemplateExecuteInputOutput() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		expect(connectionFactory.getConnection()).andReturn(connection);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		expect(connection.createInteraction()).andReturn(interaction);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
 
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord))
-				.andReturn(true);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(interactionSpec, inputRecord, outputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputRecord, outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testTemplateExecuteWithCreatorAndRecordFactoryNotSupported()
 			throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-
-		Record inputRecord = createMock(Record.class);
-		final Record outputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connectionFactory.getRecordFactory()).andThrow(
-				new NotSupportedException("not supported"));
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
 
-		expect(connection.createInteraction()).andReturn(interaction);
+		Record inputRecord = mock(Record.class);
+		final Record outputRecord = mock(Record.class);
 
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord))
-				.andReturn(true);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connectionFactory.getRecordFactory()).willThrow(new NotSupportedException("not supported"));
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.setOutputRecordCreator(new RecordCreator() {
@@ -161,352 +130,265 @@ public Record createRecord(RecordFactory recordFactory) {
 		});
 		ct.execute(interactionSpec, inputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputRecord, outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testTemplateExecuteInputTrueWithCreator2()
 			throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordCreator creator = createMock(RecordCreator.class);
-
-		Record inputRecord = createMock(Record.class);
-		final Record outputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(creator.createRecord(recordFactory)).andReturn(outputRecord);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordCreator creator = mock(RecordCreator.class);
 
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord))
-				.andReturn(true);
+		Record inputRecord = mock(Record.class);
+		final Record outputRecord = mock(Record.class);
 
-		interaction.close();
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, creator);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(creator.createRecord(recordFactory)).willReturn(outputRecord);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.setOutputRecordCreator(creator);
 		ct.execute(interactionSpec, inputRecord);
 
-		verify(connectionFactory, connection, interaction, creator);
+		verify(interaction).execute(interactionSpec, inputRecord, outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testTemplateExecuteInputFalse() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
 
-		expect(connection.createInteraction()).andReturn(interaction);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		expect(interaction.execute(interactionSpec, inputRecord)).andReturn(
-				outputRecord);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputRecord)).willReturn(outputRecord);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(interactionSpec, inputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@SuppressWarnings("unchecked")
 	@Test
 	public void testTemplateExecuteInputExtractorTrueWithCreator()
 			throws ResourceException, SQLException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordExtractor<Object> extractor = createMock(RecordExtractor.class);
-		RecordCreator creator = createMock(RecordCreator.class);
-
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordExtractor<Object> extractor = mock(RecordExtractor.class);
+		RecordCreator creator = mock(RecordCreator.class);
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		expect(connectionFactory.getConnection()).andReturn(connection);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(creator.createRecord(recordFactory)).andReturn(outputRecord);
-
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord))
-				.andReturn(true);
-
-		expect(extractor.extractData(outputRecord)).andStubReturn(new Object());
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, extractor, creator);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(creator.createRecord(recordFactory)).willReturn(outputRecord);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
+		given(extractor.extractData(outputRecord)).willReturn(new Object());
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.setOutputRecordCreator(creator);
 		ct.execute(interactionSpec, inputRecord, extractor);
 
-		verify(connectionFactory, connection, interaction, extractor, creator);
+		verify(extractor).extractData(outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@SuppressWarnings("unchecked")
 	@Test
 	public void testTemplateExecuteInputExtractorFalse()
 			throws ResourceException, SQLException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordExtractor<Object> extractor = createMock(RecordExtractor.class);
-
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordExtractor<Object> extractor = mock(RecordExtractor.class);
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		expect(connectionFactory.getConnection()).andReturn(connection);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(interaction.execute(interactionSpec, inputRecord)).andReturn(
-				outputRecord);
-
-		expect(extractor.extractData(outputRecord)).andStubReturn(new Object());
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, extractor);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputRecord)).willReturn(outputRecord);
+		given(extractor.extractData(outputRecord)).willReturn(new Object());
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(interactionSpec, inputRecord, extractor);
 
-		verify(connectionFactory, connection, interaction, extractor);
+		verify(extractor).extractData(outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testTemplateExecuteInputGeneratorTrueWithCreator()
 			throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordCreator generator = createMock(RecordCreator.class);
-		RecordCreator creator = createMock(RecordCreator.class);
-
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordCreator generator = mock(RecordCreator.class);
+		RecordCreator creator = mock(RecordCreator.class);
 
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		expect(generator.createRecord(recordFactory)).andReturn(inputRecord);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		expect(connectionFactory.getConnection()).andReturn(connection);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(generator.createRecord(recordFactory)).willReturn(inputRecord);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(creator.createRecord(recordFactory)).willReturn(outputRecord);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
 
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(creator.createRecord(recordFactory)).andReturn(outputRecord);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord))
-				.andReturn(true);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, generator, creator);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.setOutputRecordCreator(creator);
 		ct.execute(interactionSpec, generator);
 
-		verify(connectionFactory, connection, interaction, generator, creator);
+		verify(interaction).execute(interactionSpec, inputRecord, outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testTemplateExecuteInputGeneratorFalse()
 			throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordCreator generator = createMock(RecordCreator.class);
-
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordCreator generator = mock(RecordCreator.class);
 
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		expect(connectionFactory.getConnection()).andReturn(connection);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(generator.createRecord(recordFactory)).andReturn(inputRecord);
-
-		expect(interaction.execute(interactionSpec, inputRecord)).andReturn(
-				outputRecord);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, generator);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(generator.createRecord(recordFactory)).willReturn(inputRecord);
+		given(interaction.execute(interactionSpec, inputRecord)).willReturn(outputRecord);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(interactionSpec, generator);
 
-		verify(connectionFactory, connection, interaction, generator);
+		verify(interaction).execute(interactionSpec, inputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@SuppressWarnings("unchecked")
 	@Test
 	public void testTemplateExecuteInputGeneratorExtractorTrueWithCreator()
 			throws ResourceException, SQLException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordCreator generator = createMock(RecordCreator.class);
-		RecordExtractor<Object> extractor = createMock(RecordExtractor.class);
-		RecordCreator creator = createMock(RecordCreator.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordCreator generator = mock(RecordCreator.class);
+		RecordExtractor<Object> extractor = mock(RecordExtractor.class);
+		RecordCreator creator = mock(RecordCreator.class);
 
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
 		Object obj = new Object();
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(creator.createRecord(recordFactory)).andReturn(outputRecord);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(generator.createRecord(recordFactory)).andReturn(inputRecord);
-
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord))
-				.andReturn(true);
-
-		expect(extractor.extractData(outputRecord)).andStubReturn(obj);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, generator, creator,
-				extractor);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(creator.createRecord(recordFactory)).willReturn(outputRecord);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(generator.createRecord(recordFactory)).willReturn(inputRecord);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
+		given(extractor.extractData(outputRecord)).willReturn(obj);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.setOutputRecordCreator(creator);
 		assertEquals(obj, ct.execute(interactionSpec, generator, extractor));
 
-		verify(connectionFactory, connection, interaction, generator, creator,
-				extractor);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@SuppressWarnings("unchecked")
 	@Test
 	public void testTemplateExecuteInputGeneratorExtractorFalse()
 			throws ResourceException, SQLException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordCreator generator = createMock(RecordCreator.class);
-		RecordExtractor<Object> extractor = createMock(RecordExtractor.class);
-
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(generator.createRecord(recordFactory)).andReturn(inputRecord);
-
-		expect(interaction.execute(interactionSpec, inputRecord)).andReturn(
-				outputRecord);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordCreator generator = mock(RecordCreator.class);
+		RecordExtractor<Object> extractor = mock(RecordExtractor.class);
 
-		expect(extractor.extractData(outputRecord)).andStubReturn(new Object());
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		interaction.close();
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, generator, extractor);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(generator.createRecord(recordFactory)).willReturn(inputRecord);
+		given(interaction.execute(interactionSpec, inputRecord)).willReturn(outputRecord);
+		given(extractor.extractData(outputRecord)).willReturn(new Object());
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(interactionSpec, generator, extractor);
 
-		verify(connectionFactory, connection, interaction, generator, extractor);
+		verify(extractor).extractData(outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
-	public void testTemplateExecuteInputOutputConnectionSpec()
-			throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		ConnectionSpec connectionSpec = createMock(ConnectionSpec.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+	public void testTemplateExecuteInputOutputConnectionSpec() throws ResourceException {
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		ConnectionSpec connectionSpec = mock(ConnectionSpec.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
 
-		expect(connectionFactory.getConnection(connectionSpec)).andReturn(
-				connection);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		expect(connection.createInteraction()).andReturn(interaction);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord))
-				.andReturn(true);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction);
+		given(connectionFactory.getConnection(connectionSpec)).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
 
 		ConnectionSpecConnectionFactoryAdapter adapter = new ConnectionSpecConnectionFactoryAdapter();
 		adapter.setTargetConnectionFactory(connectionFactory);
@@ -514,197 +396,146 @@ public void testTemplateExecuteInputOutputConnectionSpec()
 		CciTemplate ct = new CciTemplate(adapter);
 		ct.execute(interactionSpec, inputRecord, outputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputRecord, outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@SuppressWarnings("unchecked")
 	@Test
 	public void testTemplateExecuteInputOutputResultsSetFalse()
 			throws ResourceException, SQLException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		Record record = createMock(Record.class);
-		ResultSet resultset = createMock(ResultSet.class);
-		RecordCreator generator = createMock(RecordCreator.class);
-		RecordExtractor<Object> extractor = createMock(RecordExtractor.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(generator.createRecord(recordFactory)).andReturn(record);
-
-		expect(interaction.execute(interactionSpec, record)).andReturn(
-				resultset);
-
-		expect(extractor.extractData(resultset)).andStubReturn(new Object());
-
-		resultset.close();
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, generator,
-				extractor, resultset);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		Record record = mock(Record.class);
+		ResultSet resultset = mock(ResultSet.class);
+		RecordCreator generator = mock(RecordCreator.class);
+		RecordExtractor<Object> extractor = mock(RecordExtractor.class);
+
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
+
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(generator.createRecord(recordFactory)).willReturn(record);
+		given(interaction.execute(interactionSpec, record)).willReturn(resultset);
+		given(extractor.extractData(resultset)).willReturn(new Object());
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(interactionSpec, generator, extractor);
 
-		verify(connectionFactory, connection, interaction, generator,
-				extractor, resultset);
+		verify(extractor).extractData(resultset);
+		verify(resultset).close();
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@SuppressWarnings("unchecked")
 	@Test
 	public void testTemplateExecuteConnectionCallback()
 			throws ResourceException, SQLException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		ConnectionCallback<Object> connectionCallback = createMock(ConnectionCallback.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		ConnectionCallback<Object> connectionCallback = mock(ConnectionCallback.class);
 
-		expect(connectionCallback.doInConnection(connection, connectionFactory))
-				.andStubReturn(new Object());
-
-		connection.close();
-
-		replay(connectionFactory, connection, connectionCallback);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connectionCallback.doInConnection(connection, connectionFactory)).willReturn(new Object());
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(connectionCallback);
 
-		verify(connectionFactory, connection, connectionCallback);
+		verify(connectionCallback).doInConnection(connection, connectionFactory);
+		verify(connection).close();
 	}
 
 	@SuppressWarnings("unchecked")
 	@Test
 	public void testTemplateExecuteInteractionCallback()
 			throws ResourceException, SQLException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		InteractionCallback<Object> interactionCallback = createMock(InteractionCallback.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		InteractionCallback<Object> interactionCallback = mock(InteractionCallback.class);
 
-		expect(
-				interactionCallback.doInInteraction(interaction,
-						connectionFactory)).andStubReturn(new Object());
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, interactionCallback);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interactionCallback.doInInteraction(interaction,connectionFactory)).willReturn(new Object());
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(interactionCallback);
 
-		verify(connectionFactory, connection, interaction, interactionCallback);
+		verify(interactionCallback).doInInteraction(interaction,connectionFactory);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testTemplateExecuteInputTrueTrueWithCreator()
 			throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordCreator creator = createMock(RecordCreator.class);
-
-		Record inputOutputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordCreator creator = mock(RecordCreator.class);
 
-		expect(
-				interaction.execute(interactionSpec, inputOutputRecord,
-						inputOutputRecord)).andReturn(true);
+		Record inputOutputRecord = mock(Record.class);
 
-		interaction.close();
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, creator);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputOutputRecord, inputOutputRecord)).willReturn(true);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.setOutputRecordCreator(creator);
 		ct.execute(interactionSpec, inputOutputRecord, inputOutputRecord);
 
-		verify(connectionFactory, connection, interaction, creator);
+		verify(interaction).execute(interactionSpec, inputOutputRecord, inputOutputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testTemplateExecuteInputTrueTrue() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-
-		Record inputOutputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(
-				interaction.execute(interactionSpec, inputOutputRecord,
-						inputOutputRecord)).andReturn(true);
-
-		interaction.close();
-
-		connection.close();
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		Record inputOutputRecord = mock(Record.class);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		replay(connectionFactory, connection, interaction);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputOutputRecord, inputOutputRecord)).willReturn(true);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		ct.execute(interactionSpec, inputOutputRecord, inputOutputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputOutputRecord, inputOutputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testTemplateExecuteInputFalseTrue() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-
-		Record inputOutputRecord = createMock(Record.class);
-
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(interaction.execute(interactionSpec, inputOutputRecord))
-				.andReturn(null);
-
-		interaction.close();
-
-		connection.close();
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		Record inputOutputRecord = mock(Record.class);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		replay(connectionFactory, connection, interaction);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputOutputRecord)).willReturn(null);
 
 		CciTemplate ct = new CciTemplate(connectionFactory);
 		Record tmpOutputRecord = ct.execute(interactionSpec,
 				inputOutputRecord);
 		assertNull(tmpOutputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputOutputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 }
diff --git a/spring-tx/src/test/java/org/springframework/jca/cci/EisOperationTests.java b/spring-tx/src/test/java/org/springframework/jca/cci/EisOperationTests.java
index 4e5a3281d49f..e5e2f8a61752 100644
--- a/spring-tx/src/test/java/org/springframework/jca/cci/EisOperationTests.java
+++ b/spring-tx/src/test/java/org/springframework/jca/cci/EisOperationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,6 @@
 
 package org.springframework.jca.cci;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.assertSame;
-
 import javax.resource.ResourceException;
 import javax.resource.cci.Connection;
 import javax.resource.cci.ConnectionFactory;
@@ -32,6 +29,9 @@
 import org.springframework.jca.cci.object.MappingRecordOperation;
 import org.springframework.jca.cci.object.SimpleRecordOperation;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Thierry Templier
  * @author Chris Beams
@@ -40,106 +40,88 @@ public class EisOperationTests {
 
 	@Test
 	public void testSimpleRecordOperation() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
 
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
 		SimpleRecordOperation query = new SimpleRecordOperation(connectionFactory, interactionSpec);
 
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(interaction.execute(interactionSpec, inputRecord)).andReturn(outputRecord);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputRecord)).willReturn(outputRecord);
 
 		query.execute(inputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testSimpleRecordOperationWithExplicitOutputRecord() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
 
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
 		SimpleRecordOperation operation = new SimpleRecordOperation(connectionFactory, interactionSpec);
 
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord)).andReturn(true);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
 
 		operation.execute(inputRecord, outputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputRecord, outputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testSimpleRecordOperationWithInputOutputRecord() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
 
-		Record inputOutputRecord = createMock(Record.class);
+		Record inputOutputRecord = mock(Record.class);
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
 		SimpleRecordOperation query = new SimpleRecordOperation(connectionFactory, interactionSpec);
 
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(interaction.execute(interactionSpec, inputOutputRecord, inputOutputRecord)).andReturn(true);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputOutputRecord, inputOutputRecord)).willReturn(true);
 
 		query.execute(inputOutputRecord, inputOutputRecord);
 
-		verify(connectionFactory, connection, interaction);
+		verify(interaction).execute(interactionSpec, inputOutputRecord, inputOutputRecord);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testMappingRecordOperation() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
 
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		QueryCallDetector callDetector = createMock(QueryCallDetector.class);
+		QueryCallDetector callDetector = mock(QueryCallDetector.class);
 
 		MappingRecordOperationImpl query = new MappingRecordOperationImpl(connectionFactory, interactionSpec);
 		query.setCallDetector(callDetector);
@@ -147,44 +129,33 @@ public void testMappingRecordOperation() throws ResourceException {
 		Object inObj = new Object();
 		Object outObj = new Object();
 
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(callDetector.callCreateInputRecord(recordFactory, inObj)).andReturn(inputRecord);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(interaction.execute(interactionSpec, inputRecord)).andReturn(outputRecord);
-
-		expect(callDetector.callExtractOutputData(outputRecord)).andReturn(outObj);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, callDetector);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(callDetector.callCreateInputRecord(recordFactory, inObj)).willReturn(inputRecord);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(interaction.execute(interactionSpec, inputRecord)).willReturn(outputRecord);
+		given(callDetector.callExtractOutputData(outputRecord)).willReturn(outObj);
 
 		assertSame(outObj, query.execute(inObj));
-
-		verify(connectionFactory, connection, interaction, callDetector);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 	@Test
 	public void testMappingRecordOperationWithOutputRecordCreator() throws ResourceException {
-		ConnectionFactory connectionFactory = createMock(ConnectionFactory.class);
-		Connection connection = createMock(Connection.class);
-		Interaction interaction = createMock(Interaction.class);
-		RecordFactory recordFactory = createMock(RecordFactory.class);
+		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+		Connection connection = mock(Connection.class);
+		Interaction interaction = mock(Interaction.class);
+		RecordFactory recordFactory = mock(RecordFactory.class);
 
-		Record inputRecord = createMock(Record.class);
-		Record outputRecord = createMock(Record.class);
+		Record inputRecord = mock(Record.class);
+		Record outputRecord = mock(Record.class);
 
-		RecordCreator outputCreator = createMock(RecordCreator.class);
+		RecordCreator outputCreator = mock(RecordCreator.class);
 
-		InteractionSpec interactionSpec = createMock(InteractionSpec.class);
+		InteractionSpec interactionSpec = mock(InteractionSpec.class);
 
-		QueryCallDetector callDetector = createMock(QueryCallDetector.class);
+		QueryCallDetector callDetector = mock(QueryCallDetector.class);
 
 		MappingRecordOperationImpl query = new MappingRecordOperationImpl(connectionFactory, interactionSpec);
 		query.setOutputRecordCreator(outputCreator);
@@ -193,31 +164,18 @@ public void testMappingRecordOperationWithOutputRecordCreator() throws ResourceE
 		Object inObj = new Object();
 		Object outObj = new Object();
 
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(callDetector.callCreateInputRecord(recordFactory, inObj)).andReturn(inputRecord);
-
-		expect(connectionFactory.getConnection()).andReturn(connection);
-
-		expect(connection.createInteraction()).andReturn(interaction);
-
-		expect(connectionFactory.getRecordFactory()).andReturn(recordFactory);
-
-		expect(outputCreator.createRecord(recordFactory)).andReturn(outputRecord);
-
-		expect(interaction.execute(interactionSpec, inputRecord, outputRecord)).andReturn(true);
-
-		expect(callDetector.callExtractOutputData(outputRecord)).andReturn(outObj);
-
-		interaction.close();
-
-		connection.close();
-
-		replay(connectionFactory, connection, interaction, outputCreator, callDetector);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(callDetector.callCreateInputRecord(recordFactory, inObj)).willReturn(inputRecord);
+		given(connectionFactory.getConnection()).willReturn(connection);
+		given(connection.createInteraction()).willReturn(interaction);
+		given(connectionFactory.getRecordFactory()).willReturn(recordFactory);
+		given(outputCreator.createRecord(recordFactory)).willReturn(outputRecord);
+		given(interaction.execute(interactionSpec, inputRecord, outputRecord)).willReturn(true);
+		given(callDetector.callExtractOutputData(outputRecord)).willReturn(outObj);
 
 		assertSame(outObj, query.execute(inObj));
-
-		verify(connectionFactory, connection, interaction, outputCreator, callDetector);
+		verify(interaction).close();
+		verify(connection).close();
 	}
 
 
diff --git a/spring-tx/src/test/java/org/springframework/jca/support/LocalConnectionFactoryBeanTests.java b/spring-tx/src/test/java/org/springframework/jca/support/LocalConnectionFactoryBeanTests.java
index c19efddd551a..617f47f2413d 100644
--- a/spring-tx/src/test/java/org/springframework/jca/support/LocalConnectionFactoryBeanTests.java
+++ b/spring-tx/src/test/java/org/springframework/jca/support/LocalConnectionFactoryBeanTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2006 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,14 @@
 
 package org.springframework.jca.support;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
-
 import javax.resource.spi.ConnectionManager;
 import javax.resource.spi.ManagedConnectionFactory;
 
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Unit tests for the {@link LocalConnectionFactoryBean} class.
  *
@@ -51,38 +51,24 @@ public void testGetObjectTypeIsNullIfConnectionFactoryHasNotBeenConfigured() thr
 
 	@Test
 	public void testCreatesVanillaConnectionFactoryIfNoConnectionManagerHasBeenConfigured() throws Exception {
-
 		final Object CONNECTION_FACTORY = new Object();
-
-		ManagedConnectionFactory managedConnectionFactory = createMock(ManagedConnectionFactory.class);
-
-		expect(managedConnectionFactory.createConnectionFactory()).andReturn(CONNECTION_FACTORY);
-		replay(managedConnectionFactory);
-
+		ManagedConnectionFactory managedConnectionFactory = mock(ManagedConnectionFactory.class);
+		given(managedConnectionFactory.createConnectionFactory()).willReturn(CONNECTION_FACTORY);
 		LocalConnectionFactoryBean factory = new LocalConnectionFactoryBean();
 		factory.setManagedConnectionFactory(managedConnectionFactory);
 		factory.afterPropertiesSet();
 		assertEquals(CONNECTION_FACTORY, factory.getObject());
-
-		verify(managedConnectionFactory);
 	}
 
 	@Test
 	public void testCreatesManagedConnectionFactoryIfAConnectionManagerHasBeenConfigured() throws Exception {
-		ManagedConnectionFactory managedConnectionFactory = createMock(ManagedConnectionFactory.class);
-
-		ConnectionManager connectionManager = createMock(ConnectionManager.class);
-
-		expect(managedConnectionFactory.createConnectionFactory(connectionManager)).andReturn(null);
-
-		replay(connectionManager, managedConnectionFactory);
-
+		ManagedConnectionFactory managedConnectionFactory = mock(ManagedConnectionFactory.class);
+		ConnectionManager connectionManager = mock(ConnectionManager.class);
 		LocalConnectionFactoryBean factory = new LocalConnectionFactoryBean();
 		factory.setManagedConnectionFactory(managedConnectionFactory);
 		factory.setConnectionManager(connectionManager);
 		factory.afterPropertiesSet();
-
-		verify(connectionManager, managedConnectionFactory);
+		verify(managedConnectionFactory).createConnectionFactory(connectionManager);
 	}
 
 }
diff --git a/spring-tx/src/test/java/org/springframework/transaction/JndiJtaTransactionManagerTests.java b/spring-tx/src/test/java/org/springframework/transaction/JndiJtaTransactionManagerTests.java
index 04e937b7eccc..510b1ccf471a 100644
--- a/spring-tx/src/test/java/org/springframework/transaction/JndiJtaTransactionManagerTests.java
+++ b/spring-tx/src/test/java/org/springframework/transaction/JndiJtaTransactionManagerTests.java
@@ -21,7 +21,6 @@
 import javax.transaction.UserTransaction;
 
 import junit.framework.TestCase;
-import org.easymock.MockControl;
 
 import org.springframework.tests.mock.jndi.ExpectedLookupTemplate;
 import org.springframework.transaction.jta.JtaTransactionManager;
@@ -30,6 +29,8 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 05.08.2005
@@ -55,33 +56,14 @@ public void testJtaTransactionManagerWithDefaultJndiLookupsAndNoUtFound() throws
 	private void doTestJtaTransactionManagerWithDefaultJndiLookups(String tmName, boolean tmFound, boolean defaultUt)
 			throws Exception {
 
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
+		UserTransaction ut = mock(UserTransaction.class);
+		TransactionManager tm = mock(TransactionManager.class);
 		if (defaultUt) {
-			ut.getStatus();
-			utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-			ut.getStatus();
-			utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-			ut.begin();
-			utControl.setVoidCallable(1);
-			ut.commit();
-			utControl.setVoidCallable(1);
+			given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
 		}
-		utControl.replay();
-
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
-		if (!defaultUt) {
-			tm.getStatus();
-			tmControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-			tm.getStatus();
-			tmControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-			tm.begin();
-			tmControl.setVoidCallable(1);
-			tm.commit();
-			tmControl.setVoidCallable(1);
+		else {
+			given(tm.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
 		}
-		tmControl.replay();
 
 		JtaTransactionManager ptm = new JtaTransactionManager();
 		ExpectedLookupTemplate jndiTemplate = new ExpectedLookupTemplate();
@@ -122,25 +104,23 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		assertTrue(!TransactionSynchronizationManager.isSynchronizationActive());
 		assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly());
 
-		utControl.verify();
-		tmControl.verify();
+
+		if (defaultUt) {
+			verify(ut).begin();
+			verify(ut).commit();
+		}
+		else {
+			verify(tm).begin();
+			verify(tm).commit();
+		}
+
 	}
 
 	public void testJtaTransactionManagerWithCustomJndiLookups() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+
+		TransactionManager tm = mock(TransactionManager.class);
 
 		JtaTransactionManager ptm = new JtaTransactionManager();
 		ptm.setUserTransactionName("jndi-ut");
@@ -168,33 +148,16 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		assertTrue(!TransactionSynchronizationManager.isSynchronizationActive());
 		assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly());
 
-		utControl.verify();
+		verify(ut).begin();
+		verify(ut).commit();
 	}
 
 	public void testJtaTransactionManagerWithNotCacheUserTransaction() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl ut2Control = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut2 = (UserTransaction) ut2Control.getMock();
-		ut2.getStatus();
-		ut2Control.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut2.getStatus();
-		ut2Control.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut2.begin();
-		ut2Control.setVoidCallable(1);
-		ut2.commit();
-		ut2Control.setVoidCallable(1);
-		ut2Control.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+
+		UserTransaction ut2 = mock(UserTransaction.class);
+		given(ut2.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = new JtaTransactionManager();
 		ptm.setJndiTemplate(new ExpectedLookupTemplate("java:comp/UserTransaction", ut));
@@ -228,8 +191,10 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		assertTrue(!TransactionSynchronizationManager.isSynchronizationActive());
 		assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly());
 
-		utControl.verify();
-		ut2Control.verify();
+		verify(ut).begin();
+		verify(ut).commit();
+		verify(ut2).begin();
+		verify(ut2).commit();
 	}
 
 	/**
diff --git a/spring-tx/src/test/java/org/springframework/transaction/JtaTransactionManagerTests.java b/spring-tx/src/test/java/org/springframework/transaction/JtaTransactionManagerTests.java
index c13ea6bc4173..2c5a55790573 100644
--- a/spring-tx/src/test/java/org/springframework/transaction/JtaTransactionManagerTests.java
+++ b/spring-tx/src/test/java/org/springframework/transaction/JtaTransactionManagerTests.java
@@ -27,7 +27,6 @@
 import javax.transaction.UserTransaction;
 
 import junit.framework.TestCase;
-import org.easymock.MockControl;
 
 import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.tests.transaction.MockJtaTransaction;
@@ -39,6 +38,8 @@
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 import org.springframework.transaction.support.TransactionTemplate;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 12.05.2003
@@ -46,29 +47,10 @@
 public class JtaTransactionManagerTests extends TestCase {
 
 	public void testJtaTransactionManagerWithCommit() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCommit(false);
-		synchControl.setVoidCallable(1);
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCommit();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_COMMITTED);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -92,34 +74,19 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		assertNull(TransactionSynchronizationManager.getCurrentTransactionName());
 		assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).begin();
+		verify(ut).commit();
+		verify(synch).beforeCommit(false);
+		verify(synch).beforeCompletion();
+		verify(synch).afterCommit();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_COMMITTED);
 	}
 
 	public void testJtaTransactionManagerWithCommitAndSynchronizationOnActual() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCommit(false);
-		synchControl.setVoidCallable(1);
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCommit();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_COMMITTED);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -135,22 +102,18 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).begin();
+		verify(ut).commit();
+		verify(synch).beforeCommit(false);
+		verify(synch).beforeCompletion();
+		verify(synch).afterCommit();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_COMMITTED);
 	}
 
 	public void testJtaTransactionManagerWithCommitAndSynchronizationNever() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(
+		Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -166,31 +129,14 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
+		verify(ut).begin();
+		verify(ut).commit();
 	}
 
 	public void testJtaTransactionManagerWithRollback() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.setTransactionTimeout(10);
-		utControl.setVoidCallable(1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		ut.rollback();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE);
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -214,32 +160,17 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		assertNull(TransactionSynchronizationManager.getCurrentTransactionName());
 		assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).setTransactionTimeout(10);
+		verify(ut).begin();
+		verify(ut).rollback();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK);
 	}
 
 	public void testJtaTransactionManagerWithRollbackAndSynchronizationOnActual() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.setTransactionTimeout(10);
-		utControl.setVoidCallable(1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		ut.rollback();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE);
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -256,24 +187,16 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).setTransactionTimeout(10);
+		verify(ut).begin();
+		verify(ut).rollback();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK);
 	}
 
 	public void testJtaTransactionManagerWithRollbackAndSynchronizationNever() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.setTransactionTimeout(10);
-		utControl.setVoidCallable(1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		ut.rollback();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -291,25 +214,17 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
+		verify(ut).setTransactionTimeout(10);
+		verify(ut).begin();
+		verify(ut, atLeastOnce()).getStatus();
+		verify(ut).rollback();
 	}
 
 	public void testJtaTransactionManagerWithExistingTransactionAndRollbackOnly() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.setRollbackOnly();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -324,26 +239,16 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).setRollbackOnly();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
 	}
 
 	public void testJtaTransactionManagerWithExistingTransactionAndException() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.setRollbackOnly();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -364,28 +269,17 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		}
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).setRollbackOnly();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
 	}
 
 	public void testJtaTransactionManagerWithExistingTransactionAndCommitException() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.setRollbackOnly();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCommit(false);
-		synchControl.setThrowable(new OptimisticLockingFailureException(""));
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
+		willThrow(new OptimisticLockingFailureException("")).given(synch).beforeCommit(false);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -405,26 +299,16 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		}
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).setRollbackOnly();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
 	}
 
 	public void testJtaTransactionManagerWithExistingTransactionAndRollbackOnlyAndNoGlobalRollback() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.setRollbackOnly();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		ptm.setGlobalRollbackOnParticipationFailure(false);
@@ -440,24 +324,15 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).setRollbackOnly();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
 	}
 
 	public void testJtaTransactionManagerWithExistingTransactionAndExceptionAndNoGlobalRollback() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		ptm.setGlobalRollbackOnParticipationFailure(false);
@@ -479,34 +354,19 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		}
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
 	}
 
 	public void testJtaTransactionManagerWithExistingTransactionAndJtaSynchronization() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
+		UserTransaction ut = mock(UserTransaction.class);
+		TransactionManager tm = mock(TransactionManager.class);
 		MockJtaTransaction tx = new MockJtaTransaction();
 
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.setRollbackOnly();
-		utControl.setVoidCallable(1);
-		tm.getTransaction();
-		tmControl.setReturnValue(tx, 1);
-
-		utControl.replay();
-		tmControl.replay();
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		given(tm.getTransaction()).willReturn(tx);
 
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut, tm);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -524,27 +384,16 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		tx.getSynchronization().beforeCompletion();
 		tx.getSynchronization().afterCompletion(Status.STATUS_ROLLEDBACK);
 
-		utControl.verify();
-		tmControl.verify();
-		synchControl.verify();
+		verify(ut).setRollbackOnly();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK);
 	}
 
 	public void testJtaTransactionManagerWithExistingTransactionAndSynchronizationOnActual() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.setRollbackOnly();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -560,18 +409,14 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).setRollbackOnly();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
 	}
 
 	public void testJtaTransactionManagerWithExistingTransactionAndSynchronizationNever() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.setRollbackOnly();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -588,25 +433,14 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
+		verify(ut).setRollbackOnly();
 	}
 
 	public void testJtaTransactionManagerWithExistingAndPropagationSupports() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.setRollbackOnly();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -622,24 +456,16 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(ut).setRollbackOnly();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN);
 	}
 
 	public void testJtaTransactionManagerWithPropagationSupports() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		utControl.replay();
-
-		MockControl synchControl = MockControl.createControl(TransactionSynchronization.class);
-		final TransactionSynchronization synch = (TransactionSynchronization) synchControl.getMock();
-		synch.beforeCompletion();
-		synchControl.setVoidCallable(1);
-		synch.afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK);
-		synchControl.setVoidCallable(1);
-		synchControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION);
+
+		final TransactionSynchronization synch = mock(TransactionSynchronization.class);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -655,16 +481,13 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		synchControl.verify();
+		verify(synch).beforeCompletion();
+		verify(synch).afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK);
 	}
 
 	public void testJtaTransactionManagerWithPropagationSupportsAndSynchronizationOnActual() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -681,16 +504,11 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 			}
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithPropagationSupportsAndSynchronizationNever() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -707,25 +525,14 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 			}
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithPropagationNotSupported() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		tm.suspend();
-		tmControl.setReturnValue(tx, 1);
-		tm.resume(tx);
-		tmControl.setVoidCallable(1);
-		utControl.replay();
-		tmControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		TransactionManager tm = mock(TransactionManager.class);
+		Transaction tx = mock(Transaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		given(tm.suspend()).willReturn(tx);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut, tm);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -740,35 +547,17 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		tmControl.verify();
+		verify(tm).resume(tx);
 	}
 
 	public void testJtaTransactionManagerWithPropagationRequiresNew() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 5);
-		tm.suspend();
-		tmControl.setReturnValue(tx, 1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		tm.resume(tx);
-		tmControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
-		tmControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		TransactionManager tm = mock(TransactionManager.class);
+		Transaction tx = mock(Transaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,
+				Status.STATUS_ACTIVE, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE,
+				Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+		given(tm.suspend()).willReturn(tx);
 
 		final JtaTransactionManager ptm = newJtaTransactionManager(ut, tm);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -803,22 +592,15 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		tmControl.verify();
+		verify(ut, times(2)).begin();
+		verify(ut, times(2)).commit();
+		verify(tm).resume(tx);
 	}
 
 	public void testJtaTransactionManagerWithPropagationRequiresNewWithinSupports() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,
+				Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
 
 		final JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -850,28 +632,16 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
+		verify(ut).begin();
+		verify(ut).commit();
 	}
 
 	public void testJtaTransactionManagerWithPropagationRequiresNewAndExisting() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		tm.suspend();
-		tmControl.setReturnValue(tx, 1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		tm.resume(tx);
-		tmControl.setVoidCallable(1);
-		utControl.replay();
-		tmControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		TransactionManager tm = mock(TransactionManager.class);
+		Transaction tx = mock(Transaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		given(tm.suspend()).willReturn(tx);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut, tm);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -885,21 +655,16 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		utControl.verify();
-		tmControl.verify();
+		verify(ut).begin();
+		verify(ut).commit();
+		verify(tm).resume(tx);
 	}
 
 	public void testJtaTransactionManagerWithPropagationRequiresNewAndExistingWithSuspendException() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		tm.suspend();
-		tmControl.setThrowable(new SystemException());
-		utControl.replay();
-		tmControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		TransactionManager tm = mock(TransactionManager.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		willThrow(new SystemException()).given(tm).suspend();
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut, tm);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -918,28 +683,15 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 			// expected
 		}
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
-
-		utControl.verify();
-		tmControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithPropagationRequiresNewAndExistingWithBeginException() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		tm.suspend();
-		tmControl.setReturnValue(tx, 1);
-		ut.begin();
-		utControl.setThrowable(new SystemException());
-		tm.resume(tx);
-		tmControl.setVoidCallable(1);
-		utControl.replay();
-		tmControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		TransactionManager tm = mock(TransactionManager.class);
+		Transaction tx = mock(Transaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		given(tm.suspend()).willReturn(tx);
+		willThrow(new SystemException()).given(ut).begin();
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut, tm);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -958,27 +710,14 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 			// expected
 		}
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
-
-		utControl.verify();
-		tmControl.verify();
+		verify(tm).resume(tx);
 	}
 
 	public void testJtaTransactionManagerWithPropagationRequiresNewAndAdapter() throws Exception {
-		MockControl tmControl = MockControl.createControl(TransactionManager.class);
-		TransactionManager tm = (TransactionManager) tmControl.getMock();
-		MockControl txControl = MockControl.createControl(Transaction.class);
-		Transaction tx = (Transaction) txControl.getMock();
-		tm.getStatus();
-		tmControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		tm.suspend();
-		tmControl.setReturnValue(tx, 1);
-		tm.begin();
-		tmControl.setVoidCallable(1);
-		tm.commit();
-		tmControl.setVoidCallable(1);
-		tm.resume(tx);
-		tmControl.setVoidCallable(1);
-		tmControl.replay();
+		TransactionManager tm = mock(TransactionManager.class);
+		Transaction tx = mock(Transaction.class);
+		given(tm.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		given(tm.suspend()).willReturn(tx);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(tm);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -992,15 +731,14 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		});
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
 
-		tmControl.verify();
+		verify(tm).begin();
+		verify(tm).commit();
+		verify(tm).resume(tx);
 	}
 
 	public void testJtaTransactionManagerWithPropagationRequiresNewAndSuspensionNotSupported() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -1018,16 +756,11 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 			// expected
 		}
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithIsolationLevel() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION);
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1044,16 +777,11 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		catch (InvalidIsolationLevelException ex) {
 			// expected
 		}
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithSystemExceptionOnIsExisting() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setThrowable(new SystemException("system exception"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willThrow(new SystemException("system exception"));
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1069,20 +797,11 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		catch (TransactionSystemException ex) {
 			// expected
 		}
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithNestedBegin() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		TransactionTemplate tt = new TransactionTemplate(ptm);
@@ -1094,17 +813,14 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 			}
 		});
 
-		utControl.verify();
+		verify(ut).begin();
+		verify(ut).commit();
 	}
 
 	public void testJtaTransactionManagerWithNotSupportedExceptionOnNestedBegin() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		ut.begin();
-		utControl.setThrowable(new NotSupportedException("not supported"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		willThrow(new NotSupportedException("not supported")).given(ut).begin();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1121,18 +837,12 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		catch (NestedTransactionNotSupportedException ex) {
 			// expected
 		}
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithUnsupportedOperationExceptionOnNestedBegin() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		ut.begin();
-		utControl.setThrowable(new UnsupportedOperationException("not supported"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		willThrow(new UnsupportedOperationException("not supported")).given(ut).begin();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1149,18 +859,12 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		catch (NestedTransactionNotSupportedException ex) {
 			// expected
 		}
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithSystemExceptionOnBegin() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.begin();
-		utControl.setThrowable(new SystemException("system exception"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION);
+		willThrow(new SystemException("system exception")).given(ut).begin();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1176,22 +880,13 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		catch (CannotCreateTransactionException ex) {
 			// expected
 		}
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithRollbackExceptionOnCommit() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setThrowable(new RollbackException("unexpected rollback"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,
+				Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+		willThrow(new RollbackException("unexpected rollback")).given(ut).commit();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1214,7 +909,7 @@ public void afterCompletion(int status) {
 			// expected
 		}
 
-		utControl.verify();
+		verify(ut).begin();
 	}
 
 	public void testJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly() throws Exception {
@@ -1226,22 +921,10 @@ public void testJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnlyAndFailE
 	}
 
 	private void doTestJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly(boolean failEarly) throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_MARKED_ROLLBACK, 3);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		if (failEarly) {
-			ut.rollback();
-		}
-		else {
-			ut.commit();
-		}
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,
+				Status.STATUS_MARKED_ROLLBACK, Status.STATUS_MARKED_ROLLBACK,
+				Status.STATUS_MARKED_ROLLBACK);
 
 		JtaTransactionManager tm = newJtaTransactionManager(ut);
 		if (failEarly) {
@@ -1285,21 +968,20 @@ public void afterCompletion(int status) {
 			}
 		}
 
-		utControl.verify();
+		verify(ut).begin();
+		if (failEarly) {
+			verify(ut).rollback();
+		}
+		else {
+			verify(ut).commit();
+		}
 	}
 
 	public void testJtaTransactionManagerWithHeuristicMixedExceptionOnCommit() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setThrowable(new HeuristicMixedException("heuristic exception"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,
+				Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+		willThrow(new HeuristicMixedException("heuristic exception")).given(ut).commit();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1323,21 +1005,14 @@ public void afterCompletion(int status) {
 			assertTrue(ex.getOutcomeState() == HeuristicCompletionException.STATE_MIXED);
 		}
 
-		utControl.verify();
+		verify(ut).begin();
 	}
 
 	public void testJtaTransactionManagerWithHeuristicRollbackExceptionOnCommit() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setThrowable(new HeuristicRollbackException("heuristic exception"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,
+				Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+		willThrow(new HeuristicRollbackException("heuristic exception")).given(ut).commit();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1361,21 +1036,14 @@ public void afterCompletion(int status) {
 			assertTrue(ex.getOutcomeState() == HeuristicCompletionException.STATE_ROLLED_BACK);
 		}
 
-		utControl.verify();
+		verify(ut).begin();
 	}
 
 	public void testJtaTransactionManagerWithSystemExceptionOnCommit() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setThrowable(new SystemException("system exception"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,
+				Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
+		willThrow(new SystemException("system exception")).given(ut).commit();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1398,21 +1066,13 @@ public void afterCompletion(int status) {
 			// expected
 		}
 
-		utControl.verify();
+		verify(ut).begin();
 	}
 
 	public void testJtaTransactionManagerWithSystemExceptionOnRollback() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		ut.rollback();
-		utControl.setThrowable(new SystemException("system exception"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE);
+		willThrow(new SystemException("system exception")).given(ut).rollback();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1435,17 +1095,13 @@ public void afterCompletion(int status) {
 			// expected
 		}
 
-		utControl.verify();
+		verify(ut).begin();
 	}
 
 	public void testJtaTransactionManagerWithIllegalStateExceptionOnRollbackOnly() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.setRollbackOnly();
-		utControl.setThrowable(new IllegalStateException("no existing transaction"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		willThrow(new IllegalStateException("no existing transaction")).given(ut).setRollbackOnly();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1461,18 +1117,12 @@ protected void doInTransactionWithoutResult(TransactionStatus status) {
 		catch (TransactionSystemException ex) {
 			// expected
 		}
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithSystemExceptionOnRollbackOnly() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 3);
-		ut.setRollbackOnly();
-		utControl.setThrowable(new SystemException("system exception"));
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE);
+		willThrow(new SystemException("system exception")).given(ut).setRollbackOnly();
 
 		try {
 			JtaTransactionManager ptm = newJtaTransactionManager(ut);
@@ -1494,22 +1144,12 @@ public void afterCompletion(int status) {
 		catch (TransactionSystemException ex) {
 			// expected
 		}
-
-		utControl.verify();
 	}
 
 	public void testJtaTransactionManagerWithDoubleCommit() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION,
+				Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
@@ -1527,21 +1167,13 @@ public void testJtaTransactionManagerWithDoubleCommit() throws Exception {
 			// expected
 		}
 
-		utControl.verify();
+		verify(ut).begin();
+		verify(ut).commit();
 	}
 
 	public void testJtaTransactionManagerWithDoubleRollback() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		ut.rollback();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
@@ -1559,21 +1191,13 @@ public void testJtaTransactionManagerWithDoubleRollback() throws Exception {
 			// expected
 		}
 
-		utControl.verify();
+		verify(ut).begin();
+		verify(ut).rollback();
 	}
 
 	public void testJtaTransactionManagerWithRollbackAndCommit() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 1);
-		ut.rollback();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE);
 
 		JtaTransactionManager ptm = newJtaTransactionManager(ut);
 		assertFalse(TransactionSynchronizationManager.isSynchronizationActive());
@@ -1591,7 +1215,8 @@ public void testJtaTransactionManagerWithRollbackAndCommit() throws Exception {
 			// expected
 		}
 
-		utControl.verify();
+		verify(ut).begin();
+		verify(ut).rollback();
 	}
 
 
diff --git a/spring-tx/src/test/java/org/springframework/transaction/interceptor/AbstractTransactionAspectTests.java b/spring-tx/src/test/java/org/springframework/transaction/interceptor/AbstractTransactionAspectTests.java
index 2b01ef4a916e..b097bf382c36 100644
--- a/spring-tx/src/test/java/org/springframework/transaction/interceptor/AbstractTransactionAspectTests.java
+++ b/spring-tx/src/test/java/org/springframework/transaction/interceptor/AbstractTransactionAspectTests.java
@@ -19,11 +19,10 @@
 import java.lang.reflect.Method;
 
 import junit.framework.TestCase;
-import org.easymock.MockControl;
 
+import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.tests.sample.beans.TestBean;
-import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.transaction.CannotCreateTransactionException;
 import org.springframework.transaction.MockCallbackPreferringTransactionManager;
 import org.springframework.transaction.NoTransactionException;
@@ -34,6 +33,8 @@
 import org.springframework.transaction.UnexpectedRollbackException;
 import org.springframework.transaction.interceptor.TransactionAspectSupport.TransactionInfo;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * Mock object based tests for transaction aspects.
  * True unit test in that it tests how the transaction aspect uses
@@ -69,11 +70,7 @@ public AbstractTransactionAspectTests() {
 
 
 	public void testNoTransaction() throws Exception {
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
-
-		// expect no calls
-		ptmControl.replay();
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 
 		TestBean tb = new TestBean();
 		TransactionAttributeSource tas = new MapTransactionAttributeSource();
@@ -87,7 +84,8 @@ public void testNoTransaction() throws Exception {
 		itb.getName();
 		checkTransactionStatus(false);
 
-		ptmControl.verify();
+		// expect no calls
+		verifyZeroInteractions(ptm);
 	}
 
 	/**
@@ -99,15 +97,10 @@ public void testTransactionShouldSucceed() throws Exception {
 		MapTransactionAttributeSource tas = new MapTransactionAttributeSource();
 		tas.register(getNameMethod, txatt);
 
-		TransactionStatus status = transactionStatusForNewTransaction();
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		TransactionStatus status = mock(TransactionStatus.class);
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 		// expect a transaction
-		ptm.getTransaction(txatt);
-		ptmControl.setReturnValue(status, 1);
-		ptm.commit(status);
-		ptmControl.setVoidCallable(1);
-		ptmControl.replay();
+		given(ptm.getTransaction(txatt)).willReturn(status);
 
 		TestBean tb = new TestBean();
 		ITestBean itb = (ITestBean) advised(tb, ptm, tas);
@@ -116,7 +109,7 @@ public void testTransactionShouldSucceed() throws Exception {
 		itb.getName();
 		checkTransactionStatus(false);
 
-		ptmControl.verify();
+		verify(ptm).commit(status);
 	}
 
 	/**
@@ -178,15 +171,10 @@ public void testTwoTransactionsShouldSucceed() throws Exception {
 		MapTransactionAttributeSource tas2 = new MapTransactionAttributeSource();
 		tas2.register(setNameMethod, txatt);
 
-		TransactionStatus status = transactionStatusForNewTransaction();
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		TransactionStatus status = mock(TransactionStatus.class);
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 		// expect a transaction
-		ptm.getTransaction(txatt);
-		ptmControl.setReturnValue(status, 2);
-		ptm.commit(status);
-		ptmControl.setVoidCallable(2);
-		ptmControl.replay();
+		given(ptm.getTransaction(txatt)).willReturn(status);
 
 		TestBean tb = new TestBean();
 		ITestBean itb = (ITestBean) advised(tb, ptm, new TransactionAttributeSource[] {tas1, tas2});
@@ -197,7 +185,7 @@ public void testTwoTransactionsShouldSucceed() throws Exception {
 		itb.setName("myName");
 		checkTransactionStatus(false);
 
-		ptmControl.verify();
+		verify(ptm, times(2)).commit(status);
 	}
 
 	/**
@@ -209,16 +197,10 @@ public void testTransactionShouldSucceedWithNotNew() throws Exception {
 		MapTransactionAttributeSource tas = new MapTransactionAttributeSource();
 		tas.register(getNameMethod, txatt);
 
-		MockControl statusControl = MockControl.createControl(TransactionStatus.class);
-		TransactionStatus status = (TransactionStatus) statusControl.getMock();
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		TransactionStatus status = mock(TransactionStatus.class);
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 		// expect a transaction
-		ptm.getTransaction(txatt);
-		ptmControl.setReturnValue(status, 1);
-		ptm.commit(status);
-		ptmControl.setVoidCallable(1);
-		ptmControl.replay();
+		given(ptm.getTransaction(txatt)).willReturn(status);
 
 		TestBean tb = new TestBean();
 		ITestBean itb = (ITestBean) advised(tb, ptm, tas);
@@ -228,7 +210,7 @@ public void testTransactionShouldSucceedWithNotNew() throws Exception {
 		itb.getName();
 		checkTransactionStatus(false);
 
-		ptmControl.verify();
+		verify(ptm).commit(status);
 	}
 
 	public void testEnclosingTransactionWithNonTransactionMethodOnAdvisedInside() throws Throwable {
@@ -237,15 +219,10 @@ public void testEnclosingTransactionWithNonTransactionMethodOnAdvisedInside() th
 		MapTransactionAttributeSource tas = new MapTransactionAttributeSource();
 		tas.register(exceptionalMethod, txatt);
 
-		TransactionStatus status = transactionStatusForNewTransaction();
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		TransactionStatus status = mock(TransactionStatus.class);
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 		// Expect a transaction
-		ptm.getTransaction(txatt);
-		ptmControl.setReturnValue(status, 1);
-		ptm.commit(status);
-		ptmControl.setVoidCallable(1);
-		ptmControl.replay();
+		given(ptm.getTransaction(txatt)).willReturn(status);
 
 		final String spouseName = "innerName";
 
@@ -278,7 +255,7 @@ public String getName() {
 
 		checkTransactionStatus(false);
 
-		ptmControl.verify();
+		verify(ptm).commit(status);
 	}
 
 	public void testEnclosingTransactionWithNestedTransactionOnAdvisedInside() throws Throwable {
@@ -291,24 +268,13 @@ public void testEnclosingTransactionWithNestedTransactionOnAdvisedInside() throw
 		tas.register(outerMethod, outerTxatt);
 		tas.register(innerMethod, innerTxatt);
 
-		TransactionStatus outerStatus = transactionStatusForNewTransaction();
-		TransactionStatus innerStatus = transactionStatusForNewTransaction();
+		TransactionStatus outerStatus = mock(TransactionStatus.class);
+		TransactionStatus innerStatus = mock(TransactionStatus.class);
 
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 		// Expect a transaction
-		ptm.getTransaction(outerTxatt);
-		ptmControl.setReturnValue(outerStatus, 1);
-
-		ptm.getTransaction(innerTxatt);
-		ptmControl.setReturnValue(innerStatus, 1);
-
-		ptm.commit(innerStatus);
-		ptmControl.setVoidCallable(1);
-
-		ptm.commit(outerStatus);
-		ptmControl.setVoidCallable(1);
-		ptmControl.replay();
+		given(ptm.getTransaction(outerTxatt)).willReturn(outerStatus);
+		given(ptm.getTransaction(innerTxatt)).willReturn(innerStatus);
 
 		final String spouseName = "innerName";
 
@@ -344,7 +310,8 @@ public String getName() {
 
 		checkTransactionStatus(false);
 
-		ptmControl.verify();
+		verify(ptm).commit(innerStatus);
+		verify(ptm).commit(outerStatus);
 	}
 
 	public void testRollbackOnCheckedException() throws Throwable {
@@ -401,29 +368,21 @@ public boolean rollbackOn(Throwable t) {
 		MapTransactionAttributeSource tas = new MapTransactionAttributeSource();
 		tas.register(m, txatt);
 
-		MockControl statusControl = MockControl.createControl(TransactionStatus.class);
-		TransactionStatus status = (TransactionStatus) statusControl.getMock();
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		TransactionStatus status = mock(TransactionStatus.class);
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 		// Gets additional call(s) from TransactionControl
 
-		ptm.getTransaction(txatt);
-		ptmControl.setReturnValue(status, 1);
+		given(ptm.getTransaction(txatt)).willReturn(status);
 
-		if (shouldRollback) {
-			ptm.rollback(status);
-		}
-		else {
-			ptm.commit(status);
-		}
 		TransactionSystemException tex = new TransactionSystemException("system exception");
 		if (rollbackException) {
-			ptmControl.setThrowable(tex, 1);
-		}
-		else {
-			ptmControl.setVoidCallable(1);
+			if (shouldRollback) {
+				willThrow(tex).given(ptm).rollback(status);
+			}
+			else {
+				willThrow(tex).given(ptm).commit(status);
+			}
 		}
-		ptmControl.replay();
 
 		TestBean tb = new TestBean();
 		ITestBean itb = (ITestBean) advised(tb, ptm, tas);
@@ -441,7 +400,14 @@ public boolean rollbackOn(Throwable t) {
 			}
 		}
 
-		ptmControl.verify();
+		if (!rollbackException) {
+			if (shouldRollback) {
+				verify(ptm).rollback(status);
+			}
+			else {
+				verify(ptm).commit(status);
+			}
+		}
 	}
 
 	/**
@@ -454,15 +420,10 @@ public void testProgrammaticRollback() throws Exception {
 		MapTransactionAttributeSource tas = new MapTransactionAttributeSource();
 		tas.register(m, txatt);
 
-		TransactionStatus status = transactionStatusForNewTransaction();
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		TransactionStatus status = mock(TransactionStatus.class);
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 
-		ptm.getTransaction(txatt);
-		ptmControl.setReturnValue(status, 1);
-		ptm.commit(status);
-		ptmControl.setVoidCallable(1);
-		ptmControl.replay();
+		given(ptm.getTransaction(txatt)).willReturn(status);
 
 		final String name = "jenny";
 		TestBean tb = new TestBean() {
@@ -479,15 +440,7 @@ public String getName() {
 		// verification!?
 		assertTrue(name.equals(itb.getName()));
 
-		ptmControl.verify();
-	}
-
-	/**
-	 * @return a TransactionStatus object configured for a new transaction
-	 */
-	private TransactionStatus transactionStatusForNewTransaction() {
-		MockControl statusControl = MockControl.createControl(TransactionStatus.class);
-		return (TransactionStatus) statusControl.getMock();
+		verify(ptm).commit(status);
 	}
 
 	/**
@@ -501,13 +454,10 @@ public void testCannotCreateTransaction() throws Exception {
 		MapTransactionAttributeSource tas = new MapTransactionAttributeSource();
 		tas.register(m, txatt);
 
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 		// Expect a transaction
-		ptm.getTransaction(txatt);
 		CannotCreateTransactionException ex = new CannotCreateTransactionException("foobar", null);
-		ptmControl.setThrowable(ex);
-		ptmControl.replay();
+		given(ptm.getTransaction(txatt)).willThrow(ex);
 
 		TestBean tb = new TestBean() {
 			@Override
@@ -525,7 +475,6 @@ public String getName() {
 		catch (CannotCreateTransactionException thrown) {
 			assertTrue(thrown == ex);
 		}
-		ptmControl.verify();
 	}
 
 	/**
@@ -539,19 +488,15 @@ public void testCannotCommitTransaction() throws Exception {
 		Method m = setNameMethod;
 		MapTransactionAttributeSource tas = new MapTransactionAttributeSource();
 		tas.register(m, txatt);
-		Method m2 = getNameMethod;
+		// Method m2 = getNameMethod;
 		// No attributes for m2
 
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 
-		TransactionStatus status = transactionStatusForNewTransaction();
-		ptm.getTransaction(txatt);
-		ptmControl.setReturnValue(status);
+		TransactionStatus status = mock(TransactionStatus.class);
+		given(ptm.getTransaction(txatt)).willReturn(status);
 		UnexpectedRollbackException ex = new UnexpectedRollbackException("foobar", null);
-		ptm.commit(status);
-		ptmControl.setThrowable(ex);
-		ptmControl.replay();
+		willThrow(ex).given(ptm).commit(status);
 
 		TestBean tb = new TestBean();
 		ITestBean itb = (ITestBean) advised(tb, ptm, tas);
@@ -567,7 +512,6 @@ public void testCannotCommitTransaction() throws Exception {
 
 		// Should have invoked target and changed name
 		assertTrue(itb.getName() == name);
-		ptmControl.verify();
 	}
 
 	protected void checkTransactionStatus(boolean expected) {
diff --git a/spring-tx/src/test/java/org/springframework/transaction/interceptor/BeanFactoryTransactionTests.java b/spring-tx/src/test/java/org/springframework/transaction/interceptor/BeanFactoryTransactionTests.java
index 1ff4a262f4ec..268cee7bb7bb 100644
--- a/spring-tx/src/test/java/org/springframework/transaction/interceptor/BeanFactoryTransactionTests.java
+++ b/spring-tx/src/test/java/org/springframework/transaction/interceptor/BeanFactoryTransactionTests.java
@@ -24,23 +24,24 @@
 
 import org.aopalliance.intercept.MethodInterceptor;
 import org.aopalliance.intercept.MethodInvocation;
-import org.easymock.MockControl;
 import org.springframework.aop.support.AopUtils;
 import org.springframework.aop.support.StaticMethodMatcherPointcut;
 import org.springframework.aop.target.HotSwappableTargetSource;
-import org.springframework.tests.sample.beans.DerivedTestBean;
 import org.springframework.beans.FatalBeanException;
-import org.springframework.tests.sample.beans.ITestBean;
-import org.springframework.tests.sample.beans.TestBean;
-import org.springframework.tests.transaction.CallCountingTransactionManager;
 import org.springframework.beans.factory.support.DefaultListableBeanFactory;
 import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
 import org.springframework.core.io.ClassPathResource;
+import org.springframework.tests.sample.beans.DerivedTestBean;
+import org.springframework.tests.sample.beans.ITestBean;
+import org.springframework.tests.sample.beans.TestBean;
+import org.springframework.tests.transaction.CallCountingTransactionManager;
 import org.springframework.transaction.PlatformTransactionManager;
 import org.springframework.transaction.TransactionDefinition;
 import org.springframework.transaction.TransactionException;
 import org.springframework.transaction.TransactionStatus;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test cases for AOP transaction management.
  *
@@ -116,19 +117,16 @@ public void testGetsAreNotTransactionalWithProxyFactory3() throws NoSuchMethodEx
 
 	private void doTestGetsAreNotTransactional(final ITestBean testBean) {
 		// Install facade
-		MockControl ptmControl = MockControl.createControl(PlatformTransactionManager.class);
-		PlatformTransactionManager ptm = (PlatformTransactionManager) ptmControl.getMock();
-		// Expect no methods
-		ptmControl.replay();
+		PlatformTransactionManager ptm = mock(PlatformTransactionManager.class);
 		PlatformTransactionManagerFacade.delegate = ptm;
 
 		assertTrue("Age should not be " + testBean.getAge(), testBean.getAge() == 666);
-		// Check no calls
-		ptmControl.verify();
+
+		// Expect no methods
+		verifyZeroInteractions(ptm);
 
 		// Install facade expecting a call
-		MockControl statusControl = MockControl.createControl(TransactionStatus.class);
-		final TransactionStatus ts = (TransactionStatus) statusControl.getMock();
+		final TransactionStatus ts = mock(TransactionStatus.class);
 		ptm = new PlatformTransactionManager() {
 			private boolean invoked;
 			@Override
@@ -158,11 +156,11 @@ public void rollback(TransactionStatus status) throws TransactionException {
 		int age = 666;
 		testBean.setAge(age);
 		assertTrue(testBean.getAge() == age);
-		ptmControl.verify();
 	}
 
 	public void testGetBeansOfTypeWithAbstract() {
 		Map beansOfType = factory.getBeansOfType(ITestBean.class, true, true);
+		assertNotNull(beansOfType);
 	}
 
 	/**
@@ -172,7 +170,7 @@ public void testNoTransactionAttributeSource() {
 		try {
 			DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
 			new XmlBeanDefinitionReader(bf).loadBeanDefinitions(new ClassPathResource("noTransactionAttributeSource.xml", getClass()));
-			ITestBean testBean = (ITestBean) bf.getBean("noTransactionAttributeSource");
+			bf.getBean("noTransactionAttributeSource");
 			fail("Should require TransactionAttributeSource to be set");
 		}
 		catch (FatalBeanException ex) {
diff --git a/spring-tx/src/test/java/org/springframework/transaction/jta/WebSphereUowTransactionManagerTests.java b/spring-tx/src/test/java/org/springframework/transaction/jta/WebSphereUowTransactionManagerTests.java
index 5630bd821974..802b7fd028c8 100644
--- a/spring-tx/src/test/java/org/springframework/transaction/jta/WebSphereUowTransactionManagerTests.java
+++ b/spring-tx/src/test/java/org/springframework/transaction/jta/WebSphereUowTransactionManagerTests.java
@@ -20,11 +20,7 @@
 import javax.transaction.Status;
 import javax.transaction.UserTransaction;
 
-import com.ibm.wsspi.uow.UOWAction;
-import com.ibm.wsspi.uow.UOWException;
-import com.ibm.wsspi.uow.UOWManager;
 import junit.framework.TestCase;
-import org.easymock.MockControl;
 
 import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.tests.mock.jndi.ExpectedLookupTemplate;
@@ -37,6 +33,12 @@
 import org.springframework.transaction.support.TransactionCallback;
 import org.springframework.transaction.support.TransactionSynchronizationManager;
 
+import com.ibm.wsspi.uow.UOWAction;
+import com.ibm.wsspi.uow.UOWException;
+import com.ibm.wsspi.uow.UOWManager;
+
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  */
@@ -64,17 +66,8 @@ public Object doInTransaction(TransactionStatus status) {
 	}
 
 	public void testUowManagerAndUserTransactionFoundInJndi() throws Exception {
-		MockControl utControl = MockControl.createControl(UserTransaction.class);
-		UserTransaction ut = (UserTransaction) utControl.getMock();
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_NO_TRANSACTION, 1);
-		ut.getStatus();
-		utControl.setReturnValue(Status.STATUS_ACTIVE, 2);
-		ut.begin();
-		utControl.setVoidCallable(1);
-		ut.commit();
-		utControl.setVoidCallable(1);
-		utControl.replay();
+		UserTransaction ut = mock(UserTransaction.class);
+		given(ut.getStatus()).willReturn( Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE);
 
 		MockUOWManager manager = new MockUOWManager();
 		ExpectedLookupTemplate jndiTemplate = new ExpectedLookupTemplate();
@@ -97,6 +90,8 @@ public Object doInTransaction(TransactionStatus status) {
 		assertEquals(UOWManager.UOW_TYPE_GLOBAL_TRANSACTION, manager.getUOWType());
 		assertFalse(manager.getJoined());
 		assertFalse(manager.getRollbackOnly());
+		verify(ut).begin();
+		verify(ut).commit();
 	}
 
 	public void testPropagationMandatoryFailsInCaseOfNoExistingTransaction() {
diff --git a/spring-tx/src/test/java/org/springframework/transaction/support/JtaTransactionManagerSerializationTests.java b/spring-tx/src/test/java/org/springframework/transaction/support/JtaTransactionManagerSerializationTests.java
index ff819d3ede57..c0c567c1d3d8 100644
--- a/spring-tx/src/test/java/org/springframework/transaction/support/JtaTransactionManagerSerializationTests.java
+++ b/spring-tx/src/test/java/org/springframework/transaction/support/JtaTransactionManagerSerializationTests.java
@@ -16,8 +16,6 @@
 
 package org.springframework.transaction.support;
 
-import static org.easymock.EasyMock.createMock;
-
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
@@ -27,15 +25,17 @@
 import org.springframework.transaction.jta.JtaTransactionManager;
 import org.springframework.util.SerializationTestUtils;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  */
 public class JtaTransactionManagerSerializationTests extends TestCase {
 
 	public void testSerializable() throws Exception {
-		UserTransaction ut1 = createMock(UserTransaction.class);
-		UserTransaction ut2 = createMock(UserTransaction.class);
-		TransactionManager tm = createMock(TransactionManager.class);
+		UserTransaction ut1 = mock(UserTransaction.class);
+		UserTransaction ut2 = mock(UserTransaction.class);
+		TransactionManager tm = mock(TransactionManager.class);
 
 		JtaTransactionManager jtam = new JtaTransactionManager();
 		jtam.setUserTransaction(ut1);
diff --git a/spring-web/src/main/java/org/springframework/http/HttpStatus.java b/spring-web/src/main/java/org/springframework/http/HttpStatus.java
index 74dc2af2c216..225fbccd9f7b 100644
--- a/spring-web/src/main/java/org/springframework/http/HttpStatus.java
+++ b/spring-web/src/main/java/org/springframework/http/HttpStatus.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -125,7 +125,9 @@ public enum HttpStatus {
 	/**
 	 * {@code 302 Moved Temporarily}.
 	 * @see <a href="http://tools.ietf.org/html/rfc1945#section-9.3">HTTP/1.0</a>
+	 * @deprecated In favor of {@link #FOUND} which will be returned from {@code HttpStatus.valueOf(302)}
 	 */
+	@Deprecated
 	MOVED_TEMPORARILY(302, "Moved Temporarily"),
 	/**
 	 * {@code 303 See Other}.
diff --git a/spring-web/src/main/java/org/springframework/http/InvalidMediaTypeException.java b/spring-web/src/main/java/org/springframework/http/InvalidMediaTypeException.java
new file mode 100644
index 000000000000..358c9c8226a0
--- /dev/null
+++ b/spring-web/src/main/java/org/springframework/http/InvalidMediaTypeException.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.http;
+
+/**
+ * Exception thrown from {@link MediaType#parseMediaType(String)} in case of
+ * encountering an invalid media type specification String.
+ *
+ * @author Juergen Hoeller
+ * @since 3.2.2
+ */
+@SuppressWarnings("serial")
+public class InvalidMediaTypeException extends IllegalArgumentException {
+
+	private String mediaType;
+
+
+	/**
+	 * Create a new InvalidMediaTypeException for the given media type.
+	 * @param mediaType the offending media type
+	 * @param msg a detail message indicating the invalid part
+	 */
+	public InvalidMediaTypeException(String mediaType, String msg) {
+		super("Invalid media type \"" + mediaType + "\": " + msg);
+		this.mediaType = mediaType;
+
+	}
+
+
+	/**
+	 * Return the offending media type.
+	 */
+	public String getMediaType() {
+		return this.mediaType;
+	}
+
+}
diff --git a/spring-web/src/main/java/org/springframework/http/MediaType.java b/spring-web/src/main/java/org/springframework/http/MediaType.java
index 99e1b2d12499..9f527c7c8ced 100644
--- a/spring-web/src/main/java/org/springframework/http/MediaType.java
+++ b/spring-web/src/main/java/org/springframework/http/MediaType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package org.springframework.http;
 
 import java.nio.charset.Charset;
+import java.nio.charset.UnsupportedCharsetException;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collection;
@@ -321,8 +322,8 @@ public MediaType(MediaType other, Map<String, String> parameters) {
 	 * @throws IllegalArgumentException if any of the parameters contain illegal characters
 	 */
 	public MediaType(String type, String subtype, Map<String, String> parameters) {
-		Assert.hasLength(type, "'type' must not be empty");
-		Assert.hasLength(subtype, "'subtype' must not be empty");
+		Assert.hasLength(type, "type must not be empty");
+		Assert.hasLength(subtype, "subtype must not be empty");
 		checkToken(type);
 		checkToken(subtype);
 		this.type = type.toLowerCase(Locale.ENGLISH);
@@ -347,11 +348,11 @@ public MediaType(String type, String subtype, Map<String, String> parameters) {
 	 * @throws IllegalArgumentException in case of illegal characters
 	 * @see <a href="http://tools.ietf.org/html/rfc2616#section-2.2">HTTP 1.1, section 2.2</a>
 	 */
-	private void checkToken(String s) {
-		for (int i=0; i < s.length(); i++ ) {
-			char ch = s.charAt(i);
+	private void checkToken(String token) {
+		for (int i=0; i < token.length(); i++ ) {
+			char ch = token.charAt(i);
 			if (!TOKEN.get(ch)) {
-				throw new IllegalArgumentException("Invalid token character '" + ch + "' in token \"" + s + "\"");
+				throw new IllegalArgumentException("Invalid token character '" + ch + "' in token \"" + token + "\"");
 			}
 		}
 	}
@@ -681,7 +682,7 @@ public static MediaType valueOf(String value) {
 	 * Parse the given String into a single {@code MediaType}.
 	 * @param mediaType the string to parse
 	 * @return the media type
-	 * @throws IllegalArgumentException if the string cannot be parsed
+	 * @throws InvalidMediaTypeException if the string cannot be parsed
 	 */
 	public static MediaType parseMediaType(String mediaType) {
 		Assert.hasLength(mediaType, "'mediaType' must not be empty");
@@ -694,15 +695,15 @@ public static MediaType parseMediaType(String mediaType) {
 		}
 		int subIndex = fullType.indexOf('/');
 		if (subIndex == -1) {
-			throw new IllegalArgumentException("\"" + mediaType + "\" does not contain '/'");
+			throw new InvalidMediaTypeException(mediaType, "does not contain '/'");
 		}
 		if (subIndex == fullType.length() - 1) {
-			throw new IllegalArgumentException("\"" + mediaType + "\" does not contain subtype after '/'");
+			throw new InvalidMediaTypeException(mediaType, "does not contain subtype after '/'");
 		}
 		String type = fullType.substring(0, subIndex);
 		String subtype = fullType.substring(subIndex + 1, fullType.length());
 		if (WILDCARD_TYPE.equals(type) && !WILDCARD_TYPE.equals(subtype)) {
-			throw new IllegalArgumentException("A wildcard type is legal only in '*/*' (all media types).");
+			throw new InvalidMediaTypeException(mediaType, "wildcard type is legal only in '*/*' (all media types)");
 		}
 
 		Map<String, String> parameters = null;
@@ -719,7 +720,15 @@ public static MediaType parseMediaType(String mediaType) {
 			}
 		}
 
-		return new MediaType(type, subtype, parameters);
+		try {
+			return new MediaType(type, subtype, parameters);
+		}
+		catch (UnsupportedCharsetException ex) {
+			throw new InvalidMediaTypeException(mediaType, "unsupported charset '" + ex.getCharsetName() + "'");
+		}
+		catch (IllegalArgumentException ex) {
+			throw new InvalidMediaTypeException(mediaType, ex.getMessage());
+		}
 	}
 
 
diff --git a/spring-web/src/main/java/org/springframework/http/client/BufferingClientHttpRequestWrapper.java b/spring-web/src/main/java/org/springframework/http/client/BufferingClientHttpRequestWrapper.java
index 813f98cfad98..bb8784442019 100644
--- a/spring-web/src/main/java/org/springframework/http/client/BufferingClientHttpRequestWrapper.java
+++ b/spring-web/src/main/java/org/springframework/http/client/BufferingClientHttpRequestWrapper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,7 +23,7 @@
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpMethod;
 import org.springframework.util.Assert;
-import org.springframework.util.FileCopyUtils;
+import org.springframework.util.StreamUtils;
 
 /**
  * Simple implementation of {@link ClientHttpRequest} that wraps another request.
@@ -53,8 +53,7 @@ public URI getURI() {
 	@Override
 	protected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException {
 		this.request.getHeaders().putAll(headers);
-		OutputStream body = this.request.getBody();
-		FileCopyUtils.copy(bufferedOutput, body);
+		StreamUtils.copy(bufferedOutput, this.request.getBody());
 		ClientHttpResponse response = this.request.execute();
 		return new BufferingClientHttpResponseWrapper(response);
 	}
diff --git a/spring-web/src/main/java/org/springframework/http/client/BufferingClientHttpResponseWrapper.java b/spring-web/src/main/java/org/springframework/http/client/BufferingClientHttpResponseWrapper.java
index f280790fec8e..f075b202bd52 100644
--- a/spring-web/src/main/java/org/springframework/http/client/BufferingClientHttpResponseWrapper.java
+++ b/spring-web/src/main/java/org/springframework/http/client/BufferingClientHttpResponseWrapper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,6 +23,7 @@
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpStatus;
 import org.springframework.util.FileCopyUtils;
+import org.springframework.util.StreamUtils;
 
 /**
  * Simple implementation of {@link ClientHttpResponse} that reads the request's body into memory,
@@ -61,7 +62,7 @@ public HttpHeaders getHeaders() {
 
 	public InputStream getBody() throws IOException {
 		if (this.body == null) {
-			this.body = FileCopyUtils.copyToByteArray(this.response.getBody());
+			this.body = StreamUtils.copyToByteArray(this.response.getBody());
 		}
 		return new ByteArrayInputStream(this.body);
 	}
diff --git a/spring-web/src/main/java/org/springframework/http/client/CommonsClientHttpResponse.java b/spring-web/src/main/java/org/springframework/http/client/CommonsClientHttpResponse.java
index 7cc8cec6e937..0e3f949da395 100644
--- a/spring-web/src/main/java/org/springframework/http/client/CommonsClientHttpResponse.java
+++ b/spring-web/src/main/java/org/springframework/http/client/CommonsClientHttpResponse.java
@@ -74,4 +74,4 @@ public void close() {
 		this.httpMethod.releaseConnection();
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/http/client/InterceptingClientHttpRequest.java b/spring-web/src/main/java/org/springframework/http/client/InterceptingClientHttpRequest.java
index 9d3976047991..a422614fe9f3 100644
--- a/spring-web/src/main/java/org/springframework/http/client/InterceptingClientHttpRequest.java
+++ b/spring-web/src/main/java/org/springframework/http/client/InterceptingClientHttpRequest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,7 +24,7 @@
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpMethod;
 import org.springframework.http.HttpRequest;
-import org.springframework.util.FileCopyUtils;
+import org.springframework.util.StreamUtils;
 
 /**
  * Wrapper for a {@link ClientHttpRequest} that has support for {@link ClientHttpRequestInterceptor}s.
@@ -86,7 +86,7 @@ public ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOExc
 				delegate.getHeaders().putAll(request.getHeaders());
 
 				if (body.length > 0) {
-					FileCopyUtils.copy(body, delegate.getBody());
+					StreamUtils.copy(body, delegate.getBody());
 				}
 				return delegate.execute();
 			}
diff --git a/spring-web/src/main/java/org/springframework/http/client/SimpleBufferingClientHttpRequest.java b/spring-web/src/main/java/org/springframework/http/client/SimpleBufferingClientHttpRequest.java
index 989d9e4d2819..c2a786429644 100644
--- a/spring-web/src/main/java/org/springframework/http/client/SimpleBufferingClientHttpRequest.java
+++ b/spring-web/src/main/java/org/springframework/http/client/SimpleBufferingClientHttpRequest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -39,9 +39,12 @@ final class SimpleBufferingClientHttpRequest extends AbstractBufferingClientHttp
 
 	private final HttpURLConnection connection;
 
+	private final boolean outputStreaming;
 
-	SimpleBufferingClientHttpRequest(HttpURLConnection connection) {
+
+	SimpleBufferingClientHttpRequest(HttpURLConnection connection, boolean outputStreaming) {
 		this.connection = connection;
+		this.outputStreaming = outputStreaming;
 	}
 
 
@@ -67,7 +70,7 @@ protected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] buffere
 			}
 		}
 
-		if (this.connection.getDoOutput()) {
+		if (this.connection.getDoOutput() && this.outputStreaming) {
 			this.connection.setFixedLengthStreamingMode(bufferedOutput.length);
 		}
 		this.connection.connect();
diff --git a/spring-web/src/main/java/org/springframework/http/client/SimpleClientHttpRequestFactory.java b/spring-web/src/main/java/org/springframework/http/client/SimpleClientHttpRequestFactory.java
index 22d17b50f0be..3aa31d9b839d 100644
--- a/spring-web/src/main/java/org/springframework/http/client/SimpleClientHttpRequestFactory.java
+++ b/spring-web/src/main/java/org/springframework/http/client/SimpleClientHttpRequestFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -50,6 +50,8 @@ public class SimpleClientHttpRequestFactory implements ClientHttpRequestFactory
 
 	private int readTimeout = -1;
 
+	private boolean outputStreaming = true;
+
 
 	/**
 	 * Set the {@link Proxy} to use for this request factory.
@@ -104,15 +106,31 @@ public void setReadTimeout(int readTimeout) {
 		this.readTimeout = readTimeout;
 	}
 
+	/**
+	 * Set if the underlying URLConnection can be set to 'output streaming' mode. When
+	 * output streaming is enabled, authentication and redirection cannot be handled
+	 * automatically. If output streaming is disabled the
+	 * {@link HttpURLConnection#setFixedLengthStreamingMode(int)
+	 * setFixedLengthStreamingMode} and
+	 * {@link HttpURLConnection#setChunkedStreamingMode(int) setChunkedStreamingMode}
+	 * methods of the underlying connection will never be called.
+	 * <p>Default is {@code true}.
+	 * @param outputStreaming if output streaming is enabled
+	 */
+	public void setOutputStreaming(boolean outputStreaming) {
+		this.outputStreaming = outputStreaming;
+	}
+
 
 	public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException {
 		HttpURLConnection connection = openConnection(uri.toURL(), this.proxy);
 		prepareConnection(connection, httpMethod.name());
 		if (this.bufferRequestBody) {
-			return new SimpleBufferingClientHttpRequest(connection);
+			return new SimpleBufferingClientHttpRequest(connection, this.outputStreaming);
 		}
 		else {
-			return new SimpleStreamingClientHttpRequest(connection, this.chunkSize);
+			return new SimpleStreamingClientHttpRequest(connection, this.chunkSize,
+					this.outputStreaming);
 		}
 	}
 
diff --git a/spring-web/src/main/java/org/springframework/http/client/SimpleStreamingClientHttpRequest.java b/spring-web/src/main/java/org/springframework/http/client/SimpleStreamingClientHttpRequest.java
index a5e831102c47..f14f7e9025d0 100644
--- a/spring-web/src/main/java/org/springframework/http/client/SimpleStreamingClientHttpRequest.java
+++ b/spring-web/src/main/java/org/springframework/http/client/SimpleStreamingClientHttpRequest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 
 package org.springframework.http.client;
 
-import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.net.HttpURLConnection;
@@ -27,6 +26,7 @@
 
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpMethod;
+import org.springframework.util.StreamUtils;
 
 /**
  * {@link ClientHttpRequest} implementation that uses standard J2SE facilities to execute streaming requests.
@@ -44,10 +44,14 @@ final class SimpleStreamingClientHttpRequest extends AbstractClientHttpRequest {
 
 	private OutputStream body;
 
+	private final boolean outputStreaming;
 
-	SimpleStreamingClientHttpRequest(HttpURLConnection connection, int chunkSize) {
+
+	SimpleStreamingClientHttpRequest(HttpURLConnection connection, int chunkSize,
+			boolean outputStreaming) {
 		this.connection = connection;
 		this.chunkSize = chunkSize;
+		this.outputStreaming = outputStreaming;
 	}
 
 	public HttpMethod getMethod() {
@@ -66,18 +70,20 @@ public URI getURI() {
 	@Override
 	protected OutputStream getBodyInternal(HttpHeaders headers) throws IOException {
 		if (this.body == null) {
-			int contentLength = (int) headers.getContentLength();
-			if (contentLength >= 0) {
-				this.connection.setFixedLengthStreamingMode(contentLength);
-			}
-			else {
-				this.connection.setChunkedStreamingMode(this.chunkSize);
+			if(this.outputStreaming) {
+				int contentLength = (int) headers.getContentLength();
+				if (contentLength >= 0) {
+					this.connection.setFixedLengthStreamingMode(contentLength);
+				}
+				else {
+					this.connection.setChunkedStreamingMode(this.chunkSize);
+				}
 			}
 			writeHeaders(headers);
 			this.connection.connect();
 			this.body = this.connection.getOutputStream();
 		}
-		return new NonClosingOutputStream(this.body);
+		return StreamUtils.nonClosing(this.body);
 	}
 
 	private void writeHeaders(HttpHeaders headers) {
@@ -106,26 +112,4 @@ protected ClientHttpResponse executeInternal(HttpHeaders headers) throws IOExcep
 		return new SimpleClientHttpResponse(this.connection);
 	}
 
-
-	private static class NonClosingOutputStream extends FilterOutputStream {
-
-		private NonClosingOutputStream(OutputStream out) {
-			super(out);
-		}
-
-		@Override
-		public void write(byte[] b) throws IOException {
-			super.write(b);
-		}
-
-		@Override
-		public void write(byte[] b, int off, int let) throws IOException {
-			out.write(b, off, let);
-		}
-
-		@Override
-		public void close() throws IOException {
-		}
-	}
-
 }
diff --git a/spring-web/src/main/java/org/springframework/http/converter/ByteArrayHttpMessageConverter.java b/spring-web/src/main/java/org/springframework/http/converter/ByteArrayHttpMessageConverter.java
index f1ddc0080f79..d1b25f7c353f 100644
--- a/spring-web/src/main/java/org/springframework/http/converter/ByteArrayHttpMessageConverter.java
+++ b/spring-web/src/main/java/org/springframework/http/converter/ByteArrayHttpMessageConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@
 import org.springframework.http.HttpInputMessage;
 import org.springframework.http.HttpOutputMessage;
 import org.springframework.http.MediaType;
-import org.springframework.util.FileCopyUtils;
+import org.springframework.util.StreamUtils;
 
 /**
  * Implementation of {@link HttpMessageConverter} that can read and write byte arrays.
@@ -49,14 +49,9 @@ public boolean supports(Class<?> clazz) {
 	@Override
 	public byte[] readInternal(Class clazz, HttpInputMessage inputMessage) throws IOException {
 		long contentLength = inputMessage.getHeaders().getContentLength();
-		if (contentLength >= 0) {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream((int) contentLength);
-			FileCopyUtils.copy(inputMessage.getBody(), bos);
-			return bos.toByteArray();
-		}
-		else {
-			return FileCopyUtils.copyToByteArray(inputMessage.getBody());
-		}
+		ByteArrayOutputStream bos = new ByteArrayOutputStream(contentLength >= 0 ? (int) contentLength : StreamUtils.BUFFER_SIZE);
+		StreamUtils.copy(inputMessage.getBody(), bos);
+		return bos.toByteArray();
 	}
 
 	@Override
@@ -66,7 +61,7 @@ protected Long getContentLength(byte[] bytes, MediaType contentType) {
 
 	@Override
 	protected void writeInternal(byte[] bytes, HttpOutputMessage outputMessage) throws IOException {
-		FileCopyUtils.copy(bytes, outputMessage.getBody());
+		StreamUtils.copy(bytes, outputMessage.getBody());
 	}
 
 }
diff --git a/spring-web/src/main/java/org/springframework/http/converter/FormHttpMessageConverter.java b/spring-web/src/main/java/org/springframework/http/converter/FormHttpMessageConverter.java
index f66a38bf192d..516eb92ab257 100644
--- a/spring-web/src/main/java/org/springframework/http/converter/FormHttpMessageConverter.java
+++ b/spring-web/src/main/java/org/springframework/http/converter/FormHttpMessageConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,7 +17,6 @@
 package org.springframework.http.converter;
 
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
@@ -37,9 +36,9 @@
 import org.springframework.http.HttpOutputMessage;
 import org.springframework.http.MediaType;
 import org.springframework.util.Assert;
-import org.springframework.util.FileCopyUtils;
 import org.springframework.util.LinkedMultiValueMap;
 import org.springframework.util.MultiValueMap;
+import org.springframework.util.StreamUtils;
 import org.springframework.util.StringUtils;
 
 /**
@@ -170,7 +169,7 @@ public MultiValueMap<String, String> read(Class<? extends MultiValueMap<String,
 
 		MediaType contentType = inputMessage.getHeaders().getContentType();
 		Charset charset = contentType.getCharSet() != null ? contentType.getCharSet() : this.charset;
-		String body = FileCopyUtils.copyToString(new InputStreamReader(inputMessage.getBody(), charset));
+		String body = StreamUtils.copyToString(inputMessage.getBody(), charset);
 
 		String[] pairs = StringUtils.tokenizeToStringArray(body, "&");
 
@@ -246,7 +245,7 @@ private void writeForm(MultiValueMap<String, String> form, MediaType contentType
 		}
 		byte[] bytes = builder.toString().getBytes(charset.name());
 		outputMessage.getHeaders().setContentLength(bytes.length);
-		FileCopyUtils.copy(bytes, outputMessage.getBody());
+		StreamUtils.copy(bytes, outputMessage.getBody());
 	}
 
 	private void writeMultipart(MultiValueMap<String, Object> parts, HttpOutputMessage outputMessage)
diff --git a/spring-web/src/main/java/org/springframework/http/converter/ResourceHttpMessageConverter.java b/spring-web/src/main/java/org/springframework/http/converter/ResourceHttpMessageConverter.java
index 9991fbcc8048..69f22a92e10a 100644
--- a/spring-web/src/main/java/org/springframework/http/converter/ResourceHttpMessageConverter.java
+++ b/spring-web/src/main/java/org/springframework/http/converter/ResourceHttpMessageConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2011 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+
 import javax.activation.FileTypeMap;
 import javax.activation.MimetypesFileTypeMap;
 
@@ -28,7 +29,7 @@
 import org.springframework.http.HttpOutputMessage;
 import org.springframework.http.MediaType;
 import org.springframework.util.ClassUtils;
-import org.springframework.util.FileCopyUtils;
+import org.springframework.util.StreamUtils;
 import org.springframework.util.StringUtils;
 
 /**
@@ -61,7 +62,7 @@ protected boolean supports(Class<?> clazz) {
 	protected Resource readInternal(Class<? extends Resource> clazz, HttpInputMessage inputMessage)
 			throws IOException, HttpMessageNotReadableException {
 
-		byte[] body = FileCopyUtils.copyToByteArray(inputMessage.getBody());
+		byte[] body = StreamUtils.copyToByteArray(inputMessage.getBody());
 		return new ByteArrayResource(body);
 	}
 
@@ -84,7 +85,7 @@ protected Long getContentLength(Resource resource, MediaType contentType) throws
 	protected void writeInternal(Resource resource, HttpOutputMessage outputMessage)
 			throws IOException, HttpMessageNotWritableException {
 
-		FileCopyUtils.copy(resource.getInputStream(), outputMessage.getBody());
+		StreamUtils.copy(resource.getInputStream(), outputMessage.getBody());
 		outputMessage.getBody().flush();
 	}
 
diff --git a/spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java b/spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java
index e995713d45f8..686ec93767b9 100644
--- a/spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java
+++ b/spring-web/src/main/java/org/springframework/http/converter/StringHttpMessageConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,8 +17,6 @@
 package org.springframework.http.converter;
 
 import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
 import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
@@ -27,7 +25,7 @@
 import org.springframework.http.HttpInputMessage;
 import org.springframework.http.HttpOutputMessage;
 import org.springframework.http.MediaType;
-import org.springframework.util.FileCopyUtils;
+import org.springframework.util.StreamUtils;
 
 /**
  * Implementation of {@link HttpMessageConverter} that can read and write strings.
@@ -84,7 +82,7 @@ public boolean supports(Class<?> clazz) {
 	@Override
 	protected String readInternal(Class<? extends String> clazz, HttpInputMessage inputMessage) throws IOException {
 		Charset charset = getContentTypeCharset(inputMessage.getHeaders().getContentType());
-		return FileCopyUtils.copyToString(new InputStreamReader(inputMessage.getBody(), charset));
+		return StreamUtils.copyToString(inputMessage.getBody(), charset);
 	}
 
 	@Override
@@ -105,7 +103,7 @@ protected void writeInternal(String s, HttpOutputMessage outputMessage) throws I
 			outputMessage.getHeaders().setAcceptCharset(getAcceptedCharsets());
 		}
 		Charset charset = getContentTypeCharset(outputMessage.getHeaders().getContentType());
-		FileCopyUtils.copy(s, new OutputStreamWriter(outputMessage.getBody(), charset));
+		StreamUtils.copy(s, charset, outputMessage.getBody());
 	}
 
 	/**
diff --git a/spring-web/src/main/java/org/springframework/http/converter/feed/RssChannelHttpMessageConverter.java b/spring-web/src/main/java/org/springframework/http/converter/feed/RssChannelHttpMessageConverter.java
index 7add4751ba16..08091984d9fd 100644
--- a/spring-web/src/main/java/org/springframework/http/converter/feed/RssChannelHttpMessageConverter.java
+++ b/spring-web/src/main/java/org/springframework/http/converter/feed/RssChannelHttpMessageConverter.java
@@ -43,5 +43,4 @@ protected boolean supports(Class<?> clazz) {
 		return Channel.class.isAssignableFrom(clazz);
 	}
 
-
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManager.java b/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManager.java
index 961ffdcc72e7..0024eef27db1 100644
--- a/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManager.java
+++ b/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -55,6 +56,7 @@ public class ContentNegotiationManager implements ContentNegotiationStrategy, Me
 	private final Set<MediaTypeFileExtensionResolver> fileExtensionResolvers =
 			new LinkedHashSet<MediaTypeFileExtensionResolver>();
 
+
 	/**
 	 * Create an instance with the given ContentNegotiationStrategy instances.
 	 * <p>Each instance is checked to see if it is also an implementation of
@@ -72,12 +74,29 @@ public ContentNegotiationManager(ContentNegotiationStrategy... strategies) {
 	}
 
 	/**
-	 * Create an instance with a {@link HeaderContentNegotiationStrategy}.
+	 * Create an instance with the given ContentNegotiationStrategy instances.
+	 * <p>Each instance is checked to see if it is also an implementation of
+	 * MediaTypeFileExtensionResolver, and if so it is registered as such.
+	 * @param strategies one more more ContentNegotiationStrategy instances
+	 */
+	public ContentNegotiationManager(Collection<ContentNegotiationStrategy> strategies) {
+		Assert.notEmpty(strategies, "At least one ContentNegotiationStrategy is expected");
+		this.contentNegotiationStrategies.addAll(strategies);
+		for (ContentNegotiationStrategy strategy : this.contentNegotiationStrategies) {
+			if (strategy instanceof MediaTypeFileExtensionResolver) {
+				this.fileExtensionResolvers.add((MediaTypeFileExtensionResolver) strategy);
+			}
+		}
+	}
+
+	/**
+	 * Create a default instance with a {@link HeaderContentNegotiationStrategy}.
 	 */
 	public ContentNegotiationManager() {
 		this(new HeaderContentNegotiationStrategy());
 	}
 
+
 	/**
 	 * Add MediaTypeFileExtensionResolver instances.
 	 * <p>Note that some {@link ContentNegotiationStrategy} implementations also
diff --git a/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.java b/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.java
index 8cf79f927d49..a5d0357d91e7 100644
--- a/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.java
+++ b/spring-web/src/main/java/org/springframework/web/accept/ContentNegotiationManagerFactoryBean.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.springframework.web.accept;
 
 import java.util.ArrayList;
@@ -22,7 +23,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Properties;
-
 import javax.servlet.ServletContext;
 
 import org.springframework.beans.factory.FactoryBean;
@@ -39,13 +39,13 @@
  * <p>By default strategies for checking the extension of the request path and
  * the {@code Accept} header are registered. The path extension check will perform
  * lookups through the {@link ServletContext} and the Java Activation Framework
- * (if present) unless {@linkplain #setMediaTypes(Properties) media types} are configured.
+ * (if present) unless {@linkplain #setMediaTypes media types} are configured.
  *
  * @author Rossen Stoyanchev
  * @since 3.2
  */
 public class ContentNegotiationManagerFactoryBean
-		implements FactoryBean<ContentNegotiationManager>, InitializingBean, ServletContextAware {
+		implements FactoryBean<ContentNegotiationManager>, ServletContextAware, InitializingBean {
 
 	private boolean favorPathExtension = true;
 
@@ -65,6 +65,7 @@ public class ContentNegotiationManagerFactoryBean
 
 	private ServletContext servletContext;
 
+
 	/**
 	 * Indicate whether the extension of the request path should be used to determine
 	 * the requested media type with the <em>highest priority</em>.
@@ -81,7 +82,6 @@ public void setFavorPathExtension(boolean favorPathExtension) {
 	 * <p>When this mapping is not set or when an extension is not found, the Java
 	 * Action Framework, if available, may be used if enabled via
 	 * {@link #setFavorPathExtension(boolean)}.
-	 *
 	 * @see #addMediaType(String, MediaType)
 	 * @see #addMediaTypes(Map)
 	 */
@@ -121,9 +121,8 @@ public void addMediaTypes(Map<String, MediaType> mediaTypes) {
 	 * to map from file extensions to media types. This is used only when
 	 * {@link #setFavorPathExtension(boolean)} is set to {@code true}.
 	 * <p>The default value is {@code true}.
-	 *
-	 * @see #parameterName
-	 * @see #setMediaTypes(Properties)
+	 * @see #setParameterName
+	 * @see #setMediaTypes
 	 */
 	public void setUseJaf(boolean useJaf) {
 		this.useJaf = useJaf;
@@ -138,8 +137,7 @@ public void setUseJaf(boolean useJaf) {
 	 * {@code "application/pdf"} regardless of the {@code Accept} header.
 	 * <p>To use this option effectively you must also configure the MediaType
 	 * type mappings via {@link #setMediaTypes(Properties)}.
-	 *
-	 * @see #setParameterName(String)
+	 * @see #setParameterName
 	 */
 	public void setFavorParameter(boolean favorParameter) {
 		this.favorParameter = favorParameter;
@@ -180,7 +178,8 @@ public void setServletContext(ServletContext servletContext) {
 		this.servletContext = servletContext;
 	}
 
-	public void afterPropertiesSet() throws Exception {
+
+	public void afterPropertiesSet() {
 		List<ContentNegotiationStrategy> strategies = new ArrayList<ContentNegotiationStrategy>();
 
 		if (this.favorPathExtension) {
@@ -210,8 +209,12 @@ public void afterPropertiesSet() throws Exception {
 			strategies.add(new FixedContentNegotiationStrategy(this.defaultContentType));
 		}
 
-		ContentNegotiationStrategy[] array = strategies.toArray(new ContentNegotiationStrategy[strategies.size()]);
-		this.contentNegotiationManager = new ContentNegotiationManager(array);
+		this.contentNegotiationManager = new ContentNegotiationManager(strategies);
+	}
+
+
+	public ContentNegotiationManager getObject() {
+		return this.contentNegotiationManager;
 	}
 
 	public Class<?> getObjectType() {
@@ -222,8 +225,4 @@ public boolean isSingleton() {
 		return true;
 	}
 
-	public ContentNegotiationManager getObject() throws Exception {
-		return this.contentNegotiationManager;
-	}
-
 }
diff --git a/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestParam.java b/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestParam.java
index 43032ba59811..b1395b498526 100644
--- a/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestParam.java
+++ b/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestParam.java
@@ -68,8 +68,9 @@
 	boolean required() default true;
 
 	/**
-	 * The default value to use as a fallback. Supplying a default value implicitly
-	 * sets {@link #required()} to false.
+	 * The default value to use as a fallback when the request parameter value
+	 * is not provided or empty. Supplying a default value implicitly sets
+	 * {@link #required()} to false.
 	 */
 	String defaultValue() default ValueConstants.DEFAULT_NONE;
 
diff --git a/spring-web/src/main/java/org/springframework/web/bind/annotation/ResponseBody.java b/spring-web/src/main/java/org/springframework/web/bind/annotation/ResponseBody.java
index fe7fac62cd47..69ec80110315 100644
--- a/spring-web/src/main/java/org/springframework/web/bind/annotation/ResponseBody.java
+++ b/spring-web/src/main/java/org/springframework/web/bind/annotation/ResponseBody.java
@@ -36,4 +36,4 @@
 @Documented
 public @interface ResponseBody {
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/bind/support/WebDataBinderFactory.java b/spring-web/src/main/java/org/springframework/web/bind/support/WebDataBinderFactory.java
index 03f13d86ff63..e37776a3c87e 100644
--- a/spring-web/src/main/java/org/springframework/web/bind/support/WebDataBinderFactory.java
+++ b/spring-web/src/main/java/org/springframework/web/bind/support/WebDataBinderFactory.java
@@ -37,4 +37,4 @@ public interface WebDataBinderFactory {
 	 */
 	WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName) throws Exception;
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/context/request/NativeWebRequest.java b/spring-web/src/main/java/org/springframework/web/context/request/NativeWebRequest.java
index 2b0df14d95ab..855409907659 100644
--- a/spring-web/src/main/java/org/springframework/web/context/request/NativeWebRequest.java
+++ b/spring-web/src/main/java/org/springframework/web/context/request/NativeWebRequest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -56,13 +56,13 @@ public interface NativeWebRequest extends WebRequest {
 	<T> T getNativeRequest(Class<T> requiredType);
 
 	/**
-	 * Return the underlying native request object, if available.
+	 * Return the underlying native response object, if available.
 	 * @param requiredType the desired type of response object
 	 * @return the matching response object, or {@code null} if none
 	 * of that type is available
-	 * @see javax.servlet.http.HttpServletRequest
-	 * @see javax.portlet.ActionRequest
-	 * @see javax.portlet.RenderRequest
+	 * @see javax.servlet.http.HttpServletResponse
+	 * @see javax.portlet.ActionResponse
+	 * @see javax.portlet.RenderResponse
 	 */
 	<T> T getNativeResponse(Class<T> requiredType);
 
diff --git a/spring-web/src/main/java/org/springframework/web/context/request/RequestAttributes.java b/spring-web/src/main/java/org/springframework/web/context/request/RequestAttributes.java
index 8286de1bebeb..71568c0a47c6 100644
--- a/spring-web/src/main/java/org/springframework/web/context/request/RequestAttributes.java
+++ b/spring-web/src/main/java/org/springframework/web/context/request/RequestAttributes.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -135,14 +135,14 @@ public interface RequestAttributes {
 
 	/**
 	 * Return an id for the current underlying session.
-	 * @return the session id as String (never {@code null}
+	 * @return the session id as String (never {@code null})
 	 */
 	String getSessionId();
 
 	/**
 	 * Expose the best available mutex for the underlying session:
 	 * that is, an object to synchronize on for the underlying session.
-	 * @return the session mutex to use (never {@code null}
+	 * @return the session mutex to use (never {@code null})
 	 */
 	Object getSessionMutex();
 
diff --git a/spring-web/src/main/java/org/springframework/web/method/HandlerMethod.java b/spring-web/src/main/java/org/springframework/web/method/HandlerMethod.java
index 9ed46d9cf202..aec22e4d5a30 100644
--- a/spring-web/src/main/java/org/springframework/web/method/HandlerMethod.java
+++ b/spring-web/src/main/java/org/springframework/web/method/HandlerMethod.java
@@ -54,7 +54,7 @@ public class HandlerMethod {
 
 	private final BeanFactory beanFactory;
 
-	private MethodParameter[] parameters;
+	private final MethodParameter[] parameters;
 
 	private final Method bridgedMethod;
 
@@ -69,6 +69,16 @@ public HandlerMethod(Object bean, Method method) {
 		this.beanFactory = null;
 		this.method = method;
 		this.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
+		this.parameters = initMethodParameters();
+	}
+
+	private MethodParameter[] initMethodParameters() {
+		int count = this.bridgedMethod.getParameterTypes().length;
+		MethodParameter[] result = new MethodParameter[count];
+		for (int i = 0; i < count; i++) {
+			result[i] = new HandlerMethodParameter(i);
+		}
+		return result;
 	}
 
 	/**
@@ -82,6 +92,7 @@ public HandlerMethod(Object bean, String methodName, Class<?>... parameterTypes)
 		this.beanFactory = null;
 		this.method = bean.getClass().getMethod(methodName, parameterTypes);
 		this.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
+		this.parameters = initMethodParameters();
 	}
 
 	/**
@@ -99,10 +110,11 @@ public HandlerMethod(String beanName, BeanFactory beanFactory, Method method) {
 		this.beanFactory = beanFactory;
 		this.method = method;
 		this.bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
+		this.parameters = initMethodParameters();
 	}
 
 	/**
-	 * Create an instance from another {@code HandlerMethod}.
+	 * Copy constructor for use in sub-classes.
 	 */
 	protected HandlerMethod(HandlerMethod handlerMethod) {
 		Assert.notNull(handlerMethod, "HandlerMethod is required");
@@ -113,6 +125,19 @@ protected HandlerMethod(HandlerMethod handlerMethod) {
 		this.parameters = handlerMethod.parameters;
 	}
 
+	/**
+	 * Re-create HandlerMethod with the resolved handler.
+	 */
+	private HandlerMethod(HandlerMethod handlerMethod, Object handler) {
+		Assert.notNull(handlerMethod, "handlerMethod is required");
+		Assert.notNull(handler, "handler is required");
+		this.bean = handler;
+		this.beanFactory = handlerMethod.beanFactory;
+		this.method = handlerMethod.method;
+		this.bridgedMethod = handlerMethod.bridgedMethod;
+		this.parameters = handlerMethod.parameters;
+	}
+
 	/**
 	 * Returns the bean for this handler method.
 	 */
@@ -150,13 +175,6 @@ protected Method getBridgedMethod() {
 	 * Returns the method parameters for this handler method.
 	 */
 	public MethodParameter[] getMethodParameters() {
-		if (this.parameters == null) {
-			int parameterCount = this.bridgedMethod.getParameterTypes().length;
-			this.parameters = new MethodParameter[parameterCount];
-			for (int i = 0; i < parameterCount; i++) {
-				this.parameters[i] = new HandlerMethodParameter(i);
-			}
-		}
 		return this.parameters;
 	}
 
@@ -201,9 +219,7 @@ public HandlerMethod createWithResolvedBean() {
 			String beanName = (String) this.bean;
 			handler = this.beanFactory.getBean(beanName);
 		}
-		HandlerMethod handlerMethod = new HandlerMethod(handler, this.method);
-		handlerMethod.parameters = getMethodParameters();
-		return handlerMethod;
+		return new HandlerMethod(this, handler);
 	}
 
 	@Override
diff --git a/spring-web/src/main/java/org/springframework/web/method/HandlerMethodSelector.java b/spring-web/src/main/java/org/springframework/web/method/HandlerMethodSelector.java
index 4d93eff7f2ce..fc43fc5f8b5c 100644
--- a/spring-web/src/main/java/org/springframework/web/method/HandlerMethodSelector.java
+++ b/spring-web/src/main/java/org/springframework/web/method/HandlerMethodSelector.java
@@ -69,4 +69,4 @@ public void doWith(Method method) {
 		return handlerMethods;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractCookieValueMethodArgumentResolver.java b/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractCookieValueMethodArgumentResolver.java
index 07c44b32a880..cd14b2e3aecd 100644
--- a/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractCookieValueMethodArgumentResolver.java
+++ b/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractCookieValueMethodArgumentResolver.java
@@ -71,4 +71,4 @@ private CookieValueNamedValueInfo(CookieValue annotation) {
 			super(annotation.value(), annotation.required(), annotation.defaultValue());
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractNamedValueMethodArgumentResolver.java b/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractNamedValueMethodArgumentResolver.java
index 9e35288687cf..a51547921012 100644
--- a/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractNamedValueMethodArgumentResolver.java
+++ b/spring-web/src/main/java/org/springframework/web/method/annotation/AbstractNamedValueMethodArgumentResolver.java
@@ -92,6 +92,9 @@ else if (namedValueInfo.required) {
 			}
 			arg = handleNullValue(namedValueInfo.name, arg, paramType);
 		}
+		else if ("".equals(arg) && (namedValueInfo.defaultValue != null)) {
+			arg = resolveDefaultValue(namedValueInfo.defaultValue);
+		}
 
 		if (binderFactory != null) {
 			WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);
diff --git a/spring-web/src/main/java/org/springframework/web/method/annotation/ExpressionValueMethodArgumentResolver.java b/spring-web/src/main/java/org/springframework/web/method/annotation/ExpressionValueMethodArgumentResolver.java
index 92a2aa88d13c..d93a6d43a3b6 100644
--- a/spring-web/src/main/java/org/springframework/web/method/annotation/ExpressionValueMethodArgumentResolver.java
+++ b/spring-web/src/main/java/org/springframework/web/method/annotation/ExpressionValueMethodArgumentResolver.java
@@ -76,4 +76,4 @@ private ExpressionValueNamedValueInfo(Value annotation) {
 			super("@Value", false, annotation.value());
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/method/annotation/ModelFactory.java b/spring-web/src/main/java/org/springframework/web/method/annotation/ModelFactory.java
index ee5672cfa447..7366edef1204 100644
--- a/spring-web/src/main/java/org/springframework/web/method/annotation/ModelFactory.java
+++ b/spring-web/src/main/java/org/springframework/web/method/annotation/ModelFactory.java
@@ -243,4 +243,4 @@ private boolean isBindingCandidate(String attributeName, Object value) {
 				!(value instanceof Map) && !BeanUtils.isSimpleValueType(value.getClass()));
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/method/annotation/RequestHeaderMethodArgumentResolver.java b/spring-web/src/main/java/org/springframework/web/method/annotation/RequestHeaderMethodArgumentResolver.java
index e7b46bdb6a90..7e4fdb403675 100644
--- a/spring-web/src/main/java/org/springframework/web/method/annotation/RequestHeaderMethodArgumentResolver.java
+++ b/spring-web/src/main/java/org/springframework/web/method/annotation/RequestHeaderMethodArgumentResolver.java
@@ -87,4 +87,4 @@ private RequestHeaderNamedValueInfo(RequestHeader annotation) {
 			super(annotation.value(), annotation.required(), annotation.defaultValue());
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java b/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java
index 3f351595ecdb..2a532f4bed8c 100644
--- a/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java
+++ b/spring-web/src/main/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolver.java
@@ -212,4 +212,4 @@ private RequestParamNamedValueInfo(RequestParam annotation) {
 			super(annotation.value(), annotation.required(), annotation.defaultValue());
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodArgumentResolver.java b/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodArgumentResolver.java
index e2a7b7d7982d..b3c34427910e 100644
--- a/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodArgumentResolver.java
+++ b/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodArgumentResolver.java
@@ -62,4 +62,4 @@ Object resolveArgument(MethodParameter parameter,
 						   NativeWebRequest webRequest,
 						   WebDataBinderFactory binderFactory) throws Exception;
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodReturnValueHandler.java b/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodReturnValueHandler.java
index d97fe876d194..ae1afc1155f5 100644
--- a/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodReturnValueHandler.java
+++ b/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodReturnValueHandler.java
@@ -58,4 +58,4 @@ void handleReturnValue(Object returnValue,
 						   ModelAndViewContainer mavContainer,
 						   NativeWebRequest webRequest) throws Exception;
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java b/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java
index 103784e9c29b..60e67878b3f7 100644
--- a/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java
+++ b/spring-web/src/main/java/org/springframework/web/util/HierarchicalUriComponents.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package org.springframework.web.util;
 
 import java.io.ByteArrayOutputStream;
+import java.io.Serializable;
 import java.io.UnsupportedEncodingException;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -38,6 +39,7 @@
  * Extension of {@link UriComponents} for hierarchical URIs.
  *
  * @author Arjen Poutsma
+ * @author Phillip Webb
  * @since 3.1.3
  * @see <a href="http://tools.ietf.org/html/rfc3986#section-1.2.3">Hierarchical URIs</a>
  */
@@ -406,7 +408,10 @@ public URI toUri() {
 			else {
 				String path = getPath();
 				if (StringUtils.hasLength(path) && path.charAt(0) != PATH_DELIMITER) {
-					path = PATH_DELIMITER + path;
+					// Only prefix the path delimiter if something exists before it
+					if(getScheme() != null || getUserInfo() != null || getHost() != null || getPort() != -1) {
+						path = PATH_DELIMITER + path;
+					}
 				}
 				return new URI(getScheme(), getUserInfo(), getHost(), getPort(), path, getQuery(),
 						getFragment());
@@ -426,28 +431,15 @@ public boolean equals(Object obj) {
 			return false;
 		}
 		HierarchicalUriComponents other = (HierarchicalUriComponents) obj;
-		if (ObjectUtils.nullSafeEquals(getScheme(), other.getScheme())) {
-			return false;
-		}
-		if (ObjectUtils.nullSafeEquals(getUserInfo(), other.getUserInfo())) {
-			return false;
-		}
-		if (ObjectUtils.nullSafeEquals(getHost(), other.getHost())) {
-			return false;
-		}
-		if (this.port != other.port) {
-			return false;
-		}
-		if (!this.path.equals(other.path)) {
-			return false;
-		}
-		if (!this.queryParams.equals(other.queryParams)) {
-			return false;
-		}
-		if (ObjectUtils.nullSafeEquals(getFragment(), other.getFragment())) {
-			return false;
-		}
-		return true;
+		boolean rtn = true;
+		rtn &= ObjectUtils.nullSafeEquals(getScheme(), other.getScheme());
+		rtn &= ObjectUtils.nullSafeEquals(getUserInfo(), other.getUserInfo());
+		rtn &= ObjectUtils.nullSafeEquals(getHost(), other.getHost());
+		rtn &= getPort() == other.getPort();
+		rtn &= this.path.equals(other.path);
+		rtn &= this.queryParams.equals(other.queryParams);
+		rtn &= ObjectUtils.nullSafeEquals(getFragment(), other.getFragment());
+		return rtn;
 	}
 
 	@Override
@@ -615,7 +607,7 @@ protected boolean isPchar(int c) {
 	/**
 	 * Defines the contract for path (segments).
 	 */
-	interface PathComponent {
+	interface PathComponent extends Serializable {
 
 		String getPath();
 
diff --git a/spring-web/src/main/java/org/springframework/web/util/JavaScriptUtils.java b/spring-web/src/main/java/org/springframework/web/util/JavaScriptUtils.java
index 0ee697f6d9a5..861b46fe55b1 100644
--- a/spring-web/src/main/java/org/springframework/web/util/JavaScriptUtils.java
+++ b/spring-web/src/main/java/org/springframework/web/util/JavaScriptUtils.java
@@ -80,6 +80,20 @@ else if (c == '\b') {
 			else if (c == '\013') {
 				filtered.append("\\v");
 			}
+			else if (c == '<') {
+				filtered.append("\\u003C");
+			}
+			else if (c == '>') {
+				filtered.append("\\u003E");
+			}
+			// Unicode for PS (line terminator in ECMA-262)
+			else if (c == '\u2028') {
+				filtered.append("\\u2028");
+			}
+			// Unicode for LS (line terminator in ECMA-262)
+			else if (c == '\u2029') {
+				filtered.append("\\u2029");
+			}
 			else {
 				filtered.append(c);
 			}
diff --git a/spring-web/src/main/java/org/springframework/web/util/Log4jWebConfigurer.java b/spring-web/src/main/java/org/springframework/web/util/Log4jWebConfigurer.java
index 63211beaf5b0..8b50ac6fda12 100644
--- a/spring-web/src/main/java/org/springframework/web/util/Log4jWebConfigurer.java
+++ b/spring-web/src/main/java/org/springframework/web/util/Log4jWebConfigurer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,12 +17,10 @@
 package org.springframework.web.util;
 
 import java.io.FileNotFoundException;
-
 import javax.servlet.ServletContext;
 
 import org.springframework.util.Log4jConfigurer;
 import org.springframework.util.ResourceUtils;
-import org.springframework.util.SystemPropertyUtils;
 
 /**
  * Convenience class that performs custom log4j initialization for web environments,
@@ -90,6 +88,7 @@
  * context-param at all) without worrying.
  *
  * @author Juergen Hoeller
+ * @author Marten Deinum
  * @since 12.08.2003
  * @see org.springframework.util.Log4jConfigurer
  * @see Log4jConfigListener
@@ -122,9 +121,8 @@ public static void initLogging(ServletContext servletContext) {
 		if (location != null) {
 			// Perform actual log4j initialization; else rely on log4j's default initialization.
 			try {
-				// Resolve system property placeholders before potentially
-				// resolving a real path.
-				location = SystemPropertyUtils.resolvePlaceholders(location);
+				// Resolve property placeholders before potentially resolving a real path.
+				location = ServletContextPropertyUtils.resolvePlaceholders(location, servletContext);
 
 				// Leave a URL (e.g. "classpath:" or "file:") as-is.
 				if (!ResourceUtils.isUrl(location)) {
diff --git a/spring-web/src/main/java/org/springframework/web/util/OpaqueUriComponents.java b/spring-web/src/main/java/org/springframework/web/util/OpaqueUriComponents.java
index 6e51c77dffdc..54d788d624e3 100644
--- a/spring-web/src/main/java/org/springframework/web/util/OpaqueUriComponents.java
+++ b/spring-web/src/main/java/org/springframework/web/util/OpaqueUriComponents.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,6 +30,7 @@
  * Extension of {@link UriComponents} for opaque URIs.
  *
  * @author Arjen Poutsma
+ * @author Phillip Webb
  * @since 3.2
  * @see <a href="http://tools.ietf.org/html/rfc3986#section-1.2.3">Hierarchical vs Opaque URIs</a>
  */
@@ -145,18 +146,11 @@ public boolean equals(Object obj) {
 		}
 
 		OpaqueUriComponents other = (OpaqueUriComponents) obj;
-
-		if (ObjectUtils.nullSafeEquals(getScheme(), other.getScheme())) {
-			return false;
-		}
-		if (ObjectUtils.nullSafeEquals(this.ssp, other.ssp)) {
-			return false;
-		}
-		if (ObjectUtils.nullSafeEquals(getFragment(), other.getFragment())) {
-			return false;
-		}
-
-		return true;
+		boolean rtn = true;
+		rtn &= ObjectUtils.nullSafeEquals(getScheme(), other.getScheme());
+		rtn &= ObjectUtils.nullSafeEquals(this.ssp, other.ssp);
+		rtn &= ObjectUtils.nullSafeEquals(getFragment(), other.getFragment());
+		return rtn;
 	}
 
 	@Override
diff --git a/spring-web/src/main/java/org/springframework/web/util/ServletContextPropertyUtils.java b/spring-web/src/main/java/org/springframework/web/util/ServletContextPropertyUtils.java
new file mode 100644
index 000000000000..46105f8aa03a
--- /dev/null
+++ b/spring-web/src/main/java/org/springframework/web/util/ServletContextPropertyUtils.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.web.util;
+
+import javax.servlet.ServletContext;
+
+import org.springframework.util.PropertyPlaceholderHelper;
+import org.springframework.util.SystemPropertyUtils;
+
+/**
+ * Helper class for resolving placeholders in texts. Usually applied to file paths.
+ *
+ * <p>A text may contain {@code ${...}} placeholders, to be resolved as servlet context
+ * init parameters or system properties: e.g. {@code ${user.dir}}. Default values can
+ * be supplied using the ":" separator between key and value.
+ *
+ * @author Juergen Hoeller
+ * @author Marten Deinum
+ * @since 3.2.2
+ * @see SystemPropertyUtils
+ * @see ServletContext#getInitParameter(String)
+ */
+public abstract class ServletContextPropertyUtils {
+
+    private static final PropertyPlaceholderHelper strictHelper =
+            new PropertyPlaceholderHelper(SystemPropertyUtils.PLACEHOLDER_PREFIX,
+					SystemPropertyUtils.PLACEHOLDER_SUFFIX, SystemPropertyUtils.VALUE_SEPARATOR, false);
+
+    private static final PropertyPlaceholderHelper nonStrictHelper =
+            new PropertyPlaceholderHelper(SystemPropertyUtils.PLACEHOLDER_PREFIX,
+					SystemPropertyUtils.PLACEHOLDER_SUFFIX, SystemPropertyUtils.VALUE_SEPARATOR, true);
+
+
+	/**
+	 * Resolve ${...} placeholders in the given text, replacing them with corresponding
+	 * servlet context init parameter or system property values.
+     * @param text the String to resolve
+     * @param servletContext the servletContext to use for lookups.
+	 * @return the resolved String
+	 * @see SystemPropertyUtils#PLACEHOLDER_PREFIX
+	 * @see SystemPropertyUtils#PLACEHOLDER_SUFFIX
+     * @see SystemPropertyUtils#resolvePlaceholders(String, boolean)
+	 * @throws IllegalArgumentException if there is an unresolvable placeholder
+	 */
+	public static String resolvePlaceholders(String text, ServletContext servletContext) {
+		return resolvePlaceholders(text, servletContext, false);
+	}
+
+	/**
+	 * Resolve ${...} placeholders in the given text, replacing them with corresponding
+	 * servlet context init parameter or system property values. Unresolvable placeholders
+	 * with no default value are ignored and passed through unchanged if the flag is set to true.
+	 * @param text the String to resolve
+     * @param servletContext the servletContext to use for lookups.
+	 * @param ignoreUnresolvablePlaceholders flag to determine is unresolved placeholders are ignored
+	 * @return the resolved String
+	 * @see SystemPropertyUtils#PLACEHOLDER_PREFIX
+	 * @see SystemPropertyUtils#PLACEHOLDER_SUFFIX
+     * @see SystemPropertyUtils#resolvePlaceholders(String, boolean)
+	 * @throws IllegalArgumentException if there is an unresolvable placeholder and the flag is false
+	 */
+	public static String resolvePlaceholders(String text, ServletContext servletContext, boolean ignoreUnresolvablePlaceholders) {
+		PropertyPlaceholderHelper helper = (ignoreUnresolvablePlaceholders ? nonStrictHelper : strictHelper);
+		return helper.replacePlaceholders(text, new ServletContextPlaceholderResolver(text, servletContext));
+	}
+
+
+	private static class ServletContextPlaceholderResolver implements PropertyPlaceholderHelper.PlaceholderResolver {
+
+        private final String text;
+
+        private final ServletContext servletContext;
+
+        public ServletContextPlaceholderResolver(String text, ServletContext servletContext) {
+            this.text = text;
+            this.servletContext = servletContext;
+        }
+
+        public String resolvePlaceholder(String placeholderName) {
+            try {
+                String propVal = this.servletContext.getInitParameter(placeholderName);
+				if (propVal == null) {
+					// Fall back to system properties.
+					propVal = System.getProperty(placeholderName);
+					if (propVal == null) {
+						// Fall back to searching the system environment.
+						propVal = System.getenv(placeholderName);
+					}
+				}
+				return propVal;
+			}
+            catch (Throwable ex) {
+                System.err.println("Could not resolve placeholder '" + placeholderName + "' in [" +
+                        this.text + "] as ServletContext init-parameter or system property: " + ex);
+                return null;
+            }
+        }
+    }
+
+}
diff --git a/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java b/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java
index 141cd7b86e2a..7fbd0178f235 100644
--- a/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java
+++ b/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,7 @@
 
 import java.net.URI;
 import java.util.ArrayList;
-import java.util.Collection;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Matcher;
@@ -29,6 +29,7 @@
 import org.springframework.util.MultiValueMap;
 import org.springframework.util.ObjectUtils;
 import org.springframework.util.StringUtils;
+import org.springframework.web.util.HierarchicalUriComponents.PathComponent;
 
 /**
  * Builder for {@link UriComponents}.
@@ -46,6 +47,8 @@
  *
  * @author Arjen Poutsma
  * @author Rossen Stoyanchev
+ * @author Phillip Webb
+ * @author Oliver Gierke
  * @since 3.1
  * @see #newInstance()
  * @see #fromPath(String)
@@ -53,7 +56,7 @@
  */
 public class UriComponentsBuilder {
 
-	private static final Pattern QUERY_PARAM_PATTERN = Pattern.compile("([^&=]+)=?([^&]+)?");
+	private static final Pattern QUERY_PARAM_PATTERN = Pattern.compile("([^&=]+)(=?)([^&]+)?");
 
 	private static final String SCHEME_PATTERN = "([^:/?#]+):";
 
@@ -91,7 +94,7 @@ public class UriComponentsBuilder {
 
 	private int port = -1;
 
-	private PathComponentBuilder pathBuilder = NULL_PATH_COMPONENT_BUILDER;
+	private CompositePathComponentBuilder pathBuilder = new CompositePathComponentBuilder();
 
 	private final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();
 
@@ -202,7 +205,10 @@ public static UriComponentsBuilder fromUriString(String uri) {
 				builder.path(path);
 				builder.query(query);
 			}
-			builder.fragment(fragment);
+
+			if (StringUtils.hasText(fragment)) {
+				builder.fragment(fragment);
+			}
 
 			return builder;
 		}
@@ -334,7 +340,7 @@ public UriComponentsBuilder uri(URI uri) {
 				this.port = uri.getPort();
 			}
 			if (StringUtils.hasLength(uri.getRawPath())) {
-				this.pathBuilder = new FullPathComponentBuilder(uri.getRawPath());
+				this.pathBuilder = new CompositePathComponentBuilder(uri.getRawPath());
 			}
 			if (StringUtils.hasLength(uri.getRawQuery())) {
 				this.queryParams.clear();
@@ -352,7 +358,7 @@ private void resetHierarchicalComponents() {
 		this.userInfo = null;
 		this.host = null;
 		this.port = -1;
-		this.pathBuilder = NULL_PATH_COMPONENT_BUILDER;
+		this.pathBuilder = new CompositePathComponentBuilder();
 		this.queryParams.clear();
 	}
 
@@ -436,12 +442,7 @@ public UriComponentsBuilder port(int port) {
 	 * @return this UriComponentsBuilder
 	 */
 	public UriComponentsBuilder path(String path) {
-		if (path != null) {
-			this.pathBuilder = this.pathBuilder.appendPath(path);
-		}
-		else {
-			this.pathBuilder = NULL_PATH_COMPONENT_BUILDER;
-		}
+		this.pathBuilder.addPath(path);
 		resetSchemeSpecificPart();
 		return this;
 	}
@@ -453,22 +454,21 @@ public UriComponentsBuilder path(String path) {
 	 * @return this UriComponentsBuilder
 	 */
 	public UriComponentsBuilder replacePath(String path) {
-		this.pathBuilder = NULL_PATH_COMPONENT_BUILDER;
-		path(path);
+		this.pathBuilder = new CompositePathComponentBuilder(path);
 		resetSchemeSpecificPart();
 		return this;
 	}
 
 	/**
-	 * Appends the given path segments to the existing path of this builder. Each given path segments may contain URI
-	 * template variables.
+	 * Appends the given path segments to the existing path of this builder. Each given
+	 * path segments may contain URI template variables.
 	 *
 	 * @param pathSegments the URI path segments
 	 * @return this UriComponentsBuilder
 	 */
 	public UriComponentsBuilder pathSegment(String... pathSegments) throws IllegalArgumentException {
 		Assert.notNull(pathSegments, "'segments' must not be null");
-		this.pathBuilder = this.pathBuilder.appendPathSegments(pathSegments);
+		this.pathBuilder.addPathSegments(pathSegments);
 		resetSchemeSpecificPart();
 		return this;
 	}
@@ -496,8 +496,10 @@ public UriComponentsBuilder query(String query) {
 			Matcher m = QUERY_PARAM_PATTERN.matcher(query);
 			while (m.find()) {
 				String name = m.group(1);
-				String value = m.group(2);
-				queryParam(name, value);
+				String eq = m.group(2);
+				String value = m.group(3);
+				queryParam(name, (value != null ? value :
+					(StringUtils.hasLength(eq) ? "" : null)));
 			}
 		}
 		else {
@@ -588,131 +590,122 @@ public UriComponentsBuilder fragment(String fragment) {
 		return this;
 	}
 
-	/**
-	 * Represents a builder for {@link HierarchicalUriComponents.PathComponent}
-	 */
-	private interface PathComponentBuilder {
-
-		HierarchicalUriComponents.PathComponent build();
 
-		PathComponentBuilder appendPath(String path);
-
-		PathComponentBuilder appendPathSegments(String... pathSegments);
+	private interface PathComponentBuilder {
+		PathComponent build();
 	}
 
-	/**
-	 * Represents a builder for full string paths.
-	 */
-	private static class FullPathComponentBuilder implements PathComponentBuilder {
+	private static class CompositePathComponentBuilder implements PathComponentBuilder {
 
-		private final StringBuilder path;
+		private LinkedList<PathComponentBuilder> componentBuilders = new LinkedList<PathComponentBuilder>();
 
-		private FullPathComponentBuilder(String path) {
-			this.path = new StringBuilder(path);
+		public CompositePathComponentBuilder() {
 		}
 
-		public HierarchicalUriComponents.PathComponent build() {
-			return new HierarchicalUriComponents.FullPathComponent(path.toString());
-		}
-
-		public PathComponentBuilder appendPath(String path) {
-			this.path.append(path);
-			return this;
-		}
-
-		public PathComponentBuilder appendPathSegments(String... pathSegments) {
-			PathComponentCompositeBuilder builder = new PathComponentCompositeBuilder(this);
-			builder.appendPathSegments(pathSegments);
-			return builder;
-		}
-	}
-
-	/**
-	 * Represents a builder for paths segment paths.
-	 */
-	private static class PathSegmentComponentBuilder implements PathComponentBuilder {
-
-		private final List<String> pathSegments = new ArrayList<String>();
-
-		private PathSegmentComponentBuilder(String... pathSegments) {
-			this.pathSegments.addAll(removeEmptyPathSegments(pathSegments));
+		public CompositePathComponentBuilder(String path) {
+			addPath(path);
 		}
 
-		private Collection<String> removeEmptyPathSegments(String... pathSegments) {
-			List<String> result = new ArrayList<String>();
-			for (String segment : pathSegments) {
-				if (StringUtils.hasText(segment)) {
-					result.add(segment);
+		public void addPathSegments(String... pathSegments) {
+			if (!ObjectUtils.isEmpty(pathSegments)) {
+				PathSegmentComponentBuilder psBuilder = getLastBuilder(PathSegmentComponentBuilder.class);
+				FullPathComponentBuilder fpBuilder = getLastBuilder(FullPathComponentBuilder.class);
+				if (psBuilder == null) {
+					psBuilder = new PathSegmentComponentBuilder();
+					this.componentBuilders.add(psBuilder);
+					if (fpBuilder != null) {
+						fpBuilder.removeTrailingSlash();
+					}
 				}
+				psBuilder.append(pathSegments);
 			}
-			return result;
 		}
 
-		public HierarchicalUriComponents.PathComponent build() {
-			return new HierarchicalUriComponents.PathSegmentComponent(pathSegments);
+		public void addPath(String path) {
+			if (StringUtils.hasText(path)) {
+				PathSegmentComponentBuilder psBuilder = getLastBuilder(PathSegmentComponentBuilder.class);
+				FullPathComponentBuilder fpBuilder = getLastBuilder(FullPathComponentBuilder.class);
+				if (psBuilder != null) {
+					path = path.startsWith("/") ? path : "/" + path;
+				}
+				if (fpBuilder == null) {
+					fpBuilder = new FullPathComponentBuilder();
+					this.componentBuilders.add(fpBuilder);
+				}
+				fpBuilder.append(path);
+			}
 		}
 
-		public PathComponentBuilder appendPath(String path) {
-			PathComponentCompositeBuilder builder = new PathComponentCompositeBuilder(this);
-			builder.appendPath(path);
-			return builder;
+		@SuppressWarnings("unchecked")
+		private <T> T getLastBuilder(Class<T> builderClass) {
+			if (!this.componentBuilders.isEmpty()) {
+				PathComponentBuilder last = this.componentBuilders.getLast();
+				if (builderClass.isInstance(last)) {
+					return (T) last;
+				}
+			}
+			return null;
 		}
 
-		public PathComponentBuilder appendPathSegments(String... pathSegments) {
-			this.pathSegments.addAll(removeEmptyPathSegments(pathSegments));
-			return this;
+		public PathComponent build() {
+			int size = this.componentBuilders.size();
+			List<PathComponent> components = new ArrayList<PathComponent>(size);
+			for (int i = 0; i < size; i++) {
+				PathComponent pathComponent = this.componentBuilders.get(i).build();
+				if (pathComponent != null) {
+					components.add(pathComponent);
+				}
+			}
+			if (components.isEmpty()) {
+				return HierarchicalUriComponents.NULL_PATH_COMPONENT;
+			}
+			if (components.size() == 1) {
+				return components.get(0);
+			}
+			return new HierarchicalUriComponents.PathComponentComposite(components);
 		}
 	}
 
-	/**
-	 * Represents a builder for a collection of PathComponents.
-	 */
-	private static class PathComponentCompositeBuilder implements PathComponentBuilder {
+	private static class FullPathComponentBuilder implements PathComponentBuilder {
 
-		private final List<PathComponentBuilder> pathComponentBuilders = new ArrayList<PathComponentBuilder>();
+		private StringBuilder path = new StringBuilder();
 
-		private PathComponentCompositeBuilder(PathComponentBuilder builder) {
-			pathComponentBuilders.add(builder);
+		public void append(String path) {
+			this.path.append(path);
 		}
 
-		public HierarchicalUriComponents.PathComponent build() {
-			List<HierarchicalUriComponents.PathComponent> pathComponents =
-					new ArrayList<HierarchicalUriComponents.PathComponent>(pathComponentBuilders.size());
-
-			for (PathComponentBuilder pathComponentBuilder : pathComponentBuilders) {
-				pathComponents.add(pathComponentBuilder.build());
+		public PathComponent build() {
+			if (this.path.length() == 0) {
+				return null;
 			}
-			return new HierarchicalUriComponents.PathComponentComposite(pathComponents);
-		}
-
-		public PathComponentBuilder appendPath(String path) {
-			this.pathComponentBuilders.add(new FullPathComponentBuilder(path));
-			return this;
+			String path = this.path.toString().replace("//", "/");
+			return new HierarchicalUriComponents.FullPathComponent(path);
 		}
 
-		public PathComponentBuilder appendPathSegments(String... pathSegments) {
-			this.pathComponentBuilders.add(new PathSegmentComponentBuilder(pathSegments));
-			return this;
+		public void removeTrailingSlash() {
+			int index = this.path.length() - 1;
+			if (this.path.charAt(index) == '/') {
+				this.path.deleteCharAt(index);
+			}
 		}
 	}
 
+	private static class PathSegmentComponentBuilder implements PathComponentBuilder {
 
-	/**
-	 * Represents a builder for an empty path.
-	 */
-	private static PathComponentBuilder NULL_PATH_COMPONENT_BUILDER = new PathComponentBuilder() {
-
-		public HierarchicalUriComponents.PathComponent build() {
-			return HierarchicalUriComponents.NULL_PATH_COMPONENT;
-		}
+		private List<String> pathSegments = new LinkedList<String>();
 
-		public PathComponentBuilder appendPath(String path) {
-			return new FullPathComponentBuilder(path);
+		public void append(String... pathSegments) {
+			for (String pathSegment : pathSegments) {
+				if (StringUtils.hasText(pathSegment)) {
+					this.pathSegments.add(pathSegment);
+				}
+			}
 		}
 
-		public PathComponentBuilder appendPathSegments(String... pathSegments) {
-			return new PathSegmentComponentBuilder(pathSegments);
+		public PathComponent build() {
+			return this.pathSegments.isEmpty() ?
+					null : new HierarchicalUriComponents.PathSegmentComponent(this.pathSegments);
 		}
-	};
+	}
 
 }
diff --git a/spring-web/src/main/java/org/springframework/web/util/UriTemplate.java b/spring-web/src/main/java/org/springframework/web/util/UriTemplate.java
index a8699042e97e..3aacd605592b 100644
--- a/spring-web/src/main/java/org/springframework/web/util/UriTemplate.java
+++ b/spring-web/src/main/java/org/springframework/web/util/UriTemplate.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,7 +32,7 @@
 
 /**
  * Represents a URI template. A URI template is a URI-like String that contains variables enclosed
- * by braces ({@code {}, {@code }}), which can be expanded to produce an actual URI.
+ * by braces ({@code {}}), which can be expanded to produce an actual URI.
  *
  * <p>See {@link #expand(Map)}, {@link #expand(Object[])}, and {@link #match(String)} for example usages.
  *
diff --git a/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java b/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java
index 7f98ee236961..362b9336580f 100644
--- a/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java
+++ b/spring-web/src/main/java/org/springframework/web/util/UrlPathHelper.java
@@ -441,10 +441,8 @@ protected String determineEncoding(HttpServletRequest request) {
 	 * @return the updated URI string
 	 */
 	public String removeSemicolonContent(String requestUri) {
-		if (this.removeSemicolonContent) {
-			return removeSemicolonContentInternal(requestUri);
-		}
-		return removeJsessionid(requestUri);
+		return this.removeSemicolonContent ?
+				removeSemicolonContentInternal(requestUri) : removeJsessionid(requestUri);
 	}
 
 	private String removeSemicolonContentInternal(String requestUri) {
diff --git a/spring-web/src/main/resources/META-INF/web-fragment.xml b/spring-web/src/main/resources/META-INF/web-fragment.xml
index d7c28cbccdbb..e687c8b58ecc 100644
--- a/spring-web/src/main/resources/META-INF/web-fragment.xml
+++ b/spring-web/src/main/resources/META-INF/web-fragment.xml
@@ -5,5 +5,6 @@
 	version="3.0" metadata-complete="true">
 
 	<name>spring_web</name>
+	<distributable/>
 
-</web-fragment>
\ No newline at end of file
+</web-fragment>
diff --git a/spring-web/src/test/java/org/springframework/http/MediaTypeTests.java b/spring-web/src/test/java/org/springframework/http/MediaTypeTests.java
index 906c8dec5880..d5657d199e78 100644
--- a/spring-web/src/test/java/org/springframework/http/MediaTypeTests.java
+++ b/spring-web/src/test/java/org/springframework/http/MediaTypeTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -97,12 +97,12 @@ public void testToString() throws Exception {
 		assertEquals("Invalid toString() returned", "text/plain;q=0.7", result);
 	}
 
-	@Test(expected= IllegalArgumentException.class)
+	@Test(expected = IllegalArgumentException.class)
 	public void slashInType() {
 		new MediaType("text/plain");
 	}
 
-	@Test(expected= IllegalArgumentException.class)
+	@Test(expected = IllegalArgumentException.class)
 	public void slashInSubtype() {
 		new MediaType("text", "/");
 	}
@@ -122,57 +122,57 @@ public void parseMediaType() throws Exception {
 		assertEquals("Invalid quality factor", 0.2D, mediaType.getQualityValue(), 0D);
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeNoSubtype() {
 		MediaType.parseMediaType("audio");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeNoSubtypeSlash() {
 		MediaType.parseMediaType("audio/");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeTypeRange() {
 		MediaType.parseMediaType("*/json");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeIllegalType() {
 		MediaType.parseMediaType("audio(/basic");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeIllegalSubtype() {
 		MediaType.parseMediaType("audio/basic)");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeEmptyParameterAttribute() {
 		MediaType.parseMediaType("audio/*;=value");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeEmptyParameterValue() {
 		MediaType.parseMediaType("audio/*;attr=");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeIllegalParameterAttribute() {
 		MediaType.parseMediaType("audio/*;attr<=value");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeIllegalParameterValue() {
 		MediaType.parseMediaType("audio/*;attr=v>alue");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeIllegalQualityFactor() {
 		MediaType.parseMediaType("audio/basic;q=1.1");
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeIllegalCharset() {
 		MediaType.parseMediaType("text/html; charset=foo-bar");
 	}
@@ -193,7 +193,7 @@ public void parseMediaTypeSingleQuotedParameterValue() {
 		assertEquals("'v>alue'", mediaType.getParameter("attr"));
 	}
 
-	@Test(expected = IllegalArgumentException.class)
+	@Test(expected = InvalidMediaTypeException.class)
 	public void parseMediaTypeIllegalQuotedParameterValue() {
 		MediaType.parseMediaType("audio/*;attr=\"");
 	}
diff --git a/spring-web/src/test/java/org/springframework/http/MockHttpOutputMessage.java b/spring-web/src/test/java/org/springframework/http/MockHttpOutputMessage.java
index c8dfbfc079b4..cb08fa91a116 100644
--- a/spring-web/src/test/java/org/springframework/http/MockHttpOutputMessage.java
+++ b/spring-web/src/test/java/org/springframework/http/MockHttpOutputMessage.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,6 +21,8 @@
 import java.io.OutputStream;
 import java.nio.charset.Charset;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Arjen Poutsma
  */
@@ -28,7 +30,7 @@ public class MockHttpOutputMessage implements HttpOutputMessage {
 
 	private final HttpHeaders headers = new HttpHeaders();
 
-	private final ByteArrayOutputStream body = new ByteArrayOutputStream();
+	private final ByteArrayOutputStream body = spy(new ByteArrayOutputStream());
 
 	@Override
 	public HttpHeaders getHeaders() {
diff --git a/spring-web/src/test/java/org/springframework/http/client/NoOutputStreamingBufferedSimpleHttpRequestFactoryTests.java b/spring-web/src/test/java/org/springframework/http/client/NoOutputStreamingBufferedSimpleHttpRequestFactoryTests.java
new file mode 100644
index 000000000000..002f33c7e8ea
--- /dev/null
+++ b/spring-web/src/test/java/org/springframework/http/client/NoOutputStreamingBufferedSimpleHttpRequestFactoryTests.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.http.client;
+
+
+public class NoOutputStreamingBufferedSimpleHttpRequestFactoryTests extends AbstractHttpRequestFactoryTestCase {
+
+	@Override
+	protected ClientHttpRequestFactory createRequestFactory() {
+		SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
+		factory.setOutputStreaming(false);
+		return factory;
+	}
+
+}
diff --git a/spring-web/src/test/java/org/springframework/http/client/NoOutputStreamingStreamingSimpleHttpRequestFactoryTests.java b/spring-web/src/test/java/org/springframework/http/client/NoOutputStreamingStreamingSimpleHttpRequestFactoryTests.java
new file mode 100644
index 000000000000..68111693e184
--- /dev/null
+++ b/spring-web/src/test/java/org/springframework/http/client/NoOutputStreamingStreamingSimpleHttpRequestFactoryTests.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.http.client;
+
+
+public class NoOutputStreamingStreamingSimpleHttpRequestFactoryTests extends AbstractHttpRequestFactoryTestCase {
+
+	@Override
+	protected ClientHttpRequestFactory createRequestFactory() {
+		SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
+		factory.setBufferRequestBody(false);
+		factory.setOutputStreaming(false);
+		return factory;
+	}
+}
diff --git a/spring-web/src/test/java/org/springframework/http/client/StreamingSimpleHttpRequestFactoryTests.java b/spring-web/src/test/java/org/springframework/http/client/StreamingSimpleHttpRequestFactoryTests.java
index ccb91450a4ab..6eed7ae1be63 100644
--- a/spring-web/src/test/java/org/springframework/http/client/StreamingSimpleHttpRequestFactoryTests.java
+++ b/spring-web/src/test/java/org/springframework/http/client/StreamingSimpleHttpRequestFactoryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -81,7 +81,7 @@ public void largeFileUpload() throws Exception {
 			ClientHttpRequest request = factory.createRequest(new URI(baseUrl + "/methods/post"), HttpMethod.POST);
 			final int BUF_SIZE = 4096;
 			final int ITERATIONS = Integer.MAX_VALUE / BUF_SIZE;
-			final int contentLength = ITERATIONS * BUF_SIZE;
+//			final int contentLength = ITERATIONS * BUF_SIZE;
 //			request.getHeaders().setContentLength(contentLength);
 			OutputStream body = request.getBody();
 			for (int i = 0; i < ITERATIONS; i++) {
diff --git a/spring-web/src/test/java/org/springframework/http/converter/FormHttpMessageConverterTests.java b/spring-web/src/test/java/org/springframework/http/converter/FormHttpMessageConverterTests.java
index 0792d6c6a8e6..1c11bb0a1959 100644
--- a/spring-web/src/test/java/org/springframework/http/converter/FormHttpMessageConverterTests.java
+++ b/spring-web/src/test/java/org/springframework/http/converter/FormHttpMessageConverterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,7 @@
 import java.io.StringReader;
 import java.nio.charset.Charset;
 import java.util.List;
+
 import javax.xml.transform.Source;
 import javax.xml.transform.stream.StreamSource;
 
@@ -32,7 +33,6 @@
 import org.apache.commons.fileupload.disk.DiskFileItemFactory;
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.core.io.ClassPathResource;
 import org.springframework.core.io.Resource;
 import org.springframework.http.HttpEntity;
@@ -45,6 +45,7 @@
 import org.springframework.util.MultiValueMap;
 
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Arjen Poutsma
@@ -72,7 +73,6 @@ public void canWrite() {
 	}
 
 	@Test
-	@SuppressWarnings("unchecked")
 	public void readForm() throws Exception {
 		String body = "name+1=value+1&name+2=value+2%2B1&name+2=value+2%2B2&name+3";
 		Charset iso88591 = Charset.forName("ISO-8859-1");
@@ -158,6 +158,7 @@ public void writeMultipart() throws Exception {
 		item = (FileItem) items.get(4);
 		assertEquals("xml", item.getFieldName());
 		assertEquals("text/xml", item.getContentType());
+		verify(outputMessage.getBody(), never()).close();
 	}
 
 	private static class MockHttpOutputMessageRequestContext implements RequestContext {
diff --git a/spring-web/src/test/java/org/springframework/http/converter/xml/MarshallingHttpMessageConverterTests.java b/spring-web/src/test/java/org/springframework/http/converter/xml/MarshallingHttpMessageConverterTests.java
index 7fd414b627cd..75de8e40199c 100644
--- a/spring-web/src/test/java/org/springframework/http/converter/xml/MarshallingHttpMessageConverterTests.java
+++ b/spring-web/src/test/java/org/springframework/http/converter/xml/MarshallingHttpMessageConverterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2009 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,18 +19,20 @@
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.http.MediaType;
 import org.springframework.http.MockHttpInputMessage;
 import org.springframework.http.MockHttpOutputMessage;
 import org.springframework.oxm.Marshaller;
 import org.springframework.oxm.Unmarshaller;
 
-/** @author Arjen Poutsma */
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
+/**
+ * @author Arjen Poutsma
+ */
 public class MarshallingHttpMessageConverterTests {
 
 	private MarshallingHttpMessageConverter converter;
@@ -41,9 +43,8 @@ public class MarshallingHttpMessageConverterTests {
 
 	@Before
 	public void setUp() {
-		marshaller = createMock(Marshaller.class);
-		unmarshaller = createMock(Unmarshaller.class);
-
+		marshaller = mock(Marshaller.class);
+		unmarshaller = mock(Unmarshaller.class);
 		converter = new MarshallingHttpMessageConverter(marshaller, unmarshaller);
 	}
 
@@ -52,12 +53,10 @@ public void read() throws Exception {
 		String body = "<root>Hello World</root>";
 		MockHttpInputMessage inputMessage = new MockHttpInputMessage(body.getBytes("UTF-8"));
 
-		expect(unmarshaller.unmarshal(isA(StreamSource.class))).andReturn(body);
+		given(unmarshaller.unmarshal(isA(StreamSource.class))).willReturn(body);
 
-		replay(marshaller, unmarshaller);
 		String result = (String) converter.read(Object.class, inputMessage);
 		assertEquals("Invalid result", body, result);
-		verify(marshaller, unmarshaller);
 	}
 
 	@Test
@@ -65,12 +64,9 @@ public void write() throws Exception {
 		String body = "<root>Hello World</root>";
 		MockHttpOutputMessage outputMessage = new MockHttpOutputMessage();
 
-		marshaller.marshal(eq(body), isA(StreamResult.class));
-
-		replay(marshaller, unmarshaller);
 		converter.write(body, null, outputMessage);
 		assertEquals("Invalid content-type", new MediaType("application", "xml"),
 				outputMessage.getHeaders().getContentType());
-		verify(marshaller, unmarshaller);
+		verify(marshaller).marshal(eq(body), isA(StreamResult.class));
 	}
 }
diff --git a/spring-web/src/test/java/org/springframework/mock/web/test/MockServletContext.java b/spring-web/src/test/java/org/springframework/mock/web/test/MockServletContext.java
index d18678dc4a44..dd070c7785c2 100644
--- a/spring-web/src/test/java/org/springframework/mock/web/test/MockServletContext.java
+++ b/spring-web/src/test/java/org/springframework/mock/web/test/MockServletContext.java
@@ -45,7 +45,6 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
 import org.springframework.core.io.DefaultResourceLoader;
 import org.springframework.core.io.Resource;
 import org.springframework.core.io.ResourceLoader;
@@ -258,9 +257,17 @@ public int getEffectiveMinorVersion() {
 		return this.effectiveMinorVersion;
 	}
 
+	/**
+	 * This method uses the Java Activation framework, which returns
+	 * "application/octet-stream" when the mime type is unknown (i.e. it never returns
+	 * {@code null}). In order to maintain the {@link ServletContext#getMimeType(String)
+	 * contract, as of version 3.2.2, this method returns null if the mimeType is
+	 * "application/octet-stream".
+	 */
 	@Override
 	public String getMimeType(String filePath) {
-		return MimeTypeResolver.getMimeType(filePath);
+		String mimeType = MimeTypeResolver.getMimeType(filePath);
+		return ("application/octet-stream".equals(mimeType)) ? null : mimeType;
 	}
 
 	@Override
diff --git a/spring-web/src/test/java/org/springframework/remoting/jaxrpc/JaxRpcSupportTests.java b/spring-web/src/test/java/org/springframework/remoting/jaxrpc/JaxRpcSupportTests.java
index 975d9537a304..d5606f9f3a26 100644
--- a/spring-web/src/test/java/org/springframework/remoting/jaxrpc/JaxRpcSupportTests.java
+++ b/spring-web/src/test/java/org/springframework/remoting/jaxrpc/JaxRpcSupportTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,7 +20,6 @@
 import java.net.URL;
 import java.rmi.Remote;
 import java.rmi.RemoteException;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
@@ -34,12 +33,11 @@
 import javax.xml.rpc.Stub;
 
 import junit.framework.TestCase;
-import org.easymock.ArgumentsMatcher;
-import org.easymock.MockControl;
 
 import org.springframework.remoting.RemoteAccessException;
 import org.springframework.remoting.RemoteLookupFailureException;
-import org.springframework.util.ObjectUtils;
+
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Juergen Hoeller
@@ -117,7 +115,6 @@ public void testJaxRpcPortProxyFactoryBean() throws Exception {
 		IRemoteBean proxy = (IRemoteBean) factory.getObject();
 		proxy.setName("myName");
 		assertEquals("myName", RemoteBean.name);
-		MockServiceFactory.service1Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithProperties() throws Exception {
@@ -145,7 +142,6 @@ public void testJaxRpcPortProxyFactoryBeanWithProperties() throws Exception {
 		IRemoteBean proxy = (IRemoteBean) factory.getObject();
 		proxy.setName("myName");
 		assertEquals("myName", RemoteBean.name);
-		MockServiceFactory.service1Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithCustomProperties() throws Exception {
@@ -173,7 +169,6 @@ public void testJaxRpcPortProxyFactoryBeanWithCustomProperties() throws Exceptio
 		IRemoteBean proxy = (IRemoteBean) factory.getObject();
 		proxy.setName("myName");
 		assertEquals("myName", RemoteBean.name);
-		MockServiceFactory.service1Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithCustomPropertyMap() throws Exception {
@@ -203,7 +198,6 @@ public void testJaxRpcPortProxyFactoryBeanWithCustomPropertyMap() throws Excepti
 		IRemoteBean proxy = (IRemoteBean) factory.getObject();
 		proxy.setName("myName");
 		assertEquals("myName", RemoteBean.name);
-		MockServiceFactory.service1Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithDynamicCalls() throws Exception {
@@ -219,13 +213,11 @@ public void testJaxRpcPortProxyFactoryBeanWithDynamicCalls() throws Exception {
 		assertTrue(factory.getObject() instanceof IBusinessBean);
 		IBusinessBean proxy = (IBusinessBean) factory.getObject();
 		proxy.setName("myName");
-		MockServiceFactory.service1Control.verify();
-		CallMockServiceFactory.call1Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithDynamicCallsAndProperties() throws Exception {
 		JaxRpcPortProxyFactoryBean factory = new JaxRpcPortProxyFactoryBean();
-		factory.setServiceFactoryClass(CallWithPropertiesMockServiceFactory.class);
+		factory.setServiceFactoryClass(CallMockServiceFactory.class);
 		factory.setNamespaceUri("myNamespace");
 		factory.setServiceName("myService1");
 		factory.setPortName("myPort");
@@ -240,8 +232,11 @@ public void testJaxRpcPortProxyFactoryBeanWithDynamicCallsAndProperties() throws
 		assertTrue(factory.getObject() instanceof IBusinessBean);
 		IBusinessBean proxy = (IBusinessBean) factory.getObject();
 		proxy.setName("myName");
-		MockServiceFactory.service1Control.verify();
-		CallMockServiceFactory.call1Control.verify();
+
+		verify(CallMockServiceFactory.call1).setProperty(Call.USERNAME_PROPERTY, "user");
+		verify(CallMockServiceFactory.call1).setProperty(Call.PASSWORD_PROPERTY, "pw");
+		verify(CallMockServiceFactory.call1).setTargetEndpointAddress("ea");
+		verify(CallMockServiceFactory.call1).setProperty(Call.SESSION_MAINTAIN_PROPERTY, Boolean.TRUE);
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithDynamicCallsAndServiceException() throws Exception {
@@ -310,9 +305,6 @@ public void testJaxRpcPortProxyFactoryBeanWithDynamicCallsAndRemoteException_()
 		assertEquals("myName", RemoteBean.name);
 
 		assertEquals(1, serviceFactory.serviceCount);
-		MockServiceFactory.service1Control.verify();
-		CallMockServiceFactory.call1Control.verify();
-		ExceptionCallMockServiceFactory.call2Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithDynamicCallsAndRemoteExceptionAndRefresh() throws Exception {
@@ -344,9 +336,6 @@ public void testJaxRpcPortProxyFactoryBeanWithDynamicCallsAndRemoteExceptionAndR
 		assertEquals("myName", RemoteBean.name);
 
 		assertEquals(2, serviceFactory.serviceCount);
-		MockServiceFactory.service1Control.verify();
-		CallMockServiceFactory.call1Control.verify();
-		ExceptionCallMockServiceFactory.call2Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithPortInterface() throws Exception {
@@ -363,7 +352,6 @@ public void testJaxRpcPortProxyFactoryBeanWithPortInterface() throws Exception {
 		IBusinessBean proxy = (IBusinessBean) factory.getObject();
 		proxy.setName("myName");
 		assertEquals("myName", RemoteBean.name);
-		MockServiceFactory.service1Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithPortInterfaceAndServiceException() throws Exception {
@@ -436,7 +424,6 @@ public void testJaxRpcPortProxyFactoryBeanWithPortInterfaceAndRemoteException()
 		assertEquals("myName", RemoteBean.name);
 
 		assertEquals(1, serviceFactory.serviceCount);
-		MockServiceFactory.service1Control.verify();
 	}
 
 	public void testJaxRpcPortProxyFactoryBeanWithPortInterfaceAndRemoteExceptionAndRefresh() throws Exception {
@@ -470,30 +457,25 @@ public void testJaxRpcPortProxyFactoryBeanWithPortInterfaceAndRemoteExceptionAnd
 		assertEquals("myName", RemoteBean.name);
 
 		assertEquals(2, serviceFactory.serviceCount);
-		MockServiceFactory.service1Control.verify();
 	}
 
 
 	public static class MockServiceFactory extends ServiceFactory {
 
-		protected static MockControl service1Control;
 		protected static Service service1;
-		protected static MockControl service2Control;
 		protected static Service service2;
 		protected int serviceCount = 0;
 
 		public MockServiceFactory() throws Exception {
-			service1Control = MockControl.createControl(Service.class);
-			service1 = (Service) service1Control.getMock();
-			service2Control = MockControl.createControl(Service.class);
-			service2 = (Service) service2Control.getMock();
+			service1 = mock(Service.class);
+			service2 = mock(Service.class);
 			initMocks();
-			service1Control.replay();
 		}
 
 		protected void initMocks() throws Exception {
-			service1.getPort(new QName("myNamespace", "myPort"), IRemoteBean.class);
-			service1Control.setReturnValue(new RemoteBean());
+			RemoteBean remoteBean = new RemoteBean();
+			given(service1.getPort(new QName("myNamespace", "myPort"),
+					IRemoteBean.class)).willReturn(remoteBean);
 		}
 
 		@Override
@@ -572,15 +554,14 @@ public ExceptionMockServiceFactory() throws Exception {
 		@Override
 		protected void initMocks() throws Exception {
 			super.initMocks();
-			service1.getPort(new QName("myNamespace", "myPort"), IRemoteBean.class);
-			service1Control.setReturnValue(new RemoteBean());
+			given(service1.getPort(new QName("myNamespace", "myPort"),
+					IRemoteBean.class)).willReturn(new RemoteBean());
 		}
 	}
 
 
 	public static class CallMockServiceFactory extends MockServiceFactory {
 
-		protected static MockControl call1Control;
 		protected static Call call1;
 
 		public CallMockServiceFactory() throws Exception {
@@ -589,38 +570,15 @@ public CallMockServiceFactory() throws Exception {
 
 		@Override
 		protected void initMocks() throws Exception {
-			initStandardCall(1);
-		}
-
-		protected void initStandardCall(int count) throws Exception {
-			call1Control = MockControl.createControl(Call.class);
-			call1 = (Call) call1Control.getMock();
-			service1.createCall(new QName("myNamespace", "myPort"), "setName");
-			service1Control.setReturnValue(call1, count);
-			call1.invoke(new Object[] {"myName"});
-			call1Control.setMatcher(new ArgumentsMatcher() {
-				@Override
-				public boolean matches(Object[] objects, Object[] objects1) {
-					return Arrays.equals((Object[]) objects[0], (Object[]) objects1[0]);
-				}
-				@Override
-				public String toString(Object[] objects) {
-					return ObjectUtils.nullSafeToString(objects[0]);
-				}
-			});
-			call1Control.setReturnValue(null, count);
-			extendStandardCall();
-			call1Control.replay();
-		}
-
-		protected void extendStandardCall() {
+			call1 = mock(Call.class);
+			given(service1.createCall(new QName("myNamespace", "myPort"), "setName")).willReturn(call1);
 		}
 	}
 
 
-	public static class ExceptionCallMockServiceFactory extends CallMockServiceFactory {
+	public static class ExceptionCallMockServiceFactory extends MockServiceFactory {
 
-		protected static MockControl call2Control;
+		protected static Call call1;
 		protected static Call call2;
 
 		public ExceptionCallMockServiceFactory() throws Exception {
@@ -628,47 +586,10 @@ public ExceptionCallMockServiceFactory() throws Exception {
 
 		@Override
 		protected void initMocks() throws Exception {
-			initExceptionCall();
-			initStandardCall(2);
-		}
-
-		protected void initExceptionCall() throws Exception {
-			call2Control = MockControl.createControl(Call.class);
-			call2 = (Call) call2Control.getMock();
-			service1.createCall(new QName("myNamespace", "myPort"), "setName");
-			service1Control.setReturnValue(call2);
-			call2.invoke(new Object[] {"exception"});
-			call2Control.setMatcher(new ArgumentsMatcher() {
-				@Override
-				public boolean matches(Object[] objects, Object[] objects1) {
-					return Arrays.equals((Object[]) objects[0], (Object[]) objects1[0]);
-				}
-				@Override
-				public String toString(Object[] objects) {
-					return ObjectUtils.nullSafeToString(objects[0]);
-				}
-			});
-			call2Control.setThrowable(new RemoteException());
-			call2Control.replay();
-		}
-	}
-
-
-	public static class CallWithPropertiesMockServiceFactory extends CallMockServiceFactory {
-
-		public CallWithPropertiesMockServiceFactory() throws Exception {
-		}
-
-		@Override
-		protected void extendStandardCall() {
-			call1.setProperty(Call.USERNAME_PROPERTY, "user");
-			call1Control.setVoidCallable();
-			call1.setProperty(Call.PASSWORD_PROPERTY, "pw");
-			call1Control.setVoidCallable();
-			call1.setTargetEndpointAddress("ea");
-			call1Control.setVoidCallable();
-			call1.setProperty(Call.SESSION_MAINTAIN_PROPERTY, Boolean.TRUE);
-			call1Control.setVoidCallable();
+			call1 = mock(Call.class);
+			call2 = mock(Call.class);
+			given(service1.createCall(new QName("myNamespace", "myPort"), "setName")).willReturn(call2, call1);
+			given(call2.invoke(new Object[] { "exception" })).willThrow(new RemoteException());
 		}
 	}
 
diff --git a/spring-web/src/test/java/org/springframework/remoting/jaxws/JaxWsSupportTests.java b/spring-web/src/test/java/org/springframework/remoting/jaxws/JaxWsSupportTests.java
index 7ae30114deab..66637e04b259 100644
--- a/spring-web/src/test/java/org/springframework/remoting/jaxws/JaxWsSupportTests.java
+++ b/spring-web/src/test/java/org/springframework/remoting/jaxws/JaxWsSupportTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,6 @@
 
 package org.springframework.remoting.jaxws;
 
-import static org.junit.Assert.*;
-
 import java.net.MalformedURLException;
 import java.net.URL;
 
@@ -28,7 +26,6 @@
 import javax.xml.ws.WebServiceRef;
 import javax.xml.ws.soap.AddressingFeature;
 
-import org.junit.Ignore;
 import org.junit.Test;
 import org.springframework.beans.factory.BeanCreationException;
 import org.springframework.beans.factory.support.GenericBeanDefinition;
@@ -36,12 +33,12 @@
 import org.springframework.context.annotation.AnnotationConfigUtils;
 import org.springframework.context.support.GenericApplicationContext;
 
+import static org.junit.Assert.*;
+
 /**
  * @author Juergen Hoeller
  * @since 2.5
  */
-// TODO [SPR-10074] see https://gist.github.com/1150858
-@Ignore("see https://gist.github.com/1150858")
 public class JaxWsSupportTests {
 
 	@Test
diff --git a/spring-web/src/test/java/org/springframework/web/accept/PathExtensionContentNegotiationStrategyTests.java b/spring-web/src/test/java/org/springframework/web/accept/PathExtensionContentNegotiationStrategyTests.java
index 81029401f089..b814c5926e3d 100644
--- a/spring-web/src/test/java/org/springframework/web/accept/PathExtensionContentNegotiationStrategyTests.java
+++ b/spring-web/src/test/java/org/springframework/web/accept/PathExtensionContentNegotiationStrategyTests.java
@@ -74,10 +74,12 @@ public void resolveMediaTypesFromJaf() {
 		assertEquals(Arrays.asList(new MediaType("application", "vnd.ms-excel")), mediaTypes);
 	}
 
+	// SPR-10334
+
 	@Test
 	public void getMediaTypeFromFilenameNoJaf() {
 
-		this.servletRequest.setRequestURI("test.xls");
+		this.servletRequest.setRequestURI("test.json");
 
 		ServletContext servletContext = this.servletRequest.getServletContext();
 		PathExtensionContentNegotiationStrategy strategy =
@@ -86,7 +88,7 @@ public void getMediaTypeFromFilenameNoJaf() {
 
 		List<MediaType> mediaTypes = strategy.resolveMediaTypes(this.webRequest);
 
-		assertEquals(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM), mediaTypes);
+		assertEquals(Collections.emptyList(), mediaTypes);
 	}
 
 	// SPR-8678
diff --git a/spring-web/src/test/java/org/springframework/web/client/DefaultResponseErrorHandlerTests.java b/spring-web/src/test/java/org/springframework/web/client/DefaultResponseErrorHandlerTests.java
index 7149dece12f2..55457d59821d 100644
--- a/spring-web/src/test/java/org/springframework/web/client/DefaultResponseErrorHandlerTests.java
+++ b/spring-web/src/test/java/org/springframework/web/client/DefaultResponseErrorHandlerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,15 +21,13 @@
 
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpStatus;
 import org.springframework.http.MediaType;
 import org.springframework.http.client.ClientHttpResponse;
 
-import static org.easymock.EasyMock.*;
-
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * Unit tests for {@link DefaultResponseErrorHandler}.
@@ -45,27 +43,19 @@ public class DefaultResponseErrorHandlerTests {
 	@Before
 	public void setUp() throws Exception {
 		handler = new DefaultResponseErrorHandler();
-		response = createMock(ClientHttpResponse.class);
+		response = mock(ClientHttpResponse.class);
 	}
 
 	@Test
 	public void hasErrorTrue() throws Exception {
-		expect(response.getStatusCode()).andReturn(HttpStatus.NOT_FOUND);
-
-		replay(response);
+		given(response.getStatusCode()).willReturn(HttpStatus.NOT_FOUND);
 		assertTrue(handler.hasError(response));
-
-		verify(response);
 	}
 
 	@Test
 	public void hasErrorFalse() throws Exception {
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-
-		replay(response);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
 		assertFalse(handler.hasError(response));
-
-		verify(response);
 	}
 
 	@Test
@@ -73,12 +63,10 @@ public void handleError() throws Exception {
 		HttpHeaders headers = new HttpHeaders();
 		headers.setContentType(MediaType.TEXT_PLAIN);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.NOT_FOUND);
-		expect(response.getStatusText()).andReturn("Not Found");
-		expect(response.getHeaders()).andReturn(headers).atLeastOnce();
-		expect(response.getBody()).andReturn(new ByteArrayInputStream("Hello World".getBytes("UTF-8")));
-
-		replay(response);
+		given(response.getStatusCode()).willReturn(HttpStatus.NOT_FOUND);
+		given(response.getStatusText()).willReturn("Not Found");
+		given(response.getHeaders()).willReturn(headers);
+		given(response.getBody()).willReturn(new ByteArrayInputStream("Hello World".getBytes("UTF-8")));
 
 		try {
 			handler.handleError(response);
@@ -87,8 +75,6 @@ public void handleError() throws Exception {
 		catch (HttpClientErrorException e) {
 			assertSame(headers, e.getResponseHeaders());
 		}
-
-		verify(response);
 	}
 
 	@Test(expected = HttpClientErrorException.class)
@@ -96,16 +82,12 @@ public void handleErrorIOException() throws Exception {
 		HttpHeaders headers = new HttpHeaders();
 		headers.setContentType(MediaType.TEXT_PLAIN);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.NOT_FOUND);
-		expect(response.getStatusText()).andReturn("Not Found");
-		expect(response.getHeaders()).andReturn(headers).atLeastOnce();
-		expect(response.getBody()).andThrow(new IOException());
-
-		replay(response);
+		given(response.getStatusCode()).willReturn(HttpStatus.NOT_FOUND);
+		given(response.getStatusText()).willReturn("Not Found");
+		given(response.getHeaders()).willReturn(headers);
+		given(response.getBody()).willThrow(new IOException());
 
 		handler.handleError(response);
-
-		verify(response);
 	}
 
 	@Test(expected = HttpClientErrorException.class)
@@ -113,16 +95,11 @@ public void handleErrorNullResponse() throws Exception {
 		HttpHeaders headers = new HttpHeaders();
 		headers.setContentType(MediaType.TEXT_PLAIN);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.NOT_FOUND);
-		expect(response.getStatusText()).andReturn("Not Found");
-		expect(response.getHeaders()).andReturn(headers).atLeastOnce();
-		expect(response.getBody()).andReturn(null);
-
-		replay(response);
+		given(response.getStatusCode()).willReturn(HttpStatus.NOT_FOUND);
+		given(response.getStatusText()).willReturn("Not Found");
+		given(response.getHeaders()).willReturn(headers);
 
 		handler.handleError(response);
-
-		verify(response);
 	}
 
 	// SPR-9406
@@ -132,13 +109,10 @@ public void unknownStatusCode() throws Exception {
 		HttpHeaders headers = new HttpHeaders();
 		headers.setContentType(MediaType.TEXT_PLAIN);
 
-		expect(response.getStatusCode()).andThrow(new IllegalArgumentException("No matching constant for 999"));
-		expect(response.getRawStatusCode()).andReturn(999);
-		expect(response.getStatusText()).andReturn("Custom status code");
-		expect(response.getHeaders()).andReturn(headers).atLeastOnce();
-		expect(response.getBody()).andReturn(null);
-
-		replay(response);
+		given(response.getStatusCode()).willThrow(new IllegalArgumentException("No matching constant for 999"));
+		given(response.getRawStatusCode()).willReturn(999);
+		given(response.getStatusText()).willReturn("Custom status code");
+		given(response.getHeaders()).willReturn(headers);
 
 		handler.handleError(response);
 	}
diff --git a/spring-web/src/test/java/org/springframework/web/client/HttpMessageConverterExtractorTests.java b/spring-web/src/test/java/org/springframework/web/client/HttpMessageConverterExtractorTests.java
index f9c587248ec5..1ce003da4b3b 100644
--- a/spring-web/src/test/java/org/springframework/web/client/HttpMessageConverterExtractorTests.java
+++ b/spring-web/src/test/java/org/springframework/web/client/HttpMessageConverterExtractorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,6 @@
 
 package org.springframework.web.client;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
 import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -39,6 +31,9 @@
 import org.springframework.http.converter.GenericHttpMessageConverter;
 import org.springframework.http.converter.HttpMessageConverter;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test fixture for {@link HttpMessageConverter}.
  *
@@ -52,101 +47,80 @@ public class HttpMessageConverterExtractorTests {
 
 	@Before
 	public void createMocks() {
-		response = createMock(ClientHttpResponse.class);
+		response = mock(ClientHttpResponse.class);
 	}
 
 	@Test
 	public void noContent() throws IOException {
-		HttpMessageConverter<?> converter = createMock(HttpMessageConverter.class);
-
+		HttpMessageConverter<?> converter = mock(HttpMessageConverter.class);
 		extractor = new HttpMessageConverterExtractor<String>(String.class, createConverterList(converter));
+		given(response.getStatusCode()).willReturn(HttpStatus.NO_CONTENT);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.NO_CONTENT);
-
-		replay(response, converter);
 		Object result = extractor.extractData(response);
 
 		assertNull(result);
-		verify(response, converter);
 	}
 
 	@Test
 	public void notModified() throws IOException {
-		HttpMessageConverter<?> converter = createMock(HttpMessageConverter.class);
-
+		HttpMessageConverter<?> converter = mock(HttpMessageConverter.class);
 		extractor = new HttpMessageConverterExtractor<String>(String.class, createConverterList(converter));
+		given(response.getStatusCode()).willReturn(HttpStatus.NOT_MODIFIED);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.NOT_MODIFIED);
-
-		replay(response, converter);
 		Object result = extractor.extractData(response);
 
 		assertNull(result);
-		verify(response, converter);
 	}
 
 	@Test
 	public void zeroContentLength() throws IOException {
-		HttpMessageConverter<?> converter = createMock(HttpMessageConverter.class);
+		HttpMessageConverter<?> converter = mock(HttpMessageConverter.class);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentLength(0);
-
 		extractor = new HttpMessageConverterExtractor<String>(String.class, createConverterList(converter));
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders);
-
-		replay(response, converter);
 		Object result = extractor.extractData(response);
 
 		assertNull(result);
-		verify(response, converter);
 	}
 
 	@Test
 	@SuppressWarnings("unchecked")
 	public void normal() throws IOException {
-		HttpMessageConverter<String> converter = createMock(HttpMessageConverter.class);
+		HttpMessageConverter<String> converter = mock(HttpMessageConverter.class);
 		List<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>();
 		converters.add(converter);
-
 		HttpHeaders responseHeaders = new HttpHeaders();
 		MediaType contentType = MediaType.TEXT_PLAIN;
 		responseHeaders.setContentType(contentType);
 		String expected = "Foo";
-
 		extractor = new HttpMessageConverterExtractor<String>(String.class, converters);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
+		given(converter.canRead(String.class, contentType)).willReturn(true);
+		given(converter.read(String.class, response)).willReturn(expected);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(2);
-		expect(converter.canRead(String.class, contentType)).andReturn(true);
-		expect(converter.read(String.class, response)).andReturn(expected);
-
-		replay(response, converter);
 		Object result = extractor.extractData(response);
 
 		assertEquals(expected, result);
-		verify(response, converter);
 	}
 
 	@Test
 	@SuppressWarnings("unchecked")
 	public void cannotRead() throws IOException {
-		HttpMessageConverter<String> converter = createMock(HttpMessageConverter.class);
+		HttpMessageConverter<String> converter = mock(HttpMessageConverter.class);
 		List<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>();
 		converters.add(converter);
-
 		HttpHeaders responseHeaders = new HttpHeaders();
 		MediaType contentType = MediaType.TEXT_PLAIN;
 		responseHeaders.setContentType(contentType);
-
 		extractor = new HttpMessageConverterExtractor<String>(String.class, converters);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
+		given(converter.canRead(String.class, contentType)).willReturn(false);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(2);
-		expect(converter.canRead(String.class, contentType)).andReturn(false);
-
-		replay(response, converter);
 		try {
 			extractor.extractData(response);
 			fail("RestClientException expected");
@@ -154,36 +128,28 @@ public void cannotRead() throws IOException {
 		catch (RestClientException expected) {
 			// expected
 		}
-
-		verify(response, converter);
 	}
 
 	@Test
 	@SuppressWarnings("unchecked")
 	public void generics() throws IOException {
-		GenericHttpMessageConverter<String> converter = createMock(GenericHttpMessageConverter.class);
+		GenericHttpMessageConverter<String> converter = mock(GenericHttpMessageConverter.class);
 		List<HttpMessageConverter<?>> converters = createConverterList(converter);
-
 		HttpHeaders responseHeaders = new HttpHeaders();
 		MediaType contentType = MediaType.TEXT_PLAIN;
 		responseHeaders.setContentType(contentType);
 		String expected = "Foo";
-
 		ParameterizedTypeReference<List<String>> reference = new ParameterizedTypeReference<List<String>>() {};
 		Type type = reference.getType();
-
 		extractor = new HttpMessageConverterExtractor<List<String>>(type, converters);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
+		given(converter.canRead(type, null, contentType)).willReturn(true);
+		given(converter.read(type, null, response)).willReturn(expected);
 
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(2);
-		expect(converter.canRead(type, null, contentType)).andReturn(true);
-		expect(converter.read(type, null, response)).andReturn(expected);
-
-		replay(response, converter);
 		Object result = extractor.extractData(response);
 
 		assertEquals(expected, result);
-		verify(response, converter);
 	}
 
 	private List<HttpMessageConverter<?>> createConverterList(HttpMessageConverter converter) {
diff --git a/spring-web/src/test/java/org/springframework/web/client/RestTemplateTests.java b/spring-web/src/test/java/org/springframework/web/client/RestTemplateTests.java
index faca295254db..fcfc34077045 100644
--- a/spring-web/src/test/java/org/springframework/web/client/RestTemplateTests.java
+++ b/spring-web/src/test/java/org/springframework/web/client/RestTemplateTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,11 +25,8 @@
 import java.util.Map;
 import java.util.Set;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.core.ParameterizedTypeReference;
 import org.springframework.http.HttpEntity;
 import org.springframework.http.HttpHeaders;
@@ -43,7 +40,12 @@
 import org.springframework.http.converter.GenericHttpMessageConverter;
 import org.springframework.http.converter.HttpMessageConverter;
 
-/** @author Arjen Poutsma */
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
+/**
+ * @author Arjen Poutsma
+ */
 @SuppressWarnings("unchecked")
 public class RestTemplateTests {
 
@@ -61,11 +63,11 @@ public class RestTemplateTests {
 
 	@Before
 	public void setUp() {
-		requestFactory = createMock(ClientHttpRequestFactory.class);
-		request = createMock(ClientHttpRequest.class);
-		response = createMock(ClientHttpResponse.class);
-		errorHandler = createMock(ResponseErrorHandler.class);
-		converter = createMock(HttpMessageConverter.class);
+		requestFactory = mock(ClientHttpRequestFactory.class);
+		request = mock(ClientHttpRequest.class);
+		response = mock(ClientHttpResponse.class);
+		errorHandler = mock(ResponseErrorHandler.class);
+		converter = mock(HttpMessageConverter.class);
 		template = new RestTemplate(requestFactory);
 		template.setErrorHandler(errorHandler);
 		template.setMessageConverters(Collections.<HttpMessageConverter<?>>singletonList(converter));
@@ -73,85 +75,77 @@ public void setUp() {
 
 	@Test
 	public void varArgsTemplateVariables() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com/hotels/42/bookings/21"), HttpMethod.GET))
-				.andReturn(request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(requestFactory.createRequest(new URI("http://example.com/hotels/42/bookings/21"), HttpMethod.GET))
+				.willReturn(request);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		template.execute("http://example.com/hotels/{hotel}/bookings/{booking}", HttpMethod.GET, null, null, "42",
 				"21");
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void varArgsNullTemplateVariable() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com/-foo"), HttpMethod.GET))
-				.andReturn(request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(requestFactory.createRequest(new URI("http://example.com/-foo"), HttpMethod.GET))
+				.willReturn(request);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		template.execute("http://example.com/{first}-{last}", HttpMethod.GET, null, null, null, "foo");
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void mapTemplateVariables() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com/hotels/42/bookings/42"), HttpMethod.GET))
-				.andReturn(request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(requestFactory.createRequest(new URI("http://example.com/hotels/42/bookings/42"), HttpMethod.GET))
+				.willReturn(request);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		Map<String, String> vars = Collections.singletonMap("hotel", "42");
 		template.execute("http://example.com/hotels/{hotel}/bookings/{hotel}", HttpMethod.GET, null, null, vars);
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void mapNullTemplateVariable() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com/-foo"), HttpMethod.GET))
-				.andReturn(request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(requestFactory.createRequest(new URI("http://example.com/-foo"), HttpMethod.GET))
+				.willReturn(request);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		Map<String, String> vars = new HashMap<String, String>(2);
 		vars.put("first", null);
 		vars.put("last", "foo");
 		template.execute("http://example.com/{first}-{last}", HttpMethod.GET, null, null, vars);
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void errorHandling() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.GET)).andReturn(request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(true);
-		expect(response.getStatusCode()).andReturn(HttpStatus.INTERNAL_SERVER_ERROR);
-		expect(response.getStatusText()).andReturn("Internal Server Error");
-		errorHandler.handleError(response);
-		expectLastCall().andThrow(new HttpServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR));
-		response.close();
-
-		replayMocks();
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.GET)).willReturn(request);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(true);
+		given(response.getStatusCode()).willReturn(HttpStatus.INTERNAL_SERVER_ERROR);
+		given(response.getStatusText()).willReturn("Internal Server Error");
+		willThrow(new HttpServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR)).given(errorHandler).handleError(response);
 
 		try {
 			template.execute("http://example.com", HttpMethod.GET, null, null);
@@ -160,60 +154,59 @@ public void errorHandling() throws Exception {
 		catch (HttpServerErrorException ex) {
 			// expected
 		}
-		verifyMocks();
+
+		verify(response).close();
 	}
 
 	@Test
 	public void getForObject() throws Exception {
-		expect(converter.canRead(String.class, null)).andReturn(true);
+		given(converter.canRead(String.class, null)).willReturn(true);
 		MediaType textPlain = new MediaType("text", "plain");
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(textPlain));
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.GET)).andReturn(request);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(textPlain));
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.GET)).willReturn(request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.getHeaders()).willReturn(requestHeaders);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentType(textPlain);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(2);
-		expect(converter.canRead(String.class, textPlain)).andReturn(true);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
+		given(converter.canRead(String.class, textPlain)).willReturn(true);
 		String expected = "Hello World";
-		expect(converter.read(String.class, response)).andReturn(expected);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(converter.read(String.class, response)).willReturn(expected);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		String result = template.getForObject("http://example.com", String.class);
 		assertEquals("Invalid GET result", expected, result);
 		assertEquals("Invalid Accept header", textPlain.toString(), requestHeaders.getFirst("Accept"));
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void getUnsupportedMediaType() throws Exception {
-		expect(converter.canRead(String.class, null)).andReturn(true);
+		given(converter.canRead(String.class, null)).willReturn(true);
 		MediaType supportedMediaType = new MediaType("foo", "bar");
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(supportedMediaType));
-		expect(requestFactory.createRequest(new URI("http://example.com/resource"), HttpMethod.GET)).andReturn(request);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(supportedMediaType));
+		given(requestFactory.createRequest(new URI("http://example.com/resource"), HttpMethod.GET)).willReturn(request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.getHeaders()).willReturn(requestHeaders);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		MediaType contentType = new MediaType("bar", "baz");
 		responseHeaders.setContentType(contentType);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(2);
-		expect(converter.canRead(String.class, contentType)).andReturn(false);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
+		given(converter.canRead(String.class, contentType)).willReturn(false);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		try {
 			template.getForObject("http://example.com/{p}", String.class, "resource");
@@ -222,33 +215,33 @@ public void getUnsupportedMediaType() throws Exception {
 		catch (RestClientException ex) {
 			// expected
 		}
-		verifyMocks();
+
+		verify(response).close();
 	}
 
 
 	@Test
 	public void getForEntity() throws Exception {
-		expect(converter.canRead(String.class, null)).andReturn(true);
+		given(converter.canRead(String.class, null)).willReturn(true);
 		MediaType textPlain = new MediaType("text", "plain");
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(textPlain));
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.GET)).andReturn(request);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(textPlain));
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.GET)).willReturn(request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.getHeaders()).willReturn(requestHeaders);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentType(textPlain);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(3);
-		expect(converter.canRead(String.class, textPlain)).andReturn(true);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
+		given(converter.canRead(String.class, textPlain)).willReturn(true);
 		String expected = "Hello World";
-		expect(converter.read(String.class, response)).andReturn(expected);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(converter.read(String.class, response)).willReturn(expected);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		ResponseEntity<String> result = template.getForEntity("http://example.com", String.class);
 		assertEquals("Invalid GET result", expected, result.getBody());
@@ -256,70 +249,68 @@ public void getForEntity() throws Exception {
 		assertEquals("Invalid Content-Type header", textPlain, result.getHeaders().getContentType());
 		assertEquals("Invalid status code", HttpStatus.OK, result.getStatusCode());
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 
 	@Test
 	public void headForHeaders() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.HEAD)).andReturn(request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.HEAD)).willReturn(request);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
-		expect(response.getHeaders()).andReturn(responseHeaders);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
+		given(response.getHeaders()).willReturn(responseHeaders);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
-		replayMocks();
 		HttpHeaders result = template.headForHeaders("http://example.com");
 
 		assertSame("Invalid headers returned", responseHeaders, result);
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForLocation() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(request);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(request);
 		String helloWorld = "Hello World";
-		expect(converter.canWrite(String.class, null)).andReturn(true);
+		given(converter.canWrite(String.class, null)).willReturn(true);
 		converter.write(helloWorld, null, request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		URI expected = new URI("http://example.com/hotels");
 		responseHeaders.setLocation(expected);
-		expect(response.getHeaders()).andReturn(responseHeaders);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(response.getHeaders()).willReturn(responseHeaders);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		URI result = template.postForLocation("http://example.com", helloWorld);
 		assertEquals("Invalid POST result", expected, result);
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForLocationEntityContentType() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(request);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(request);
 		String helloWorld = "Hello World";
 		MediaType contentType = MediaType.TEXT_PLAIN;
-		expect(converter.canWrite(String.class, contentType)).andReturn(true);
+		given(converter.canWrite(String.class, contentType)).willReturn(true);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders);
+		given(request.getHeaders()).willReturn(requestHeaders);
 		converter.write(helloWorld, contentType, request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		URI expected = new URI("http://example.com/hotels");
 		responseHeaders.setLocation(expected);
-		expect(response.getHeaders()).andReturn(responseHeaders);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(response.getHeaders()).willReturn(responseHeaders);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		HttpHeaders entityHeaders = new HttpHeaders();
 		entityHeaders.setContentType(contentType);
@@ -328,27 +319,26 @@ public void postForLocationEntityContentType() throws Exception {
 		URI result = template.postForLocation("http://example.com", entity);
 		assertEquals("Invalid POST result", expected, result);
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForLocationEntityCustomHeader() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(request);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(request);
 		String helloWorld = "Hello World";
-		expect(converter.canWrite(String.class, null)).andReturn(true);
+		given(converter.canWrite(String.class, null)).willReturn(true);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders);
+		given(request.getHeaders()).willReturn(requestHeaders);
 		converter.write(helloWorld, null, request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		URI expected = new URI("http://example.com/hotels");
 		responseHeaders.setLocation(expected);
-		expect(response.getHeaders()).andReturn(responseHeaders);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(response.getHeaders()).willReturn(responseHeaders);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		HttpHeaders entityHeaders = new HttpHeaders();
 		entityHeaders.set("MyHeader", "MyValue");
@@ -358,108 +348,105 @@ public void postForLocationEntityCustomHeader() throws Exception {
 		assertEquals("Invalid POST result", expected, result);
 		assertEquals("No custom header set", "MyValue", requestHeaders.getFirst("MyHeader"));
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForLocationNoLocation() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(request);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(request);
 		String helloWorld = "Hello World";
-		expect(converter.canWrite(String.class, null)).andReturn(true);
+		given(converter.canWrite(String.class, null)).willReturn(true);
 		converter.write(helloWorld, null, request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
-		expect(response.getHeaders()).andReturn(responseHeaders);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(response.getHeaders()).willReturn(responseHeaders);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		URI result = template.postForLocation("http://example.com", helloWorld);
 		assertNull("Invalid POST result", result);
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForLocationNull() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(request);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.getHeaders()).willReturn(requestHeaders);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
-		expect(response.getHeaders()).andReturn(responseHeaders);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
+		given(response.getHeaders()).willReturn(responseHeaders);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
-		replayMocks();
 		template.postForLocation("http://example.com", null);
 		assertEquals("Invalid content length", 0, requestHeaders.getContentLength());
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForObject() throws Exception {
 		MediaType textPlain = new MediaType("text", "plain");
-		expect(converter.canRead(Integer.class, null)).andReturn(true);
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(textPlain));
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(this.request);
+		given(converter.canRead(Integer.class, null)).willReturn(true);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(textPlain));
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(this.request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(this.request.getHeaders()).andReturn(requestHeaders);
+		given(this.request.getHeaders()).willReturn(requestHeaders);
 		String request = "Hello World";
-		expect(converter.canWrite(String.class, null)).andReturn(true);
+		given(converter.canWrite(String.class, null)).willReturn(true);
 		converter.write(request, null, this.request);
-		expect(this.request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(this.request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentType(textPlain);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(2);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
 		Integer expected = 42;
-		expect(converter.canRead(Integer.class, textPlain)).andReturn(true);
-		expect(converter.read(Integer.class, response)).andReturn(expected);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(converter.canRead(Integer.class, textPlain)).willReturn(true);
+		given(converter.read(Integer.class, response)).willReturn(expected);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		Integer result = template.postForObject("http://example.com", request, Integer.class);
 		assertEquals("Invalid POST result", expected, result);
 		assertEquals("Invalid Accept header", textPlain.toString(), requestHeaders.getFirst("Accept"));
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForEntity() throws Exception {
 		MediaType textPlain = new MediaType("text", "plain");
-		expect(converter.canRead(Integer.class, null)).andReturn(true);
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(textPlain));
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(this.request);
+		given(converter.canRead(Integer.class, null)).willReturn(true);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(textPlain));
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(this.request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(this.request.getHeaders()).andReturn(requestHeaders);
+		given(this.request.getHeaders()).willReturn(requestHeaders);
 		String request = "Hello World";
-		expect(converter.canWrite(String.class, null)).andReturn(true);
+		given(converter.canWrite(String.class, null)).willReturn(true);
 		converter.write(request, null, this.request);
-		expect(this.request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(this.request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentType(textPlain);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(3);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
 		Integer expected = 42;
-		expect(converter.canRead(Integer.class, textPlain)).andReturn(true);
-		expect(converter.read(Integer.class, response)).andReturn(expected);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(converter.canRead(Integer.class, textPlain)).willReturn(true);
+		given(converter.read(Integer.class, response)).willReturn(expected);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		ResponseEntity<Integer> result = template.postForEntity("http://example.com", request, Integer.class);
 		assertEquals("Invalid POST result", expected, result.getBody());
@@ -467,148 +454,143 @@ public void postForEntity() throws Exception {
 		assertEquals("Invalid Accept header", textPlain.toString(), requestHeaders.getFirst("Accept"));
 		assertEquals("Invalid status code", HttpStatus.OK, result.getStatusCode());
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForObjectNull() throws Exception {
 		MediaType textPlain = new MediaType("text", "plain");
-		expect(converter.canRead(Integer.class, null)).andReturn(true);
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(textPlain));
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(request);
+		given(converter.canRead(Integer.class, null)).willReturn(true);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(textPlain));
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders).times(2);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.getHeaders()).willReturn(requestHeaders);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentType(textPlain);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(2);
-		expect(converter.canRead(Integer.class, textPlain)).andReturn(true);
-		expect(converter.read(Integer.class, response)).andReturn(null);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
+		given(converter.canRead(Integer.class, textPlain)).willReturn(true);
+		given(converter.read(Integer.class, response)).willReturn(null);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
+
 		Integer result = template.postForObject("http://example.com", null, Integer.class);
 		assertNull("Invalid POST result", result);
 		assertEquals("Invalid content length", 0, requestHeaders.getContentLength());
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void postForEntityNull() throws Exception {
 		MediaType textPlain = new MediaType("text", "plain");
-		expect(converter.canRead(Integer.class, null)).andReturn(true);
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(textPlain));
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(request);
+		given(converter.canRead(Integer.class, null)).willReturn(true);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(textPlain));
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders).times(2);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(request.getHeaders()).willReturn(requestHeaders);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentType(textPlain);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(3);
-		expect(converter.canRead(Integer.class, textPlain)).andReturn(true);
-		expect(converter.read(Integer.class, response)).andReturn(null);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
+		given(converter.canRead(Integer.class, textPlain)).willReturn(true);
+		given(converter.read(Integer.class, response)).willReturn(null);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
+
 		ResponseEntity<Integer> result = template.postForEntity("http://example.com", null, Integer.class);
 		assertFalse("Invalid POST result", result.hasBody());
 		assertEquals("Invalid Content-Type", textPlain, result.getHeaders().getContentType());
 		assertEquals("Invalid content length", 0, requestHeaders.getContentLength());
 		assertEquals("Invalid status code", HttpStatus.OK, result.getStatusCode());
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void put() throws Exception {
-		expect(converter.canWrite(String.class, null)).andReturn(true);
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.PUT)).andReturn(request);
+		given(converter.canWrite(String.class, null)).willReturn(true);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.PUT)).willReturn(request);
 		String helloWorld = "Hello World";
 		converter.write(helloWorld, null, request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		template.put("http://example.com", helloWorld);
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void putNull() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.PUT)).andReturn(request);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.PUT)).willReturn(request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(request.getHeaders()).andReturn(requestHeaders);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
+		given(request.getHeaders()).willReturn(requestHeaders);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
-		replayMocks();
 		template.put("http://example.com", null);
 		assertEquals("Invalid content length", 0, requestHeaders.getContentLength());
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void delete() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.DELETE)).andReturn(request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.DELETE)).willReturn(request);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		template.delete("http://example.com");
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void optionsForAllow() throws Exception {
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.OPTIONS)).andReturn(request);
-		expect(request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.OPTIONS)).willReturn(request);
+		given(request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		EnumSet<HttpMethod> expected = EnumSet.of(HttpMethod.GET, HttpMethod.POST);
 		responseHeaders.setAllow(expected);
-		expect(response.getHeaders()).andReturn(responseHeaders);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(response.getHeaders()).willReturn(responseHeaders);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		Set<HttpMethod> result = template.optionsForAllow("http://example.com");
 		assertEquals("Invalid OPTIONS result", expected, result);
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void ioException() throws Exception {
-		expect(converter.canRead(String.class, null)).andReturn(true);
+		given(converter.canRead(String.class, null)).willReturn(true);
 		MediaType mediaType = new MediaType("foo", "bar");
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(mediaType));
-		expect(requestFactory.createRequest(new URI("http://example.com/resource"), HttpMethod.GET)).andReturn(request);
-		expect(request.getHeaders()).andReturn(new HttpHeaders());
-		expect(request.execute()).andThrow(new IOException());
-
-		replayMocks();
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(mediaType));
+		given(requestFactory.createRequest(new URI("http://example.com/resource"), HttpMethod.GET)).willReturn(request);
+		given(request.getHeaders()).willReturn(new HttpHeaders());
+		given(request.execute()).willThrow(new IOException());
 
 		try {
 			template.getForObject("http://example.com/resource", String.class);
@@ -617,35 +599,32 @@ public void ioException() throws Exception {
 		catch (ResourceAccessException ex) {
 			// expected
 		}
-
-		verifyMocks();
 	}
 
 	@Test
 	public void exchange() throws Exception {
-		expect(converter.canRead(Integer.class, null)).andReturn(true);
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(this.request);
+		given(converter.canRead(Integer.class, null)).willReturn(true);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(this.request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(this.request.getHeaders()).andReturn(requestHeaders).times(2);
-		expect(converter.canWrite(String.class, null)).andReturn(true);
+		given(this.request.getHeaders()).willReturn(requestHeaders);
+		given(converter.canWrite(String.class, null)).willReturn(true);
 		String body = "Hello World";
 		converter.write(body, null, this.request);
-		expect(this.request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(this.request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentType(MediaType.TEXT_PLAIN);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(3);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
 		Integer expected = 42;
-		expect(converter.canRead(Integer.class, MediaType.TEXT_PLAIN)).andReturn(true);
-		expect(converter.read(Integer.class, response)).andReturn(expected);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replayMocks();
+		given(converter.canRead(Integer.class, MediaType.TEXT_PLAIN)).willReturn(true);
+		given(converter.read(Integer.class, response)).willReturn(expected);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		HttpHeaders entityHeaders = new HttpHeaders();
 		entityHeaders.set("MyHeader", "MyValue");
@@ -657,38 +636,37 @@ public void exchange() throws Exception {
 		assertEquals("Invalid custom header", "MyValue", requestHeaders.getFirst("MyHeader"));
 		assertEquals("Invalid status code", HttpStatus.OK, result.getStatusCode());
 
-		verifyMocks();
+		verify(response).close();
 	}
 
 	@Test
 	public void exchangeParameterizedType() throws Exception {
-		GenericHttpMessageConverter converter = createMock(GenericHttpMessageConverter.class);
+		GenericHttpMessageConverter converter = mock(GenericHttpMessageConverter.class);
 		template.setMessageConverters(Collections.<HttpMessageConverter<?>>singletonList(converter));
 
 		ParameterizedTypeReference<List<Integer>> intList = new ParameterizedTypeReference<List<Integer>>() {};
-		expect(converter.canRead(intList.getType(), null, null)).andReturn(true);
-		expect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		expect(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).andReturn(this.request);
+		given(converter.canRead(intList.getType(), null, null)).willReturn(true);
+		given(converter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
+		given(requestFactory.createRequest(new URI("http://example.com"), HttpMethod.POST)).willReturn(this.request);
 		HttpHeaders requestHeaders = new HttpHeaders();
-		expect(this.request.getHeaders()).andReturn(requestHeaders).times(2);
-		expect(converter.canWrite(String.class, null)).andReturn(true);
+		given(this.request.getHeaders()).willReturn(requestHeaders);
+		given(converter.canWrite(String.class, null)).willReturn(true);
 		String requestBody = "Hello World";
 		converter.write(requestBody, null, this.request);
-		expect(this.request.execute()).andReturn(response);
-		expect(errorHandler.hasError(response)).andReturn(false);
+		given(this.request.execute()).willReturn(response);
+		given(errorHandler.hasError(response)).willReturn(false);
 		HttpHeaders responseHeaders = new HttpHeaders();
 		responseHeaders.setContentType(MediaType.TEXT_PLAIN);
 		responseHeaders.setContentLength(10);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		expect(response.getHeaders()).andReturn(responseHeaders).times(3);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		given(response.getHeaders()).willReturn(responseHeaders);
 		List<Integer> expected = Collections.singletonList(42);
-		expect(converter.canRead(intList.getType(), null, MediaType.TEXT_PLAIN)).andReturn(true);
-		expect(converter.read(intList.getType(), null, response)).andReturn(expected);
-		expect(response.getStatusCode()).andReturn(HttpStatus.OK);
-		addLogResponseStatusExpectations(HttpStatus.OK);
-		response.close();
-
-		replay(requestFactory, request, response, errorHandler, converter);
+		given(converter.canRead(intList.getType(), null, MediaType.TEXT_PLAIN)).willReturn(true);
+		given(converter.read(intList.getType(), null, response)).willReturn(expected);
+		given(response.getStatusCode()).willReturn(HttpStatus.OK);
+		HttpStatus status = HttpStatus.OK;
+		given(response.getStatusCode()).willReturn(status);
+		given(response.getStatusText()).willReturn(status.getReasonPhrase());
 
 		HttpHeaders entityHeaders = new HttpHeaders();
 		entityHeaders.set("MyHeader", "MyValue");
@@ -700,22 +678,6 @@ public void exchangeParameterizedType() throws Exception {
 		assertEquals("Invalid custom header", "MyValue", requestHeaders.getFirst("MyHeader"));
 		assertEquals("Invalid status code", HttpStatus.OK, result.getStatusCode());
 
-		verify(requestFactory, request, response, errorHandler, converter);
+		verify(response).close();
 	}
-
-
-	private void addLogResponseStatusExpectations(HttpStatus status) throws IOException {
-		expect(response.getStatusCode()).andReturn(status).times(0, 1);
-		expect(response.getStatusText()).andReturn(status.getReasonPhrase()).times(0, 1);
-	}
-
-	private void replayMocks() {
-		replay(requestFactory, request, response, errorHandler, converter);
-	}
-
-	private void verifyMocks() {
-		verify(requestFactory, request, response, errorHandler, converter);
-	}
-
-
 }
diff --git a/spring-web/src/test/java/org/springframework/web/context/request/ServletRequestAttributesTests.java b/spring-web/src/test/java/org/springframework/web/context/request/ServletRequestAttributesTests.java
index dc6ea054101b..2e5688857f82 100644
--- a/spring-web/src/test/java/org/springframework/web/context/request/ServletRequestAttributesTests.java
+++ b/spring-web/src/test/java/org/springframework/web/context/request/ServletRequestAttributesTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,15 +17,16 @@
 package org.springframework.web.context.request;
 
 import java.io.Serializable;
+
 import javax.servlet.http.HttpServletRequest;
 
-import org.easymock.MockControl;
-import static org.junit.Assert.*;
 import org.junit.Test;
-
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockHttpSession;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
@@ -132,17 +133,12 @@ public void setGlobalSessionScopedAttributeAfterCompletion() throws Exception {
 
 	@Test
 	public void getSessionScopedAttributeDoesNotForceCreationOfSession() throws Exception {
-		MockControl mockRequest = MockControl.createControl(HttpServletRequest.class);
-		HttpServletRequest request = (HttpServletRequest) mockRequest.getMock();
-		request.getSession(false);
-		mockRequest.setReturnValue(null, 1);
-		mockRequest.replay();
+		HttpServletRequest request = mock(HttpServletRequest.class);
 
 		ServletRequestAttributes attrs = new ServletRequestAttributes(request);
 		Object value = attrs.getAttribute(KEY, RequestAttributes.SCOPE_SESSION);
 		assertNull(value);
-
-		mockRequest.verify();
+		verify(request).getSession(false);
 	}
 
 	@Test
@@ -159,16 +155,11 @@ public void removeSessionScopedAttribute() throws Exception {
 
 	@Test
 	public void removeSessionScopedAttributeDoesNotForceCreationOfSession() throws Exception {
-		MockControl mockRequest = MockControl.createControl(HttpServletRequest.class);
-		HttpServletRequest request = (HttpServletRequest) mockRequest.getMock();
-		request.getSession(false);
-		mockRequest.setReturnValue(null, 1);
-		mockRequest.replay();
+		HttpServletRequest request = mock(HttpServletRequest.class);
 
 		ServletRequestAttributes attrs = new ServletRequestAttributes(request);
 		attrs.removeAttribute(KEY, RequestAttributes.SCOPE_SESSION);
-
-		mockRequest.verify();
+		verify(request).getSession(false);
 	}
 
 }
diff --git a/spring-web/src/test/java/org/springframework/web/context/request/async/DeferredResultTests.java b/spring-web/src/test/java/org/springframework/web/context/request/async/DeferredResultTests.java
index 2590481d3d3d..dbdf0a5a2be3 100644
--- a/spring-web/src/test/java/org/springframework/web/context/request/async/DeferredResultTests.java
+++ b/spring-web/src/test/java/org/springframework/web/context/request/async/DeferredResultTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,16 +16,12 @@
 
 package org.springframework.web.context.request.async;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
 import org.junit.Test;
 import org.springframework.web.context.request.async.DeferredResult.DeferredResultHandler;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * DeferredResult tests.
  *
@@ -35,23 +31,18 @@ public class DeferredResultTests {
 
 	@Test
 	public void setResult() {
-		DeferredResultHandler handler = createMock(DeferredResultHandler.class);
-		handler.handleResult("hello");
-		replay(handler);
+		DeferredResultHandler handler = mock(DeferredResultHandler.class);
 
 		DeferredResult<String> result = new DeferredResult<String>();
 		result.setResultHandler(handler);
 
 		assertTrue(result.setResult("hello"));
-
-		verify(handler);
+		verify(handler).handleResult("hello");
 	}
 
 	@Test
 	public void setResultTwice() {
-		DeferredResultHandler handler = createMock(DeferredResultHandler.class);
-		handler.handleResult("hello");
-		replay(handler);
+		DeferredResultHandler handler = mock(DeferredResultHandler.class);
 
 		DeferredResult<String> result = new DeferredResult<String>();
 		result.setResultHandler(handler);
@@ -59,14 +50,12 @@ public void setResultTwice() {
 		assertTrue(result.setResult("hello"));
 		assertFalse(result.setResult("hi"));
 
-		verify(handler);
+		verify(handler).handleResult("hello");
 	}
 
 	@Test
 	public void isSetOrExpired() {
-		DeferredResultHandler handler = createMock(DeferredResultHandler.class);
-		handler.handleResult("hello");
-		replay(handler);
+		DeferredResultHandler handler = mock(DeferredResultHandler.class);
 
 		DeferredResult<String> result = new DeferredResult<String>();
 		result.setResultHandler(handler);
@@ -77,7 +66,7 @@ public void isSetOrExpired() {
 
 		assertTrue(result.isSetOrExpired());
 
-		verify(handler);
+		verify(handler).handleResult("hello");
 	}
 
 	@Test
@@ -102,9 +91,7 @@ public void run() {
 	public void onTimeout() throws Exception {
 		final StringBuilder sb = new StringBuilder();
 
-		DeferredResultHandler handler = createMock(DeferredResultHandler.class);
-		handler.handleResult("timeout result");
-		replay(handler);
+		DeferredResultHandler handler = mock(DeferredResultHandler.class);
 
 		DeferredResult<String> result = new DeferredResult<String>(null, "timeout result");
 		result.setResultHandler(handler);
@@ -119,7 +106,7 @@ public void run() {
 
 		assertEquals("timeout event", sb.toString());
 		assertFalse("Should not be able to set result a second time", result.setResult("hello"));
-		verify(handler);
+		verify(handler).handleResult("timeout result");
 	}
 
 }
diff --git a/spring-web/src/test/java/org/springframework/web/context/request/async/StandardServletAsyncWebRequestTests.java b/spring-web/src/test/java/org/springframework/web/context/request/async/StandardServletAsyncWebRequestTests.java
index cbd7dfeee2ec..d378bd8edca3 100644
--- a/spring-web/src/test/java/org/springframework/web/context/request/async/StandardServletAsyncWebRequestTests.java
+++ b/spring-web/src/test/java/org/springframework/web/context/request/async/StandardServletAsyncWebRequestTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,26 +17,18 @@
 package org.springframework.web.context.request.async;
 
 
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import javax.servlet.AsyncEvent;
 
-import org.easymock.EasyMock;
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.mock.web.test.MockAsyncContext;
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockHttpServletResponse;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * A test fixture with a {@link StandardServletAsyncWebRequest}.
  *
@@ -124,14 +116,12 @@ public void onTimeoutDefaultBehavior() throws Exception {
 
 	@Test
 	public void onTimeoutTimeoutHandler() throws Exception {
-		Runnable timeoutHandler = EasyMock.createMock(Runnable.class);
-		timeoutHandler.run();
-		replay(timeoutHandler);
+		Runnable timeoutHandler = mock(Runnable.class);
 
 		this.asyncRequest.addTimeoutHandler(timeoutHandler);
 		this.asyncRequest.onTimeout(new AsyncEvent(null));
 
-		verify(timeoutHandler);
+		verify(timeoutHandler).run();
 	}
 
 	@Test(expected=IllegalStateException.class)
diff --git a/spring-web/src/test/java/org/springframework/web/context/request/async/WebAsyncManagerTests.java b/spring-web/src/test/java/org/springframework/web/context/request/async/WebAsyncManagerTests.java
index 506201f5ba58..f9ec9666ecdf 100644
--- a/spring-web/src/test/java/org/springframework/web/context/request/async/WebAsyncManagerTests.java
+++ b/spring-web/src/test/java/org/springframework/web/context/request/async/WebAsyncManagerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,30 +16,19 @@
 
 package org.springframework.web.context.request.async;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.createStrictMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.expectLastCall;
-import static org.easymock.EasyMock.notNull;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.reset;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.util.concurrent.Callable;
 
 import javax.servlet.http.HttpServletRequest;
 
-import org.easymock.EasyMock;
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.core.task.AsyncTaskExecutor;
 import org.springframework.core.task.SimpleAsyncTaskExecutor;
 import org.springframework.mock.web.test.MockHttpServletRequest;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test fixture with an {@link WebAsyncManager} with a mock AsyncWebRequest.
  *
@@ -59,14 +48,9 @@ public void setUp() {
 		this.servletRequest = new MockHttpServletRequest();
 		this.asyncManager = WebAsyncUtils.getAsyncManager(servletRequest);
 		this.asyncManager.setTaskExecutor(new SyncTaskExecutor());
-
-		this.asyncWebRequest = createStrictMock(AsyncWebRequest.class);
-		this.asyncWebRequest.addCompletionHandler((Runnable) notNull());
-		replay(this.asyncWebRequest);
-
+		this.asyncWebRequest = mock(AsyncWebRequest.class);
 		this.asyncManager.setAsyncWebRequest(this.asyncWebRequest);
-
-		verify(this.asyncWebRequest);
+		verify(this.asyncWebRequest).addCompletionHandler((Runnable) notNull());
 		reset(this.asyncWebRequest);
 	}
 
@@ -93,21 +77,14 @@ public void startAsyncProcessingWithoutAsyncWebRequest() throws Exception {
 
 	@Test
 	public void isConcurrentHandlingStarted() {
-
-		expect(this.asyncWebRequest.isAsyncStarted()).andReturn(false);
-		replay(this.asyncWebRequest);
+		given(this.asyncWebRequest.isAsyncStarted()).willReturn(false);
 
 		assertFalse(this.asyncManager.isConcurrentHandlingStarted());
 
-		verify(this.asyncWebRequest);
 		reset(this.asyncWebRequest);
-
-		expect(this.asyncWebRequest.isAsyncStarted()).andReturn(true);
-		replay(this.asyncWebRequest);
+		given(this.asyncWebRequest.isAsyncStarted()).willReturn(true);
 
 		assertTrue(this.asyncManager.isConcurrentHandlingStarted());
-
-		verify(this.asyncWebRequest);
 	}
 
 	@Test(expected=IllegalArgumentException.class)
@@ -122,11 +99,7 @@ public void startCallableProcessing() throws Exception {
 		int concurrentResult = 21;
 		Callable<Object> task = new StubCallable(concurrentResult);
 
-		CallableProcessingInterceptor interceptor = createStrictMock(CallableProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, task);
-		interceptor.preProcess(this.asyncWebRequest, task);
-		interceptor.postProcess(this.asyncWebRequest, task, new Integer(concurrentResult));
-		replay(interceptor);
+		CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class);
 
 		setupDefaultAsyncScenario();
 
@@ -136,7 +109,10 @@ public void startCallableProcessing() throws Exception {
 		assertTrue(this.asyncManager.hasConcurrentResult());
 		assertEquals(concurrentResult, this.asyncManager.getConcurrentResult());
 
-		verify(interceptor, this.asyncWebRequest);
+		verifyDefaultAsyncScenario();
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, task);
+		verify(interceptor).preProcess(this.asyncWebRequest, task);
+		verify(interceptor).postProcess(this.asyncWebRequest, task, new Integer(concurrentResult));
 	}
 
 	@Test
@@ -145,11 +121,7 @@ public void startCallableProcessingCallableException() throws Exception {
 		Exception concurrentResult = new Exception();
 		Callable<Object> task = new StubCallable(concurrentResult);
 
-		CallableProcessingInterceptor interceptor = createStrictMock(CallableProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, task);
-		interceptor.preProcess(this.asyncWebRequest, task);
-		interceptor.postProcess(this.asyncWebRequest, task, concurrentResult);
-		replay(interceptor);
+		CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class);
 
 		setupDefaultAsyncScenario();
 
@@ -159,7 +131,10 @@ public void startCallableProcessingCallableException() throws Exception {
 		assertTrue(this.asyncManager.hasConcurrentResult());
 		assertEquals(concurrentResult, this.asyncManager.getConcurrentResult());
 
-		verify(interceptor, this.asyncWebRequest);
+		verifyDefaultAsyncScenario();
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, task);
+		verify(interceptor).preProcess(this.asyncWebRequest, task);
+		verify(interceptor).postProcess(this.asyncWebRequest, task, concurrentResult);
 	}
 
 	@Test
@@ -167,14 +142,8 @@ public void startCallableProcessingBeforeConcurrentHandlingException() throws Ex
 		Callable<Object> task = new StubCallable(21);
 		Exception exception = new Exception();
 
-		CallableProcessingInterceptor interceptor = createStrictMock(CallableProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, task);
-		expectLastCall().andThrow(exception);
-		replay(interceptor);
-
-		this.asyncWebRequest.addTimeoutHandler((Runnable) notNull());
-		this.asyncWebRequest.addCompletionHandler((Runnable) notNull());
-		replay(this.asyncWebRequest);
+		CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class);
+		willThrow(exception).given(interceptor).beforeConcurrentHandling(this.asyncWebRequest, task);
 
 		this.asyncManager.registerCallableInterceptor("interceptor", interceptor);
 
@@ -187,7 +156,8 @@ public void startCallableProcessingBeforeConcurrentHandlingException() throws Ex
 
 		assertFalse(this.asyncManager.hasConcurrentResult());
 
-		verify(this.asyncWebRequest, interceptor);
+		verify(this.asyncWebRequest).addTimeoutHandler((Runnable) notNull());
+		verify(this.asyncWebRequest).addCompletionHandler((Runnable) notNull());
 	}
 
 	@Test
@@ -196,11 +166,8 @@ public void startCallableProcessingPreProcessException() throws Exception {
 		Callable<Object> task = new StubCallable(21);
 		Exception exception = new Exception();
 
-		CallableProcessingInterceptor interceptor = createStrictMock(CallableProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, task);
-		interceptor.preProcess(this.asyncWebRequest, task);
-		expectLastCall().andThrow(exception);
-		replay(interceptor);
+		CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class);
+		willThrow(exception).given(interceptor).preProcess(this.asyncWebRequest, task);
 
 		setupDefaultAsyncScenario();
 
@@ -210,7 +177,8 @@ public void startCallableProcessingPreProcessException() throws Exception {
 		assertTrue(this.asyncManager.hasConcurrentResult());
 		assertEquals(exception, this.asyncManager.getConcurrentResult());
 
-		verify(interceptor, this.asyncWebRequest);
+		verifyDefaultAsyncScenario();
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, task);
 	}
 
 	@Test
@@ -219,12 +187,8 @@ public void startCallableProcessingPostProcessException() throws Exception {
 		Callable<Object> task = new StubCallable(21);
 		Exception exception = new Exception();
 
-		CallableProcessingInterceptor interceptor = createStrictMock(CallableProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, task);
-		interceptor.preProcess(this.asyncWebRequest, task);
-		interceptor.postProcess(this.asyncWebRequest, task, 21);
-		expectLastCall().andThrow(exception);
-		replay(interceptor);
+		CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class);
+		willThrow(exception).given(interceptor).postProcess(this.asyncWebRequest, task, 21);
 
 		setupDefaultAsyncScenario();
 
@@ -234,7 +198,9 @@ public void startCallableProcessingPostProcessException() throws Exception {
 		assertTrue(this.asyncManager.hasConcurrentResult());
 		assertEquals(exception, this.asyncManager.getConcurrentResult());
 
-		verify(interceptor, this.asyncWebRequest);
+		verifyDefaultAsyncScenario();
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, task);
+		verify(interceptor).preProcess(this.asyncWebRequest, task);
 	}
 
 	@Test
@@ -243,18 +209,9 @@ public void startCallableProcessingPostProcessContinueAfterException() throws Ex
 		Callable<Object> task = new StubCallable(21);
 		Exception exception = new Exception();
 
-		CallableProcessingInterceptor interceptor1 = createMock(CallableProcessingInterceptor.class);
-		interceptor1.beforeConcurrentHandling(this.asyncWebRequest, task);
-		interceptor1.preProcess(this.asyncWebRequest, task);
-		interceptor1.postProcess(this.asyncWebRequest, task, 21);
-		replay(interceptor1);
-
-		CallableProcessingInterceptor interceptor2 = createMock(CallableProcessingInterceptor.class);
-		interceptor2.beforeConcurrentHandling(this.asyncWebRequest, task);
-		interceptor2.preProcess(this.asyncWebRequest, task);
-		interceptor2.postProcess(this.asyncWebRequest, task, 21);
-		expectLastCall().andThrow(exception);
-		replay(interceptor2);
+		CallableProcessingInterceptor interceptor1 = mock(CallableProcessingInterceptor.class);
+		CallableProcessingInterceptor interceptor2 = mock(CallableProcessingInterceptor.class);
+		willThrow(exception).given(interceptor2).postProcess(this.asyncWebRequest, task, 21);
 
 		setupDefaultAsyncScenario();
 
@@ -264,30 +221,29 @@ public void startCallableProcessingPostProcessContinueAfterException() throws Ex
 		assertTrue(this.asyncManager.hasConcurrentResult());
 		assertEquals(exception, this.asyncManager.getConcurrentResult());
 
-		verify(interceptor1);
-		verify(interceptor2);
-		verify(this.asyncWebRequest);
+		verifyDefaultAsyncScenario();
+		verify(interceptor1).beforeConcurrentHandling(this.asyncWebRequest, task);
+		verify(interceptor1).preProcess(this.asyncWebRequest, task);
+		verify(interceptor1).postProcess(this.asyncWebRequest, task, 21);
+		verify(interceptor2).beforeConcurrentHandling(this.asyncWebRequest, task);
+		verify(interceptor2).preProcess(this.asyncWebRequest, task);
 	}
 
 	@Test
 	public void startCallableProcessingWithAsyncTask() throws Exception {
 
-		AsyncTaskExecutor executor = createMock(AsyncTaskExecutor.class);
-		expect(executor.submit((Runnable) notNull())).andReturn(null);
-		replay(executor);
-
-		this.asyncWebRequest.setTimeout(1000L);
-		this.asyncWebRequest.addTimeoutHandler(EasyMock.<Runnable>anyObject());
-		this.asyncWebRequest.addCompletionHandler(EasyMock.<Runnable>anyObject());
-		this.asyncWebRequest.startAsync();
-		expect(this.asyncWebRequest.getNativeRequest(HttpServletRequest.class)).andReturn(this.servletRequest).times(0, 1);
-		replay(this.asyncWebRequest);
+		AsyncTaskExecutor executor = mock(AsyncTaskExecutor.class);
+		given(this.asyncWebRequest.getNativeRequest(HttpServletRequest.class)).willReturn(this.servletRequest);
 
 		@SuppressWarnings("unchecked")
-		WebAsyncTask<Object> asyncTask = new WebAsyncTask<Object>(1000L, executor, createMock(Callable.class));
+		WebAsyncTask<Object> asyncTask = new WebAsyncTask<Object>(1000L, executor, mock(Callable.class));
 		this.asyncManager.startCallableProcessing(asyncTask);
 
-		verify(executor, this.asyncWebRequest);
+		verify(executor).submit((Runnable) notNull());
+		verify(this.asyncWebRequest).setTimeout(1000L);
+		verify(this.asyncWebRequest).addTimeoutHandler(any(Runnable.class));
+		verify(this.asyncWebRequest).addCompletionHandler(any(Runnable.class));
+		verify(this.asyncWebRequest).startAsync();
 	}
 
 	@Test
@@ -307,13 +263,8 @@ public void startDeferredResultProcessing() throws Exception {
 		DeferredResult<String> deferredResult = new DeferredResult<String>(1000L);
 		String concurrentResult = "abc";
 
-		DeferredResultProcessingInterceptor interceptor = createStrictMock(DeferredResultProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
-		interceptor.preProcess(this.asyncWebRequest, deferredResult);
-		interceptor.postProcess(asyncWebRequest, deferredResult, concurrentResult);
-		replay(interceptor);
+		DeferredResultProcessingInterceptor interceptor = mock(DeferredResultProcessingInterceptor.class);
 
-		this.asyncWebRequest.setTimeout(1000L);
 		setupDefaultAsyncScenario();
 
 		this.asyncManager.registerDeferredResultInterceptor("interceptor", interceptor);
@@ -322,7 +273,11 @@ public void startDeferredResultProcessing() throws Exception {
 		deferredResult.setResult(concurrentResult);
 
 		assertEquals(concurrentResult, this.asyncManager.getConcurrentResult());
-		verify(this.asyncWebRequest, interceptor);
+		verifyDefaultAsyncScenario();
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
+		verify(interceptor).preProcess(this.asyncWebRequest, deferredResult);
+		verify(interceptor).postProcess(asyncWebRequest, deferredResult, concurrentResult);
+		verify(this.asyncWebRequest).setTimeout(1000L);
 	}
 
 	@Test
@@ -331,14 +286,8 @@ public void startDeferredResultProcessingBeforeConcurrentHandlingException() thr
 		DeferredResult<Integer> deferredResult = new DeferredResult<Integer>();
 		Exception exception = new Exception();
 
-		DeferredResultProcessingInterceptor interceptor = createStrictMock(DeferredResultProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
-		expectLastCall().andThrow(exception);
-		replay(interceptor);
-
-		this.asyncWebRequest.addTimeoutHandler((Runnable) notNull());
-		this.asyncWebRequest.addCompletionHandler((Runnable) notNull());
-		replay(this.asyncWebRequest);
+		DeferredResultProcessingInterceptor interceptor = mock(DeferredResultProcessingInterceptor.class);
+		willThrow(exception).given(interceptor).beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
 
 		this.asyncManager.registerDeferredResultInterceptor("interceptor", interceptor);
 
@@ -352,7 +301,8 @@ public void startDeferredResultProcessingBeforeConcurrentHandlingException() thr
 
 		assertFalse(this.asyncManager.hasConcurrentResult());
 
-		verify(this.asyncWebRequest, interceptor);
+		verify(this.asyncWebRequest).addTimeoutHandler((Runnable) notNull());
+		verify(this.asyncWebRequest).addCompletionHandler((Runnable) notNull());
 	}
 
 	@Test
@@ -361,11 +311,8 @@ public void startDeferredResultProcessingPreProcessException() throws Exception
 		DeferredResult<Integer> deferredResult = new DeferredResult<Integer>();
 		Exception exception = new Exception();
 
-		DeferredResultProcessingInterceptor interceptor = createStrictMock(DeferredResultProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
-		interceptor.preProcess(this.asyncWebRequest, deferredResult);
-		expectLastCall().andThrow(exception);
-		replay(interceptor);
+		DeferredResultProcessingInterceptor interceptor = mock(DeferredResultProcessingInterceptor.class);
+		willThrow(exception).given(interceptor).preProcess(this.asyncWebRequest, deferredResult);
 
 		setupDefaultAsyncScenario();
 
@@ -375,7 +322,8 @@ public void startDeferredResultProcessingPreProcessException() throws Exception
 		deferredResult.setResult(25);
 
 		assertEquals(exception, this.asyncManager.getConcurrentResult());
-		verify(this.asyncWebRequest, interceptor);
+		verifyDefaultAsyncScenario();
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
 	}
 
 	@Test
@@ -384,12 +332,8 @@ public void startDeferredResultProcessingPostProcessException() throws Exception
 		DeferredResult<Integer> deferredResult = new DeferredResult<Integer>();
 		Exception exception = new Exception();
 
-		DeferredResultProcessingInterceptor interceptor = createStrictMock(DeferredResultProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
-		interceptor.preProcess(this.asyncWebRequest, deferredResult);
-		interceptor.postProcess(this.asyncWebRequest, deferredResult, 25);
-		expectLastCall().andThrow(exception);
-		replay(interceptor);
+		DeferredResultProcessingInterceptor interceptor = mock(DeferredResultProcessingInterceptor.class);
+		willThrow(exception).given(interceptor).postProcess(this.asyncWebRequest, deferredResult, 25);;
 
 		setupDefaultAsyncScenario();
 
@@ -399,7 +343,9 @@ public void startDeferredResultProcessingPostProcessException() throws Exception
 		deferredResult.setResult(25);
 
 		assertEquals(exception, this.asyncManager.getConcurrentResult());
-		verify(this.asyncWebRequest, interceptor);
+		verifyDefaultAsyncScenario();
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
+		verify(interceptor).preProcess(this.asyncWebRequest, deferredResult);
 	}
 
 	@Test
@@ -414,15 +360,16 @@ public void startDeferredResultProcessingNullInput() throws Exception {
 	}
 
 	private void setupDefaultAsyncScenario() {
-		this.asyncWebRequest.addTimeoutHandler((Runnable) notNull());
-		this.asyncWebRequest.addCompletionHandler((Runnable) notNull());
-		this.asyncWebRequest.startAsync();
-		expect(this.asyncWebRequest.getNativeRequest(HttpServletRequest.class)).andReturn(this.servletRequest).times(0, 1);
-		expect(this.asyncWebRequest.isAsyncComplete()).andReturn(false);
-		this.asyncWebRequest.dispatch();
-		replay(this.asyncWebRequest);
+		given(this.asyncWebRequest.getNativeRequest(HttpServletRequest.class)).willReturn(this.servletRequest);
+		given(this.asyncWebRequest.isAsyncComplete()).willReturn(false);
 	}
 
+	private void verifyDefaultAsyncScenario() {
+		verify(this.asyncWebRequest).addTimeoutHandler((Runnable) notNull());
+		verify(this.asyncWebRequest).addCompletionHandler((Runnable) notNull());
+		verify(this.asyncWebRequest).startAsync();
+		verify(this.asyncWebRequest).dispatch();
+	}
 
 	private final class StubCallable implements Callable<Object> {
 
diff --git a/spring-web/src/test/java/org/springframework/web/context/request/async/WebAsyncManagerTimeoutTests.java b/spring-web/src/test/java/org/springframework/web/context/request/async/WebAsyncManagerTimeoutTests.java
index 936be8d79aa7..adccdb11ebea 100644
--- a/spring-web/src/test/java/org/springframework/web/context/request/async/WebAsyncManagerTimeoutTests.java
+++ b/spring-web/src/test/java/org/springframework/web/context/request/async/WebAsyncManagerTimeoutTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,17 +16,6 @@
 
 package org.springframework.web.context.request.async;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.createStrictMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.notNull;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.springframework.web.context.request.async.CallableProcessingInterceptor.RESULT_NONE;
-
 import java.util.concurrent.Callable;
 
 import javax.servlet.AsyncEvent;
@@ -40,6 +29,10 @@
 import org.springframework.mock.web.test.MockHttpServletResponse;
 import org.springframework.web.context.request.NativeWebRequest;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+import static org.springframework.web.context.request.async.CallableProcessingInterceptor.*;
+
 /**
  * {@link WebAsyncManager} tests where container-triggered timeout/completion
  * events are simulated.
@@ -65,9 +58,7 @@ public void setUp() {
 		this.servletResponse = new MockHttpServletResponse();
 		this.asyncWebRequest = new StandardServletAsyncWebRequest(servletRequest, servletResponse);
 
-		AsyncTaskExecutor executor = createMock(AsyncTaskExecutor.class);
-		expect(executor.submit((Runnable) notNull())).andReturn(null);
-		replay(executor);
+		AsyncTaskExecutor executor = mock(AsyncTaskExecutor.class);
 
 		this.asyncManager = WebAsyncUtils.getAsyncManager(servletRequest);
 		this.asyncManager.setTaskExecutor(executor);
@@ -79,11 +70,8 @@ public void startCallableProcessingTimeoutAndComplete() throws Exception {
 
 		StubCallable callable = new StubCallable();
 
-		CallableProcessingInterceptor interceptor = createStrictMock(CallableProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, callable);
-		expect(interceptor.handleTimeout(this.asyncWebRequest, callable)).andReturn(RESULT_NONE);
-		interceptor.afterCompletion(this.asyncWebRequest, callable);
-		replay(interceptor);
+		CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class);
+		given(interceptor.handleTimeout(this.asyncWebRequest, callable)).willReturn(RESULT_NONE);
 
 		this.asyncManager.registerCallableInterceptor("interceptor", interceptor);
 		this.asyncManager.startCallableProcessing(callable);
@@ -95,7 +83,8 @@ public void startCallableProcessingTimeoutAndComplete() throws Exception {
 		assertEquals(DispatcherType.REQUEST, this.servletRequest.getDispatcherType());
 		assertEquals(503, this.servletResponse.getStatus());
 
-		verify(interceptor);
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, callable);
+		verify(interceptor).afterCompletion(this.asyncWebRequest, callable);
 	}
 
 	@Test
@@ -124,10 +113,8 @@ public void startCallableProcessingTimeoutAndResumeThroughInterceptor() throws E
 
 		StubCallable callable = new StubCallable();
 
-		CallableProcessingInterceptor interceptor = createStrictMock(CallableProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, callable);
-		expect(interceptor.handleTimeout(this.asyncWebRequest, callable)).andReturn(22);
-		replay(interceptor);
+		CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class);
+		given(interceptor.handleTimeout(this.asyncWebRequest, callable)).willReturn(22);
 
 		this.asyncManager.registerCallableInterceptor("timeoutInterceptor", interceptor);
 		this.asyncManager.startCallableProcessing(callable);
@@ -138,7 +125,7 @@ public void startCallableProcessingTimeoutAndResumeThroughInterceptor() throws E
 		assertEquals(22, this.asyncManager.getConcurrentResult());
 		assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath());
 
-		verify(interceptor);
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, callable);
 	}
 
 	@Test
@@ -147,10 +134,8 @@ public void startCallableProcessingAfterTimeoutException() throws Exception {
 		StubCallable callable = new StubCallable();
 		Exception exception = new Exception();
 
-		CallableProcessingInterceptor interceptor = createStrictMock(CallableProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, callable);
-		expect(interceptor.handleTimeout(this.asyncWebRequest, callable)).andThrow(exception);
-		replay(interceptor);
+		CallableProcessingInterceptor interceptor = mock(CallableProcessingInterceptor.class);
+		given(interceptor.handleTimeout(this.asyncWebRequest, callable)).willThrow(exception);
 
 		this.asyncManager.registerCallableInterceptor("timeoutInterceptor", interceptor);
 		this.asyncManager.startCallableProcessing(callable);
@@ -161,7 +146,7 @@ public void startCallableProcessingAfterTimeoutException() throws Exception {
 		assertEquals(exception, this.asyncManager.getConcurrentResult());
 		assertEquals("/test", ((MockAsyncContext) this.servletRequest.getAsyncContext()).getDispatchedPath());
 
-		verify(interceptor);
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, callable);
 	}
 
 	@Test
@@ -169,12 +154,8 @@ public void startDeferredResultProcessingTimeoutAndComplete() throws Exception {
 
 		DeferredResult<Integer> deferredResult = new DeferredResult<Integer>();
 
-		DeferredResultProcessingInterceptor interceptor = createStrictMock(DeferredResultProcessingInterceptor.class);
-		interceptor.beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
-		interceptor.preProcess(this.asyncWebRequest, deferredResult);
-		expect(interceptor.handleTimeout(this.asyncWebRequest, deferredResult)).andReturn(true);
-		interceptor.afterCompletion(this.asyncWebRequest, deferredResult);
-		replay(interceptor);
+		DeferredResultProcessingInterceptor interceptor = mock(DeferredResultProcessingInterceptor.class);
+		given(interceptor.handleTimeout(this.asyncWebRequest, deferredResult)).willReturn(true);
 
 		this.asyncManager.registerDeferredResultInterceptor("interceptor", interceptor);
 		this.asyncManager.startDeferredResultProcessing(deferredResult);
@@ -186,7 +167,9 @@ public void startDeferredResultProcessingTimeoutAndComplete() throws Exception {
 		assertEquals(DispatcherType.REQUEST, this.servletRequest.getDispatcherType());
 		assertEquals(503, this.servletResponse.getStatus());
 
-		verify(interceptor);
+		verify(interceptor).beforeConcurrentHandling(this.asyncWebRequest, deferredResult);
+		verify(interceptor).preProcess(this.asyncWebRequest, deferredResult);
+		verify(interceptor).afterCompletion(this.asyncWebRequest, deferredResult);
 	}
 
 	@Test
diff --git a/spring-web/src/test/java/org/springframework/web/filter/CharacterEncodingFilterTests.java b/spring-web/src/test/java/org/springframework/web/filter/CharacterEncodingFilterTests.java
index 141d68cfaee0..6091fa6a80cb 100644
--- a/spring-web/src/test/java/org/springframework/web/filter/CharacterEncodingFilterTests.java
+++ b/spring-web/src/test/java/org/springframework/web/filter/CharacterEncodingFilterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,6 @@
 
 package org.springframework.web.filter;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.expectLastCall;
-import static org.easymock.EasyMock.notNull;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.same;
-import static org.easymock.EasyMock.verify;
-
 import javax.servlet.FilterChain;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
@@ -33,9 +25,10 @@
 import org.springframework.mock.web.test.MockFilterConfig;
 import org.springframework.mock.web.test.MockHttpServletResponse;
 import org.springframework.mock.web.test.MockServletContext;
-import org.springframework.web.context.request.async.WebAsyncUtils;
 import org.springframework.web.util.WebUtils;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
@@ -48,22 +41,13 @@ public class CharacterEncodingFilterTests extends TestCase {
 
 
 	public void testForceAlwaysSetsEncoding() throws Exception {
-		HttpServletRequest request = createMock(HttpServletRequest.class);
-		addAsyncManagerExpectations(request);
+		HttpServletRequest request = mock(HttpServletRequest.class);
 		request.setCharacterEncoding(ENCODING);
-		expect(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).andReturn(null);
-		expect(request.getAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).andReturn(null);
-		request.setAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
-		request.removeAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
-		replay(request);
-
-		HttpServletResponse response = createMock(HttpServletResponse.class);
-		response.setCharacterEncoding(ENCODING);
-		replay(response);
+		given(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).willReturn(null);
+		given(request.getAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).willReturn(null);
 
-		FilterChain filterChain = createMock(FilterChain.class);
-		filterChain.doFilter(request, response);
-		replay(filterChain);
+		HttpServletResponse response = mock(HttpServletResponse.class);
+		FilterChain filterChain = mock(FilterChain.class);
 
 		CharacterEncodingFilter filter = new CharacterEncodingFilter();
 		filter.setForceEncoding(true);
@@ -71,27 +55,21 @@ public void testForceAlwaysSetsEncoding() throws Exception {
 		filter.init(new MockFilterConfig(FILTER_NAME));
 		filter.doFilter(request, response, filterChain);
 
-		verify(request);
-		verify(response);
-		verify(filterChain);
+		verify(request).setAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
+		verify(request).removeAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
+		verify(response).setCharacterEncoding(ENCODING);
+		verify(filterChain).doFilter(request, response);
 	}
 
 	public void testEncodingIfEmptyAndNotForced() throws Exception {
-		HttpServletRequest request = createMock(HttpServletRequest.class);
-		addAsyncManagerExpectations(request);
-		expect(request.getCharacterEncoding()).andReturn(null);
-		request.setCharacterEncoding(ENCODING);
-		expect(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).andReturn(null);
-		expect(request.getAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).andReturn(null);
-		request.setAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
-		request.removeAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
-		replay(request);
+		HttpServletRequest request = mock(HttpServletRequest.class);
+		given(request.getCharacterEncoding()).willReturn(null);
+		given(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).willReturn(null);
+		given(request.getAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).willReturn(null);
 
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		FilterChain filterChain = createMock(FilterChain.class);
-		filterChain.doFilter(request, response);
-		replay(filterChain);
+		FilterChain filterChain = mock(FilterChain.class);
 
 		CharacterEncodingFilter filter = new CharacterEncodingFilter();
 		filter.setForceEncoding(false);
@@ -99,51 +77,41 @@ public void testEncodingIfEmptyAndNotForced() throws Exception {
 		filter.init(new MockFilterConfig(FILTER_NAME));
 		filter.doFilter(request, response, filterChain);
 
-		verify(request);
-		verify(filterChain);
+		verify(request).setCharacterEncoding(ENCODING);
+		verify(request).setAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
+		verify(request).removeAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
+		verify(filterChain).doFilter(request, response);
 	}
 
 	public void testDoesNowtIfEncodingIsNotEmptyAndNotForced() throws Exception {
-		HttpServletRequest request = createMock(HttpServletRequest.class);
-		addAsyncManagerExpectations(request);
-		expect(request.getCharacterEncoding()).andReturn(ENCODING);
-		expect(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).andReturn(null);
-		expect(request.getAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).andReturn(null);
-		request.setAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
-		request.removeAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
-		replay(request);
+		HttpServletRequest request = mock(HttpServletRequest.class);
+		given(request.getCharacterEncoding()).willReturn(ENCODING);
+		given(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).willReturn(null);
+		given(request.getAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).willReturn(null);
 
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		FilterChain filterChain = createMock(FilterChain.class);
-		filterChain.doFilter(request, response);
-		replay(filterChain);
+		FilterChain filterChain = mock(FilterChain.class);
 
 		CharacterEncodingFilter filter = new CharacterEncodingFilter();
 		filter.setEncoding(ENCODING);
 		filter.init(new MockFilterConfig(FILTER_NAME));
 		filter.doFilter(request, response, filterChain);
 
-		verify(request);
-		verify(filterChain);
+		verify(request).setAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
+		verify(request).removeAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
+		verify(filterChain).doFilter(request, response);
 	}
 
 	public void testWithBeanInitialization() throws Exception {
-		HttpServletRequest request = createMock(HttpServletRequest.class);
-		addAsyncManagerExpectations(request);
-		expect(request.getCharacterEncoding()).andReturn(null);
-		request.setCharacterEncoding(ENCODING);
-		expect(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).andReturn(null);
-		expect(request.getAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).andReturn(null);
-		request.setAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
-		request.removeAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
-		replay(request);
+		HttpServletRequest request = mock(HttpServletRequest.class);
+		given(request.getCharacterEncoding()).willReturn(null);
+		given(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).willReturn(null);
+		given(request.getAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).willReturn(null);
 
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		FilterChain filterChain = createMock(FilterChain.class);
-		filterChain.doFilter(request, response);
-		replay(filterChain);
+		FilterChain filterChain = mock(FilterChain.class);
 
 		CharacterEncodingFilter filter = new CharacterEncodingFilter();
 		filter.setEncoding(ENCODING);
@@ -151,40 +119,29 @@ public void testWithBeanInitialization() throws Exception {
 		filter.setServletContext(new MockServletContext());
 		filter.doFilter(request, response, filterChain);
 
-		verify(request);
-		verify(filterChain);
+		verify(request).setCharacterEncoding(ENCODING);
+		verify(request).setAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
+		verify(request).removeAttribute(FILTER_NAME + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
+		verify(filterChain).doFilter(request, response);
 	}
 
 	public void testWithIncompleteInitialization() throws Exception {
-		HttpServletRequest request = createMock(HttpServletRequest.class);
-		addAsyncManagerExpectations(request);
-		expect(request.getCharacterEncoding()).andReturn(null);
-		request.setCharacterEncoding(ENCODING);
-		expect(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).andReturn(null);
-		expect(request.getAttribute(CharacterEncodingFilter.class.getName() + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).andReturn(null);
-		request.setAttribute(CharacterEncodingFilter.class.getName() + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
-		request.removeAttribute(CharacterEncodingFilter.class.getName() + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
-		replay(request);
+		HttpServletRequest request = mock(HttpServletRequest.class);
+		given(request.getCharacterEncoding()).willReturn(null);
+		given(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE)).willReturn(null);
+		given(request.getAttribute(CharacterEncodingFilter.class.getName() + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX)).willReturn(null);
 
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		FilterChain filterChain = createMock(FilterChain.class);
-		filterChain.doFilter(request, response);
-		replay(filterChain);
+		FilterChain filterChain = mock(FilterChain.class);
 
 		CharacterEncodingFilter filter = new CharacterEncodingFilter();
 		filter.setEncoding(ENCODING);
 		filter.doFilter(request, response, filterChain);
 
-		verify(request);
-		verify(filterChain);
-	}
-
-
-	private void addAsyncManagerExpectations(HttpServletRequest request) {
-		expect(request.getAttribute(WebAsyncUtils.WEB_ASYNC_MANAGER_ATTRIBUTE)).andReturn(null);
-		expectLastCall().anyTimes();
-		request.setAttribute(same(WebAsyncUtils.WEB_ASYNC_MANAGER_ATTRIBUTE), notNull());
-		expectLastCall().anyTimes();
+		verify(request).setCharacterEncoding(ENCODING);
+		verify(request).setAttribute(CharacterEncodingFilter.class.getName() + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX, Boolean.TRUE);
+		verify(request).removeAttribute(CharacterEncodingFilter.class.getName() + OncePerRequestFilter.ALREADY_FILTERED_SUFFIX);
+		verify(filterChain).doFilter(request, response);
 	}
 }
diff --git a/spring-web/src/test/java/org/springframework/web/method/annotation/InitBinderDataBinderFactoryTests.java b/spring-web/src/test/java/org/springframework/web/method/annotation/InitBinderDataBinderFactoryTests.java
index 40b600377cb8..866fcae1add8 100644
--- a/spring-web/src/test/java/org/springframework/web/method/annotation/InitBinderDataBinderFactoryTests.java
+++ b/spring-web/src/test/java/org/springframework/web/method/annotation/InitBinderDataBinderFactoryTests.java
@@ -140,29 +140,25 @@ private WebDataBinderFactory createBinderFactory(String methodName, Class<?>...
 
 	private static class InitBinderHandler {
 
-		@SuppressWarnings("unused")
 		@InitBinder
 		public void initBinder(WebDataBinder dataBinder) {
 			dataBinder.setDisallowedFields("id");
 		}
 
-		@SuppressWarnings("unused")
 		@InitBinder(value="foo")
 		public void initBinderWithAttributeName(WebDataBinder dataBinder) {
 			dataBinder.setDisallowedFields("id");
 		}
 
-		@SuppressWarnings("unused")
 		@InitBinder
 		public String initBinderReturnValue(WebDataBinder dataBinder) {
 			return "invalid";
 		}
 
-		@SuppressWarnings("unused")
 		@InitBinder
 		public void initBinderTypeConversion(WebDataBinder dataBinder, @RequestParam int requestParam) {
 			dataBinder.setDisallowedFields("requestParam-" + requestParam);
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/test/java/org/springframework/web/method/annotation/ModelAttributeMethodProcessorTests.java b/spring-web/src/test/java/org/springframework/web/method/annotation/ModelAttributeMethodProcessorTests.java
index 170e8e2c9b89..297f103e8769 100644
--- a/spring-web/src/test/java/org/springframework/web/method/annotation/ModelAttributeMethodProcessorTests.java
+++ b/spring-web/src/test/java/org/springframework/web/method/annotation/ModelAttributeMethodProcessorTests.java
@@ -22,10 +22,9 @@
 
 import org.junit.Before;
 import org.junit.Test;
-
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.core.MethodParameter;
 import org.springframework.mock.web.test.MockHttpServletRequest;
+import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.validation.BindException;
 import org.springframework.validation.BindingResult;
 import org.springframework.validation.Errors;
@@ -37,13 +36,14 @@
 import org.springframework.web.context.request.NativeWebRequest;
 import org.springframework.web.context.request.ServletWebRequest;
 import org.springframework.web.context.request.WebRequest;
-import org.springframework.web.method.annotation.ModelAttributeMethodProcessor;
 import org.springframework.web.method.support.ModelAndViewContainer;
 
 import static java.lang.annotation.ElementType.*;
 import static java.lang.annotation.RetentionPolicy.*;
-import static org.easymock.EasyMock.*;
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
 
 /**
  * Test fixture with {@link ModelAttributeMethodProcessor}.
@@ -153,26 +153,23 @@ private void getAttributeFromModel(String expectedAttributeName, MethodParameter
 		mavContainer.addAttribute(expectedAttributeName, target);
 
 		WebDataBinder dataBinder = new WebRequestDataBinder(target);
-		WebDataBinderFactory factory = createMock(WebDataBinderFactory.class);
-		expect(factory.createBinder(webRequest, target, expectedAttributeName)).andReturn(dataBinder);
-		replay(factory);
+		WebDataBinderFactory factory = mock(WebDataBinderFactory.class);
+		given(factory.createBinder(webRequest, target, expectedAttributeName)).willReturn(dataBinder);
 
 		processor.resolveArgument(param, mavContainer, webRequest, factory);
-
-		verify(factory);
+		verify(factory).createBinder(webRequest, target, expectedAttributeName);
 	}
 
 	@Test
 	public void resovleArgumentViaDefaultConstructor() throws Exception {
 		WebDataBinder dataBinder = new WebRequestDataBinder(null);
 
-		WebDataBinderFactory factory = createMock(WebDataBinderFactory.class);
-		expect(factory.createBinder((NativeWebRequest) anyObject(), notNull(), eq("attrName"))).andReturn(dataBinder);
-		replay(factory);
+		WebDataBinderFactory factory = mock(WebDataBinderFactory.class);
+		given(factory.createBinder((NativeWebRequest) anyObject(), notNull(), eq("attrName"))).willReturn(dataBinder);
 
 		processor.resolveArgument(paramNamedValidModelAttr, mavContainer, webRequest, factory);
 
-		verify(factory);
+		verify(factory).createBinder((NativeWebRequest) anyObject(), notNull(), eq("attrName"));
 	}
 
 	@Test
@@ -182,9 +179,8 @@ public void resovleArgumentValidation() throws Exception {
 		mavContainer.addAttribute(name, target);
 
 		StubRequestDataBinder dataBinder = new StubRequestDataBinder(target, name);
-		WebDataBinderFactory binderFactory = createMock(WebDataBinderFactory.class);
-		expect(binderFactory.createBinder(webRequest, target, name)).andReturn(dataBinder);
-		replay(binderFactory);
+		WebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);
+		given(binderFactory.createBinder(webRequest, target, name)).willReturn(dataBinder);
 
 		processor.resolveArgument(paramNamedValidModelAttr, mavContainer, webRequest, binderFactory);
 
@@ -201,11 +197,11 @@ public void resovleArgumentBindException() throws Exception {
 		StubRequestDataBinder dataBinder = new StubRequestDataBinder(target, name);
 		dataBinder.getBindingResult().reject("error");
 
-		WebDataBinderFactory binderFactory = createMock(WebDataBinderFactory.class);
-		expect(binderFactory.createBinder(webRequest, target, name)).andReturn(dataBinder);
-		replay(binderFactory);
+		WebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);
+		given(binderFactory.createBinder(webRequest, target, name)).willReturn(dataBinder);
 
 		processor.resolveArgument(paramNonSimpleType, mavContainer, webRequest, binderFactory);
+		verify(binderFactory).createBinder(webRequest, target, name);
 	}
 
 	// SPR-9378
@@ -221,9 +217,8 @@ public void resolveArgumentOrdering() throws Exception {
 		mavContainer.addAttribute("anotherTestBean", anotherTestBean);
 
 		StubRequestDataBinder dataBinder = new StubRequestDataBinder(testBean, name);
-		WebDataBinderFactory binderFactory = createMock(WebDataBinderFactory.class);
-		expect(binderFactory.createBinder(webRequest, testBean, name)).andReturn(dataBinder);
-		replay(binderFactory);
+		WebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);
+		given(binderFactory.createBinder(webRequest, testBean, name)).willReturn(dataBinder);
 
 		processor.resolveArgument(paramModelAttr, mavContainer, webRequest, binderFactory);
 
@@ -299,7 +294,6 @@ public void modelAttribute(@ModelAttribute("attrName") @Valid TestBean annotated
 		}
 	}
 
-	@SuppressWarnings("unused")
 	@ModelAttribute("modelAttrName")
 	private String annotatedReturnValue() {
 		return null;
@@ -310,4 +304,4 @@ private TestBean notAnnotatedReturnValue() {
 		return null;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/test/java/org/springframework/web/method/annotation/ModelFactoryTests.java b/spring-web/src/test/java/org/springframework/web/method/annotation/ModelFactoryTests.java
index 34ca840ce93e..bfa4e49d1e2b 100644
--- a/spring-web/src/test/java/org/springframework/web/method/annotation/ModelFactoryTests.java
+++ b/spring-web/src/test/java/org/springframework/web/method/annotation/ModelFactoryTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,16 +16,6 @@
 
 package org.springframework.web.method.annotation;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.lang.reflect.Method;
 import java.util.Arrays;
 
@@ -48,6 +38,9 @@
 import org.springframework.web.method.support.InvocableHandlerMethod;
 import org.springframework.web.method.support.ModelAndViewContainer;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Text fixture for {@link ModelFactory} tests.
  *
@@ -153,9 +146,8 @@ public void updateModelBindingResultKeys() throws Exception {
 		mavContainer.addAttribute(attrName, attrValue);
 
 		WebDataBinder dataBinder = new WebDataBinder(attrValue, attrName);
-		WebDataBinderFactory binderFactory = createMock(WebDataBinderFactory.class);
-		expect(binderFactory.createBinder(webRequest, attrValue, attrName)).andReturn(dataBinder);
-		replay(binderFactory);
+		WebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);
+		given(binderFactory.createBinder(webRequest, attrValue, attrName)).willReturn(dataBinder);
 
 		ModelFactory modelFactory = new ModelFactory(null, binderFactory, sessionAttrsHandler);
 		modelFactory.updateModel(webRequest, mavContainer);
@@ -163,8 +155,6 @@ public void updateModelBindingResultKeys() throws Exception {
 		assertEquals(attrValue, mavContainer.getModel().remove(attrName));
 		assertSame(dataBinder.getBindingResult(), mavContainer.getModel().remove(bindingResultKey(attrName)));
 		assertEquals(0, mavContainer.getModel().size());
-
-		verify(binderFactory);
 	}
 
 	@Test
@@ -181,17 +171,14 @@ public void updateModelSessionStatusComplete() throws Exception {
 		assertTrue(sessionAttrsHandler.isHandlerSessionAttribute(attrName, null));
 
 		WebDataBinder dataBinder = new WebDataBinder(attrValue, attrName);
-		WebDataBinderFactory binderFactory = createMock(WebDataBinderFactory.class);
-		expect(binderFactory.createBinder(webRequest, attrValue, attrName)).andReturn(dataBinder);
-		replay(binderFactory);
+		WebDataBinderFactory binderFactory = mock(WebDataBinderFactory.class);
+		given(binderFactory.createBinder(webRequest, attrValue, attrName)).willReturn(dataBinder);
 
 		ModelFactory modelFactory = new ModelFactory(null, binderFactory, sessionAttrsHandler);
 		modelFactory.updateModel(webRequest, mavContainer);
 
 		assertEquals(attrValue, mavContainer.getModel().get(attrName));
 		assertNull(sessionAttributeStore.retrieveAttribute(webRequest, attrName));
-
-		verify(binderFactory);
 	}
 
 	private String bindingResultKey(String key) {
diff --git a/spring-web/src/test/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolverTests.java b/spring-web/src/test/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolverTests.java
index f8978d8b176b..bda24d4892a2 100644
--- a/spring-web/src/test/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolverTests.java
+++ b/spring-web/src/test/java/org/springframework/web/method/annotation/RequestParamMethodArgumentResolverTests.java
@@ -68,6 +68,7 @@ public class RequestParamMethodArgumentResolverTests {
 	private MethodParameter paramMultipartFileList;
 	private MethodParameter paramServlet30Part;
 	private MethodParameter paramRequestPartAnnot;
+	private MethodParameter paramRequired;
 
 	private NativeWebRequest webRequest;
 
@@ -80,7 +81,7 @@ public void setUp() throws Exception {
 		ParameterNameDiscoverer paramNameDiscoverer = new LocalVariableTableParameterNameDiscoverer();
 
 		Method method = getClass().getMethod("params", String.class, String[].class, Map.class, MultipartFile.class,
-				Map.class, String.class, MultipartFile.class, List.class, Part.class, MultipartFile.class);
+				Map.class, String.class, MultipartFile.class, List.class, Part.class, MultipartFile.class, String.class);
 
 		paramNamedDefaultValueString = new MethodParameter(method, 0);
 		paramNamedStringArray = new MethodParameter(method, 1);
@@ -96,6 +97,7 @@ public void setUp() throws Exception {
 		paramServlet30Part = new MethodParameter(method, 8);
 		paramServlet30Part.initParameterNameDiscovery(paramNameDiscoverer);
 		paramRequestPartAnnot = new MethodParameter(method, 9);
+		paramRequired = new MethodParameter(method, 10);
 
 		request = new MockHttpServletRequest();
 		webRequest = new ServletWebRequest(request, new MockHttpServletResponse());
@@ -257,16 +259,41 @@ public void resolveSimpleTypeParamToNull() throws Exception {
 		assertNull(result);
 	}
 
+	// SPR-10180
+
+	@Test
+	public void resolveEmptyValueToDefault() throws Exception {
+		this.request.addParameter("name", "");
+		Object result = resolver.resolveArgument(paramNamedDefaultValueString, null, webRequest, null);
+		assertEquals("bar", result);
+	}
+
+	@Test
+	public void resolveEmptyValueWithoutDefault() throws Exception {
+		this.request.addParameter("stringNotAnnot", "");
+		Object result = resolver.resolveArgument(paramStringNotAnnot, null, webRequest, null);
+		assertEquals("", result);
+	}
+
+	@Test
+	public void resolveEmptyValueRequiredWithoutDefault() throws Exception {
+		this.request.addParameter("name", "");
+		Object result = resolver.resolveArgument(paramRequired, null, webRequest, null);
+		assertEquals("", result);
+	}
+
+
 	public void params(@RequestParam(value = "name", defaultValue = "bar") String param1,
-					   @RequestParam("name") String[] param2,
-					   @RequestParam("name") Map<?, ?> param3,
-					   @RequestParam(value = "file") MultipartFile param4,
-					   @RequestParam Map<?, ?> param5,
-					   String stringNotAnnot,
-					   MultipartFile multipartFileNotAnnot,
-					   List<MultipartFile> multipartFileList,
-					   Part servlet30Part,
-					   @RequestPart MultipartFile requestPartAnnot) {
+			@RequestParam("name") String[] param2,
+			@RequestParam("name") Map<?, ?> param3,
+			@RequestParam(value = "file") MultipartFile param4,
+			@RequestParam Map<?, ?> param5,
+			String stringNotAnnot,
+			MultipartFile multipartFileNotAnnot,
+			List<MultipartFile> multipartFileList,
+			Part servlet30Part,
+			@RequestPart MultipartFile requestPartAnnot,
+			@RequestParam(value = "name") String paramRequired) {
 	}
 
 }
diff --git a/spring-web/src/test/java/org/springframework/web/method/annotation/WebArgumentResolverAdapterTests.java b/spring-web/src/test/java/org/springframework/web/method/annotation/WebArgumentResolverAdapterTests.java
index 3cd926d20c51..4738e030e813 100644
--- a/spring-web/src/test/java/org/springframework/web/method/annotation/WebArgumentResolverAdapterTests.java
+++ b/spring-web/src/test/java/org/springframework/web/method/annotation/WebArgumentResolverAdapterTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,6 @@
 
 package org.springframework.web.method.annotation;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -34,6 +26,9 @@
 import org.springframework.web.context.request.RequestContextHolder;
 import org.springframework.web.context.request.ServletWebRequest;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test fixture with {@link WebArgumentResolverAdapterTests}.
  *
@@ -52,7 +47,7 @@ public class WebArgumentResolverAdapterTests {
 
 	@Before
 	public void setUp() throws Exception {
-		adaptee = createMock(WebArgumentResolver.class);
+		adaptee = mock(WebArgumentResolver.class);
 		adapter = new TestWebArgumentResolverAdapter(adaptee);
 		parameter = new MethodParameter(getClass().getMethod("handle", Integer.TYPE), 0);
 		webRequest = new ServletWebRequest(new MockHttpServletRequest());
@@ -68,85 +63,68 @@ public void resetRequestContextHolder() {
 
 	@Test
 	public void supportsParameter() throws Exception {
-		expect(adaptee.resolveArgument(parameter, webRequest)).andReturn(42);
-		replay(adaptee);
+		given(adaptee.resolveArgument(parameter, webRequest)).willReturn(42);
 
 		assertTrue("Parameter not supported", adapter.supportsParameter(parameter));
 
-		verify(adaptee);
+		verify(adaptee).resolveArgument(parameter, webRequest);
 	}
 
 	@Test
 	public void supportsParameterUnresolved() throws Exception {
-		expect(adaptee.resolveArgument(parameter, webRequest)).andReturn(WebArgumentResolver.UNRESOLVED);
-		replay(adaptee);
+		given(adaptee.resolveArgument(parameter, webRequest)).willReturn(WebArgumentResolver.UNRESOLVED);
 
 		assertFalse("Parameter supported", adapter.supportsParameter(parameter));
 
-		verify(adaptee);
+		verify(adaptee).resolveArgument(parameter, webRequest);
 	}
 
 	@Test
 	public void supportsParameterWrongType() throws Exception {
-		expect(adaptee.resolveArgument(parameter, webRequest)).andReturn("Foo");
-		replay(adaptee);
+		given(adaptee.resolveArgument(parameter, webRequest)).willReturn("Foo");
 
 		assertFalse("Parameter supported", adapter.supportsParameter(parameter));
 
-		verify(adaptee);
+		verify(adaptee).resolveArgument(parameter, webRequest);
 	}
 
 	@Test
 	public void supportsParameterThrowsException() throws Exception {
-		expect(adaptee.resolveArgument(parameter, webRequest)).andThrow(new Exception());
-		replay(adaptee);
+		given(adaptee.resolveArgument(parameter, webRequest)).willThrow(new Exception());
 
 		assertFalse("Parameter supported", adapter.supportsParameter(parameter));
 
-		verify(adaptee);
+		verify(adaptee).resolveArgument(parameter, webRequest);
 	}
 
 	@Test
 	public void resolveArgument() throws Exception {
 		int expected = 42;
-		expect(adaptee.resolveArgument(parameter, webRequest)).andReturn(expected);
-		replay(adaptee);
+		given(adaptee.resolveArgument(parameter, webRequest)).willReturn(expected);
 
 		Object result = adapter.resolveArgument(parameter, null, webRequest, null);
 		assertEquals("Invalid result", expected, result);
-
-		verify(adaptee);
-
 	}
 
 	@Test(expected = IllegalStateException.class)
 	public void resolveArgumentUnresolved() throws Exception {
-		expect(adaptee.resolveArgument(parameter, webRequest)).andReturn(WebArgumentResolver.UNRESOLVED);
-		replay(adaptee);
+		given(adaptee.resolveArgument(parameter, webRequest)).willReturn(WebArgumentResolver.UNRESOLVED);
 
 		adapter.resolveArgument(parameter, null, webRequest, null);
-
-		verify(adaptee);
 	}
 
 	@Test(expected = IllegalStateException.class)
 	public void resolveArgumentWrongType() throws Exception {
-		expect(adaptee.resolveArgument(parameter, webRequest)).andReturn("Foo");
-		replay(adaptee);
+		given(adaptee.resolveArgument(parameter, webRequest)).willReturn("Foo");
 
 		adapter.resolveArgument(parameter, null, webRequest, null);
-
-		verify(adaptee);
 	}
 
 	@Test(expected = Exception.class)
 	public void resolveArgumentThrowsException() throws Exception {
-		expect(adaptee.resolveArgument(parameter, webRequest)).andThrow(new Exception());
-		replay(adaptee);
+		given(adaptee.resolveArgument(parameter, webRequest)).willThrow(new Exception());
 
 		adapter.resolveArgument(parameter, null, webRequest, null);
-
-		verify(adaptee);
 	}
 
 	public void handle(int param) {
@@ -164,4 +142,4 @@ protected NativeWebRequest getWebRequest() {
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-web/src/test/java/org/springframework/web/multipart/commons/CommonsMultipartResolverTests.java b/spring-web/src/test/java/org/springframework/web/multipart/commons/CommonsMultipartResolverTests.java
index 29df40fbf337..b264a4461364 100644
--- a/spring-web/src/test/java/org/springframework/web/multipart/commons/CommonsMultipartResolverTests.java
+++ b/spring-web/src/test/java/org/springframework/web/multipart/commons/CommonsMultipartResolverTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -465,19 +465,11 @@ public void write(File file) throws Exception {
 			this.writtenFile = file;
 		}
 
-		public File getWrittenFile() {
-			return writtenFile;
-		}
-
 		@Override
 		public void delete() {
 			this.deleted = true;
 		}
 
-		public boolean isDeleted() {
-			return deleted;
-		}
-
 		@Override
 		public String getFieldName() {
 			return fieldName;
diff --git a/spring-web/src/test/java/org/springframework/web/multipart/support/ByteArrayMultipartFileEditorTests.java b/spring-web/src/test/java/org/springframework/web/multipart/support/ByteArrayMultipartFileEditorTests.java
index 169f2477e01f..df10bd0d09ef 100644
--- a/spring-web/src/test/java/org/springframework/web/multipart/support/ByteArrayMultipartFileEditorTests.java
+++ b/spring-web/src/test/java/org/springframework/web/multipart/support/ByteArrayMultipartFileEditorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2006 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,10 +19,11 @@
 import java.io.IOException;
 
 import junit.framework.TestCase;
-import org.easymock.MockControl;
 
 import org.springframework.web.multipart.MultipartFile;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  */
@@ -63,30 +64,22 @@ public void testSetValueAsNullGetsBackEmptyString() throws Exception {
 	public void testSetValueAsMultipartFile() throws Exception {
 		String expectedValue = "That is comforting to know";
 		ByteArrayMultipartFileEditor editor = new ByteArrayMultipartFileEditor();
-		MockControl mock = MockControl.createControl(MultipartFile.class);
-		MultipartFile file = (MultipartFile) mock.getMock();
-		file.getBytes();
-		mock.setReturnValue(expectedValue.getBytes());
-		mock.replay();
+		MultipartFile file = mock(MultipartFile.class);
+		given(file.getBytes()).willReturn(expectedValue.getBytes());
 		editor.setValue(file);
 		assertEquals(expectedValue, editor.getAsText());
-		mock.verify();
 	}
 
 	public void testSetValueAsMultipartFileWithBadBytes() throws Exception {
 		ByteArrayMultipartFileEditor editor = new ByteArrayMultipartFileEditor();
-		MockControl mock = MockControl.createControl(MultipartFile.class);
-		MultipartFile file = (MultipartFile) mock.getMock();
-		file.getBytes();
-		mock.setThrowable(new IOException());
-		mock.replay();
+		MultipartFile file = mock(MultipartFile.class);
+		given(file.getBytes()).willThrow(new IOException());
 		try {
 			editor.setValue(file);
 			fail("Must have thrown an IllegalArgumentException: IOException thrown when reading MultipartFile bytes");
 		}
 		catch (IllegalArgumentException expected) {
 		}
-		mock.verify();
 	}
 
 }
diff --git a/spring-web/src/test/java/org/springframework/web/util/JavaScriptUtilsTests.java b/spring-web/src/test/java/org/springframework/web/util/JavaScriptUtilsTests.java
new file mode 100644
index 000000000000..182f18eb2dba
--- /dev/null
+++ b/spring-web/src/test/java/org/springframework/web/util/JavaScriptUtilsTests.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2004-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.web.util;
+
+import static org.junit.Assert.*;
+
+import java.io.UnsupportedEncodingException;
+
+import org.junit.Test;
+
+/**
+ * Test fixture for {@link JavaScriptUtils}.
+ *
+ * @author Rossen Stoyanchev
+ */
+public class JavaScriptUtilsTests {
+
+	@Test
+	public void escape() {
+		StringBuilder sb = new StringBuilder();
+		sb.append('"');
+		sb.append("'");
+		sb.append("\\");
+		sb.append("/");
+		sb.append("\t");
+		sb.append("\n");
+		sb.append("\r");
+		sb.append("\f");
+		sb.append("\b");
+		sb.append("\013");
+		assertEquals("\\\"\\'\\\\\\/\\t\\n\\n\\f\\b\\v", JavaScriptUtils.javaScriptEscape(sb.toString()));
+	}
+
+	// SPR-9983
+
+	@Test
+	public void escapePsLsLineTerminators() {
+		StringBuilder sb = new StringBuilder();
+		sb.append('\u2028');
+		sb.append('\u2029');
+		String result = JavaScriptUtils.javaScriptEscape(sb.toString());
+
+		assertEquals("\\u2028\\u2029", result);
+	}
+
+	// SPR-9983
+
+	@Test
+	public void escapeLessThanGreaterThanSigns() throws UnsupportedEncodingException {
+		assertEquals("\\u003C\\u003E", JavaScriptUtils.javaScriptEscape("<>"));
+	}
+
+}
diff --git a/spring-web/src/test/java/org/springframework/web/util/ServletContextPropertyUtilsTests.java b/spring-web/src/test/java/org/springframework/web/util/ServletContextPropertyUtilsTests.java
new file mode 100644
index 000000000000..21082779a4ce
--- /dev/null
+++ b/spring-web/src/test/java/org/springframework/web/util/ServletContextPropertyUtilsTests.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2002-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */package org.springframework.web.util;
+
+import org.junit.Test;
+
+import org.springframework.mock.web.test.MockServletContext;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Marten Deinum
+ * @since 3.2.2
+ */
+public class ServletContextPropertyUtilsTests {
+
+    @Test
+    public void resolveAsServletContextInitParameter() {
+        MockServletContext servletContext = new MockServletContext();
+        servletContext.setInitParameter("test.prop", "bar");
+        String resolved = ServletContextPropertyUtils.resolvePlaceholders("${test.prop:foo}", servletContext);
+        assertEquals(resolved, "bar");
+    }
+
+    @Test
+    public void fallbackToSystemProperties() {
+        MockServletContext servletContext = new MockServletContext();
+        System.setProperty("test.prop", "bar");
+        try {
+            String resolved = ServletContextPropertyUtils.resolvePlaceholders("${test.prop:foo}", servletContext);
+            assertEquals(resolved, "bar");
+        }
+		finally {
+            System.clearProperty("test.prop");
+        }
+    }
+
+}
diff --git a/spring-web/src/test/java/org/springframework/web/util/UriComponentsBuilderTests.java b/spring-web/src/test/java/org/springframework/web/util/UriComponentsBuilderTests.java
index 8205ca6cdf81..fd60e2dcd9de 100644
--- a/spring-web/src/test/java/org/springframework/web/util/UriComponentsBuilderTests.java
+++ b/spring-web/src/test/java/org/springframework/web/util/UriComponentsBuilderTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,14 +23,16 @@
 import java.util.Map;
 
 import org.junit.Test;
-
 import org.springframework.util.LinkedMultiValueMap;
 import org.springframework.util.MultiValueMap;
 
+import static org.hamcrest.Matchers.*;
 import static org.junit.Assert.*;
 
 /**
  * @author Arjen Poutsma
+ * @author Phillip Webb
+ * @author Oliver Gierke
  */
 public class UriComponentsBuilderTests {
 
@@ -55,7 +57,9 @@ public void fromPath() throws URISyntaxException {
 		assertEquals("bar", result.getQuery());
 		assertEquals("baz", result.getFragment());
 
-		URI expected = new URI("/foo?bar#baz");
+		assertEquals("Invalid result URI String", "foo?bar#baz", result.toUriString());
+
+		URI expected = new URI("foo?bar#baz");
 		assertEquals("Invalid result URI", expected, result.toUri());
 
 		result = UriComponentsBuilder.fromPath("/foo").build();
@@ -312,4 +316,49 @@ public void buildAndExpandOpaque() {
 		assertEquals("mailto:foo@example.com", result.toUriString());
 	}
 
+	@Test
+	public void queryParamWithValueWithEquals() throws Exception {
+		UriComponents uriComponents = UriComponentsBuilder.fromUriString("http://example.com/foo?bar=baz").build();
+		assertThat(uriComponents.toUriString(), equalTo("http://example.com/foo?bar=baz"));
+	}
+
+	@Test
+	public void queryParamWithoutValueWithEquals() throws Exception {
+		UriComponents uriComponents = UriComponentsBuilder.fromUriString("http://example.com/foo?bar=").build();
+		assertThat(uriComponents.toUriString(), equalTo("http://example.com/foo?bar="));
+	}
+
+	@Test
+	public void queryParamWithoutValueWithoutEquals() throws Exception {
+		UriComponents uriComponents = UriComponentsBuilder.fromUriString("http://example.com/foo?bar").build();
+		assertThat(uriComponents.toUriString(), equalTo("http://example.com/foo?bar"));
+	}
+
+	@Test
+	public void relativeUrls() throws Exception {
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com/foo/../bar").build().toString(), equalTo("http://example.com/foo/../bar"));
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com/foo/../bar").build().toUriString(), equalTo("http://example.com/foo/../bar"));
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com/foo/../bar").build().toUri().getPath(), equalTo("/foo/../bar"));
+		assertThat(UriComponentsBuilder.fromUriString("../../").build().toString(), equalTo("../../"));
+		assertThat(UriComponentsBuilder.fromUriString("../../").build().toUriString(), equalTo("../../"));
+		assertThat(UriComponentsBuilder.fromUriString("../../").build().toUri().getPath(), equalTo("../../"));
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com").path("foo/../bar").build().toString(), equalTo("http://example.com/foo/../bar"));
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com").path("foo/../bar").build().toUriString(), equalTo("http://example.com/foo/../bar"));
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com").path("foo/../bar").build().toUri().getPath(), equalTo("/foo/../bar"));
+	}
+
+	@Test
+	public void emptySegments() throws Exception {
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com/abc/").path("/x/y/z").build().toString(), equalTo("http://example.com/abc/x/y/z"));
+	    assertThat(UriComponentsBuilder.fromUriString("http://example.com/abc/").pathSegment("x", "y", "z").build().toString(), equalTo("http://example.com/abc/x/y/z"));
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com/abc/").path("/x/").path("/y/z").build().toString(), equalTo("http://example.com/abc/x/y/z"));
+		assertThat(UriComponentsBuilder.fromUriString("http://example.com/abc/").pathSegment("x").path("y").build().toString(), equalTo("http://example.com/abc/x/y"));
+	}
+
+	@Test
+	public void parsesEmptyFragment() {
+		UriComponents components = UriComponentsBuilder.fromUriString("/example#").build();
+		assertThat(components.getFragment(), is(nullValue()));
+		assertThat(components.toString(), equalTo("/example"));
+	}
 }
diff --git a/spring-web/src/test/java/org/springframework/web/util/UriComponentsTests.java b/spring-web/src/test/java/org/springframework/web/util/UriComponentsTests.java
index c9f8d609177c..2013e6df659e 100644
--- a/spring-web/src/test/java/org/springframework/web/util/UriComponentsTests.java
+++ b/spring-web/src/test/java/org/springframework/web/util/UriComponentsTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,14 +16,24 @@
 
 package org.springframework.web.util;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.net.URI;
 import java.net.URISyntaxException;
 
 import org.junit.Test;
 
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.not;
 import static org.junit.Assert.*;
 
-/** @author Arjen Poutsma */
+/**
+ * @author Arjen Poutsma
+ * @author Phillip Webb
+ */
 public class UriComponentsTests {
 
 	@Test
@@ -75,4 +85,38 @@ public void normalize() {
 		assertEquals("http://example.com/bar", uriComponents.normalize().toString());
 	}
 
+	@Test
+	public void serializable() throws Exception {
+		UriComponents uriComponents = UriComponentsBuilder.fromUriString(
+				"http://example.com").path("/{foo}").query("bar={baz}").build();
+		ByteArrayOutputStream bos = new ByteArrayOutputStream();
+		ObjectOutputStream oos = new ObjectOutputStream(bos);
+		oos.writeObject(uriComponents);
+		ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
+		UriComponents readObject = (UriComponents) ois.readObject();
+		assertThat(uriComponents.toString(), equalTo(readObject.toString()));
+	}
+
+	@Test
+	public void equalsHierarchicalUriComponents() throws Exception {
+		UriComponents uriComponents1 = UriComponentsBuilder.fromUriString("http://example.com").path("/{foo}").query("bar={baz}").build();
+		UriComponents uriComponents2 = UriComponentsBuilder.fromUriString("http://example.com").path("/{foo}").query("bar={baz}").build();
+		UriComponents uriComponents3 = UriComponentsBuilder.fromUriString("http://example.com").path("/{foo}").query("bin={baz}").build();
+		assertThat(uriComponents1, instanceOf(HierarchicalUriComponents.class));
+		assertThat(uriComponents1, equalTo(uriComponents1));
+		assertThat(uriComponents1, equalTo(uriComponents2));
+		assertThat(uriComponents1, not(equalTo(uriComponents3)));
+	}
+
+	@Test
+	public void equalsOpaqueUriComponents() throws Exception {
+		UriComponents uriComponents1 = UriComponentsBuilder.fromUriString("http:example.com/foo/bar").build();
+		UriComponents uriComponents2 = UriComponentsBuilder.fromUriString("http:example.com/foo/bar").build();
+		UriComponents uriComponents3 = UriComponentsBuilder.fromUriString("http:example.com/foo/bin").build();
+		assertThat(uriComponents1, instanceOf(OpaqueUriComponents.class));
+		assertThat(uriComponents1, equalTo(uriComponents1));
+		assertThat(uriComponents1, equalTo(uriComponents2));
+		assertThat(uriComponents1, not(equalTo(uriComponents3)));
+	}
+
 }
diff --git a/spring-webmvc-portlet/src/test/java/org/springframework/web/portlet/context/PortletRequestAttributesTests.java b/spring-webmvc-portlet/src/test/java/org/springframework/web/portlet/context/PortletRequestAttributesTests.java
index e44f91457572..ee739b9831ee 100644
--- a/spring-webmvc-portlet/src/test/java/org/springframework/web/portlet/context/PortletRequestAttributesTests.java
+++ b/spring-webmvc-portlet/src/test/java/org/springframework/web/portlet/context/PortletRequestAttributesTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2008 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,6 @@
 
 package org.springframework.web.portlet.context;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
-
 import java.io.Serializable;
 
 import javax.portlet.PortletRequest;
@@ -28,6 +25,9 @@
 import org.springframework.mock.web.portlet.MockPortletSession;
 import org.springframework.web.context.request.RequestAttributes;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rick Evans
  * @author Juergen Hoeller
@@ -136,15 +136,13 @@ public void testSetGlobalSessionScopedAttributeAfterCompletion() throws Exceptio
 
 	@Test
 	public void testGetSessionScopedAttributeDoesNotForceCreationOfSession() throws Exception {
-		PortletRequest request = createMock(PortletRequest.class);
-		expect(request.getPortletSession(false)).andReturn(null);
-		replay(request);
+		PortletRequest request = mock(PortletRequest.class);
 
 		PortletRequestAttributes attrs = new PortletRequestAttributes(request);
 		Object value = attrs.getAttribute(KEY, RequestAttributes.SCOPE_SESSION);
 		assertNull(value);
 
-		verify(request);
+		verify(request).getPortletSession(false);
 	}
 
 	@Test
@@ -161,14 +159,12 @@ public void testRemoveSessionScopedAttribute() throws Exception {
 
 	@Test
 	public void testRemoveSessionScopedAttributeDoesNotForceCreationOfSession() throws Exception {
-		PortletRequest request = createMock(PortletRequest.class);
-		expect(request.getPortletSession(false)).andReturn(null);
-		replay(request);
+		PortletRequest request = mock(PortletRequest.class);
 
 		PortletRequestAttributes attrs = new PortletRequestAttributes(request);
 		attrs.removeAttribute(KEY, RequestAttributes.SCOPE_SESSION);
 
-		verify(request);
+		verify(request).getPortletSession(false);
 	}
 
 }
diff --git a/spring-webmvc-portlet/src/test/java/org/springframework/web/portlet/util/PortletUtilsTests.java b/spring-webmvc-portlet/src/test/java/org/springframework/web/portlet/util/PortletUtilsTests.java
index 8fd99d5357ff..f7192f7accd0 100644
--- a/spring-webmvc-portlet/src/test/java/org/springframework/web/portlet/util/PortletUtilsTests.java
+++ b/spring-webmvc-portlet/src/test/java/org/springframework/web/portlet/util/PortletUtilsTests.java
@@ -21,23 +21,23 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+
 import javax.portlet.PortletContext;
 import javax.portlet.PortletRequest;
 import javax.portlet.PortletSession;
 
 import org.junit.Test;
-
-import org.springframework.tests.sample.beans.ITestBean;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.mock.web.portlet.MockActionRequest;
 import org.springframework.mock.web.portlet.MockActionResponse;
 import org.springframework.mock.web.portlet.MockPortletContext;
 import org.springframework.mock.web.portlet.MockPortletRequest;
 import org.springframework.mock.web.portlet.MockPortletSession;
+import org.springframework.tests.sample.beans.ITestBean;
+import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.web.util.WebUtils;
 
-import static org.easymock.EasyMock.*;
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Rick Evans
@@ -60,9 +60,8 @@ public void testGetTempDirSunnyDay() throws Exception {
 	public void testGetRealPathInterpretsLocationAsRelativeToWebAppRootIfPathDoesNotBeginWithALeadingSlash() throws Exception {
 		final String originalPath = "web/foo";
 		final String expectedRealPath = "/" + originalPath;
-		PortletContext ctx = createMock(PortletContext.class);
-		expect(ctx.getRealPath(expectedRealPath)).andReturn(expectedRealPath);
-		replay(ctx);
+		PortletContext ctx = mock(PortletContext.class);
+		given(ctx.getRealPath(expectedRealPath)).willReturn(expectedRealPath);
 
 		String actualRealPath = PortletUtils.getRealPath(ctx, originalPath);
 		assertEquals(expectedRealPath, actualRealPath);
@@ -402,13 +401,11 @@ public void testSetSessionAttributeWithNullPortletRequest() throws Exception {
 
 	@Test
 	public void testGetSessionAttributeDoes_Not_CreateANewSession() throws Exception {
-		PortletRequest request = createMock(PortletRequest.class);
-		expect(request.getPortletSession(false)).andReturn(null);
-		replay(request);
+		PortletRequest request = mock(PortletRequest.class);
 
 		Object sessionAttribute = PortletUtils.getSessionAttribute(request, "foo");
 		assertNull("Must return null if session attribute does not exist (or if Session does not exist)", sessionAttribute);
-		verify(request);
+		verify(request).getPortletSession(false);
 	}
 
 	@Test
@@ -416,15 +413,12 @@ public void testGetSessionAttributeWithExistingSession() throws Exception {
 		MockPortletSession session = new MockPortletSession();
 		session.setAttribute("foo", "foo");
 
-		PortletRequest request = createMock(PortletRequest.class);
-		expect(request.getPortletSession(false)).andReturn(session);
-		replay(request);
+		PortletRequest request = mock(PortletRequest.class);
+		given(request.getPortletSession(false)).willReturn(session);
 
 		Object sessionAttribute = PortletUtils.getSessionAttribute(request, "foo");
 		assertNotNull("Must not return null if session attribute exists (and Session exists)", sessionAttribute);
 		assertEquals("foo", sessionAttribute);
-
-		verify(request);
 	}
 
 	@Test
@@ -432,102 +426,72 @@ public void testGetRequiredSessionAttributeWithExistingSession() throws Exceptio
 		MockPortletSession session = new MockPortletSession();
 		session.setAttribute("foo", "foo");
 
-		PortletRequest request = createMock(PortletRequest.class);
-		expect(request.getPortletSession(false)).andReturn(session);
-		replay(request);
+		PortletRequest request = mock(PortletRequest.class);
+		given(request.getPortletSession(false)).willReturn(session);
 
 		Object sessionAttribute = PortletUtils.getRequiredSessionAttribute(request, "foo");
 		assertNotNull("Must not return null if session attribute exists (and Session exists)", sessionAttribute);
 		assertEquals("foo", sessionAttribute);
-
-		verify(request);
 	}
 
 	@Test
 	public void testGetRequiredSessionAttributeWithExistingSessionAndNoAttribute() throws Exception {
 		MockPortletSession session = new MockPortletSession();
 
-		final PortletRequest request = createMock(PortletRequest.class);
-		expect(request.getPortletSession(false)).andReturn(session);
-		replay(request);
+		final PortletRequest request = mock(PortletRequest.class);
+		given(request.getPortletSession(false)).willReturn(session);
 		try {
 			PortletUtils.getRequiredSessionAttribute(request, "foo");
 			fail("expected IllegalStateException");
 		} catch (IllegalStateException ex) { /* expected */ }
-		verify(request);
+
 	}
 
 	@Test
 	public void testSetSessionAttributeWithExistingSessionAndNullValue() throws Exception {
-		PortletSession session = createMock(PortletSession.class);
-		PortletRequest request = createMock(PortletRequest.class);
-
-		expect(request.getPortletSession(false)).andReturn(session); // must not create Session for null value...
-		session.removeAttribute("foo", PortletSession.APPLICATION_SCOPE);
-		replay(request, session);
-
+		PortletSession session = mock(PortletSession.class);
+		PortletRequest request = mock(PortletRequest.class);
+		given(request.getPortletSession(false)).willReturn(session); // must not create Session for null value...
 		PortletUtils.setSessionAttribute(request, "foo", null, PortletSession.APPLICATION_SCOPE);
-
-		verify(request, session);
+		verify(session).removeAttribute("foo", PortletSession.APPLICATION_SCOPE);
 	}
 
 	@Test
 	public void testSetSessionAttributeWithNoExistingSessionAndNullValue() throws Exception {
-		PortletRequest request = createMock(PortletRequest.class);
-
-		expect(request.getPortletSession(false)).andReturn(null); // must not create Session for null value...
-		replay(request);
-
+		PortletRequest request = mock(PortletRequest.class);
 		PortletUtils.setSessionAttribute(request, "foo", null, PortletSession.APPLICATION_SCOPE);
-
-		verify(request);
+		verify(request).getPortletSession(false); // must not create Session for null value...
 	}
 
 	@Test
 	public void testSetSessionAttributeWithExistingSessionAndSpecificScope() throws Exception {
-		PortletSession session = createMock(PortletSession.class);
-		PortletRequest request = createMock(PortletRequest.class);
-
-		expect(request.getPortletSession()).andReturn(session); // must not create Session ...
-		session.setAttribute("foo", "foo", PortletSession.APPLICATION_SCOPE);
-		replay(request, session);
-
+		PortletSession session = mock(PortletSession.class);
+		PortletRequest request = mock(PortletRequest.class);
+		given(request.getPortletSession()).willReturn(session); // must not create Session ...
 		PortletUtils.setSessionAttribute(request, "foo", "foo", PortletSession.APPLICATION_SCOPE);
-
-		verify(request, session);
+		verify(session).setAttribute("foo", "foo", PortletSession.APPLICATION_SCOPE);
 	}
 
 	@Test
 	public void testGetSessionAttributeWithExistingSessionAndSpecificScope() throws Exception {
-		PortletSession session = createMock(PortletSession.class);
-		PortletRequest request = createMock(PortletRequest.class);
-
-		expect(request.getPortletSession(false)).andReturn(session);
-		expect(session.getAttribute("foo", PortletSession.APPLICATION_SCOPE)).andReturn("foo");
-		replay(request, session);
-
+		PortletSession session = mock(PortletSession.class);
+		PortletRequest request = mock(PortletRequest.class);
+		given(request.getPortletSession(false)).willReturn(session);
+		given(session.getAttribute("foo", PortletSession.APPLICATION_SCOPE)).willReturn("foo");
 		Object sessionAttribute = PortletUtils.getSessionAttribute(request, "foo", PortletSession.APPLICATION_SCOPE);
 		assertNotNull("Must not return null if session attribute exists (and Session exists)", sessionAttribute);
 		assertEquals("foo", sessionAttribute);
-
-		verify(request, session);
 	}
 
 	@Test
 	public void testGetSessionAttributeWithExistingSessionDefaultsToPortletScope() throws Exception {
-		PortletSession session = createMock(PortletSession.class);
-		PortletRequest request = createMock(PortletRequest.class);
-
-		expect(request.getPortletSession(false)).andReturn(session);
-		expect(session.getAttribute("foo", PortletSession.PORTLET_SCOPE)).andReturn("foo");
-
-		replay(request, session);
-
+		PortletSession session = mock(PortletSession.class);
+		PortletRequest request = mock(PortletRequest.class);
+		given(request.getPortletSession(false)).willReturn(session);
+		given(session.getAttribute("foo", PortletSession.PORTLET_SCOPE)).willReturn("foo");
 		Object sessionAttribute = PortletUtils.getSessionAttribute(request, "foo");
 		assertNotNull("Must not return null if session attribute exists (and Session exists)", sessionAttribute);
 		assertEquals("foo", sessionAttribute);
-
-		verify(request, session);
 	}
 
 
diff --git a/spring-webmvc-tiles3/src/main/java/org/springframework/web/servlet/view/tiles3/TilesConfigurer.java b/spring-webmvc-tiles3/src/main/java/org/springframework/web/servlet/view/tiles3/TilesConfigurer.java
index d23ac0033b28..5b43420b195f 100644
--- a/spring-webmvc-tiles3/src/main/java/org/springframework/web/servlet/view/tiles3/TilesConfigurer.java
+++ b/spring-webmvc-tiles3/src/main/java/org/springframework/web/servlet/view/tiles3/TilesConfigurer.java
@@ -373,12 +373,6 @@ protected AbstractTilesContainerFactory createContainerFactory(ApplicationContex
 
 	private class SpringCompleteAutoloadTilesContainerFactory extends CompleteAutoloadTilesContainerFactory {
 
-		@Override
-		protected AttributeEvaluatorFactory createAttributeEvaluatorFactory(
-				ApplicationContext applicationContext, LocaleResolver resolver) {
-			return new BasicAttributeEvaluatorFactory(new DirectAttributeEvaluator());
-		}
-
 		@Override
 		public TilesContainer createContainer(ApplicationContext applicationContext) {
 			CachingTilesContainer cachingContainer = (CachingTilesContainer) super.createContainer(applicationContext);
diff --git a/spring-webmvc-tiles3/src/main/java/org/springframework/web/servlet/view/tiles3/TilesView.java b/spring-webmvc-tiles3/src/main/java/org/springframework/web/servlet/view/tiles3/TilesView.java
index df8cd2d4532a..67dec5912430 100644
--- a/spring-webmvc-tiles3/src/main/java/org/springframework/web/servlet/view/tiles3/TilesView.java
+++ b/spring-webmvc-tiles3/src/main/java/org/springframework/web/servlet/view/tiles3/TilesView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,6 +30,9 @@
 import org.apache.tiles.request.render.Renderer;
 import org.apache.tiles.request.servlet.ServletRequest;
 import org.apache.tiles.request.servlet.ServletUtil;
+import org.springframework.web.context.request.RequestAttributes;
+import org.springframework.web.context.request.RequestContextHolder;
+import org.springframework.web.context.request.ServletRequestAttributes;
 import org.springframework.web.servlet.support.JstlUtils;
 import org.springframework.web.servlet.support.RequestContext;
 import org.springframework.web.servlet.support.RequestContextUtils;
@@ -95,7 +98,12 @@ public void afterPropertiesSet() throws Exception {
 
 	@Override
 	public boolean checkResource(final Locale locale) throws Exception {
-		Request request = new ServletRequest(this.applicationContext, null, null) {
+		HttpServletRequest servletRequest = null;
+		RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
+		if(requestAttributes != null && requestAttributes instanceof ServletRequestAttributes) {
+			servletRequest = ((ServletRequestAttributes)requestAttributes).getRequest();
+		}
+		Request request = new ServletRequest(this.applicationContext, servletRequest, null) {
 			@Override
 			public Locale getRequestLocale() {
 				return locale;
diff --git a/spring-webmvc-tiles3/src/test/java/org/springframework/web/servlet/view/tiles3/TilesViewResolverTests.java b/spring-webmvc-tiles3/src/test/java/org/springframework/web/servlet/view/tiles3/TilesViewResolverTests.java
index 896fef861802..a3c14a019312 100644
--- a/spring-webmvc-tiles3/src/test/java/org/springframework/web/servlet/view/tiles3/TilesViewResolverTests.java
+++ b/spring-webmvc-tiles3/src/test/java/org/springframework/web/servlet/view/tiles3/TilesViewResolverTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,24 +15,18 @@
  */
 package org.springframework.web.servlet.view.tiles3;
 
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.isA;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
 import java.util.Locale;
 
 import org.apache.tiles.request.Request;
 import org.apache.tiles.request.render.Renderer;
-import org.easymock.EasyMock;
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.mock.web.test.MockServletContext;
 import org.springframework.web.context.support.StaticWebApplicationContext;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test fixture for {@link TilesViewResolver}.
  *
@@ -51,7 +45,7 @@ public void setUp() {
 		wac.setServletContext(new MockServletContext());
 		wac.refresh();
 
-		this.renderer = EasyMock.createMock(Renderer.class);
+		this.renderer = mock(Renderer.class);
 
 		this.viewResolver = new TilesViewResolver();
 		this.viewResolver.setRenderer(this.renderer);
@@ -60,13 +54,13 @@ public void setUp() {
 
 	@Test
 	public void testResolve() throws Exception {
-		expect(this.renderer.isRenderable(eq("/template.test"), isA(Request.class))).andReturn(true);
-		expect(this.renderer.isRenderable(eq("/nonexistent.test"), isA(Request.class))).andReturn(false);
-		replay(this.renderer);
+		given(this.renderer.isRenderable(eq("/template.test"), isA(Request.class))).willReturn(true);
+		given(this.renderer.isRenderable(eq("/nonexistent.test"), isA(Request.class))).willReturn(false);
 
 		assertTrue(this.viewResolver.resolveViewName("/template.test", Locale.ITALY) instanceof TilesView);
 		assertNull(this.viewResolver.resolveViewName("/nonexistent.test", Locale.ITALY));
 
-		verify(this.renderer);
+		verify(this.renderer).isRenderable(eq("/template.test"), isA(Request.class));
+		verify(this.renderer).isRenderable(eq("/nonexistent.test"), isA(Request.class));
 	}
 }
diff --git a/spring-webmvc-tiles3/src/test/java/org/springframework/web/servlet/view/tiles3/TilesViewTests.java b/spring-webmvc-tiles3/src/test/java/org/springframework/web/servlet/view/tiles3/TilesViewTests.java
index 91bfef1bc691..4ebf4dab300e 100644
--- a/spring-webmvc-tiles3/src/test/java/org/springframework/web/servlet/view/tiles3/TilesViewTests.java
+++ b/spring-webmvc-tiles3/src/test/java/org/springframework/web/servlet/view/tiles3/TilesViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,18 +15,9 @@
  */
 package org.springframework.web.servlet.view.tiles3;
 
-import static org.easymock.EasyMock.and;
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.isA;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-
 import java.util.HashMap;
 import java.util.Map;
 
-import org.apache.tiles.request.ApplicationContext;
 import org.apache.tiles.request.Request;
 import org.apache.tiles.request.render.Renderer;
 import org.junit.Before;
@@ -37,6 +28,10 @@
 import org.springframework.web.context.support.StaticWebApplicationContext;
 import org.springframework.web.servlet.DispatcherServlet;
 
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test fixture for {@link TilesView}.
  *
@@ -67,7 +62,7 @@ public void setUp() throws Exception {
 
 		response = new MockHttpServletResponse();
 
-		renderer = createMock(Renderer.class);
+		renderer = mock(Renderer.class);
 
 		view = new TilesView();
 		view.setServletContext(servletContext);
@@ -80,16 +75,9 @@ public void setUp() throws Exception {
 	public void testRender() throws Exception {
 		Map<String, Object> model = new HashMap<String, Object>();
 		model.put("modelAttribute", "modelValue");
-
-		ApplicationContext tilesContext = createMock(ApplicationContext.class);
-
-		renderer.render(eq(VIEW_PATH), and(isA(Request.class), isA(Request.class)));
-		replay(tilesContext, renderer);
-
 		view.render(model, request, response);
-
 		assertEquals("modelValue", request.getAttribute("modelAttribute"));
-		verify(tilesContext, renderer);
+		verify(renderer).render(eq(VIEW_PATH), isA(Request.class));
 	}
 
 }
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java
index 6483616edbe5..fbe27e3a46ff 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,7 +28,6 @@
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
-
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
@@ -36,6 +35,7 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+
 import org.springframework.beans.factory.BeanFactoryUtils;
 import org.springframework.beans.factory.BeanInitializationException;
 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
@@ -810,13 +810,13 @@ protected Object createDefaultStrategy(ApplicationContext context, Class<?> claz
 		return context.getAutowireCapableBeanFactory().createBean(clazz);
 	}
 
+
 	/**
 	 * Exposes the DispatcherServlet-specific request attributes and delegates to {@link #doDispatch}
 	 * for the actual dispatching.
 	 */
 	@Override
 	protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
-
 		if (logger.isDebugEnabled()) {
 			String requestUri = urlPathHelper.getRequestUri(request);
 			String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? " resumed" : "";
@@ -1268,6 +1268,7 @@ private void triggerAfterCompletionWithError(HttpServletRequest request, HttpSer
 	 * @param request current HTTP request
 	 * @param attributesSnapshot the snapshot of the request attributes before the include
 	 */
+	@SuppressWarnings("unchecked")
 	private void restoreAttributesAfterInclude(HttpServletRequest request, Map<?,?> attributesSnapshot) {
 		logger.debug("Restoring snapshot of request attributes after include");
 
@@ -1282,6 +1283,9 @@ private void restoreAttributesAfterInclude(HttpServletRequest request, Map<?,?>
 			}
 		}
 
+		// Add attributes that may have been removed
+		attrsToCheck.addAll((Set<String>) attributesSnapshot.keySet());
+
 		// Iterate over the attributes to check, restoring the original value
 		// or removing the attribute, respectively, if appropriate.
 		for (String attrName : attrsToCheck) {
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/FrameworkServlet.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/FrameworkServlet.java
index 3dca4eda9429..07f2db164848 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/FrameworkServlet.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/FrameworkServlet.java
@@ -21,11 +21,11 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.concurrent.Callable;
-
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpServletResponseWrapper;
 
 import org.springframework.beans.BeanUtils;
 import org.springframework.context.ApplicationContext;
@@ -51,7 +51,6 @@
 import org.springframework.web.context.request.RequestAttributes;
 import org.springframework.web.context.request.RequestContextHolder;
 import org.springframework.web.context.request.ServletRequestAttributes;
-import org.springframework.web.context.request.async.CallableProcessingInterceptor;
 import org.springframework.web.context.request.async.CallableProcessingInterceptorAdapter;
 import org.springframework.web.context.request.async.WebAsyncManager;
 import org.springframework.web.context.request.async.WebAsyncUtils;
@@ -784,6 +783,18 @@ protected void onRefresh(ApplicationContext context) {
 		// For subclasses: do nothing by default.
 	}
 
+	/**
+	 * Close the WebApplicationContext of this servlet.
+	 * @see org.springframework.context.ConfigurableApplicationContext#close()
+	 */
+	@Override
+	public void destroy() {
+		getServletContext().log("Destroying Spring FrameworkServlet '" + getServletName() + "'");
+		if (this.webApplicationContext instanceof ConfigurableApplicationContext) {
+			((ConfigurableApplicationContext) this.webApplicationContext).close();
+		}
+	}
+
 
 	/**
 	 * Override the parent class implementation in order to intercept PATCH
@@ -866,10 +877,18 @@ protected void doOptions(HttpServletRequest request, HttpServletResponse respons
 				return;
 			}
 		}
-		super.doOptions(request, response);
-		String allowedMethods = response.getHeader("Allow");
-		allowedMethods += ", " + RequestMethod.PATCH.name();
-		response.setHeader("Allow", allowedMethods);
+
+		// Use response wrapper for Servlet 2.5 compatibility where
+		// the getHeader() method does not exist
+		super.doOptions(request, new HttpServletResponseWrapper(response) {
+			@Override
+			public void setHeader(String name, String value) {
+				if ("Allow".equals(name)) {
+					value = (StringUtils.hasLength(value) ? value + ", " : "") + RequestMethod.PATCH.name();
+				}
+				super.setHeader(name, value);
+			}
+		});
 	}
 
 	/**
@@ -906,15 +925,12 @@ protected final void processRequest(HttpServletRequest request, HttpServletRespo
 		LocaleContext localeContext = buildLocaleContext(request);
 
 		RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
-		ServletRequestAttributes requestAttributes = null;
-		if (previousAttributes == null || (previousAttributes instanceof ServletRequestAttributes)) {
-			requestAttributes = new ServletRequestAttributes(request);
-		}
-
-		initContextHolders(request, localeContext, requestAttributes);
+		ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);
 
 		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
-		asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), getRequestBindingInterceptor(request));
+		asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());
+
+		initContextHolders(request, localeContext, requestAttributes);
 
 		try {
 			doService(request, response);
@@ -941,27 +957,18 @@ protected final void processRequest(HttpServletRequest request, HttpServletRespo
 			if (logger.isDebugEnabled()) {
 				if (failureCause != null) {
 					this.logger.debug("Could not complete request", failureCause);
-				} else {
+				}
+				else {
 					if (asyncManager.isConcurrentHandlingStarted()) {
-						if (logger.isDebugEnabled()) {
-							logger.debug("Leaving response open for concurrent processing");
-						}
+						logger.debug("Leaving response open for concurrent processing");
 					}
 					else {
 						this.logger.debug("Successfully completed request");
 					}
 				}
 			}
-			if (this.publishEvents) {
-				// Whether or not we succeeded, publish an event.
-				long processingTime = System.currentTimeMillis() - startTime;
-				this.webApplicationContext.publishEvent(
-						new ServletRequestHandledEvent(this,
-								request.getRequestURI(), request.getRemoteAddr(),
-								request.getMethod(), getServletConfig().getServletName(),
-								WebUtils.getSessionId(request), getUsernameForRequest(request),
-								processingTime, failureCause));
-			}
+
+			publishRequestHandledEvent(request, startTime, failureCause);
 		}
 	}
 
@@ -969,18 +976,43 @@ protected final void processRequest(HttpServletRequest request, HttpServletRespo
 	 * Build a LocaleContext for the given request, exposing the request's
 	 * primary locale as current locale.
 	 * @param request current HTTP request
-	 * @return the corresponding LocaleContext
+	 * @return the corresponding LocaleContext, or {@code null} if none to bind
+	 * @see LocaleContextHolder#setLocaleContext
 	 */
 	protected LocaleContext buildLocaleContext(HttpServletRequest request) {
 		return new SimpleLocaleContext(request.getLocale());
 	}
 
-	private void initContextHolders(HttpServletRequest request,
-			LocaleContext localeContext, RequestAttributes attributes) {
+	/**
+	 * Build ServletRequestAttributes for the given request (potentially also
+	 * holding a reference to the response), taking pre-bound attributes
+	 * (and their type) into consideration.
+	 * @param request current HTTP request
+	 * @param response current HTTP response
+	 * @param previousAttributes pre-bound RequestAttributes instance, if any
+	 * @return the ServletRequestAttributes to bind, or {@code null} to preserve
+	 * the previously bound instance (or not binding any, if none bound before)
+	 * @see RequestContextHolder#setRequestAttributes
+	 */
+	protected ServletRequestAttributes buildRequestAttributes(
+			HttpServletRequest request, HttpServletResponse response, RequestAttributes previousAttributes) {
 
-		LocaleContextHolder.setLocaleContext(localeContext, this.threadContextInheritable);
-		if (attributes != null) {
-			RequestContextHolder.setRequestAttributes(attributes, this.threadContextInheritable);
+		if (previousAttributes == null || previousAttributes instanceof ServletRequestAttributes) {
+			return new ServletRequestAttributes(request);
+		}
+		else {
+			return null;  // preserve the pre-bound RequestAttributes instance
+		}
+	}
+
+	private void initContextHolders(
+			HttpServletRequest request, LocaleContext localeContext, RequestAttributes requestAttributes) {
+
+		if (localeContext != null) {
+			LocaleContextHolder.setLocaleContext(localeContext, this.threadContextInheritable);
+		}
+		if (requestAttributes != null) {
+			RequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);
 		}
 		if (logger.isTraceEnabled()) {
 			logger.trace("Bound request context to thread: " + request);
@@ -997,17 +1029,17 @@ private void resetContextHolders(HttpServletRequest request,
 		}
 	}
 
-	private CallableProcessingInterceptor getRequestBindingInterceptor(final HttpServletRequest request) {
-		return new CallableProcessingInterceptorAdapter() {
-			@Override
-			public <T> void preProcess(NativeWebRequest webRequest, Callable<T> task) {
-				initContextHolders(request, buildLocaleContext(request), new ServletRequestAttributes(request));
-			}
-			@Override
-			public <T> void postProcess(NativeWebRequest webRequest, Callable<T> task, Object concurrentResult) {
-				resetContextHolders(request, null, null);
-			}
-		};
+	private void publishRequestHandledEvent(HttpServletRequest request, long startTime, Throwable failureCause) {
+		if (this.publishEvents) {
+			// Whether or not we succeeded, publish an event.
+			long processingTime = System.currentTimeMillis() - startTime;
+			this.webApplicationContext.publishEvent(
+					new ServletRequestHandledEvent(this,
+							request.getRequestURI(), request.getRemoteAddr(),
+							request.getMethod(), getServletConfig().getServletName(),
+							WebUtils.getSessionId(request), getUsernameForRequest(request),
+							processingTime, failureCause));
+		}
 	}
 
 	/**
@@ -1023,6 +1055,7 @@ protected String getUsernameForRequest(HttpServletRequest request) {
 		return (userPrincipal != null ? userPrincipal.getName() : null);
 	}
 
+
 	/**
 	 * Subclasses must implement this method to do the work of request handling,
 	 * receiving a centralized callback for GET, POST, PUT and DELETE.
@@ -1040,19 +1073,6 @@ protected abstract void doService(HttpServletRequest request, HttpServletRespons
 			throws Exception;
 
 
-	/**
-	 * Close the WebApplicationContext of this servlet.
-	 * @see org.springframework.context.ConfigurableApplicationContext#close()
-	 */
-	@Override
-	public void destroy() {
-		getServletContext().log("Destroying Spring FrameworkServlet '" + getServletName() + "'");
-		if (this.webApplicationContext instanceof ConfigurableApplicationContext) {
-			((ConfigurableApplicationContext) this.webApplicationContext).close();
-		}
-	}
-
-
 	/**
 	 * ApplicationListener endpoint that receives events from this servlet's WebApplicationContext
 	 * only, delegating to {@code onApplicationEvent} on the FrameworkServlet instance.
@@ -1064,4 +1084,28 @@ public void onApplicationEvent(ContextRefreshedEvent event) {
 		}
 	}
 
+
+	/**
+	 * CallableProcessingInterceptor implementation that initializes and resets
+	 * FrameworkServlet's context holders, i.e. LocaleContextHolder and RequestContextHolder.
+	 */
+	private class RequestBindingInterceptor extends CallableProcessingInterceptorAdapter {
+
+		@Override
+		public <T> void preProcess(NativeWebRequest webRequest, Callable<T> task) {
+			HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
+			if (request != null) {
+				HttpServletResponse response = webRequest.getNativeRequest(HttpServletResponse.class);
+				initContextHolders(request, buildLocaleContext(request), buildRequestAttributes(request, response, null));
+			}
+		}
+		@Override
+		public <T> void postProcess(NativeWebRequest webRequest, Callable<T> task, Object concurrentResult) {
+			HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
+			if (request != null) {
+				resetContextHolders(request, null, null);
+			}
+		}
+	}
+
 }
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/AnnotationDrivenBeanDefinitionParser.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/AnnotationDrivenBeanDefinitionParser.java
index 9d409a3fec5e..7fef39364c37 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/AnnotationDrivenBeanDefinitionParser.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/AnnotationDrivenBeanDefinitionParser.java
@@ -154,7 +154,6 @@ public BeanDefinition parse(Element element, ParserContext parserContext) {
 		handlerMappingDef.setSource(source);
 		handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
 		handlerMappingDef.getPropertyValues().add("order", 0);
-		handlerMappingDef.getPropertyValues().add("removeSemicolonContent", false);
 		handlerMappingDef.getPropertyValues().add("contentNegotiationManager", contentNegotiationManager);
 		String methodMappingName = parserContext.getReaderContext().registerWithGeneratedName(handlerMappingDef);
 
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/ResourcesBeanDefinitionParser.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/ResourcesBeanDefinitionParser.java
index 97df07e544aa..6bfdb9c56f45 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/ResourcesBeanDefinitionParser.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/ResourcesBeanDefinitionParser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package org.springframework.web.servlet.config;
 
+import java.util.Arrays;
 import java.util.Map;
 
 import org.w3c.dom.Element;
@@ -89,7 +90,7 @@ private String registerResourceHandler(ParserContext parserContext, Element elem
 		}
 
 		ManagedList<String> locations = new ManagedList<String>();
-		locations.addAll(StringUtils.commaDelimitedListToSet(locationAttr));
+		locations.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(locationAttr)));
 
 		RootBeanDefinition resourceHandlerDef = new RootBeanDefinition(ResourceHttpRequestHandler.class);
 		resourceHandlerDef.setSource(source);
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/DefaultServletHandlerConfigurer.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/DefaultServletHandlerConfigurer.java
index 6b6f5d1acf88..7e85dcf956ef 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/DefaultServletHandlerConfigurer.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/DefaultServletHandlerConfigurer.java
@@ -95,4 +95,4 @@ protected AbstractHandlerMapping getHandlerMapping() {
 		return handlerMapping;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ResourceHandlerRegistry.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ResourceHandlerRegistry.java
index 96fdcaf4e09f..65ef9be6c533 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ResourceHandlerRegistry.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ResourceHandlerRegistry.java
@@ -108,4 +108,4 @@ protected AbstractHandlerMapping getHandlerMapping() {
 		return handlerMapping;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ViewControllerRegistry.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ViewControllerRegistry.java
index fcc284989f8d..adfd5cf1632f 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ViewControllerRegistry.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/ViewControllerRegistry.java
@@ -74,4 +74,4 @@ protected AbstractHandlerMapping getHandlerMapping() {
 		return handlerMapping;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java
index e85f18912600..c3d1fc08833e 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurationSupport.java
@@ -192,7 +192,6 @@ public void setApplicationContext(ApplicationContext applicationContext) throws
 	public RequestMappingHandlerMapping requestMappingHandlerMapping() {
 		RequestMappingHandlerMapping handlerMapping = new RequestMappingHandlerMapping();
 		handlerMapping.setOrder(0);
-		handlerMapping.setRemoveSemicolonContent(false);
 		handlerMapping.setInterceptors(getInterceptors());
 		handlerMapping.setContentNegotiationManager(mvcContentNegotiationManager());
 		return handlerMapping;
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurerAdapter.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurerAdapter.java
index ac63b1cbca93..6f6c82733c03 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurerAdapter.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/WebMvcConfigurerAdapter.java
@@ -128,4 +128,4 @@ public void addResourceHandlers(ResourceHandlerRegistry registry) {
 	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java
index ea079c493867..b790a1e62b2c 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java
@@ -127,6 +127,7 @@ public void setUrlDecode(boolean urlDecode) {
 
 	/**
 	 * Set if ";" (semicolon) content should be stripped from the request URI.
+	 * <p>The default value is {@code false}.
 	 * @see org.springframework.web.util.UrlPathHelper#setRemoveSemicolonContent(boolean)
 	 */
 	public void setRemoveSemicolonContent(boolean removeSemicolonContent) {
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java
index c8f11c8175f1..ccdec77d51dd 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java
@@ -37,6 +37,7 @@
 import org.springframework.web.method.HandlerMethod;
 import org.springframework.web.method.HandlerMethodSelector;
 import org.springframework.web.servlet.HandlerMapping;
+import org.springframework.web.util.UrlPathHelper;
 
 /**
  * Abstract base class for {@link HandlerMapping} implementations that define a
@@ -61,6 +62,12 @@ public abstract class AbstractHandlerMethodMapping<T> extends AbstractHandlerMap
 	private final MultiValueMap<String, T> urlMap = new LinkedMultiValueMap<String, T>();
 
 
+	public AbstractHandlerMethodMapping() {
+		UrlPathHelper pathHelper = new UrlPathHelper();
+		pathHelper.setRemoveSemicolonContent(false);
+		setUrlPathHelper(pathHelper);
+	}
+
 	/**
 	 * Whether to detect handler methods in beans in ancestor ApplicationContexts.
 	 * <p>Default is "false": Only beans in the current ApplicationContext are
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/AbstractMediaTypeExpression.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/AbstractMediaTypeExpression.java
index 15aee22ec259..bc65b27de2a5 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/AbstractMediaTypeExpression.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/AbstractMediaTypeExpression.java
@@ -107,4 +107,4 @@ public String toString() {
 		return builder.toString();
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/MediaTypeExpression.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/MediaTypeExpression.java
index 986d9a4fe9b0..9810bedc0f55 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/MediaTypeExpression.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/MediaTypeExpression.java
@@ -36,4 +36,4 @@ public interface MediaTypeExpression {
 
 	boolean isNegated();
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/NameValueExpression.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/NameValueExpression.java
index 6bb9c8187275..0203f698af9c 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/NameValueExpression.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/NameValueExpression.java
@@ -37,4 +37,4 @@ public interface NameValueExpression<T> {
 
 	boolean isNegated();
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/PatternsRequestCondition.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/PatternsRequestCondition.java
index 357e31fe368c..53642385ca90 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/PatternsRequestCondition.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/PatternsRequestCondition.java
@@ -42,9 +42,16 @@
  */
 public final class PatternsRequestCondition extends AbstractRequestCondition<PatternsRequestCondition> {
 
+	private static UrlPathHelper pathHelperNoSemicolonContent;
+
+	static {
+		pathHelperNoSemicolonContent = new UrlPathHelper();
+		pathHelperNoSemicolonContent.setRemoveSemicolonContent(true);
+	}
+
 	private final Set<String> patterns;
 
-	private final UrlPathHelper urlPathHelper;
+	private final UrlPathHelper pathHelper;
 
 	private final PathMatcher pathMatcher;
 
@@ -105,7 +112,7 @@ private PatternsRequestCondition(Collection<String> patterns, UrlPathHelper urlP
 			List<String> fileExtensions) {
 
 		this.patterns = Collections.unmodifiableSet(prependLeadingSlash(patterns));
-		this.urlPathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper();
+		this.pathHelper = urlPathHelper != null ? urlPathHelper : new UrlPathHelper();
 		this.pathMatcher = pathMatcher != null ? pathMatcher : new AntPathMatcher();
 		this.useSuffixPatternMatch = useSuffixPatternMatch;
 		this.useTrailingSlashMatch = useTrailingSlashMatch;
@@ -179,7 +186,7 @@ else if (!other.patterns.isEmpty()) {
 		else {
 			result.add("");
 		}
-		return new PatternsRequestCondition(result, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,
+		return new PatternsRequestCondition(result, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,
 				this.useTrailingSlashMatch, this.fileExtensions);
 	}
 
@@ -206,17 +213,24 @@ public PatternsRequestCondition getMatchingCondition(HttpServletRequest request)
 		if (this.patterns.isEmpty()) {
 			return this;
 		}
-		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
+
+		String lookupPath = this.pathHelper.getLookupPathForRequest(request);
+		String lookupPathNoSemicolonContent = (lookupPath.indexOf(';') != -1) ?
+				pathHelperNoSemicolonContent.getLookupPathForRequest(request) : null;
+
 		List<String> matches = new ArrayList<String>();
 		for (String pattern : patterns) {
 			String match = getMatchingPattern(pattern, lookupPath);
+			if (match == null && lookupPathNoSemicolonContent != null) {
+				match = getMatchingPattern(pattern, lookupPathNoSemicolonContent);
+			}
 			if (match != null) {
 				matches.add(match);
 			}
 		}
 		Collections.sort(matches, this.pathMatcher.getPatternComparator(lookupPath));
 		return matches.isEmpty() ? null :
-			new PatternsRequestCondition(matches, this.urlPathHelper, this.pathMatcher, this.useSuffixPatternMatch,
+			new PatternsRequestCondition(matches, this.pathHelper, this.pathMatcher, this.useSuffixPatternMatch,
 					this.useTrailingSlashMatch, this.fileExtensions);
 	}
 
@@ -225,7 +239,7 @@ private String getMatchingPattern(String pattern, String lookupPath) {
 			return pattern;
 		}
 		if (this.useSuffixPatternMatch) {
-			if (useSmartSuffixPatternMatch(pattern, lookupPath)) {
+			if (!this.fileExtensions.isEmpty() && lookupPath.indexOf('.') != -1) {
 				for (String extension : this.fileExtensions) {
 					if (this.pathMatcher.match(pattern + extension, lookupPath)) {
 						return pattern + extension;
@@ -251,14 +265,6 @@ private String getMatchingPattern(String pattern, String lookupPath) {
 		return null;
 	}
 
-	/**
-	 * Whether to match by known file extensions. Return "true" if file extensions
-	 * are configured, and the lookup path has a suffix.
-	 */
-	private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath) {
-		return (!this.fileExtensions.isEmpty() && lookupPath.indexOf('.') != -1) ;
-	}
-
 	/**
 	 * Compare the two conditions based on the URL patterns they contain.
 	 * Patterns are compared one at a time, from top to bottom via
@@ -272,7 +278,7 @@ private boolean useSmartSuffixPatternMatch(String pattern, String lookupPath) {
 	 * the best matches on top.
 	 */
 	public int compareTo(PatternsRequestCondition other, HttpServletRequest request) {
-		String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);
+		String lookupPath = this.pathHelper.getLookupPathForRequest(request);
 		Comparator<String> patternComparator = this.pathMatcher.getPatternComparator(lookupPath);
 
 		Iterator<String> iterator = patterns.iterator();
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping.java
index cc242bf756a9..89fcb4e9e1c3 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping.java
@@ -205,7 +205,12 @@ else if (patternAndMethodMatches.isEmpty() && !allowedMethods.isEmpty()) {
 		if (!consumableMediaTypes.isEmpty()) {
 			MediaType contentType = null;
 			if (StringUtils.hasLength(request.getContentType())) {
-				contentType = MediaType.parseMediaType(request.getContentType());
+				try {
+					contentType = MediaType.parseMediaType(request.getContentType());
+				}
+				catch (IllegalArgumentException ex) {
+					throw new HttpMediaTypeNotSupportedException(ex.getMessage());
+				}
 			}
 			throw new HttpMediaTypeNotSupportedException(contentType, new ArrayList<MediaType>(consumableMediaTypes));
 		}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/PathVariableMapMethodArgumentResolver.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/PathVariableMapMethodArgumentResolver.java
index 52af8e427af1..514df9100228 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/PathVariableMapMethodArgumentResolver.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/PathVariableMapMethodArgumentResolver.java
@@ -67,4 +67,4 @@ public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer m
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/PathVariableMethodArgumentResolver.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/PathVariableMethodArgumentResolver.java
index d93b7746a7a3..7b960f001ce5 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/PathVariableMethodArgumentResolver.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/PathVariableMethodArgumentResolver.java
@@ -119,4 +119,4 @@ private PathVariableNamedValueInfo(PathVariable annotation) {
 			super(annotation.value(), true, ValueConstants.DEFAULT_NONE);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java
index d79a9ef5db0d..848e9127034e 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java
@@ -879,4 +879,4 @@ public boolean matches(Method method) {
 		}
 	};
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessor.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessor.java
index 9b320cedb960..a7473a60f185 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessor.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessor.java
@@ -190,4 +190,4 @@ public void handleReturnValue(Object returnValue, MethodParameter returnType,
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletCookieValueMethodArgumentResolver.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletCookieValueMethodArgumentResolver.java
index 8d3d77acd995..48080aa16a09 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletCookieValueMethodArgumentResolver.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletCookieValueMethodArgumentResolver.java
@@ -60,4 +60,4 @@ else if (cookieValue != null) {
 			return null;
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletModelAttributeMethodProcessor.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletModelAttributeMethodProcessor.java
index 3b54676ed31c..3cfd087e334b 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletModelAttributeMethodProcessor.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletModelAttributeMethodProcessor.java
@@ -153,4 +153,4 @@ protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest requ
 		servletBinder.bind(servletRequest);
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletWebArgumentResolverAdapter.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletWebArgumentResolverAdapter.java
index 5513dddae00b..d716a9bc4884 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletWebArgumentResolverAdapter.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletWebArgumentResolverAdapter.java
@@ -51,4 +51,4 @@ protected NativeWebRequest getWebRequest() {
 		}
 		return null;
 	}
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/multiaction/ParameterMethodNameResolver.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/multiaction/ParameterMethodNameResolver.java
index bd9405b65bb7..1a2e175fb1a0 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/multiaction/ParameterMethodNameResolver.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/multiaction/ParameterMethodNameResolver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -50,14 +50,14 @@
  *
  * <p>Note that the second strategy also supports the use of submit buttons of
  * type 'image'. That is, an image submit button named 'reset' will normally be
- * submitted by the browser as two request paramters called 'reset.x', and
- * 'reset.y'. When checking for the existence of a paramter from the
+ * submitted by the browser as two request parameters called 'reset.x', and
+ * 'reset.y'. When checking for the existence of a parameter from the
  * {@code methodParamNames} list, to indicate that a specific method should
- * be called, the code will look for request parameter in the "reset" form
- * (exactly as spcified in the list), and in the "reset.x" form ('.x' appended to
- * the name in the list). In this way it can handle both normal and image submit
- * buttons. The actual method name resolved if there is a match will always be
- * the bare form without the ".x".
+ * be called, the code will look for a request parameter in the "reset" form
+ * (exactly as specified in the list), and in the "reset.x" form ('.x' appended
+ * to the name in the list). In this way it can handle both normal and image
+ * submit buttons. The actual method name resolved, if there is a match, will
+ * always be the bare form without the ".x".
  *
  * <p><b>Note:</b> If both strategies are configured, i.e. both "paramName"
  * and "methodParamNames" are specified, then both will be checked for any given
@@ -69,7 +69,7 @@
  *
  * <p>For both resolution strategies, the method name is of course coming from
  * some sort of view code, (such as a JSP page). While this may be acceptable,
- * it is sometimes desireable to treat this only as a 'logical' method name,
+ * it is sometimes desirable to treat this only as a 'logical' method name,
  * with a further mapping to a 'real' method name. As such, an optional
  * 'logical' mapping may be specified for this purpose.
  *
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/AbstractCachingViewResolver.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/AbstractCachingViewResolver.java
index c0a66c521608..51b6cbc2f2fb 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/AbstractCachingViewResolver.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/AbstractCachingViewResolver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,9 @@
 import java.util.LinkedHashMap;
 import java.util.Locale;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 
 import org.springframework.web.context.support.WebApplicationObjectSupport;
 import org.springframework.web.servlet.View;
@@ -42,19 +45,38 @@ public abstract class AbstractCachingViewResolver extends WebApplicationObjectSu
 	/** Default maximum number of entries for the view cache: 1024 */
 	public static final int DEFAULT_CACHE_LIMIT = 1024;
 
+	/** Dummy marker object for unresolved views in the cache Maps */
+	private static final View UNRESOLVED_VIEW = new View() {
+		public String getContentType() {
+			return null;
+		}
+		public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {
+		}
+	};
 
+
+	/** The maximum number of entries in the cache */
 	private volatile int cacheLimit = DEFAULT_CACHE_LIMIT;
 
 	/** Whether we should refrain from resolving views again if unresolved once */
 	private boolean cacheUnresolved = true;
 
-	/** Map from view key to View instance */
+	/** Fast access cache for Views, returning already cached instances without a global lock */
+	private final Map<Object, View> viewAccessCache = new ConcurrentHashMap<Object, View>(DEFAULT_CACHE_LIMIT);
+
+	/** Map from view key to View instance, synchronized for View creation */
 	@SuppressWarnings("serial")
-	private final Map<Object, View> viewCache =
+	private final Map<Object, View> viewCreationCache =
 			new LinkedHashMap<Object, View>(DEFAULT_CACHE_LIMIT, 0.75f, true) {
 				@Override
 				protected boolean removeEldestEntry(Map.Entry<Object, View> eldest) {
-					return size() > getCacheLimit();
+					if (size() > getCacheLimit()) {
+						viewAccessCache.remove(eldest.getKey());
+						return true;
+					}
+					else {
+						return false;
+					}
 				}
 			};
 
@@ -122,20 +144,27 @@ public View resolveViewName(String viewName, Locale locale) throws Exception {
 		}
 		else {
 			Object cacheKey = getCacheKey(viewName, locale);
-			synchronized (this.viewCache) {
-				View view = this.viewCache.get(cacheKey);
-				if (view == null && (!this.cacheUnresolved || !this.viewCache.containsKey(cacheKey))) {
-					// Ask the subclass to create the View object.
-					view = createView(viewName, locale);
-					if (view != null || this.cacheUnresolved) {
-						this.viewCache.put(cacheKey, view);
-						if (logger.isTraceEnabled()) {
-							logger.trace("Cached view [" + cacheKey + "]");
+			View view = this.viewAccessCache.get(cacheKey);
+			if (view == null) {
+				synchronized (this.viewCreationCache) {
+					view = this.viewCreationCache.get(cacheKey);
+					if (view == null) {
+						// Ask the subclass to create the View object.
+						view = createView(viewName, locale);
+						if (view == null && this.cacheUnresolved) {
+							view = UNRESOLVED_VIEW;
+						}
+						if (view != null) {
+							this.viewAccessCache.put(cacheKey, view);
+							this.viewCreationCache.put(cacheKey, view);
+							if (logger.isTraceEnabled()) {
+								logger.trace("Cached view [" + cacheKey + "]");
+							}
 						}
 					}
 				}
-				return view;
 			}
+			return (view != UNRESOLVED_VIEW ? view : null);
 		}
 	}
 
@@ -166,17 +195,16 @@ public void removeFromCache(String viewName, Locale locale) {
 		else {
 			Object cacheKey = getCacheKey(viewName, locale);
 			Object cachedView;
-			synchronized (this.viewCache) {
-				cachedView = this.viewCache.remove(cacheKey);
+			synchronized (this.viewCreationCache) {
+				this.viewAccessCache.remove(cacheKey);
+				cachedView = this.viewCreationCache.remove(cacheKey);
 			}
-			if (cachedView == null) {
+			if (logger.isDebugEnabled()) {
 				// Some debug output might be useful...
-				if (logger.isDebugEnabled()) {
+				if (cachedView == null) {
 					logger.debug("No cached instance for view '" + cacheKey + "' was found");
 				}
-			}
-			else {
-				if (logger.isDebugEnabled()) {
+				else {
 					logger.debug("Cache for view " + cacheKey + " has been cleared");
 				}
 			}
@@ -189,8 +217,9 @@ public void removeFromCache(String viewName, Locale locale) {
 	 */
 	public void clearCache() {
 		logger.debug("Clearing entire view cache");
-		synchronized (this.viewCache) {
-			this.viewCache.clear();
+		synchronized (this.viewCreationCache) {
+			this.viewAccessCache.clear();
+			this.viewCreationCache.clear();
 		}
 	}
 
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.java
index 2d543941af6f..f7b59c3f6c24 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,7 +25,6 @@
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
-
 import javax.activation.FileTypeMap;
 import javax.servlet.ServletContext;
 import javax.servlet.http.HttpServletRequest;
@@ -33,6 +32,7 @@
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+
 import org.springframework.beans.factory.BeanFactoryUtils;
 import org.springframework.beans.factory.InitializingBean;
 import org.springframework.core.OrderComparator;
@@ -95,7 +95,7 @@ public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport
 
 	private ContentNegotiationManager contentNegotiationManager;
 
-	private ContentNegotiationManagerFactoryBean cnManagerFactoryBean = new ContentNegotiationManagerFactoryBean();
+	private final ContentNegotiationManagerFactoryBean cnManagerFactoryBean = new ContentNegotiationManagerFactoryBean();
 
 	private boolean useNotAcceptableStatusCode = false;
 
@@ -104,10 +104,6 @@ public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport
 	private List<ViewResolver> viewResolvers;
 
 
-	public ContentNegotiatingViewResolver() {
-		super();
-	}
-
 	public void setOrder(int order) {
 		this.order = order;
 	}
@@ -118,7 +114,9 @@ public int getOrder() {
 
 	/**
 	 * Set the {@link ContentNegotiationManager} to use to determine requested media types.
-	 * If not set, the default constructor is used.
+	 * <p>If not set, ContentNegotiationManager's default constructor will be used,
+	 * applying a {@link org.springframework.web.accept.HeaderContentNegotiationStrategy}.
+	 * @see ContentNegotiationManager#ContentNegotiationManager()
 	 */
 	public void setContentNegotiationManager(ContentNegotiationManager contentNegotiationManager) {
 		this.contentNegotiationManager = contentNegotiationManager;
@@ -130,18 +128,16 @@ public void setContentNegotiationManager(ContentNegotiationManager contentNegoti
 	 * <p>For instance, when this flag is {@code true} (the default), a request for {@code /hotels.pdf}
 	 * will result in an {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the
 	 * browser-defined {@code text/html,application/xhtml+xml}.
-	 *
 	 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 	 */
 	@Deprecated
 	public void setFavorPathExtension(boolean favorPathExtension) {
-		this.cnManagerFactoryBean.setFavorParameter(favorPathExtension);
+		this.cnManagerFactoryBean.setFavorPathExtension(favorPathExtension);
 	}
 
 	/**
 	 * Indicate whether to use the Java Activation Framework to map from file extensions to media types.
 	 * <p>Default is {@code true}, i.e. the Java Activation Framework is used (if available).
-	 *
 	 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 	 */
 	@Deprecated
@@ -155,7 +151,6 @@ public void setUseJaf(boolean useJaf) {
 	 * <p>For instance, when this flag is {@code true}, a request for {@code /hotels?format=pdf} will result
 	 * in an {@code AbstractPdfView} being resolved, while the {@code Accept} header can be the browser-defined
 	 * {@code text/html,application/xhtml+xml}.
-	 *
 	 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 	 */
 	@Deprecated
@@ -166,7 +161,6 @@ public void setFavorParameter(boolean favorParameter) {
 	/**
 	 * Set the parameter name that can be used to determine the requested media type if the {@link
 	 * #setFavorParameter} property is {@code true}. The default parameter name is {@code format}.
-	 *
 	 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 	 */
 	@Deprecated
@@ -179,7 +173,6 @@ public void setParameterName(String parameterName) {
 	 * <p>If set to {@code true}, this view resolver will only refer to the file extension and/or
 	 * parameter, as indicated by the {@link #setFavorPathExtension favorPathExtension} and
 	 * {@link #setFavorParameter favorParameter} properties.
-	 *
 	 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 	 */
 	@Deprecated
@@ -191,7 +184,6 @@ public void setIgnoreAcceptHeader(boolean ignoreAcceptHeader) {
 	 * Set the mapping from file extensions to media types.
 	 * <p>When this mapping is not set or when an extension is not present, this view resolver
 	 * will fall back to using a {@link FileTypeMap} when the Java Action Framework is available.
-	 *
 	 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 	 */
 	@Deprecated
@@ -207,7 +199,6 @@ public void setMediaTypes(Map<String, String> mediaTypes) {
 	 * Set the default content type.
 	 * <p>This content type will be used when file extension, parameter, nor {@code Accept}
 	 * header define a content-type, either through being disabled or empty.
-	 *
 	 * @deprecated use {@link #setContentNegotiationManager(ContentNegotiationManager)}
 	 */
 	@Deprecated
@@ -275,7 +266,7 @@ protected void initServletContext(ServletContext servletContext) {
 		this.cnManagerFactoryBean.setServletContext(servletContext);
 	}
 
-	public void afterPropertiesSet() throws Exception {
+	public void afterPropertiesSet() {
 		if (this.contentNegotiationManager == null) {
 			this.cnManagerFactoryBean.afterPropertiesSet();
 			this.contentNegotiationManager = this.cnManagerFactoryBean.getObject();
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ResourceBundleViewResolver.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ResourceBundleViewResolver.java
index 2726e0537c31..77c3a67e036a 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ResourceBundleViewResolver.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ResourceBundleViewResolver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -160,7 +160,7 @@ protected ClassLoader getBundleClassLoader() {
 	 * <p>View definitions that define their own parent or carry their own
 	 * class can still override this. Strictly speaking, the rule that a
 	 * default parent setting does not apply to a bean definition that
-	 * carries a class is there for backwards compatiblity reasons.
+	 * carries a class is there for backwards compatibility reasons.
 	 * It still matches the typical use case.
 	 */
 	public void setDefaultParentView(String defaultParentView) {
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/freemarker/spring.ftl b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/freemarker/spring.ftl
index 43b29af322eb..bfb41221f7c5 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/freemarker/spring.ftl
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/freemarker/spring.ftl
@@ -309,8 +309,8 @@
 	<@bind path />
     <#assign id="${status.expression?replace('[','')?replace(']','')}">
     <#assign isSelected = status.value?? && status.value?string=="true">
-	<input type="hidden" name="_${id}" value="on"/>
-	<input type="checkbox" id="${id}" name="${id}"<#if isSelected> checked="checked"</#if> ${attributes}/>
+	<input type="hidden" name="_${status.expression}" value="on"/>
+	<input type="checkbox" id="${id}" name="${status.expression}"<#if isSelected> checked="checked"</#if> ${attributes}/>
 </#macro>
 
 <#--
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/jasperreports/JasperReportsCsvView.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/jasperreports/JasperReportsCsvView.java
index f8297f3b1443..b93a28269be0 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/jasperreports/JasperReportsCsvView.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/jasperreports/JasperReportsCsvView.java
@@ -43,4 +43,4 @@ protected boolean useWriter() {
 		return true;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/MappingJackson2JsonView.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/MappingJackson2JsonView.java
index 7510ab304e69..29c670a13896 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/MappingJackson2JsonView.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/MappingJackson2JsonView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@
 package org.springframework.web.servlet.view.json;
 
 import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Collections;
 import java.util.HashMap;
@@ -27,7 +28,6 @@
 
 import com.fasterxml.jackson.core.JsonEncoding;
 import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.SerializationFeature;
 
@@ -48,13 +48,15 @@
  * @author Jeremy Grelle
  * @author Arjen Poutsma
  * @author Rossen Stoyanchev
+ * @author Juergen Hoeller
  * @since 3.1.2
  * @see org.springframework.http.converter.json.MappingJackson2HttpMessageConverter
  */
 public class MappingJackson2JsonView extends AbstractView {
 
 	/**
-	 * Default content type. Overridable as bean property.
+	 * Default content type: "application/json".
+	 * Overridable through {@link #setContentType}.
 	 */
 	public static final String DEFAULT_CONTENT_TYPE = "application/json";
 
@@ -75,8 +77,9 @@ public class MappingJackson2JsonView extends AbstractView {
 
 	private boolean updateContentLength = false;
 
+
 	/**
-	 * Construct a new {@code JacksonJsonView}, setting the content type to {@code application/json}.
+	 * Construct a new {@code MappingJackson2JsonView}, setting the content type to {@code application/json}.
 	 */
 	public MappingJackson2JsonView() {
 		setContentType(DEFAULT_CONTENT_TYPE);
@@ -85,13 +88,11 @@ public MappingJackson2JsonView() {
 
 
 	/**
-	 * Sets the {@code ObjectMapper} for this view.
-	 * If not set, a default {@link ObjectMapper#ObjectMapper() ObjectMapper} is used.
-	 * <p>Setting a custom-configured {@code ObjectMapper} is one way to take further control
-	 * of the JSON serialization process. For example, an extended {@code SerializerFactory}
-	 * can be configured that provides custom serializers for specific types. The other option
-	 * for refining the serialization process is to use Jackson's provided annotations on the
-	 * types to be serialized, in which case a custom-configured ObjectMapper is unnecessary.
+	 * Set the {@code ObjectMapper} for this view.
+	 * If not set, a default {@link ObjectMapper#ObjectMapper() ObjectMapper} will be used.
+	 * <p>Setting a custom-configured {@code ObjectMapper} is one way to take further control of
+	 * the JSON serialization process. The other option is to use Jackson's provided annotations
+	 * on the types to be serialized, in which case a custom-configured ObjectMapper is unnecessary.
 	 */
 	public void setObjectMapper(ObjectMapper objectMapper) {
 		Assert.notNull(objectMapper, "'objectMapper' must not be null");
@@ -99,14 +100,15 @@ public void setObjectMapper(ObjectMapper objectMapper) {
 		configurePrettyPrint();
 	}
 
-	private void configurePrettyPrint() {
-		if (this.prettyPrint != null) {
-			this.objectMapper.configure(SerializationFeature.INDENT_OUTPUT, this.prettyPrint);
-		}
+	/**
+	 * Return the {@code ObjectMapper} for this view.
+	 */
+	public final ObjectMapper getObjectMapper() {
+		return this.objectMapper;
 	}
 
 	/**
-	 * Set the {@code JsonEncoding} for this converter.
+	 * Set the {@code JsonEncoding} for this view.
 	 * By default, {@linkplain JsonEncoding#UTF8 UTF-8} is used.
 	 */
 	public void setEncoding(JsonEncoding encoding) {
@@ -114,9 +116,16 @@ public void setEncoding(JsonEncoding encoding) {
 		this.encoding = encoding;
 	}
 
+	/**
+	 * Return the {@code JsonEncoding} for this view.
+	 */
+	public final JsonEncoding getEncoding() {
+		return this.encoding;
+	}
+
 	/**
 	 * Indicates whether the JSON output by this view should be prefixed with <tt>"{} && "</tt>.
-	 * Default is false.
+	 * Default is {@code false}.
 	 * <p>Prefixing the JSON string in this manner is used to help prevent JSON Hijacking.
 	 * The prefix renders the string syntactically invalid as a script so that it cannot be hijacked.
 	 * This prefix does not affect the evaluation of JSON, but if JSON validation is performed
@@ -127,12 +136,11 @@ public void setPrefixJson(boolean prefixJson) {
 	}
 
 	/**
-	 * Whether to use the {@link DefaultPrettyPrinter} when writing JSON.
+	 * Whether to use the default pretty printer when writing JSON.
 	 * This is a shortcut for setting up an {@code ObjectMapper} as follows:
 	 * <pre>
 	 * ObjectMapper mapper = new ObjectMapper();
 	 * mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
-	 * converter.setObjectMapper(mapper);
 	 * </pre>
 	 * <p>The default value is {@code false}.
 	 */
@@ -141,6 +149,12 @@ public void setPrettyPrint(boolean prettyPrint) {
 		configurePrettyPrint();
 	}
 
+	private void configurePrettyPrint() {
+		if (this.prettyPrint != null) {
+			this.objectMapper.configure(SerializationFeature.INDENT_OUTPUT, this.prettyPrint);
+		}
+	}
+
 	/**
 	 * Set the attribute in the model that should be rendered by this view.
 	 * When set, all other model attributes will be ignored.
@@ -160,7 +174,7 @@ public void setModelKeys(Set<String> modelKeys) {
 	/**
 	 * Return the attributes in the model that should be rendered by this view.
 	 */
-	public Set<String> getModelKeys() {
+	public final Set<String> getModelKeys() {
 		return this.modelKeys;
 	}
 
@@ -179,7 +193,7 @@ public void setRenderedAttributes(Set<String> renderedAttributes) {
 	 * @deprecated use {@link #getModelKeys()} instead
 	 */
 	@Deprecated
-	public Set<String> getRenderedAttributes() {
+	public final Set<String> getRenderedAttributes() {
 		return this.modelKeys;
 	}
 
@@ -212,6 +226,7 @@ public void setUpdateContentLength(boolean updateContentLength) {
 		this.updateContentLength = updateContentLength;
 	}
 
+
 	@Override
 	protected void prepareResponse(HttpServletRequest request, HttpServletResponse response) {
 		setResponseContentType(request, response);
@@ -227,34 +242,21 @@ protected void prepareResponse(HttpServletRequest request, HttpServletResponse r
 	protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,
 			HttpServletResponse response) throws Exception {
 
-		OutputStream stream = this.updateContentLength ? createTemporaryOutputStream() : response.getOutputStream();
-
+		OutputStream stream = (this.updateContentLength ? createTemporaryOutputStream() : response.getOutputStream());
 		Object value = filterModel(model);
-		JsonGenerator generator = this.objectMapper.getJsonFactory().createJsonGenerator(stream, this.encoding);
-
-		// A workaround for JsonGenerators not applying serialization features
-		// https://github.com/FasterXML/jackson-databind/issues/12
-		if (this.objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
-			generator.useDefaultPrettyPrinter();
-		}
-
-		if (this.prefixJson) {
-			generator.writeRaw("{} && ");
-		}
-		this.objectMapper.writeValue(generator, value);
-
+		writeContent(stream, value, this.prefixJson);
 		if (this.updateContentLength) {
 			writeToResponse(response, (ByteArrayOutputStream) stream);
 		}
 	}
 
 	/**
-	 * Filters out undesired attributes from the given model.
+	 * Filter out undesired attributes from the given model.
 	 * The return value can be either another {@link Map} or a single value object.
 	 * <p>The default implementation removes {@link BindingResult} instances and entries
 	 * not included in the {@link #setRenderedAttributes renderedAttributes} property.
 	 * @param model the model, as passed on to {@link #renderMergedOutputModel}
-	 * @return the object to be rendered
+	 * @return the value to be rendered
 	 */
 	protected Object filterModel(Map<String, Object> model) {
 		Map<String, Object> result = new HashMap<String, Object>(model.size());
@@ -267,4 +269,27 @@ protected Object filterModel(Map<String, Object> model) {
 		return (this.extractValueFromSingleKeyModel && result.size() == 1 ? result.values().iterator().next() : result);
 	}
 
+	/**
+	 * Write the actual JSON content to the stream.
+	 * @param stream the output stream to use
+	 * @param value the value to be rendered, as returned from {@link #filterModel}
+	 * @param prefixJson whether the JSON output by this view should be prefixed
+	 * with <tt>"{} && "</tt> (as indicated through {@link #setPrefixJson})
+	 * @throws IOException if writing failed
+	 */
+	protected void writeContent(OutputStream stream, Object value, boolean prefixJson) throws IOException {
+		JsonGenerator generator = this.objectMapper.getJsonFactory().createJsonGenerator(stream, this.encoding);
+
+		// A workaround for JsonGenerators not applying serialization features
+		// https://github.com/FasterXML/jackson-databind/issues/12
+		if (this.objectMapper.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
+			generator.useDefaultPrettyPrinter();
+		}
+
+		if (prefixJson) {
+			generator.writeRaw("{} && ");
+		}
+		this.objectMapper.writeValue(generator, value);
+	}
+
 }
diff --git a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/MappingJacksonJsonView.java b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/MappingJacksonJsonView.java
index 5b97da49a82a..ef0ad59d9952 100644
--- a/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/MappingJacksonJsonView.java
+++ b/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/MappingJacksonJsonView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,12 +17,12 @@
 package org.springframework.web.servlet.view.json;
 
 import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
@@ -30,15 +30,13 @@
 import org.codehaus.jackson.JsonGenerator;
 import org.codehaus.jackson.map.ObjectMapper;
 import org.codehaus.jackson.map.SerializationConfig;
-import org.codehaus.jackson.map.SerializerFactory;
+
 import org.springframework.util.Assert;
 import org.springframework.util.CollectionUtils;
 import org.springframework.validation.BindingResult;
 import org.springframework.web.servlet.View;
 import org.springframework.web.servlet.view.AbstractView;
 
-import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
-
 /**
  * Spring MVC {@link View} that renders JSON content by serializing the model for the current request
  * using <a href="http://jackson.codehaus.org/">Jackson's</a> {@link ObjectMapper}.
@@ -50,13 +48,15 @@
  * @author Jeremy Grelle
  * @author Arjen Poutsma
  * @author Rossen Stoyanchev
+ * @author Juergen Hoeller
  * @since 3.0
  * @see org.springframework.http.converter.json.MappingJacksonHttpMessageConverter
  */
 public class MappingJacksonJsonView extends AbstractView {
 
 	/**
-	 * Default content type. Overridable as bean property.
+	 * Default content type: "application/json".
+	 * Overridable through {@link #setContentType}.
 	 */
 	public static final String DEFAULT_CONTENT_TYPE = "application/json";
 
@@ -77,8 +77,9 @@ public class MappingJacksonJsonView extends AbstractView {
 
 	private boolean updateContentLength = false;
 
+
 	/**
-	 * Construct a new {@code JacksonJsonView}, setting the content type to {@code application/json}.
+	 * Construct a new {@code MappingJacksonJsonView}, setting the content type to {@code application/json}.
 	 */
 	public MappingJacksonJsonView() {
 		setContentType(DEFAULT_CONTENT_TYPE);
@@ -87,13 +88,11 @@ public MappingJacksonJsonView() {
 
 
 	/**
-	 * Sets the {@code ObjectMapper} for this view.
-	 * If not set, a default {@link ObjectMapper#ObjectMapper() ObjectMapper} is used.
-	 * <p>Setting a custom-configured {@code ObjectMapper} is one way to take further control
-	 * of the JSON serialization process. For example, an extended {@link SerializerFactory}
-	 * can be configured that provides custom serializers for specific types. The other option
-	 * for refining the serialization process is to use Jackson's provided annotations on the
-	 * types to be serialized, in which case a custom-configured ObjectMapper is unnecessary.
+	 * Set the {@code ObjectMapper} for this view.
+	 * If not set, a default {@link ObjectMapper#ObjectMapper() ObjectMapper} will be used.
+	 * <p>Setting a custom-configured {@code ObjectMapper} is one way to take further control of
+	 * the JSON serialization process. The other option is to use Jackson's provided annotations
+	 * on the types to be serialized, in which case a custom-configured ObjectMapper is unnecessary.
 	 */
 	public void setObjectMapper(ObjectMapper objectMapper) {
 		Assert.notNull(objectMapper, "'objectMapper' must not be null");
@@ -101,14 +100,15 @@ public void setObjectMapper(ObjectMapper objectMapper) {
 		configurePrettyPrint();
 	}
 
-	private void configurePrettyPrint() {
-		if (this.prettyPrint != null) {
-			this.objectMapper.configure(SerializationConfig.Feature.INDENT_OUTPUT, this.prettyPrint);
-		}
+	/**
+	 * Return the {@code ObjectMapper} for this view.
+	 */
+	public final ObjectMapper getObjectMapper() {
+		return this.objectMapper;
 	}
 
 	/**
-	 * Set the {@code JsonEncoding} for this converter.
+	 * Set the {@code JsonEncoding} for this view.
 	 * By default, {@linkplain JsonEncoding#UTF8 UTF-8} is used.
 	 */
 	public void setEncoding(JsonEncoding encoding) {
@@ -116,9 +116,16 @@ public void setEncoding(JsonEncoding encoding) {
 		this.encoding = encoding;
 	}
 
+	/**
+	 * Return the {@code JsonEncoding} for this view.
+	 */
+	public final JsonEncoding getEncoding() {
+		return this.encoding;
+	}
+
 	/**
 	 * Indicates whether the JSON output by this view should be prefixed with <tt>"{} && "</tt>.
-	 * Default is false.
+	 * Default is {@code false}.
 	 * <p>Prefixing the JSON string in this manner is used to help prevent JSON Hijacking.
 	 * The prefix renders the string syntactically invalid as a script so that it cannot be hijacked.
 	 * This prefix does not affect the evaluation of JSON, but if JSON validation is performed
@@ -129,12 +136,11 @@ public void setPrefixJson(boolean prefixJson) {
 	}
 
 	/**
-	 * Whether to use the {@link DefaultPrettyPrinter} when writing JSON.
+	 * Whether to use the default pretty printer when writing JSON.
 	 * This is a shortcut for setting up an {@code ObjectMapper} as follows:
 	 * <pre>
 	 * ObjectMapper mapper = new ObjectMapper();
 	 * mapper.configure(SerializationConfig.Feature.INDENT_OUTPUT, true);
-	 * converter.setObjectMapper(mapper);
 	 * </pre>
 	 * <p>The default value is {@code false}.
 	 */
@@ -143,6 +149,12 @@ public void setPrettyPrint(boolean prettyPrint) {
 		configurePrettyPrint();
 	}
 
+	private void configurePrettyPrint() {
+		if (this.prettyPrint != null) {
+			this.objectMapper.configure(SerializationConfig.Feature.INDENT_OUTPUT, this.prettyPrint);
+		}
+	}
+
 	/**
 	 * Set the attribute in the model that should be rendered by this view.
 	 * When set, all other model attributes will be ignored.
@@ -162,7 +174,7 @@ public void setModelKeys(Set<String> modelKeys) {
 	/**
 	 * Return the attributes in the model that should be rendered by this view.
 	 */
-	public Set<String> getModelKeys() {
+	public final Set<String> getModelKeys() {
 		return this.modelKeys;
 	}
 
@@ -181,7 +193,7 @@ public void setRenderedAttributes(Set<String> renderedAttributes) {
 	 * @deprecated use {@link #getModelKeys()} instead
 	 */
 	@Deprecated
-	public Set<String> getRenderedAttributes() {
+	public final Set<String> getRenderedAttributes() {
 		return this.modelKeys;
 	}
 
@@ -230,34 +242,21 @@ protected void prepareResponse(HttpServletRequest request, HttpServletResponse r
 	protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,
 			HttpServletResponse response) throws Exception {
 
-		OutputStream stream = this.updateContentLength ? createTemporaryOutputStream() : response.getOutputStream();
-
+		OutputStream stream = (this.updateContentLength ? createTemporaryOutputStream() : response.getOutputStream());
 		Object value = filterModel(model);
-		JsonGenerator generator = this.objectMapper.getJsonFactory().createJsonGenerator(stream, this.encoding);
-
-		// A workaround for JsonGenerators not applying serialization features
-		// https://github.com/FasterXML/jackson-databind/issues/12
-		if (this.objectMapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {
-			generator.useDefaultPrettyPrinter();
-		}
-
-		if (this.prefixJson) {
-			generator.writeRaw("{} && ");
-		}
-		this.objectMapper.writeValue(generator, value);
-
+		writeContent(stream, value, this.prefixJson);
 		if (this.updateContentLength) {
 			writeToResponse(response, (ByteArrayOutputStream) stream);
 		}
 	}
 
 	/**
-	 * Filters out undesired attributes from the given model.
+	 * Filter out undesired attributes from the given model.
 	 * The return value can be either another {@link Map} or a single value object.
 	 * <p>The default implementation removes {@link BindingResult} instances and entries
 	 * not included in the {@link #setRenderedAttributes renderedAttributes} property.
 	 * @param model the model, as passed on to {@link #renderMergedOutputModel}
-	 * @return the object to be rendered
+	 * @return the value to be rendered
 	 */
 	protected Object filterModel(Map<String, Object> model) {
 		Map<String, Object> result = new HashMap<String, Object>(model.size());
@@ -270,4 +269,27 @@ protected Object filterModel(Map<String, Object> model) {
 		return (this.extractValueFromSingleKeyModel && result.size() == 1 ? result.values().iterator().next() : result);
 	}
 
+	/**
+	 * Write the actual JSON content to the stream.
+	 * @param stream the output stream to use
+	 * @param value the value to be rendered, as returned from {@link #filterModel}
+	 * @param prefixJson whether the JSON output by this view should be prefixed
+	 * with <tt>"{} && "</tt> (as indicated through {@link #setPrefixJson})
+	 * @throws IOException if writing failed
+	 */
+	protected void writeContent(OutputStream stream, Object value, boolean prefixJson) throws IOException {
+		JsonGenerator generator = this.objectMapper.getJsonFactory().createJsonGenerator(stream, this.encoding);
+
+		// A workaround for JsonGenerators not applying serialization features
+		// https://github.com/FasterXML/jackson-databind/issues/12
+		if (this.objectMapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {
+			generator.useDefaultPrettyPrinter();
+		}
+
+		if (prefixJson) {
+			generator.writeRaw("{} && ");
+		}
+		this.objectMapper.writeValue(generator, value);
+	}
+
 }
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/DispatcherServletTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/DispatcherServletTests.java
index b73e69ae6f28..d5ed530e5879 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/DispatcherServletTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/DispatcherServletTests.java
@@ -61,6 +61,7 @@
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * @author Rod Johnson
@@ -857,9 +858,10 @@ protected ConfigurableWebEnvironment createEnvironment() {
 
 	public void testAllowedOptionsIncludesPatchMethod() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest(getServletContext(), "OPTIONS", "/foo");
-		MockHttpServletResponse response = new MockHttpServletResponse();
+		MockHttpServletResponse response = spy(new MockHttpServletResponse());
 		DispatcherServlet servlet = new DispatcherServlet();
 		servlet.service(request, response);
+		verify(response, never()).getHeader(anyString()); // SPR-10341
 		assertThat(response.getHeader("Allow"), equalTo("GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH"));
 	}
 
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/HandlerExecutionChainTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/HandlerExecutionChainTests.java
index dca233e91475..a4f9572dc152 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/HandlerExecutionChainTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/HandlerExecutionChainTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,17 +16,14 @@
 
 package org.springframework.web.servlet;
 
-import static org.easymock.EasyMock.createStrictMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertSame;
-
 import org.junit.Before;
 import org.junit.Test;
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockHttpServletResponse;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * A test fixture with HandlerExecutionChain and mock handler interceptors.
  *
@@ -56,9 +53,9 @@ public void setup() {
 		this.handler = new Object();
 		this.chain = new HandlerExecutionChain(this.handler);
 
-		this.interceptor1 = createStrictMock(AsyncHandlerInterceptor.class);
-		this.interceptor2 = createStrictMock(AsyncHandlerInterceptor.class);
-		this.interceptor3 = createStrictMock(AsyncHandlerInterceptor.class);
+		this.interceptor1 = mock(AsyncHandlerInterceptor.class);
+		this.interceptor2 = mock(AsyncHandlerInterceptor.class);
+		this.interceptor3 = mock(AsyncHandlerInterceptor.class);
 
 		this.chain.addInterceptor(this.interceptor1);
 		this.chain.addInterceptor(this.interceptor2);
@@ -69,79 +66,60 @@ public void setup() {
 	public void successScenario() throws Exception {
 		ModelAndView mav = new ModelAndView();
 
-		expect(this.interceptor1.preHandle(this.request, this.response, this.handler)).andReturn(true);
-		expect(this.interceptor2.preHandle(this.request, this.response, this.handler)).andReturn(true);
-		expect(this.interceptor3.preHandle(this.request, this.response, this.handler)).andReturn(true);
-
-		this.interceptor1.postHandle(this.request, this.response, this.handler, mav);
-		this.interceptor2.postHandle(this.request, this.response, this.handler, mav);
-		this.interceptor3.postHandle(this.request, this.response, this.handler, mav);
-
-		this.interceptor3.afterCompletion(this.request, this.response, this.handler, null);
-		this.interceptor2.afterCompletion(this.request, this.response, this.handler, null);
-		this.interceptor1.afterCompletion(this.request, this.response, this.handler, null);
-
-		replay(this.interceptor1, this.interceptor2, this.interceptor3);
+		given(this.interceptor1.preHandle(this.request, this.response, this.handler)).willReturn(true);
+		given(this.interceptor2.preHandle(this.request, this.response, this.handler)).willReturn(true);
+		given(this.interceptor3.preHandle(this.request, this.response, this.handler)).willReturn(true);
 
 		this.chain.applyPreHandle(request, response);
 		this.chain.applyPostHandle(request, response, mav);
 		this.chain.triggerAfterCompletion(this.request, this.response, null);
 
-		verify(this.interceptor1, this.interceptor2, this.interceptor3);
+		verify(this.interceptor1).postHandle(this.request, this.response, this.handler, mav);
+		verify(this.interceptor2).postHandle(this.request, this.response, this.handler, mav);
+		verify(this.interceptor3).postHandle(this.request, this.response, this.handler, mav);
+
+		verify(this.interceptor3).afterCompletion(this.request, this.response, this.handler, null);
+		verify(this.interceptor2).afterCompletion(this.request, this.response, this.handler, null);
+		verify(this.interceptor1).afterCompletion(this.request, this.response, this.handler, null);
 	}
 
 	@Test
 	public void successAsyncScenario() throws Exception {
-		expect(this.interceptor1.preHandle(this.request, this.response, this.handler)).andReturn(true);
-		expect(this.interceptor2.preHandle(this.request, this.response, this.handler)).andReturn(true);
-		expect(this.interceptor3.preHandle(this.request, this.response, this.handler)).andReturn(true);
-
-		this.interceptor1.afterConcurrentHandlingStarted(request, response, this.handler);
-		this.interceptor2.afterConcurrentHandlingStarted(request, response, this.handler);
-		this.interceptor3.afterConcurrentHandlingStarted(request, response, this.handler);
-
-		replay(this.interceptor1, this.interceptor2, this.interceptor3);
+		given(this.interceptor1.preHandle(this.request, this.response, this.handler)).willReturn(true);
+		given(this.interceptor2.preHandle(this.request, this.response, this.handler)).willReturn(true);
+		given(this.interceptor3.preHandle(this.request, this.response, this.handler)).willReturn(true);
 
 		this.chain.applyPreHandle(request, response);
 		this.chain.applyAfterConcurrentHandlingStarted(request, response);
 		this.chain.triggerAfterCompletion(this.request, this.response, null);
 
-		verify(this.interceptor1, this.interceptor2, this.interceptor3);
+		verify(this.interceptor1).afterConcurrentHandlingStarted(request, response, this.handler);
+		verify(this.interceptor2).afterConcurrentHandlingStarted(request, response, this.handler);
+		verify(this.interceptor3).afterConcurrentHandlingStarted(request, response, this.handler);
 	}
 
 	@Test
 	public void earlyExitInPreHandle() throws Exception {
-		expect(this.interceptor1.preHandle(this.request, this.response, this.handler)).andReturn(true);
-		expect(this.interceptor2.preHandle(this.request, this.response, this.handler)).andReturn(false);
-
-		this.interceptor1.afterCompletion(this.request, this.response, this.handler, null);
-
-		replay(this.interceptor1, this.interceptor2, this.interceptor3);
+		given(this.interceptor1.preHandle(this.request, this.response, this.handler)).willReturn(true);
+		given(this.interceptor2.preHandle(this.request, this.response, this.handler)).willReturn(false);
 
 		this.chain.applyPreHandle(request, response);
 
-		verify(this.interceptor1, this.interceptor2, this.interceptor3);
+		verify(this.interceptor1).afterCompletion(this.request, this.response, this.handler, null);
 	}
 
 	@Test
 	public void exceptionBeforePreHandle() throws Exception {
-		replay(this.interceptor1, this.interceptor2, this.interceptor3);
-
 		this.chain.triggerAfterCompletion(this.request, this.response, null);
-
-		verify(this.interceptor1, this.interceptor2, this.interceptor3);
+		verifyZeroInteractions(this.interceptor1, this.interceptor2, this.interceptor3);
 	}
 
 	@Test
 	public void exceptionDuringPreHandle() throws Exception {
 		Exception ex = new Exception("");
 
-		expect(this.interceptor1.preHandle(this.request, this.response, this.handler)).andReturn(true);
-		expect(this.interceptor2.preHandle(this.request, this.response, this.handler)).andThrow(ex);
-
-		this.interceptor1.afterCompletion(this.request, this.response, this.handler, ex);
-
-		replay(this.interceptor1, this.interceptor2, this.interceptor3);
+		given(this.interceptor1.preHandle(this.request, this.response, this.handler)).willReturn(true);
+		given(this.interceptor2.preHandle(this.request, this.response, this.handler)).willThrow(ex);
 
 		try {
 			this.chain.applyPreHandle(request, response);
@@ -151,27 +129,24 @@ public void exceptionDuringPreHandle() throws Exception {
 		}
 		this.chain.triggerAfterCompletion(this.request, this.response, ex);
 
-		verify(this.interceptor1, this.interceptor2, this.interceptor3);
+		verify(this.interceptor1).afterCompletion(this.request, this.response, this.handler, ex);
+		verify(this.interceptor3, never()).preHandle(this.request, this.response, this.handler);
 	}
 
 	@Test
 	public void exceptionAfterPreHandle() throws Exception {
 		Exception ex = new Exception("");
 
-		expect(this.interceptor1.preHandle(this.request, this.response, this.handler)).andReturn(true);
-		expect(this.interceptor2.preHandle(this.request, this.response, this.handler)).andReturn(true);
-		expect(this.interceptor3.preHandle(this.request, this.response, this.handler)).andReturn(true);
-
-		this.interceptor3.afterCompletion(this.request, this.response, this.handler, ex);
-		this.interceptor2.afterCompletion(this.request, this.response, this.handler, ex);
-		this.interceptor1.afterCompletion(this.request, this.response, this.handler, ex);
-
-		replay(this.interceptor1, this.interceptor2, this.interceptor3);
+		given(this.interceptor1.preHandle(this.request, this.response, this.handler)).willReturn(true);
+		given(this.interceptor2.preHandle(this.request, this.response, this.handler)).willReturn(true);
+		given(this.interceptor3.preHandle(this.request, this.response, this.handler)).willReturn(true);
 
 		this.chain.applyPreHandle(request, response);
 		this.chain.triggerAfterCompletion(this.request, this.response, ex);
 
-		verify(this.interceptor1, this.interceptor2, this.interceptor3);
+		verify(this.interceptor3).afterCompletion(this.request, this.response, this.handler, ex);
+		verify(this.interceptor2).afterCompletion(this.request, this.response, this.handler, ex);
+		verify(this.interceptor1).afterCompletion(this.request, this.response, this.handler, ex);
 	}
 
 }
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/config/annotation/DelegatingWebMvcConfigurationTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/config/annotation/DelegatingWebMvcConfigurationTests.java
index 7153c901f93f..392cb9b9799d 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/config/annotation/DelegatingWebMvcConfigurationTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/config/annotation/DelegatingWebMvcConfigurationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,23 +16,17 @@
 
 package org.springframework.web.servlet.config.annotation;
 
-import static org.easymock.EasyMock.capture;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import org.easymock.Capture;
-import org.easymock.EasyMock;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Captor;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.springframework.core.convert.ConversionService;
 import org.springframework.format.support.FormattingConversionService;
 import org.springframework.http.converter.HttpMessageConverter;
 import org.springframework.http.converter.StringHttpMessageConverter;
@@ -48,6 +42,9 @@
 import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
 import org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * A test fixture for {@link DelegatingWebMvcConfiguration} tests.
  *
@@ -57,46 +54,59 @@ public class DelegatingWebMvcConfigurationTests {
 
 	private DelegatingWebMvcConfiguration delegatingConfig;
 
+	@Mock
 	private WebMvcConfigurer webMvcConfigurer;
 
+	@Captor
+	private ArgumentCaptor<List<HttpMessageConverter<?>>> converters;
+
+	@Captor
+	private ArgumentCaptor<ContentNegotiationConfigurer> contentNegotiationConfigurer;
+
+	@Captor
+	private ArgumentCaptor<FormattingConversionService> conversionService;
+
+	@Captor
+	private ArgumentCaptor<List<HandlerMethodArgumentResolver>> resolvers;
+
+	@Captor
+	private ArgumentCaptor<List<HandlerMethodReturnValueHandler>> handlers;
+
+	@Captor
+	private ArgumentCaptor<AsyncSupportConfigurer> asyncConfigurer;
+
+	@Captor
+	private ArgumentCaptor<List<HandlerExceptionResolver>> exceptionResolvers;
+
+
 	@Before
 	public void setUp() {
-		webMvcConfigurer = EasyMock.createMock(WebMvcConfigurer.class);
+		MockitoAnnotations.initMocks(this);
 		delegatingConfig = new DelegatingWebMvcConfiguration();
 	}
 
 	@Test
 	public void requestMappingHandlerAdapter() throws Exception {
-		Capture<List<HttpMessageConverter<?>>> converters = new Capture<List<HttpMessageConverter<?>>>();
-		Capture<ContentNegotiationConfigurer> contentNegotiationConfigurer = new Capture<ContentNegotiationConfigurer>();
-		Capture<FormattingConversionService> conversionService = new Capture<FormattingConversionService>();
-		Capture<List<HandlerMethodArgumentResolver>> resolvers = new Capture<List<HandlerMethodArgumentResolver>>();
-		Capture<List<HandlerMethodReturnValueHandler>> handlers = new Capture<List<HandlerMethodReturnValueHandler>>();
-		Capture<AsyncSupportConfigurer> asyncConfigurer = new Capture<AsyncSupportConfigurer>();
-
-		webMvcConfigurer.configureMessageConverters(capture(converters));
-		webMvcConfigurer.configureContentNegotiation(capture(contentNegotiationConfigurer));
-		expect(webMvcConfigurer.getValidator()).andReturn(null);
-		expect(webMvcConfigurer.getMessageCodesResolver()).andReturn(null);
-		webMvcConfigurer.addFormatters(capture(conversionService));
-		webMvcConfigurer.addArgumentResolvers(capture(resolvers));
-		webMvcConfigurer.addReturnValueHandlers(capture(handlers));
-		webMvcConfigurer.configureAsyncSupport(capture(asyncConfigurer));
-		replay(webMvcConfigurer);
 
 		delegatingConfig.setConfigurers(Arrays.asList(webMvcConfigurer));
 		RequestMappingHandlerAdapter adapter = delegatingConfig.requestMappingHandlerAdapter();
 
 		ConfigurableWebBindingInitializer initializer = (ConfigurableWebBindingInitializer) adapter.getWebBindingInitializer();
-		assertSame(conversionService.getValue(), initializer.getConversionService());
+		ConversionService initializerConversionService = initializer.getConversionService();
 		assertTrue(initializer.getValidator() instanceof LocalValidatorFactoryBean);
 
+		verify(webMvcConfigurer).configureMessageConverters(converters.capture());
+		verify(webMvcConfigurer).configureContentNegotiation(contentNegotiationConfigurer.capture());
+		verify(webMvcConfigurer).addFormatters(conversionService.capture());
+		verify(webMvcConfigurer).addArgumentResolvers(resolvers.capture());
+		verify(webMvcConfigurer).addReturnValueHandlers(handlers.capture());
+		verify(webMvcConfigurer).configureAsyncSupport(asyncConfigurer.capture());
+
+		assertSame(conversionService.getValue(), initializerConversionService);
 		assertEquals(0, resolvers.getValue().size());
 		assertEquals(0, handlers.getValue().size());
 		assertEquals(converters.getValue(), adapter.getMessageConverters());
 		assertNotNull(asyncConfigurer);
-
-		verify(webMvcConfigurer);
 	}
 
 	@Test
@@ -117,47 +127,39 @@ public void configureMessageConverters(List<HttpMessageConverter<?>> converters)
 
 	@Test
 	public void getCustomValidator() {
-		expect(webMvcConfigurer.getValidator()).andReturn(new LocalValidatorFactoryBean());
-		replay(webMvcConfigurer);
+		given(webMvcConfigurer.getValidator()).willReturn(new LocalValidatorFactoryBean());
 
 		delegatingConfig.setConfigurers(Arrays.asList(webMvcConfigurer));
 		delegatingConfig.mvcValidator();
 
-		verify(webMvcConfigurer);
+		verify(webMvcConfigurer).getValidator();
 	}
 
 	@Test
 	public void getCustomMessageCodesResolver() {
-		expect(webMvcConfigurer.getMessageCodesResolver()).andReturn(new DefaultMessageCodesResolver());
-		replay(webMvcConfigurer);
+		given(webMvcConfigurer.getMessageCodesResolver()).willReturn(new DefaultMessageCodesResolver());
 
 		delegatingConfig.setConfigurers(Arrays.asList(webMvcConfigurer));
 		delegatingConfig.getMessageCodesResolver();
 
-		verify(webMvcConfigurer);
+		verify(webMvcConfigurer).getMessageCodesResolver();
 	}
 
 	@Test
 	public void handlerExceptionResolver() throws Exception {
-		Capture<List<HttpMessageConverter<?>>> converters = new Capture<List<HttpMessageConverter<?>>>();
-		Capture<List<HandlerExceptionResolver>> exceptionResolvers = new Capture<List<HandlerExceptionResolver>>();
-		Capture<ContentNegotiationConfigurer> contentNegotiationConfigurer = new Capture<ContentNegotiationConfigurer>();
-
-		webMvcConfigurer.configureMessageConverters(capture(converters));
-		webMvcConfigurer.configureContentNegotiation(capture(contentNegotiationConfigurer));
-		webMvcConfigurer.configureHandlerExceptionResolvers(capture(exceptionResolvers));
-		replay(webMvcConfigurer);
 
 		delegatingConfig.setConfigurers(Arrays.asList(webMvcConfigurer));
 		delegatingConfig.handlerExceptionResolver();
 
+		verify(webMvcConfigurer).configureMessageConverters(converters.capture());
+		verify(webMvcConfigurer).configureContentNegotiation(contentNegotiationConfigurer.capture());
+		verify(webMvcConfigurer).configureHandlerExceptionResolvers(exceptionResolvers.capture());
+
 		assertEquals(3, exceptionResolvers.getValue().size());
 		assertTrue(exceptionResolvers.getValue().get(0) instanceof ExceptionHandlerExceptionResolver);
 		assertTrue(exceptionResolvers.getValue().get(1) instanceof ResponseStatusExceptionResolver);
 		assertTrue(exceptionResolvers.getValue().get(2) instanceof DefaultHandlerExceptionResolver);
 		assertTrue(converters.getValue().size() > 0);
-
-		verify(webMvcConfigurer);
 	}
 
 	@Test
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/ControllerTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/ControllerTests.java
index 208225c4333b..b7628eb630e1 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/ControllerTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/ControllerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,7 +28,6 @@
 import javax.servlet.http.HttpServletResponse;
 
 import junit.framework.TestCase;
-import org.easymock.MockControl;
 
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockHttpServletResponse;
@@ -36,6 +35,8 @@
 import org.springframework.web.servlet.ModelAndView;
 import org.springframework.web.util.WebUtils;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
@@ -74,43 +75,31 @@ public void testServletForwardingControllerWithBeanName() throws Exception {
 	private void doTestServletForwardingController(ServletForwardingController sfc, boolean include)
 			throws Exception {
 
-		MockControl requestControl = MockControl.createControl(HttpServletRequest.class);
-		HttpServletRequest request = (HttpServletRequest) requestControl.getMock();
-		MockControl responseControl = MockControl.createControl(HttpServletResponse.class);
-		HttpServletResponse response = (HttpServletResponse) responseControl.getMock();
-		MockControl contextControl = MockControl.createControl(ServletContext.class);
-		ServletContext context = (ServletContext) contextControl.getMock();
-		MockControl dispatcherControl = MockControl.createControl(RequestDispatcher.class);
-		RequestDispatcher dispatcher = (RequestDispatcher) dispatcherControl.getMock();
-
-		request.getMethod();
-		requestControl.setReturnValue("GET", 1);
-		context.getNamedDispatcher("action");
-		contextControl.setReturnValue(dispatcher, 1);
+		HttpServletRequest request = mock(HttpServletRequest.class);
+		HttpServletResponse response = mock(HttpServletResponse.class);
+		ServletContext context = mock(ServletContext.class);
+		RequestDispatcher dispatcher = mock(RequestDispatcher.class);
+
+		given(request.getMethod()).willReturn("GET");
+		given(context.getNamedDispatcher("action")).willReturn(dispatcher);
 		if (include) {
-			request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);
-			requestControl.setReturnValue("somePath", 1);
-			dispatcher.include(request, response);
-			dispatcherControl.setVoidCallable(1);
+			given(request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE)).willReturn("somePath");
 		}
 		else {
-			request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);
-			requestControl.setReturnValue(null, 1);
-			dispatcher.forward(request, response);
-			dispatcherControl.setVoidCallable(1);
+			given(request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE)).willReturn(null);
 		}
-		requestControl.replay();
-		contextControl.replay();
-		dispatcherControl.replay();
 
 		StaticWebApplicationContext sac = new StaticWebApplicationContext();
 		sac.setServletContext(context);
 		sfc.setApplicationContext(sac);
 		assertNull(sfc.handleRequest(request, response));
 
-		requestControl.verify();
-		contextControl.verify();
-		dispatcherControl.verify();
+		if (include) {
+			verify(dispatcher).include(request, response);
+		}
+		else {
+			verify(dispatcher).forward(request, response);
+		}
 	}
 
 	public void testServletWrappingController() throws Exception {
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ResponseStatusExceptionResolverTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ResponseStatusExceptionResolverTests.java
index 25348f53f7af..4731ce6fedd4 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ResponseStatusExceptionResolverTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ResponseStatusExceptionResolverTests.java
@@ -63,7 +63,7 @@ public void statusCodeAndReasonMessage() {
 			exceptionResolver.setMessageSource(messageSource);
 
 			StatusCodeAndReasonMessageException ex = new StatusCodeAndReasonMessageException();
-			ModelAndView mav = exceptionResolver.resolveException(request, response, null, ex);
+			exceptionResolver.resolveException(request, response, null, ex);
 			assertEquals("Invalid status reason", "Gone reason message", response.getErrorMessage());
 		}
 		finally {
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ServletAnnotationControllerTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ServletAnnotationControllerTests.java
index bbfa7e29902e..722099df3e2d 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ServletAnnotationControllerTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/annotation/ServletAnnotationControllerTests.java
@@ -16,6 +16,16 @@
 
 package org.springframework.web.servlet.mvc.annotation;
 
+import static org.hamcrest.Matchers.instanceOf;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.beans.PropertyEditorSupport;
 import java.io.IOException;
 import java.io.Serializable;
@@ -43,6 +53,7 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
+
 import javax.servlet.ServletConfig;
 import javax.servlet.ServletContext;
 import javax.servlet.ServletException;
@@ -54,17 +65,12 @@
 import javax.xml.bind.annotation.XmlRootElement;
 
 import org.junit.Test;
-
 import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
 import org.springframework.aop.interceptor.SimpleTraceInterceptor;
 import org.springframework.aop.support.DefaultPointcutAdvisor;
 import org.springframework.beans.BeansException;
-import org.springframework.tests.sample.beans.DerivedTestBean;
-import org.springframework.tests.sample.beans.GenericBean;
-import org.springframework.tests.sample.beans.ITestBean;
 import org.springframework.beans.PropertyEditorRegistrar;
 import org.springframework.beans.PropertyEditorRegistry;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.beans.factory.BeanCreationException;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.beans.factory.annotation.Value;
@@ -96,6 +102,10 @@
 import org.springframework.mock.web.test.MockServletContext;
 import org.springframework.oxm.jaxb.Jaxb2Marshaller;
 import org.springframework.stereotype.Controller;
+import org.springframework.tests.sample.beans.DerivedTestBean;
+import org.springframework.tests.sample.beans.GenericBean;
+import org.springframework.tests.sample.beans.ITestBean;
+import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.ui.ExtendedModelMap;
 import org.springframework.ui.Model;
 import org.springframework.ui.ModelMap;
@@ -140,8 +150,6 @@
 import org.springframework.web.servlet.view.InternalResourceViewResolver;
 import org.springframework.web.util.NestedServletException;
 
-import static org.junit.Assert.*;
-
 /**
  * @author Juergen Hoeller
  * @author Sam Brannen
@@ -3291,7 +3299,7 @@ public void processCsv(@RequestParam("content") Integer[] content, HttpServletRe
 
 		@RequestMapping("/integerSet")
 		public void processCsv(@RequestParam("content") Set<Integer> content, HttpServletResponse response) throws IOException {
-			assertTrue(content.iterator().next() instanceof Integer);
+			assertThat(content.iterator().next(), instanceOf(Integer.class));
 			response.getWriter().write(StringUtils.collectionToDelimitedString(content, "-"));
 		}
 	}
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/condition/PatternsRequestConditionTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/condition/PatternsRequestConditionTests.java
index 9c38b7c39c49..72f6639713f4 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/condition/PatternsRequestConditionTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/condition/PatternsRequestConditionTests.java
@@ -27,6 +27,7 @@
 
 import org.junit.Test;
 import org.springframework.mock.web.test.MockHttpServletRequest;
+import org.springframework.web.util.UrlPathHelper;
 
 /**
  * @author Rossen Stoyanchev
@@ -185,6 +186,16 @@ public void matchPatternContainsExtension() {
 		assertNull(match);
 	}
 
+	@Test
+	public void matchIgnorePathParams() {
+		UrlPathHelper pathHelper = new UrlPathHelper();
+		pathHelper.setRemoveSemicolonContent(false);
+		PatternsRequestCondition condition = new PatternsRequestCondition(new String[] {"/foo/bar"}, pathHelper, null, true, true);
+		PatternsRequestCondition match = condition.getMatchingCondition(new MockHttpServletRequest("GET", "/foo;q=1/bar;s=1"));
+
+		assertNotNull(match);
+	}
+
 	@Test
 	public void compareEqualPatterns() {
 		PatternsRequestCondition c1 = new PatternsRequestCondition("/foo*");
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMappingTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMappingTests.java
index 2db8412a827f..099197c07dea 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMappingTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMappingTests.java
@@ -90,7 +90,6 @@ public void setUp() throws Exception {
 
 		this.handlerMapping = new TestRequestMappingInfoHandlerMapping();
 		this.handlerMapping.registerHandler(testController);
-		this.handlerMapping.setRemoveSemicolonContent(false);
 	}
 
 	@Test
@@ -181,6 +180,19 @@ private void testMediaTypeNotSupported(String url) throws Exception {
 		}
 	}
 
+	@Test
+	public void testMediaTypeNotValue() throws Exception {
+		try {
+			MockHttpServletRequest request = new MockHttpServletRequest("PUT", "/person/1");
+			request.setContentType("bogus");
+			this.handlerMapping.getHandler(request);
+			fail("HttpMediaTypeNotSupportedException expected");
+		}
+		catch (HttpMediaTypeNotSupportedException ex) {
+			assertEquals("Invalid media type \"bogus\": does not contain '/'", ex.getMessage());
+		}
+	}
+
 	@Test
 	public void mediaTypeNotAccepted() throws Exception {
 		testMediaTypeNotAccepted("/persons");
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessorMockTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessorMockTests.java
index fde7ae794657..42aa80abf37c 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessorMockTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/HttpEntityMethodProcessorMockTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,27 +15,14 @@
  */
 
 package org.springframework.web.servlet.mvc.method.annotation;
-import static org.easymock.EasyMock.capture;
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.isA;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.reset;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.springframework.web.servlet.HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE;
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.Collections;
 
-import org.easymock.Capture;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.ArgumentCaptor;
 import org.springframework.core.MethodParameter;
 import org.springframework.http.HttpEntity;
 import org.springframework.http.HttpHeaders;
@@ -52,7 +39,12 @@
 import org.springframework.web.bind.annotation.RequestMapping;
 import org.springframework.web.context.request.ServletWebRequest;
 import org.springframework.web.method.support.ModelAndViewContainer;
-import org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor;
+
+import static org.mockito.Mockito.*;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+import static org.springframework.web.servlet.HandlerMapping.*;
 
 /**
  * Test fixture for {@link HttpEntityMethodProcessor} delegating to a mock
@@ -88,9 +80,8 @@ public class HttpEntityMethodProcessorMockTests {
 	@SuppressWarnings("unchecked")
 	@Before
 	public void setUp() throws Exception {
-		messageConverter = createMock(HttpMessageConverter.class);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		replay(messageConverter);
+		messageConverter = mock(HttpMessageConverter.class);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
 
 		processor = new HttpEntityMethodProcessor(Collections.<HttpMessageConverter<?>>singletonList(messageConverter));
 		reset(messageConverter);
@@ -135,16 +126,14 @@ public void resolveArgument() throws Exception {
 		servletRequest.addHeader("Content-Type", contentType.toString());
 
 		String body = "Foo";
-		expect(messageConverter.canRead(String.class, contentType)).andReturn(true);
-		expect(messageConverter.read(eq(String.class), isA(HttpInputMessage.class))).andReturn(body);
-		replay(messageConverter);
+		given(messageConverter.canRead(String.class, contentType)).willReturn(true);
+		given(messageConverter.read(eq(String.class), isA(HttpInputMessage.class))).willReturn(body);
 
 		Object result = processor.resolveArgument(paramHttpEntity, mavContainer, webRequest, null);
 
 		assertTrue(result instanceof HttpEntity);
 		assertFalse("The requestHandled flag shouldn't change", mavContainer.isRequestHandled());
 		assertEquals("Invalid argument", body, ((HttpEntity<?>) result).getBody());
-		verify(messageConverter);
 	}
 
 	@Test(expected = HttpMediaTypeNotSupportedException.class)
@@ -152,9 +141,8 @@ public void resolveArgumentNotReadable() throws Exception {
 		MediaType contentType = MediaType.TEXT_PLAIN;
 		servletRequest.addHeader("Content-Type", contentType.toString());
 
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Arrays.asList(contentType));
-		expect(messageConverter.canRead(String.class, contentType)).andReturn(false);
-		replay(messageConverter);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Arrays.asList(contentType));
+		given(messageConverter.canRead(String.class, contentType)).willReturn(false);
 
 		processor.resolveArgument(paramHttpEntity, mavContainer, webRequest, null);
 
@@ -175,16 +163,14 @@ public void handleReturnValue() throws Exception {
 		MediaType accepted = MediaType.TEXT_PLAIN;
 		servletRequest.addHeader("Accept", accepted.toString());
 
-		expect(messageConverter.canWrite(String.class, null)).andReturn(true);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		expect(messageConverter.canWrite(String.class, accepted)).andReturn(true);
-		messageConverter.write(eq(body), eq(accepted), isA(HttpOutputMessage.class));
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, null)).willReturn(true);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
+		given(messageConverter.canWrite(String.class, accepted)).willReturn(true);
 
 		processor.handleReturnValue(returnValue, returnTypeResponseEntity, mavContainer, webRequest);
 
 		assertTrue(mavContainer.isRequestHandled());
-		verify(messageConverter);
+		verify(messageConverter).write(eq(body), eq(accepted), isA(HttpOutputMessage.class));
 	}
 
 	@Test
@@ -195,14 +181,12 @@ public void handleReturnValueProduces() throws Exception {
 		servletRequest.addHeader("Accept", "text/*");
 		servletRequest.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, Collections.singleton(MediaType.TEXT_HTML));
 
-		expect(messageConverter.canWrite(String.class, MediaType.TEXT_HTML)).andReturn(true);
-		messageConverter.write(eq(body), eq(MediaType.TEXT_HTML), isA(HttpOutputMessage.class));
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, MediaType.TEXT_HTML)).willReturn(true);
 
 		processor.handleReturnValue(returnValue, returnTypeResponseEntityProduces, mavContainer, webRequest);
 
 		assertTrue(mavContainer.isRequestHandled());
-		verify(messageConverter);
+		verify(messageConverter).write(eq(body), eq(MediaType.TEXT_HTML), isA(HttpOutputMessage.class));
 	}
 
 	@Test(expected = HttpMediaTypeNotAcceptableException.class)
@@ -213,10 +197,9 @@ public void handleReturnValueNotAcceptable() throws Exception {
 		MediaType accepted = MediaType.APPLICATION_ATOM_XML;
 		servletRequest.addHeader("Accept", accepted.toString());
 
-		expect(messageConverter.canWrite(String.class, null)).andReturn(true);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Arrays.asList(MediaType.TEXT_PLAIN));
-		expect(messageConverter.canWrite(String.class, accepted)).andReturn(false);
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, null)).willReturn(true);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Arrays.asList(MediaType.TEXT_PLAIN));
+		given(messageConverter.canWrite(String.class, accepted)).willReturn(false);
 
 		processor.handleReturnValue(returnValue, returnTypeResponseEntity, mavContainer, webRequest);
 
@@ -231,10 +214,9 @@ public void handleReturnValueNotAcceptableProduces() throws Exception {
 		MediaType accepted = MediaType.TEXT_PLAIN;
 		servletRequest.addHeader("Accept", accepted.toString());
 
-		expect(messageConverter.canWrite(String.class, null)).andReturn(true);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		expect(messageConverter.canWrite(String.class, accepted)).andReturn(false);
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, null)).willReturn(true);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
+		given(messageConverter.canWrite(String.class, accepted)).willReturn(false);
 
 		processor.handleReturnValue(returnValue, returnTypeResponseEntityProduces, mavContainer, webRequest);
 
@@ -270,18 +252,16 @@ public void responseHeaderAndBody() throws Exception {
 		responseHeaders.set("header", "headerValue");
 		ResponseEntity<String> returnValue = new ResponseEntity<String>("body", responseHeaders, HttpStatus.ACCEPTED);
 
-		Capture<HttpOutputMessage> outputMessage = new Capture<HttpOutputMessage>();
-		expect(messageConverter.canWrite(String.class, null)).andReturn(true);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		expect(messageConverter.canWrite(String.class, MediaType.TEXT_PLAIN)).andReturn(true);
-		messageConverter.write(eq("body"), eq(MediaType.TEXT_PLAIN),  capture(outputMessage));
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, null)).willReturn(true);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
+		given(messageConverter.canWrite(String.class, MediaType.TEXT_PLAIN)).willReturn(true);
 
 		processor.handleReturnValue(returnValue, returnTypeResponseEntity, mavContainer, webRequest);
 
+		ArgumentCaptor<HttpOutputMessage> outputMessage = ArgumentCaptor.forClass(HttpOutputMessage.class);
+		verify(messageConverter).write(eq("body"), eq(MediaType.TEXT_PLAIN),  outputMessage.capture());
 		assertTrue(mavContainer.isRequestHandled());
 		assertEquals("headerValue", outputMessage.getValue().getHeaders().get("header").get(0));
-		verify(messageConverter);
 	}
 
 	public ResponseEntity<String> handle1(HttpEntity<String> httpEntity, ResponseEntity<String> responseEntity, int i) {
@@ -302,4 +282,4 @@ public ResponseEntity<String> handle4() {
 	}
 
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/RequestPartMethodArgumentResolverTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/RequestPartMethodArgumentResolverTests.java
index 5f9869e1dc8d..dd5a4570bdd9 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/RequestPartMethodArgumentResolverTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/RequestPartMethodArgumentResolverTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,20 +16,6 @@
 
 package org.springframework.web.servlet.mvc.method.annotation;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.isA;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.reset;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.util.Arrays;
@@ -52,19 +38,21 @@
 import org.springframework.mock.web.test.MockMultipartHttpServletRequest;
 import org.springframework.mock.web.test.MockPart;
 import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;
+import org.springframework.web.bind.MethodArgumentNotValidException;
 import org.springframework.web.bind.WebDataBinder;
 import org.springframework.web.bind.annotation.RequestParam;
 import org.springframework.web.bind.annotation.RequestPart;
 import org.springframework.web.bind.support.WebDataBinderFactory;
 import org.springframework.web.context.request.NativeWebRequest;
 import org.springframework.web.context.request.ServletWebRequest;
-import org.springframework.web.bind.MethodArgumentNotValidException;
 import org.springframework.web.method.support.ModelAndViewContainer;
 import org.springframework.web.multipart.MultipartException;
 import org.springframework.web.multipart.MultipartFile;
 import org.springframework.web.multipart.support.MissingServletRequestPartException;
 import org.springframework.web.multipart.support.RequestPartServletServerHttpRequest;
-import org.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
 
 /**
  * Test fixture with {@link RequestPartMethodArgumentResolver} and mock {@link HttpMessageConverter}.
@@ -116,9 +104,8 @@ public void setUp() throws Exception {
 		paramServlet30Part.initParameterNameDiscovery(new LocalVariableTableParameterNameDiscoverer());
 		paramRequestParamAnnot = new MethodParameter(method, 8);
 
-		messageConverter = createMock(HttpMessageConverter.class);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		replay(messageConverter);
+		messageConverter = mock(HttpMessageConverter.class);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
 
 		resolver = new RequestPartMethodArgumentResolver(Collections.<HttpMessageConverter<?>>singletonList(messageConverter));
 		reset(messageConverter);
@@ -246,17 +233,14 @@ public void isMultipartRequestPut() throws Exception {
 	private void testResolveArgument(SimpleBean argValue, MethodParameter parameter) throws IOException, Exception {
 		MediaType contentType = MediaType.TEXT_PLAIN;
 
-		expect(messageConverter.canRead(SimpleBean.class, contentType)).andReturn(true);
-		expect(messageConverter.read(eq(SimpleBean.class), isA(RequestPartServletServerHttpRequest.class))).andReturn(argValue);
-		replay(messageConverter);
+		given(messageConverter.canRead(SimpleBean.class, contentType)).willReturn(true);
+		given(messageConverter.read(eq(SimpleBean.class), isA(RequestPartServletServerHttpRequest.class))).willReturn(argValue);
 
 		ModelAndViewContainer mavContainer = new ModelAndViewContainer();
 		Object actualValue = resolver.resolveArgument(parameter, mavContainer, webRequest, new ValidatingBinderFactory());
 
 		assertEquals("Invalid argument value", argValue, actualValue);
 		assertFalse("The requestHandled flag shouldn't change", mavContainer.isRequestHandled());
-
-		verify(messageConverter);
 	}
 
 	private static class SimpleBean {
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessorMockTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessorMockTests.java
index 315040419e99..5eb6d49f42ca 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessorMockTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/method/annotation/RequestResponseBodyMethodProcessorMockTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,20 +16,6 @@
 
 package org.springframework.web.servlet.mvc.method.annotation;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.eq;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.isA;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.reset;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.util.Arrays;
@@ -61,6 +47,9 @@
 import org.springframework.web.method.support.ModelAndViewContainer;
 import org.springframework.web.servlet.HandlerMapping;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Test fixture for {@link RequestResponseBodyMethodProcessor} delegating to a
  * mock HttpMessageConverter.
@@ -95,12 +84,10 @@ public class RequestResponseBodyMethodProcessorMockTests {
 	@SuppressWarnings("unchecked")
 	@Before
 	public void setUp() throws Exception {
-		messageConverter = createMock(HttpMessageConverter.class);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		replay(messageConverter);
+		messageConverter = mock(HttpMessageConverter.class);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
 
 		processor = new RequestResponseBodyMethodProcessor(Collections.<HttpMessageConverter<?>>singletonList(messageConverter));
-		reset(messageConverter);
 
 		Method methodHandle1 = getClass().getMethod("handle1", String.class, Integer.TYPE);
 		paramRequestBodyString = new MethodParameter(methodHandle1, 0);
@@ -138,15 +125,13 @@ public void resolveArgument() throws Exception {
 		String body = "Foo";
 		servletRequest.setContent(body.getBytes());
 
-		expect(messageConverter.canRead(String.class, contentType)).andReturn(true);
-		expect(messageConverter.read(eq(String.class), isA(HttpInputMessage.class))).andReturn(body);
-		replay(messageConverter);
+		given(messageConverter.canRead(String.class, contentType)).willReturn(true);
+		given(messageConverter.read(eq(String.class), isA(HttpInputMessage.class))).willReturn(body);
 
 		Object result = processor.resolveArgument(paramRequestBodyString, mavContainer, webRequest, new ValidatingBinderFactory());
 
 		assertEquals("Invalid argument", body, result);
 		assertFalse("The requestHandled flag shouldn't change", mavContainer.isRequestHandled());
-		verify(messageConverter);
 	}
 
 	@Test
@@ -172,16 +157,13 @@ private void testResolveArgumentWithValidation(SimpleBean simpleBean) throws IOE
 		servletRequest.setContent(new byte[] {});
 
 		@SuppressWarnings("unchecked")
-		HttpMessageConverter<SimpleBean> beanConverter = createMock(HttpMessageConverter.class);
-		expect(beanConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		expect(beanConverter.canRead(SimpleBean.class, contentType)).andReturn(true);
-		expect(beanConverter.read(eq(SimpleBean.class), isA(HttpInputMessage.class))).andReturn(simpleBean);
-		replay(beanConverter);
+		HttpMessageConverter<SimpleBean> beanConverter = mock(HttpMessageConverter.class);
+		given(beanConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
+		given(beanConverter.canRead(SimpleBean.class, contentType)).willReturn(true);
+		given(beanConverter.read(eq(SimpleBean.class), isA(HttpInputMessage.class))).willReturn(simpleBean);
 
 		processor = new RequestResponseBodyMethodProcessor(Collections.<HttpMessageConverter<?>>singletonList(beanConverter));
 		processor.resolveArgument(paramValidBean, mavContainer, webRequest, new ValidatingBinderFactory());
-
-		verify(beanConverter);
 	}
 
 	@Test(expected = HttpMediaTypeNotSupportedException.class)
@@ -189,23 +171,20 @@ public void resolveArgumentCannotRead() throws Exception {
 		MediaType contentType = MediaType.TEXT_PLAIN;
 		servletRequest.addHeader("Content-Type", contentType.toString());
 
-		expect(messageConverter.canRead(String.class, contentType)).andReturn(false);
-		replay(messageConverter);
+		given(messageConverter.canRead(String.class, contentType)).willReturn(false);
 
 		processor.resolveArgument(paramRequestBodyString, mavContainer, webRequest, null);
 	}
 
 	@Test
 	public void resolveArgumentNoContentType() throws Exception {
-		expect(messageConverter.canRead(String.class, MediaType.APPLICATION_OCTET_STREAM)).andReturn(false);
-		replay(messageConverter);
+		given(messageConverter.canRead(String.class, MediaType.APPLICATION_OCTET_STREAM)).willReturn(false);
 		try {
 			processor.resolveArgument(paramRequestBodyString, mavContainer, webRequest, null);
 			fail("Expected exception");
 		}
 		catch (HttpMediaTypeNotSupportedException ex) {
 		}
-		verify(messageConverter);
 	}
 
 	@Test
@@ -223,16 +202,14 @@ public void handleReturnValue() throws Exception {
 		servletRequest.addHeader("Accept", accepted.toString());
 
 		String body = "Foo";
-		expect(messageConverter.canWrite(String.class, null)).andReturn(true);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		expect(messageConverter.canWrite(String.class, accepted)).andReturn(true);
-		messageConverter.write(eq(body), eq(accepted), isA(HttpOutputMessage.class));
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, null)).willReturn(true);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
+		given(messageConverter.canWrite(String.class, accepted)).willReturn(true);
 
 		processor.handleReturnValue(body, returnTypeString, mavContainer, webRequest);
 
 		assertTrue("The requestHandled flag wasn't set", mavContainer.isRequestHandled());
-		verify(messageConverter);
+		verify(messageConverter).write(eq(body), eq(accepted), isA(HttpOutputMessage.class));
 	}
 
 	@Test
@@ -242,14 +219,12 @@ public void handleReturnValueProduces() throws Exception {
 		servletRequest.addHeader("Accept", "text/*");
 		servletRequest.setAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, Collections.singleton(MediaType.TEXT_HTML));
 
-		expect(messageConverter.canWrite(String.class, MediaType.TEXT_HTML)).andReturn(true);
-		messageConverter.write(eq(body), eq(MediaType.TEXT_HTML), isA(HttpOutputMessage.class));
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, MediaType.TEXT_HTML)).willReturn(true);
 
 		processor.handleReturnValue(body, returnTypeStringProduces, mavContainer, webRequest);
 
 		assertTrue(mavContainer.isRequestHandled());
-		verify(messageConverter);
+		verify(messageConverter).write(eq(body), eq(MediaType.TEXT_HTML), isA(HttpOutputMessage.class));
 	}
 
 
@@ -258,10 +233,9 @@ public void handleReturnValueNotAcceptable() throws Exception {
 		MediaType accepted = MediaType.APPLICATION_ATOM_XML;
 		servletRequest.addHeader("Accept", accepted.toString());
 
-		expect(messageConverter.canWrite(String.class, null)).andReturn(true);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Arrays.asList(MediaType.TEXT_PLAIN));
-		expect(messageConverter.canWrite(String.class, accepted)).andReturn(false);
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, null)).willReturn(true);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Arrays.asList(MediaType.TEXT_PLAIN));
+		given(messageConverter.canWrite(String.class, accepted)).willReturn(false);
 
 		processor.handleReturnValue("Foo", returnTypeString, mavContainer, webRequest);
 	}
@@ -271,10 +245,9 @@ public void handleReturnValueNotAcceptableProduces() throws Exception {
 		MediaType accepted = MediaType.TEXT_PLAIN;
 		servletRequest.addHeader("Accept", accepted.toString());
 
-		expect(messageConverter.canWrite(String.class, null)).andReturn(true);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
-		expect(messageConverter.canWrite(String.class, accepted)).andReturn(false);
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, null)).willReturn(true);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(Collections.singletonList(MediaType.TEXT_PLAIN));
+		given(messageConverter.canWrite(String.class, accepted)).willReturn(false);
 
 		processor.handleReturnValue("Foo", returnTypeStringProduces, mavContainer, webRequest);
 	}
@@ -289,16 +262,14 @@ public void handleReturnValueMediaTypeSuffix() throws Exception {
 
 		servletRequest.addHeader("Accept", accepted);
 
-		expect(messageConverter.canWrite(String.class, null)).andReturn(true);
-		expect(messageConverter.getSupportedMediaTypes()).andReturn(supported);
-		expect(messageConverter.canWrite(String.class, accepted)).andReturn(true);
-		messageConverter.write(eq(body), eq(accepted), isA(HttpOutputMessage.class));
-		replay(messageConverter);
+		given(messageConverter.canWrite(String.class, null)).willReturn(true);
+		given(messageConverter.getSupportedMediaTypes()).willReturn(supported);
+		given(messageConverter.canWrite(String.class, accepted)).willReturn(true);
 
 		processor.handleReturnValue(body, returnTypeStringProduces, mavContainer, webRequest);
 
 		assertTrue(mavContainer.isRequestHandled());
-		verify(messageConverter);
+		verify(messageConverter).write(eq(body), eq(accepted), isA(HttpOutputMessage.class));
 	}
 
 
@@ -348,4 +319,4 @@ public String getName() {
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/multiaction/MultiActionControllerTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/multiaction/MultiActionControllerTests.java
index 64de09b05afd..de40940d0d2a 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/multiaction/MultiActionControllerTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/mvc/multiaction/MultiActionControllerTests.java
@@ -453,7 +453,7 @@ public void testCannotCallExceptionHandlerDirectly() throws Exception {
 
 		MockHttpServletRequest request = new MockHttpServletRequest("GET", "/handleIllegalStateException.html");
 		MockHttpServletResponse response = new MockHttpServletResponse();
-		ModelAndView mav = mac.handleRequest(request, response);
+		mac.handleRequest(request, response);
 		assertEquals(HttpServletResponse.SC_NOT_FOUND, response.getStatus());
 	}
 
@@ -524,7 +524,6 @@ public ModelAndView commandNoSession(HttpServletRequest request, HttpServletResp
 			this.invoked.put("commandNoSession", Boolean.TRUE);
 
 			String pname = request.getParameter("name");
-			String page = request.getParameter("age");
 			// ALLOW FOR NULL
 			if (pname == null) {
 				assertTrue("name null", command.getName() == null);
@@ -532,6 +531,8 @@ public ModelAndView commandNoSession(HttpServletRequest request, HttpServletResp
 			else {
 				assertTrue("name param set", pname.equals(command.getName()));
 			}
+
+			//String page = request.getParameter("age");
 			// if (page == null)
 			// assertTrue("age default", command.getAge() == 0);
 			// else
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/UrlTagTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/UrlTagTests.java
index edabd11d4fb3..f66a8c2b507d 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/UrlTagTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/UrlTagTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,9 @@
 
 package org.springframework.web.servlet.tags;
 
+import static org.hamcrest.Matchers.instanceOf;
+import static org.junit.Assert.assertThat;
+
 import java.lang.reflect.Method;
 import java.util.HashSet;
 import java.util.LinkedList;
@@ -49,7 +52,7 @@ protected void setUp() throws Exception {
 	}
 
 	public void testParamSupport() {
-		assertTrue(tag instanceof ParamAware);
+		assertThat(tag, instanceOf(ParamAware.class));
 	}
 
 	public void testDoStartTag() throws JspException {
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/AbstractHtmlElementTagTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/AbstractHtmlElementTagTests.java
index a114680a9429..3f00bf145274 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/AbstractHtmlElementTagTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/AbstractHtmlElementTagTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,6 @@
 
 package org.springframework.web.servlet.tags.form;
 
-import static org.easymock.EasyMock.createMock;
-
 import java.io.StringWriter;
 import java.io.Writer;
 import java.util.HashMap;
@@ -32,14 +30,16 @@
 import org.springframework.validation.BindingResult;
 import org.springframework.validation.Errors;
 import org.springframework.web.context.support.StaticWebApplicationContext;
-import org.springframework.web.servlet.support.RequestDataValueProcessorWrapper;
 import org.springframework.web.servlet.support.JspAwareRequestContext;
 import org.springframework.web.servlet.support.RequestContext;
 import org.springframework.web.servlet.support.RequestContextUtils;
 import org.springframework.web.servlet.support.RequestDataValueProcessor;
+import org.springframework.web.servlet.support.RequestDataValueProcessorWrapper;
 import org.springframework.web.servlet.tags.AbstractTagTests;
 import org.springframework.web.servlet.tags.RequestContextAwareTag;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rob Harrop
  * @author Juergen Hoeller
@@ -102,7 +102,7 @@ protected final RequestContext getRequestContext() {
 	}
 
 	protected RequestDataValueProcessor getMockRequestDataValueProcessor() {
-		RequestDataValueProcessor mockProcessor = createMock(RequestDataValueProcessor.class);
+		RequestDataValueProcessor mockProcessor = mock(RequestDataValueProcessor.class);
 		ServletRequest request = getPageContext().getRequest();
 		StaticWebApplicationContext wac = (StaticWebApplicationContext) RequestContextUtils.getWebApplicationContext(request);
 		wac.getBean(RequestDataValueProcessorWrapper.class).setRequestDataValueProcessor(mockProcessor);
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java
index 3f4247033b52..a687e1efc9d9 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/tags/form/FormTagTests.java
@@ -16,10 +16,6 @@
 
 package org.springframework.web.servlet.tags.form;
 
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-
 import java.util.Collections;
 
 import javax.servlet.jsp.PageContext;
@@ -28,6 +24,8 @@
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.web.servlet.support.RequestDataValueProcessor;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rob Harrop
  * @author Rick Evans
@@ -328,9 +326,8 @@ public void testClearAttributesOnFinally() throws Exception {
 	public void testRequestDataValueProcessorHooks() throws Exception {
 		String action = "/my/form?foo=bar";
 		RequestDataValueProcessor processor = getMockRequestDataValueProcessor();
-		expect(processor.processAction(this.request, action)).andReturn(action);
-		expect(processor.getExtraHiddenFields(this.request)).andReturn(Collections.singletonMap("key", "value"));
-		replay(processor);
+		given(processor.processAction(this.request, action)).willReturn(action);
+		given(processor.getExtraHiddenFields(this.request)).willReturn(Collections.singletonMap("key", "value"));
 
 		this.tag.doStartTag();
 		this.tag.doEndTag();
@@ -341,8 +338,6 @@ public void testRequestDataValueProcessorHooks() throws Exception {
 		assertEquals("<input type=\"hidden\" name=\"key\" value=\"value\" />", getInputTag(output));
 		assertFormTagOpened(output);
 		assertFormTagClosed(output);
-
-		verify(processor);
 	}
 
 	private String getFormTag(String output) {
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/BaseViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/BaseViewTests.java
index 289fcbf064c1..ad0a6cdae6c1 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/BaseViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/BaseViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,11 +15,6 @@
  */
 
 package org.springframework.web.servlet.view;
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expectLastCall;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -40,6 +35,8 @@
 import org.springframework.web.context.WebApplicationContext;
 import org.springframework.web.servlet.View;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * Tests for AbstractView. Not called AbstractViewTests as
  * would otherwise be excluded by Ant build script wildcard.
@@ -49,11 +46,8 @@
 public class BaseViewTests extends TestCase {
 
 	public void testRenderWithoutStaticAttributes() throws Exception {
-
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
-		wac.getServletContext();
-		expectLastCall().andReturn(new MockServletContext());
-		replay(wac);
+		WebApplicationContext wac = mock(WebApplicationContext.class);
+		given(wac.getServletContext()).willReturn(new MockServletContext());
 
 		HttpServletRequest request = new MockHttpServletRequest();
 		HttpServletResponse response = new MockHttpServletResponse();
@@ -72,17 +66,14 @@ public void testRenderWithoutStaticAttributes() throws Exception {
 		checkContainsAll(model, tv.model);
 
 		assertTrue(tv.inited);
-		verify(wac);
 	}
 
 	/**
 	 * Test attribute passing, NOT CSV parsing.
 	 */
 	public void testRenderWithStaticAttributesNoCollision() throws Exception {
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
-		wac.getServletContext();
-		expectLastCall().andReturn(new MockServletContext());
-		replay(wac);
+		WebApplicationContext wac = mock(WebApplicationContext.class);
+		given(wac.getServletContext()).willReturn(new MockServletContext());
 
 		HttpServletRequest request = new MockHttpServletRequest();
 		HttpServletResponse response = new MockHttpServletResponse();
@@ -104,14 +95,11 @@ public void testRenderWithStaticAttributesNoCollision() throws Exception {
 		checkContainsAll(p, tv.model);
 
 		assertTrue(tv.inited);
-		verify(wac);
 	}
 
 	public void testPathVarsOverrideStaticAttributes() throws Exception {
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
-		wac.getServletContext();
-		expectLastCall().andReturn(new MockServletContext());
-		replay(wac);
+		WebApplicationContext wac = mock(WebApplicationContext.class);
+		given(wac.getServletContext()).willReturn(new MockServletContext());
 
 		HttpServletRequest request = new MockHttpServletRequest();
 		HttpServletResponse response = new MockHttpServletResponse();
@@ -138,14 +126,11 @@ public void testPathVarsOverrideStaticAttributes() throws Exception {
 		assertTrue(tv.model.get("something").equals("else"));
 
 		assertTrue(tv.inited);
-		verify(wac);
 	}
 
 	public void testDynamicModelOverridesStaticAttributesIfCollision() throws Exception {
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
-		wac.getServletContext();
-		expectLastCall().andReturn(new MockServletContext());
-		replay(wac);
+		WebApplicationContext wac = mock(WebApplicationContext.class);
+		given(wac.getServletContext()).willReturn(new MockServletContext());
 
 		HttpServletRequest request = new MockHttpServletRequest();
 		HttpServletResponse response = new MockHttpServletResponse();
@@ -169,14 +154,11 @@ public void testDynamicModelOverridesStaticAttributesIfCollision() throws Except
 		assertTrue(tv.model.get("something").equals("else"));
 
 		assertTrue(tv.inited);
-		verify(wac);
 	}
 
 	public void testDynamicModelOverridesPathVariables() throws Exception {
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
-		wac.getServletContext();
-		expectLastCall().andReturn(new MockServletContext());
-		replay(wac);
+		WebApplicationContext wac = mock(WebApplicationContext.class);
+		given(wac.getServletContext()).willReturn(new MockServletContext());
 
 		TestView tv = new TestView(wac);
 		tv.setApplicationContext(wac);
@@ -202,7 +184,6 @@ public void testDynamicModelOverridesPathVariables() throws Exception {
 		assertTrue(tv.model.get("something").equals("else"));
 
 		assertTrue(tv.inited);
-		verify(wac);
 	}
 
 	public void testIgnoresNullAttributes() {
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolverTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolverTests.java
index 0cb6e6f108a5..fafea1c9d128 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolverTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolverTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,6 @@
 
 package org.springframework.web.servlet.view;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -53,6 +44,9 @@
 import org.springframework.web.servlet.View;
 import org.springframework.web.servlet.ViewResolver;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Arjen Poutsma
  */
@@ -92,25 +86,21 @@ public void getMediaTypeAcceptHeaderWithProduces() throws Exception {
 	public void resolveViewNameWithPathExtension() throws Exception {
 		request.setRequestURI("/test.xls");
 
-		ViewResolver viewResolverMock = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Collections.singletonList(viewResolverMock));
 		viewResolver.afterPropertiesSet();
 
-		View viewMock = createMock("application_xls", View.class);
+		View viewMock = mock(View.class, "application_xls");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock.resolveViewName(viewName, locale)).andReturn(null);
-		expect(viewResolverMock.resolveViewName(viewName + ".xls", locale)).andReturn(viewMock);
-		expect(viewMock.getContentType()).andReturn("application/vnd.ms-excel").anyTimes();
-
-		replay(viewResolverMock, viewMock);
+		given(viewResolverMock.resolveViewName(viewName, locale)).willReturn(null);
+		given(viewResolverMock.resolveViewName(viewName + ".xls", locale)).willReturn(viewMock);
+		given(viewMock.getContentType()).willReturn("application/vnd.ms-excel");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", viewMock, result);
-
-		verify(viewResolverMock, viewMock);
 	}
 
 	@Test
@@ -123,23 +113,20 @@ public void resolveViewNameWithAcceptHeader() throws Exception {
 		manager.addFileExtensionResolvers(extensionsResolver);
 		viewResolver.setContentNegotiationManager(manager);
 
-		ViewResolver viewResolverMock = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Collections.singletonList(viewResolverMock));
 
-		View viewMock = createMock("application_xls", View.class);
+		View viewMock = mock(View.class, "application_xls");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock.resolveViewName(viewName, locale)).andReturn(null);
-		expect(viewResolverMock.resolveViewName(viewName + ".xls", locale)).andReturn(viewMock);
-		expect(viewMock.getContentType()).andReturn("application/vnd.ms-excel").anyTimes();
-
-		replay(viewResolverMock, viewMock);
+		given(viewResolverMock.resolveViewName(viewName, locale)).willReturn(null);
+		given(viewResolverMock.resolveViewName(viewName + ".xls", locale)).willReturn(viewMock);
+		given(viewMock.getContentType()).willReturn("application/vnd.ms-excel");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", viewMock, result);
-		verify(viewResolverMock, viewMock);
 	}
 
 	@Test
@@ -159,26 +146,21 @@ public void resolveViewNameWithRequestParameter() throws Exception {
 		ParameterContentNegotiationStrategy paramStrategy = new ParameterContentNegotiationStrategy(mapping);
 		viewResolver.setContentNegotiationManager(new ContentNegotiationManager(paramStrategy));
 
-		ViewResolver viewResolverMock = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Collections.singletonList(viewResolverMock));
-
 		viewResolver.afterPropertiesSet();
 
-		View viewMock = createMock("application_xls", View.class);
+		View viewMock = mock(View.class, "application_xls");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock.resolveViewName(viewName, locale)).andReturn(null);
-		expect(viewResolverMock.resolveViewName(viewName + ".xls", locale)).andReturn(viewMock);
-		expect(viewMock.getContentType()).andReturn("application/vnd.ms-excel").anyTimes();
-
-		replay(viewResolverMock, viewMock);
+		given(viewResolverMock.resolveViewName(viewName, locale)).willReturn(null);
+		given(viewResolverMock.resolveViewName(viewName + ".xls", locale)).willReturn(viewMock);
+		given(viewMock.getContentType()).willReturn("application/vnd.ms-excel");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", viewMock, result);
-
-		verify(viewResolverMock, viewMock);
 	}
 
 	@Test
@@ -189,58 +171,49 @@ public void resolveViewNameWithDefaultContentType() throws Exception {
 		FixedContentNegotiationStrategy fixedStrategy = new FixedContentNegotiationStrategy(mediaType);
 		viewResolver.setContentNegotiationManager(new ContentNegotiationManager(fixedStrategy));
 
-		ViewResolver viewResolverMock1 = createMock("viewResolver1", ViewResolver.class);
-		ViewResolver viewResolverMock2 = createMock("viewResolver2", ViewResolver.class);
+		ViewResolver viewResolverMock1 = mock(ViewResolver.class, "viewResolver1");
+		ViewResolver viewResolverMock2 = mock(ViewResolver.class, "viewResolver2");
 		viewResolver.setViewResolvers(Arrays.asList(viewResolverMock1, viewResolverMock2));
-
 		viewResolver.afterPropertiesSet();
 
-		View viewMock1 = createMock("application_xml", View.class);
-		View viewMock2 = createMock("text_html", View.class);
+		View viewMock1 = mock(View.class, "application_xml");
+		View viewMock2 = mock(View.class, "text_html");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock1.resolveViewName(viewName, locale)).andReturn(viewMock1);
-		expect(viewResolverMock2.resolveViewName(viewName, locale)).andReturn(viewMock2);
-		expect(viewMock1.getContentType()).andReturn("application/xml").anyTimes();
-		expect(viewMock2.getContentType()).andReturn("text/html;charset=ISO-8859-1").anyTimes();
-
-		replay(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2);
+		given(viewResolverMock1.resolveViewName(viewName, locale)).willReturn(viewMock1);
+		given(viewResolverMock2.resolveViewName(viewName, locale)).willReturn(viewMock2);
+		given(viewMock1.getContentType()).willReturn("application/xml");
+		given(viewMock2.getContentType()).willReturn("text/html;charset=ISO-8859-1");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", viewMock1, result);
-
-		verify(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2);
 	}
 
 	@Test
 	public void resolveViewNameAcceptHeader() throws Exception {
 		request.addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
 
-		ViewResolver viewResolverMock1 = createMock(ViewResolver.class);
-		ViewResolver viewResolverMock2 = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock1 = mock(ViewResolver.class);
+		ViewResolver viewResolverMock2 = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Arrays.asList(viewResolverMock1, viewResolverMock2));
 
 		viewResolver.afterPropertiesSet();
 
-		View viewMock1 = createMock("application_xml", View.class);
-		View viewMock2 = createMock("text_html", View.class);
+		View viewMock1 = mock(View.class, "application_xml");
+		View viewMock2 = mock(View.class, "text_html");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock1.resolveViewName(viewName, locale)).andReturn(viewMock1);
-		expect(viewResolverMock2.resolveViewName(viewName, locale)).andReturn(viewMock2);
-		expect(viewMock1.getContentType()).andReturn("application/xml").anyTimes();
-		expect(viewMock2.getContentType()).andReturn("text/html;charset=ISO-8859-1").anyTimes();
-
-		replay(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2);
+		given(viewResolverMock1.resolveViewName(viewName, locale)).willReturn(viewMock1);
+		given(viewResolverMock2.resolveViewName(viewName, locale)).willReturn(viewMock2);
+		given(viewMock1.getContentType()).willReturn("application/xml");
+		given(viewMock2.getContentType()).willReturn("text/html;charset=ISO-8859-1");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", viewMock2, result);
-
-		verify(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2);
 	}
 
 	// SPR-9160
@@ -251,26 +224,23 @@ public void resolveViewNameAcceptHeaderSortByQuality() throws Exception {
 
 		viewResolver.setContentNegotiationManager(new ContentNegotiationManager(new HeaderContentNegotiationStrategy()));
 
-		ViewResolver htmlViewResolver = createMock(ViewResolver.class);
-		ViewResolver jsonViewResolver = createMock(ViewResolver.class);
+		ViewResolver htmlViewResolver = mock(ViewResolver.class);
+		ViewResolver jsonViewResolver = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Arrays.asList(htmlViewResolver, jsonViewResolver));
 
-		View htmlView = createMock("text_html", View.class);
-		View jsonViewMock = createMock("application_json", View.class);
+		View htmlView = mock(View.class, "text_html");
+		View jsonViewMock = mock(View.class, "application_json");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(htmlViewResolver.resolveViewName(viewName, locale)).andReturn(htmlView);
-		expect(jsonViewResolver.resolveViewName(viewName, locale)).andReturn(jsonViewMock);
-		expect(htmlView.getContentType()).andReturn("text/html").anyTimes();
-		expect(jsonViewMock.getContentType()).andReturn("application/json").anyTimes();
-		replay(htmlViewResolver, jsonViewResolver, htmlView, jsonViewMock);
+		given(htmlViewResolver.resolveViewName(viewName, locale)).willReturn(htmlView);
+		given(jsonViewResolver.resolveViewName(viewName, locale)).willReturn(jsonViewMock);
+		given(htmlView.getContentType()).willReturn("text/html");
+		given(jsonViewMock.getContentType()).willReturn("application/json");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", jsonViewMock, result);
-
-		verify(htmlViewResolver, jsonViewResolver, htmlView, jsonViewMock);
 	}
 
 	// SPR-9807
@@ -279,40 +249,36 @@ public void resolveViewNameAcceptHeaderSortByQuality() throws Exception {
 	public void resolveViewNameAcceptHeaderWithSuffix() throws Exception {
 		request.addHeader("Accept", "application/vnd.example-v2+xml");
 
-		ViewResolver viewResolverMock = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Arrays.asList(viewResolverMock));
 
 		viewResolver.afterPropertiesSet();
 
-		View viewMock = createMock("application_xml", View.class);
+		View viewMock = mock(View.class, "application_xml");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock.resolveViewName(viewName, locale)).andReturn(viewMock);
-		expect(viewMock.getContentType()).andReturn("application/*+xml").anyTimes();
-
-		replay(viewResolverMock, viewMock);
+		given(viewResolverMock.resolveViewName(viewName, locale)).willReturn(viewMock);
+		given(viewMock.getContentType()).willReturn("application/*+xml");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 
 		assertSame("Invalid view", viewMock, result);
 		assertEquals(new MediaType("application", "vnd.example-v2+xml"), request.getAttribute(View.SELECTED_CONTENT_TYPE));
-
-		verify(viewResolverMock, viewMock);
 	}
 
 	@Test
 	public void resolveViewNameAcceptHeaderDefaultView() throws Exception {
 		request.addHeader("Accept", "application/json");
 
-		ViewResolver viewResolverMock1 = createMock(ViewResolver.class);
-		ViewResolver viewResolverMock2 = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock1 = mock(ViewResolver.class);
+		ViewResolver viewResolverMock2 = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Arrays.asList(viewResolverMock1, viewResolverMock2));
 
-		View viewMock1 = createMock("application_xml", View.class);
-		View viewMock2 = createMock("text_html", View.class);
-		View viewMock3 = createMock("application_json", View.class);
+		View viewMock1 = mock(View.class, "application_xml");
+		View viewMock2 = mock(View.class, "text_html");
+		View viewMock3 = mock(View.class, "application_json");
 
 		List<View> defaultViews = new ArrayList<View>();
 		defaultViews.add(viewMock3);
@@ -323,49 +289,41 @@ public void resolveViewNameAcceptHeaderDefaultView() throws Exception {
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock1.resolveViewName(viewName, locale)).andReturn(viewMock1);
-		expect(viewResolverMock2.resolveViewName(viewName, locale)).andReturn(viewMock2);
-		expect(viewMock1.getContentType()).andReturn("application/xml").anyTimes();
-		expect(viewMock2.getContentType()).andReturn("text/html;charset=ISO-8859-1").anyTimes();
-		expect(viewMock3.getContentType()).andReturn("application/json").anyTimes();
-
-		replay(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2, viewMock3);
+		given(viewResolverMock1.resolveViewName(viewName, locale)).willReturn(viewMock1);
+		given(viewResolverMock2.resolveViewName(viewName, locale)).willReturn(viewMock2);
+		given(viewMock1.getContentType()).willReturn("application/xml");
+		given(viewMock2.getContentType()).willReturn("text/html;charset=ISO-8859-1");
+		given(viewMock3.getContentType()).willReturn("application/json");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", viewMock3, result);
-
-		verify(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2, viewMock3);
 	}
 
 	@Test
 	public void resolveViewNameFilename() throws Exception {
 		request.setRequestURI("/test.html");
 
-		ViewResolver viewResolverMock1 = createMock("viewResolver1", ViewResolver.class);
-		ViewResolver viewResolverMock2 = createMock("viewResolver2", ViewResolver.class);
+		ViewResolver viewResolverMock1 = mock(ViewResolver.class, "viewResolver1");
+		ViewResolver viewResolverMock2 = mock(ViewResolver.class, "viewResolver2");
 		viewResolver.setViewResolvers(Arrays.asList(viewResolverMock1, viewResolverMock2));
 
 		viewResolver.afterPropertiesSet();
 
-		View viewMock1 = createMock("application_xml", View.class);
-		View viewMock2 = createMock("text_html", View.class);
+		View viewMock1 = mock(View.class, "application_xml");
+		View viewMock2 = mock(View.class, "text_html");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock1.resolveViewName(viewName, locale)).andReturn(viewMock1);
-		expect(viewResolverMock1.resolveViewName(viewName + ".html", locale)).andReturn(null);
-		expect(viewResolverMock2.resolveViewName(viewName, locale)).andReturn(null);
-		expect(viewResolverMock2.resolveViewName(viewName + ".html", locale)).andReturn(viewMock2);
-		expect(viewMock1.getContentType()).andReturn("application/xml").anyTimes();
-		expect(viewMock2.getContentType()).andReturn("text/html;charset=ISO-8859-1").anyTimes();
-
-		replay(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2);
+		given(viewResolverMock1.resolveViewName(viewName, locale)).willReturn(viewMock1);
+		given(viewResolverMock1.resolveViewName(viewName + ".html", locale)).willReturn(null);
+		given(viewResolverMock2.resolveViewName(viewName, locale)).willReturn(null);
+		given(viewResolverMock2.resolveViewName(viewName + ".html", locale)).willReturn(viewMock2);
+		given(viewMock1.getContentType()).willReturn("application/xml");
+		given(viewMock2.getContentType()).willReturn("text/html;charset=ISO-8859-1");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", viewMock2, result);
-
-		verify(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2);
 	}
 
 	@Test
@@ -376,13 +334,13 @@ public void resolveViewNameFilenameDefaultView() throws Exception {
 		PathExtensionContentNegotiationStrategy pathStrategy = new PathExtensionContentNegotiationStrategy(mapping);
 		viewResolver.setContentNegotiationManager(new ContentNegotiationManager(pathStrategy));
 
-		ViewResolver viewResolverMock1 = createMock(ViewResolver.class);
-		ViewResolver viewResolverMock2 = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock1 = mock(ViewResolver.class);
+		ViewResolver viewResolverMock2 = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Arrays.asList(viewResolverMock1, viewResolverMock2));
 
-		View viewMock1 = createMock("application_xml", View.class);
-		View viewMock2 = createMock("text_html", View.class);
-		View viewMock3 = createMock("application_json", View.class);
+		View viewMock1 = mock(View.class, "application_xml");
+		View viewMock2 = mock(View.class, "text_html");
+		View viewMock3 = mock(View.class, "application_json");
 
 		List<View> defaultViews = new ArrayList<View>();
 		defaultViews.add(viewMock3);
@@ -393,45 +351,37 @@ public void resolveViewNameFilenameDefaultView() throws Exception {
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock1.resolveViewName(viewName, locale)).andReturn(viewMock1);
-		expect(viewResolverMock1.resolveViewName(viewName + ".json", locale)).andReturn(null);
-		expect(viewResolverMock2.resolveViewName(viewName, locale)).andReturn(viewMock2);
-		expect(viewResolverMock2.resolveViewName(viewName + ".json", locale)).andReturn(null);
-		expect(viewMock1.getContentType()).andReturn("application/xml").anyTimes();
-		expect(viewMock2.getContentType()).andReturn("text/html;charset=ISO-8859-1").anyTimes();
-		expect(viewMock3.getContentType()).andReturn("application/json").anyTimes();
-
-		replay(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2, viewMock3);
+		given(viewResolverMock1.resolveViewName(viewName, locale)).willReturn(viewMock1);
+		given(viewResolverMock1.resolveViewName(viewName + ".json", locale)).willReturn(null);
+		given(viewResolverMock2.resolveViewName(viewName, locale)).willReturn(viewMock2);
+		given(viewResolverMock2.resolveViewName(viewName + ".json", locale)).willReturn(null);
+		given(viewMock1.getContentType()).willReturn("application/xml");
+		given(viewMock2.getContentType()).willReturn("text/html;charset=ISO-8859-1");
+		given(viewMock3.getContentType()).willReturn("application/json");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertSame("Invalid view", viewMock3, result);
-
-		verify(viewResolverMock1, viewResolverMock2, viewMock1, viewMock2, viewMock3);
 	}
 
 	@Test
 	public void resolveViewContentTypeNull() throws Exception {
 		request.addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
 
-		ViewResolver viewResolverMock = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Collections.singletonList(viewResolverMock));
 
 		viewResolver.afterPropertiesSet();
 
-		View viewMock = createMock("application_xml", View.class);
+		View viewMock = mock(View.class, "application_xml");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock.resolveViewName(viewName, locale)).andReturn(viewMock);
-		expect(viewMock.getContentType()).andReturn(null).anyTimes();
-
-		replay(viewResolverMock, viewMock);
+		given(viewResolverMock.resolveViewName(viewName, locale)).willReturn(viewMock);
+		given(viewMock.getContentType()).willReturn(null);
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertNull("Invalid view", result);
-
-		verify(viewResolverMock, viewMock);
 	}
 
 	@Test
@@ -445,11 +395,11 @@ public void resolveViewNameRedirectView() throws Exception {
 
 		UrlBasedViewResolver urlViewResolver = new InternalResourceViewResolver();
 		urlViewResolver.setApplicationContext(webAppContext);
-		ViewResolver xmlViewResolver = createMock(ViewResolver.class);
+		ViewResolver xmlViewResolver = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Arrays.<ViewResolver>asList(xmlViewResolver, urlViewResolver));
 
-		View xmlView = createMock("application_xml", View.class);
-		View jsonView = createMock("application_json", View.class);
+		View xmlView = mock(View.class, "application_xml");
+		View jsonView = mock(View.class, "application_json");
 		viewResolver.setDefaultViews(Arrays.asList(jsonView));
 
 		viewResolver.afterPropertiesSet();
@@ -457,40 +407,32 @@ public void resolveViewNameRedirectView() throws Exception {
 		String viewName = "redirect:anotherTest";
 		Locale locale = Locale.ENGLISH;
 
-		expect(xmlViewResolver.resolveViewName(viewName, locale)).andReturn(xmlView);
-		expect(jsonView.getContentType()).andReturn("application/json").anyTimes();
-
-		replay(xmlViewResolver, xmlView, jsonView);
+		given(xmlViewResolver.resolveViewName(viewName, locale)).willReturn(xmlView);
+		given(jsonView.getContentType()).willReturn("application/json");
 
 		View actualView = viewResolver.resolveViewName(viewName, locale);
 		assertEquals("Invalid view", RedirectView.class, actualView.getClass());
-
-		verify(xmlViewResolver, xmlView, jsonView);
 	}
 
 	@Test
 	public void resolveViewNoMatch() throws Exception {
 		request.addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9");
 
-		ViewResolver viewResolverMock = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Collections.singletonList(viewResolverMock));
 
 		viewResolver.afterPropertiesSet();
 
-		View viewMock = createMock("application_xml", View.class);
+		View viewMock = mock(View.class, "application_xml");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock.resolveViewName(viewName, locale)).andReturn(viewMock);
-		expect(viewMock.getContentType()).andReturn("application/pdf").anyTimes();
-
-		replay(viewResolverMock, viewMock);
+		given(viewResolverMock.resolveViewName(viewName, locale)).willReturn(viewMock);
+		given(viewMock.getContentType()).willReturn("application/pdf");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertNull("Invalid view", result);
-
-		verify(viewResolverMock, viewMock);
 	}
 
 	@Test
@@ -498,28 +440,24 @@ public void resolveViewNoMatchUseUnacceptableStatus() throws Exception {
 		viewResolver.setUseNotAcceptableStatusCode(true);
 		request.addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9");
 
-		ViewResolver viewResolverMock = createMock(ViewResolver.class);
+		ViewResolver viewResolverMock = mock(ViewResolver.class);
 		viewResolver.setViewResolvers(Collections.singletonList(viewResolverMock));
 
 		viewResolver.afterPropertiesSet();
 
-		View viewMock = createMock("application_xml", View.class);
+		View viewMock = mock(View.class, "application_xml");
 
 		String viewName = "view";
 		Locale locale = Locale.ENGLISH;
 
-		expect(viewResolverMock.resolveViewName(viewName, locale)).andReturn(viewMock);
-		expect(viewMock.getContentType()).andReturn("application/pdf").anyTimes();
-
-		replay(viewResolverMock, viewMock);
+		given(viewResolverMock.resolveViewName(viewName, locale)).willReturn(viewMock);
+		given(viewMock.getContentType()).willReturn("application/pdf");
 
 		View result = viewResolver.resolveViewName(viewName, locale);
 		assertNotNull("Invalid view", result);
 		MockHttpServletResponse response = new MockHttpServletResponse();
 		result.render(null, request, response);
 		assertEquals("Invalid status code set", 406, response.getStatus());
-
-		verify(viewResolverMock, viewMock);
 	}
 
 	@Test
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/InternalResourceViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/InternalResourceViewTests.java
index e46aa5449e58..3a9531b7d059 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/InternalResourceViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/InternalResourceViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,11 +16,6 @@
 
 package org.springframework.web.servlet.view;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expectLastCall;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Set;
@@ -36,6 +31,8 @@
 import org.springframework.web.servlet.View;
 import org.springframework.web.util.WebUtils;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
@@ -150,19 +147,9 @@ public void testAlwaysInclude() throws Exception {
 
 		String url = "forward-to";
 
-		HttpServletRequest request = createMock(HttpServletRequest.class);
-		request.getAttribute(View.PATH_VARIABLES);
-		expectLastCall().andReturn(null);
-		Set<String> keys = model.keySet();
-		for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
-			String key = iter.next();
-			request.setAttribute(key, model.get(key));
-			expectLastCall().times(1);
-		}
-
-		request.getRequestDispatcher(url);
-		expectLastCall().andReturn(new MockRequestDispatcher(url));
-		replay(request);
+		HttpServletRequest request = mock(HttpServletRequest.class);
+		given(request.getAttribute(View.PATH_VARIABLES)).willReturn(null);
+		given(request.getRequestDispatcher(url)).willReturn(new MockRequestDispatcher(url));
 
 		MockHttpServletResponse response = new MockHttpServletResponse();
 		InternalResourceView v = new InternalResourceView();
@@ -172,7 +159,12 @@ public void testAlwaysInclude() throws Exception {
 		// Can now try multiple tests
 		v.render(model, request, response);
 		assertEquals(url, response.getIncludedUrl());
-		verify(request);
+
+		Set<String> keys = model.keySet();
+		for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
+			String key = iter.next();
+			verify(request).setAttribute(key, model.get(key));
+		}
 	}
 
 	public void testIncludeOnAttribute() throws Exception {
@@ -183,21 +175,11 @@ public void testIncludeOnAttribute() throws Exception {
 
 		String url = "forward-to";
 
-		HttpServletRequest request = createMock(HttpServletRequest.class);
-		request.getAttribute(View.PATH_VARIABLES);
-		expectLastCall().andReturn(null);
-		Set<String> keys = model.keySet();
-		for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
-			String key = iter.next();
-			request.setAttribute(key, model.get(key));
-			expectLastCall().times(1);
-		}
+		HttpServletRequest request = mock(HttpServletRequest.class);
+		given(request.getAttribute(View.PATH_VARIABLES)).willReturn(null);
 
-		request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);
-		expectLastCall().andReturn("somepath");
-		request.getRequestDispatcher(url);
-		expectLastCall().andReturn(new MockRequestDispatcher(url));
-		replay(request);
+		given(request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE)).willReturn("somepath");
+		given(request.getRequestDispatcher(url)).willReturn(new MockRequestDispatcher(url));
 
 		MockHttpServletResponse response = new MockHttpServletResponse();
 		InternalResourceView v = new InternalResourceView();
@@ -206,7 +188,12 @@ public void testIncludeOnAttribute() throws Exception {
 		// Can now try multiple tests
 		v.render(model, request, response);
 		assertEquals(url, response.getIncludedUrl());
-		verify(request);
+
+		Set<String> keys = model.keySet();
+		for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
+			String key = iter.next();
+			verify(request).setAttribute(key, model.get(key));
+		}
 	}
 
 	public void testIncludeOnCommitted() throws Exception {
@@ -217,21 +204,11 @@ public void testIncludeOnCommitted() throws Exception {
 
 		String url = "forward-to";
 
-		HttpServletRequest request = createMock(HttpServletRequest.class);
-		request.getAttribute(View.PATH_VARIABLES);
-		expectLastCall().andReturn(null);
-		Set<String> keys = model.keySet();
-		for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
-			String key = iter.next();
-			request.setAttribute(key, model.get(key));
-			expectLastCall().times(1);
-		}
+		HttpServletRequest request = mock(HttpServletRequest.class);
+		given(request.getAttribute(View.PATH_VARIABLES)).willReturn(null);
 
-		request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);
-		expectLastCall().andReturn(null);
-		request.getRequestDispatcher(url);
-		expectLastCall().andReturn(new MockRequestDispatcher(url));
-		replay(request);
+		given(request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE)).willReturn(null);
+		given(request.getRequestDispatcher(url)).willReturn(new MockRequestDispatcher(url));
 
 		MockHttpServletResponse response = new MockHttpServletResponse();
 		response.setCommitted(true);
@@ -241,7 +218,12 @@ public void testIncludeOnCommitted() throws Exception {
 		// Can now try multiple tests
 		v.render(model, request, response);
 		assertEquals(url, response.getIncludedUrl());
-		verify(request);
+
+		Set<String> keys = model.keySet();
+		for (Iterator<String> iter = keys.iterator(); iter.hasNext();) {
+			String key = iter.next();
+			verify(request).setAttribute(key, model.get(key));
+		}
 	}
 
 }
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/RedirectViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/RedirectViewTests.java
index d3c45fb24931..c3fd2614102b 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/RedirectViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/RedirectViewTests.java
@@ -16,14 +16,6 @@
 
 package org.springframework.web.servlet.view;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.createNiceMock;
-import static org.easymock.EasyMock.expect;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
@@ -34,13 +26,12 @@
 
 import junit.framework.AssertionFailedError;
 
-import org.easymock.EasyMock;
 import org.junit.Test;
-import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.http.HttpStatus;
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockHttpServletResponse;
 import org.springframework.mock.web.test.MockServletContext;
+import org.springframework.tests.sample.beans.TestBean;
 import org.springframework.ui.ModelMap;
 import org.springframework.web.context.ContextLoader;
 import org.springframework.web.context.support.StaticWebApplicationContext;
@@ -53,6 +44,9 @@
 import org.springframework.web.servlet.support.SessionFlashMapManager;
 import org.springframework.web.util.WebUtils;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Tests for redirect view, and query string construction.
  * Doesn't test URL encoding, although it does check that it's called.
@@ -156,7 +150,7 @@ public void updateTargetUrl() throws Exception {
 		wac.setServletContext(new MockServletContext());
 		wac.refresh();
 
-		RequestDataValueProcessor mockProcessor = createMock(RequestDataValueProcessor.class);
+		RequestDataValueProcessor mockProcessor = mock(RequestDataValueProcessor.class);
 		wac.getBean(RequestDataValueProcessorWrapper.class).setRequestDataValueProcessor(mockProcessor);
 
 		RedirectView rv = new RedirectView();
@@ -167,12 +161,11 @@ public void updateTargetUrl() throws Exception {
 		request.setAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
 		HttpServletResponse response = new MockHttpServletResponse();
 
-		EasyMock.expect(mockProcessor.processUrl(request, "/path")).andReturn("/path?key=123");
-		EasyMock.replay(mockProcessor);
+		given(mockProcessor.processUrl(request, "/path")).willReturn("/path?key=123");
 
 		rv.render(new ModelMap(), request, response);
 
-		EasyMock.verify(mockProcessor);
+		verify(mockProcessor).processUrl(request, "/path");
 	}
 
 
@@ -186,7 +179,7 @@ public void updateTargetUrlWithContextLoader() throws Exception {
 		contextLoader.initWebApplicationContext(servletContext);
 
 		try {
-			RequestDataValueProcessor mockProcessor = createMock(RequestDataValueProcessor.class);
+			RequestDataValueProcessor mockProcessor = mock(RequestDataValueProcessor.class);
 			wac.getBean(RequestDataValueProcessorWrapper.class).setRequestDataValueProcessor(mockProcessor);
 
 			RedirectView rv = new RedirectView();
@@ -195,12 +188,11 @@ public void updateTargetUrlWithContextLoader() throws Exception {
 			MockHttpServletRequest request = createRequest();
 			HttpServletResponse response = new MockHttpServletResponse();
 
-			EasyMock.expect(mockProcessor.processUrl(request, "/path")).andReturn("/path?key=123");
-			EasyMock.replay(mockProcessor);
+			given(mockProcessor.processUrl(request, "/path")).willReturn("/path?key=123");
 
 			rv.render(new ModelMap(), request, response);
 
-			EasyMock.verify(mockProcessor);
+			verify(mockProcessor).processUrl(request, "/path");
 		}
 		finally {
 			contextLoader.closeWebApplicationContext(servletContext);
@@ -363,32 +355,28 @@ protected Map<String, Object> queryProperties(Map<String, Object> model) {
 		rv.setContextRelative(contextRelative);
 		rv.setExposeModelAttributes(exposeModelAttributes);
 
-		HttpServletRequest request = createNiceMock("request", HttpServletRequest.class);
+		HttpServletRequest request = mock(HttpServletRequest.class, "request");
 		if (exposeModelAttributes) {
-			expect(request.getCharacterEncoding()).andReturn(WebUtils.DEFAULT_CHARACTER_ENCODING);
+			given(request.getCharacterEncoding()).willReturn(WebUtils.DEFAULT_CHARACTER_ENCODING);
 		}
 		if (contextRelative) {
 			expectedUrlForEncoding = "/context" + expectedUrlForEncoding;
-			expect(request.getContextPath()).andReturn("/context");
+			given(request.getContextPath()).willReturn("/context");
 		}
 
-		expect(request.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE)).andReturn(new FlashMap());
+		given(request.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE)).willReturn(new FlashMap());
 
 		FlashMapManager flashMapManager = new SessionFlashMapManager();
-		expect(request.getAttribute(DispatcherServlet.FLASH_MAP_MANAGER_ATTRIBUTE)).andReturn(flashMapManager);
+		given(request.getAttribute(DispatcherServlet.FLASH_MAP_MANAGER_ATTRIBUTE)).willReturn(flashMapManager);
 
-		HttpServletResponse response = createMock("response", HttpServletResponse.class);
-		expect(response.encodeRedirectURL(expectedUrlForEncoding)).andReturn(expectedUrlForEncoding);
+		HttpServletResponse response = mock(HttpServletResponse.class, "response");
+		given(response.encodeRedirectURL(expectedUrlForEncoding)).willReturn(expectedUrlForEncoding);
 		response.sendRedirect(expectedUrlForEncoding);
 
-		replay(request, response);
-
 		rv.render(map, request, response);
 		if (exposeModelAttributes) {
 			assertTrue("queryProperties() should have been called.", rv.queryPropertiesCalled);
 		}
-
-		verify(request, response);
 	}
 
 }
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/ResourceBundleViewResolverTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/ResourceBundleViewResolverTests.java
index b100a6a68ebb..19e4551fb3d2 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/ResourceBundleViewResolverTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/ResourceBundleViewResolverTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,14 +72,14 @@ protected boolean getCache() {
 
 	public void testParentsAreAbstract() throws Exception {
 		try {
-			View v = rb.resolveViewName("debug.Parent", Locale.ENGLISH);
+			rb.resolveViewName("debug.Parent", Locale.ENGLISH);
 			fail("Should have thrown BeanIsAbstractException");
 		}
 		catch (BeanIsAbstractException ex) {
 			// expected
 		}
 		try {
-			View v = rb.resolveViewName("testParent", Locale.ENGLISH);
+			rb.resolveViewName("testParent", Locale.ENGLISH);
 			fail("Should have thrown BeanIsAbstractException");
 		}
 		catch (BeanIsAbstractException ex) {
@@ -152,7 +152,7 @@ public void testOnSetContextCalledOnce() throws Exception {
 	public void testNoSuchBasename() throws Exception {
 		try {
 			rb.setBasename("weoriwoierqupowiuer");
-			View v = rb.resolveViewName("debugView", Locale.ENGLISH);
+			rb.resolveViewName("debugView", Locale.ENGLISH);
 			fail("No such basename: all requests should fail with exception");
 		}
 		catch (MissingResourceException ex) {
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerConfigurerTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerConfigurerTests.java
index 962b3fa33c3a..077c5b3a73a0 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerConfigurerTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerConfigurerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,9 @@
 
 package org.springframework.web.servlet.view.freemarker;
 
+import static org.hamcrest.Matchers.instanceOf;
+import static org.junit.Assert.assertThat;
+
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Properties;
@@ -98,7 +101,7 @@ public ClassLoader getClassLoader() {
 			}
 		});
 		fcfb.afterPropertiesSet();
-		assertTrue(fcfb.getObject() instanceof Configuration);
+		assertThat(fcfb.getObject(), instanceOf(Configuration.class));
 		Configuration fc = fcfb.getObject();
 		Template ft = fc.getTemplate("test");
 		assertEquals("test", FreeMarkerTemplateUtils.processTemplateIntoString(ft, new HashMap()));
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerMacroTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerMacroTests.java
index 17a4c4f50c49..9e4f320ef684 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerMacroTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerMacroTests.java
@@ -107,7 +107,7 @@ protected void processTemplate(Template template, SimpleHash fmModel, HttpServle
 		fv.setApplicationContext(wac);
 		fv.setExposeSpringMacroHelpers(true);
 
-		Map model = new HashMap();
+		Map<String, Object> model = new HashMap<String, Object>();
 		model.put("tb", new TestBean("juergen", 99));
 		fv.render(model, request, response);
 	}
@@ -126,7 +126,7 @@ protected void processTemplate(Template template, SimpleHash model, HttpServletR
 		fv.setApplicationContext(wac);
 		fv.setExposeSpringMacroHelpers(true);
 
-		Map model = new HashMap();
+		Map<String, Object> model = new HashMap<String, Object>();
 		model.put(FreeMarkerView.SPRING_MACRO_REQUEST_CONTEXT_ATTRIBUTE, helperTool);
 
 		try {
@@ -265,6 +265,13 @@ public void testForm17() throws Exception {
 		assertEquals("<input type=\"text\" id=\"spouses0.name\" name=\"spouses[0].name\" value=\"Fred\"     >", getMacroOutput("FORM17"));
 	}
 
+	@Test
+	public void testForm18() throws Exception {
+		String output = getMacroOutput("FORM18");
+		assertTrue("Wrong output: " + output, output.startsWith("<input type=\"hidden\" name=\"_spouses[0].jedi\" value=\"on\"/>"));
+		assertTrue("Wrong output: " + output, output.contains("<input type=\"checkbox\" id=\"spouses0.jedi\" name=\"spouses[0].jedi\" checked=\"checked\" />"));
+	}
+
 	private String getMacroOutput(String name) throws Exception {
 
 		String macro = fetchMacro(name);
@@ -274,30 +281,32 @@ private String getMacroOutput(String name) throws Exception {
 		FileCopyUtils.copy("<#import \"spring.ftl\" as spring />\n" + macro, new FileWriter(resource.getPath()));
 
 		DummyMacroRequestContext rc = new DummyMacroRequestContext(request);
-		Map msgMap = new HashMap();
+		Map<String, String> msgMap = new HashMap<String, String>();
 		msgMap.put("hello", "Howdy");
 		msgMap.put("world", "Mundo");
 		rc.setMessageMap(msgMap);
-		Map themeMsgMap = new HashMap();
+		Map<String, String> themeMsgMap = new HashMap<String, String>();
 		themeMsgMap.put("hello", "Howdy!");
 		themeMsgMap.put("world", "Mundo!");
 		rc.setThemeMessageMap(themeMsgMap);
 		rc.setContextPath("/springtest");
 
-		TestBean tb = new TestBean("Darren", 99);
-		tb.setSpouse(new TestBean("Fred"));
-		tb.setJedi(true);
-		request.setAttribute("command", tb);
+		TestBean darren = new TestBean("Darren", 99);
+		TestBean fred = new TestBean("Fred");
+		fred.setJedi(true);
+		darren.setSpouse(fred);
+		darren.setJedi(true);
+		request.setAttribute("command", darren);
 
-		HashMap names = new HashMap();
+		Map<String, String> names = new HashMap<String, String>();
 		names.put("Darren", "Darren Davison");
 		names.put("John", "John Doe");
 		names.put("Fred", "Fred Bloggs");
 		names.put("Rob&Harrop", "Rob Harrop");
 
 		Configuration config = fc.getConfiguration();
-		Map model = new HashMap();
-		model.put("command", tb);
+		Map<String, Object> model = new HashMap<String, Object>();
+		model.put("command", darren);
 		model.put("springMacroRequestContext", rc);
 		model.put("msgArgs", new Object[] { "World" });
 		model.put("nameOptionMap", names);
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerViewTests.java
index ff233b9be2fb..0131151f0e91 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/FreeMarkerViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,16 +23,10 @@
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
+
 import javax.servlet.http.HttpServletResponse;
 
-import freemarker.ext.servlet.AllHttpScopesHashModel;
-import freemarker.template.Configuration;
-import freemarker.template.Template;
-import freemarker.template.TemplateException;
-import org.easymock.MockControl;
-import static org.junit.Assert.*;
 import org.junit.Test;
-
 import org.springframework.context.ApplicationContextException;
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockHttpServletResponse;
@@ -46,6 +40,14 @@
 import org.springframework.web.servlet.view.InternalResourceView;
 import org.springframework.web.servlet.view.RedirectView;
 
+import freemarker.ext.servlet.AllHttpScopesHashModel;
+import freemarker.template.Configuration;
+import freemarker.template.Template;
+import freemarker.template.TemplateException;
+
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Juergen Hoeller
  * @since 14.03.2004
@@ -56,15 +58,9 @@ public class FreeMarkerViewTests {
 	public void testNoFreeMarkerConfig() throws Exception {
 		FreeMarkerView fv = new FreeMarkerView();
 
-		MockControl wmc = MockControl.createControl(WebApplicationContext.class);
-		WebApplicationContext wac = (WebApplicationContext) wmc.getMock();
-		wac.getBeansOfType(FreeMarkerConfig.class, true, false);
-		wmc.setReturnValue(new HashMap());
-		wac.getParentBeanFactory();
-		wmc.setReturnValue(null);
-		wac.getServletContext();
-		wmc.setReturnValue(new MockServletContext());
-		wmc.replay();
+		WebApplicationContext wac = mock(WebApplicationContext.class);
+		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(new HashMap<String, FreeMarkerConfig>());
+		given(wac.getServletContext()).willReturn(new MockServletContext());
 
 		fv.setUrl("anythingButNull");
 		try {
@@ -76,8 +72,6 @@ public void testNoFreeMarkerConfig() throws Exception {
 			// Check there's a helpful error message
 			assertTrue(ex.getMessage().indexOf("FreeMarkerConfig") != -1);
 		}
-
-		wmc.verify();
 	}
 
 	@Test
@@ -97,21 +91,15 @@ public void testNoTemplateName() throws Exception {
 	public void testValidTemplateName() throws Exception {
 		FreeMarkerView fv = new FreeMarkerView();
 
-		MockControl wmc = MockControl.createNiceControl(WebApplicationContext.class);
-		WebApplicationContext wac = (WebApplicationContext) wmc.getMock();
+		WebApplicationContext wac = mock(WebApplicationContext.class);
 		MockServletContext sc = new MockServletContext();
 
-		wac.getBeansOfType(FreeMarkerConfig.class, true, false);
 		Map configs = new HashMap();
 		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
 		configurer.setConfiguration(new TestConfiguration());
 		configs.put("configurer", configurer);
-		wmc.setReturnValue(configs);
-		wac.getParentBeanFactory();
-		wmc.setReturnValue(null);
-		wac.getServletContext();
-		wmc.setReturnValue(sc, 2);
-		wmc.replay();
+		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(configs);
+		given(wac.getServletContext()).willReturn(sc);
 
 		fv.setUrl("templateName");
 		fv.setApplicationContext(wac);
@@ -126,7 +114,6 @@ public void testValidTemplateName() throws Exception {
 		model.put("myattr", "myvalue");
 		fv.render(model, request, response);
 
-		wmc.verify();
 		assertEquals(AbstractView.DEFAULT_CONTENT_TYPE, response.getContentType());
 	}
 
@@ -134,21 +121,15 @@ public void testValidTemplateName() throws Exception {
 	public void testKeepExistingContentType() throws Exception {
 		FreeMarkerView fv = new FreeMarkerView();
 
-		MockControl wmc = MockControl.createNiceControl(WebApplicationContext.class);
-		WebApplicationContext wac = (WebApplicationContext) wmc.getMock();
+		WebApplicationContext wac = mock(WebApplicationContext.class);
 		MockServletContext sc = new MockServletContext();
 
-		wac.getBeansOfType(FreeMarkerConfig.class, true, false);
 		Map configs = new HashMap();
 		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
 		configurer.setConfiguration(new TestConfiguration());
 		configs.put("configurer", configurer);
-		wmc.setReturnValue(configs);
-		wac.getParentBeanFactory();
-		wmc.setReturnValue(null);
-		wac.getServletContext();
-		wmc.setReturnValue(sc, 2);
-		wmc.replay();
+		given(wac.getBeansOfType(FreeMarkerConfig.class, true, false)).willReturn(configs);
+		given(wac.getServletContext()).willReturn(sc);
 
 		fv.setUrl("templateName");
 		fv.setApplicationContext(wac);
@@ -164,7 +145,6 @@ public void testKeepExistingContentType() throws Exception {
 		model.put("myattr", "myvalue");
 		fv.render(model, request, response);
 
-		wmc.verify();
 		assertEquals("myContentType", response.getContentType());
 	}
 
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/test.ftl b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/test.ftl
index 8440b4f945f4..b1e015618618 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/test.ftl
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/freemarker/test.ftl
@@ -89,3 +89,6 @@ FORM16
 
 FORM17
 <@spring.formInput "command.spouses[0].name", ""/>
+
+FORM18
+<@spring.formCheckbox "command.spouses[0].jedi" />
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/jasperreports/AbstractJasperReportsViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/jasperreports/AbstractJasperReportsViewTests.java
index 5350f1599995..463fe47d2884 100755
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/jasperreports/AbstractJasperReportsViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/jasperreports/AbstractJasperReportsViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,15 +32,16 @@
 import net.sf.jasperreports.engine.JasperReport;
 import net.sf.jasperreports.engine.data.JRAbstractBeanDataSourceProvider;
 import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
-import org.easymock.MockControl;
-import org.junit.Ignore;
 
+import org.junit.Ignore;
 import org.springframework.context.ApplicationContextException;
 import org.springframework.mock.web.test.MockServletContext;
 import org.springframework.ui.jasperreports.PersonBean;
 import org.springframework.web.context.support.StaticWebApplicationContext;
 import org.springframework.web.servlet.DispatcherServlet;
 
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rob Harrop
  * @author Juergen Hoeller
@@ -372,11 +373,8 @@ public void testJRDataSourceOverridesJdbcDataSource() throws Exception {
 	}
 
 	private DataSource getMockJdbcDataSource() throws SQLException {
-		MockControl ctl = MockControl.createControl(DataSource.class);
-		DataSource ds = (DataSource) ctl.getMock();
-		ds.getConnection();
-		ctl.setThrowable(new SQLException());
-		ctl.replay();
+		DataSource ds = mock(DataSource.class);
+		given(ds.getConnection()).willThrow(new SQLException());
 		return ds;
 	}
 
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/json/MappingJackson2JsonViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/json/MappingJackson2JsonViewTests.java
index d1cd12d8b48f..5874985aa335 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/json/MappingJackson2JsonViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/json/MappingJackson2JsonViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,13 +16,6 @@
 
 package org.springframework.web.servlet.view.json;
 
-import static org.easymock.EasyMock.createMock;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
 import java.io.IOException;
 import java.util.Date;
 import java.util.HashMap;
@@ -56,6 +49,9 @@
 import com.fasterxml.jackson.databind.ser.SerializerFactory;
 import com.fasterxml.jackson.databind.ser.Serializers;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Jeremy Grelle
  * @author Arjen Poutsma
@@ -93,7 +89,7 @@ public void isExposePathVars() {
 	public void renderSimpleMap() throws Exception {
 
 		Map<String, Object> model = new HashMap<String, Object>();
-		model.put("bindingResult", createMock("binding_result", BindingResult.class));
+		model.put("bindingResult", mock(BindingResult.class, "binding_result"));
 		model.put("foo", "bar");
 
 		view.setUpdateContentLength(true);
@@ -133,7 +129,7 @@ public void renderCaching() throws Exception {
 		view.setDisableCaching(false);
 
 		Map<String, Object> model = new HashMap<String, Object>();
-		model.put("bindingResult", createMock("binding_result", BindingResult.class));
+		model.put("bindingResult", mock(BindingResult.class, "binding_result"));
 		model.put("foo", "bar");
 
 		view.render(model, request, response);
@@ -154,7 +150,7 @@ public void renderSimpleBean() throws Exception {
 
 		Object bean = new TestBeanSimple();
 		Map<String, Object> model = new HashMap<String, Object>();
-		model.put("bindingResult", createMock("binding_result", BindingResult.class));
+		model.put("bindingResult", mock(BindingResult.class, "binding_result"));
 		model.put("foo", bean);
 
 		view.setUpdateContentLength(true);
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/json/MappingJacksonJsonViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/json/MappingJacksonJsonViewTests.java
index da6a9b6418c0..1e2f9eda5eb4 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/json/MappingJacksonJsonViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/json/MappingJacksonJsonViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,13 +16,6 @@
 
 package org.springframework.web.servlet.view.json;
 
-import static org.easymock.EasyMock.createMock;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
 import java.io.IOException;
 import java.util.Date;
 import java.util.HashMap;
@@ -48,6 +41,9 @@
 import org.springframework.ui.ModelMap;
 import org.springframework.validation.BindingResult;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Jeremy Grelle
  * @author Arjen Poutsma
@@ -84,7 +80,7 @@ public void isExposePathVars() {
 	public void renderSimpleMap() throws Exception {
 
 		Map<String, Object> model = new HashMap<String, Object>();
-		model.put("bindingResult", createMock("binding_result", BindingResult.class));
+		model.put("bindingResult", mock(BindingResult.class, "binding_result"));
 		model.put("foo", "bar");
 
 		view.setUpdateContentLength(true);
@@ -108,7 +104,7 @@ public void renderCaching() throws Exception {
 		view.setDisableCaching(false);
 
 		Map<String, Object> model = new HashMap<String, Object>();
-		model.put("bindingResult", createMock("binding_result", BindingResult.class));
+		model.put("bindingResult", mock(BindingResult.class, "binding_result"));
 		model.put("foo", "bar");
 
 		view.render(model, request, response);
@@ -129,7 +125,7 @@ public void renderSimpleBean() throws Exception {
 
 		Object bean = new TestBeanSimple();
 		Map<String, Object> model = new HashMap<String, Object>();
-		model.put("bindingResult", createMock("binding_result", BindingResult.class));
+		model.put("bindingResult", mock(BindingResult.class, "binding_result"));
 		model.put("foo", bean);
 
 		view.setUpdateContentLength(true);
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/velocity/VelocityConfigurerTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/velocity/VelocityConfigurerTests.java
index 69f8ea613aa3..647505059757 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/velocity/VelocityConfigurerTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/velocity/VelocityConfigurerTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,9 @@
 
 package org.springframework.web.servlet.view.velocity;
 
+import static org.hamcrest.Matchers.instanceOf;
+import static org.junit.Assert.assertThat;
+
 import java.io.File;
 import java.io.IOException;
 import java.net.MalformedURLException;
@@ -25,9 +28,9 @@
 import java.util.Vector;
 
 import junit.framework.TestCase;
+
 import org.apache.velocity.app.VelocityEngine;
 import org.apache.velocity.exception.VelocityException;
-
 import org.springframework.core.io.ByteArrayResource;
 import org.springframework.core.io.DescriptiveResource;
 import org.springframework.core.io.FileSystemResource;
@@ -68,7 +71,7 @@ public void testVelocityEngineFactoryBeanWithVelocityProperties() throws Velocit
 		map.put("myentry", value);
 		vefb.setVelocityPropertiesMap(map);
 		vefb.afterPropertiesSet();
-		assertTrue(vefb.getObject() instanceof VelocityEngine);
+		assertThat(vefb.getObject(), instanceOf(VelocityEngine.class));
 		VelocityEngine ve = vefb.getObject();
 		assertEquals("/mydir", ve.getProperty("myprop"));
 		assertEquals(value, ve.getProperty("myentry"));
@@ -78,7 +81,7 @@ public void testVelocityEngineFactoryBeanWithResourceLoaderPath() throws IOExcep
 		VelocityEngineFactoryBean vefb = new VelocityEngineFactoryBean();
 		vefb.setResourceLoaderPath("file:/mydir");
 		vefb.afterPropertiesSet();
-		assertTrue(vefb.getObject() instanceof VelocityEngine);
+		assertThat(vefb.getObject(), instanceOf(VelocityEngine.class));
 		VelocityEngine ve = vefb.getObject();
 		assertEquals(new File("/mydir").getAbsolutePath(), ve.getProperty(VelocityEngine.FILE_RESOURCE_LOADER_PATH));
 	}
@@ -105,7 +108,7 @@ public ClassLoader getClassLoader() {
 			}
 		});
 		vefb.afterPropertiesSet();
-		assertTrue(vefb.getObject() instanceof VelocityEngine);
+		assertThat(vefb.getObject(), instanceOf(VelocityEngine.class));
 		VelocityEngine ve = vefb.getObject();
 		assertEquals("test", VelocityEngineUtils.mergeTemplateIntoString(ve, "test", new HashMap()));
 	}
@@ -114,7 +117,7 @@ public void testVelocityConfigurer() throws IOException, VelocityException {
 		VelocityConfigurer vc = new VelocityConfigurer();
 		vc.setResourceLoaderPath("file:/mydir");
 		vc.afterPropertiesSet();
-		assertTrue(vc.createVelocityEngine() instanceof VelocityEngine);
+		assertThat(vc.createVelocityEngine(), instanceOf(VelocityEngine.class));
 		VelocityEngine ve = vc.createVelocityEngine();
 		assertEquals(new File("/mydir").getAbsolutePath(), ve.getProperty(VelocityEngine.FILE_RESOURCE_LOADER_PATH));
 	}
@@ -123,7 +126,7 @@ public void testVelocityConfigurerWithCsvPath() throws IOException, VelocityExce
 		VelocityConfigurer vc = new VelocityConfigurer();
 		vc.setResourceLoaderPath("file:/mydir,file:/yourdir");
 		vc.afterPropertiesSet();
-		assertTrue(vc.createVelocityEngine() instanceof VelocityEngine);
+		assertThat(vc.createVelocityEngine(), instanceOf(VelocityEngine.class));
 		VelocityEngine ve = vc.createVelocityEngine();
 		Vector paths = new Vector();
 		paths.add(new File("/mydir").getAbsolutePath());
@@ -149,7 +152,7 @@ public ClassLoader getClassLoader() {
 		});
 		vc.setPreferFileSystemAccess(false);
 		vc.afterPropertiesSet();
-		assertTrue(vc.createVelocityEngine() instanceof VelocityEngine);
+		assertThat(vc.createVelocityEngine(), instanceOf(VelocityEngine.class));
 		VelocityEngine ve = vc.createVelocityEngine();
 		assertEquals("test", VelocityEngineUtils.mergeTemplateIntoString(ve, "test", new HashMap()));
 	}
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/velocity/VelocityViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/velocity/VelocityViewTests.java
index ac1a396f6596..dd0f8749d1e3 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/velocity/VelocityViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/velocity/VelocityViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,6 @@
 
 package org.springframework.web.servlet.view.velocity;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.expectLastCall;
-import static org.easymock.EasyMock.replay;
-import static org.easymock.EasyMock.verify;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Locale;
@@ -53,6 +44,9 @@
 import org.springframework.web.servlet.support.RequestDataValueProcessor;
 import org.springframework.web.servlet.view.AbstractView;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Rod Johnson
  * @author Juergen Hoeller
@@ -63,12 +57,8 @@ public class VelocityViewTests {
 	@Test
 	public void testNoVelocityConfig() throws Exception {
 		VelocityView vv = new VelocityView();
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
-		wac.getBeansOfType(VelocityConfig.class, true, false);
-		expectLastCall().andReturn(new HashMap<String, Object>());
-		wac.getParentBeanFactory();
-		expectLastCall().andReturn(null);
-		replay(wac);
+		WebApplicationContext wac = mock(WebApplicationContext.class);
+		given(wac.getBeansOfType(VelocityConfig.class, true, false)).willReturn(new HashMap<String, VelocityConfig>());
 
 		vv.setUrl("anythingButNull");
 		try {
@@ -79,8 +69,6 @@ public void testNoVelocityConfig() throws Exception {
 			// Check there's a helpful error message
 			assertTrue(ex.getMessage().contains("VelocityConfig"));
 		}
-
-		verify(wac);
 	}
 
 	@Test
@@ -131,7 +119,7 @@ private void testValidTemplateName(final Exception mergeTemplateFailureException
 
 		final String templateName = "test.vm";
 
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
+		WebApplicationContext wac = mock(WebApplicationContext.class);
 		MockServletContext sc = new MockServletContext();
 		sc.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
 
@@ -142,17 +130,12 @@ public VelocityEngine getVelocityEngine() {
 				return new TestVelocityEngine(templateName, expectedTemplate);
 			}
 		};
-		wac.getBeansOfType(VelocityConfig.class, true, false);
-		Map<String, Object> configurers = new HashMap<String, Object>();
+		Map<String, VelocityConfig> configurers = new HashMap<String, VelocityConfig>();
 		configurers.put("velocityConfigurer", vc);
-		expectLastCall().andReturn(configurers);
-		wac.getParentBeanFactory();
-		expectLastCall().andReturn(null);
-		wac.getServletContext();
-		expectLastCall().andReturn(sc).times(3);
-		wac.getBean("requestDataValueProcessor", RequestDataValueProcessor.class);
-		expectLastCall().andReturn(null);
-		replay(wac);
+		given(wac.getBeansOfType(VelocityConfig.class, true, false)).willReturn(configurers);
+		given(wac.getServletContext()).willReturn(sc);
+		given(wac.getBean("requestDataValueProcessor",
+				RequestDataValueProcessor.class)).willReturn(null);
 
 		HttpServletRequest request = new MockHttpServletRequest();
 		final HttpServletResponse expectedResponse = new MockHttpServletResponse();
@@ -182,15 +165,13 @@ protected void mergeTemplate(Template template, Context context, HttpServletResp
 			assertNotNull(mergeTemplateFailureException);
 			assertEquals(ex, mergeTemplateFailureException);
 		}
-
-		verify(wac);
 	}
 
 	@Test
 	public void testKeepExistingContentType() throws Exception {
 		final String templateName = "test.vm";
 
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
+		WebApplicationContext wac = mock(WebApplicationContext.class);
 		MockServletContext sc = new MockServletContext();
 		sc.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);
 
@@ -201,17 +182,12 @@ public VelocityEngine getVelocityEngine() {
 				return new TestVelocityEngine(templateName, expectedTemplate);
 			}
 		};
-		wac.getBeansOfType(VelocityConfig.class, true, false);
-		Map<String, Object> configurers = new HashMap<String, Object>();
+		Map<String, VelocityConfig> configurers = new HashMap<String, VelocityConfig>();
 		configurers.put("velocityConfigurer", vc);
-		expectLastCall().andReturn(configurers);
-		wac.getParentBeanFactory();
-		expectLastCall().andReturn(null);
-		wac.getServletContext();
-		expectLastCall().andReturn(sc).times(3);
-		wac.getBean("requestDataValueProcessor", RequestDataValueProcessor.class);
-		expectLastCall().andReturn(null);
-		replay(wac);
+		given(wac.getBeansOfType(VelocityConfig.class, true, false)).willReturn(configurers);
+		given(wac.getServletContext()).willReturn(sc);
+		given(wac.getBean("requestDataValueProcessor",
+				RequestDataValueProcessor.class)).willReturn(null);
 
 		HttpServletRequest request = new MockHttpServletRequest();
 		final HttpServletResponse expectedResponse = new MockHttpServletResponse();
@@ -233,7 +209,6 @@ protected void exposeHelpers(Map<String, Object> model, HttpServletRequest reque
 		vv.setApplicationContext(wac);
 		vv.render(new HashMap<String, Object>(), request, expectedResponse);
 
-		verify(wac);
 		assertEquals("myContentType", expectedResponse.getContentType());
 	}
 
@@ -241,11 +216,8 @@ protected void exposeHelpers(Map<String, Object> model, HttpServletRequest reque
 	public void testExposeHelpers() throws Exception {
 		final String templateName = "test.vm";
 
-		WebApplicationContext wac = createMock(WebApplicationContext.class);
-		wac.getParentBeanFactory();
-		expectLastCall().andReturn(null);
-		wac.getServletContext();
-		expectLastCall().andReturn(new MockServletContext());
+		WebApplicationContext wac = mock(WebApplicationContext.class);
+		given(wac.getServletContext()).willReturn(new MockServletContext());
 
 		final Template expectedTemplate = new Template();
 		VelocityConfig vc = new VelocityConfig() {
@@ -254,22 +226,16 @@ public VelocityEngine getVelocityEngine() {
 				return new TestVelocityEngine(templateName, expectedTemplate);
 			}
 		};
-		wac.getBeansOfType(VelocityConfig.class, true, false);
-		Map<String, Object> configurers = new HashMap<String, Object>();
+		Map<String, VelocityConfig> configurers = new HashMap<String, VelocityConfig>();
 		configurers.put("velocityConfigurer", vc);
-		expectLastCall().andReturn(configurers);
-		replay(wac);
+		given(wac.getBeansOfType(VelocityConfig.class, true, false)).willReturn(configurers);
 
 
 		// let it ask for locale
-		HttpServletRequest req = createMock(HttpServletRequest.class);
-		req.getAttribute(View.PATH_VARIABLES);
-		expectLastCall().andReturn(null);
-		req.getAttribute(DispatcherServlet.LOCALE_RESOLVER_ATTRIBUTE);
-		expectLastCall().andReturn(new AcceptHeaderLocaleResolver());
-		req.getLocale();
-		expectLastCall().andReturn(Locale.CANADA);
-		replay(req);
+		HttpServletRequest req = mock(HttpServletRequest.class);
+		given(req.getAttribute(View.PATH_VARIABLES)).willReturn(null);
+		given(req.getAttribute(DispatcherServlet.LOCALE_RESOLVER_ATTRIBUTE)).willReturn(new AcceptHeaderLocaleResolver());
+		given(req.getLocale()).willReturn(Locale.CANADA);
 
 		final HttpServletResponse expectedResponse = new MockHttpServletResponse();
 
@@ -308,8 +274,6 @@ protected void exposeHelpers(Map<String, Object> model, HttpServletRequest reque
 
 		vv.render(new HashMap<String, Object>(), req, expectedResponse);
 
-		verify(wac);
-		verify(req);
 		assertEquals(AbstractView.DEFAULT_CONTENT_TYPE, expectedResponse.getContentType());
 	}
 
diff --git a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/xml/MarshallingViewTests.java b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/xml/MarshallingViewTests.java
index d51fc618bfa4..6b767c7f78e2 100644
--- a/spring-webmvc/src/test/java/org/springframework/web/servlet/view/xml/MarshallingViewTests.java
+++ b/spring-webmvc/src/test/java/org/springframework/web/servlet/view/xml/MarshallingViewTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,18 +18,19 @@
 
 import java.util.HashMap;
 import java.util.Map;
+
 import javax.servlet.ServletException;
 import javax.xml.transform.stream.StreamResult;
 
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
 import org.junit.Before;
 import org.junit.Test;
-
 import org.springframework.mock.web.test.MockHttpServletRequest;
 import org.springframework.mock.web.test.MockHttpServletResponse;
 import org.springframework.oxm.Marshaller;
 
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * @author Arjen Poutsma
  */
@@ -41,7 +42,7 @@ public class MarshallingViewTests {
 
 	@Before
 	public void createView() throws Exception {
-		marshallerMock = createMock(Marshaller.class);
+		marshallerMock = mock(Marshaller.class);
 		view = new MarshallingView(marshallerMock);
 	}
 
@@ -71,14 +72,12 @@ public void renderModelKey() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest();
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		expect(marshallerMock.supports(Object.class)).andReturn(true);
+		given(marshallerMock.supports(Object.class)).willReturn(true);
 		marshallerMock.marshal(eq(toBeMarshalled), isA(StreamResult.class));
 
-		replay(marshallerMock);
 		view.render(model, request, response);
 		assertEquals("Invalid content type", "application/xml", response.getContentType());
 		assertEquals("Invalid content length", 0, response.getContentLength());
-		verify(marshallerMock);
 	}
 
 	@Test
@@ -92,7 +91,6 @@ public void renderInvalidModelKey() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest();
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		replay(marshallerMock);
 		try {
 			view.render(model, request, response);
 			fail("ServletException expected");
@@ -101,7 +99,6 @@ public void renderInvalidModelKey() throws Exception {
 			// expected
 		}
 		assertEquals("Invalid content length", 0, response.getContentLength());
-		verify(marshallerMock);
 	}
 
 	@Test
@@ -113,7 +110,6 @@ public void renderNullModelValue() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest();
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		replay(marshallerMock);
 		try {
 			view.render(model, request, response);
 			fail("ServletException expected");
@@ -122,7 +118,6 @@ public void renderNullModelValue() throws Exception {
 			// expected
 		}
 		assertEquals("Invalid content length", 0, response.getContentLength());
-		verify(marshallerMock);
 	}
 
 	@Test
@@ -136,9 +131,8 @@ public void renderModelKeyUnsupported() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest();
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		expect(marshallerMock.supports(Object.class)).andReturn(false);
+		given(marshallerMock.supports(Object.class)).willReturn(false);
 
-		replay(marshallerMock);
 		try {
 			view.render(model, request, response);
 			fail("ServletException expected");
@@ -146,7 +140,6 @@ public void renderModelKeyUnsupported() throws Exception {
 		catch (ServletException ex) {
 			// expected
 		}
-		verify(marshallerMock);
 	}
 
 	@Test
@@ -159,14 +152,12 @@ public void renderNoModelKey() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest();
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		expect(marshallerMock.supports(Object.class)).andReturn(true);
-		marshallerMock.marshal(eq(toBeMarshalled), isA(StreamResult.class));
+		given(marshallerMock.supports(Object.class)).willReturn(true);
 
-		replay(marshallerMock);
 		view.render(model, request, response);
 		assertEquals("Invalid content type", "application/xml", response.getContentType());
 		assertEquals("Invalid content length", 0, response.getContentLength());
-		verify(marshallerMock);
+		verify(marshallerMock).marshal(eq(toBeMarshalled), isA(StreamResult.class));
 	}
 
 	@Test
@@ -179,9 +170,8 @@ public void testRenderUnsupportedModel() throws Exception {
 		MockHttpServletRequest request = new MockHttpServletRequest();
 		MockHttpServletResponse response = new MockHttpServletResponse();
 
-		expect(marshallerMock.supports(Object.class)).andReturn(false);
+		given(marshallerMock.supports(Object.class)).willReturn(false);
 
-		replay(marshallerMock);
 		try {
 			view.render(model, request, response);
 			fail("ServletException expected");
@@ -189,7 +179,6 @@ public void testRenderUnsupportedModel() throws Exception {
 		catch (ServletException ex) {
 			// expected
 		}
-		verify(marshallerMock);
 	}
 
 }
diff --git a/src/api/stylesheet.css b/src/api/stylesheet.css
new file mode 100644
index 000000000000..4b105f4ca418
--- /dev/null
+++ b/src/api/stylesheet.css
@@ -0,0 +1,541 @@
+/* Javadoc style sheet */
+
+/*
+Overall document style
+*/
+body {
+    background-color:#ffffff;
+    color:#353833;
+    font-family:Arial, Helvetica, sans-serif;
+    font-size:76%;
+    margin:0;
+}
+a:link, a:visited {
+    text-decoration:none;
+    color:#4c6b87;
+}
+a:hover, a:focus {
+    text-decoration:none;
+    color:#bb7a2a;
+}
+a:active {
+    text-decoration:none;
+    color:#4c6b87;
+}
+a[name] {
+    color:#353833;
+}
+a[name]:hover {
+    text-decoration:none;
+    color:#353833;
+}
+pre {
+    font-size:1.3em;
+}
+h1 {
+    font-size:1.8em;
+}
+h2 {
+    font-size:1.5em;
+}
+h3 {
+    font-size:1.4em;
+}
+h4 {
+    font-size:1.3em;
+}
+h5 {
+    font-size:1.2em;
+}
+h6 {
+    font-size:1.1em;
+}
+ul {
+    list-style-type:disc;
+}
+code, tt {
+    font-size:1.2em;
+}
+dt code {
+    font-size:1.2em;
+}
+table tr td dt code {
+    font-size:1.2em;
+    vertical-align:top;
+}
+sup {
+    font-size:.6em;
+}
+/*
+Document title and Copyright styles
+*/
+.clear {
+    clear:both;
+    height:0px;
+    overflow:hidden;
+}
+.aboutLanguage {
+    float:right;
+    padding:0px 21px;
+    font-size:.8em;
+    z-index:200;
+    margin-top:-7px;
+}
+.legalCopy {
+    margin-left:.5em;
+}
+.bar a, .bar a:link, .bar a:visited, .bar a:active {
+    color:#FFFFFF;
+    text-decoration:none;
+}
+.bar a:hover, .bar a:focus {
+    color:#bb7a2a;
+}
+.tab {
+    background-color:#0066FF;
+    background-image:url(resources/titlebar.gif);
+    background-position:left top;
+    background-repeat:no-repeat;
+    color:#ffffff;
+    padding:8px;
+    width:5em;
+    font-weight:bold;
+}
+/*
+Navigation bar styles
+*/
+.bar {
+    background-image:url(resources/background.gif);
+    background-repeat:repeat-x;
+    color:#FFFFFF;
+    padding:.8em .5em .4em .8em;
+    height:auto;/*height:1.8em;*/
+    font-size:1em;
+    margin:0;
+}
+.topNav {
+    background-image:url(resources/background.gif);
+    background-repeat:repeat-x;
+    color:#FFFFFF;
+    float:left;
+    padding:0;
+    width:100%;
+    clear:right;
+    height:2.8em;
+    padding-top:10px;
+    overflow:hidden;
+}
+.bottomNav {
+    margin-top:10px;
+    background-image:url(resources/background.gif);
+    background-repeat:repeat-x;
+    color:#FFFFFF;
+    float:left;
+    padding:0;
+    width:100%;
+    clear:right;
+    height:2.8em;
+    padding-top:10px;
+    overflow:hidden;
+}
+.subNav {
+    background-color:#dee3e9;
+    border-bottom:1px solid #9eadc0;
+    float:left;
+    width:100%;
+    overflow:hidden;
+}
+.subNav div {
+    clear:left;
+    float:left;
+    padding:0 0 5px 6px;
+}
+ul.navList, ul.subNavList {
+    float:left;
+    margin:0 25px 0 0;
+    padding:0;
+}
+ul.navList li{
+    list-style:none;
+    float:left;
+    padding:3px 6px;
+}
+ul.subNavList li{
+    list-style:none;
+    float:left;
+    font-size:90%;
+}
+.topNav a:link, .topNav a:active, .topNav a:visited, .bottomNav a:link, .bottomNav a:active, .bottomNav a:visited {
+    color:#FFFFFF;
+    text-decoration:none;
+}
+.topNav a:hover, .bottomNav a:hover {
+    text-decoration:none;
+    color:#bb7a2a;
+}
+.navBarCell1Rev {
+    background-image:url(resources/tab.gif);
+    background-color:#a88834;
+    color:#FFFFFF;
+    margin: auto 5px;
+    border:1px solid #c9aa44;
+}
+/*
+Page header and footer styles
+*/
+.header, .footer {
+    clear:both;
+    margin:0 20px;
+    padding:5px 0 0 0;
+}
+.indexHeader {
+    margin:10px;
+    position:relative;
+}
+.indexHeader h1 {
+    font-size:1.3em;
+}
+.title {
+    color:#2c4557;
+    margin:10px 0;
+}
+.subTitle {
+    margin:5px 0 0 0;
+}
+.header ul {
+    margin:0 0 25px 0;
+    padding:0;
+}
+.footer ul {
+    margin:20px 0 5px 0;
+}
+.header ul li, .footer ul li {
+    list-style:none;
+    font-size:1.2em;
+}
+/*
+Heading styles
+*/
+div.details ul.blockList ul.blockList ul.blockList li.blockList h4, div.details ul.blockList ul.blockList ul.blockListLast li.blockList h4 {
+    background-color:#dee3e9;
+    border-top:1px solid #9eadc0;
+    border-bottom:1px solid #9eadc0;
+    margin:0 0 6px -8px;
+    padding:2px 5px;
+}
+ul.blockList ul.blockList ul.blockList li.blockList h3 {
+    background-color:#dee3e9;
+    border-top:1px solid #9eadc0;
+    border-bottom:1px solid #9eadc0;
+    margin:0 0 6px -8px;
+    padding:2px 5px;
+}
+ul.blockList ul.blockList li.blockList h3 {
+    padding:0;
+    margin:15px 0;
+}
+ul.blockList li.blockList h2 {
+    padding:0px 0 20px 0;
+}
+/*
+Page layout container styles
+*/
+.contentContainer, .sourceContainer, .classUseContainer, .serializedFormContainer, .constantValuesContainer {
+    clear:both;
+    padding:10px 20px;
+    position:relative;
+}
+.indexContainer {
+    margin:10px;
+    position:relative;
+    font-size:1.0em;
+}
+.indexContainer h2 {
+    font-size:1.1em;
+    padding:0 0 3px 0;
+}
+.indexContainer ul {
+    margin:0;
+    padding:0;
+}
+.indexContainer ul li {
+    list-style:none;
+}
+.contentContainer .description dl dt, .contentContainer .details dl dt, .serializedFormContainer dl dt {
+    font-size:1.1em;
+    font-weight:bold;
+    margin:10px 0 0 0;
+    color:#4E4E4E;
+}
+.contentContainer .description dl dd, .contentContainer .details dl dd, .serializedFormContainer dl dd {
+    margin:10px 0 10px 20px;
+}
+.serializedFormContainer dl.nameValue dt {
+    margin-left:1px;
+    font-size:1.1em;
+    display:inline;
+    font-weight:bold;
+}
+.serializedFormContainer dl.nameValue dd {
+    margin:0 0 0 1px;
+    font-size:1.1em;
+    display:inline;
+}
+/*
+List styles
+*/
+ul.horizontal li {
+    display:inline;
+    font-size:0.9em;
+}
+ul.inheritance {
+    margin:0;
+    padding:0;
+}
+ul.inheritance li {
+    display:inline;
+    list-style:none;
+}
+ul.inheritance li ul.inheritance {
+    margin-left:15px;
+    padding-left:15px;
+    padding-top:1px;
+}
+ul.blockList, ul.blockListLast {
+    margin:10px 0 10px 0;
+    padding:0;
+}
+ul.blockList li.blockList, ul.blockListLast li.blockList {
+    list-style:none;
+    margin-bottom:25px;
+}
+ul.blockList ul.blockList li.blockList, ul.blockList ul.blockListLast li.blockList {
+    padding:0px 20px 5px 10px;
+    border:1px solid #9eadc0;
+    background-color:#f9f9f9;
+}
+ul.blockList ul.blockList ul.blockList li.blockList, ul.blockList ul.blockList ul.blockListLast li.blockList {
+    padding:0 0 5px 8px;
+    background-color:#ffffff;
+    border:1px solid #9eadc0;
+    border-top:none;
+}
+ul.blockList ul.blockList ul.blockList ul.blockList li.blockList {
+    margin-left:0;
+    padding-left:0;
+    padding-bottom:15px;
+    border:none;
+    border-bottom:1px solid #9eadc0;
+}
+ul.blockList ul.blockList ul.blockList ul.blockList li.blockListLast {
+    list-style:none;
+    border-bottom:none;
+    padding-bottom:0;
+}
+table tr td dl, table tr td dl dt, table tr td dl dd {
+    margin-top:0;
+    margin-bottom:1px;
+}
+/*
+Table styles
+*/
+.contentContainer table, .classUseContainer table, .constantValuesContainer table {
+    border-bottom:1px solid #9eadc0;
+    width:100%;
+}
+.contentContainer ul li table, .classUseContainer ul li table, .constantValuesContainer ul li table {
+    width:100%;
+}
+.contentContainer .description table, .contentContainer .details table {
+    border-bottom:none;
+}
+.contentContainer ul li table th.colOne, .contentContainer ul li table th.colFirst, .contentContainer ul li table th.colLast, .classUseContainer ul li table th, .constantValuesContainer ul li table th, .contentContainer ul li table td.colOne, .contentContainer ul li table td.colFirst, .contentContainer ul li table td.colLast, .classUseContainer ul li table td, .constantValuesContainer ul li table td{
+    vertical-align:top;
+    padding-right:20px;
+}
+.contentContainer ul li table th.colLast, .classUseContainer ul li table th.colLast,.constantValuesContainer ul li table th.colLast,
+.contentContainer ul li table td.colLast, .classUseContainer ul li table td.colLast,.constantValuesContainer ul li table td.colLast,
+.contentContainer ul li table th.colOne, .classUseContainer ul li table th.colOne,
+.contentContainer ul li table td.colOne, .classUseContainer ul li table td.colOne {
+    padding-right:3px;
+}
+.overviewSummary caption, .packageSummary caption, .contentContainer ul.blockList li.blockList caption, .summary caption, .classUseContainer caption, .constantValuesContainer caption {
+    position:relative;
+    text-align:left;
+    background-repeat:no-repeat;
+    color:#FFFFFF;
+    font-weight:bold;
+    clear:none;
+    overflow:hidden;
+    padding:0px;
+    margin:0px;
+}
+caption a:link, caption a:hover, caption a:active, caption a:visited {
+    color:#FFFFFF;
+}
+.overviewSummary caption span, .packageSummary caption span, .contentContainer ul.blockList li.blockList caption span, .summary caption span, .classUseContainer caption span, .constantValuesContainer caption span {
+    white-space:nowrap;
+    padding-top:8px;
+    padding-left:8px;
+    display:block;
+    float:left;
+    background-image:url(resources/titlebar.gif);
+    height:18px;
+}
+.contentContainer ul.blockList li.blockList caption span.activeTableTab span {
+    white-space:nowrap;
+    padding-top:8px;
+    padding-left:8px;
+    display:block;
+    float:left;
+    background-image:url(resources/activetitlebar.gif);
+    height:18px;
+}
+.contentContainer ul.blockList li.blockList caption span.tableTab span {
+    white-space:nowrap;
+    padding-top:8px;
+    padding-left:8px;
+    display:block;
+    float:left;
+    background-image:url(resources/titlebar.gif);
+    height:18px;
+}
+.contentContainer ul.blockList li.blockList caption span.tableTab, .contentContainer ul.blockList li.blockList caption span.activeTableTab {
+    padding-top:0px;
+    padding-left:0px;
+    background-image:none;
+    float:none;
+    display:inline;
+}
+.overviewSummary .tabEnd, .packageSummary .tabEnd, .contentContainer ul.blockList li.blockList .tabEnd, .summary .tabEnd, .classUseContainer .tabEnd, .constantValuesContainer .tabEnd {
+    width:10px;
+    background-image:url(resources/titlebar_end.gif);
+    background-repeat:no-repeat;
+    background-position:top right;
+    position:relative;
+    float:left;
+}
+.contentContainer ul.blockList li.blockList .activeTableTab .tabEnd {
+    width:10px;
+    margin-right:5px;
+    background-image:url(resources/activetitlebar_end.gif);
+    background-repeat:no-repeat;
+    background-position:top right;
+    position:relative;
+    float:left;
+}
+.contentContainer ul.blockList li.blockList .tableTab .tabEnd {
+    width:10px;
+    margin-right:5px;
+    background-image:url(resources/titlebar_end.gif);
+    background-repeat:no-repeat;
+    background-position:top right;
+    position:relative;
+    float:left;
+}
+ul.blockList ul.blockList li.blockList table {
+    margin:0 0 12px 0px;
+    width:100%;
+}
+.tableSubHeadingColor {
+    background-color: #EEEEFF;
+}
+.altColor {
+    background-color:#eeeeef;
+}
+.rowColor {
+    background-color:#ffffff;
+}
+.overviewSummary td, .packageSummary td, .contentContainer ul.blockList li.blockList td, .summary td, .classUseContainer td, .constantValuesContainer td {
+    text-align:left;
+    padding:3px 3px 3px 7px;
+}
+th.colFirst, th.colLast, th.colOne, .constantValuesContainer th {
+    background:#dee3e9;
+    border-top:1px solid #9eadc0;
+    border-bottom:1px solid #9eadc0;
+    text-align:left;
+    padding:3px 3px 3px 7px;
+}
+td.colOne a:link, td.colOne a:active, td.colOne a:visited, td.colOne a:hover, td.colFirst a:link, td.colFirst a:active, td.colFirst a:visited, td.colFirst a:hover, td.colLast a:link, td.colLast a:active, td.colLast a:visited, td.colLast a:hover, .constantValuesContainer td a:link, .constantValuesContainer td a:active, .constantValuesContainer td a:visited, .constantValuesContainer td a:hover {
+    font-weight:bold;
+}
+td.colFirst, th.colFirst {
+    border-left:1px solid #9eadc0;
+    white-space:nowrap;
+}
+td.colLast, th.colLast {
+    border-right:1px solid #9eadc0;
+}
+td.colOne, th.colOne {
+    border-right:1px solid #9eadc0;
+    border-left:1px solid #9eadc0;
+}
+table.overviewSummary  {
+    padding:0px;
+    margin-left:0px;
+}
+table.overviewSummary td.colFirst, table.overviewSummary th.colFirst,
+table.overviewSummary td.colOne, table.overviewSummary th.colOne {
+    width:25%;
+    vertical-align:middle;
+}
+table.packageSummary td.colFirst, table.overviewSummary th.colFirst {
+    width:25%;
+    vertical-align:middle;
+}
+/*
+Content styles
+*/
+.description pre {
+    margin-top:0;
+}
+.deprecatedContent {
+    margin:0;
+    padding:10px 0;
+}
+.docSummary {
+    padding:0;
+}
+/*
+Formatting effect styles
+*/
+.sourceLineNo {
+    color:green;
+    padding:0 30px 0 0;
+}
+h1.hidden {
+    visibility:hidden;
+    overflow:hidden;
+    font-size:.9em;
+}
+.block {
+    display:block;
+    margin:3px 0 0 0;
+}
+.strong {
+    font-weight:bold;
+}
+
+
+/*
+Spring
+*/
+
+pre.code {
+    background-color: #F8F8F8;
+    border: 1px solid #CCCCCC;
+    border-radius: 3px 3px 3px 3px;
+    overflow: auto;
+    padding: 10px;
+    margin: 4px 20px 2px 0px;
+}
+
+pre.code code, pre.code code * {
+    font-size: 1em;
+}
+
+pre.code code, pre.code code * {
+    padding: 0 !important;
+    margin: 0 !important;
+}
diff --git a/src/dist/changelog.txt b/src/dist/changelog.txt
index 25b90985b9b6..2e605b0d963b 100644
--- a/src/dist/changelog.txt
+++ b/src/dist/changelog.txt
@@ -3,6 +3,55 @@ SPRING FRAMEWORK CHANGELOG
 http://www.springsource.org
 
 
+Changes in version 3.2.2 (2013-03-14)
+--------------------------------------
+
+* official support for Hibernate 4.2 (SPR-10255)
+* fixed missing inter-dependencies in module POMs (SPR-10218)
+* marked spring-web module as 'distributable' in order for session replication to work on Tomcat (SPR-10219)
+* DefaultListableBeanFactory caches target type per bean definition and allows for specifying it in advance (SPR-10335)
+* DefaultListableBeanFactory clears by-type matching cache on runtime register/destroySingleton calls (SPR-10326)
+* ConfigurationClassPostProcessor consistently uses ClassLoader, not loading core JDK annotations via ASM (SPR-10249)
+* ConfigurationClassPostProcessor detects covariant return type mismatch, avoiding infinite recursion (SPR-10261)
+* ConfigurationClassPostProcessor allows for overriding of scoped-proxy bean definitions (SPR-10265)
+* "depends-on" attribute on lang namespace element actually respected at runtime now (SPR-8625)
+* added locale-independent "commonMessages" property to AbstractMessageSource (SPR-10291)
+* added "maximumAutoGrowSize" property to SpelParserConfiguration (SPR-10229)
+* allow for ordering of mixed AspectJ before/after advices (SPR-9438)
+* added "beforeExistingAdvisors" flag to AbstractAdvisingBeanPostProcessor (SPR-10309)
+* MethodValidation/PersistenceExceptionTranslationPostProcessor apply after existing advisors by default (SPR-10309)
+* fixed regression in SpringValidatorAdapter's retrieval of invalid values (SPR-10243)
+* support 'unless' expression for cache veto (SPR-8871)
+* @Async's qualifier works for target class annotations behind a JDK proxy as well (SPR-10274)
+* @Scheduled provides String variants of fixedDelay, fixedRate, initialDelay for placeholder support (SPR-8067)
+* refined CronSequenceGenerator's rounding up of seconds to address second-specific cron expressions (SPR-9459)
+* @Transactional in AspectJ mode works with CallbackPreferringPlatformTransactionManager (WebSphere) as well (SPR-9268)
+* LazyConnectionDataSourceProxy catches setReadOnly exception analogous to DataSourceUtils (SPR-10312)
+* SQLErrorCodeSQLExceptionTranslator tries to find SQLException with actual error code among causes (SPR-10260)
+* added "createTemporaryLob" flag to DefaultLobHandler, using JDBC 4.0's createBlob/Clob mechanism (SPR-10339)
+* deprecated OracleLobHandler in favor of DefaultLobHandler for the Oracle 10g driver and higher (SPR-10339)
+* deprecated (NamedParameter)JdbcTemplate's queryForInt/Long operations in favor of queryForObject (SPR-10257)
+* added useful query variants without parameters to NamedParameterJdbcTemplate, for convenience in DAOs (SPR-10256)
+* "packagesToScan" feature for Hibernate 3 and Hibernate 4 detects annotated packages as well (SPR-7748, SPR-10288)
+* HibernateTransactionManager for Hibernate 4 supports "entityInterceptor(BeanName)" property (SPR-10301)
+* DefaultJdoDialect supports the JDO 2.2+ isolation level feature out of the box (SPR-10323)
+* DefaultMessageListenerContainer invokes specified ExceptionListener for recovery exceptions as well (SPR-10230)
+* DefaultMessageListenerContainer logs recovery failures at error level and exposes "isRecovering()" method (SPR-10230)
+* added "mappedClass" property to Jaxb2Marshaller, introducing support for partial unmarshalling (SPR-10282)
+* added "entityResolver", "classDescriptorResolver", "doctypes" and further properties to CastorMarshaller (SPR-8470)
+* deprecated CastorMarshaller's "object" property in favor of "rootObject" (SPR-8470)
+* MediaType throws dedicated InvalidMediaTypeException instead of generic IllegalArgumentException (SPR-10226)
+* DispatcherServlet allows for customizing its RequestAttributes exposure in subclasses (SPR-10342)
+* AbstractCachingViewResolver does not use global lock for accessing existing View instances anymore (SPR-3145)
+* MappingJackson(2)JsonView allows subclasses to access the ObjectMapper and to override content writing (SPR-7619)
+* Tiles 3 TilesConfigurer preserves standard EL support for "completeAutoload" mode as well (SPR-10361)
+* Log4jWebConfigurer supports resolving placeholders against ServletContext init-parameters as well (SPR-10284)
+* consistent use of LinkedHashMaps and independent getAttributeNames Enumeration in Servlet/Portlet mocks (SPR-10224)
+* several MockMvcBuilder refinements (SPR-10277, SPR-10279, SPR-10280)
+* introduced support for context hierarchies in the TestContext framework (SPR-5613)
+* introduced support for WebApplicationContext hierarchies in the TestContext framework (SPR-9863)
+
+
 Changes in version 3.2.1 (2013-01-24)
 --------------------------------------
 
@@ -24,7 +73,7 @@ Changes in version 3.2.1 (2013-01-24)
 * MessageSourceResourceBundle overrides JDK 1.6 containsKey method, avoiding NPE in getKeys (SPR-10136)
 * SpringValidationAdapter properly detects invalid value for JSR-303 field-level bean constraints (SPR-9332)
 * SpringBeanAutowiringInterceptor eagerly releases BeanFactory if post-construction fails (SPR-10013)
-* added "exposeAccessContext" flag JndiRmiClientInterceptor/ProxyFactoryBean (for WebLogic; SPR-9428)
+* added "exposeAccessContext" flag to JndiRmiClientInterceptor/ProxyFactoryBean (for WebLogic; SPR-9428)
 * MBeanExporter does not log warnings for manually unregistered MBeans (SPR-9451)
 * MBeanInfoAssembler impls expose actual method parameter names if possible (SPR-9985)
 * AbstractCacheManager accepts no caches defined, allowing for EHCache default cache setup (SPR-7955)
diff --git a/src/eclipse/org.eclipse.jdt.core.prefs b/src/eclipse/org.eclipse.jdt.core.prefs
index 2286420ffe92..80a095b1a1a4 100644
--- a/src/eclipse/org.eclipse.jdt.core.prefs
+++ b/src/eclipse/org.eclipse.jdt.core.prefs
@@ -23,7 +23,6 @@ org.eclipse.jdt.core.compiler.compliance=1.7
 org.eclipse.jdt.core.compiler.debug.lineNumber=generate
 org.eclipse.jdt.core.compiler.debug.localVariable=generate
 org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.doc.comment.support=enabled
 org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
 org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
 org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
@@ -47,25 +46,12 @@ org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=disabled
 org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
 org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
 org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
-org.eclipse.jdt.core.compiler.problem.invalidJavadoc=warning
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=disabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
-org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=default
 org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
 org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
 org.eclipse.jdt.core.compiler.problem.missingDefaultCase=ignore
 org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
 org.eclipse.jdt.core.compiler.problem.missingEnumCaseDespiteDefault=disabled
 org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=ignore
-org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
-org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=disabled
-org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
-org.eclipse.jdt.core.compiler.problem.missingJavadocTagDescription=return_tag
-org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
-org.eclipse.jdt.core.compiler.problem.missingJavadocTagsMethodTypeParameters=disabled
-org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=disabled
-org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=public
 org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=ignore
 org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
 org.eclipse.jdt.core.compiler.problem.missingSerialVersion=ignore
diff --git a/src/eclipse/org.eclipse.jdt.ui.prefs b/src/eclipse/org.eclipse.jdt.ui.prefs
index 4aa12d7db504..7631dce007a0 100644
--- a/src/eclipse/org.eclipse.jdt.ui.prefs
+++ b/src/eclipse/org.eclipse.jdt.ui.prefs
@@ -55,8 +55,8 @@ eclipse.preferences.version=1
 formatter_profile=_Spring
 formatter_settings_version=12
 org.eclipse.jdt.ui.ignorelowercasenames=true
-org.eclipse.jdt.ui.importorder=java;javax;org;com;
+org.eclipse.jdt.ui.importorder=java;javax;org;com;\#;
 org.eclipse.jdt.ui.javadoc=true
 org.eclipse.jdt.ui.ondemandthreshold=9999
-org.eclipse.jdt.ui.staticondemandthreshold=9999
+org.eclipse.jdt.ui.staticondemandthreshold=1
 org.eclipse.jdt.ui.text.custom_code_templates=<?xml version\="1.0" encoding\="UTF-8" standalone\="no"?><templates><template autoinsert\="true" context\="gettercomment_context" deleted\="false" description\="Comment for getter method" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.gettercomment" name\="gettercomment">/**\n * @return the ${bare_field_name}\n */</template><template autoinsert\="true" context\="settercomment_context" deleted\="false" description\="Comment for setter method" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.settercomment" name\="settercomment">/**\n * @param ${param} the ${bare_field_name} to set\n */</template><template autoinsert\="true" context\="constructorcomment_context" deleted\="false" description\="Comment for created constructors" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.constructorcomment" name\="constructorcomment">/**\n * ${tags}\n */</template><template autoinsert\="false" context\="filecomment_context" deleted\="false" description\="Comment for created Java files" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.filecomment" name\="filecomment">/*\n * Copyright 2002-2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http\://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n</template><template autoinsert\="false" context\="typecomment_context" deleted\="false" description\="Comment for created types" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.typecomment" name\="typecomment">/**\n * ${tags}\n * @author ${user}\n */</template><template autoinsert\="true" context\="fieldcomment_context" deleted\="false" description\="Comment for fields" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.fieldcomment" name\="fieldcomment">/**\n * \n */</template><template autoinsert\="true" context\="methodcomment_context" deleted\="false" description\="Comment for non-overriding methods" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.methodcomment" name\="methodcomment">/**\n * ${tags}\n */</template><template autoinsert\="true" context\="overridecomment_context" deleted\="false" description\="Comment for overriding methods" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.overridecomment" name\="overridecomment">/* (non-Javadoc)\n * ${see_to_overridden}\n */</template><template autoinsert\="true" context\="delegatecomment_context" deleted\="false" description\="Comment for delegate methods" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.delegatecomment" name\="delegatecomment">/**\n * ${tags}\n * ${see_to_target}\n */</template><template autoinsert\="true" context\="newtype_context" deleted\="false" description\="Newly created files" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.newtype" name\="newtype">${filecomment}\n${package_declaration}\n\n${typecomment}\n${type_declaration}</template><template autoinsert\="true" context\="classbody_context" deleted\="false" description\="Code in new class type bodies" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.classbody" name\="classbody">\n</template><template autoinsert\="true" context\="interfacebody_context" deleted\="false" description\="Code in new interface type bodies" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.interfacebody" name\="interfacebody">\n</template><template autoinsert\="true" context\="enumbody_context" deleted\="false" description\="Code in new enum type bodies" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.enumbody" name\="enumbody">\n</template><template autoinsert\="true" context\="annotationbody_context" deleted\="false" description\="Code in new annotation type bodies" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.annotationbody" name\="annotationbody">\n</template><template autoinsert\="true" context\="catchblock_context" deleted\="false" description\="Code in new catch blocks" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.catchblock" name\="catchblock">// ${todo} Auto-generated catch block\n${exception_var}.printStackTrace();</template><template autoinsert\="false" context\="methodbody_context" deleted\="false" description\="Code in created method stubs" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.methodbody" name\="methodbody">// ${todo} Auto-generated method stub\nthrow new UnsupportedOperationException("Auto-generated method stub");</template><template autoinsert\="true" context\="constructorbody_context" deleted\="false" description\="Code in created constructor stubs" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.constructorbody" name\="constructorbody">${body_statement}\n// ${todo} Auto-generated constructor stub</template><template autoinsert\="true" context\="getterbody_context" deleted\="false" description\="Code in created getters" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.getterbody" name\="getterbody">return ${field};</template><template autoinsert\="true" context\="setterbody_context" deleted\="false" description\="Code in created setters" enabled\="true" id\="org.eclipse.jdt.ui.text.codetemplates.setterbody" name\="setterbody">${field} \= ${param};</template></templates>
diff --git a/src/reference/docbook/aop-api.xml b/src/reference/docbook/aop-api.xml
index 4099fbc940e7..a616d7b30d15 100644
--- a/src/reference/docbook/aop-api.xml
+++ b/src/reference/docbook/aop-api.xml
@@ -1405,32 +1405,32 @@ assertEquals("Added two advisors",
   </section>
 
   <section xml:id="aop-autoproxy">
-    <title>Using the "autoproxy" facility</title>
+    <title>Using the "auto-proxy" facility</title>
 
     <para>So far we've considered explicit creation of AOP proxies using a
     <literal>ProxyFactoryBean</literal> or similar factory bean.</para>
 
-    <para>Spring also allows us to use "autoproxy" bean definitions, which can
+    <para>Spring also allows us to use "auto-proxy" bean definitions, which can
     automatically proxy selected bean definitions. This is built on Spring
     "bean post processor" infrastructure, which enables modification of any
     bean definition as the container loads.</para>
 
     <para>In this model, you set up some special bean definitions in your XML
     bean definition file to configure the auto proxy infrastructure. This
-    allows you just to declare the targets eligible for autoproxying: you
+    allows you just to declare the targets eligible for auto-proxying: you
     don't need to use <literal>ProxyFactoryBean</literal>.</para>
 
     <para>There are two ways to do this:</para>
 
     <itemizedlist>
       <listitem>
-        <para>Using an autoproxy creator that refers to specific beans in the
+        <para>Using an auto-proxy creator that refers to specific beans in the
         current context.</para>
       </listitem>
 
       <listitem>
-        <para>A special case of autoproxy creation that deserves to be
-        considered separately; autoproxy creation driven by source-level
+        <para>A special case of auto-proxy creation that deserves to be
+        considered separately; auto-proxy creation driven by source-level
         metadata attributes.</para>
       </listitem>
     </itemizedlist>
@@ -1439,7 +1439,7 @@ assertEquals("Added two advisors",
       <title>Autoproxy bean definitions</title>
 
       <para>The <literal>org.springframework.aop.framework.autoproxy</literal>
-      package provides the following standard autoproxy creators.</para>
+      package provides the following standard auto-proxy creators.</para>
 
       <section xml:id="aop-api-autoproxy">
         <title>BeanNameAutoProxyCreator</title>
@@ -1484,7 +1484,7 @@ assertEquals("Added two advisors",
         <para>A more general and extremely powerful auto proxy creator is
         <literal>DefaultAdvisorAutoProxyCreator</literal>. This will
         automagically apply eligible advisors in the current context, without
-        the need to include specific bean names in the autoproxy advisor's
+        the need to include specific bean names in the auto-proxy advisor's
         bean definition. It offers the same merit of consistent configuration
         and avoidance of duplication as
         <literal>BeanNameAutoProxyCreator</literal>.</para>
@@ -1561,7 +1561,7 @@ assertEquals("Added two advisors",
         <title>AbstractAdvisorAutoProxyCreator</title>
 
         <para>This is the superclass of DefaultAdvisorAutoProxyCreator. You
-        can create your own autoproxy creators by subclassing this class, in
+        can create your own auto-proxy creators by subclassing this class, in
         the unlikely event that advisor definitions offer insufficient
         customization to the behavior of the framework
         <literal>DefaultAdvisorAutoProxyCreator</literal>.</para>
@@ -1571,17 +1571,17 @@ assertEquals("Added two advisors",
     <section xml:id="aop-autoproxy-metadata">
       <title>Using metadata-driven auto-proxying</title>
 
-      <para>A particularly important type of autoproxying is driven by
+      <para>A particularly important type of auto-proxying is driven by
       metadata. This produces a similar programming model to .NET
-      <literal>ServicedComponents</literal>. Instead of using XML deployment
-      descriptors as in EJB, configuration for transaction management and
+      <literal>ServicedComponents</literal>. Instead of defining metadata
+      in XML descriptors, configuration for transaction management and
       other enterprise services is held in source-level attributes.</para>
 
       <para>In this case, you use the
       <literal>DefaultAdvisorAutoProxyCreator</literal>, in combination with
       Advisors that understand metadata attributes. The metadata specifics are
       held in the pointcut part of the candidate advisors, rather than in the
-      autoproxy creation class itself.</para>
+      auto-proxy creation class itself.</para>
 
       <para>This is really a special case of the
       <literal>DefaultAdvisorAutoProxyCreator</literal>, but deserves
@@ -1589,8 +1589,8 @@ assertEquals("Added two advisors",
       contained in the advisors, not the AOP framework itself.)</para>
 
       <para>The <literal>/attributes</literal> directory of the JPetStore
-      sample application shows the use of attribute-driven autoproxying. In
-      this case, there's no need to use the
+      sample application shows the use of attribute-driven auto-proxying.
+      In this case, there's no need to use the
       <literal>TransactionProxyFactoryBean</literal>. Simply defining
       transactional attributes on business objects is sufficient, because of
       the use of metadata-aware pointcuts. The bean definitions include the
@@ -1669,7 +1669,7 @@ assertEquals("Added two advisors",
         to that of .NET ServicedComponents.</para>
       </tip>
 
-      <para>This mechanism is extensible. It's possible to do autoproxying
+      <para>This mechanism is extensible. It's possible to do auto-proxying
       based on custom attributes. You need to:</para>
 
       <itemizedlist>
@@ -1866,8 +1866,8 @@ System.out.println("Max pool size is " + conf.getMaxSize());</programlisting>
         if resources are cached.</para>
       </note>
 
-      <para>Simpler pooling is available using autoproxying. It's possible to
-      set the TargetSources used by any autoproxy creator.</para>
+      <para>Simpler pooling is available using auto-proxying. It's possible to
+      set the TargetSources used by any auto-proxy creator.</para>
     </section>
 
     <section xml:id="aop-ts-prototype">
diff --git a/src/reference/docbook/aop.xml b/src/reference/docbook/aop.xml
index 7078e1535aa7..fafebe612761 100644
--- a/src/reference/docbook/aop.xml
+++ b/src/reference/docbook/aop.xml
@@ -2847,8 +2847,8 @@ public class Account {
 
       <para>When used as a marker interface in this way, Spring will configure
       new instances of the annotated type (<classname>Account</classname> in
-      this case) using a prototype-scoped bean definition with the same name
-      as the fully-qualified type name
+      this case) using a bean definition (typically prototype-scoped) with the
+      same name as the fully-qualified type name
       (<classname>com.xyz.myapp.domain.Account</classname>). Since the default
       name for a bean is the fully-qualified name of its type, a convenient
       way to declare the prototype definition is simply to omit the
@@ -2875,7 +2875,7 @@ public class Account {
       new <classname>Account</classname> instances.</para>
 
       <para>You can also use autowiring to avoid having to specify a
-      prototype-scoped bean definition at all. To have Spring apply autowiring
+      dedicated bean definition at all. To have Spring apply autowiring
       use the '<literal>autowire</literal>' property of the
       <interfacename>@Configurable</interfacename> annotation: specify either
       <literal>@Configurable(autowire=Autowire.BY_TYPE)</literal> or
@@ -2969,8 +2969,8 @@ public class AppConfig {
 
       <para>Instances of <interfacename>@Configurable</interfacename> objects
       created <emphasis>before</emphasis> the aspect has been configured will
-      result in a warning being issued to the log and no configuration of the
-      object taking place. An example might be a bean in the Spring
+      result in a message being issued to the debug log and no configuration
+      of the object taking place. An example might be a bean in the Spring
       configuration that creates domain objects when it is initialized by
       Spring. In this case you can use the "depends-on" bean attribute to
       manually specify that the bean depends on the configuration
diff --git a/src/reference/docbook/beans-customizing.xml b/src/reference/docbook/beans-customizing.xml
index acca5514a746..9e5c4284b98a 100644
--- a/src/reference/docbook/beans-customizing.xml
+++ b/src/reference/docbook/beans-customizing.xml
@@ -13,18 +13,25 @@
   <section xml:id="beans-factory-lifecycle">
     <title>Lifecycle callbacks</title>
 
-    <!-- MLP Beverly to review: Old Text: The Spring Framework provides several callback interfaces to
-    change the behavior of your bean in the container; they include -->
-
     <para>To interact with the container's management of the bean lifecycle, you
       can implement the Spring <interfacename>InitializingBean</interfacename>
       and <interfacename>DisposableBean</interfacename> interfaces. The
       container calls <methodname>afterPropertiesSet()</methodname> for the
       former and <methodname>destroy()</methodname> for the latter to allow the
       bean to perform certain actions upon initialization and destruction of
-      your beans. You can also achieve the same integration with the container
-      without coupling your classes to Spring interfaces through the use of
-      init-method and destroy method object definition metadata.</para>
+      your beans.</para>
+
+      <tip>
+          <para>The JSR-250 <interfacename>@PostConstruct</interfacename> and
+          <interfacename>@PreDestroy</interfacename> annotations are generally
+          considered best practice for receiving lifecycle callbacks in a modern
+          Spring application. Using these annotations means that your beans are not
+          coupled to Spring specific interfaces. For details see
+          <xref linkend="beans-postconstruct-and-predestroy-annotations"/>.</para>
+          <para>If you don't want to use the JSR-250 annotations but you are still
+          looking to remove coupling consider the use of init-method and destroy-method
+          object definition metadata.</para>
+      </tip>
 
     <para>Internally, the Spring Framework uses
       <interfacename>BeanPostProcessor</interfacename> implementations to
@@ -57,7 +64,9 @@
 
       <para>It is recommended that you do not use the
         <interfacename>InitializingBean</interfacename> interface because it
-        unnecessarily couples the code to Spring. Alternatively, specify a POJO
+        unnecessarily couples the code to Spring. Alternatively, use the
+        <link linkend="beans-postconstruct-and-predestroy-annotations">
+        <interfacename>@PostConstruct</interfacename> annotation</link> or specify a POJO
         initialization method. In the case of XML-based configuration metadata,
         you use the <literal>init-method</literal> attribute to specify the name
         of the method that has a void no-argument signature. For example, the
@@ -99,7 +108,9 @@
 
       <para>It is recommended that you do not use the
         <interfacename>DisposableBean</interfacename> callback interface because
-        it unnecessarily couples the code to Spring. Alternatively, specify a
+        it unnecessarily couples the code to Spring. Alternatively, use the
+        <link linkend="beans-postconstruct-and-predestroy-annotations">
+        <interfacename>@PreDestroy</interfacename> annotation</link> or specify a
         generic method that is supported by bean definitions. With XML-based
         configuration metadata, you use the <literal>destroy-method</literal>
         attribute on the <literal>&lt;bean/&gt;</literal>. For example, the
diff --git a/src/reference/docbook/beans-dependencies.xml b/src/reference/docbook/beans-dependencies.xml
index 0723be50fc26..7c0984129028 100644
--- a/src/reference/docbook/beans-dependencies.xml
+++ b/src/reference/docbook/beans-dependencies.xml
@@ -727,8 +727,7 @@ public class ExampleBean {
         container ignores these values. It also ignores the
         <literal>scope</literal> flag. Inner beans are
         <emphasis>always</emphasis> anonymous and they are
-        <emphasis>always</emphasis> scoped as <link
-        linkend="beans-factory-scopes-prototype">prototypes</link>. It is
+        <emphasis>always</emphasis> created with the outer bean. It is
         <emphasis>not</emphasis> possible to inject inner beans into
         collaborating beans other than into the enclosing bean.</para>
     </section>
diff --git a/src/reference/docbook/beans-extension-points.xml b/src/reference/docbook/beans-extension-points.xml
index 551496d7beaf..d2a0aa80c343 100644
--- a/src/reference/docbook/beans-extension-points.xml
+++ b/src/reference/docbook/beans-extension-points.xml
@@ -65,8 +65,7 @@
         />.</para>
     </note>
 
-    <para>The
-      <interfacename>org.springframework.beans.factory.config.BeanPostProcessor</interfacename>
+    <para>The <interfacename>org.springframework.beans.factory.config.BeanPostProcessor</interfacename>
       interface consists of exactly two callback methods. When such a class is
       registered as a post-processor with the container, for each bean instance
       that is created by the container, the post-processor gets a callback from
@@ -93,8 +92,7 @@
     <note>
       <title>Programmatically registering <interfacename>BeanPostProcessors
         </interfacename></title>
-      <para>
-         While the recommended approach for <interfacename>BeanPostProcessor
+      <para>While the recommended approach for <interfacename>BeanPostProcessor
          </interfacename> registration is through <interfacename>ApplicationContext
          </interfacename> auto-detection (as described above), it is also
          possible to register them <emphasis>programmatically</emphasis>
@@ -108,8 +106,7 @@
          registration</emphasis> that dictates the order of execution.  Note also
          that <interfacename>BeanPostProcessors</interfacename> registered
          programmatically are always processed before those registered through
-         auto-detection, regardless of any explicit ordering.
-      </para>
+         auto-detection, regardless of any explicit ordering.</para>
     </note>
 
     <note>
@@ -135,6 +132,14 @@
         <quote><emphasis>Bean foo is not eligible for getting processed by all
         BeanPostProcessor interfaces (for example: not eligible for
         auto-proxying)</emphasis></quote>.</para>
+
+      <para>Note that if you have beans wired into your <interfacename>BeanPostProcessor</interfacename>
+        using autowiring or <interfacename>@Resource</interfacename> (which may fall back to autowiring),
+        Spring might access unexpected beans when searching for type-matching dependency candidates,
+        and therefore make them ineligible for auto-proxying or other kinds of bean post-processing.
+        For example, if you have a dependency annotated with <interfacename>@Resource</interfacename>
+        where the field/setter name does not directly correspond to the declared name of a bean and
+        no name attribute is used, then Spring will access other beans for matching them by type.</para>
     </note>
 
     <para>The following examples show how to write, register, and use
diff --git a/src/reference/docbook/beans-java.xml b/src/reference/docbook/beans-java.xml
index 8db15fb83479..2a76971104f0 100644
--- a/src/reference/docbook/beans-java.xml
+++ b/src/reference/docbook/beans-java.xml
@@ -10,21 +10,46 @@
   <title>Java-based container configuration</title>
 
   <section xml:id="beans-java-basic-concepts">
-    <title>Basic concepts: <literal>@Configuration</literal> and
-      <literal>@Bean</literal></title>
-
-    <para>The central artifact in Spring's new Java-configuration support is the
-      <interfacename>@Configuration</interfacename>-annotated class. These
-      classes consist principally of
-      <interfacename>@Bean</interfacename>-annotated methods that define
-      instantiation, configuration, and initialization logic for objects to be
-      managed by the Spring IoC container.</para>
-
-    <para>Annotating a class with the
-      <interfacename>@Configuration</interfacename> indicates that the class can
-      be used by the Spring IoC container as a source of bean definitions. The
-      simplest possible <interfacename>@Configuration</interfacename> class
-      would read as follows:
+    <title>Basic concepts: <literal>@Bean</literal> and <literal>@Configuration</literal></title>
+
+    <sidebar>
+      <title>Full @Configuration vs 'lite' @Beans mode?</title>
+      <para>When <interfacename>@Bean</interfacename> methods are declared within
+        classes that are <emphasis>not</emphasis> annotated with
+        <interfacename>@Configuration</interfacename> they are referred to as being
+        processed in a 'lite' mode. For example, bean methods declared in a
+        <interfacename>@Component</interfacename> or even in a <emphasis>plain old
+        class</emphasis> will be considered 'lite'.</para>
+      <para>Unlike full <interfacename>@Configuration</interfacename>, lite
+        <interfacename>@Bean</interfacename> methods cannot easily declare inter-bean
+        dependencies. Usually one <interfacename>@Bean</interfacename> method should not
+        invoke another  <interfacename>@Bean</interfacename> method when operating in
+        'lite' mode.</para>
+      <para>Only using <interfacename>@Bean</interfacename> methods within
+        <interfacename>@Configuration</interfacename> classes is a recommended approach
+        of ensuring that 'full' mode is always used. This will prevent the same
+        <interfacename>@Bean</interfacename> method from accidentally being invoked
+        multiple times and helps to reduce subtle bugs that can be hard to track down
+        when operating in 'lite' mode.</para>
+    </sidebar>
+
+    <para>The central artifacts in Spring's new Java-configuration support are
+      <interfacename>@Configuration</interfacename>-annotated classes and
+      <interfacename>@Bean</interfacename>-annotated methods.</para>
+    <para>The <interfacename>@Bean</interfacename> annotation is used to indicate that a
+      method instantiates, configures and initializes a new object to be managed by
+      the Spring IoC container. For those familiar with Spring's
+      <literal>&lt;beans/&gt;</literal> XML configuration the <literal>@Bean</literal>
+      annotation plays the same role as the <literal>&lt;bean/&gt;</literal>
+      element. You can use <interfacename>@Bean</interfacename> annotated methods with
+      any Spring <interfacename>@Component</interfacename>, however, they are most
+      often used with <interfacename>@Configuration</interfacename> beans.</para>
+    <para>Annotating a class with <interfacename>@Configuration</interfacename>
+      indicates that its primary purpose is as a source of bean definitions. Furthermore,
+      <interfacename>@Configuration</interfacename> classes allow inter-bean
+      dependencies to be defined by simply calling other <interfacename>@Bean</interfacename>
+      methods in the same class.  The simplest possible
+      <interfacename>@Configuration</interfacename> class would read as follows:
       <programlisting language="java">@Configuration
 public class AppConfig {
   @Bean
@@ -33,16 +58,15 @@ public class AppConfig {
   }
 }</programlisting></para>
 
-    <para>For those more familiar with Spring <literal>&lt;beans/&gt;</literal>
-      XML, the <literal>AppConfig</literal> class above would be equivalent to:
+    <para>The <literal>AppConfig</literal> class above would be equivalent to the
+      following Spring <literal>&lt;beans/&gt;</literal> XML:
       <programlisting language="xml">&lt;beans&gt;
   &lt;bean id="myService" class="com.acme.services.MyServiceImpl"/&gt;
 &lt;/beans&gt;</programlisting>
-      As you can see, the <literal>@Bean</literal> annotation plays the same
-      role as the <literal>&lt;bean/&gt;</literal> element. The
-      <literal>@Bean</literal> annotation will be discussed in depth in the
-      sections below. First, however, we'll cover the various ways of creating a
-      spring container using Java-based configuration.</para>
+      The <interfacename>@Bean</interfacename> and <interfacename>@Configuration</interfacename>
+      annotations will be discussed in depth in the sections below. First, however, we'll
+      cover the various ways of creating a spring container using Java-based
+      configuration.</para>
   </section>
 
   <section xml:id="beans-java-instantiating-container">
@@ -218,389 +242,245 @@ public class AppConfig {
     </section>
   </section>
 
-  <section xml:id="beans-java-composing-configuration-classes">
-    <title>Composing Java-based configurations</title>
-
-    <section xml:id="beans-java-using-import">
-      <title>Using the <literal>@Import</literal> annotation</title>
-
-      <para>Much as the <literal>&lt;import/&gt;</literal> element is used
-        within Spring XML files to aid in modularizing configurations, the
-        <literal>@Import</literal> annotation allows for loading
-        <literal>@Bean</literal> definitions from another configuration
-        class:<programlisting language="java">@Configuration
-public class ConfigA {
-  public @Bean A a() { return new A(); }
-}
-
-@Configuration
-@Import(ConfigA.class)
-public class ConfigB {
-  public @Bean B b() { return new B(); }
-}</programlisting>
-        Now, rather than needing to specify both
-        <literal>ConfigA.class</literal> and <literal>ConfigB.class</literal>
-        when instantiating the context, only <literal>ConfigB</literal> needs to
-        be supplied
-        explicitly:<programlisting language="java">public static void main(String[] args) {
-  ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);
-
-  // now both beans A and B will be available...
-  A a = ctx.getBean(A.class);
-  B b = ctx.getBean(B.class);
-}</programlisting>
-        This approach simplifies container instantiation, as only one class
-        needs to be dealt with, rather than requiring the developer to remember
-        a potentially large number of <literal>@Configuration</literal> classes
-        during construction.</para>
+  <section xml:id="beans-java-bean-annotation">
+    <title>Using the <interfacename>@Bean</interfacename> annotation</title>
 
-      <section xml:id="beans-java-injecting-imported-beans">
-        <title>Injecting dependencies on imported <literal>@Bean</literal>
-          definitions</title>
+    <para><interfacename>@Bean</interfacename> is a method-level annotation and
+      a direct analog of the XML <code>&lt;bean/&gt;</code> element. The
+      annotation supports some of the attributes offered by
+      <code>&lt;bean/&gt;</code>, such as: <code><link
+      linkend="beans-factory-lifecycle-initializingbean"
+      >init-method</link></code>, <code><link
+      linkend="beans-factory-lifecycle-disposablebean"
+      >destroy-method</link></code>, <code><link
+      linkend="beans-factory-autowire">autowiring</link></code> and
+      <code>name</code>.</para>
 
-        <para>The example above works, but is simplistic. In most practical
-          scenarios, beans will have dependencies on one another across
-          configuration classes. When using XML, this is not an issue, per se,
-          because there is no compiler involved, and one can simply declare
-          <literal>ref="someBean"</literal> and trust that Spring will work it
-          out during container initialization. Of course, when using
-          <literal>@Configuration</literal> classes, the Java compiler places
-          constraints on the configuration model, in that references to other
-          beans must be valid Java syntax.</para>
+    <para>You can use the <interfacename>@Bean</interfacename> annotation in a
+      <interfacename>@Configuration</interfacename>-annotated or in a
+      <interfacename>@Component</interfacename>-annotated class.</para>
 
-        <para>Fortunately, solving this problem is simple. Remember that
-          <literal>@Configuration</literal> classes are ultimately just another
-          bean in the container - this means that they can take advantage of
-          <literal>@Autowired</literal> injection metadata just like any other
-          bean!</para>
+    <section xml:id="beans-java-declaring-a-bean">
+      <title>Declaring a bean</title>
 
-        <para>Let's consider a more real-world scenario with several
-          <literal>@Configuration</literal> classes, each depending on beans
-          declared in the
-          others:<programlisting language="java">@Configuration
-public class ServiceConfig {
-  private @Autowired AccountRepository accountRepository;
+      <para>To declare a bean, simply annotate a method with the
+        <interfacename>@Bean</interfacename> annotation. You use this method to
+        register a bean definition within an <code>ApplicationContext</code> of
+        the type specified as the method's return value. By default, the bean
+        name will be the same as the method name. The following is a simple
+        example of a <interfacename>@Bean</interfacename> method declaration:
+        <programlisting language="java">@Configuration
+public class AppConfig {
 
-  public @Bean TransferService transferService() {
-      return new TransferServiceImpl(accountRepository);
+  @Bean
+  public TransferService transferService() {
+      return new TransferServiceImpl();
   }
-}
 
-@Configuration
-public class RepositoryConfig {
-  private @Autowired DataSource dataSource;
+}</programlisting></para>
 
-  public @Bean AccountRepository accountRepository() {
-      return new JdbcAccountRepository(dataSource);
-  }
-}
+      <para>The preceding configuration is exactly equivalent to the following
+        Spring XML:
+        <programlisting language="xml">&lt;beans&gt;
+  &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;
+&lt;/beans&gt;                </programlisting></para>
 
-@Configuration
-@Import({ServiceConfig.class, RepositoryConfig.class})
-public class SystemTestConfig {
-  public @Bean DataSource dataSource() { /* return new DataSource */ }
-}
+      <para>Both declarations make a bean named <code>transferService</code>
+        available in the <code>ApplicationContext</code>, bound to an object
+        instance of type <code>TransferServiceImpl</code>:
+        <programlisting>
+transferService -&gt; com.acme.TransferServiceImpl
+              </programlisting></para>
+    </section>
 
-public static void main(String[] args) {
-  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
-  // everything wires up across configuration classes...
-  TransferService transferService = ctx.getBean(TransferService.class);
-  transferService.transfer(100.00, "A123", "C456");
-}</programlisting></para>
+    <section xml:id="beans-java-lifecycle-callbacks">
+      <title>Receiving lifecycle callbacks</title>
 
-        <section xml:id="beans-java-injecting-imported-beans-fq">
-          <title>Fully-qualifying imported beans for ease of navigation</title>
+      <para>Any classes defined with the
+        <literal>@Bean</literal> annotation support
+        the regular lifecycle callbacks and can use the
+        <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal>
+        annotations from JSR-250, see <link
+        linkend="beans-postconstruct-and-predestroy-annotations">JSR-250
+        annotations</link> for further details.</para>
 
-          <para>In the scenario above, using <literal>@Autowired</literal> works
-            well and provides the desired modularity, but determining exactly
-            where the autowired bean definitions are declared is still somewhat
-            ambiguous. For example, as a developer looking at
-            <literal>ServiceConfig</literal>, how do you know exactly where the
-            <literal>@Autowired AccountRepository</literal> bean is declared?
-            It's not explicit in the code, and this may be just fine. Remember
-            that the <link xl:href="http://www.springsource.com/products/sts"
-            >SpringSource Tool Suite</link> provides tooling that can render
-            graphs showing how everything is wired up - that may be all you
-            need. Also, your Java IDE can easily find all declarations and uses
-            of the <literal>AccountRepository</literal> type, and will quickly
-            show you the location of <literal>@Bean</literal> methods that
-            return that type.</para>
+      <para>The regular Spring <link linkend="beans-factory-nature"
+        >lifecycle</link> callbacks are fully supported as well. If a bean
+        implements <code>InitializingBean</code>, <code>DisposableBean</code>,
+        or <code>Lifecycle</code>, their respective methods are called by the
+        container.</para>
 
-          <para>In cases where this ambiguity is not acceptable and you wish to
-            have direct navigation from within your IDE from one
-            <literal>@Configuration</literal> class to another, consider
-            autowiring the configuration classes themselves:
-            <programlisting language="java">@Configuration
-public class ServiceConfig {
-  private @Autowired RepositoryConfig repositoryConfig;
+      <para>The standard set of <code>*Aware</code> interfaces such as
+        <code><link linkend="beans-beanfactory">BeanFactoryAware</link></code>,
+        <code><link linkend="beans-factory-aware">BeanNameAware</link></code>,
+        <code><link linkend="context-functionality-messagesource"
+        >MessageSourceAware</link></code>, <code><link
+        linkend="beans-factory-aware">ApplicationContextAware</link></code>, and
+        so on are also fully supported.</para>
 
-  public @Bean TransferService transferService() {
-      // navigate 'through' the config class to the @Bean method!
-      return new TransferServiceImpl(repositoryConfig.accountRepository());
+      <para>The <interfacename>@Bean</interfacename> annotation supports
+        specifying arbitrary initialization and destruction callback methods,
+        much like Spring XML's <code>init-method</code> and
+        <code>destroy-method</code> attributes on the <code>bean</code> element:
+        <programlisting language="java">public class Foo {
+  public void init() {
+      // initialization logic
   }
-}</programlisting>
-            In the situation above, it is completely explicit where
-            <literal>AccountRepository</literal> is defined. However,
-            <literal>ServiceConfig</literal> is now tightly coupled to
-            <literal>RepositoryConfig</literal>; that's the tradeoff. This tight
-            coupling can be somewhat mitigated by using interface-based or
-            abstract class-based <literal>@Configuration</literal> classes.
-            Consider the following:
-            <programlisting language="java">@Configuration
-public class ServiceConfig {
-  private @Autowired RepositoryConfig repositoryConfig;
+}
 
-  public @Bean TransferService transferService() {
-      return new TransferServiceImpl(repositoryConfig.accountRepository());
+public class Bar {
+  public void cleanup() {
+      // destruction logic
   }
 }
 
 @Configuration
-public interface RepositoryConfig {
-  @Bean AccountRepository accountRepository();
+public class AppConfig {
+  @Bean(initMethod = "init")
+  public Foo foo() {
+      return new Foo();
+  }
+  @Bean(destroyMethod = "cleanup")
+  public Bar bar() {
+      return new Bar();
+  }
 }
+</programlisting></para>
 
-@Configuration
-public class DefaultRepositoryConfig implements RepositoryConfig {
-  public @Bean AccountRepository accountRepository() {
-      return new JdbcAccountRepository(...);
+      <para>Of course, in the case of <code>Foo</code> above, it would be
+        equally as valid to call the <code>init()</code> method directly during
+        construction:
+        <programlisting language="java">@Configuration
+public class AppConfig {
+  @Bean
+  public Foo foo() {
+      Foo foo = new Foo();
+      foo.init();
+      return foo;
   }
-}
 
-@Configuration
-@Import({ServiceConfig.class, DefaultRepositoryConfig.class}) // import the concrete config!
-public class SystemTestConfig {
-  public @Bean DataSource dataSource() { /* return DataSource */ }
-}
+  // ...
+}                    </programlisting></para>
 
-public static void main(String[] args) {
-  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
-  TransferService transferService = ctx.getBean(TransferService.class);
-  transferService.transfer(100.00, "A123", "C456");
-}</programlisting>
-            Now <literal>ServiceConfig</literal> is loosely coupled with respect
-            to the concrete <literal>DefaultRepositoryConfig</literal>, and
-            built-in IDE tooling is still useful: it will be easy for the
-            developer to get a type hierarchy of
-            <literal>RepositoryConfig</literal> implementations. In this way,
-            navigating <literal>@Configuration</literal> classes and their
-            dependencies becomes no different than the usual process of
-            navigating interface-based code.</para>
-        </section>
-      </section>
+      <tip>
+        <para>When you work directly in Java, you can do anything you like with
+          your objects and do not always need to rely on the container
+          lifecycle!</para>
+      </tip>
     </section>
 
-    <section xml:id="beans-java-combining">
-      <title>Combining Java and XML configuration</title>
+    <section xml:id="beans-java-specifying-bean-scope">
+      <title>Specifying bean scope</title>
 
-      <para>Spring's <literal>@Configuration</literal> class support does not
-        aim to be a 100% complete replacement for Spring XML. Some facilities
-        such as Spring XML namespaces remain an ideal way to configure the
-        container. In cases where XML is convenient or necessary, you have a
-        choice: either instantiate the container in an "XML-centric" way using,
-        for example, <literal>ClassPathXmlApplicationContext</literal>, or in a
-        "Java-centric" fashion using
-        <literal>AnnotationConfigApplicationContext</literal> and the
-        <literal>@ImportResource</literal> annotation to import XML as
-        needed.</para>
-
-      <section xml:id="beans-java-combining-xml-centric">
-        <title>XML-centric use of <literal>@Configuration</literal>
-          classes</title>
-
-        <para>It may be preferable to bootstrap the Spring container from XML
-          and include <literal>@Configuration</literal> classes in an ad-hoc
-          fashion. For example, in a large existing codebase that uses Spring
-          XML, it will be easier to create <literal>@Configuration</literal>
-          classes on an as-needed basis and include them from the existing XML
-          files. Below you'll find the options for using
-          <literal>@Configuration</literal> classes in this kind of
-          "XML-centric" situation.</para>
-
-        <section xml:id="beans-java-combining-xml-centric-declare-as-bean">
-          <title>Declaring <literal>@Configuration</literal> classes as plain
-            Spring <literal>&lt;bean/&gt;</literal> elements</title>
+      <section xml:id="beans-java-available-scopes">
+        <title>Using the <interfacename>@Scope</interfacename>
+          annotation</title>
 
-          <para>Remember that <literal>@Configuration</literal> classes are
-            ultimately just bean definitions in the container. In this example,
-            we create a <literal>@Configuration</literal> class named
-            <literal>AppConfig</literal> and include it within
-            <literal>system-test-config.xml</literal> as a
-            <literal>&lt;bean/&gt;</literal>definition. Because
-            <literal>&lt;context:annotation-config/&gt;</literal> is switched
-            on, the container will recognize the
-            <literal>@Configuration</literal> annotation, and process the
-            <literal>@Bean</literal> methods declared in
-            <literal>AppConfig</literal>
-            properly.<programlisting language="java">@Configuration
-public class AppConfig {
-  private @Autowired DataSource dataSource;
+        <!-- MLP: Beverly, did not apply your edit as it changed meaning -->
 
-  public @Bean AccountRepository accountRepository() {
-      return new JdbcAccountRepository(dataSource);
-  }
+        <para>You can specify that your beans defined with the
+          <interfacename>@Bean</interfacename> annotation should have a specific
+          scope. You can use any of the standard scopes specified in the <link
+          linkend="beans-factory-scopes">Bean Scopes</link> section.</para>
 
-  public @Bean TransferService transferService() {
-      return new TransferService(accountRepository());
+        <para>The default scope is <literal>singleton</literal>, but you can
+          override this with the <interfacename>@Scope</interfacename>
+          annotation:
+          <programlisting language="java">@Configuration
+public class MyConfiguration {
+  @Bean
+  <emphasis role="bold">@Scope("prototype")</emphasis>
+  public Encryptor encryptor() {
+      // ...
   }
-}</programlisting>
-            <programlisting language="xml"><lineannotation role="listingtitle">system-test-config.xml</lineannotation>
-&lt;beans&gt;
-  &lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;
-  &lt;context:annotation-config/&gt;
-  &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
-
-  &lt;bean class="com.acme.AppConfig"/&gt;
-
-  &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
-      &lt;property name="url" value="${jdbc.url}"/&gt;
-      &lt;property name="username" value="${jdbc.username}"/&gt;
-      &lt;property name="password" value="${jdbc.password}"/&gt;
-  &lt;/bean&gt;
-&lt;/beans&gt;</programlisting>
-            <programlisting><lineannotation role="listingtitle">jdbc.properties</lineannotation>
-jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
-jdbc.username=sa
-jdbc.password=</programlisting>
-            <programlisting language="java">public static void main(String[] args) {
-  ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
-  TransferService transferService = ctx.getBean(TransferService.class);
-  // ...
 }</programlisting></para>
+      </section>
 
-          <note>
-            <para>In <literal>system-test-config.xml</literal> above, the
-              <literal>AppConfig&lt;bean/&gt;</literal> does not declare an
-              <literal>id</literal> element. While it would be acceptable to do
-              so, it is unnecessary given that no other bean will ever refer to
-              it, and it is unlikely that it will be explicitly fetched from the
-              container by name. Likewise with the <literal>DataSource</literal>
-              bean - it is only ever autowired by type, so an explicit bean id
-              is not strictly required.</para>
-          </note>
-        </section>
+      <section xml:id="beans-java-scoped-proxy">
+        <title><code>@Scope and scoped-proxy</code></title>
 
-        <section xml:id="beans-java-combining-xml-centric-component-scan">
-          <title>Using <literal>&lt;context:component-scan/&gt;</literal> to
-            pick up <literal>@Configuration</literal> classes</title>
+        <para>Spring offers a convenient way of working with scoped dependencies
+          through <link linkend="beans-factory-scopes-other-injection">scoped
+          proxies</link>. The easiest way to create such a proxy when using the
+          XML configuration is the <code>&lt;aop:scoped-proxy/&gt;</code>
+          element. Configuring your beans in Java with a @Scope annotation
+          offers equivalent support with the proxyMode attribute. The default is
+          no proxy (<varname>ScopedProxyMode.NO</varname>), but you can specify
+          <classname>ScopedProxyMode.TARGET_CLASS</classname> or
+          <classname>ScopedProxyMode.INTERFACES</classname>.</para>
 
-          <para>Because <literal>@Configuration</literal> is meta-annotated with
-            <literal>@Component</literal>,
-            <literal>@Configuration</literal>-annotated classes are
-            automatically candidates for component scanning. Using the same
-            scenario as above, we can redefine
-            <literal>system-test-config.xml</literal> to take advantage of
-            component-scanning. Note that in this case, we don't need to
-            explicitly declare
-            <literal>&lt;context:annotation-config/&gt;</literal>, because
-            <literal>&lt;context:component-scan/&gt;</literal> enables all the
-            same
-            functionality.<programlisting language="xml"><lineannotation role="listingtitle">system-test-config.xml</lineannotation>
-&lt;beans&gt;
-  &lt;!-- picks up and registers AppConfig as a bean definition --&gt;
-  &lt;context:component-scan base-package="com.acme"/&gt;
-  &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
+        <para>If you port the scoped proxy example from the XML reference
+          documentation (see preceding link) to our
+          <interfacename>@Bean</interfacename> using Java, it would look like
+          the following:
+          <programlisting language="java">// an HTTP Session-scoped bean exposed as a proxy
+@Bean
+<emphasis role="bold">@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)</emphasis>
+public UserPreferences userPreferences() {
+ return new UserPreferences();
+}
 
-  &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
-      &lt;property name="url" value="${jdbc.url}"/&gt;
-      &lt;property name="username" value="${jdbc.username}"/&gt;
-      &lt;property name="password" value="${jdbc.password}"/&gt;
-  &lt;/bean&gt;
-&lt;/beans&gt;</programlisting></para>
-        </section>
+@Bean
+public Service userService() {
+ UserService service = new SimpleUserService();
+ // a reference to the proxied userPreferences bean
+ service.setUserPreferences(userPreferences());
+ return service;
+}                </programlisting></para>
       </section>
+    </section>
 
-      <section xml:id="beans-java-combining-java-centric">
-        <title><literal>@Configuration</literal> class-centric use of XML with
-          <literal>@ImportResource</literal></title>
+    <section xml:id="beans-java-customizing-bean-naming">
+      <title>Customizing bean naming</title>
 
-        <para>In applications where <literal>@Configuration</literal> classes
-          are the primary mechanism for configuring the container, it will still
-          likely be necessary to use at least some XML. In these scenarios,
-          simply use <literal>@ImportResource</literal> and define only as much
-          XML as is needed. Doing so achieves a "Java-centric" approach to
-          configuring the container and keeps XML to a bare minimum.
-          <programlisting language="java">@Configuration
-@ImportResource("classpath:/com/acme/properties-config.xml")
+      <para>By default, configuration classes use a
+        <interfacename>@Bean</interfacename> method's name as the name of the
+        resulting bean. This functionality can be overridden, however, with the
+        <code>name</code> attribute.
+        <programlisting language="java">@Configuration
 public class AppConfig {
-  private @Value("${jdbc.url}") String url;
-  private @Value("${jdbc.username}") String username;
-  private @Value("${jdbc.password}") String password;
 
-  public @Bean DataSource dataSource() {
-      return new DriverManagerDataSource(url, username, password);
+  @Bean(name = "myFoo")
+  public Foo foo() {
+      return new Foo();
   }
-}</programlisting>
-          <programlisting language="xml"><lineannotation role="listingtitle">properties-config.xml</lineannotation>
-&lt;beans&gt;
-  &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
-&lt;/beans&gt;</programlisting>
-          <programlisting><lineannotation role="listingtitle">jdbc.properties</lineannotation>
-jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
-jdbc.username=sa
-jdbc.password=</programlisting>
-          <programlisting language="java">public static void main(String[] args) {
-  ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
-  TransferService transferService = ctx.getBean(TransferService.class);
-  // ...
-}</programlisting></para>
-      </section>
-    </section>
-  </section>
-
-  <section xml:id="beans-java-bean-annotation">
-    <title>Using the <interfacename>@Bean</interfacename> annotation</title>
-
-    <para><interfacename>@Bean</interfacename> is a method-level annotation and
-      a direct analog of the XML <code>&lt;bean/&gt;</code> element. The
-      annotation supports some of the attributes offered by
-      <code>&lt;bean/&gt;</code>, such as: <code><link
-      linkend="beans-factory-lifecycle-initializingbean"
-      >init-method</link></code>, <code><link
-      linkend="beans-factory-lifecycle-disposablebean"
-      >destroy-method</link></code>, <code><link
-      linkend="beans-factory-autowire">autowiring</link></code> and
-      <code>name</code>.</para>
 
-    <para>You can use the <interfacename>@Bean</interfacename> annotation in a
-      <interfacename>@Configuration</interfacename>-annotated or in a
-      <interfacename>@Component</interfacename>-annotated class.</para>
+}        </programlisting></para>
+    </section>
 
-    <section xml:id="beans-java-declaring-a-bean">
-      <title>Declaring a bean</title>
+    <section xml:id="beans-java-bean-aliasing">
+      <title>Bean aliasing</title>
 
-      <para>To declare a bean, simply annotate a method with the
-        <interfacename>@Bean</interfacename> annotation. You use this method to
-        register a bean definition within an <code>ApplicationContext</code> of
-        the type specified as the method's return value. By default, the bean
-        name will be the same as the method name. The following is a simple
-        example of a <interfacename>@Bean</interfacename> method declaration:
+      <para>As discussed in <xref linkend="beans-beanname"/>, it is sometimes
+        desirable to give a single bean multiple names, otherwise known as
+        <emphasis>bean aliasing</emphasis>. The <literal>name</literal>
+        attribute of the <literal>@Bean</literal> annotation accepts a String
+        array for this purpose.
         <programlisting language="java">@Configuration
 public class AppConfig {
 
-  @Bean
-  public TransferService transferService() {
-      return new TransferServiceImpl();
+  @Bean(name = { "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" })
+  public DataSource dataSource() {
+      // instantiate, configure and return DataSource bean...
   }
 
-}</programlisting></para>
-
-      <para>The preceding configuration is exactly equivalent to the following
-        Spring XML:
-        <programlisting language="xml">&lt;beans&gt;
-  &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;
-&lt;/beans&gt;                </programlisting></para>
-
-      <para>Both declarations make a bean named <code>transferService</code>
-        available in the <code>ApplicationContext</code>, bound to an object
-        instance of type <code>TransferServiceImpl</code>:
-        <programlisting>
-transferService -&gt; com.acme.TransferServiceImpl
-              </programlisting></para>
+}        </programlisting></para>
     </section>
+  </section>
+
+  <section xml:id="beans-java-configuration-annotation">
+    <title>Using the <interfacename>@Configuration</interfacename> annotation</title>
+    <para><interfacename>@Configuration</interfacename> is a class-level annotation
+      indicating that an object is a source of bean definitions.
+      <interfacename>@Configuration</interfacename> classes declare beans via
+      public <interfacename>@Bean</interfacename> annotated methods. Calls to
+      <interfacename>@Bean</interfacename> methods on
+      <interfacename>@Configuration</interfacename> classes can also be used to
+      define inter-bean dependencies. See <xref linkend="beans-java-basic-concepts"/> for
+      a general introduction.</para>
 
     <section xml:id="beans-java-injecting-dependencies">
-      <title>Injecting dependencies</title>
+      <title>Injecting inter-bean dependencies</title>
 
       <para>When <interfacename>@Bean</interfacename>s have dependencies on one
         another, expressing that dependency is as simple as having one bean
@@ -622,157 +502,28 @@ public class AppConfig {
 
       <para>In the example above, the <code>foo</code> bean receives a reference
         to <code> bar</code> via constructor injection.</para>
+
+      <note>
+        <para>This method of declaring inter-bean dependencies only works when
+        the <interfacename>@Bean</interfacename> method is declared within a
+        <interfacename>@Configuration</interfacename> class. You cannot declare
+        inter-bean dependencies using plain <interfacename>@Component</interfacename>
+        classes.</para>
+      </note>
     </section>
 
-    <section xml:id="beans-java-lifecycle-callbacks">
-      <title>Receiving lifecycle callbacks</title>
+    <section xml:id="beans-java-method-injection">
+      <title>Lookup method injection</title>
 
-      <para>Beans declared in a
-        <interfacename>@Configuration</interfacename>-annotated class support
-        the regular lifecycle callbacks. Any classes defined with the
-        <literal>@Bean</literal> annotation can use the
-        <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal>
-        annotations from JSR-250, see <link
-        linkend="beans-postconstruct-and-predestroy-annotations">JSR-250
-        annotations</link> for further details.</para>
-
-      <para>The regular Spring <link linkend="beans-factory-nature"
-        >lifecycle</link> callbacks are fully supported as well. If a bean
-        implements <code>InitializingBean</code>, <code>DisposableBean</code>,
-        or <code>Lifecycle</code>, their respective methods are called by the
-        container.</para>
-
-      <para>The standard set of <code>*Aware</code> interfaces such as
-        <code><link linkend="beans-beanfactory">BeanFactoryAware</link></code>,
-        <code><link linkend="beans-factory-aware">BeanNameAware</link></code>,
-        <code><link linkend="context-functionality-messagesource"
-        >MessageSourceAware</link></code>, <code><link
-        linkend="beans-factory-aware">ApplicationContextAware</link></code>, and
-        so on are also fully supported.</para>
-
-      <para>The <interfacename>@Bean</interfacename> annotation supports
-        specifying arbitrary initialization and destruction callback methods,
-        much like Spring XML's <code>init-method</code> and
-        <code>destroy-method</code> attributes on the <code>bean</code> element:
-        <programlisting language="java">public class Foo {
-  public void init() {
-      // initialization logic
-  }
-}
-
-public class Bar {
-  public void cleanup() {
-      // destruction logic
-  }
-}
-
-@Configuration
-public class AppConfig {
-  @Bean(initMethod = "init")
-  public Foo foo() {
-      return new Foo();
-  }
-  @Bean(destroyMethod = "cleanup")
-  public Bar bar() {
-      return new Bar();
-  }
-}
-</programlisting></para>
-
-      <para>Of course, in the case of <code>Foo</code> above, it would be
-        equally as valid to call the <code>init()</code> method directly during
-        construction:
-        <programlisting language="java">@Configuration
-public class AppConfig {
-  @Bean
-  public Foo foo() {
-      Foo foo = new Foo();
-      foo.init();
-      return foo;
-  }
-
-  // ...
-}                    </programlisting></para>
-
-      <tip>
-        <para>When you work directly in Java, you can do anything you like with
-          your objects and do not always need to rely on the container
-          lifecycle!</para>
-      </tip>
-    </section>
-
-    <section xml:id="beans-java-specifying-bean-scope">
-      <title>Specifying bean scope</title>
-
-      <section xml:id="beans-java-available-scopes">
-        <title>Using the <interfacename>@Scope</interfacename>
-          annotation</title>
-
-        <!-- MLP: Beverly, did not apply your edit as it changed meaning -->
-
-        <para>You can specify that your beans defined with the
-          <interfacename>@Bean</interfacename> annotation should have a specific
-          scope. You can use any of the standard scopes specified in the <link
-          linkend="beans-factory-scopes">Bean Scopes</link> section.</para>
-
-        <para>The default scope is <literal>singleton</literal>, but you can
-          override this with the <interfacename>@Scope</interfacename>
-          annotation:
-          <programlisting language="java">@Configuration
-public class MyConfiguration {
-  @Bean
-  <emphasis role="bold">@Scope("prototype")</emphasis>
-  public Encryptor encryptor() {
-      // ...
-  }
-}</programlisting></para>
-      </section>
-
-      <section xml:id="beans-java-scoped-proxy">
-        <title><code>@Scope and scoped-proxy</code></title>
-
-        <para>Spring offers a convenient way of working with scoped dependencies
-          through <link linkend="beans-factory-scopes-other-injection">scoped
-          proxies</link>. The easiest way to create such a proxy when using the
-          XML configuration is the <code>&lt;aop:scoped-proxy/&gt;</code>
-          element. Configuring your beans in Java with a @Scope annotation
-          offers equivalent support with the proxyMode attribute. The default is
-          no proxy (<varname>ScopedProxyMode.NO</varname>), but you can specify
-          <classname>ScopedProxyMode.TARGET_CLASS</classname> or
-          <classname>ScopedProxyMode.INTERFACES</classname>.</para>
-
-        <para>If you port the scoped proxy example from the XML reference
-          documentation (see preceding link) to our
-          <interfacename>@Bean</interfacename> using Java, it would look like
-          the following:
-          <programlisting language="java">// an HTTP Session-scoped bean exposed as a proxy
-@Bean
-<emphasis role="bold">@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)</emphasis>
-public UserPreferences userPreferences() {
- return new UserPreferences();
-}
-
-@Bean
-public Service userService() {
- UserService service = new SimpleUserService();
- // a reference to the proxied userPreferences bean
- service.setUserPreferences(userPreferences());
- return service;
-}                </programlisting></para>
-      </section>
-
-      <section xml:id="beans-java-method-injection">
-        <title>Lookup method injection</title>
-
-        <para>As noted earlier, <link linkend="beans-factory-method-injection"
-          >lookup method injection</link> is an advanced feature that you should
-          use rarely. It is useful in cases where a singleton-scoped bean has a
-          dependency on a prototype-scoped bean. Using Java for this type of
-          configuration provides a natural means for implementing this pattern.
-          <programlisting language="java">public abstract class CommandManager {
-  public Object process(Object commandState) {
-      // grab a new instance of the appropriate Command interface
-      Command command = createCommand();
+      <para>As noted earlier, <link linkend="beans-factory-method-injection"
+        >lookup method injection</link> is an advanced feature that you should
+        use rarely. It is useful in cases where a singleton-scoped bean has a
+        dependency on a prototype-scoped bean. Using Java for this type of
+        configuration provides a natural means for implementing this pattern.
+        <programlisting language="java">public abstract class CommandManager {
+  public Object process(Object commandState) {
+      // grab a new instance of the appropriate Command interface
+      Command command = createCommand();
 
       // set the state on the (hopefully brand new) Command instance
       command.setState(commandState);
@@ -783,11 +534,11 @@ public Service userService() {
   protected abstract Command createCommand();
 }                   </programlisting></para>
 
-        <para>Using Java-configuration support , you can create a subclass of
-          <code>CommandManager</code> where the abstract
-          <code>createCommand()</code> method is overridden in such a way that
-          it looks up a new (prototype) command object:
-          <programlisting language="java">@Bean
+      <para>Using Java-configuration support , you can create a subclass of
+        <code>CommandManager</code> where the abstract
+        <code>createCommand()</code> method is overridden in such a way that
+        it looks up a new (prototype) command object:
+        <programlisting language="java">@Bean
 @Scope("prototype")
 public AsyncCommand asyncCommand() {
   AsyncCommand command = new AsyncCommand();
@@ -805,51 +556,9 @@ public CommandManager commandManager() {
       }
   }
 }                    </programlisting></para>
-      </section>
-    </section>
-
-    <section xml:id="beans-java-customizing-bean-naming">
-      <title>Customizing bean naming</title>
-
-      <para>By default, configuration classes use a
-        <interfacename>@Bean</interfacename> method's name as the name of the
-        resulting bean. This functionality can be overridden, however, with the
-        <code>name</code> attribute.
-        <programlisting language="java">@Configuration
-public class AppConfig {
-
-  @Bean(name = "myFoo")
-  public Foo foo() {
-      return new Foo();
-  }
-
-}        </programlisting></para>
     </section>
 
-
-
-
-    <section xml:id="beans-java-bean-aliasing">
-      <title>Bean aliasing</title>
-
-      <para>As discussed in <xref linkend="beans-beanname"/>, it is sometimes
-        desirable to give a single bean multiple names, otherwise known as
-        <emphasis>bean aliasing</emphasis>. The <literal>name</literal>
-        attribute of the <literal>@Bean</literal> annotation accepts a String
-        array for this purpose.
-        <programlisting language="java">@Configuration
-public class AppConfig {
-
-  @Bean(name = { "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" })
-  public DataSource dataSource() {
-      // instantiate, configure and return DataSource bean...
-  }
-
-}        </programlisting></para>
-    </section>
-  </section>
-
-  <section xml:id="beans-java-further-information-java-config">
+    <section xml:id="beans-java-further-information-java-config">
     <title>Further information about how Java-based configuration works
       internally</title>
 
@@ -909,4 +618,338 @@ public class AppConfig {
         </itemizedlist> </para>
     </note>
   </section>
+  </section>
+
+
+
+
+  <section xml:id="beans-java-composing-configuration-classes">
+    <title>Composing Java-based configurations</title>
+
+    <section xml:id="beans-java-using-import">
+      <title>Using the <literal>@Import</literal> annotation</title>
+
+      <para>Much as the <literal>&lt;import/&gt;</literal> element is used
+        within Spring XML files to aid in modularizing configurations, the
+        <literal>@Import</literal> annotation allows for loading
+        <literal>@Bean</literal> definitions from another configuration
+        class:<programlisting language="java">@Configuration
+public class ConfigA {
+  public @Bean A a() { return new A(); }
+}
+
+@Configuration
+@Import(ConfigA.class)
+public class ConfigB {
+  public @Bean B b() { return new B(); }
+}</programlisting>
+        Now, rather than needing to specify both
+        <literal>ConfigA.class</literal> and <literal>ConfigB.class</literal>
+        when instantiating the context, only <literal>ConfigB</literal> needs to
+        be supplied
+        explicitly:<programlisting language="java">public static void main(String[] args) {
+  ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);
+
+  // now both beans A and B will be available...
+  A a = ctx.getBean(A.class);
+  B b = ctx.getBean(B.class);
+}</programlisting>
+        This approach simplifies container instantiation, as only one class
+        needs to be dealt with, rather than requiring the developer to remember
+        a potentially large number of <literal>@Configuration</literal> classes
+        during construction.</para>
+
+      <section xml:id="beans-java-injecting-imported-beans">
+        <title>Injecting dependencies on imported <literal>@Bean</literal>
+          definitions</title>
+
+        <para>The example above works, but is simplistic. In most practical
+          scenarios, beans will have dependencies on one another across
+          configuration classes. When using XML, this is not an issue, per se,
+          because there is no compiler involved, and one can simply declare
+          <literal>ref="someBean"</literal> and trust that Spring will work it
+          out during container initialization. Of course, when using
+          <literal>@Configuration</literal> classes, the Java compiler places
+          constraints on the configuration model, in that references to other
+          beans must be valid Java syntax.</para>
+
+        <para>Fortunately, solving this problem is simple. Remember that
+          <literal>@Configuration</literal> classes are ultimately just another
+          bean in the container - this means that they can take advantage of
+          <literal>@Autowired</literal> injection metadata just like any other
+          bean!</para>
+
+        <para>Let's consider a more real-world scenario with several
+          <literal>@Configuration</literal> classes, each depending on beans
+          declared in the
+          others:<programlisting language="java">@Configuration
+public class ServiceConfig {
+  private @Autowired AccountRepository accountRepository;
+
+  public @Bean TransferService transferService() {
+      return new TransferServiceImpl(accountRepository);
+  }
+}
+
+@Configuration
+public class RepositoryConfig {
+  private @Autowired DataSource dataSource;
+
+  public @Bean AccountRepository accountRepository() {
+      return new JdbcAccountRepository(dataSource);
+  }
+}
+
+@Configuration
+@Import({ServiceConfig.class, RepositoryConfig.class})
+public class SystemTestConfig {
+  public @Bean DataSource dataSource() { /* return new DataSource */ }
+}
+
+public static void main(String[] args) {
+  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
+  // everything wires up across configuration classes...
+  TransferService transferService = ctx.getBean(TransferService.class);
+  transferService.transfer(100.00, "A123", "C456");
+}</programlisting></para>
+
+        <section xml:id="beans-java-injecting-imported-beans-fq">
+          <title>Fully-qualifying imported beans for ease of navigation</title>
+
+          <para>In the scenario above, using <literal>@Autowired</literal> works
+            well and provides the desired modularity, but determining exactly
+            where the autowired bean definitions are declared is still somewhat
+            ambiguous. For example, as a developer looking at
+            <literal>ServiceConfig</literal>, how do you know exactly where the
+            <literal>@Autowired AccountRepository</literal> bean is declared?
+            It's not explicit in the code, and this may be just fine. Remember
+            that the <link xl:href="http://www.springsource.com/products/sts"
+            >SpringSource Tool Suite</link> provides tooling that can render
+            graphs showing how everything is wired up - that may be all you
+            need. Also, your Java IDE can easily find all declarations and uses
+            of the <literal>AccountRepository</literal> type, and will quickly
+            show you the location of <literal>@Bean</literal> methods that
+            return that type.</para>
+
+          <para>In cases where this ambiguity is not acceptable and you wish to
+            have direct navigation from within your IDE from one
+            <literal>@Configuration</literal> class to another, consider
+            autowiring the configuration classes themselves:
+            <programlisting language="java">@Configuration
+public class ServiceConfig {
+  private @Autowired RepositoryConfig repositoryConfig;
+
+  public @Bean TransferService transferService() {
+      // navigate 'through' the config class to the @Bean method!
+      return new TransferServiceImpl(repositoryConfig.accountRepository());
+  }
+}</programlisting>
+            In the situation above, it is completely explicit where
+            <literal>AccountRepository</literal> is defined. However,
+            <literal>ServiceConfig</literal> is now tightly coupled to
+            <literal>RepositoryConfig</literal>; that's the tradeoff. This tight
+            coupling can be somewhat mitigated by using interface-based or
+            abstract class-based <literal>@Configuration</literal> classes.
+            Consider the following:
+            <programlisting language="java">@Configuration
+public class ServiceConfig {
+  private @Autowired RepositoryConfig repositoryConfig;
+
+  public @Bean TransferService transferService() {
+      return new TransferServiceImpl(repositoryConfig.accountRepository());
+  }
+}
+
+@Configuration
+public interface RepositoryConfig {
+  @Bean AccountRepository accountRepository();
+}
+
+@Configuration
+public class DefaultRepositoryConfig implements RepositoryConfig {
+  public @Bean AccountRepository accountRepository() {
+      return new JdbcAccountRepository(...);
+  }
+}
+
+@Configuration
+@Import({ServiceConfig.class, DefaultRepositoryConfig.class}) // import the concrete config!
+public class SystemTestConfig {
+  public @Bean DataSource dataSource() { /* return DataSource */ }
+}
+
+public static void main(String[] args) {
+  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
+  TransferService transferService = ctx.getBean(TransferService.class);
+  transferService.transfer(100.00, "A123", "C456");
+}</programlisting>
+            Now <literal>ServiceConfig</literal> is loosely coupled with respect
+            to the concrete <literal>DefaultRepositoryConfig</literal>, and
+            built-in IDE tooling is still useful: it will be easy for the
+            developer to get a type hierarchy of
+            <literal>RepositoryConfig</literal> implementations. In this way,
+            navigating <literal>@Configuration</literal> classes and their
+            dependencies becomes no different than the usual process of
+            navigating interface-based code.</para>
+        </section>
+      </section>
+    </section>
+
+    <section xml:id="beans-java-combining">
+      <title>Combining Java and XML configuration</title>
+
+      <para>Spring's <literal>@Configuration</literal> class support does not
+        aim to be a 100% complete replacement for Spring XML. Some facilities
+        such as Spring XML namespaces remain an ideal way to configure the
+        container. In cases where XML is convenient or necessary, you have a
+        choice: either instantiate the container in an "XML-centric" way using,
+        for example, <literal>ClassPathXmlApplicationContext</literal>, or in a
+        "Java-centric" fashion using
+        <literal>AnnotationConfigApplicationContext</literal> and the
+        <literal>@ImportResource</literal> annotation to import XML as
+        needed.</para>
+
+      <section xml:id="beans-java-combining-xml-centric">
+        <title>XML-centric use of <literal>@Configuration</literal>
+          classes</title>
+
+        <para>It may be preferable to bootstrap the Spring container from XML
+          and include <literal>@Configuration</literal> classes in an ad-hoc
+          fashion. For example, in a large existing codebase that uses Spring
+          XML, it will be easier to create <literal>@Configuration</literal>
+          classes on an as-needed basis and include them from the existing XML
+          files. Below you'll find the options for using
+          <literal>@Configuration</literal> classes in this kind of
+          "XML-centric" situation.</para>
+
+        <section xml:id="beans-java-combining-xml-centric-declare-as-bean">
+          <title>Declaring <literal>@Configuration</literal> classes as plain
+            Spring <literal>&lt;bean/&gt;</literal> elements</title>
+
+          <para>Remember that <literal>@Configuration</literal> classes are
+            ultimately just bean definitions in the container. In this example,
+            we create a <literal>@Configuration</literal> class named
+            <literal>AppConfig</literal> and include it within
+            <literal>system-test-config.xml</literal> as a
+            <literal>&lt;bean/&gt;</literal>definition. Because
+            <literal>&lt;context:annotation-config/&gt;</literal> is switched
+            on, the container will recognize the
+            <literal>@Configuration</literal> annotation, and process the
+            <literal>@Bean</literal> methods declared in
+            <literal>AppConfig</literal>
+            properly.<programlisting language="java">@Configuration
+public class AppConfig {
+  private @Autowired DataSource dataSource;
+
+  public @Bean AccountRepository accountRepository() {
+      return new JdbcAccountRepository(dataSource);
+  }
+
+  public @Bean TransferService transferService() {
+      return new TransferService(accountRepository());
+  }
+}</programlisting>
+            <programlisting language="xml"><lineannotation role="listingtitle">system-test-config.xml</lineannotation>
+&lt;beans&gt;
+  &lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;
+  &lt;context:annotation-config/&gt;
+  &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
+
+  &lt;bean class="com.acme.AppConfig"/&gt;
+
+  &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
+      &lt;property name="url" value="${jdbc.url}"/&gt;
+      &lt;property name="username" value="${jdbc.username}"/&gt;
+      &lt;property name="password" value="${jdbc.password}"/&gt;
+  &lt;/bean&gt;
+&lt;/beans&gt;</programlisting>
+            <programlisting><lineannotation role="listingtitle">jdbc.properties</lineannotation>
+jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
+jdbc.username=sa
+jdbc.password=</programlisting>
+            <programlisting language="java">public static void main(String[] args) {
+  ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
+  TransferService transferService = ctx.getBean(TransferService.class);
+  // ...
+}</programlisting></para>
+
+          <note>
+            <para>In <literal>system-test-config.xml</literal> above, the
+              <literal>AppConfig&lt;bean/&gt;</literal> does not declare an
+              <literal>id</literal> element. While it would be acceptable to do
+              so, it is unnecessary given that no other bean will ever refer to
+              it, and it is unlikely that it will be explicitly fetched from the
+              container by name. Likewise with the <literal>DataSource</literal>
+              bean - it is only ever autowired by type, so an explicit bean id
+              is not strictly required.</para>
+          </note>
+        </section>
+
+        <section xml:id="beans-java-combining-xml-centric-component-scan">
+          <title>Using <literal>&lt;context:component-scan/&gt;</literal> to
+            pick up <literal>@Configuration</literal> classes</title>
+
+          <para>Because <literal>@Configuration</literal> is meta-annotated with
+            <literal>@Component</literal>,
+            <literal>@Configuration</literal>-annotated classes are
+            automatically candidates for component scanning. Using the same
+            scenario as above, we can redefine
+            <literal>system-test-config.xml</literal> to take advantage of
+            component-scanning. Note that in this case, we don't need to
+            explicitly declare
+            <literal>&lt;context:annotation-config/&gt;</literal>, because
+            <literal>&lt;context:component-scan/&gt;</literal> enables all the
+            same
+            functionality.<programlisting language="xml"><lineannotation role="listingtitle">system-test-config.xml</lineannotation>
+&lt;beans&gt;
+  &lt;!-- picks up and registers AppConfig as a bean definition --&gt;
+  &lt;context:component-scan base-package="com.acme"/&gt;
+  &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
+
+  &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
+      &lt;property name="url" value="${jdbc.url}"/&gt;
+      &lt;property name="username" value="${jdbc.username}"/&gt;
+      &lt;property name="password" value="${jdbc.password}"/&gt;
+  &lt;/bean&gt;
+&lt;/beans&gt;</programlisting></para>
+        </section>
+      </section>
+
+      <section xml:id="beans-java-combining-java-centric">
+        <title><literal>@Configuration</literal> class-centric use of XML with
+          <literal>@ImportResource</literal></title>
+
+        <para>In applications where <literal>@Configuration</literal> classes
+          are the primary mechanism for configuring the container, it will still
+          likely be necessary to use at least some XML. In these scenarios,
+          simply use <literal>@ImportResource</literal> and define only as much
+          XML as is needed. Doing so achieves a "Java-centric" approach to
+          configuring the container and keeps XML to a bare minimum.
+          <programlisting language="java">@Configuration
+@ImportResource("classpath:/com/acme/properties-config.xml")
+public class AppConfig {
+  private @Value("${jdbc.url}") String url;
+  private @Value("${jdbc.username}") String username;
+  private @Value("${jdbc.password}") String password;
+
+  public @Bean DataSource dataSource() {
+      return new DriverManagerDataSource(url, username, password);
+  }
+}</programlisting>
+          <programlisting language="xml"><lineannotation role="listingtitle">properties-config.xml</lineannotation>
+&lt;beans&gt;
+  &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
+&lt;/beans&gt;</programlisting>
+          <programlisting><lineannotation role="listingtitle">jdbc.properties</lineannotation>
+jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
+jdbc.username=sa
+jdbc.password=</programlisting>
+          <programlisting language="java">public static void main(String[] args) {
+  ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
+  TransferService transferService = ctx.getBean(TransferService.class);
+  // ...
+}</programlisting></para>
+      </section>
+    </section>
+  </section>
 </section>
diff --git a/src/reference/docbook/cache.xml b/src/reference/docbook/cache.xml
index 08d2f34c0e15..01fa2d5a875f 100644
--- a/src/reference/docbook/cache.xml
+++ b/src/reference/docbook/cache.xml
@@ -57,7 +57,7 @@
     <para>Note that just like other services in Spring Framework, the caching service is an abstraction (not a cache implementation) and requires
     the use of an actual storage to store the cache data - that is, the abstraction frees the developer from having to write the caching
     logic but does not provide the actual stores. There are two integrations available out of the box, for JDK <literal>java.util.concurrent.ConcurrentMap</literal>
-    and <link xl:href="http://ehcache.org/">Ehcache</link> - see <xref linkend="cache-plug"/> for more information on plugging in other cache stores/providers.</para>
+    and <link xl:href="http://ehcache.org/">EhCache</link> - see <xref linkend="cache-plug"/> for more information on plugging in other cache stores/providers.</para>
     </section>
 
     <section xml:id="cache-annotations">
@@ -152,6 +152,13 @@ public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</pr
 
             <programlisting language="java"><![CDATA[@Cacheable(value="book", condition="#name.length < 32")
 public Book findBook(String name)]]></programlisting>
+
+            <para>In addition the <literal>conditional</literal> parameter, the <literal>unless</literal> parameter can be used to veto the adding of a value to the cache. Unlike
+            <literal>conditional</literal>, <literal>unless</literal> <literal>SpEL</literal> expressions are evalulated <emphasis>after</emphasis> the method has been called. Expanding
+            on the previous example - perhaps we only want to cache paperback books:</para>
+
+            <programlisting language="java"><![CDATA[@Cacheable(value="book", condition="#name.length < 32", unless="#result.hardback")
+public Book findBook(String name)]]></programlisting>
         </section>
 
         <section xml:id="cache-spel-context">
@@ -218,6 +225,13 @@ public Book findBook(String name)]]></programlisting>
                             <emphasis><![CDATA[#arg]]></emphasis> stands for the argument index (starting from 0).</entry>
                             <entry><screen>iban</screen> or <screen>a0</screen> (one can also use <screen>p0</screen> or <literal><![CDATA[p<#arg>]]></literal> notation as an alias).</entry>
                         </row>
+                        <row>
+                            <entry>result</entry>
+                            <entry>evaluation context</entry>
+                            <entry>The result of the method call (the value to be cached). Only available in '<literal>unless</literal>' expressions and '<literal>cache evict</literal>'
+                            expression (when <literal>beforeInvocation</literal> is <literal>false</literal>).</entry>
+                            <entry><screen>#result</screen></entry>
+                        </row>
                     </tbody>
                  </tgroup>
             </table>
@@ -544,20 +558,28 @@ public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)]]><
     </section>
 
     <section xml:id="cache-store-configuration-ehcache">
-        <title>Ehcache-based <interfacename>Cache</interfacename></title>
+        <title>EhCache-based <interfacename>Cache</interfacename></title>
 
-        <para>The Ehcache implementation is located under <literal>org.springframework.cache.ehcache</literal> package. Again, to use it, one simply needs to declare the appropriate
+        <para>The EhCache implementation is located under <literal>org.springframework.cache.ehcache</literal> package. Again, to use it, one simply needs to declare the appropriate
         <interfacename>CacheManager</interfacename>:</para>
 
         <programlisting language="xml"><![CDATA[<bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager" p:cache-manager-ref="ehcache"/>
 
-<!-- Ehcache library setup -->
+<!-- EhCache library setup -->
 <bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" p:config-location="ehcache.xml"/>]]></programlisting>
 
         <para>This setup bootstraps ehcache library inside Spring IoC (through bean <literal>ehcache</literal>) which is then wired into the dedicated <interfacename>CacheManager</interfacename>
         implementation. Note the entire ehcache-specific configuration is read from the resource <literal>ehcache.xml</literal>.</para>
     </section>
 
+    <section xml:id="cache-store-configuration-gemfire">
+        <title>GemFire-based <interfacename>Cache</interfacename></title>
+
+        <para>GemFire is a memory-oriented/disk-backed, elastically scalable, continuously available, active (with built-in pattern-based subscription notifications),
+        globally replicated database and provides fully-featured edge caching. For further information on how to use GemFire as a CacheManager (and more), please refer
+        to the <link xl:href="http://static.springsource.org/spring-gemfire/docs/1.0.0.RELEASE/reference/html/">Spring GemFire reference documentation</link>.</para>
+    </section>
+
     <section xml:id="cache-store-configuration-noop">
         <title>Dealing with caches without a backing store</title>
 
diff --git a/src/reference/docbook/jdbc.xml b/src/reference/docbook/jdbc.xml
index e3b3d7f03c40..f4af0e3b233c 100644
--- a/src/reference/docbook/jdbc.xml
+++ b/src/reference/docbook/jdbc.xml
@@ -159,19 +159,12 @@
           parameters for an SQL statement.</para>
         </listitem>
 
-        <listitem>
-          <para><emphasis role="bold">SimpleJdbcTemplate</emphasis> combines
-          the most frequently used operations of JdbcTemplate and
-          NamedParameterJdbcTemplate.</para>
-        </listitem>
-
         <listitem>
           <para><emphasis role="bold">SimpleJdbcInsert and
           SimpleJdbcCall</emphasis> optimize database metadata to limit the
           amount of necessary configuration. This approach simplifies coding
           so that you only need to provide the name of the table or procedure
-          and provide a map of parameters matching the column names. <!--Revise preceding to clarify: You *must* use this approach w/ SimpleJdbcTemplate, it is *recommended*, or you *can*?
-TR: OK. I removed the sentence since it isn;t entirely accurate. The implementation uses a plain JdbcTemplate internally.-->
+          and provide a map of parameters matching the column names.
           This only works if the database provides adequate metadata. If the
           database doesn't provide this metadata, you will have to provide
           explicit configuration of the parameters.</para>
@@ -201,8 +194,7 @@ TR: OK. I removed the sentence since it isn;t entirely accurate. The implementat
       contains the <classname>JdbcTemplate</classname> class and its various
       callback interfaces, plus a variety of related classes. A subpackage
       named <literal>org.springframework.jdbc.core.simple</literal> contains
-      the <classname>SimpleJdbcTemplate</classname> class and the related
-      <classname>SimpleJdbcInsert</classname> and
+      the <classname>SimpleJdbcInsert</classname> and
       <classname>SimpleJdbcCall</classname> classes. Another subpackage named
       <literal>org.springframework.jdbc.core.namedparam</literal> contains the
       <classname>NamedParameterJdbcTemplate</classname> class and the related
@@ -434,8 +426,6 @@ private static final class ActorMapper implements RowMapper&lt;Actor&gt; {
 
         <para>A common practice when using the
         <classname>JdbcTemplate</classname> class (and the associated <link
-        linkend="jdbc-SimpleJdbcTemplate"><classname>SimpleJdbcTemplate</classname></link>
-        and <link
         linkend="jdbc-NamedParameterJdbcTemplate"><classname>NamedParameterJdbcTemplate</classname></link>
         classes) is to configure a <interfacename>DataSource</interfacename>
         in your Spring configuration file, and then dependency-inject that
@@ -693,107 +683,6 @@ public int countOfActors(Actor exampleActor) {
       of an application.</para>
     </section>
 
-    <section xml:id="jdbc-SimpleJdbcTemplate">
-      <title><classname>SimpleJdbcTemplate</classname></title>
-
-      <para>The <classname>SimpleJdbcTemplate</classname> class wraps the
-      classic <classname>JdbcTemplate</classname> and leverages Java 5
-      language features such as varargs and autoboxing.</para>
-
-      <note>
-        <para>In Spring 3.0, the original <classname>JdbcTemplate</classname>
-        also supports Java 5-enhanced syntax with generics and varargs.
-        However, the <classname>SimpleJdbcTemplate</classname> provides a
-        simpler API that works best when you do not need access to all the
-        methods that the JdbcTemplate offers. Also, because the
-        <classname>SimpleJdbcTemplate</classname> was designed for Java 5, it
-        has more methods that take advantage of varargs due to different
-        ordering of the parameters.</para>
-      </note>
-
-      <para>The value-add of the <classname>SimpleJdbcTemplate</classname>
-      class in the area of syntactic-sugar is best illustrated with a
-      before-and-after example. The next code snippet shows data access code
-      that uses the classic <classname>JdbcTemplate</classname>, followed by a
-      code snippet that does the same job with the
-      <classname>SimpleJdbcTemplate</classname>.</para>
-
-      <programlisting language="java"><lineannotation>// classic JdbcTemplate-style...</lineannotation>
-private JdbcTemplate jdbcTemplate;
-
-public void setDataSource(DataSource dataSource) {
-    this.jdbcTemplate = new JdbcTemplate(dataSource);
-}
-<!--How is the code shown below different from the code shown in the next example? It seems like they're the same.-->
-public Actor findActor(String specialty, int age) {
-
-    String sql = "select id, first_name, last_name from T_ACTOR" +
-            " where specialty = ? and age = ?";
-
-    RowMapper&lt;Actor&gt; mapper = new RowMapper&lt;Actor&gt;() {
-        public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
-            Actor actor = new Actor();
-            actor.setId(rs.getLong("id"));
-            actor.setFirstName(rs.getString("first_name"));
-            actor.setLastName(rs.getString("last_name"));
-            return actor;
-        }
-    };
-
-
-    <lineannotation>// notice the wrapping up of the arguments in an array</lineannotation>
-    return (Actor) jdbcTemplate.queryForObject(sql, new Object[] {specialty, age}, mapper);
-}</programlisting>
-
-      <para>Here is the same method, with the
-      <classname>SimpleJdbcTemplate</classname>.<!--The code shown above is the same as the code shown below. What is the difference?
-TR: difference is in the way the parameters are passed in on the last line; no need to use an Objcet[].--></para>
-
-      <programlisting language="java"><lineannotation>// SimpleJdbcTemplate-style...</lineannotation>
-private SimpleJdbcTemplate simpleJdbcTemplate;
-
-public void setDataSource(DataSource dataSource) {
-    this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
-}
-
-public Actor findActor(String specialty, int age) {
-
-    String sql = "select id, first_name, last_name from T_ACTOR" +
-            " where specialty = ? and age = ?";
-    RowMapper&lt;Actor&gt; mapper = new RowMapper&lt;Actor&gt;() {
-        public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
-            Actor actor = new Actor();
-            actor.setId(rs.getLong("id"));
-            actor.setFirstName(rs.getString("first_name"));
-            actor.setLastName(rs.getString("last_name"));
-            return actor;
-        }
-    };
-
-    <lineannotation>// notice the use of varargs since the parameter values now come
-    // after the RowMapper parameter</lineannotation>
-    return this.simpleJdbcTemplate.queryForObject(sql, mapper, specialty, age);
-}</programlisting>
-
-      <para>See <xref linkend="jdbc-JdbcTemplate-idioms" /> for guidelines on
-      how to use the <classname>SimpleJdbcTemplate</classname> class in the
-      context of an application.</para>
-
-      <note>
-        <para>The <classname>SimpleJdbcTemplate</classname> class only offers
-        a subset of the methods exposed on the
-        <classname>JdbcTemplate</classname> class. If you need to use a method
-        from the <classname>JdbcTemplate</classname> that is not defined on
-        the <classname>SimpleJdbcTemplate</classname>, you can always access
-        the underlying <classname>JdbcTemplate</classname> by calling the
-        <methodname>getJdbcOperations()</methodname> method on the
-        <classname>SimpleJdbcTemplate</classname>, which then allows you to
-        invoke the method that you want. The only downside is that the methods
-        on the <interfacename>JdbcOperations</interfacename> interface are not
-        generic, so you are back to casting and so on.</para>
-      </note>
-    </section>
-
     <section xml:id="jdbc-SQLExceptionTranslator">
       <title><interfacename>SQLExceptionTranslator</interfacename></title>
 
@@ -1370,9 +1259,7 @@ dataSource.setPassword("");</programlisting>
 
     <para>Most JDBC drivers provide improved performance if you batch multiple
     calls to the same prepared statement. By grouping updates into batches you
-    limit the number of round trips to the database. This section covers batch
-    processing using both the <classname>JdbcTemplate</classname> and the
-    <classname>SimpleJdbcTemplate</classname>.</para>
+    limit the number of round trips to the database.</para>
 
     <section xml:id="jdbc-batch-classic">
       <title>Basic batch operations with the JdbcTemplate</title>
@@ -1579,11 +1466,11 @@ TR: Revised, please review.-->For this example, the initializing method is the
       you will see examples of multiple ones later.</para>
 
       <programlisting language="java">public class JdbcActorDao implements ActorDao {
-    private SimpleJdbcTemplate simpleJdbcTemplate;
+    private JdbcTemplate jdbcTemplate;
     private SimpleJdbcInsert insertActor;
 
     public void setDataSource(DataSource dataSource) {
-        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
+        this.jdbcTemplate = new JdbcTemplate(dataSource);
         this.insertActor =
                 new SimpleJdbcInsert(dataSource).withTableName("t_actor");
     }
@@ -1618,11 +1505,11 @@ TR: Revised, please review.-->For this example, the initializing method is the
       <classname>usingGeneratedKeyColumns</classname> method.</para>
 
       <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
-    private SimpleJdbcTemplate simpleJdbcTemplate;
+    private JdbcTemplate jdbcTemplate;
     private SimpleJdbcInsert insertActor;
 
     public void setDataSource(DataSource dataSource) {
-        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
+        this.jdbcTemplate = new JdbcTemplate(dataSource);
         this.insertActor =
                 new SimpleJdbcInsert(dataSource)
                         .withTableName("t_actor")
@@ -1658,11 +1545,11 @@ TR: Revised, please review.-->For this example, the initializing method is the
       column names with the <classname>usingColumns</classname> method:</para>
 
       <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
-    private SimpleJdbcTemplate simpleJdbcTemplate;
+    private JdbcTemplate jdbcTemplate;
     private SimpleJdbcInsert insertActor;
 
     public void setDataSource(DataSource dataSource) {
-        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
+        this.jdbcTemplate = new JdbcTemplate(dataSource);
         this.insertActor =
                 new SimpleJdbcInsert(dataSource)
                         .withTableName("t_actor")
@@ -1697,11 +1584,11 @@ TR: Revised, please review.-->For this example, the initializing method is the
       to extract the parameter values. Here is an example:</para>
 
       <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
-    private SimpleJdbcTemplate simpleJdbcTemplate;
+    private JdbcTemplate jdbcTemplate;
     private SimpleJdbcInsert insertActor;
 
     public void setDataSource(DataSource dataSource) {
-        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
+        this.jdbcTemplate = new JdbcTemplate(dataSource);
         this.insertActor =
                 new SimpleJdbcInsert(dataSource)
                         .withTableName("t_actor")
@@ -1721,11 +1608,11 @@ TR: Revised, please review.-->For this example, the initializing method is the
       can be chained.</para>
 
       <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
-    private SimpleJdbcTemplate simpleJdbcTemplate;
+    private JdbcTemplate jdbcTemplate;
     private SimpleJdbcInsert insertActor;
 
     public void setDataSource(DataSource dataSource) {
-        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
+        this.jdbcTemplate = new JdbcTemplate(dataSource);
         this.insertActor =
                 new SimpleJdbcInsert(dataSource)
                         .withTableName("t_actor")
@@ -1786,11 +1673,11 @@ END;</programlisting>The <code>in_id</code> parameter contains the
       procedure.<!--Indicate what the purpose of this example is (what it does) and identify the name of procedure. Also see next query. TR: Revised, please review.--></para>
 
       <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
-    private SimpleJdbcTemplate simpleJdbcTemplate;
+    private JdbcTemplate jdbcTemplate;
     private SimpleJdbcCall procReadActor;
 
     public void setDataSource(DataSource dataSource) {
-        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
+        this.jdbcTemplate = new JdbcTemplate(dataSource);
         this.procReadActor =
                 new SimpleJdbcCall(dataSource)
                         .withProcedureName("read_actor");
@@ -2004,11 +1891,11 @@ END;</programlisting></para>
       method.</para>
 
       <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
-    private SimpleJdbcTemplate simpleJdbcTemplate;
+    private JdbcTemplate jdbcTemplate;
     private SimpleJdbcCall funcGetActorName;
 
     public void setDataSource(DataSource dataSource) {
-        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
+        this.jdbcTemplate = new JdbcTemplate(dataSource);
         JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
         jdbcTemplate.setResultsMapCaseInsensitive(true);
         this.funcGetActorName =
@@ -2062,11 +1949,9 @@ END;</programlisting>To call this procedure you declare the
       <classname>newInstance</classname> method.</para>
 
       <para><programlisting language="java">public class JdbcActorDao implements ActorDao {
-    private SimpleJdbcTemplate simpleJdbcTemplate;
     private SimpleJdbcCall procReadAllActors;
 
     public void setDataSource(DataSource dataSource) {
-        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
         JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
         jdbcTemplate.setResultsMapCaseInsensitive(true);
         this.procReadAllActors =
@@ -2679,7 +2564,7 @@ clobReader.close();]]></programlisting>
       or you need to generate the SQL string dynamically once you know how
       many placeholders are required. The named parameter support provided in
       the <classname>NamedParameterJdbcTemplate</classname> and
-      <classname>SimpleJdbcTemplate</classname> takes the latter approach.
+      <classname>JdbcTemplate</classname> takes the latter approach.
       Pass in the values as a <classname>java.util.List</classname> of
       primitive objects. This list will be used to insert the required
       placeholders and pass in the values during the statement
diff --git a/src/reference/docbook/migration-3.2.xml b/src/reference/docbook/migration-3.2.xml
index c96b43d8ba12..79f5c9150c40 100644
--- a/src/reference/docbook/migration-3.2.xml
+++ b/src/reference/docbook/migration-3.2.xml
@@ -138,16 +138,14 @@
     depend on JUnit 4.11 (<literal>junit:junit</literal>), TestNG 6.5.2
     (<literal>org.testng:testng</literal>), and Hamcrest Core 1.3
     (<literal>org.hamcrest:hamcrest-core</literal>). Each of these
-    dependencies is declared as an <emphasis>optional</emphasis> dependency
-    in the Maven POM. Furthermore, it is important to note that the JUnit
-    team has stopped inlining Hamcrest Core within the
-    <literal>junit:junit</literal> Maven artifact as of JUnit 4.11. Thus, if
-    your existing JUnit-based tests make use of Hamcrest matchers that were
-    previously available directly within the <literal>junit:junit</literal>
-    JAR, you will now need to explicitly declare a dependency on
-    <literal>org.hamcrest:hamcrest-core</literal>,
-    <literal>org.hamcrest:hamcrest-library</literal>, or
-    <literal>org.hamcrest:hamcrest-all</literal>.</para>
+    dependencies is declared as an <emphasis>optional</emphasis> dependency in
+    the Maven POM. Furthermore, it is important to note that the JUnit team
+    has stopped inlining Hamcrest Core within the
+    <literal>junit:junit</literal> Maven artifact as of JUnit 4.11. Hamcrest
+    Core is now a <emphasis>required</emphasis> transitive dependency of
+    <literal>junit</literal>, and users may therefore need to remove any
+    exclusions on <literal>hamcrest-core</literal> that they had previously
+    configured for their build.</para>
   </section>
 
   <section xml:id="migration-3.2-changes">
diff --git a/src/reference/docbook/mvc.xml b/src/reference/docbook/mvc.xml
index c8aebb4f8a4f..a9e8489af349 100644
--- a/src/reference/docbook/mvc.xml
+++ b/src/reference/docbook/mvc.xml
@@ -1062,7 +1062,7 @@ public class RelativePathUriTemplateController {
         example:</para>
 
         <programlisting language="java">
-@RequestMapping("/spring-web/{symbolicName:[a-z-]+}-{version:\d\.\d\.\d}.{extension:\.[a-z]}")
+@RequestMapping("/spring-web/{symbolicName:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{extension:\\.[a-z]+}")
   public void handle(@PathVariable String version, @PathVariable String extension) {
     // ...
   }
@@ -2157,6 +2157,14 @@ public class EditPetForm {
         available through the
         <literal>ServletRequest.getParameter*()</literal> family of
         methods.</para>
+
+        <note>
+          <para>As <classname>HttpPutFormContentFilter</classname> consumes the body of the
+          request, it should not be configured for PUT or PATCH URLs that rely on other
+          converters for <literal>application/x-www-form-urlencoded</literal>. This includes
+          <literal>@RequestBody MultiValueMap&lt;String, String&gt;</literal> and
+          <literal>HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;</literal>.</para>
+        </note>
       </section>
 
       <section xml:id="mvc-ann-cookievalue">
@@ -2594,7 +2602,7 @@ deferredResult.setResult(data);
 
     ...
 
-  &lt;web-app&gt;
+  &lt;/web-app&gt;
   </programlisting>
 
           <para>The <classname>DispatcherServlet</classname> and any
diff --git a/src/reference/docbook/new-in-3.2.xml b/src/reference/docbook/new-in-3.2.xml
index 1f3d04e3ba43..dc53ce9777a7 100644
--- a/src/reference/docbook/new-in-3.2.xml
+++ b/src/reference/docbook/new-in-3.2.xml
@@ -57,7 +57,7 @@
   <section xml:id="new-in-3.2-webmvc-content-negotiation">
     <title>Content negotiation improvements</title>
 
-    <para>A <interfacename>ContentNeogtiationStrategy</interfacename> is now
+    <para>A <interfacename>ContentNegotiationStrategy</interfacename> is now
     available for resolving the requested media types from an incoming
     request. The available implementations are based on the file extension,
     query parameter, the 'Accept' header, or a fixed content type.
@@ -120,7 +120,7 @@
     <interfacename>@ExceptionHandler</interfacename> method that handles
     standard Spring MVC exceptions and returns a
     <classname>ResponseEntity</classname> that allowing customizing and
-    writing the response with HTTP message converters. This servers as an
+    writing the response with HTTP message converters. This serves as an
     alternative to the <classname>DefaultHandlerExceptionResolver</classname>,
     which does the same but returns a <classname>ModelAndView</classname>
     instead.</para>
@@ -274,6 +274,12 @@
         WebApplicationContext</link> in integration tests</para>
       </listitem>
 
+      <listitem>
+        <para>Configuring <link
+        linkend="testcontext-ctx-management-ctx-hierarchies">context hierarchies</link>
+        in integration tests</para>
+      </listitem>
+
       <listitem>
         <para>Testing <link linkend="testcontext-web-scoped-beans">request and
         session scoped beans</link></para>
diff --git a/src/reference/docbook/oxm.xml b/src/reference/docbook/oxm.xml
index 00ae3966209f..1a7cbac17c5f 100644
--- a/src/reference/docbook/oxm.xml
+++ b/src/reference/docbook/oxm.xml
@@ -332,6 +332,9 @@ public class Application {
                 <listitem>
                     <para><link linkend="oxm-xmlbeans-xsd"><literal>xmlbeans-marshaller</literal></link></para>
                 </listitem>
+                <listitem>
+                    <para><link linkend="oxm-castor-xsd"><literal>castor-marshaller</literal></link></para>
+                </listitem>
                 <listitem>
                     <para><link linkend="oxm-jibx-xsd"><literal>jibx-marshaller</literal></link></para>
                 </listitem>
@@ -475,6 +478,86 @@ public class Application {
     </bean>
 </beans>
 ]]></programlisting>
+            <section xml:id="oxm-castor-xsd">
+                <title>XML Schema-based Configuration</title>
+                <para>
+                    The <literal>castor-marshaller</literal> tag configures a
+                    <classname>org.springframework.oxm.castor.CastorMarshaller</classname>.
+                    Here is an example:
+                </para>
+
+                <programlisting language="xml">
+                    <![CDATA[<oxm:castor-marshaller id="marshaller" mapping-location="classpath:org/springframework/oxm/castor/mapping.xml"/>]]></programlisting>
+
+                <para>
+                    The marshaller instance can be configured in two ways, by specifying either the location of
+                    a mapping file (through the <property>mapping-location</property> property), or by
+                    identifying Java POJOs (through the <property>target-class</property> or
+                    <property>target-package</property> properties) for which there exist corresponding
+                    XML descriptor classes. The latter way is usually used in conjunction with XML code generation
+                    from XML schemas.
+                </para>
+
+                <para>
+                    Available attributes are:
+                    <informaltable>
+                        <tgroup cols="3">
+                            <colspec colwidth="1.5*"/>
+                            <colspec colwidth="4*"/>
+                            <colspec colwidth="1*"/>
+                            <thead>
+                                <row>
+                                    <entry>Attribute</entry>
+                                    <entry>Description</entry>
+                                    <entry>Required</entry>
+                                </row>
+                            </thead>
+                            <tbody>
+                                <row>
+                                    <entry>
+                                        <literal>id</literal>
+                                    </entry>
+                                    <entry>the id of the marshaller</entry>
+                                    <entry>no</entry>
+                                </row>
+                                <row>
+                                    <entry>
+                                        <literal>encoding</literal>
+                                    </entry>
+                                    <entry>the encoding to use for unmarshalling from XML</entry>
+                                    <entry>no</entry>
+                                </row>
+                                <row>
+                                    <entry>
+                                        <literal>target-class</literal>
+                                    </entry>
+                                    <entry>a Java class name for a POJO for which an XML class descriptor is available (as
+                                        generated through code generation)
+                                    </entry>
+                                    <entry>no</entry>
+                                </row>
+                                <row>
+                                    <entry>
+                                        <literal>target-package</literal>
+                                    </entry>
+                                    <entry>a Java package name that identifies a package that contains POJOs and their
+                                        corresponding Castor
+                                        XML descriptor classes (as generated through code generation from XML schemas)
+                                    </entry>
+                                    <entry>no</entry>
+                                </row>
+                                <row>
+                                    <entry>
+                                        <literal>mapping-location</literal>
+                                    </entry>
+                                    <entry>location of a Castor XML mapping file</entry>
+                                    <entry>no</entry>
+                                </row>
+                            </tbody>
+                        </tgroup>
+                    </informaltable>
+                </para>
+            </section>
         </section>
     </section>
 
diff --git a/src/reference/docbook/scheduling.xml b/src/reference/docbook/scheduling.xml
index 6c5b7fbe83c3..a30a0f7d9984 100644
--- a/src/reference/docbook/scheduling.xml
+++ b/src/reference/docbook/scheduling.xml
@@ -840,9 +840,9 @@ public class ExampleJob extends QuartzJobBean {
       object. Of course, we still need to schedule the jobs themselves. This
       is done using triggers and a
       <classname>SchedulerFactoryBean</classname>. Several triggers are
-      available within Quartz. Spring offers two subclassed triggers with
-      convenient defaults: <classname>CronTriggerBean</classname> and
-      <classname>SimpleTriggerBean</classname>.</para>
+      available within Quartz and Spring offers two Quartz <interfacename>FactoryBean</interfacename>
+      implementations with convenient defaults: <classname>CronTriggerFactoryBean</classname> and
+      <classname>SimpleTriggerFactoryBean</classname>.</para>
 
       <para>Triggers need to be scheduled. Spring offers a
       <classname>SchedulerFactoryBean</classname> that exposes triggers to be
@@ -851,7 +851,7 @@ public class ExampleJob extends QuartzJobBean {
 
       <para>Find below a couple of examples:</para>
 
-      <programlisting language="xml">&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean"&gt;
+      <programlisting language="xml">&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt;
     &lt;!-- see the example of method invoking job above --&gt;
     &lt;property name="jobDetail" ref="jobDetail" /&gt;
     &lt;!-- 10 seconds --&gt;
@@ -860,7 +860,7 @@ public class ExampleJob extends QuartzJobBean {
     &lt;property name="repeatInterval" value="50000" /&gt;
 &lt;/bean&gt;
 
-&lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;
+&lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt;
     &lt;property name="jobDetail" ref="exampleJob" /&gt;
     &lt;!-- run every morning at 6 AM --&gt;
     &lt;property name="cronExpression" value="0 0 6 * * ?" /&gt;
diff --git a/src/reference/docbook/testing.xml b/src/reference/docbook/testing.xml
index 7e819cec47f1..bb26dc0c5436 100644
--- a/src/reference/docbook/testing.xml
+++ b/src/reference/docbook/testing.xml
@@ -1,12 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<chapter xml:id="testing"
-	xmlns="http://docbook.org/ns/docbook" version="5.0"
-    xmlns:xl="http://www.w3.org/1999/xlink"
-    xmlns:xi="http://www.w3.org/2001/XInclude"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="
-        http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd
-        http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd">
+<chapter version="5.0"
+         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
+         xml:id="testing" xmlns="http://docbook.org/ns/docbook"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xmlns:xs="http://www.w3.org/2001/XMLSchema"
+         xmlns:xl="http://www.w3.org/1999/xlink"
+         xmlns:xi="http://www.w3.org/2001/XInclude"
+         xmlns:ns2="http://www.w3.org/1998/Math/MathML"
+         xmlns:ns="http://docbook.org/ns/docbook">
   <title>Testing</title>
 
   <section xml:id="testing-introduction">
@@ -14,11 +15,10 @@
 
     <para>Testing is an integral part of enterprise software development. This
     chapter focuses on the value-add of the IoC principle to <link
-    linkend="unit-testing">unit testing</link> and on the benefits of the
-    Spring Framework's support for <link
-    linkend="integration-testing">integration testing</link>. <emphasis>(A
-    thorough treatment of testing in the enterprise is beyond the scope of
-    this reference manual.)</emphasis></para>
+    linkend="unit-testing">unit testing</link> and on the benefits of the Spring
+    Framework's support for <link linkend="integration-testing">integration
+    testing</link>. <emphasis>(A thorough treatment of testing in the enterprise
+    is beyond the scope of this reference manual.)</emphasis></para>
   </section>
 
   <section xml:id="unit-testing">
@@ -27,21 +27,21 @@
     <para>Dependency Injection should make your code less dependent on the
     container than it would be with traditional Java EE development. The POJOs
     that make up your application should be testable in JUnit or TestNG tests,
-    with objects simply instantiated using the <literal>new</literal>
-    operator, <emphasis>without Spring or any other container</emphasis>. You
-    can use <link linkend="mock-objects">mock objects</link> (in conjunction
-    with other valuable testing techniques) to test your code in isolation. If
-    you follow the architecture recommendations for Spring, the resulting
-    clean layering and componentization of your codebase will facilitate
-    easier unit testing. For example, you can test service layer objects by
-    stubbing or mocking DAO or Repository interfaces, without needing to
-    access persistent data while running unit tests.</para>
+    with objects simply instantiated using the <literal>new</literal> operator,
+    <emphasis>without Spring or any other container</emphasis>. You can use
+    <link linkend="mock-objects">mock objects</link> (in conjunction with other
+    valuable testing techniques) to test your code in isolation. If you follow
+    the architecture recommendations for Spring, the resulting clean layering
+    and componentization of your codebase will facilitate easier unit testing.
+    For example, you can test service layer objects by stubbing or mocking DAO
+    or Repository interfaces, without needing to access persistent data while
+    running unit tests.</para>
 
     <para>True unit tests typically run extremely quickly, as there is no
     runtime infrastructure to set up. Emphasizing true unit tests as part of
-    your development methodology will boost your productivity. You may not
-    need this section of the testing chapter to help you write effective unit
-    tests for your IoC-based applications. For certain unit testing scenarios,
+    your development methodology will boost your productivity. You may not need
+    this section of the testing chapter to help you write effective unit tests
+    for your IoC-based applications. For certain unit testing scenarios,
     however, the Spring Framework provides the following mock objects and
     testing support classes.</para>
 
@@ -54,10 +54,9 @@
         <para>The <literal>org.springframework.mock.env</literal> package
         contains mock implementations of the
         <interfacename>Environment</interfacename> and
-        <interfacename>PropertySource</interfacename> abstractions introduced
-        in Spring 3.1 (see <xref
-        linkend="new-in-3.1-environment-abstraction" /> and <xref
-        linkend="new-in-3.1-property-source-abstraction" />).
+        <interfacename>PropertySource</interfacename> abstractions introduced in
+        Spring 3.1 (see <xref linkend="new-in-3.1-environment-abstraction"/> and
+        <xref linkend="new-in-3.1-property-source-abstraction"/>).
         <classname>MockEnvironment</classname> and
         <classname>MockPropertySource</classname> are useful for developing
         <emphasis>out-of-container</emphasis> tests for code that depends on
@@ -68,12 +67,12 @@
         <title>JNDI</title>
 
         <para>The <literal>org.springframework.mock.jndi</literal> package
-        contains an implementation of the JNDI SPI, which you can use to set
-        up a simple JNDI environment for test suites or stand-alone
-        applications. If, for example, JDBC <classname>DataSource</classname>s
-        get bound to the same JNDI names in test code as within a Java EE
-        container, you can reuse both application code and configuration in
-        testing scenarios without modification.</para>
+        contains an implementation of the JNDI SPI, which you can use to set up
+        a simple JNDI environment for test suites or stand-alone applications.
+        If, for example, JDBC <classname>DataSource</classname>s get bound to
+        the same JNDI names in test code as within a Java EE container, you can
+        reuse both application code and configuration in testing scenarios
+        without modification.</para>
       </section>
 
       <section xml:id="mock-objects-servlet">
@@ -81,8 +80,8 @@
 
         <para>The <literal>org.springframework.mock.web</literal> package
         contains a comprehensive set of Servlet API mock objects, targeted at
-        usage with Spring's Web MVC framework, which are useful for testing
-        web contexts and controllers. These mock objects are generally more
+        usage with Spring's Web MVC framework, which are useful for testing web
+        contexts and controllers. These mock objects are generally more
         convenient to use than dynamic mock objects such as <link
         xl:href="http://www.easymock.org">EasyMock</link> or existing Servlet
         API mock objects such as <link
@@ -107,8 +106,8 @@
         <para>The <literal>org.springframework.test.util</literal> package
         contains <classname>ReflectionTestUtils</classname>, which is a
         collection of reflection-based utility methods. Developers use these
-        methods in unit and integration testing scenarios in which they need
-        to set a non-<literal>public</literal> field or invoke a
+        methods in unit and integration testing scenarios in which they need to
+        set a non-<literal>public</literal> field or invoke a
         non-<literal>public</literal> setter method when testing application
         code involving, for example:</para>
 
@@ -124,8 +123,8 @@
             <para>Spring's support for annotations such as
             <interfacename>@Autowired</interfacename>,
             <interfacename>@Inject</interfacename>, and
-            <interfacename>@Resource,</interfacename> which provides
-            dependency injection for <literal>private</literal> or
+            <interfacename>@Resource,</interfacename> which provides dependency
+            injection for <literal>private</literal> or
             <literal>protected</literal> fields, setter methods, and
             configuration methods.</para>
           </listitem>
@@ -136,9 +135,9 @@
         <title>Spring MVC</title>
 
         <para>The <literal>org.springframework.test.web</literal> package
-        contains <classname>ModelAndViewAssert</classname>, which you can use
-        in combination with JUnit, TestNG, or any other testing framework for
-        unit tests dealing with Spring MVC <classname>ModelAndView</classname>
+        contains <classname>ModelAndViewAssert</classname>, which you can use in
+        combination with JUnit, TestNG, or any other testing framework for unit
+        tests dealing with Spring MVC <classname>ModelAndView</classname>
         objects.</para>
 
         <tip>
@@ -149,8 +148,7 @@
           <literal>MockHttpServletRequest</literal>,
           <literal>MockHttpSession</literal>, and so on from the <link
           linkend="mock-objects-servlet">
-          <literal>org.springframework.mock.web</literal></link>
-          package.</para>
+          <literal>org.springframework.mock.web</literal></link> package.</para>
         </tip>
       </section>
     </section>
@@ -164,13 +162,12 @@
 
       <para>It is important to be able to perform some integration testing
       without requiring deployment to your application server or connecting to
-      other enterprise infrastructure. This will enable you to test things
-      such as:</para>
+      other enterprise infrastructure. This will enable you to test things such
+      as:</para>
 
       <itemizedlist>
         <listitem>
-          <para>The correct wiring of your Spring IoC container
-          contexts.</para>
+          <para>The correct wiring of your Spring IoC container contexts.</para>
         </listitem>
 
         <listitem>
@@ -182,30 +179,29 @@
 
       <para>The Spring Framework provides first-class support for integration
       testing in the <filename class="libraryfile">spring-test</filename>
-      module. The name of the actual JAR file might include the release
-      version and might also be in the long
-      <filename>org.springframework.test</filename> form, depending on where
-      you get it from (see the <link linkend="dependency-management">section
-      on Dependency Management</link> for an explanation). This library
-      includes the <literal>org.springframework.test</literal> package, which
-      contains valuable classes for integration testing with a Spring
-      container. This testing does not rely on an application server or other
-      deployment environment. Such tests are slower to run than unit tests but
-      much faster than the equivalent Cactus tests or remote tests that rely
-      on deployment to an application server.</para>
+      module. The name of the actual JAR file might include the release version
+      and might also be in the long
+      <filename>org.springframework.test</filename> form, depending on where you
+      get it from (see the <link linkend="dependency-management">section on
+      Dependency Management</link> for an explanation). This library includes
+      the <literal>org.springframework.test</literal> package, which contains
+      valuable classes for integration testing with a Spring container. This
+      testing does not rely on an application server or other deployment
+      environment. Such tests are slower to run than unit tests but much faster
+      than the equivalent Cactus tests or remote tests that rely on deployment
+      to an application server.</para>
 
       <para>In Spring 2.5 and later, unit and integration testing support is
       provided in the form of the annotation-driven <link
       linkend="testcontext-framework">Spring TestContext Framework</link>. The
-      TestContext framework is agnostic of the actual testing framework in
-      use, thus allowing instrumentation of tests in various environments
-      including JUnit, TestNG, and so on.</para>
+      TestContext framework is agnostic of the actual testing framework in use,
+      thus allowing instrumentation of tests in various environments including
+      JUnit, TestNG, and so on.</para>
 
       <warning>
         <title>JUnit 3.8 support is deprecated</title>
 
-        <para>As of Spring 3.0, the legacy JUnit 3.8 base class hierarchy
-        (i.e.,
+        <para>As of Spring 3.0, the legacy JUnit 3.8 base class hierarchy (i.e.,
         <classname>AbstractDependencyInjectionSpringContextTests</classname>,
         <classname>AbstractTransactionalDataSourceSpringContextTests</classname>,
         etc.) is officially deprecated and will be removed in a later release.
@@ -221,10 +217,10 @@
         officially deprecated and will be removed in a later release. Any test
         classes based on this code should be migrated to the JUnit 4 or TestNG
         support provided by the <link linkend="testcontext-framework">Spring
-        TestContext Framework</link>. Similarly, any test methods annotated
-        with <interfacename>@ExpectedException</interfacename> should be
-        modified to use the built-in support for expected exceptions in JUnit
-        and TestNG.</para>
+        TestContext Framework</link>. Similarly, any test methods annotated with
+        <interfacename>@ExpectedException</interfacename> should be modified to
+        use the built-in support for expected exceptions in JUnit and
+        TestNG.</para>
       </warning>
     </section>
 
@@ -252,9 +248,8 @@
 
         <listitem>
           <para>To supply <link
-          linkend="testing-support-classes">Spring-specific base
-          classes</link> that assist developers in writing integration
-          tests.</para>
+          linkend="testing-support-classes">Spring-specific base classes</link>
+          that assist developers in writing integration tests.</para>
         </listitem>
       </itemizedlist>
 
@@ -267,18 +262,18 @@
         <para>The Spring TestContext Framework provides consistent loading of
         Spring <classname>ApplicationContext</classname>s and
         <classname>WebApplicationContext</classname>s as well as caching of
-        those contexts. Support for the caching of loaded contexts is
-        important, because startup time can become an issue  not because of
-        the overhead of Spring itself, but because the objects instantiated by
-        the Spring container take time to instantiate. For example, a project
-        with 50 to 100 Hibernate mapping files might take 10 to 20 seconds to
-        load the mapping files, and incurring that cost before running every
-        test in every test fixture leads to slower overall test runs that
-        reduce developer productivity.</para>
+        those contexts. Support for the caching of loaded contexts is important,
+        because startup time can become an issue  not because of the overhead
+        of Spring itself, but because the objects instantiated by the Spring
+        container take time to instantiate. For example, a project with 50 to
+        100 Hibernate mapping files might take 10 to 20 seconds to load the
+        mapping files, and incurring that cost before running every test in
+        every test fixture leads to slower overall test runs that reduce
+        developer productivity.</para>
 
         <para>Test classes typically declare either an array of
-        <emphasis>resource locations</emphasis> for XML configuration metadata
-         often in the classpath  or an array of <emphasis>annotated
+        <emphasis>resource locations</emphasis> for XML configuration metadata 
+        often in the classpath  or an array of <emphasis>annotated
         classes</emphasis> that is used to configure the application. These
         locations or classes are the same as or similar to those specified in
         <literal>web.xml</literal> or other deployment configuration
@@ -291,29 +286,28 @@
         <emphasis>test suite</emphasis> means all tests run in the same JVM 
         for example, all tests run from an Ant, Maven, or Gradle build for a
         given project or module. In the unlikely case that a test corrupts the
-        application context and requires reloading  for example, by modifying
-        a bean definition or the state of an application object  the
-        TestContext framework can be configured to reload the configuration
-        and rebuild the application context before executing the next
-        test.</para>
-
-        <para>See context management and caching with the <link
-        linkend="testcontext-ctx-management">TestContext
-        framework</link>.</para>
+        application context and requires reloading  for example, by modifying a
+        bean definition or the state of an application object  the TestContext
+        framework can be configured to reload the configuration and rebuild the
+        application context before executing the next test.</para>
+
+        <para>See <xref linkend="testcontext-ctx-management"/> and <xref
+        linkend="testcontext-ctx-management-caching"/> with the TestContext
+        framework.</para>
       </section>
 
       <section xml:id="testing-fixture-di">
         <title>Dependency Injection of test fixtures</title>
 
-        <para>When the TestContext framework loads your application context,
-        it can optionally configure instances of your test classes via
-        Dependency Injection. This provides a convenient mechanism for setting
-        up test fixtures using preconfigured beans from your application
-        context. A strong benefit here is that you can reuse application
-        contexts across various testing scenarios (e.g., for configuring
-        Spring-managed object graphs, transactional proxies,
-        <classname>DataSource</classname>s, etc.), thus avoiding the need to
-        duplicate complex test fixture setup for individual test cases.</para>
+        <para>When the TestContext framework loads your application context, it
+        can optionally configure instances of your test classes via Dependency
+        Injection. This provides a convenient mechanism for setting up test
+        fixtures using preconfigured beans from your application context. A
+        strong benefit here is that you can reuse application contexts across
+        various testing scenarios (e.g., for configuring Spring-managed object
+        graphs, transactional proxies, <classname>DataSource</classname>s,
+        etc.), thus avoiding the need to duplicate complex test fixture setup
+        for individual test cases.</para>
 
         <para>As an example, consider the scenario where we have a class,
         <classname>HibernateTitleRepository</classname>, that implements data
@@ -322,22 +316,22 @@
 
         <itemizedlist>
           <listitem>
-            <para>The Spring configuration: basically, is everything related
-            to the configuration of the
+            <para>The Spring configuration: basically, is everything related to
+            the configuration of the
             <classname>HibernateTitleRepository</classname> bean correct and
             present?</para>
           </listitem>
 
           <listitem>
-            <para>The Hibernate mapping file configuration: is everything
-            mapped correctly, and are the correct lazy-loading settings in
+            <para>The Hibernate mapping file configuration: is everything mapped
+            correctly, and are the correct lazy-loading settings in
             place?</para>
           </listitem>
 
           <listitem>
             <para>The logic of the
-            <classname>HibernateTitleRepository</classname>: does the
-            configured instance of this class perform as anticipated?</para>
+            <classname>HibernateTitleRepository</classname>: does the configured
+            instance of this class perform as anticipated?</para>
           </listitem>
         </itemizedlist>
 
@@ -351,21 +345,20 @@
         <para>One common issue in tests that access a real database is their
         effect on the state of the persistence store. Even when you're using a
         development database, changes to the state may affect future tests.
-        Also, many operations  such as inserting or modifying persistent data
-         cannot be performed (or verified) outside a transaction.</para>
+        Also, many operations  such as inserting or modifying persistent data 
+        cannot be performed (or verified) outside a transaction.</para>
 
         <para>The TestContext framework addresses this issue. By default, the
         framework will create and roll back a transaction for each test. You
-        simply write code that can assume the existence of a transaction. If
-        you call transactionally proxied objects in your tests, they will
-        behave correctly, according to their configured transactional
-        semantics. In addition, if a test method deletes the contents of
-        selected tables while running within the transaction managed for the
-        test, the transaction will roll back by default, and the database will
-        return to its state prior to execution of the test. Transactional
-        support is provided to a test via a
-        <classname>PlatformTransactionManager</classname> bean defined in the
-        test's application context.</para>
+        simply write code that can assume the existence of a transaction. If you
+        call transactionally proxied objects in your tests, they will behave
+        correctly, according to their configured transactional semantics. In
+        addition, if a test method deletes the contents of selected tables while
+        running within the transaction managed for the test, the transaction
+        will roll back by default, and the database will return to its state
+        prior to execution of the test. Transactional support is provided to a
+        test via a <classname>PlatformTransactionManager</classname> bean
+        defined in the test's application context.</para>
 
         <para>If you want a transaction to commit  unusual, but occasionally
         useful when you want a particular test to populate or modify the
@@ -384,10 +377,10 @@
         <title>Support classes for integration testing</title>
 
         <para>The Spring TestContext Framework provides several
-        <literal>abstract</literal> support classes that simplify the writing
-        of integration tests. These base test classes provide well-defined
-        hooks into the testing framework as well as convenient instance
-        variables and methods, which enable you to access:</para>
+        <literal>abstract</literal> support classes that simplify the writing of
+        integration tests. These base test classes provide well-defined hooks
+        into the testing framework as well as convenient instance variables and
+        methods, which enable you to access:</para>
 
         <itemizedlist>
           <listitem>
@@ -400,18 +393,18 @@
             <para>A <classname>JdbcTemplate</classname>, for executing SQL
             statements to query the database. Such queries can be used to
             confirm database state both <emphasis>prior to</emphasis> and
-            <emphasis>after</emphasis> execution of database-related
-            application code, and Spring ensures that such queries run in the
-            scope of the same transaction as the application code. When used
-            in conjunction with an ORM tool, be sure to avoid <link
+            <emphasis>after</emphasis> execution of database-related application
+            code, and Spring ensures that such queries run in the scope of the
+            same transaction as the application code. When used in conjunction
+            with an ORM tool, be sure to avoid <link
             linkend="testcontext-tx-false-positives">false
             positives</link>.</para>
           </listitem>
         </itemizedlist>
 
         <para>In addition, you may want to create your own custom,
-        application-wide superclass with instance variables and methods
-        specific to your project.</para>
+        application-wide superclass with instance variables and methods specific
+        to your project.</para>
 
         <para>See support classes for the <link
         linkend="testcontext-support-classes">TestContext
@@ -435,8 +428,8 @@
       <para>The <literal>spring-jdbc</literal> module provides support for
       configuring and launching an embedded database which can be used in
       integration tests that interact with a database. For details, see <xref
-      linkend="jdbc-embedded-database-support" /> and <xref
-      linkend="jdbc-embedded-database-dao-testing" />.</para>
+      linkend="jdbc-embedded-database-support"/> and <xref
+      linkend="jdbc-embedded-database-dao-testing"/>.</para>
     </section>
 
     <section xml:id="integration-testing-annotations">
@@ -449,8 +442,7 @@
         <emphasis>Spring-specific</emphasis> annotations that you can use in
         your unit and integration tests in conjunction with the TestContext
         framework. Refer to the respective Javadoc for further information,
-        including default attribute values, attribute aliases, and so
-        on.</para>
+        including default attribute values, attribute aliases, and so on.</para>
 
         <itemizedlist>
           <listitem>
@@ -458,8 +450,8 @@
             <interfacename>@ContextConfiguration</interfacename>
             </emphasis></para>
 
-            <para>Defines class-level metadata that is used to determine how
-            to load and configure an
+            <para>Defines class-level metadata that is used to determine how to
+            load and configure an
             <interfacename>ApplicationContext</interfacename> for integration
             tests. Specifically,
             <interfacename>@ContextConfiguration</interfacename> declares
@@ -480,36 +472,34 @@ public class XmlApplicationContextTests {
 }</programlisting>
 
             <programlisting language="java"><emphasis role="bold">@ContextConfiguration</emphasis>(<emphasis
-                role="bold">classes</emphasis>=TestConfig.class)
+                role="bold">classes</emphasis> = TestConfig.class)
 public class ConfigClassApplicationContextTests {
     <lineannotation>// class body...</lineannotation>
 }</programlisting>
 
             <para>As an alternative or in addition to declaring resource
             locations or annotated classes,
-            <interfacename>@ContextConfiguration</interfacename> may be used
-            to declare
-            <interfacename>ApplicationContextInitializer</interfacename>
+            <interfacename>@ContextConfiguration</interfacename> may be used to
+            declare <interfacename>ApplicationContextInitializer</interfacename>
             classes.</para>
 
             <programlisting language="java"><emphasis role="bold">@ContextConfiguration</emphasis>(<emphasis
-                role="bold">initializers</emphasis>=CustomContextIntializer.class)
+                role="bold">initializers</emphasis> = CustomContextIntializer.class)
 public class ContextInitializerTests {
     <lineannotation>// class body...</lineannotation>
 }</programlisting>
 
             <para><interfacename>@ContextConfiguration</interfacename> may
             optionally be used to declare the
-            <interfacename>ContextLoader</interfacename> strategy as well.
-            Note, however, that you typically do not need to explicitly
-            configure the loader since the default loader supports either
-            resource <varname>locations</varname> or annotated
-            <varname>classes</varname> as well as
-            <varname>initializers</varname>.</para>
+            <interfacename>ContextLoader</interfacename> strategy as well. Note,
+            however, that you typically do not need to explicitly configure the
+            loader since the default loader supports either resource
+            <varname>locations</varname> or annotated <varname>classes</varname>
+            as well as <varname>initializers</varname>.</para>
 
             <programlisting language="java"><emphasis role="bold">@ContextConfiguration</emphasis>(<emphasis
-                role="bold">locations</emphasis>="/test-context.xml", <emphasis
-                role="bold">loader</emphasis>=CustomContextLoader.class)
+                role="bold">locations</emphasis> = "/test-context.xml", <emphasis
+                role="bold">loader</emphasis> = CustomContextLoader.class)
 public class CustomLoaderXmlApplicationContextTests {
     <lineannotation>// class body...</lineannotation>
 }</programlisting>
@@ -517,14 +507,13 @@ public class CustomLoaderXmlApplicationContextTests {
             <note>
               <para><interfacename>@ContextConfiguration</interfacename>
               provides support for <emphasis>inheriting</emphasis> resource
-              locations or configuration classes as well as context
-              initializers declared by superclasses by default.</para>
+              locations or configuration classes as well as context initializers
+              declared by superclasses by default.</para>
             </note>
 
-            <para>See <link linkend="testcontext-ctx-management">Context
-            management and caching</link> and the Javadoc for
-            <interfacename>@ContextConfiguration</interfacename> for further
-            details.</para>
+            <para>See <xref linkend="testcontext-ctx-management"/> and the
+            Javadoc for <interfacename>@ContextConfiguration</interfacename> for
+            further details.</para>
           </listitem>
 
           <listitem>
@@ -535,16 +524,15 @@ public class CustomLoaderXmlApplicationContextTests {
             <interfacename>ApplicationContext</interfacename> loaded for an
             integration test should be a
             <interfacename>WebApplicationContext</interfacename>. The mere
-            presence of <interfacename>@WebAppConfiguration</interfacename> on
-            a test class ensures that a
-            <interfacename>WebApplicationContext</interfacename> will be
-            loaded for the test, using the default value of
+            presence of <interfacename>@WebAppConfiguration</interfacename> on a
+            test class ensures that a
+            <interfacename>WebApplicationContext</interfacename> will be loaded
+            for the test, using the default value of
             <literal>"file:src/main/webapp"</literal> for the path to the root
             of the web application (i.e., the <emphasis>resource base
             path</emphasis>). The resource base path is used behind the scenes
             to create a <classname>MockServletContext</classname> which serves
-            as the <interfacename>ServletContext</interfacename> for the
-            test's
+            as the <interfacename>ServletContext</interfacename> for the test's
             <interfacename>WebApplicationContext</interfacename>.</para>
 
             <programlisting language="java">@ContextConfiguration
@@ -556,9 +544,9 @@ public class WebAppTests {
             <para>To override the default, specify a different base resource
             path via the <emphasis>implicit</emphasis>
             <interfacename>value</interfacename> attribute. Both
-            <literal>classpath:</literal> and <literal>file:</literal>
-            resource prefixes are supported. If no resource prefix is supplied
-            the path is assumed to be a file system resource.</para>
+            <literal>classpath:</literal> and <literal>file:</literal> resource
+            prefixes are supported. If no resource prefix is supplied the path
+            is assumed to be a file system resource.</para>
 
             <programlisting language="java">@ContextConfiguration
 <emphasis role="bold">@WebAppConfiguration("classpath:test-web-resources")</emphasis>
@@ -566,14 +554,56 @@ public class WebAppTests {
     <lineannotation>// class body...</lineannotation>
 }</programlisting>
 
-            <para>Note that
-            <interfacename>@WebAppConfiguration</interfacename> must be used
-            in conjunction with
-            <interfacename>@ContextConfiguration</interfacename>, either
-            within a single test class or within a test class hierarchy. See
-            the Javadoc for
-            <interfacename>@WebAppConfiguration</interfacename> for further
-            details.</para>
+            <para>Note that <interfacename>@WebAppConfiguration</interfacename>
+            must be used in conjunction with
+            <interfacename>@ContextConfiguration</interfacename>, either within
+            a single test class or within a test class hierarchy. See the
+            Javadoc for <interfacename>@WebAppConfiguration</interfacename> for
+            further details.</para>
+          </listitem>
+
+          <listitem>
+            <para><emphasis role="bold">
+            <interfacename>@ContextHierarchy</interfacename></emphasis></para>
+
+            <para>A class-level annotation that is used to define a hierarchy of
+            <interfacename>ApplicationContext</interfacename>s for integration
+            tests. <interfacename>@ContextHierarchy</interfacename> should be
+            declared with a list of one or more
+            <interfacename>@ContextConfiguration</interfacename> instances, each
+            of which defines a level in the context hierarchy. The following
+            examples demonstrate the use of
+            <interfacename>@ContextHierarchy</interfacename> within a single
+            test class; however,
+            <interfacename>@ContextHierarchy</interfacename> can also be used
+            within a test class hierarchy.</para>
+
+            <programlisting language="java">@ContextHierarchy({
+    @ContextConfiguration("/parent-config.xml"),
+    @ContextConfiguration("/child-config.xml")
+})
+public class ContextHierarchyTests {
+    <lineannotation>// class body...</lineannotation>
+}</programlisting>
+
+            <programlisting language="java">@WebAppConfiguration
+@ContextHierarchy({
+    @ContextConfiguration(classes = AppConfig.class),
+    @ContextConfiguration(classes = WebConfig.class)
+})
+public class WebIntegrationTests {
+    <lineannotation>// class body...</lineannotation>
+}</programlisting>
+
+            <para>If you need to merge or override the configuration for a given
+            level of the context hierarchy within a test class hierarchy, you
+            must explicitly name that level by supplying the same value to the
+            <varname>name</varname> attribute in
+            <interfacename>@ContextConfiguration</interfacename> at each
+            corresponding level in the class hierarchy. See <xref
+            linkend="testcontext-ctx-management-ctx-hierarchies"/> and the
+            Javadoc for <interfacename>@ContextHierarchy</interfacename> for
+            further examples.</para>
           </listitem>
 
           <listitem>
@@ -581,9 +611,9 @@ public class WebAppTests {
             <interfacename>@ActiveProfiles</interfacename> </emphasis></para>
 
             <para>A class-level annotation that is used to declare which
-            <emphasis>bean definition profiles</emphasis> should be active
-            when loading an <interfacename>ApplicationContext</interfacename>
-            for test classes.</para>
+            <emphasis>bean definition profiles</emphasis> should be active when
+            loading an <interfacename>ApplicationContext</interfacename> for
+            test classes.</para>
 
             <programlisting language="java">@ContextConfiguration
 <emphasis role="bold">@ActiveProfiles</emphasis>("dev")
@@ -599,15 +629,13 @@ public class DeveloperIntegrationTests {
 
             <note>
               <para><interfacename>@ActiveProfiles</interfacename> provides
-              support for <emphasis>inheriting</emphasis> active bean
-              definition profiles declared by superclasses by default.</para>
+              support for <emphasis>inheriting</emphasis> active bean definition
+              profiles declared by superclasses by default.</para>
             </note>
 
-            <para>See <link
-            linkend="testcontext-ctx-management-env-profiles">Context
-            configuration with environment profiles</link> and the Javadoc for
-            <interfacename>@ActiveProfiles</interfacename> for examples and
-            further details.</para>
+            <para>See <xref linkend="testcontext-ctx-management-env-profiles"/>
+            and the Javadoc for <interfacename>@ActiveProfiles</interfacename>
+            for examples and further details.</para>
           </listitem>
 
           <listitem>
@@ -616,67 +644,98 @@ public class DeveloperIntegrationTests {
 
             <para>Indicates that the underlying Spring
             <interfacename>ApplicationContext</interfacename> has been
-            <emphasis>dirtied</emphasis> (i.e., modified or corrupted in some
-            manner) during the execution of a test and should be closed,
-            regardless of whether the test passed.
-            <interfacename>@DirtiesContext</interfacename> is supported in the
-            following scenarios:</para>
+            <emphasis>dirtied</emphasis> during the execution of a test (i.e.,
+            modified or corrupted in some manner  for example, by changing the
+            state of a singleton bean) and should be closed, regardless of
+            whether the test passed. When an application context is marked
+            <emphasis>dirty</emphasis>, it is removed from the testing
+            framework's cache and closed. As a consequence, the underlying
+            Spring container will be rebuilt for any subsequent test that
+            requires a context with the same configuration metadata.</para>
+
+            <para><interfacename>@DirtiesContext</interfacename> can be used as
+            both a class-level and method-level annotation within the same test
+            class. In such scenarios, the
+            <interfacename>ApplicationContext</interfacename> is marked as
+            <emphasis>dirty</emphasis> after any such annotated method as well
+            as after the entire class. If the <classname>ClassMode</classname>
+            is set to <literal>AFTER_EACH_TEST_METHOD</literal>, the context is
+            marked dirty after each test method in the class.</para>
+
+            <para>The following examples explain when the context would be
+            dirtied for various configuration scenarios:</para>
 
             <itemizedlist>
               <listitem>
                 <para>After the current test class, when declared on a class
-                with class mode set to <literal>AFTER_CLASS</literal>, which
-                is the default class mode.</para>
+                with class mode set to <literal>AFTER_CLASS</literal> (i.e., the
+                default class mode).</para>
+
+                <programlisting language="java"><emphasis role="bold">@DirtiesContext</emphasis>
+public class ContextDirtyingTests {
+    <lineannotation>// some tests that result in the Spring container being dirtied</lineannotation>
+}</programlisting>
               </listitem>
 
               <listitem>
                 <para>After each test method in the current test class, when
                 declared on a class with class mode set to
-                <literal>AFTER_EACH_TEST_METHOD.</literal></para>
+                <literal>AFTER_EACH_TEST_METHOD.</literal><programlisting
+                language="java"><emphasis role="bold">@DirtiesContext</emphasis>(<emphasis
+                      role="bold">classMode</emphasis> = ClassMode.AFTER_EACH_TEST_METHOD)
+public class ContextDirtyingTests {
+    <lineannotation>// some tests that result in the Spring container being dirtied</lineannotation>
+}</programlisting></para>
               </listitem>
 
               <listitem>
-                <para>After the current test, when declared on a
-                method.</para>
+                <para>After the current test, when declared on a method.</para>
+
+                <programlisting language="java"><emphasis role="bold">@DirtiesContext</emphasis>
+@Test
+public void testProcessWhichDirtiesAppCtx() {
+    <lineannotation>// some logic that results in the Spring container being dirtied</lineannotation>
+}</programlisting>
               </listitem>
             </itemizedlist>
 
-            <para>Use this annotation if a test has modified the context (for
-            example, by replacing a bean definition). Subsequent tests are
-            supplied a new context.</para>
-
-            <para>With JUnit 4.5+ or TestNG you can use
-            <interfacename>@DirtiesContext</interfacename> as both a
-            class-level and method-level annotation within the same test
-            class. In such scenarios, the
-            <interfacename>ApplicationContext</interfacename> is marked as
-            <emphasis>dirty</emphasis> after any such annotated method as well
-            as after the entire class. If the <classname>ClassMode</classname>
-            is set to <literal>AFTER_EACH_TEST_METHOD</literal>, the context
-            is marked dirty after each test method in the class.</para>
+            <para>If <interfacename>@DirtiesContext</interfacename> is used in a
+            test whose context is configured as part of a context hierarchy via
+            <interfacename>@ContextHierarchy</interfacename>, the
+            <varname>hierarchyMode</varname> flag can be used to control how the
+            context cache is cleared. By default an
+            <emphasis>exhaustive</emphasis> algorithm will be used that clears
+            the context cache including not only the current level but also all
+            other context hierarchies that share an ancestor context common to
+            the current test; all
+            <interfacename>ApplicationContext</interfacename>s that reside in a
+            sub-hierarchy of the common ancestor context will be removed from
+            the context cache and closed. If the <emphasis>exhaustive</emphasis>
+            algorithm is overkill for a particular use case, the simpler
+            <emphasis>current level</emphasis> algorithm can be specified
+            instead, as seen below.</para>
+
+            <programlisting language="java">@ContextHierarchy({
+    @ContextConfiguration("/parent-config.xml"),
+    @ContextConfiguration("/child-config.xml")
+})
+public class BaseTests {
+    <lineannotation>// class body...</lineannotation>
+}
 
-            <programlisting language="java"><emphasis role="bold">@DirtiesContext</emphasis>
-public class ContextDirtyingTests {
-    <lineannotation>// some tests that result in the Spring container being dirtied</lineannotation>
-}</programlisting>
+public class ExtendedTests extends BaseTests {
 
-            <programlisting language="java"><emphasis role="bold">@DirtiesContext</emphasis>(<emphasis
-                role="bold">classMode</emphasis> = ClassMode.AFTER_EACH_TEST_METHOD)
-public class ContextDirtyingTests {
-    <lineannotation>// some tests that result in the Spring container being dirtied</lineannotation>
-}</programlisting>
-
-            <programlisting language="java"><emphasis role="bold">@DirtiesContext</emphasis>
-@Test
-public void testProcessWhichDirtiesAppCtx() {
-    <lineannotation>// some logic that results in the Spring container being dirtied</lineannotation>
+    @Test
+    @DirtiesContext(<emphasis role="bold">hierarchyMode = HierarchyMode.CURRENT_LEVEL</emphasis>)
+    public void test() {
+        <lineannotation>// some logic that results in the child context being dirtied</lineannotation>
+    }
 }</programlisting>
 
-            <para>When an application context is marked
-            <emphasis>dirty</emphasis>, it is removed from the testing
-            framework's cache and closed; thus the underlying Spring container
-            is rebuilt for any subsequent test that requires a context with
-            the same set of resource locations.</para>
+            <para>For further details regarding the
+            <constant>EXHAUSTIVE</constant> and
+            <constant>CURRENT_LEVEL</constant> algorithms see the Javadoc for
+            <interfacename>DirtiesContext.HierarchyMode</interfacename>.</para>
           </listitem>
 
           <listitem>
@@ -687,8 +746,8 @@ public void testProcessWhichDirtiesAppCtx() {
             <para>Defines class-level metadata for configuring which
             <interfacename>TestExecutionListener</interfacename>s should be
             registered with the <classname>TestContextManager</classname>.
-            Typically, <interfacename>@TestExecutionListeners</interfacename>
-            is used in conjunction with
+            Typically, <interfacename>@TestExecutionListeners</interfacename> is
+            used in conjunction with
             <interfacename>@ContextConfiguration</interfacename>.</para>
 
             <programlisting language="java">@ContextConfiguration
@@ -710,23 +769,21 @@ public class CustomTestExecutionListenerTests {
             <para>Defines class-level metadata for configuring transactional
             tests. Specifically, the bean name of the
             <interfacename>PlatformTransactionManager</interfacename> that
-            should be used to drive transactions can be explicitly specified
-            if there are multiple beans of type
+            should be used to drive transactions can be explicitly specified if
+            there are multiple beans of type
             <interfacename>PlatformTransactionManager</interfacename> in the
-            test's <interfacename>ApplicationContext</interfacename> and if
-            the bean name of the desired
+            test's <interfacename>ApplicationContext</interfacename> and if the
+            bean name of the desired
             <interfacename>PlatformTransactionManager</interfacename> is not
             "transactionManager". In addition, you can change the
-            <literal>defaultRollback</literal> flag to
-            <literal>false</literal>. Typically,
-            <interfacename>@TransactionConfiguration</interfacename> is used
-            in conjunction with
+            <literal>defaultRollback</literal> flag to <literal>false</literal>.
+            Typically, <interfacename>@TransactionConfiguration</interfacename>
+            is used in conjunction with
             <interfacename>@ContextConfiguration</interfacename>.</para>
 
             <programlisting language="java">@ContextConfiguration
-<emphasis role="bold">@TransactionConfiguration</emphasis>(<emphasis
-                role="bold">transactionManager</emphasis>="txMgr", <emphasis
-                role="bold">defaultRollback</emphasis>=false)
+<emphasis role="bold">@TransactionConfiguration</emphasis>(<emphasis role="bold">transactionManager</emphasis> = "txMgr", <emphasis
+                role="bold">defaultRollback</emphasis> = false)
 public class CustomConfiguredTransactionalTests {
     <lineannotation>// class body...</lineannotation>
 }</programlisting>
@@ -752,8 +809,8 @@ public class CustomConfiguredTransactionalTests {
 
             <para>Indicates whether the transaction for the annotated test
             method should be <emphasis>rolled back</emphasis> after the test
-            method has completed. If <literal>true</literal>, the transaction
-            is rolled back; otherwise, the transaction is committed. Use
+            method has completed. If <literal>true</literal>, the transaction is
+            rolled back; otherwise, the transaction is committed. Use
             <interfacename>@Rollback</interfacename> to override the default
             rollback flag configured at the class level.</para>
 
@@ -766,13 +823,12 @@ public void testProcessWithoutRollback() {
 
           <listitem>
             <para><emphasis role="bold">
-            <interfacename>@BeforeTransaction</interfacename>
-            </emphasis></para>
+            <interfacename>@BeforeTransaction</interfacename> </emphasis></para>
 
             <para>Indicates that the annotated <literal>public void</literal>
-            method should be executed <emphasis>before</emphasis> a
-            transaction is started for test methods configured to run within a
-            transaction via the <interfacename>@Transactional</interfacename>
+            method should be executed <emphasis>before</emphasis> a transaction
+            is started for test methods configured to run within a transaction
+            via the <interfacename>@Transactional</interfacename>
             annotation.</para>
 
             <programlisting language="java"><emphasis role="bold">@BeforeTransaction
@@ -783,8 +839,7 @@ public void testProcessWithoutRollback() {
 
           <listitem>
             <para><emphasis role="bold">
-            <interfacename>@AfterTransaction</interfacename>
-            </emphasis></para>
+            <interfacename>@AfterTransaction</interfacename> </emphasis></para>
 
             <para>Indicates that the annotated <literal>public void</literal>
             method should be executed <emphasis>after</emphasis> a transaction
@@ -800,12 +855,11 @@ public void testProcessWithoutRollback() {
 
           <listitem>
             <para><emphasis role="bold">
-            <interfacename>@NotTransactional</interfacename>
-            </emphasis></para>
+            <interfacename>@NotTransactional</interfacename> </emphasis></para>
 
             <para>The presence of this annotation indicates that the annotated
-            test method must <emphasis>not</emphasis> execute in a
-            transactional context.</para>
+            test method must <emphasis>not</emphasis> execute in a transactional
+            context.</para>
 
             <programlisting language="java"><emphasis role="bold">@NotTransactional</emphasis>
 @Test
@@ -817,14 +871,14 @@ public void testProcessWithoutTransaction() {
               <title>@NotTransactional is deprecated</title>
 
               <para>As of Spring 3.0,
-              <interfacename>@NotTransactional</interfacename> is deprecated
-              in favor of moving the <emphasis>non-transactional</emphasis>
-              test method to a separate (non-transactional) test class or to a
+              <interfacename>@NotTransactional</interfacename> is deprecated in
+              favor of moving the <emphasis>non-transactional</emphasis> test
+              method to a separate (non-transactional) test class or to a
               <interfacename>@BeforeTransaction</interfacename> or
               <interfacename>@AfterTransaction</interfacename> method. As an
               alternative to annotating an entire class with
-              <interfacename>@Transactional</interfacename>, consider
-              annotating individual methods with
+              <interfacename>@Transactional</interfacename>, consider annotating
+              individual methods with
               <interfacename>@Transactional</interfacename>; doing so allows a
               mix of transactional and non-transactional methods in the same
               test class without the need for using
@@ -839,8 +893,8 @@ public void testProcessWithoutTransaction() {
 
         <para>The following annotations are supported with standard semantics
         for all configurations of the Spring TestContext Framework. Note that
-        these annotations are not specific to tests and can be used anywhere
-        in the Spring Framework.</para>
+        these annotations are not specific to tests and can be used anywhere in
+        the Spring Framework.</para>
 
         <itemizedlist>
           <listitem>
@@ -856,14 +910,13 @@ public void testProcessWithoutTransaction() {
           <listitem>
             <para><emphasis role="bold">
             <interfacename>@Resource</interfacename> </emphasis>
-            (javax.annotation) <emphasis>if JSR-250 is
-            present</emphasis></para>
+            (javax.annotation) <emphasis>if JSR-250 is present</emphasis></para>
           </listitem>
 
           <listitem>
-            <para><emphasis role="bold">
-            <interfacename>@Inject</interfacename> </emphasis> (javax.inject)
-            <emphasis>if JSR-330 is present</emphasis></para>
+            <para><emphasis role="bold"> <interfacename>@Inject</interfacename>
+            </emphasis> (javax.inject) <emphasis>if JSR-330 is
+            present</emphasis></para>
           </listitem>
 
           <listitem>
@@ -910,13 +963,13 @@ public void testProcessWithoutTransaction() {
           <interfacename>@PostConstruct</interfacename>, that method will be
           executed before any <emphasis>before</emphasis> methods of the
           underlying test framework (e.g., methods annotated with JUnit's
-          <interfacename>@Before</interfacename>), and that will apply for
-          every test method in the test class. On the other hand, if a method
-          within a test class is annotated with
-          <interfacename>@PreDestroy</interfacename>, that method will
-          <emphasis role="bold">never</emphasis> be executed. Within a test
-          class it is therefore recommended to use test lifecycle callbacks
-          from the underlying test framework instead of
+          <interfacename>@Before</interfacename>), and that will apply for every
+          test method in the test class. On the other hand, if a method within a
+          test class is annotated with
+          <interfacename>@PreDestroy</interfacename>, that method will <emphasis
+          role="bold">never</emphasis> be executed. Within a test class it is
+          therefore recommended to use test lifecycle callbacks from the
+          underlying test framework instead of
           <interfacename>@PostConstruct</interfacename> and
           <interfacename>@PreDestroy</interfacename>.</para>
         </note>
@@ -925,8 +978,8 @@ public void testProcessWithoutTransaction() {
       <section xml:id="integration-testing-annotations-junit">
         <title>Spring JUnit Testing Annotations</title>
 
-        <para>The following annotations are <emphasis>only</emphasis>
-        supported when used in conjunction with the <link
+        <para>The following annotations are <emphasis>only</emphasis> supported
+        when used in conjunction with the <link
         linkend="testcontext-junit4-runner">SpringJUnit4ClassRunner</link> or
         the <link linkend="testcontext-support-classes-junit4">JUnit</link>
         support classes.</para>
@@ -945,8 +998,7 @@ public void testProcessWithoutTransaction() {
             method-level usage.</para>
 
             <programlisting language="java"><emphasis role="bold">@IfProfileValue</emphasis>(<emphasis
-                role="bold">name</emphasis>="java.vendor", <emphasis
-                role="bold">value</emphasis>="Sun Microsystems Inc.")
+                role="bold">name</emphasis>="java.vendor", <emphasis role="bold">value</emphasis>="Sun Microsystems Inc.")
 @Test
 public void testProcessWhichRunsOnlyOnSunJvm() {
     <lineannotation>// some logic that should run only on Java VMs from Sun Microsystems</lineannotation>
@@ -955,13 +1007,11 @@ public void testProcessWhichRunsOnlyOnSunJvm() {
             <para>Alternatively, you can configure
             <interfacename>@IfProfileValue</interfacename> with a list of
             <literal>values</literal> (with <emphasis>OR</emphasis> semantics)
-            to achieve TestNG-like support for <emphasis>test
-            groups</emphasis> in a JUnit environment. Consider the following
-            example:</para>
+            to achieve TestNG-like support for <emphasis>test groups</emphasis>
+            in a JUnit environment. Consider the following example:</para>
 
             <programlisting language="java"><emphasis role="bold">@IfProfileValue</emphasis>(<emphasis
-                role="bold">name</emphasis>="test-groups", <emphasis
-                role="bold">values</emphasis>={"unit-tests", "integration-tests"})
+                role="bold">name</emphasis>="test-groups", <emphasis role="bold">values</emphasis>={"unit-tests", "integration-tests"})
 @Test
 public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
     <lineannotation>// some logic that should run only for unit and integration test groups</lineannotation>
@@ -992,24 +1042,23 @@ public class CustomProfileValueSourceTests {
             <para><emphasis role="bold"> <interfacename>@Timed</interfacename>
             </emphasis></para>
 
-            <para>Indicates that the annotated test method must finish
-            execution in a specified time period (in milliseconds). If the
-            text execution time exceeds the specified time period, the test
-            fails.</para>
+            <para>Indicates that the annotated test method must finish execution
+            in a specified time period (in milliseconds). If the text execution
+            time exceeds the specified time period, the test fails.</para>
 
-            <para>The time period includes execution of the test method
-            itself, any repetitions of the test (see
+            <para>The time period includes execution of the test method itself,
+            any repetitions of the test (see
             <interfacename>@Repeat</interfacename>), as well as any
-            <emphasis>set up</emphasis> or <emphasis>tear down</emphasis> of
-            the test fixture.</para>
+            <emphasis>set up</emphasis> or <emphasis>tear down</emphasis> of the
+            test fixture.</para>
 
             <programlisting language="java"><emphasis role="bold">@Timed</emphasis>(millis=1000)
 public void testProcessWithOneSecondTimeout() {
     <lineannotation>// some logic that should not take longer than 1 second to execute</lineannotation>
 }</programlisting>
 
-            <para>Spring's <interfacename>@Timed</interfacename> annotation
-            has different semantics than JUnit's
+            <para>Spring's <interfacename>@Timed</interfacename> annotation has
+            different semantics than JUnit's
             <interfacename>@Test(timeout=...)</interfacename> support.
             Specifically, due to the manner in which JUnit handles test
             execution timeouts (that is, by executing the test method in a
@@ -1017,23 +1066,23 @@ public void testProcessWithOneSecondTimeout() {
             <interfacename>@Test(timeout=...)</interfacename> applies to
             <emphasis>each iteration</emphasis> in the case of repetitions and
             preemptively fails the test if the test takes too long. Spring's
-            <interfacename>@Timed</interfacename>, on the other hand, times
-            the <emphasis>total</emphasis> test execution time (including all
+            <interfacename>@Timed</interfacename>, on the other hand, times the
+            <emphasis>total</emphasis> test execution time (including all
             repetitions) and does not preemptively fail the test but rather
             waits for the test to complete before failing.</para>
           </listitem>
 
           <listitem>
-            <para><emphasis role="bold">
-            <interfacename>@Repeat</interfacename> </emphasis></para>
+            <para><emphasis role="bold"> <interfacename>@Repeat</interfacename>
+            </emphasis></para>
 
             <para>Indicates that the annotated test method must be executed
             repeatedly. The number of times that the test method is to be
             executed is specified in the annotation.</para>
 
             <para>The scope of execution to be repeated includes execution of
-            the test method itself as well as any <emphasis>set up</emphasis>
-            or <emphasis>tear down</emphasis> of the test fixture.</para>
+            the test method itself as well as any <emphasis>set up</emphasis> or
+            <emphasis>tear down</emphasis> of the test fixture.</para>
 
             <programlisting language="java"><emphasis role="bold">@Repeat</emphasis>(10)
 @Test
@@ -1060,20 +1109,18 @@ public void testProcessRepeatedly() {
       <para>In addition to generic testing infrastructure, the TestContext
       framework provides explicit support for JUnit and TestNG in the form of
       <literal>abstract</literal> support classes. For JUnit, Spring also
-      provides a custom JUnit <interfacename>Runner</interfacename> that
-      allows one to write so-called <emphasis>POJO test classes</emphasis>.
-      POJO test classes are not required to extend a particular class
-      hierarchy.</para>
+      provides a custom JUnit <interfacename>Runner</interfacename> that allows
+      one to write so-called <emphasis>POJO test classes</emphasis>. POJO test
+      classes are not required to extend a particular class hierarchy.</para>
 
       <para>The following section provides an overview of the internals of the
       TestContext framework. If you are only interested in using the framework
       and not necessarily interested in extending it with your own custom
-      listeners or custom loaders, feel free to go directly to the
-      configuration (<link linkend="testcontext-ctx-management">context
-      management</link>, <link linkend="testcontext-fixture-di">dependency
-      injection</link>, <link linkend="testcontext-tx">transaction
-      management</link>), <link linkend="testcontext-support-classes">support
-      classes</link>, and <link
+      listeners or custom loaders, feel free to go directly to the configuration
+      (<link linkend="testcontext-ctx-management">context management</link>,
+      <link linkend="testcontext-fixture-di">dependency injection</link>, <link
+      linkend="testcontext-tx">transaction management</link>), <link
+      linkend="testcontext-support-classes">support classes</link>, and <link
       linkend="integration-testing-annotations">annotation support</link>
       sections.</para>
 
@@ -1086,21 +1133,20 @@ public void testProcessRepeatedly() {
         <interfacename>TestExecutionListener</interfacename>,
         <interfacename>ContextLoader</interfacename>, and
         <interfacename>SmartContextLoader</interfacename> interfaces. A
-        <classname>TestContextManager</classname> is created on a per-test
-        basis (e.g., for the execution of a single test method in JUnit). The
+        <classname>TestContextManager</classname> is created on a per-test basis
+        (e.g., for the execution of a single test method in JUnit). The
         <classname>TestContextManager</classname> in turn manages a
-        <classname>TestContext</classname> that holds the context of the
-        current test. The <classname>TestContextManager</classname> also
-        updates the state of the <classname>TestContext</classname> as the
-        test progresses and delegates to
-        <interfacename>TestExecutionListener</interfacename>s, which
-        instrument the actual test execution by providing dependency
+        <classname>TestContext</classname> that holds the context of the current
+        test. The <classname>TestContextManager</classname> also updates the
+        state of the <classname>TestContext</classname> as the test progresses
+        and delegates to <interfacename>TestExecutionListener</interfacename>s,
+        which instrument the actual test execution by providing dependency
         injection, managing transactions, and so on. A
         <interfacename>ContextLoader</interfacename> (or
         <interfacename>SmartContextLoader</interfacename>) is responsible for
-        loading an <interfacename>ApplicationContext</interfacename> for a
-        given test class. Consult the Javadoc and the Spring test suite for
-        further information and examples of various implementations.</para>
+        loading an <interfacename>ApplicationContext</interfacename> for a given
+        test class. Consult the Javadoc and the Spring test suite for further
+        information and examples of various implementations.</para>
 
         <itemizedlist>
           <listitem>
@@ -1125,8 +1171,8 @@ public void testProcessRepeatedly() {
 
             <itemizedlist>
               <listitem>
-                <para>prior to any <emphasis>before class methods</emphasis>
-                of a particular testing framework</para>
+                <para>prior to any <emphasis>before class methods</emphasis> of
+                a particular testing framework</para>
               </listitem>
 
               <listitem>
@@ -1151,15 +1197,14 @@ public void testProcessRepeatedly() {
           </listitem>
 
           <listitem>
-            <para><interfacename>TestExecutionListener</interfacename>:
-            Defines a <emphasis>listener</emphasis> API for reacting to test
-            execution events published by the
-            <classname>TestContextManager</classname> with which the listener
-            is registered.</para>
+            <para><interfacename>TestExecutionListener</interfacename>: Defines
+            a <emphasis>listener</emphasis> API for reacting to test execution
+            events published by the <classname>TestContextManager</classname>
+            with which the listener is registered.</para>
 
             <para>Spring provides four
-            <interfacename>TestExecutionListener</interfacename>
-            implementations that are configured by default:
+            <interfacename>TestExecutionListener</interfacename> implementations
+            that are configured by default:
             <classname>ServletTestExecutionListener</classname>,
             <classname>DependencyInjectionTestExecutionListener</classname>,
             <classname>DirtiesContextTestExecutionListener</classname>, and
@@ -1168,16 +1213,14 @@ public void testProcessRepeatedly() {
             <interfacename>WebApplicationContext</interfacename>, dependency
             injection of the test instance, handling of the
             <interfacename>@DirtiesContext</interfacename> annotation, and
-            transactional test execution with default rollback
-            semantics.</para>
+            transactional test execution with default rollback semantics.</para>
           </listitem>
 
           <listitem>
             <para><interfacename>ContextLoader</interfacename>: Strategy
             interface introduced in Spring 2.5 for loading an
-            <interfacename>ApplicationContext</interfacename> for an
-            integration test managed by the Spring TestContext
-            Framework.</para>
+            <interfacename>ApplicationContext</interfacename> for an integration
+            test managed by the Spring TestContext Framework.</para>
 
             <para>As of Spring 3.1, implement
             <interfacename>SmartContextLoader</interfacename> instead of this
@@ -1191,8 +1234,8 @@ public void testProcessRepeatedly() {
             introduced in Spring 3.1.</para>
 
             <para>The <interfacename>SmartContextLoader</interfacename> SPI
-            supersedes the <interfacename>ContextLoader</interfacename> SPI
-            that was introduced in Spring 2.5. Specifically, a
+            supersedes the <interfacename>ContextLoader</interfacename> SPI that
+            was introduced in Spring 2.5. Specifically, a
             <interfacename>SmartContextLoader</interfacename> can choose to
             process resource <varname>locations</varname>, annotated
             <varname>classes</varname>, or context
@@ -1207,9 +1250,9 @@ public void testProcessRepeatedly() {
                 <para><classname>DelegatingSmartContextLoader</classname>: one
                 of two default loaders which delegates internally to an
                 <classname>AnnotationConfigContextLoader</classname> or a
-                <classname>GenericXmlContextLoader</classname> depending
-                either on the configuration declared for the test class or on
-                the presence of default locations or default configuration
+                <classname>GenericXmlContextLoader</classname> depending either
+                on the configuration declared for the test class or on the
+                presence of default locations or default configuration
                 classes.</para>
               </listitem>
 
@@ -1220,8 +1263,8 @@ public void testProcessRepeatedly() {
                 <classname>GenericXmlWebContextLoader</classname> depending
                 either on the configuration declared for the test class or on
                 the presence of default locations or default configuration
-                classes. A web <interfacename>ContextLoader</interfacename>
-                will only be used if
+                classes. A web <interfacename>ContextLoader</interfacename> will
+                only be used if
                 <interfacename>@WebAppConfiguration</interfacename> is present
                 on the test class.</para>
               </listitem>
@@ -1241,14 +1284,14 @@ public void testProcessRepeatedly() {
 
               <listitem>
                 <para><classname>GenericXmlContextLoader</classname>: loads a
-                standard <interfacename>ApplicationContext</interfacename>
-                from XML <emphasis>resource locations</emphasis>.</para>
+                standard <interfacename>ApplicationContext</interfacename> from
+                XML <emphasis>resource locations</emphasis>.</para>
               </listitem>
 
               <listitem>
-                <para><classname>GenericXmlWebContextLoader</classname>: loads
-                a <interfacename>WebApplicationContext</interfacename> from
-                XML <emphasis>resource locations</emphasis>.</para>
+                <para><classname>GenericXmlWebContextLoader</classname>: loads a
+                <interfacename>WebApplicationContext</interfacename> from XML
+                <emphasis>resource locations</emphasis>.</para>
               </listitem>
 
               <listitem>
@@ -1263,8 +1306,8 @@ public void testProcessRepeatedly() {
 
         <para>The following sections explain how to configure the
         <classname>TestContext</classname> framework through annotations and
-        provide working examples of how to write unit and integration tests
-        with the framework.</para>
+        provide working examples of how to write unit and integration tests with
+        the framework.</para>
       </section>
 
       <section xml:id="testcontext-ctx-management">
@@ -1288,10 +1331,10 @@ public void testProcessRepeatedly() {
           <title>@Autowired ApplicationContext</title>
 
           <para>As an alternative to implementing the
-          <interfacename>ApplicationContextAware</interfacename> interface,
-          you can inject the application context for your test class through
-          the <interfacename>@Autowired</interfacename> annotation on either a
-          field or setter method. For example:</para>
+          <interfacename>ApplicationContextAware</interfacename> interface, you
+          can inject the application context for your test class through the
+          <interfacename>@Autowired</interfacename> annotation on either a field
+          or setter method. For example:</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 @ContextConfiguration
@@ -1320,29 +1363,29 @@ public class MyWebAppTest {
 
           <para>Dependency injection via
           <interfacename>@Autowired</interfacename> is provided by the
-          <classname>DependencyInjectionTestExecutionListener</classname>
-          which is configured by default (see <xref
-          linkend="testcontext-fixture-di" />).</para>
+          <classname>DependencyInjectionTestExecutionListener</classname> which
+          is configured by default (see <xref
+          linkend="testcontext-fixture-di"/>).</para>
         </tip>
 
         <para>Test classes that use the TestContext framework do not need to
         extend any particular class or implement a specific interface to
-        configure their application context. Instead, configuration is
-        achieved simply by declaring the
+        configure their application context. Instead, configuration is achieved
+        simply by declaring the
         <interfacename>@ContextConfiguration</interfacename> annotation at the
-        class level. If your test class does not explicitly declare
-        application context resource <literal>locations</literal> or annotated
+        class level. If your test class does not explicitly declare application
+        context resource <literal>locations</literal> or annotated
         <varname>classes</varname>, the configured
         <interfacename>ContextLoader</interfacename> determines how to load a
         context from a default location or default configuration classes. In
-        addition to context resource <varname>locations</varname> and
-        annotated <varname>classes</varname>, an application context can also
-        be configured via application context
+        addition to context resource <varname>locations</varname> and annotated
+        <varname>classes</varname>, an application context can also be
+        configured via application context
         <varname>initializers</varname>.</para>
 
         <para>The following sections explain how to configure an
-        <interfacename>ApplicationContext</interfacename> via XML
-        configuration files, annotated classes (typically
+        <interfacename>ApplicationContext</interfacename> via XML configuration
+        files, annotated classes (typically
         <interfacename>@Configuration</interfacename> classes), or context
         initializers using Spring's
         <interfacename>@ContextConfiguration</interfacename> annotation.
@@ -1353,18 +1396,17 @@ public class MyWebAppTest {
         <section xml:id="testcontext-ctx-management-xml">
           <title>Context configuration with XML resources</title>
 
-          <para>To load an <interfacename>ApplicationContext</interfacename>
-          for your tests using XML configuration files, annotate your test
-          class with <interfacename>@ContextConfiguration</interfacename> and
+          <para>To load an <interfacename>ApplicationContext</interfacename> for
+          your tests using XML configuration files, annotate your test class
+          with <interfacename>@ContextConfiguration</interfacename> and
           configure the <literal>locations</literal> attribute with an array
-          that contains the resource locations of XML configuration metadata.
-          A plain or relative path  for example
-          <literal>"context.xml"</literal>  will be treated as a classpath
-          resource that is relative to the package in which the test class is
-          defined. A path starting with a slash is treated as an absolute
-          classpath location, for example
-          <literal>"/org/example/config.xml"</literal>. A path which
-          represents a resource URL (i.e., a path prefixed with
+          that contains the resource locations of XML configuration metadata. A
+          plain or relative path  for example <literal>"context.xml"</literal>
+           will be treated as a classpath resource that is relative to the
+          package in which the test class is defined. A path starting with a
+          slash is treated as an absolute classpath location, for example
+          <literal>"/org/example/config.xml"</literal>. A path which represents
+          a resource URL (i.e., a path prefixed with
           <literal>classpath:</literal>, <literal>file:</literal>,
           <literal>http:</literal>, etc.) will be used <emphasis>as
           is</emphasis>.</para>
@@ -1377,13 +1419,13 @@ public class MyTest {
     <lineannotation>// class body...</lineannotation>
 }</programlisting>
 
-          <para><interfacename>@ContextConfiguration</interfacename> supports
-          an alias for the <literal>locations</literal> attribute through the
-          standard Java <literal>value</literal> attribute. Thus, if you do
-          not need to declare additional attributes in
-          <interfacename>@ContextConfiguration</interfacename>, you can omit
-          the declaration of the <literal>locations</literal> attribute name
-          and declare the resource locations by using the shorthand format
+          <para><interfacename>@ContextConfiguration</interfacename> supports an
+          alias for the <literal>locations</literal> attribute through the
+          standard Java <literal>value</literal> attribute. Thus, if you do not
+          need to declare additional attributes in
+          <interfacename>@ContextConfiguration</interfacename>, you can omit the
+          declaration of the <literal>locations</literal> attribute name and
+          declare the resource locations by using the shorthand format
           demonstrated in the following example.</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
@@ -1396,12 +1438,11 @@ public class MyTest {
           <varname>value</varname> attributes from the
           <interfacename>@ContextConfiguration</interfacename> annotation, the
           TestContext framework will attempt to detect a default XML resource
-          location. Specifically,
-          <classname>GenericXmlContextLoader</classname> detects a default
-          location based on the name of the test class. If your class is named
-          <literal>com.example.MyTest</literal>,
-          <classname>GenericXmlContextLoader</classname> loads your
-          application context from
+          location. Specifically, <classname>GenericXmlContextLoader</classname>
+          detects a default location based on the name of the test class. If
+          your class is named <literal>com.example.MyTest</literal>,
+          <classname>GenericXmlContextLoader</classname> loads your application
+          context from
           <literal>"classpath:/com/example/MyTest-context.xml"</literal>.</para>
 
           <programlisting language="java">package com.example;
@@ -1418,11 +1459,11 @@ public class MyTest {
         <section xml:id="testcontext-ctx-management-javaconfig">
           <title>Context configuration with annotated classes</title>
 
-          <para>To load an <interfacename>ApplicationContext</interfacename>
-          for your tests using <emphasis>annotated classes</emphasis> (see
-          <xref linkend="beans-java" />), annotate your test class with
-          <interfacename>@ContextConfiguration</interfacename> and configure
-          the <literal>classes</literal> attribute with an array that contains
+          <para>To load an <interfacename>ApplicationContext</interfacename> for
+          your tests using <emphasis>annotated classes</emphasis> (see <xref
+          linkend="beans-java"/>), annotate your test class with
+          <interfacename>@ContextConfiguration</interfacename> and configure the
+          <literal>classes</literal> attribute with an array that contains
           references to annotated classes.</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
@@ -1437,16 +1478,16 @@ public class MyTest {
           TestContext framework will attempt to detect the presence of default
           configuration classes. Specifically,
           <classname>AnnotationConfigContextLoader</classname> will detect all
-          static inner classes of the test class that meet the requirements
-          for configuration class implementations as specified in the Javadoc
-          for <interfacename>@Configuration</interfacename>. In the following
-          example, the <classname>OrderServiceTest</classname> class declares
-          a static inner configuration class named
-          <classname>Config</classname> that will be automatically used to
-          load the <interfacename>ApplicationContext</interfacename> for the
-          test class. Note that the name of the configuration class is
-          arbitrary. In addition, a test class can contain more than one
-          static inner configuration class if desired.</para>
+          static inner classes of the test class that meet the requirements for
+          configuration class implementations as specified in the Javadoc for
+          <interfacename>@Configuration</interfacename>. In the following
+          example, the <classname>OrderServiceTest</classname> class declares a
+          static inner configuration class named <classname>Config</classname>
+          that will be automatically used to load the
+          <interfacename>ApplicationContext</interfacename> for the test class.
+          Note that the name of the configuration class is arbitrary. In
+          addition, a test class can contain more than one static inner
+          configuration class if desired.</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 <lineannotation>// ApplicationContext will be loaded from the
@@ -1480,19 +1521,18 @@ public class OrderServiceTest {
         <section xml:id="testcontext-ctx-management-mixed-config">
           <title>Mixing XML resources and annotated classes</title>
 
-          <para>It may sometimes be desirable to mix XML resources and
-          annotated classes (i.e., typically
-          <interfacename>@Configuration</interfacename> classes) to configure
-          an <interfacename>ApplicationContext</interfacename> for your tests.
-          For example, if you use XML configuration in production, you may
-          decide that you want to use
-          <interfacename>@Configuration</interfacename> classes to configure
-          specific Spring-managed components for your tests, or vice versa. As
-          mentioned in <xref
-          linkend="integration-testing-annotations-spring" /> the TestContext
-          framework does not allow you to declare <emphasis>both</emphasis>
-          via <interfacename>@ContextConfiguration</interfacename>, but this
-          does not mean that you cannot use both.</para>
+          <para>It may sometimes be desirable to mix XML resources and annotated
+          classes (i.e., typically <interfacename>@Configuration</interfacename>
+          classes) to configure an
+          <interfacename>ApplicationContext</interfacename> for your tests. For
+          example, if you use XML configuration in production, you may decide
+          that you want to use <interfacename>@Configuration</interfacename>
+          classes to configure specific Spring-managed components for your
+          tests, or vice versa. As mentioned in <xref
+          linkend="integration-testing-annotations-spring"/> the TestContext
+          framework does not allow you to declare <emphasis>both</emphasis> via
+          <interfacename>@ContextConfiguration</interfacename>, but this does
+          not mean that you cannot use both.</para>
 
           <para>If you want to use XML <emphasis role="bold">and</emphasis>
           <interfacename>@Configuration</interfacename> classes to configure
@@ -1505,27 +1545,27 @@ public class OrderServiceTest {
           <interfacename>@ImportResource</interfacename> to import XML
           configuration files. Note that this behavior is semantically
           equivalent to how you configure your application in production: in
-          production configuration you will define either a set of XML
-          resource locations or a set of
-          <interfacename>@Configuration</interfacename> classes that your
-          production <interfacename>ApplicationContext</interfacename> will be
-          loaded from, but you still have the freedom to include or import the
-          other type of configuration.</para>
+          production configuration you will define either a set of XML resource
+          locations or a set of <interfacename>@Configuration</interfacename>
+          classes that your production
+          <interfacename>ApplicationContext</interfacename> will be loaded from,
+          but you still have the freedom to include or import the other type of
+          configuration.</para>
         </section>
 
         <section xml:id="testcontext-ctx-management-initializers">
           <title>Context configuration with context initializers</title>
 
           <para>To configure an
-          <interfacename>ApplicationContext</interfacename> for your tests
-          using context initializers, annotate your test class with
-          <interfacename>@ContextConfiguration</interfacename> and configure
-          the <literal>initializers</literal> attribute with an array that
-          contains references to classes that implement
+          <interfacename>ApplicationContext</interfacename> for your tests using
+          context initializers, annotate your test class with
+          <interfacename>@ContextConfiguration</interfacename> and configure the
+          <literal>initializers</literal> attribute with an array that contains
+          references to classes that implement
           <interfacename>ApplicationContextInitializer</interfacename>. The
           declared context initializers will then be used to initialize the
-          <interfacename>ConfigurableApplicationContext</interfacename> that
-          is loaded for your tests. Note that the concrete
+          <interfacename>ConfigurableApplicationContext</interfacename> that is
+          loaded for your tests. Note that the concrete
           <interfacename>ConfigurableApplicationContext</interfacename> type
           supported by each declared initializer must be compatible with the
           type of <interfacename>ApplicationContext</interfacename> created by
@@ -1533,9 +1573,8 @@ public class OrderServiceTest {
           typically a <classname>GenericApplicationContext</classname>).
           Furthermore, the order in which the initializers are invoked depends
           on whether they implement Spring's
-          <interfacename>Ordered</interfacename> interface or are annotated
-          with Spring's <interfacename>@Order</interfacename>
-          annotation.</para>
+          <interfacename>Ordered</interfacename> interface or are annotated with
+          Spring's <interfacename>@Order</interfacename> annotation.</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 <lineannotation>// ApplicationContext will be loaded from TestConfig
@@ -1547,14 +1586,14 @@ public class MyTest {
     <lineannotation>// class body...</lineannotation>
 }</programlisting>
 
-          <para>It is also possible to omit the declaration of XML
-          configuration files or annotated classes in
+          <para>It is also possible to omit the declaration of XML configuration
+          files or annotated classes in
           <interfacename>@ContextConfiguration</interfacename> entirely and
           instead declare only
           <interfacename>ApplicationContextInitializer</interfacename> classes
-          which are then responsible for registering beans in the context 
-          for example, by programmatically loading bean definitions from XML
-          files or configuration classes.</para>
+          which are then responsible for registering beans in the context  for
+          example, by programmatically loading bean definitions from XML files
+          or configuration classes.</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 <lineannotation>// ApplicationContext will be initialized by EntireAppInitializer
@@ -1570,36 +1609,35 @@ public class MyTest {
 
           <para><interfacename>@ContextConfiguration</interfacename> supports
           boolean <varname>inheritLocations</varname> and
-          <varname>inheritInitializers</varname> attributes that denote
-          whether resource locations or annotated classes and context
-          initializers declared by superclasses should be
-          <emphasis>inherited</emphasis>. The default value for both flags is
-          <literal>true</literal>. This means that a test class inherits the
-          resource locations or annotated classes as well as the context
-          initializers declared by any superclasses. Specifically, the
-          resource locations or annotated classes for a test class are
-          appended to the list of resource locations or annotated classes
-          declared by superclasses. Similarly, the initializers for a given
-          test class will be added to the set of initializers defined by test
-          superclasses. Thus, subclasses have the option of
+          <varname>inheritInitializers</varname> attributes that denote whether
+          resource locations or annotated classes and context initializers
+          declared by superclasses should be <emphasis>inherited</emphasis>. The
+          default value for both flags is <literal>true</literal>. This means
+          that a test class inherits the resource locations or annotated classes
+          as well as the context initializers declared by any superclasses.
+          Specifically, the resource locations or annotated classes for a test
+          class are appended to the list of resource locations or annotated
+          classes declared by superclasses. Similarly, the initializers for a
+          given test class will be added to the set of initializers defined by
+          test superclasses. Thus, subclasses have the option of
           <emphasis>extending</emphasis> the resource locations, annotated
           classes, or context initializers.</para>
 
           <para>If <interfacename>@ContextConfiguration</interfacename>'s
           <literal>inheritLocations</literal> or
           <varname>inheritInitializers</varname> attribute is set to
-          <literal>false</literal>, the resource locations or annotated
-          classes and the context initializers, respectively, for the test
-          class <emphasis>shadow</emphasis> and effectively replace the
-          configuration defined by superclasses.</para>
+          <literal>false</literal>, the resource locations or annotated classes
+          and the context initializers, respectively, for the test class
+          <emphasis>shadow</emphasis> and effectively replace the configuration
+          defined by superclasses.</para>
 
           <para>In the following example that uses XML resource locations, the
           <interfacename>ApplicationContext</interfacename> for
           <classname>ExtendedTest</classname> will be loaded from
           <emphasis>"base-config.xml"</emphasis> <emphasis
-          role="bold">and</emphasis>
-          <emphasis>"extended-config.xml"</emphasis>, in that order. Beans
-          defined in <emphasis>"extended-config.xml"</emphasis> may therefore
+          role="bold">and</emphasis> <emphasis>"extended-config.xml"</emphasis>,
+          in that order. Beans defined in
+          <emphasis>"extended-config.xml"</emphasis> may therefore
           <emphasis>override</emphasis> (i.e., replace) those defined in
           <emphasis>"base-config.xml"</emphasis>.</para>
 
@@ -1618,14 +1656,14 @@ public class ExtendedTest extends BaseTest {
     <lineannotation>// class body...</lineannotation>
 }</programlisting>
 
-          <para>Similarly, in the following example that uses annotated
-          classes, the <interfacename>ApplicationContext</interfacename> for
+          <para>Similarly, in the following example that uses annotated classes,
+          the <interfacename>ApplicationContext</interfacename> for
           <classname>ExtendedTest</classname> will be loaded from the
-          <classname>BaseConfig</classname> <emphasis
-          role="bold">and</emphasis> <classname>ExtendedConfig</classname>
-          classes, in that order. Beans defined in
-          <classname>ExtendedConfig</classname> may therefore override (i.e.,
-          replace) those defined in <classname>BaseConfig</classname>.</para>
+          <classname>BaseConfig</classname> <emphasis role="bold">and</emphasis>
+          <classname>ExtendedConfig</classname> classes, in that order. Beans
+          defined in <classname>ExtendedConfig</classname> may therefore
+          override (i.e., replace) those defined in
+          <classname>BaseConfig</classname>.</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 <lineannotation>// ApplicationContext will be loaded from BaseConfig</lineannotation>
@@ -1644,12 +1682,11 @@ public class ExtendedTest extends BaseTest {
           <interfacename>ApplicationContext</interfacename> for
           <classname>ExtendedTest</classname> will be initialized using
           <classname>BaseInitializer</classname> <emphasis
-          role="bold">and</emphasis>
-          <classname>ExtendedInitializer</classname>. Note, however, that the
-          order in which the initializers are invoked depends on whether they
-          implement Spring's <interfacename>Ordered</interfacename> interface
-          or are annotated with Spring's <interfacename>@Order</interfacename>
-          annotation.</para>
+          role="bold">and</emphasis> <classname>ExtendedInitializer</classname>.
+          Note, however, that the order in which the initializers are invoked
+          depends on whether they implement Spring's
+          <interfacename>Ordered</interfacename> interface or are annotated with
+          Spring's <interfacename>@Order</interfacename> annotation.</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 <lineannotation>// ApplicationContext will be initialized by BaseInitializer</lineannotation>
@@ -1672,19 +1709,18 @@ public class ExtendedTest extends BaseTest {
           <para>Spring 3.1 introduced first-class support in the framework for
           the notion of environments and profiles (a.k.a., <emphasis>bean
           definition profiles</emphasis>), and integration tests can be
-          configured to activate particular bean definition profiles for
-          various testing scenarios. This is achieved by annotating a test
-          class with the <interfacename>@ActiveProfiles</interfacename>
-          annotation and supplying a list of profiles that should be activated
-          when loading the <interfacename>ApplicationContext</interfacename>
-          for the test.</para>
+          configured to activate particular bean definition profiles for various
+          testing scenarios. This is achieved by annotating a test class with
+          the <interfacename>@ActiveProfiles</interfacename> annotation and
+          supplying a list of profiles that should be activated when loading the
+          <interfacename>ApplicationContext</interfacename> for the test.</para>
 
           <note>
             <para><interfacename>@ActiveProfiles</interfacename> may be used
             with any implementation of the new
             <interfacename>SmartContextLoader</interfacename> SPI, but
-            <interfacename>@ActiveProfiles</interfacename> is not supported
-            with implementations of the older
+            <interfacename>@ActiveProfiles</interfacename> is not supported with
+            implementations of the older
             <interfacename>ContextLoader</interfacename> SPI.</para>
           </note>
 
@@ -1746,25 +1782,23 @@ public class TransferServiceTest {
 }</programlisting>
 
           <para>When <classname>TransferServiceTest</classname> is run, its
-          <interfacename>ApplicationContext</interfacename> will be loaded
-          from the <filename>app-config.xml</filename> configuration file in
-          the root of the classpath. If you inspect
-          <filename>app-config.xml</filename> you'll notice that the
-          <varname>accountRepository</varname> bean has a dependency on a
-          <varname>dataSource</varname> bean; however,
+          <interfacename>ApplicationContext</interfacename> will be loaded from
+          the <filename>app-config.xml</filename> configuration file in the root
+          of the classpath. If you inspect <filename>app-config.xml</filename>
+          you'll notice that the <varname>accountRepository</varname> bean has a
+          dependency on a <varname>dataSource</varname> bean; however,
           <varname>dataSource</varname> is not defined as a top-level bean.
           Instead, <varname>dataSource</varname> is defined twice: once in the
           <emphasis>production</emphasis> profile and once in the
           <emphasis>dev</emphasis> profile.</para>
 
           <para>By annotating <classname>TransferServiceTest</classname> with
-          <interfacename>@ActiveProfiles("dev")</interfacename> we instruct
-          the Spring TestContext Framework to load the
+          <interfacename>@ActiveProfiles("dev")</interfacename> we instruct the
+          Spring TestContext Framework to load the
           <interfacename>ApplicationContext</interfacename> with the active
           profiles set to <literal>{"dev"}</literal>. As a result, an embedded
-          database will be created, and the
-          <varname>accountRepository</varname> bean will be wired with a
-          reference to the development
+          database will be created, and the <varname>accountRepository</varname>
+          bean will be wired with a reference to the development
           <interfacename>DataSource</interfacename>. And that's likely what we
           want in an integration test.</para>
 
@@ -1887,23 +1921,21 @@ public class TransferServiceTest {
           <interfacename>@WebAppConfiguration</interfacename>.</para>
 
           <para>The presence of
-          <interfacename>@WebAppConfiguration</interfacename> on your test
-          class instructs the TestContext framework (TCF) that a
+          <interfacename>@WebAppConfiguration</interfacename> on your test class
+          instructs the TestContext framework (TCF) that a
           <interfacename>WebApplicationContext</interfacename> (WAC) should be
           loaded for your integration tests. In the background the TCF makes
           sure that a <interfacename>MockServletContext</interfacename> is
-          created and supplied to your test's WAC. By default the base
-          resource path for your
-          <interfacename>MockServletContext</interfacename> will be set to
-          <emphasis>"src/main/webapp"</emphasis>. This is interpreted as a
-          path relative to the root of your JVM (i.e., normally the path to
+          created and supplied to your test's WAC. By default the base resource
+          path for your <interfacename>MockServletContext</interfacename> will
+          be set to <emphasis>"src/main/webapp"</emphasis>. This is interpreted
+          as a path relative to the root of your JVM (i.e., normally the path to
           your project). If you're familiar with the directory structure of a
           web application in a Maven project, you'll know that
-          <emphasis>"src/main/webapp"</emphasis> is the default location for
-          the root of your WAR. If you need to override this default, simply
-          provide an alternate path to the
-          <interfacename>@WebAppConfiguration</interfacename> annotation
-          (e.g.,
+          <emphasis>"src/main/webapp"</emphasis> is the default location for the
+          root of your WAR. If you need to override this default, simply provide
+          an alternate path to the
+          <interfacename>@WebAppConfiguration</interfacename> annotation (e.g.,
           <interfacename>@WebAppConfiguration("src/test/webapp")</interfacename>).
           If you wish to reference a base resource path from the classpath
           instead of the file system, just use Spring's
@@ -1912,9 +1944,9 @@ public class TransferServiceTest {
           <para>Please note that Spring's testing support for
           <interfacename>WebApplicationContexts</interfacename> is on par with
           its support for standard
-          <interfacename>ApplicationContexts</interfacename>. When testing
-          with a <interfacename>WebApplicationContext</interfacename> you are
-          free to declare either XML configuration files or
+          <interfacename>ApplicationContexts</interfacename>. When testing with
+          a <interfacename>WebApplicationContext</interfacename> you are free to
+          declare either XML configuration files or
           <interfacename>@Configuration</interfacename> classes via
           <interfacename>@ContextConfiguration</interfacename>. You are of
           course also free to use any other test annotations such as
@@ -1944,23 +1976,22 @@ public class WacTests {
           </example>
 
           <para>The above example demonstrates the TestContext framework's
-          support for <emphasis>convention over configuration</emphasis>. If
-          you annotate a test class with
-          <interfacename>@WebAppConfiguration</interfacename> without
-          specifying a resource base path, the resource path will effectively
-          default to <emphasis>"file:src/main/webapp"</emphasis>. Similarly,
-          if you declare <interfacename>@ContextConfiguration</interfacename>
-          without specifying resource
-          <interfacename>locations</interfacename>, annotated
-          <interfacename>classes</interfacename>, or context
+          support for <emphasis>convention over configuration</emphasis>. If you
+          annotate a test class with
+          <interfacename>@WebAppConfiguration</interfacename> without specifying
+          a resource base path, the resource path will effectively default to
+          <emphasis>"file:src/main/webapp"</emphasis>. Similarly, if you declare
+          <interfacename>@ContextConfiguration</interfacename> without
+          specifying resource <interfacename>locations</interfacename>,
+          annotated <interfacename>classes</interfacename>, or context
           <interfacename>initializers</interfacename>, Spring will attempt to
           detect the presence of your configuration using conventions (i.e.,
-          <emphasis>"WacTests-context.xml"</emphasis> in the same package as
-          the <interfacename>WacTests</interfacename> class or static nested
+          <emphasis>"WacTests-context.xml"</emphasis> in the same package as the
+          <interfacename>WacTests</interfacename> class or static nested
           <interfacename>@Configuration</interfacename> classes).</para>
 
           <example>
-            <title>Default Resource Semantics</title>
+            <title>Default resource semantics</title>
 
             <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 
@@ -1976,18 +2007,18 @@ public class WacTests {
           </example>
 
           <para>This example demonstrates how to explicitly declare a resource
-          base path with <interfacename>@WebAppConfiguration</interfacename>
-          and an XML resource location with
+          base path with <interfacename>@WebAppConfiguration</interfacename> and
+          an XML resource location with
           <interfacename>@ContextConfiguration</interfacename>. The important
-          thing to note here is the different semantics for paths with these
-          two annotations. By default,
-          <interfacename>@WebAppConfiguration</interfacename> resource paths
-          are file system based; whereas,
+          thing to note here is the different semantics for paths with these two
+          annotations. By default,
+          <interfacename>@WebAppConfiguration</interfacename> resource paths are
+          file system based; whereas,
           <interfacename>@ContextConfiguration</interfacename> resource
           locations are classpath based.</para>
 
           <example>
-            <title>Explicit Resource Semantics</title>
+            <title>Explicit resource semantics</title>
 
             <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 
@@ -2012,13 +2043,13 @@ public class WacTests {
 
             <para>To provide comprehensive web testing support, Spring 3.2
             introduces a new
-            <interfacename>ServletTestExecutionListener</interfacename> that
-            is enabled by default. When testing against a
+            <interfacename>ServletTestExecutionListener</interfacename> that is
+            enabled by default. When testing against a
             <interfacename>WebApplicationContext</interfacename> this <link
             linkend="testcontext-key-abstractions">TestExecutionListener</link>
             sets up default thread-local state via Spring Web's
-            <interfacename>RequestContextHolder</interfacename> before each
-            test method and creates a
+            <interfacename>RequestContextHolder</interfacename> before each test
+            method and creates a
             <interfacename>MockHttpServletRequest</interfacename>,
             <interfacename>MockHttpServletResponse</interfacename>, and
             <interfacename>ServletWebRequest</interfacename> based on the base
@@ -2032,20 +2063,19 @@ public class WacTests {
             thread-local state.</para>
 
             <para>Once you have a
-            <interfacename>WebApplicationContext</interfacename> loaded for
-            your test you might find that you need to interact with the web
-            mocks  for example, to set up your test fixture or to perform
-            assertions after invoking your web component. The following
-            example demonstrates which mocks can be autowired into your test
-            instance. Note that the
-            <interfacename>WebApplicationContext</interfacename> and
-            <interfacename>MockServletContext</interfacename> are both cached
-            across the test suite; whereas, the other mocks are managed per
-            test method by the
+            <interfacename>WebApplicationContext</interfacename> loaded for your
+            test you might find that you need to interact with the web mocks 
+            for example, to set up your test fixture or to perform assertions
+            after invoking your web component. The following example
+            demonstrates which mocks can be autowired into your test instance.
+            Note that the <interfacename>WebApplicationContext</interfacename>
+            and <interfacename>MockServletContext</interfacename> are both
+            cached across the test suite; whereas, the other mocks are managed
+            per test method by the
             <interfacename>ServletTestExecutionListener</interfacename>.</para>
 
             <example>
-              <title>Injecting Mocks</title>
+              <title>Injecting mocks</title>
 
               <programlisting language="java">@WebAppConfiguration
 @ContextConfiguration
@@ -2074,19 +2104,19 @@ public class WacTests {
 
           <para>Once the TestContext framework loads an
           <interfacename>ApplicationContext</interfacename> (or
-          <interfacename>WebApplicationContext</interfacename>) for a test,
-          that context will be cached and reused for <emphasis
+          <interfacename>WebApplicationContext</interfacename>) for a test, that
+          context will be cached and reused for <emphasis
           role="bold">all</emphasis> subsequent tests that declare the same
-          unique context configuration within the same test suite. To
-          understand how caching works, it is important to understand what is
-          meant by <emphasis>unique</emphasis> and <emphasis>test
+          unique context configuration within the same test suite. To understand
+          how caching works, it is important to understand what is meant by
+          <emphasis>unique</emphasis> and <emphasis>test
           suite</emphasis>.</para>
 
           <para>An <interfacename>ApplicationContext</interfacename> can be
           <emphasis>uniquely</emphasis> identified by the combination of
           configuration parameters that are used to load it. Consequently, the
-          unique combination of configuration parameters are used to generate
-          a <emphasis>key</emphasis> under which the context is cached. The
+          unique combination of configuration parameters are used to generate a
+          <emphasis>key</emphasis> under which the context is cached. The
           TestContext framework uses the following configuration parameters to
           build the context cache key:</para>
 
@@ -2102,8 +2132,8 @@ public class WacTests {
             </listitem>
 
             <listitem>
-              <para><varname>contextInitializerClasses</varname>
-              <emphasis>(from @ContextConfiguration)</emphasis></para>
+              <para><varname>contextInitializerClasses</varname> <emphasis>(from
+              @ContextConfiguration)</emphasis></para>
             </listitem>
 
             <listitem>
@@ -2130,9 +2160,9 @@ public class WacTests {
           <interfacename>ApplicationContext</interfacename> and store it in a
           <varname>static</varname> context cache under a key that is based
           solely on those locations. So if <classname>TestClassB</classname>
-          also defines <literal>{"app-config.xml",
-          "test-config.xml"}</literal> for its locations (either explicitly or
-          implicitly through inheritance) but does not define
+          also defines <literal>{"app-config.xml", "test-config.xml"}</literal>
+          for its locations (either explicitly or implicitly through
+          inheritance) but does not define
           <interfacename>@WebAppConfiguration</interfacename>, a different
           <interfacename>ContextLoader</interfacename>, different active
           profiles, or different context initializers, then the same
@@ -2145,23 +2175,22 @@ public class WacTests {
             <title>Test suites and forked processes</title>
 
             <para>The Spring TestContext framework stores application contexts
-            in a <emphasis>static</emphasis> cache. This means that the
-            context is literally stored in a <varname>static</varname>
-            variable. In other words, if tests execute in separate processes
-            the static cache will be cleared between each test execution, and
-            this will effectively disable the caching mechanism.</para>
+            in a <emphasis>static</emphasis> cache. This means that the context
+            is literally stored in a <varname>static</varname> variable. In
+            other words, if tests execute in separate processes the static cache
+            will be cleared between each test execution, and this will
+            effectively disable the caching mechanism.</para>
 
             <para>To benefit from the caching mechanism, all tests must run
             within the same process or test suite. This can be achieved by
             executing all tests as a group within an IDE. Similarly, when
-            executing tests with a build framework such as Ant, Maven, or
-            Gradle it is important to make sure that the build framework does
-            not <emphasis>fork</emphasis> between tests. For example, if the
-            <link
+            executing tests with a build framework such as Ant, Maven, or Gradle
+            it is important to make sure that the build framework does not
+            <emphasis>fork</emphasis> between tests. For example, if the <link
             xl:href="http://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode">forkMode</link>
             for the Maven Surefire plug-in is set to <literal>always</literal>
-            or <literal>pertest</literal>, the TestContext framework will not
-            be able to cache application contexts between test classes and the
+            or <literal>pertest</literal>, the TestContext framework will not be
+            able to cache application contexts between test classes and the
             build process will run significantly slower as a result.</para>
           </note>
 
@@ -2169,50 +2198,241 @@ public class WacTests {
           context and requires reloading  for example, by modifying a bean
           definition or the state of an application object  you can annotate
           your test class or test method with
-          <interfacename>@DirtiesContext</interfacename> (see the discussion
-          of <interfacename>@DirtiesContext</interfacename> in <xref
-          linkend="integration-testing-annotations-spring" />). This instructs
+          <interfacename>@DirtiesContext</interfacename> (see the discussion of
+          <interfacename>@DirtiesContext</interfacename> in <xref
+          linkend="integration-testing-annotations-spring"/>). This instructs
           Spring to remove the context from the cache and rebuild the
-          application context before executing the next test. Note that
-          support for the <interfacename>@DirtiesContext</interfacename>
-          annotation is provided by the
+          application context before executing the next test. Note that support
+          for the <interfacename>@DirtiesContext</interfacename> annotation is
+          provided by the
           <classname>DirtiesContextTestExecutionListener</classname> which is
           enabled by default.</para>
         </section>
+
+        <section xml:id="testcontext-ctx-management-ctx-hierarchies">
+          <title>Context hierarchies</title>
+
+          <para>When writing integration tests that rely on a loaded Spring
+          <interfacename>ApplicationContext</interfacename>, it is often
+          sufficient to test against a single context; however, there are times
+          when it is beneficial or even necessary to test against a hierarchy of
+          <interfacename>ApplicationContext</interfacename>s. For example, if
+          you are developing a Spring MVC web application you will typically
+          have a root <interfacename>WebApplicationContext</interfacename>
+          loaded via Spring's <classname>ContextLoaderListener</classname> and a
+          child <interfacename>WebApplicationContext</interfacename> loaded via
+          Spring's <classname>DispatcherServlet</classname>. This results in a
+          parent-child context hierarchy where shared components and
+          infrastructure configuration are declared in the root context and
+          consumed in the child context by web-specific components. Another use
+          case can be found in Spring Batch applications where you often have a
+          parent context that provides configuration for shared batch
+          infrastructure and a child context for the configuration of a specific
+          batch job.</para>
+
+          <para>As of Spring Framework 3.2.2, it is possible to write
+          integration tests that use context hierarchies by declaring context
+          configuration via the <interfacename>@ContextHierarchy</interfacename>
+          annotation, either on an individual test class or within a test class
+          hierarchy. If a context hierarchy is declared on multiple classes
+          within a test class hierarchy it is also possible to merge or override
+          the context configuration for a specific, named level in the context
+          hierarchy. When merging configuration for a given level in the
+          hierarchy the configuration resource type (i.e., XML configuration
+          files or annotated classes) must be consistent; otherwise, it is
+          perfectly acceptable to have different levels in a context hierarchy
+          configured using different resource types.</para>
+
+          <para>The following JUnit-based examples demonstrate common
+          configuration scenarios for integration tests that require the use of
+          context hierarchies.</para>
+
+          <example>
+            <title>Single test class with context hierarchy</title>
+
+            <para><classname>ControllerIntegrationTests</classname> represents a
+            typical integration testing scenario for a Spring MVC web
+            application by declaring a context hierarchy consisting of two
+            levels, one for the <emphasis>root</emphasis> WebApplicationContext
+            (loaded using the <classname>TestAppConfig</classname>
+            <interfacename>@Configuration</interfacename> class) and one for the
+            <emphasis>dispatcher servlet</emphasis>
+            <interfacename>WebApplicationContext</interfacename> (loaded using
+            the <classname>WebConfig</classname>
+            <interfacename>@Configuration</interfacename> class). The
+            <interfacename>WebApplicationContext</interfacename> that is
+            <emphasis>autowired</emphasis> into the test instance is the one for
+            the child context (i.e., the lowest context in the
+            hierarchy).</para>
+
+            <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
+@WebAppConfiguration
+@ContextHierarchy({
+    @ContextConfiguration(classes = TestAppConfig.class),
+    @ContextConfiguration(classes = WebConfig.class)
+})
+public class ControllerIntegrationTests {
+
+    @Autowired
+    private WebApplicationContext wac;
+
+    // ...
+}</programlisting>
+          </example>
+
+          <example>
+            <title>Class hierarchy with implicit parent context</title>
+
+            <para>The following test classes define a context hierarchy within a
+            test class hierarchy. <classname>AbstractWebTests</classname>
+            declares the configuration for a root
+            <interfacename>WebApplicationContext</interfacename> in a
+            Spring-powered web application. Note, however, that
+            <classname>AbstractWebTests</classname> does not declare
+            <interfacename>@ContextHierarchy</interfacename>; consequently,
+            subclasses of <classname>AbstractWebTests</classname> can optionally
+            participate in a context hierarchy or simply follow the standard
+            semantics for <interfacename>@ContextConfiguration</interfacename>.
+            <classname>SoapWebServiceTests</classname> and
+            <classname>RestWebServiceTests</classname> both extend
+            <classname>AbstractWebTests</classname> and define a context
+            hierarchy via <interfacename>@ContextHierarchy</interfacename>. The
+            result is that three application contexts will be loaded (one for
+            each declaration of
+            <interfacename>@ContextConfiguration</interfacename>), and the
+            application context loaded based on the configuration in
+            <classname>AbstractWebTests</classname> will be set as the parent
+            context for each of the contexts loaded for the concrete
+            subclasses.</para>
+
+            <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
+@WebAppConfiguration
+@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
+public abstract class AbstractWebTests {}
+
+@ContextHierarchy(@ContextConfiguration("/spring/soap-ws-config.xml")
+public class SoapWebServiceTests extends AbstractWebTests {}
+
+@ContextHierarchy(@ContextConfiguration("/spring/rest-ws-config.xml")
+public class RestWebServiceTests extends AbstractWebTests {}</programlisting>
+          </example>
+
+          <example>
+            <title>Class hierarchy with merged context hierarchy
+            configuration</title>
+
+            <para>The following classes demonstrate the use of
+            <emphasis>named</emphasis> hierarchy levels in order to
+            <emphasis>merge</emphasis> the configuration for specific levels in
+            a context hierarchy. <classname>BaseTests</classname> defines two
+            levels in the hierarchy, <literal>parent</literal> and
+            <literal>child</literal>. <classname>ExtendedTests</classname>
+            extends <classname>BaseTests</classname> and instructs the Spring
+            TestContext Framework to merge the context configuration for the
+            <literal>child</literal> hierarchy level, simply by ensuring that
+            the names declared via
+            <interfacename>ContextConfiguration</interfacename>'s
+            <varname>name</varname> attribute are both
+            <literal>"child"</literal>. The result is that three application
+            contexts will be loaded: one for
+            <literal>"/app-config.xml"</literal>, one for
+            <literal>"/user-config.xml"</literal>, and one for
+            <literal>{"/user-config.xml", "/order-config.xml"}</literal>. As
+            with the previous example, the application context loaded from
+            <literal>"/app-config.xml"</literal> will be set as the parent
+            context for the contexts loaded from
+            <literal>"/user-config.xml"</literal> and
+            <literal>{"/user-config.xml", "/order-config.xml"}</literal>.</para>
+
+            <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy({
+    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
+    @ContextConfiguration(name = "child",  locations = "/user-config.xml")
+})
+public class BaseTests {}
+
+@ContextHierarchy(
+    @ContextConfiguration(name = "child",  locations = "/order-config.xml")
+)
+public class ExtendedTests extends BaseTests {}</programlisting>
+          </example>
+
+          <example>
+            <title>Class hierarchy with overridden context hierarchy
+            configuration</title>
+
+            <para>In contrast to the previous example, this example demonstrates
+            how to <emphasis>override</emphasis> the configuration for a given
+            named level in a context hierarchy by setting
+            <interfacename>ContextConfiguration</interfacename>'s
+            <varname>inheritLocations</varname> flag to
+            <literal>false</literal>. Consequently, the application context for
+            <classname>ExtendedTests</classname> will be loaded only from
+            <literal>"/test-user-config.xml"</literal> and will have its parent
+            set to the context loaded from
+            <literal>"/app-config.xml"</literal>.</para>
+
+            <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
+@ContextHierarchy({
+    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
+    @ContextConfiguration(name = "child",  locations = "/user-config.xml")
+})
+public class BaseTests {}
+
+@ContextHierarchy(
+    @ContextConfiguration(
+        name = "child",
+        locations = "/test-user-config.xml",
+        inheritLocations = false
+))
+public class ExtendedTests extends BaseTests {}</programlisting>
+          </example>
+
+          <note>
+            <title>Dirtying a context within a context hierarchy</title>
+
+            <para>If <interfacename>@DirtiesContext</interfacename> is used in a
+            test whose context is configured as part of a context hierarchy, the
+            <varname>hierarchyMode</varname> flag can be used to control how the
+            context cache is cleared. For further details consult the discussion
+            of <interfacename>@DirtiesContext</interfacename> in <xref
+            linkend="integration-testing-annotations-spring"/> and the Javadoc
+            for <interfacename>@DirtiesContext</interfacename>.</para>
+          </note>
+        </section>
       </section>
 
       <section xml:id="testcontext-fixture-di">
         <title>Dependency injection of test fixtures</title>
 
         <para>When you use the
-        <classname>DependencyInjectionTestExecutionListener</classname> 
-        which is configured by default  the dependencies of your test
-        instances are <emphasis>injected</emphasis> from beans in the
-        application context that you configured with
-        <interfacename>@ContextConfiguration</interfacename>. You may use
-        setter injection, field injection, or both, depending on which
-        annotations you choose and whether you place them on setter methods or
-        fields. For consistency with the annotation support introduced in
-        Spring 2.5 and 3.0, you can use Spring's
-        <interfacename>@Autowired</interfacename> annotation or the
-        <interfacename>@Inject</interfacename> annotation from JSR 300.</para>
+        <classname>DependencyInjectionTestExecutionListener</classname>  which
+        is configured by default  the dependencies of your test instances are
+        <emphasis>injected</emphasis> from beans in the application context that
+        you configured with
+        <interfacename>@ContextConfiguration</interfacename>. You may use setter
+        injection, field injection, or both, depending on which annotations you
+        choose and whether you place them on setter methods or fields. For
+        consistency with the annotation support introduced in Spring 2.5 and
+        3.0, you can use Spring's <interfacename>@Autowired</interfacename>
+        annotation or the <interfacename>@Inject</interfacename> annotation from
+        JSR 300.</para>
 
         <tip>
           <para>The TestContext framework does not instrument the manner in
           which a test instance is instantiated. Thus the use of
           <interfacename>@Autowired</interfacename> or
-          <interfacename>@Inject</interfacename> for constructors has no
-          effect for test classes.</para>
+          <interfacename>@Inject</interfacename> for constructors has no effect
+          for test classes.</para>
         </tip>
 
         <para>Because <interfacename>@Autowired</interfacename> is used to
-        perform <link linkend="beans-factory-autowire"> <emphasis>autowiring
-        by type</emphasis> </link>, if you have multiple bean definitions of
-        the same type, you cannot rely on this approach for those particular
-        beans. In that case, you can use
-        <interfacename>@Autowired</interfacename> in conjunction with
-        <interfacename>@Qualifier</interfacename>. As of Spring 3.0 you may
-        also choose to use <interfacename>@Inject</interfacename> in
+        perform <link linkend="beans-factory-autowire"> <emphasis>autowiring by
+        type</emphasis> </link>, if you have multiple bean definitions of the
+        same type, you cannot rely on this approach for those particular beans.
+        In that case, you can use <interfacename>@Autowired</interfacename> in
+        conjunction with <interfacename>@Qualifier</interfacename>. As of Spring
+        3.0 you may also choose to use <interfacename>@Inject</interfacename> in
         conjunction with <interfacename>@Named</interfacename>. Alternatively,
         if your test class has access to its
         <classname>ApplicationContext</classname>, you can perform an explicit
@@ -2224,35 +2444,33 @@ public class WacTests {
         <interfacename>@Autowired</interfacename> or
         <interfacename>@Inject</interfacename>. Alternatively, you can disable
         dependency injection altogether by explicitly configuring your class
-        with <interfacename>@TestExecutionListeners</interfacename> and
-        omitting
+        with <interfacename>@TestExecutionListeners</interfacename> and omitting
         <literal>DependencyInjectionTestExecutionListener.class</literal> from
         the list of listeners.</para>
 
         <para>Consider the scenario of testing a
         <classname>HibernateTitleRepository</classname> class, as outlined in
-        the <link linkend="integration-testing-goals">Goals</link> section.
-        The next two code listings demonstrate the use of
-        <interfacename>@Autowired</interfacename> on fields and setter
-        methods. The application context configuration is presented after all
-        sample code listings.</para>
+        the <link linkend="integration-testing-goals">Goals</link> section. The
+        next two code listings demonstrate the use of
+        <interfacename>@Autowired</interfacename> on fields and setter methods.
+        The application context configuration is presented after all sample code
+        listings.</para>
 
         <note>
-          <para>The dependency injection behavior in the following code
-          listings is not specific to JUnit. The same DI techniques can be
-          used in conjunction with any testing framework.</para>
+          <para>The dependency injection behavior in the following code listings
+          is not specific to JUnit. The same DI techniques can be used in
+          conjunction with any testing framework.</para>
 
           <para>The following examples make calls to static assertion methods
-          such as <literal>assertNotNull()</literal> but without prepending
-          the call with <literal>Assert</literal>. In such cases, assume that
-          the method was properly imported through an <literal>import
-          static</literal> declaration that is not shown in the
-          example.</para>
+          such as <literal>assertNotNull()</literal> but without prepending the
+          call with <literal>Assert</literal>. In such cases, assume that the
+          method was properly imported through an <literal>import
+          static</literal> declaration that is not shown in the example.</para>
         </note>
 
         <para>The first code listing shows a JUnit-based implementation of the
-        test class that uses <interfacename>@Autowired</interfacename> for
-        field injection.</para>
+        test class that uses <interfacename>@Autowired</interfacename> for field
+        injection.</para>
 
         <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 <lineannotation>// specifies the Spring configuration to load for this test fixture</lineannotation>
@@ -2319,10 +2537,10 @@ public class HibernateTitleRepositoryTests {
 &lt;/beans&gt;</programlisting>
 
         <note>
-          <para>If you are extending from a Spring-provided test base class
-          that happens to use <interfacename>@Autowired</interfacename> on one
-          of its setter methods, you might have multiple beans of the affected
-          type defined in your application context: for example, multiple
+          <para>If you are extending from a Spring-provided test base class that
+          happens to use <interfacename>@Autowired</interfacename> on one of its
+          setter methods, you might have multiple beans of the affected type
+          defined in your application context: for example, multiple
           <interfacename>DataSource</interfacename> beans. In such a case, you
           can override the setter method and use the
           <interfacename>@Qualifier</interfacename> annotation to indicate a
@@ -2345,8 +2563,8 @@ public class HibernateTitleRepositoryTests {
           against <literal>&lt;qualifier&gt;</literal> declarations within the
           corresponding <literal>&lt;bean&gt;</literal> definitions. The bean
           name is used as a fallback qualifier value, so you may effectively
-          also point to a specific bean by name there (as shown above,
-          assuming that "myDataSource" is the bean id).</para>
+          also point to a specific bean by name there (as shown above, assuming
+          that "myDataSource" is the bean id).</para>
         </note>
       </section>
 
@@ -2354,10 +2572,10 @@ public class HibernateTitleRepositoryTests {
         <title>Testing request and session scoped beans</title>
 
         <para><link linkend="beans-factory-scopes-other">Request and session
-        scoped beans</link> have been supported by Spring for several years
-        now, but it's always been a bit non-trivial to test them. As of Spring
-        3.2 it's now a breeze to test your request-scoped and session-scoped
-        beans by following these steps.</para>
+        scoped beans</link> have been supported by Spring for several years now,
+        but it's always been a bit non-trivial to test them. As of Spring 3.2
+        it's now a breeze to test your request-scoped and session-scoped beans
+        by following these steps.</para>
 
         <itemizedlist>
           <listitem>
@@ -2368,8 +2586,8 @@ public class HibernateTitleRepositoryTests {
           </listitem>
 
           <listitem>
-            <para>Inject the mock request or session into your test instance
-            and prepare your test fixture as appropriate.</para>
+            <para>Inject the mock request or session into your test instance and
+            prepare your test fixture as appropriate.</para>
           </listitem>
 
           <listitem>
@@ -2384,13 +2602,13 @@ public class HibernateTitleRepositoryTests {
         </itemizedlist>
 
         <para>The following code snippet displays the XML configuration for a
-        login use case. Note that the <literal>userService</literal> bean has
-        a dependency on a request-scoped <literal>loginAction</literal> bean.
-        Also, the <classname>LoginAction</classname> is instantiated using
-        <link linkend="expressions">SpEL expressions</link> that retrieve the
-        username and password from the current HTTP request. In our test, we
-        will want to configure these request parameters via the mock managed
-        by the TestContext framework.</para>
+        login use case. Note that the <literal>userService</literal> bean has a
+        dependency on a request-scoped <literal>loginAction</literal> bean.
+        Also, the <classname>LoginAction</classname> is instantiated using <link
+        linkend="expressions">SpEL expressions</link> that retrieve the username
+        and password from the current HTTP request. In our test, we will want to
+        configure these request parameters via the mock managed by the
+        TestContext framework.</para>
 
         <example>
           <title>Request-scoped bean configuration</title>
@@ -2414,16 +2632,15 @@ public class HibernateTitleRepositoryTests {
         <para>In <classname>RequestScopedBeanTests</classname> we inject both
         the <classname>UserService</classname> (i.e., the subject under test)
         and the <classname>MockHttpServletRequest</classname> into our test
-        instance. Within our <function>requestScope()</function> test method
-        we set up our test fixture by setting request parameters in the
-        provided <classname>MockHttpServletRequest</classname>. When the
+        instance. Within our <function>requestScope()</function> test method we
+        set up our test fixture by setting request parameters in the provided
+        <classname>MockHttpServletRequest</classname>. When the
         <function>loginUser()</function> method is invoked on our
-        <literal>userService</literal> we are assured that the user service
-        has access to the request-scoped <literal>loginAction</literal> for
-        the current <classname>MockHttpServletRequest</classname> (i.e., the
-        one we just set parameters in). We can then perform assertions against
-        the results based on the known inputs for the username and
-        password.</para>
+        <literal>userService</literal> we are assured that the user service has
+        access to the request-scoped <literal>loginAction</literal> for the
+        current <classname>MockHttpServletRequest</classname> (i.e., the one we
+        just set parameters in). We can then perform assertions against the
+        results based on the known inputs for the username and password.</para>
 
         <example>
           <title>Request-scoped bean test</title>
@@ -2449,14 +2666,14 @@ public class RequestScopedBeanTests {
 }</programlisting>
         </example>
 
-        <para>The following code snippet is similar to the one we saw above
-        for a request-scoped bean; however, this time the
-        <literal>userService</literal> bean has a dependency on a
-        session-scoped <literal>userPreferences</literal> bean. Note that the
-        <classname>UserPreferences</classname> bean is instantiated using a
-        SpEL expression that retrieves the <emphasis>theme</emphasis> from the
-        current HTTP session. In our test, we will need to configure a theme
-        in the mock session managed by the TestContext framework.</para>
+        <para>The following code snippet is similar to the one we saw above for
+        a request-scoped bean; however, this time the
+        <literal>userService</literal> bean has a dependency on a session-scoped
+        <literal>userPreferences</literal> bean. Note that the
+        <classname>UserPreferences</classname> bean is instantiated using a SpEL
+        expression that retrieves the <emphasis>theme</emphasis> from the
+        current HTTP session. In our test, we will need to configure a theme in
+        the mock session managed by the TestContext framework.</para>
 
         <example>
           <title>Session-scoped bean configuration</title>
@@ -2484,11 +2701,10 @@ public class RequestScopedBeanTests {
         fixture by setting the expected "theme" attribute in the provided
         <classname>MockHttpSession</classname>. When the
         <function>processUserPreferences()</function> method is invoked on our
-        <literal>userService</literal> we are assured that the user service
-        has access to the session-scoped <literal>userPreferences</literal>
-        for the current <classname>MockHttpSession</classname>, and we can
-        perform assertions against the results based on the configured
-        theme.</para>
+        <literal>userService</literal> we are assured that the user service has
+        access to the session-scoped <literal>userPreferences</literal> for the
+        current <classname>MockHttpSession</classname>, and we can perform
+        assertions against the results based on the configured theme.</para>
 
         <example>
           <title>Session-scoped bean test</title>
@@ -2519,30 +2735,28 @@ public class SessionScopedBeanTests {
 
         <para>In the TestContext framework, transactions are managed by the
         <classname>TransactionalTestExecutionListener</classname>. Note that
-        <classname>TransactionalTestExecutionListener</classname> is
-        configured by default, even if you do not explicitly declare
+        <classname>TransactionalTestExecutionListener</classname> is configured
+        by default, even if you do not explicitly declare
         <interfacename>@TestExecutionListeners</interfacename> on your test
         class. To enable support for transactions, however, you must provide a
         <classname>PlatformTransactionManager</classname> bean in the
         application context loaded by
         <interfacename>@ContextConfiguration</interfacename> semantics. In
-        addition, you must declare
-        <interfacename>@Transactional</interfacename> either at the class or
-        method level for your tests.</para>
+        addition, you must declare <interfacename>@Transactional</interfacename>
+        either at the class or method level for your tests.</para>
 
         <para>For class-level transaction configuration (i.e., setting an
-        explicit bean name for the transaction manager and the default
-        rollback flag), see the
-        <interfacename>@TransactionConfiguration</interfacename> entry in the
-        <link linkend="integration-testing-annotations">annotation
+        explicit bean name for the transaction manager and the default rollback
+        flag), see the <interfacename>@TransactionConfiguration</interfacename>
+        entry in the <link linkend="integration-testing-annotations">annotation
         support</link> section.</para>
 
-        <para>If transactions are not enabled for the entire test class, you
-        can annotate methods explicitly with
+        <para>If transactions are not enabled for the entire test class, you can
+        annotate methods explicitly with
         <interfacename>@Transactional</interfacename>. To control whether a
-        transaction should commit for a particular test method, you can use
-        the <interfacename>@Rollback</interfacename> annotation to override
-        the class-level default rollback setting.</para>
+        transaction should commit for a particular test method, you can use the
+        <interfacename>@Rollback</interfacename> annotation to override the
+        class-level default rollback setting.</para>
 
         <para><emphasis><link linkend="testcontext-support-classes-junit4">
         <classname>AbstractTransactionalJUnit4SpringContextTests</classname>
@@ -2553,14 +2767,13 @@ public class SessionScopedBeanTests {
 
         <para>Occasionally you need to execute certain code before or after a
         transactional test method but outside the transactional context, for
-        example, to verify the initial database state prior to execution of
-        your test or to verify expected transactional commit behavior after
-        test execution (if the test was configured not to roll back the
-        transaction).
+        example, to verify the initial database state prior to execution of your
+        test or to verify expected transactional commit behavior after test
+        execution (if the test was configured not to roll back the transaction).
         <classname>TransactionalTestExecutionListener</classname> supports the
         <interfacename>@BeforeTransaction</interfacename> and
-        <interfacename>@AfterTransaction</interfacename> annotations exactly
-        for such scenarios. Simply annotate any <literal>public void</literal>
+        <interfacename>@AfterTransaction</interfacename> annotations exactly for
+        such scenarios. Simply annotate any <literal>public void</literal>
         method in your test class with one of these annotations, and the
         <classname>TransactionalTestExecutionListener</classname> ensures that
         your <emphasis>before transaction method</emphasis> or <emphasis>after
@@ -2569,12 +2782,11 @@ public class SessionScopedBeanTests {
 
         <tip>
           <para>Any <emphasis>before methods</emphasis> (such as methods
-          annotated with JUnit's <interfacename>@Before</interfacename>) and
-          any <emphasis>after methods</emphasis> (such as methods annotated
-          with JUnit's <interfacename>@After</interfacename>) are executed
-          <emphasis role="bold">within</emphasis> a transaction. In addition,
-          methods annotated with
-          <interfacename>@BeforeTransaction</interfacename> or
+          annotated with JUnit's <interfacename>@Before</interfacename>) and any
+          <emphasis>after methods</emphasis> (such as methods annotated with
+          JUnit's <interfacename>@After</interfacename>) are executed <emphasis
+          role="bold">within</emphasis> a transaction. In addition, methods
+          annotated with <interfacename>@BeforeTransaction</interfacename> or
           <interfacename>@AfterTransaction</interfacename> are naturally not
           executed for tests annotated with
           <interfacename>@NotTransactional</interfacename>. However,
@@ -2623,21 +2835,21 @@ public class FictitiousTransactionalTest {
 
 }</programlisting>
 
-        <anchor xml:id="testcontext-tx-false-positives" />
+        <anchor xml:id="testcontext-tx-false-positives"/>
 
         <note>
           <title>Avoid false positives when testing ORM code</title>
 
-          <para>When you test application code that manipulates the state of
-          the Hibernate session, make sure to <emphasis>flush</emphasis> the
-          underlying session within test methods that execute that code.
-          Failing to flush the underlying session can produce <emphasis>false
-          positives</emphasis>: your test may pass, but the same code throws
-          an exception in a live, production environment. In the following
+          <para>When you test application code that manipulates the state of the
+          Hibernate session, make sure to <emphasis>flush</emphasis> the
+          underlying session within test methods that execute that code. Failing
+          to flush the underlying session can produce <emphasis>false
+          positives</emphasis>: your test may pass, but the same code throws an
+          exception in a live, production environment. In the following
           Hibernate-based example test case, one method demonstrates a false
           positive, and the other method correctly exposes the results of
-          flushing the session. Note that this applies to JPA and any other
-          ORM frameworks that maintain an in-memory <emphasis>unit of
+          flushing the session. Note that this applies to JPA and any other ORM
+          frameworks that maintain an in-memory <emphasis>unit of
           work</emphasis>.</para>
 
           <programlisting language="java"><lineannotation>// ...</lineannotation>
@@ -2688,9 +2900,9 @@ public void updateWithSessionFlush() {
 
               <itemizedlist>
                 <listitem>
-                  <para><literal>applicationContext</literal>: Use this
-                  variable to perform explicit bean lookups or to test the
-                  state of the context as a whole.</para>
+                  <para><literal>applicationContext</literal>: Use this variable
+                  to perform explicit bean lookups or to test the state of the
+                  context as a whole.</para>
                 </listitem>
               </itemizedlist>
             </listitem>
@@ -2698,29 +2910,28 @@ public void updateWithSessionFlush() {
             <listitem>
               <para><classname>AbstractTransactionalJUnit4SpringContextTests</classname>:
               Abstract <emphasis>transactional</emphasis> extension of
-              <classname>AbstractJUnit4SpringContextTests</classname> that
-              also adds some convenience functionality for JDBC access.
-              Expects a <classname>javax.sql.DataSource</classname> bean and a
-              <interfacename>PlatformTransactionManager</interfacename> bean
-              to be defined in the <classname>ApplicationContext</classname>.
-              When you extend
+              <classname>AbstractJUnit4SpringContextTests</classname> that also
+              adds some convenience functionality for JDBC access. Expects a
+              <classname>javax.sql.DataSource</classname> bean and a
+              <interfacename>PlatformTransactionManager</interfacename> bean to
+              be defined in the <classname>ApplicationContext</classname>. When
+              you extend
               <classname>AbstractTransactionalJUnit4SpringContextTests</classname>
-              you can access the following <literal>protected</literal>
-              instance variables:</para>
+              you can access the following <literal>protected</literal> instance
+              variables:</para>
 
               <itemizedlist>
                 <listitem>
                   <para><literal>applicationContext</literal>: Inherited from
                   the <classname>AbstractJUnit4SpringContextTests</classname>
-                  superclass. Use this variable to perform explicit bean
-                  lookups or to test the state of the context as a
-                  whole.</para>
+                  superclass. Use this variable to perform explicit bean lookups
+                  or to test the state of the context as a whole.</para>
                 </listitem>
 
                 <listitem>
                   <para><literal>jdbcTemplate</literal>: Use this variable to
-                  execute SQL statements to query the database. Such queries
-                  can be used to confirm database state both <emphasis>prior
+                  execute SQL statements to query the database. Such queries can
+                  be used to confirm database state both <emphasis>prior
                   to</emphasis> and <emphasis>after</emphasis> execution of
                   database-related application code, and Spring ensures that
                   such queries run in the scope of the same transaction as the
@@ -2737,8 +2948,8 @@ public void updateWithSessionFlush() {
             <para>These classes are a convenience for extension. If you do not
             want your test classes to be tied to a Spring-specific class
             hierarchy  for example, if you want to directly extend the class
-            you are testing  you can configure your own custom test classes
-            by using
+            you are testing  you can configure your own custom test classes by
+            using
             <interfacename>@RunWith(SpringJUnit4ClassRunner.class)</interfacename>,
             <interfacename>@ContextConfiguration</interfacename>,
             <interfacename>@TestExecutionListeners</interfacename>, and so
@@ -2752,18 +2963,17 @@ public void updateWithSessionFlush() {
           <para>The <emphasis>Spring TestContext Framework</emphasis> offers
           full integration with JUnit 4.5+ through a custom runner (tested on
           JUnit 4.5  4.10). By annotating test classes with
-          <literal>@RunWith(SpringJUnit4ClassRunner.class)</literal>,
-          developers can implement standard JUnit-based unit and integration
-          tests and simultaneously reap the benefits of the TestContext
-          framework such as support for loading application contexts,
-          dependency injection of test instances, transactional test method
-          execution, and so on. The following code listing displays the
-          minimal requirements for configuring a test class to run with the
-          custom Spring Runner.
+          <literal>@RunWith(SpringJUnit4ClassRunner.class)</literal>, developers
+          can implement standard JUnit-based unit and integration tests and
+          simultaneously reap the benefits of the TestContext framework such as
+          support for loading application contexts, dependency injection of test
+          instances, transactional test method execution, and so on. The
+          following code listing displays the minimal requirements for
+          configuring a test class to run with the custom Spring Runner.
           <interfacename>@TestExecutionListeners</interfacename> is configured
           with an empty list in order to disable the default listeners, which
-          otherwise would require an ApplicationContext to be configured
-          through <interfacename>@ContextConfiguration</interfacename>.</para>
+          otherwise would require an ApplicationContext to be configured through
+          <interfacename>@ContextConfiguration</interfacename>.</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 @TestExecutionListeners({})
@@ -2797,9 +3007,9 @@ public class SimpleTest {
 
               <itemizedlist>
                 <listitem>
-                  <para><literal>applicationContext</literal>: Use this
-                  variable to perform explicit bean lookups or to test the
-                  state of the context as a whole.</para>
+                  <para><literal>applicationContext</literal>: Use this variable
+                  to perform explicit bean lookups or to test the state of the
+                  context as a whole.</para>
                 </listitem>
               </itemizedlist>
             </listitem>
@@ -2807,29 +3017,28 @@ public class SimpleTest {
             <listitem>
               <para><classname>AbstractTransactionalTestNGSpringContextTests</classname>:
               Abstract <emphasis>transactional</emphasis> extension of
-              <classname>AbstractTestNGSpringContextTests</classname> that
-              adds some convenience functionality for JDBC access. Expects a
+              <classname>AbstractTestNGSpringContextTests</classname> that adds
+              some convenience functionality for JDBC access. Expects a
               <classname>javax.sql.DataSource</classname> bean and a
-              <interfacename>PlatformTransactionManager</interfacename> bean
-              to be defined in the <classname>ApplicationContext</classname>.
-              When you extend
+              <interfacename>PlatformTransactionManager</interfacename> bean to
+              be defined in the <classname>ApplicationContext</classname>. When
+              you extend
               <classname>AbstractTransactionalTestNGSpringContextTests</classname>,
-              you can access the following <literal>protected</literal>
-              instance variables:</para>
+              you can access the following <literal>protected</literal> instance
+              variables:</para>
 
               <itemizedlist>
                 <listitem>
                   <para><literal>applicationContext</literal>: Inherited from
                   the <classname>AbstractTestNGSpringContextTests</classname>
-                  superclass. Use this variable to perform explicit bean
-                  lookups or to test the state of the context as a
-                  whole.</para>
+                  superclass. Use this variable to perform explicit bean lookups
+                  or to test the state of the context as a whole.</para>
                 </listitem>
 
                 <listitem>
                   <para><literal>jdbcTemplate</literal>: Use this variable to
-                  execute SQL statements to query the database. Such queries
-                  can be used to confirm database state both <emphasis>prior
+                  execute SQL statements to query the database. Such queries can
+                  be used to confirm database state both <emphasis>prior
                   to</emphasis> and <emphasis>after</emphasis> execution of
                   database-related application code, and Spring ensures that
                   such queries run in the scope of the same transaction as the
@@ -2846,8 +3055,8 @@ public class SimpleTest {
             <para>These classes are a convenience for extension. If you do not
             want your test classes to be tied to a Spring-specific class
             hierarchy  for example, if you want to directly extend the class
-            you are testing  you can configure your own custom test classes
-            by using <interfacename>@ContextConfiguration</interfacename>,
+            you are testing  you can configure your own custom test classes by
+            using <interfacename>@ContextConfiguration</interfacename>,
             <interfacename>@TestExecutionListeners</interfacename>, and so on,
             and by manually instrumenting your test class with a
             <classname>TestContextManager</classname>. See the source code of
@@ -2873,71 +3082,70 @@ public class SimpleTest {
         xl:href="https://github.com/SpringSource/spring-test-mvc">spring-test-mvc
         project</link> is still available on GitHub and can be used in
         conjunction with Spring Framework 3.1.x. Applications upgrading to 3.2
-        should replace the <filename>spring-test-mvc</filename> dependency
-        with a dependency on <filename>spring-test</filename>.</para>
+        should replace the <filename>spring-test-mvc</filename> dependency with
+        a dependency on <filename>spring-test</filename>.</para>
 
         <para>The <filename>spring-test</filename> module uses a different
         package <classname>org.springframework.test.web</classname> but
         otherwise is nearly identical with two exceptions. One is support for
-        features new in 3.2 (e.g. asynchronous web requests). The other
-        relates to the options for creating a <classname>MockMvc</classname>
-        instance. In Spring Framework 3.2, this can only be done through the
-        TestContext framework, which provides caching benefits for the loaded
+        features new in 3.2 (e.g. asynchronous web requests). The other relates
+        to the options for creating a <classname>MockMvc</classname> instance.
+        In Spring Framework 3.2, this can only be done through the TestContext
+        framework, which provides caching benefits for the loaded
         configuration.</para>
       </sidebar>
 
       <para>The <emphasis>Spring MVC Test framework</emphasis> provides first
       class JUnit support for testing client and server-side Spring MVC code
       through a fluent API. Typically it loads the actual Spring configuration
-      through the <emphasis>TestContext framework</emphasis> and always uses
-      the <classname>DispatcherServlet</classname> to process requests thus
+      through the <emphasis>TestContext framework</emphasis> and always uses the
+      <classname>DispatcherServlet</classname> to process requests thus
       approximating full integration tests without requiring a running Servlet
       container.</para>
 
-      <para>Client-side tests are <classname>RestTemplate</classname>-based
-      and allow tests for code that relies on the
-      <classname>RestTemplate</classname> without requiring a running server
-      to respond to the requests.</para>
+      <para>Client-side tests are <classname>RestTemplate</classname>-based and
+      allow tests for code that relies on the
+      <classname>RestTemplate</classname> without requiring a running server to
+      respond to the requests.</para>
 
       <section xml:id="spring-mvc-test-server">
         <title>Server-Side Tests</title>
 
-        <para>Before Spring Framework 3.2, the most likely way to test a
-        Spring MVC controller was to write a unit test that instantiates the
+        <para>Before Spring Framework 3.2, the most likely way to test a Spring
+        MVC controller was to write a unit test that instantiates the
         controller, injects it with mock or stub dependencies, and then calls
         its methods directly, using a
         <classname>MockHttpServletRequest</classname> and
         <classname>MockHttpServletResponse</classname> where necessary.</para>
 
         <para>Although this is pretty easy to do, controllers have many
-        annotations, and much remains untested. Request mappings, data
-        binding, type conversion, and validation are just a few examples of
-        what isn't tested. Furthermore, there are other types of annotated
-        methods such as <interfacename>@InitBinder</interfacename>,
+        annotations, and much remains untested. Request mappings, data binding,
+        type conversion, and validation are just a few examples of what isn't
+        tested. Furthermore, there are other types of annotated methods such as
+        <interfacename>@InitBinder</interfacename>,
         <interfacename>@ModelAttribute</interfacename>, and
         <interfacename>@ExceptionHandler</interfacename> that get invoked as
         part of request processing.</para>
 
         <para>The idea behind Spring MVC Test is to be able to re-write those
-        controller tests by performing actual requests and generating
-        responses, as they would be at runtime, along the way invoking
-        controllers through the Spring MVC
-        <classname>DispatcherServlet</classname>. Controllers can still be
-        injected with mock dependencies, so tests can remain focused on the
-        web layer.</para>
+        controller tests by performing actual requests and generating responses,
+        as they would be at runtime, along the way invoking controllers through
+        the Spring MVC <classname>DispatcherServlet</classname>. Controllers can
+        still be injected with mock dependencies, so tests can remain focused on
+        the web layer.</para>
 
         <para>Spring MVC Test builds on the familiar "mock" implementations of
         the Servlet API available in the <filename>spring-test</filename>
-        module. This allows performing requests and generating responses
-        without the need for running in a Servlet container. For the most part
+        module. This allows performing requests and generating responses without
+        the need for running in a Servlet container. For the most part
         everything should work as it does at runtime with the exception of JSP
         rendering, which is not available outside a Servlet container.
         Furthermore, if you are familiar with how the
         <classname>MockHttpServletResponse</classname> works, you'll know that
         forwards and redirects are not actually executed. Instead "forwarded"
-        and "redirected" URLs are saved and can be asserted in tests. This
-        means if you are using JSPs, you can verify the JSP page to which the
-        request was forwarded.</para>
+        and "redirected" URLs are saved and can be asserted in tests. This means
+        if you are using JSPs, you can verify the JSP page to which the request
+        was forwarded.</para>
 
         <para>All other means of rendering including
         <interfacename>@ResponseBody</interfacename> methods and
@@ -2980,18 +3188,17 @@ public class ExampleTests {
         <para>The test relies on the
         <interfacename>WebApplicationContext</interfacename> support of the
         <emphasis>TestContext framework</emphasis>. It loads Spring
-        configuration from an XML configuration file located in the same
-        package as the test class (also supports JavaConfig) and injects the
-        created <interfacename>WebApplicationContext</interfacename> into the
-        test so a <classname>MockMvc</classname> instance can be created with
-        it.</para>
+        configuration from an XML configuration file located in the same package
+        as the test class (also supports JavaConfig) and injects the created
+        <interfacename>WebApplicationContext</interfacename> into the test so a
+        <classname>MockMvc</classname> instance can be created with it.</para>
 
         <para>The <classname>MockMvc</classname> is then used to perform a
         request to <filename>"/accounts/1"</filename> and verify the resulting
         response status is 200, the response content type is
-        <filename>"application/json"</filename>, and response content has a
-        JSON property called "name" with the value "Lee". JSON content is
-        inspected with the help of Jayway's <link
+        <filename>"application/json"</filename>, and response content has a JSON
+        property called "name" with the value "Lee". JSON content is inspected
+        with the help of Jayway's <link
         xl:href="https://github.com/jayway/JsonPath">JsonPath project</link>.
         There are lots of other options for verifying the result of the
         performed request and those will be discussed later.</para>
@@ -3004,13 +3211,13 @@ public class ExampleTests {
           <classname>MockMvcResultMatchers.*</classname>, and
           <classname>MockMvcBuilders.*</classname>. An easy way to find these
           classes is to search for types matching
-          <emphasis>"MockMvc*"</emphasis>. If using Eclipse, be sure to add
-          them as "favorite static members" in the Eclipse preferences under
+          <emphasis>"MockMvc*"</emphasis>. If using Eclipse, be sure to add them
+          as "favorite static members" in the Eclipse preferences under
           <emphasis>Java -&gt; Editor -&gt; Content Assist -&gt;
           Favorites</emphasis>. That will allow use of content assist after
-          typing the first character of the static method name. Other IDEs
-          (e.g. IntelliJ) may not require any additional configuration. Just
-          check the support for code completion on static members.</para>
+          typing the first character of the static method name. Other IDEs (e.g.
+          IntelliJ) may not require any additional configuration. Just check the
+          support for code completion on static members.</para>
         </section>
 
         <section xml:id="spring-mvc-test-server-setup-options">
@@ -3020,11 +3227,11 @@ public class ExampleTests {
           <classname>MockMvc</classname> that can be used to perform requests.
           There are two main options.</para>
 
-          <para>The first option is to point to Spring MVC configuration
-          through the <emphasis>TestContext framework</emphasis>, which loads
-          the Spring configuration and injects a
-          <interfacename>WebApplicationContext</interfacename> into the test
-          to use to create a <classname>MockMvc</classname>:</para>
+          <para>The first option is to point to Spring MVC configuration through
+          the <emphasis>TestContext framework</emphasis>, which loads the Spring
+          configuration and injects a
+          <interfacename>WebApplicationContext</interfacename> into the test to
+          use to create a <classname>MockMvc</classname>:</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 @WebAppConfiguration
@@ -3048,9 +3255,9 @@ public class MyWebTests {
           <para>The second option is to simply register a controller instance
           without loading any Spring configuration. Instead basic Spring MVC
           configuration suitable for testing annotated controllers is
-          automatically created. The created configuration is comparable to
-          that of the MVC JavaConfig (and the MVC namespace) and can be
-          customized to a degree through builder-style methods:</para>
+          automatically created. The created configuration is comparable to that
+          of the MVC JavaConfig (and the MVC namespace) and can be customized to
+          a degree through builder-style methods:</para>
 
           <programlisting language="java">public class MyWebTests {
 
@@ -3069,20 +3276,20 @@ public class MyWebTests {
 
           <para>The <emphasis>"webAppContextSetup"</emphasis> loads the actual
           Spring MVC configuration resulting in a more complete integration
-          test. Since the <emphasis>TestContext framework</emphasis> caches
-          the loaded Spring configuration, it helps to keep tests running fast
-          even as more tests get added. Furthermore, you can inject mock
-          services into controllers through Spring configuration, in order to
-          remain focused on testing the web layer. Here is an example of
-          declaring a mock service with Mockito:</para>
+          test. Since the <emphasis>TestContext framework</emphasis> caches the
+          loaded Spring configuration, it helps to keep tests running fast even
+          as more tests get added. Furthermore, you can inject mock services
+          into controllers through Spring configuration, in order to remain
+          focused on testing the web layer. Here is an example of declaring a
+          mock service with Mockito:</para>
 
           <programlisting language="xml">&lt;bean id="accountService" class="org.mockito.Mockito" factory-method="mock"&gt;
     &lt;constructor-arg value="org.example.AccountService"/&gt;
 &lt;/bean&gt;
 </programlisting>
 
-          <para>Then you can inject the mock service into the test in order
-          set up and verify expectations:</para>
+          <para>Then you can inject the mock service into the test in order set
+          up and verify expectations:</para>
 
           <programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
 @WebAppConfiguration
@@ -3101,19 +3308,19 @@ public class AccountTests {
 
 }</programlisting>
 
-          <para>The <emphasis>"standaloneSetup"</emphasis> on the other hand
-          is a little closer to a unit test. It tests one controller at a
-          time, the controller can be injected with mock dependencies
-          manually, and it doesn't involve loading Spring configuration. Such
-          tests are more focused in style and make it easier to see which
-          controller is being tested, whether any specific Spring MVC
-          configuration is required to work, and so on. The "standaloneSetup"
-          is also a very convenient way to write ad-hoc tests to verify some
-          behavior or to debug an issue.</para>
-
-          <para>Just like with integration vs unit testing, there is no right
-          or wrong answer. Using the "standaloneSetup" does imply the need for
-          some additional "webAppContextSetup" tests to verify the Spring MVC
+          <para>The <emphasis>"standaloneSetup"</emphasis> on the other hand is
+          a little closer to a unit test. It tests one controller at a time, the
+          controller can be injected with mock dependencies manually, and it
+          doesn't involve loading Spring configuration. Such tests are more
+          focused in style and make it easier to see which controller is being
+          tested, whether any specific Spring MVC configuration is required to
+          work, and so on. The "standaloneSetup" is also a very convenient way
+          to write ad-hoc tests to verify some behavior or to debug an
+          issue.</para>
+
+          <para>Just like with integration vs unit testing, there is no right or
+          wrong answer. Using the "standaloneSetup" does imply the need for some
+          additional "webAppContextSetup" tests to verify the Spring MVC
           configuration. Alternatively, you can decide write all tests with
           "webAppContextSetup" and always test against actual Spring MVC
           configuration.</para>
@@ -3151,22 +3358,21 @@ public class AccountTests {
           doesn't check the query string, as is most often the case, then it
           doesn't matter how parameters are added. Keep in mind though that
           parameters provided in the URI template will be decoded while
-          parameters provided through the <function>param(...)</function>
-          method are expected to be decoded.</para>
+          parameters provided through the <function>param(...)</function> method
+          are expected to be decoded.</para>
 
-          <para>In most cases it's preferable to leave out the context path
-          and the Servlet path from the request URI. If you must test with the
-          full request URI, be sure to set the
-          <function>contextPath</function> and
-          <function>servletPath</function> accordingly so that request
-          mappings will work:</para>
+          <para>In most cases it's preferable to leave out the context path and
+          the Servlet path from the request URI. If you must test with the full
+          request URI, be sure to set the <function>contextPath</function> and
+          <function>servletPath</function> accordingly so that request mappings
+          will work:</para>
 
           <programlisting language="java">mockMvc.perform(get("/app/main/hotels/{id}").contextPath("/app").servletPath("/main"))
 </programlisting>
 
-          <para>Looking at the above example, it would be cumbersome to set
-          the contextPath and servletPath with every performed request. That's
-          why you can define default request properties when building the
+          <para>Looking at the above example, it would be cumbersome to set the
+          contextPath and servletPath with every performed request. That's why
+          you can define default request properties when building the
           <classname>MockMvc</classname>:</para>
 
           <programlisting language="java">public class MyWebTests {
@@ -3185,10 +3391,10 @@ public class AccountTests {
 
           <para>The above properties will apply to every request performed
           through the <classname>MockMvc</classname>. If the same property is
-          also specified on a given request, it will override the default
-          value. That is why, the HTTP method and URI don't matter, when
-          setting default request properties, since they must be specified on
-          every request.</para>
+          also specified on a given request, it will override the default value.
+          That is why, the HTTP method and URI don't matter, when setting
+          default request properties, since they must be specified on every
+          request.</para>
         </section>
 
         <section xml:id="spring-mvc-test-server-defining-expectations">
@@ -3203,12 +3409,12 @@ public class AccountTests {
 
           <para><literal>MockMvcResultMatchers.*</literal> defines a number of
           static members, some of which return types with additional methods,
-          for asserting the result of the performed request. The assertions
-          fall in two general categories.</para>
+          for asserting the result of the performed request. The assertions fall
+          in two general categories.</para>
 
           <para>The first category of assertions verify properties of the
-          response, i.e the response status, headers, and content. Those are
-          the most important things to test for.</para>
+          response, i.e the response status, headers, and content. Those are the
+          most important things to test for.</para>
 
           <para>The second category of assertions go beyond the response, and
           allow inspecting Spring MVC specific constructs such as which
@@ -3216,8 +3422,8 @@ public class AccountTests {
           raised and handled, what the content of the model is, what view was
           selected, what flash attributes were added, and so on. It is also
           possible to verify Servlet specific constructs such as request and
-          session attributes. The following test asserts that
-          binding/validation failed:</para>
+          session attributes. The following test asserts that binding/validation
+          failed:</para>
 
           <programlisting language="java">
 mockMvc.perform(post("/persons"))
@@ -3225,8 +3431,8 @@ mockMvc.perform(post("/persons"))
   .andExpect(model().attributeHasErrors("person"));
 </programlisting>
 
-          <para>Many times when writing tests, it's useful to dump the result
-          of the performed request. This can be done as follows, where
+          <para>Many times when writing tests, it's useful to dump the result of
+          the performed request. This can be done as follows, where
           <function>print()</function> is a static import from
           <classname>MockMvcResultHandlers</classname>:</para>
 
@@ -3235,8 +3441,8 @@ mockMvc.perform(post("/persons"))
   .andExpect(status().isOk())
   .andExpect(model().attributeHasErrors("person"));</programlisting>
 
-          <para>As long as request processing causes an unhandled exception,
-          the <function>print()</function> method will print all the available
+          <para>As long as request processing causes an unhandled exception, the
+          <function>print()</function> method will print all the available
           result data to <literal>System.out</literal>.</para>
 
           <para>In some cases, you may want to get direct access to the result
@@ -3247,8 +3453,8 @@ mockMvc.perform(post("/persons"))
           <programlisting language="java">MvcResult mvcResult = mockMvc.perform(post("/persons")).andExpect(status().isOk()).andReturn();
 // ...</programlisting>
 
-          <para>When all tests repeat the same expectations, you can define
-          the common expectations once when building the
+          <para>When all tests repeat the same expectations, you can define the
+          common expectations once when building the
           <classname>MockMvc</classname>:</para>
 
           <programlisting language="java">standaloneSetup(new SimpleController())
@@ -3256,8 +3462,8 @@ mockMvc.perform(post("/persons"))
     .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
     .build()</programlisting>
 
-          <para>Note that the expectation is <emphasis>always</emphasis>
-          applied and cannot be overridden without creating a separate
+          <para>Note that the expectation is <emphasis>always</emphasis> applied
+          and cannot be overridden without creating a separate
           <classname>MockMvc</classname> instance.</para>
 
           <para>When JSON response content contains hypermedia links created
@@ -3268,9 +3474,8 @@ mockMvc.perform(post("/persons"))
           <programlisting language="java">mockMvc.perform(get("/people").accept(MediaType.APPLICATION_JSON))
   .andExpect(jsonPath("$.links[?(@.rel == 'self')].href").value("http://localhost:8080/people"));</programlisting>
 
-          <para>When XML response content contains hypermedia links created
-          with <link
-          xl:href="https://github.com/SpringSource/spring-hateoas">Spring
+          <para>When XML response content contains hypermedia links created with
+          <link xl:href="https://github.com/SpringSource/spring-hateoas">Spring
           HATEOAS</link>, the resulting links can be verified:</para>
 
           <programlisting language="java">Map&lt;String, String&gt; ns = Collections.singletonMap("ns", "http://www.w3.org/2005/Atom");
@@ -3289,8 +3494,8 @@ mockMvc.perform(get("/handle").accept(MediaType.APPLICATION_XML))
 
           <para>Registered filters will be invoked through
           <classname>MockFilterChain</classname> from
-          <filename>spring-test</filename> and the last filter will delegates
-          to the <classname>DispatcherServlet</classname>.</para>
+          <filename>spring-test</filename> and the last filter will delegates to
+          the <classname>DispatcherServlet</classname>.</para>
         </section>
 
         <section xml:id="spring-mvc-test-server-resources">
@@ -3321,36 +3526,34 @@ mockServer.expect(requestTo("/greeting")).andRespond(withSuccess("Hello world",
 
 mockServer.verify();</programlisting>
 
-        <para>In the above example,
-        <classname>MockRestServiceServer</classname> -- the central class for
-        client-side REST tests -- configures the
+        <para>In the above example, <classname>MockRestServiceServer</classname>
+        -- the central class for client-side REST tests -- configures the
         <classname>RestTemplate</classname> with a custom
         <interfacename>ClientHttpRequestFactory</interfacename> that asserts
         actual requests against expectations and returns "stub" responses. In
-        this case we expect a single request to "/greeting" and want to return
-        a 200 response with "text/plain" content. We could define as many
+        this case we expect a single request to "/greeting" and want to return a
+        200 response with "text/plain" content. We could define as many
         additional requests and stub responses as necessary.</para>
 
         <para>Once expected requests and stub responses have been defined, the
         <classname>RestTemplate</classname> can be used in client-side code as
         usual. At the end of the tests <literal>mockServer.verify()</literal>
-        can be used to verify that all expected requests were
-        performed.</para>
+        can be used to verify that all expected requests were performed.</para>
 
         <section xml:id="spring-mvc-test-client-static-imports">
           <title>Static Imports</title>
 
-          <para>Just like with server-side tests, the fluent API for
-          client-side tests requires a few static imports. Those are easy to
-          find by searching <emphasis>"MockRest*"</emphasis>. Eclipse users
-          should add <classname>"MockRestRequestMatchers.*"</classname> and
+          <para>Just like with server-side tests, the fluent API for client-side
+          tests requires a few static imports. Those are easy to find by
+          searching <emphasis>"MockRest*"</emphasis>. Eclipse users should add
+          <classname>"MockRestRequestMatchers.*"</classname> and
           <classname>"MockRestResponseCreators.*"</classname> as "favorite
-          static members" in the Eclipse preferences under <emphasis>Java
-          -&gt; Editor -&gt; Content Assist -&gt; Favorites</emphasis>. That
-          allows using content assist after typing the first character of the
-          static method name. Other IDEs (e.g. IntelliJ) may not require any
-          additional configuration. Just check the support for code completion
-          on static members.</para>
+          static members" in the Eclipse preferences under <emphasis>Java -&gt;
+          Editor -&gt; Content Assist -&gt; Favorites</emphasis>. That allows
+          using content assist after typing the first character of the static
+          method name. Other IDEs (e.g. IntelliJ) may not require any additional
+          configuration. Just check the support for code completion on static
+          members.</para>
         </section>
 
         <section xml:id="spring-mvc-test-client-resources">
@@ -3368,11 +3571,10 @@ mockServer.verify();</programlisting>
 
       <para>The PetClinic application, available from the <link
       linkend="new-in-3.0-samples">samples repository</link>, illustrates
-      several features of the <emphasis>Spring TestContext
-      Framework</emphasis> in a JUnit 4.5+ environment. Most test
-      functionality is included in the
-      <classname>AbstractClinicTests</classname>, for which a partial listing
-      is shown below:</para>
+      several features of the <emphasis>Spring TestContext Framework</emphasis>
+      in a JUnit 4.5+ environment. Most test functionality is included in the
+      <classname>AbstractClinicTests</classname>, for which a partial listing is
+      shown below:</para>
 
       <programlisting language="java">import static org.junit.Assert.assertEquals;
 <lineannotation>// import ...</lineannotation>
@@ -3439,10 +3641,9 @@ public abstract class AbstractClinicTests <emphasis role="bold">extends Abstract
 
       <para>The PetClinic application supports three data access technologies:
       JDBC, Hibernate, and JPA. By declaring
-      <interfacename>@ContextConfiguration</interfacename> without any
-      specific resource locations, the
-      <classname>AbstractClinicTests</classname> class will have its
-      application context loaded from the default location,
+      <interfacename>@ContextConfiguration</interfacename> without any specific
+      resource locations, the <classname>AbstractClinicTests</classname> class
+      will have its application context loaded from the default location,
       <literal>AbstractClinicTests-context.xml</literal>, which declares a
       common <classname>DataSource</classname>. Subclasses specify additional
       context locations that must declare a
@@ -3451,8 +3652,8 @@ public abstract class AbstractClinicTests <emphasis role="bold">extends Abstract
 
       <para>For example, the Hibernate implementation of the PetClinic tests
       contains the following implementation. For this example,
-      <classname>HibernateClinicTests</classname> does not contain a single
-      line of code: we only need to declare
+      <classname>HibernateClinicTests</classname> does not contain a single line
+      of code: we only need to declare
       <interfacename>@ContextConfiguration</interfacename>, and the tests are
       inherited from <classname>AbstractClinicTests</classname>. Because
       <interfacename>@ContextConfiguration</interfacename> is declared without
@@ -3474,8 +3675,8 @@ public class HibernateClinicTests extends AbstractClinicTests { }
       typically specified in a common base class for all application-specific
       integration tests. Such a base class may also add useful instance
       variables  populated by Dependency Injection, naturally  such as a
-      <classname>SessionFactory</classname> in the case of an application
-      using Hibernate.</para>
+      <classname>SessionFactory</classname> in the case of an application using
+      Hibernate.</para>
 
       <para>As far as possible, you should have exactly the same Spring
       configuration files in your integration tests as in the deployed
@@ -3491,12 +3692,11 @@ public class HibernateClinicTests extends AbstractClinicTests { }
       combination like the Commons DBCP <classname>BasicDataSource</classname>
       and <classname>DataSourceTransactionManager</classname> or
       <classname>HibernateTransactionManager</classname> for them. You can
-      factor out this variant behavior into a single XML file, having the
-      choice between application server and a 'local' configuration separated
-      from all other configuration, which will not vary between the test and
-      production environments. In addition, it is advisable to use properties
-      files for connection settings. See the PetClinic application for an
-      example.</para>
+      factor out this variant behavior into a single XML file, having the choice
+      between application server and a 'local' configuration separated from all
+      other configuration, which will not vary between the test and production
+      environments. In addition, it is advisable to use properties files for
+      connection settings. See the PetClinic application for an example.</para>
     </section>
   </section>
 
@@ -3522,8 +3722,8 @@ public class HibernateClinicTests extends AbstractClinicTests { }
       <listitem>
         <para><link
         xl:href="http://www.mockobjects.com/">MockObjects.com</link>: Web site
-        dedicated to mock objects, a technique for improving the design of
-        code within test-driven development.</para>
+        dedicated to mock objects, a technique for improving the design of code
+        within test-driven development.</para>
       </listitem>
 
       <listitem>
@@ -3533,16 +3733,15 @@ public class HibernateClinicTests extends AbstractClinicTests { }
 
       <listitem>
         <para><link xl:href="http://www.easymock.org/">EasyMock</link>: Java
-        library <quote> <emphasis>that provides Mock Objects for interfaces
-        (and objects through the class extension) by generating them on the
-        fly using Java's proxy mechanism.</emphasis> </quote> Used by the
-        Spring Framework in its test suite.</para>
+        library <quote> <emphasis>that provides Mock Objects for interfaces (and
+        objects through the class extension) by generating them on the fly using
+        Java's proxy mechanism.</emphasis> </quote> Used by the Spring Framework
+        in its test suite.</para>
       </listitem>
 
       <listitem>
         <para><link xl:href="http://www.jmock.org/">JMock</link>: Library that
-        supports test-driven development of Java code with mock
-        objects.</para>
+        supports test-driven development of Java code with mock objects.</para>
       </listitem>
 
       <listitem>
diff --git a/src/test/java/org/springframework/aop/config/AopNamespaceHandlerScopeIntegrationTests.java b/src/test/java/org/springframework/aop/config/AopNamespaceHandlerScopeIntegrationTests.java
index 8a3c17862757..067a33516628 100644
--- a/src/test/java/org/springframework/aop/config/AopNamespaceHandlerScopeIntegrationTests.java
+++ b/src/test/java/org/springframework/aop/config/AopNamespaceHandlerScopeIntegrationTests.java
@@ -41,7 +41,7 @@
  * Integration tests for scoped proxy use in conjunction with aop: namespace.
  * Deemed an integration test because .web mocks and application contexts are required.
  *
- * @see org.springframework.aop.config.AopNamespaceHandlerTests;
+ * @see org.springframework.aop.config.AopNamespaceHandlerTests
  *
  * @author Rob Harrop
  * @author Juergen Hoeller
diff --git a/src/test/java/org/springframework/aop/framework/autoproxy/AdvisorAutoProxyCreatorIntegrationTests.java b/src/test/java/org/springframework/aop/framework/autoproxy/AdvisorAutoProxyCreatorIntegrationTests.java
index d2fbb3e1e06c..a972be2d97fe 100644
--- a/src/test/java/org/springframework/aop/framework/autoproxy/AdvisorAutoProxyCreatorIntegrationTests.java
+++ b/src/test/java/org/springframework/aop/framework/autoproxy/AdvisorAutoProxyCreatorIntegrationTests.java
@@ -44,7 +44,7 @@
  * Integration tests for auto proxy creation by advisor recognition working in
  * conjunction with transaction managment resources.
  *
- * @see org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests;
+ * @see org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTests
  *
  * @author Rod Johnson
  * @author Chris Beams
diff --git a/src/test/java/org/springframework/context/annotation/jsr330/ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests.java b/src/test/java/org/springframework/context/annotation/jsr330/ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests.java
index b213a2a4e0f8..5f5938ed3641 100644
--- a/src/test/java/org/springframework/context/annotation/jsr330/ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests.java
+++ b/src/test/java/org/springframework/context/annotation/jsr330/ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2012 the original author or authors.
+ * Copyright 2002-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -86,6 +86,7 @@ public void tearDown() throws Exception {
 	public void testPrototype() {
 		ApplicationContext context = createContext(ScopedProxyMode.NO);
 		ScopedTestBean bean = (ScopedTestBean) context.getBean("prototype");
+		assertNotNull(bean);
 		assertTrue(context.isPrototype("prototype"));
 		assertFalse(context.isSingleton("prototype"));
 	}
diff --git a/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests.java b/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests.java
index aca10a3fb264..8468024f9947 100644
--- a/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests.java
+++ b/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests.java
@@ -16,14 +16,6 @@
 
 package org.springframework.scheduling.annotation;
 
-import static org.easymock.EasyMock.createMock;
-import static org.easymock.EasyMock.replay;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.Matchers.greaterThan;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Before;
@@ -43,6 +35,10 @@
 import org.springframework.transaction.annotation.EnableTransactionManagement;
 import org.springframework.transaction.annotation.Transactional;
 
+import static org.hamcrest.Matchers.*;
+import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.*;
+
 /**
  * Integration tests cornering bug SPR-8651, which revealed that @Scheduled methods may
  * not work well with beans that have already been proxied for other reasons such
@@ -81,7 +77,7 @@ public void succeedsWhenSubclassProxyAndScheduledMethodNotPresentOnInterface() t
 
 		MyRepository repository = ctx.getBean(MyRepository.class);
 		CallCountingTransactionManager txManager = ctx.getBean(CallCountingTransactionManager.class);
-		assertThat("repository is not a proxy", AopUtils.isAopProxy(repository), is(true));
+		assertThat("repository is not a proxy", AopUtils.isAopProxy(repository), equalTo(true));
 		assertThat("@Scheduled method never called", repository.getInvocationCount(), greaterThan(0));
 		assertThat("no transactions were committed", txManager.commits, greaterThan(0));
 	}
@@ -142,8 +138,7 @@ public PlatformTransactionManager txManager() {
 
 		@Bean
 		public PersistenceExceptionTranslator peTranslator() {
-			PersistenceExceptionTranslator txlator = createMock(PersistenceExceptionTranslator.class);
-			replay(txlator);
+			PersistenceExceptionTranslator txlator = mock(PersistenceExceptionTranslator.class);
 			return txlator;
 		}
 	}