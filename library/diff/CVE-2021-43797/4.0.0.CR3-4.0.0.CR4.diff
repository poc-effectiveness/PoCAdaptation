diff --git a/all/pom.xml b/all/pom.xml
index 9c27411d4e07..86c994080ecc 100644
--- a/all/pom.xml
+++ b/all/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-all</artifactId>
@@ -307,7 +307,7 @@
           <dependency>
             <groupId>${project.groupId}</groupId>
             <artifactId>netty-build</artifactId>
-            <version>10</version>
+            <version>19</version>
           </dependency>
         </dependencies>
       </plugin>
diff --git a/buffer/pom.xml b/buffer/pom.xml
index c45e2a5cbe68..325d0b0df312 100644
--- a/buffer/pom.xml
+++ b/buffer/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-buffer</artifactId>
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
index 0828ab1e0b04..5ad40037ed5a 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
@@ -15,6 +15,7 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.IllegalReferenceCountException;
 import io.netty.util.ResourceLeakDetector;
 
 import java.io.IOException;
@@ -39,7 +40,7 @@ public abstract class AbstractByteBuf implements ByteBuf {
     private int markedReaderIndex;
     private int markedWriterIndex;
 
-    private final int maxCapacity;
+    private int maxCapacity;
 
     private SwappedByteBuf swappedBuf;
 
@@ -50,16 +51,15 @@ protected AbstractByteBuf(int maxCapacity) {
         this.maxCapacity = maxCapacity;
     }
 
-    @Override
-    public BufType type() {
-        return BufType.BYTE;
-    }
-
     @Override
     public int maxCapacity() {
         return maxCapacity;
     }
 
+    protected final void maxCapacity(int maxCapacity) {
+        this.maxCapacity = maxCapacity;
+    }
+
     @Override
     public int readerIndex() {
         return readerIndex;
@@ -221,7 +221,7 @@ public ByteBuf discardSomeReadBytes() {
         return this;
     }
 
-    protected void adjustMarkers(int decrement) {
+    protected final void adjustMarkers(int decrement) {
         int markedReaderIndex = this.markedReaderIndex;
         if (markedReaderIndex <= decrement) {
             this.markedReaderIndex = 0;
@@ -951,6 +951,11 @@ public ByteBuffer[] nioBuffers() {
         return nioBuffers(readerIndex, readableBytes());
     }
 
+    @Override
+    public ByteBuffer nioBuffer(int index, int length) {
+        return internalNioBuffer(index, length).slice();
+    }
+
     @Override
     public String toString(Charset charset) {
         return toString(readerIndex, readableBytes(), charset);
@@ -971,17 +976,17 @@ public String toString(int index, int length, Charset charset) {
             nioBuffer.flip();
         }
 
-        return BufUtil.decodeString(nioBuffer, charset);
+        return ByteBufUtil.decodeString(nioBuffer, charset);
     }
 
     @Override
     public int indexOf(int fromIndex, int toIndex, byte value) {
-        return BufUtil.indexOf(this, fromIndex, toIndex, value);
+        return ByteBufUtil.indexOf(this, fromIndex, toIndex, value);
     }
 
     @Override
     public int indexOf(int fromIndex, int toIndex, ByteBufIndexFinder indexFinder) {
-        return BufUtil.indexOf(this, fromIndex, toIndex, indexFinder);
+        return ByteBufUtil.indexOf(this, fromIndex, toIndex, indexFinder);
     }
 
     @Override
@@ -1027,7 +1032,7 @@ public int bytesBefore(int index, int length,
 
     @Override
     public int hashCode() {
-        return BufUtil.hashCode(this);
+        return ByteBufUtil.hashCode(this);
     }
 
     @Override
@@ -1036,14 +1041,14 @@ public boolean equals(Object o) {
             return true;
         }
         if (o instanceof ByteBuf) {
-            return BufUtil.equals(this, (ByteBuf) o);
+            return ByteBufUtil.equals(this, (ByteBuf) o);
         }
         return false;
     }
 
     @Override
     public int compareTo(ByteBuf that) {
-        return BufUtil.compare(this, that);
+        return ByteBufUtil.compare(this, that);
     }
 
     @Override
@@ -1129,7 +1134,7 @@ protected final void checkReadableBytes(int minimumReadableBytes) {
      */
     protected final void ensureAccessible() {
         if (refCnt() == 0) {
-            throw new IllegalBufferAccessException();
+            throw new IllegalReferenceCountException(0);
         }
     }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
index 4ef5961f558b..13f906f6a630 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
@@ -52,14 +52,4 @@ public final boolean release() {
     public final boolean release(int decrement) {
         return unwrap().release(decrement);
     }
-
-    @Override
-    public final ByteBuf suspendIntermediaryDeallocations() {
-        throw new UnsupportedOperationException("derived");
-    }
-
-    @Override
-    public final ByteBuf resumeIntermediaryDeallocations() {
-        throw new UnsupportedOperationException("derived");
-    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java
deleted file mode 100644
index ec9067239cf1..000000000000
--- a/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.buffer;
-
-import io.netty.util.internal.PlatformDependent;
-
-import java.util.AbstractQueue;
-import java.util.Collection;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-
-/**
- * Abstract base class for {@link MessageBuf} implementations.
- * @param <T>
- */
-public abstract class AbstractMessageBuf<T> extends AbstractQueue<T> implements MessageBuf<T> {
-
-    @SuppressWarnings("rawtypes")
-    private static final AtomicIntegerFieldUpdater<AbstractMessageBuf> refCntUpdater =
-            AtomicIntegerFieldUpdater.newUpdater(AbstractMessageBuf.class, "refCnt");
-
-    private static final long REFCNT_FIELD_OFFSET;
-
-    static {
-        long refCntFieldOffset = -1;
-        try {
-            if (PlatformDependent.hasUnsafe()) {
-                refCntFieldOffset = PlatformDependent.objectFieldOffset(
-                        AbstractMessageBuf.class.getDeclaredField("refCnt"));
-            }
-        } catch (Throwable t) {
-            // Ignored
-        }
-
-        REFCNT_FIELD_OFFSET = refCntFieldOffset;
-    }
-
-    private final int maxCapacity;
-
-    @SuppressWarnings("FieldMayBeFinal")
-    private volatile int refCnt = 1;
-
-    protected AbstractMessageBuf(int maxCapacity) {
-        if (maxCapacity < 0) {
-            throw new IllegalArgumentException("maxCapacity: " + maxCapacity + " (expected: >= 0)");
-        }
-        this.maxCapacity = maxCapacity;
-    }
-
-    @Override
-    public final BufType type() {
-        return BufType.MESSAGE;
-    }
-
-    @Override
-    public final int refCnt() {
-        if (REFCNT_FIELD_OFFSET >= 0) {
-            // Try to do non-volatile read for performance.
-            return PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET);
-        } else {
-            return refCnt;
-        }
-    }
-
-    @Override
-    public MessageBuf<T> retain() {
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
-            }
-            if (refCnt == Integer.MAX_VALUE) {
-                throw new IllegalBufferAccessException("refCnt overflow");
-            }
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt + 1)) {
-                break;
-            }
-        }
-        return this;
-    }
-
-    @Override
-    public MessageBuf<T> retain(int increment) {
-        if (increment <= 0) {
-            throw new IllegalArgumentException("increment: " + increment + " (expected: > 0)");
-        }
-
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
-            }
-            if (refCnt > Integer.MAX_VALUE - increment) {
-                throw new IllegalBufferAccessException("refCnt overflow");
-            }
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt + increment)) {
-                break;
-            }
-        }
-        return this;
-    }
-
-    @Override
-    public final boolean release() {
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
-            }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - 1)) {
-                if (refCnt == 1) {
-                    deallocate();
-                    return true;
-                }
-                return false;
-            }
-        }
-    }
-
-    @Override
-    public final boolean release(int decrement) {
-        if (decrement <= 0) {
-            throw new IllegalArgumentException("decrement: " + decrement + " (expected: > 0)");
-        }
-
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt < decrement) {
-                throw new IllegalBufferAccessException();
-            }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
-                    deallocate();
-                    return true;
-                }
-                return false;
-            }
-        }
-    }
-
-    protected abstract void deallocate();
-
-    @Override
-    public final int maxCapacity() {
-        return maxCapacity;
-    }
-
-    @Override
-    public final boolean isReadable() {
-        return !isEmpty();
-    }
-
-    @Override
-    public final boolean isReadable(int size) {
-        if (size < 0) {
-            throw new IllegalArgumentException("size: " + size + " (expected: >= 0)");
-        }
-        return size() >= size;
-    }
-
-    @Override
-    public final boolean isWritable() {
-        return size() < maxCapacity;
-    }
-
-    @Override
-    public final boolean isWritable(int size) {
-        if (size < 0) {
-            throw new IllegalArgumentException("size: " + size + " (expected: >= 0)");
-        }
-        return size() <= maxCapacity - size;
-    }
-
-    protected final void ensureAccessible() {
-        if (refCnt <= 0) {
-            throw new IllegalBufferAccessException();
-        }
-    }
-
-    @Override
-    public final boolean add(T t) {
-        return super.add(t);
-    }
-
-    @Override
-    public final T remove() {
-        return super.remove();
-    }
-
-    @Override
-    public final T element() {
-        return super.element();
-    }
-
-    @Override
-    public int drainTo(Collection<? super T> c) {
-        ensureAccessible();
-        int cnt = 0;
-        for (;;) {
-            T o = poll();
-            if (o == null) {
-                break;
-            }
-            c.add(o);
-            cnt ++;
-        }
-        return cnt;
-    }
-
-    @Override
-    public int drainTo(Collection<? super T> c, int maxElements) {
-        ensureAccessible();
-        int cnt = 0;
-        while (cnt < maxElements) {
-            T o = poll();
-            if (o == null) {
-                break;
-            }
-            c.add(o);
-            cnt ++;
-        }
-        return cnt;
-    }
-
-    @Override
-    public String toString() {
-        if (refCnt <= 0) {
-            return getClass().getSimpleName() + "(freed)";
-        }
-
-        StringBuilder buf = new StringBuilder();
-        buf.append(getClass().getSimpleName());
-        buf.append("(size: ");
-        buf.append(size());
-        if (maxCapacity != Integer.MAX_VALUE) {
-            buf.append('/');
-            buf.append(maxCapacity);
-        }
-        buf.append(')');
-
-        return buf.toString();
-    }
-}
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index 2558306dbe01..25e237a19e04 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -16,6 +16,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.IllegalReferenceCountException;
 import io.netty.util.internal.PlatformDependent;
 
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
@@ -73,10 +74,10 @@ public ByteBuf retain() {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
+                throw new IllegalReferenceCountException(0, 1);
             }
             if (refCnt == Integer.MAX_VALUE) {
-                throw new IllegalBufferAccessException("refCnt overflow");
+                throw new IllegalReferenceCountException(Integer.MAX_VALUE, 1);
             }
             if (refCntUpdater.compareAndSet(this, refCnt, refCnt + 1)) {
                 break;
@@ -94,10 +95,10 @@ public ByteBuf retain(int increment) {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
+                throw new IllegalReferenceCountException(0, increment);
             }
             if (refCnt > Integer.MAX_VALUE - increment) {
-                throw new IllegalBufferAccessException("refCnt overflow");
+                throw new IllegalReferenceCountException(refCnt, increment);
             }
             if (refCntUpdater.compareAndSet(this, refCnt, refCnt + increment)) {
                 break;
@@ -111,7 +112,7 @@ public final boolean release() {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
+                throw new IllegalReferenceCountException(0, -1);
             }
 
             if (refCntUpdater.compareAndSet(this, refCnt, refCnt - 1)) {
@@ -133,7 +134,7 @@ public final boolean release(int decrement) {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt < decrement) {
-                throw new IllegalBufferAccessException();
+                throw new IllegalReferenceCountException(refCnt, -decrement);
             }
 
             if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
diff --git a/buffer/src/main/java/io/netty/buffer/Buf.java b/buffer/src/main/java/io/netty/buffer/Buf.java
deleted file mode 100644
index 5cf36606e758..000000000000
--- a/buffer/src/main/java/io/netty/buffer/Buf.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.buffer;
-
-/**
- * A buffer to operate on
- */
-public interface Buf extends ReferenceCounted {
-    /**
-     * The BufType which will be handled by the Buf implementation
-     */
-    BufType type();
-
-    /**
-     * Returns the maximum allowed capacity of this buffer.
-     */
-    int maxCapacity();
-
-    /**
-     * Returns {@code true} if and only if this buffer contains at least one readable element.
-     */
-    boolean isReadable();
-
-    /**
-     * Returns {@code true} if and only if this buffer contains equal to or more than the specified number of elements.
-     */
-    boolean isReadable(int size);
-
-    /**
-     * Returns {@code true} if and only if this buffer has enough room to allow writing one element.
-     */
-    boolean isWritable();
-
-    /**
-     * Returns {@code true} if and only if this buffer has enough room to allow writing the specified number of
-     * elements.
-     */
-    boolean isWritable(int size);
-
-    @Override
-    Buf retain();
-
-    @Override
-    Buf retain(int increment);
-}
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBuf.java b/buffer/src/main/java/io/netty/buffer/ByteBuf.java
index ce0c68ea7145..9062c82e2de9 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java
@@ -15,6 +15,8 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.ReferenceCounted;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -227,7 +229,7 @@
  * Please refer to {@link ByteBufInputStream} and
  * {@link ByteBufOutputStream}.
  */
-public interface ByteBuf extends Buf, Comparable<ByteBuf> {
+public interface ByteBuf extends ReferenceCounted, Comparable<ByteBuf> {
 
     /**
      * Returns the number of bytes (octets) this buffer can contain.
@@ -248,7 +250,6 @@ public interface ByteBuf extends Buf, Comparable<ByteBuf> {
      * {@link #ensureWritable(int)}, those methods will raise an
      * {@link IllegalArgumentException}.
      */
-    @Override
     int maxCapacity();
 
     /**
@@ -391,9 +392,13 @@ public interface ByteBuf extends Buf, Comparable<ByteBuf> {
      * if and only if {@code (this.writerIndex - this.readerIndex)} is greater
      * than {@code 0}.
      */
-    @Override
     boolean isReadable();
 
+    /**
+     * Returns {@code true} if and only if this buffer contains equal to or more than the specified number of elements.
+     */
+    boolean isReadable(int size);
+
     /**
      * @deprecated Use {@link #isReadable()} or {@link #isReadable(int)} instead.
      */
@@ -405,9 +410,14 @@ public interface ByteBuf extends Buf, Comparable<ByteBuf> {
      * if and only if {@code (this.capacity - this.writerIndex)} is greater
      * than {@code 0}.
      */
-    @Override
     boolean isWritable();
 
+    /**
+     * Returns {@code true} if and only if this buffer has enough room to allow writing the specified number of
+     * elements.
+     */
+    boolean isWritable(int size);
+
     /**
      * @deprecated Use {@link #isWritable()} or {@link #isWritable(int)} instead.
      */
@@ -1776,6 +1786,11 @@ public interface ByteBuf extends Buf, Comparable<ByteBuf> {
      */
     ByteBuffer nioBuffer(int index, int length);
 
+    /**
+     * Internal use only: Exposes the internal NIO buffer.
+     */
+    ByteBuffer internalNioBuffer(int index, int length);
+
     /**
      * Exposes this buffer's readable bytes as an NIO {@link ByteBuffer}'s.  The returned buffer
      * shares the content with this buffer, while changing the position and limit of the returned
@@ -1869,23 +1884,6 @@ public interface ByteBuf extends Buf, Comparable<ByteBuf> {
      */
     String toString(int index, int length, Charset charset);
 
-    /**
-     * Suspends the intermediary deallocation of the internal memory block of this buffer until asked via
-     * {@link #resumeIntermediaryDeallocations()}. An intermediary deallocation is usually made when the capacity of
-     * a buffer changes.
-     *
-     * @throws UnsupportedOperationException if this buffer is derived
-     */
-    ByteBuf suspendIntermediaryDeallocations();
-
-    /**
-     * Resumes the intermediary deallocation of the internal memory block of this buffer, suspended by
-     * {@link #suspendIntermediaryDeallocations()}.
-     *
-     * @throws UnsupportedOperationException if this buffer is derived
-     */
-    ByteBuf resumeIntermediaryDeallocations();
-
     /**
      * Returns a hash code which was calculated from the content of this
      * buffer.  If there's a byte array which is
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
index b4a506deb5a6..4c6fbb3fcbd8 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
@@ -15,6 +15,8 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.ReferenceCounted;
+
 /**
  * A packet which is send or receive.
  */
diff --git a/buffer/src/main/java/io/netty/buffer/BufUtil.java b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
similarity index 94%
rename from buffer/src/main/java/io/netty/buffer/BufUtil.java
rename to buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
index b65131638778..353cce8b14d6 100644
--- a/buffer/src/main/java/io/netty/buffer/BufUtil.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
@@ -16,6 +16,7 @@
 package io.netty.buffer;
 
 import io.netty.util.CharsetUtil;
+import io.netty.util.ReferenceCounted;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -25,13 +26,11 @@
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CoderResult;
-import java.util.Iterator;
 
 /**
- * A collection of utility methods that is related with handling {@link ByteBuf}, {@link MessageBuf}, and their
- * elements.
+ * A collection of utility methods that is related with handling {@link ByteBuf}.
  */
-public final class BufUtil {
+public final class ByteBufUtil {
 
     private static final char[] HEXDUMP_TABLE = new char[256 * 4];
 
@@ -418,29 +417,5 @@ static String decodeString(ByteBuffer src, Charset charset) {
         return dst.flip().toString();
     }
 
-    /**
-     * Return the content of the given {@link MessageBuf} as string representation.
-     */
-    public static String contentToString(MessageBuf<?> buf) {
-        if (buf.isEmpty()) {
-            return "[]";
-        }
-        Iterator<?> it = buf.iterator();
-        StringBuilder sb = new StringBuilder();
-        sb.append('[');
-        while (it.hasNext()) {
-            Object msg = it.next();
-            if (msg == buf) {
-                sb.append('(' + buf.getClass().getSimpleName() + ')');
-            } else {
-                sb.append(msg);
-            }
-            if (it.hasNext()) {
-                sb.append(", ");
-            }
-        }
-        return sb.append(']').toString();
-    }
-
-    private BufUtil() { }
+    private ByteBufUtil() { }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
index 483390bd3356..f39a50608f26 100644
--- a/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
@@ -387,12 +387,6 @@ public interface CompositeByteBuf extends ByteBuf, Iterable<ByteBuf> {
     @Override
     CompositeByteBuf writeZero(int length);
 
-    @Override
-    CompositeByteBuf suspendIntermediaryDeallocations();
-
-    @Override
-    CompositeByteBuf resumeIntermediaryDeallocations();
-
     @Override
     CompositeByteBuf retain(int increment);
 
diff --git a/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
index 23b13116c7ad..51314a63a76f 100644
--- a/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
+++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
@@ -15,6 +15,8 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.IllegalReferenceCountException;
+
 /**
  * Default implementation of a {@link ByteBufHolder} that holds it's data in a {@link ByteBuf}.
  *
@@ -33,7 +35,7 @@ public DefaultByteBufHolder(ByteBuf data) {
     @Override
     public ByteBuf content() {
         if (data.refCnt() <= 0) {
-            throw new IllegalBufferAccessException();
+            throw new IllegalReferenceCountException(data.refCnt());
         }
         return data;
     }
diff --git a/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java
index 49dc661d29a1..960d5c5b8767 100644
--- a/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java
@@ -26,14 +26,12 @@
 import java.nio.ByteOrder;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
-import java.util.Queue;
 
 
 /**
@@ -50,7 +48,6 @@ public class DefaultCompositeByteBuf extends AbstractReferenceCountedByteBuf imp
     private final int maxNumComponents;
 
     private boolean freed;
-    private Queue<ByteBuf> suspendedDeallocations;
 
     public DefaultCompositeByteBuf(ByteBufAllocator alloc, boolean direct, int maxNumComponents) {
         super(Integer.MAX_VALUE);
@@ -979,13 +976,24 @@ private Component findComponent(int offset) {
 
     @Override
     public int nioBufferCount() {
-        return components.size();
+        if (components.size() == 1) {
+            return components.get(0).buf.nioBufferCount();
+        } else {
+            int count = 0;
+            int componentsCount = components.size();
+            //noinspection ForLoopReplaceableByForEach
+            for (int i = 0; i < componentsCount; i++) {
+                Component c = components.get(i);
+                count += c.buf.nioBufferCount();
+            }
+            return count;
+        }
     }
 
     @Override
-    public ByteBuffer nioBuffer(int index, int length) {
+    public ByteBuffer internalNioBuffer(int index, int length) {
         if (components.size() == 1) {
-            return components.get(0).buf.nioBuffer(index, length);
+            return components.get(0).buf.internalNioBuffer(index, length);
         }
         throw new UnsupportedOperationException();
     }
@@ -1202,11 +1210,7 @@ private final class Component {
 
         void freeIfNecessary() {
             // Unwrap so that we can free slices, too.
-            if (suspendedDeallocations == null) {
-                buf.release(); // We should not get a NPE here. If so, it must be a bug.
-            } else {
-                suspendedDeallocations.add(buf);
-            }
+            buf.release(); // We should not get a NPE here. If so, it must be a bug.
         }
     }
 
@@ -1457,7 +1461,6 @@ protected void deallocate() {
         }
 
         freed = true;
-        resumeIntermediaryDeallocations();
         for (Component c: components) {
             c.freeIfNecessary();
         }
@@ -1465,30 +1468,6 @@ protected void deallocate() {
         leak.close();
     }
 
-    @Override
-    public CompositeByteBuf suspendIntermediaryDeallocations() {
-        ensureAccessible();
-        if (suspendedDeallocations == null) {
-            suspendedDeallocations = new ArrayDeque<ByteBuf>(2);
-        }
-        return this;
-    }
-
-    @Override
-    public CompositeByteBuf resumeIntermediaryDeallocations() {
-        if (suspendedDeallocations == null) {
-            return this;
-        }
-
-        Queue<ByteBuf> suspendedDeallocations = this.suspendedDeallocations;
-        this.suspendedDeallocations = null;
-
-        for (ByteBuf buf: suspendedDeallocations) {
-            buf.release();
-        }
-        return this;
-    }
-
     @Override
     public ByteBuf unwrap() {
         return null;
diff --git a/buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java b/buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java
deleted file mode 100644
index 300b3d46b1a7..000000000000
--- a/buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java
+++ /dev/null
@@ -1,337 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-/*
- * Written by Josh Bloch of Google Inc. and released to the public domain,
- * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
- */
-package io.netty.buffer;
-
-import java.lang.reflect.Array;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-
-/**
- * Default {@link MessageBuf} implementation.
- *
- * You should use {@link Unpooled#messageBuffer()} to create an instance
- *
- */
-public class DefaultMessageBuf<T> extends AbstractMessageBuf<T> {
-
-    private static final int MIN_INITIAL_CAPACITY = 8;
-    private static final Object[] PLACEHOLDER = new Object[2];
-
-    private T[] elements;
-    private int head;
-    private int tail;
-
-    protected DefaultMessageBuf() {
-        this(MIN_INITIAL_CAPACITY << 1);
-    }
-
-    protected DefaultMessageBuf(int initialCapacity) {
-        this(initialCapacity, Integer.MAX_VALUE);
-    }
-
-    protected DefaultMessageBuf(int initialCapacity, int maxCapacity) {
-        super(maxCapacity);
-
-        if (initialCapacity < 0) {
-            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: >= 0)");
-        }
-        if (maxCapacity < initialCapacity) {
-            throw new IllegalArgumentException(
-                    "maxCapacity: " + maxCapacity + " (expected: >= initialCapacity(" + initialCapacity + ')');
-        }
-
-        // Find the best power of two to hold elements.
-        // Tests "<=" because arrays aren't kept full.
-        if (initialCapacity >= MIN_INITIAL_CAPACITY) {
-            initialCapacity |= initialCapacity >>>  1;
-            initialCapacity |= initialCapacity >>>  2;
-            initialCapacity |= initialCapacity >>>  4;
-            initialCapacity |= initialCapacity >>>  8;
-            initialCapacity |= initialCapacity >>> 16;
-            initialCapacity ++;
-
-            if (initialCapacity < 0) {  // Too many elements, must back off
-                initialCapacity >>>= 1; // Good luck allocating 2 ^ 30 elements
-            }
-        } else {
-            initialCapacity = MIN_INITIAL_CAPACITY;
-        }
-
-        elements = cast(new Object[initialCapacity]);
-    }
-
-    @Override
-    protected void deallocate() {
-        head = 0;
-        tail = 0;
-        elements = cast(PLACEHOLDER);
-    }
-
-    @Override
-    public boolean offer(T e) {
-        if (e == null) {
-            throw new NullPointerException();
-        }
-
-        ensureAccessible();
-        if (!isWritable()) {
-            return false;
-        }
-
-        elements[tail] = e;
-        if ((tail = tail + 1 & elements.length - 1) == head) {
-            doubleCapacity();
-        }
-
-        return true;
-    }
-
-    private void doubleCapacity() {
-        assert head == tail;
-
-        int p = head;
-        int n = elements.length;
-        int r = n - p; // number of elements to the right of p
-        int newCapacity = n << 1;
-        if (newCapacity < 0) {
-            throw new IllegalStateException("Sorry, deque too big");
-        }
-        Object[] a = new Object[newCapacity];
-        System.arraycopy(elements, p, a, 0, r);
-        System.arraycopy(elements, 0, a, r, p);
-        elements = cast(a);
-        head = 0;
-        tail = n;
-    }
-
-    @Override
-    public T poll() {
-        ensureAccessible();
-        int h = head;
-        T result = elements[h]; // Element is null if deque empty
-        if (result == null) {
-            return null;
-        }
-        elements[h] = null;     // Must null out slot
-        head = h + 1 & elements.length - 1;
-        return result;
-    }
-
-    @Override
-    public T peek() {
-        ensureAccessible();
-        return elements[head]; // elements[head] is null if deque empty
-    }
-
-    @Override
-    public boolean remove(Object o) {
-        if (o == null) {
-            return false;
-        }
-
-        ensureAccessible();
-        int mask = elements.length - 1;
-        int i = head;
-        T x;
-        while ((x = elements[i]) != null) {
-            if (o.equals(x)) {
-                delete(i);
-                return true;
-            }
-            i = i + 1 & mask;
-        }
-        return false;
-    }
-
-    private boolean delete(int i) {
-        assert elements[tail] == null;
-        assert head == tail ? elements[head] == null
-                            : elements[head] != null && elements[tail - 1 & elements.length - 1] != null;
-        assert elements[head - 1 & elements.length - 1] == null;
-
-        final T[] elements = this.elements;
-        final int mask = elements.length - 1;
-        final int h = head;
-        final int t = tail;
-        final int front = i - h & mask;
-        final int back  = t - i & mask;
-
-        // Invariant: head <= i < tail mod circularity
-        if (front >= (t - h & mask)) {
-            throw new ConcurrentModificationException();
-        }
-
-        // Optimize for least element motion
-        if (front < back) {
-            if (h <= i) {
-                System.arraycopy(elements, h, elements, h + 1, front);
-            } else { // Wrap around
-                System.arraycopy(elements, 0, elements, 1, i);
-                elements[0] = elements[mask];
-                System.arraycopy(elements, h, elements, h + 1, mask - h);
-            }
-            elements[h] = null;
-            head = h + 1 & mask;
-            return false;
-        } else {
-            if (i < t) { // Copy the null tail as well
-                System.arraycopy(elements, i + 1, elements, i, back);
-                tail = t - 1;
-            } else { // Wrap around
-                System.arraycopy(elements, i + 1, elements, i, mask - i);
-                elements[mask] = elements[0];
-                System.arraycopy(elements, 1, elements, 0, t);
-                tail = t - 1 & mask;
-            }
-            return true;
-        }
-    }
-
-    @Override
-    public int size() {
-        return tail - head & elements.length - 1;
-    }
-
-    @Override
-    public boolean isEmpty() {
-        return head == tail;
-    }
-
-    @Override
-    public Iterator<T> iterator() {
-        ensureAccessible();
-        return new Itr();
-    }
-
-    @Override
-    public boolean contains(Object o) {
-        if (o == null) {
-            return false;
-        }
-
-        ensureAccessible();
-        final int mask = elements.length - 1;
-        int i = head;
-        Object e;
-        while ((e = elements[i]) != null) {
-            if (o.equals(e)) {
-                return true;
-            }
-            i = i + 1 & mask;
-        }
-
-        return false;
-    }
-
-    @Override
-    public void clear() {
-        ensureAccessible();
-        int head = this.head;
-        int tail = this.tail;
-        if (head != tail) {
-            this.head = this.tail = 0;
-            final int mask = elements.length - 1;
-            int i = head;
-            do {
-                elements[i] = null;
-                i = i + 1 & mask;
-            } while (i != tail);
-        }
-    }
-
-    @Override
-    public Object[] toArray() {
-        ensureAccessible();
-        return copyElements(new Object[size()]);
-    }
-
-    @Override
-    public <T> T[] toArray(T[] a) {
-        ensureAccessible();
-        int size = size();
-        if (a.length < size) {
-            a = cast(Array.newInstance(a.getClass().getComponentType(), size));
-        }
-        copyElements(a);
-        if (a.length > size) {
-            a[size] = null;
-        }
-        return a;
-    }
-
-    private <U> U[] copyElements(U[] a) {
-        if (head < tail) {
-            System.arraycopy(elements, head, cast(a), 0, size());
-        } else if (head > tail) {
-            int headPortionLen = elements.length - head;
-            System.arraycopy(elements, head, cast(a), 0, headPortionLen);
-            System.arraycopy(elements, 0, cast(a), headPortionLen, tail);
-        }
-        return a;
-    }
-
-    @SuppressWarnings({ "unchecked", "SuspiciousArrayCast" })
-    private static <T> T[] cast(Object a) {
-        return (T[]) a;
-    }
-
-    private class Itr implements Iterator<T> {
-        private int cursor = head;
-        private int fence = tail;
-        private int lastRet = -1;
-
-        @Override
-        public boolean hasNext() {
-            ensureAccessible();
-            return cursor != fence;
-        }
-
-        @Override
-        public T next() {
-            ensureAccessible();
-            if (cursor == fence) {
-                throw new NoSuchElementException();
-            }
-            T result = elements[cursor];
-            // This check doesn't catch all possible comodifications,
-            // but does catch the ones that corrupt traversal
-            if (tail != fence || result == null) {
-                throw new ConcurrentModificationException();
-            }
-            lastRet = cursor;
-            cursor = cursor + 1 & elements.length - 1;
-            return result;
-        }
-
-        @Override
-        public void remove() {
-            ensureAccessible();
-            if (lastRet < 0) {
-                throw new IllegalStateException();
-            }
-            if (delete(lastRet)) { // if left-shifted, undo increment in next()
-                cursor = cursor - 1 & elements.length - 1;
-                fence = tail;
-            }
-            lastRet = -1;
-        }
-    }
-}
diff --git a/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
index 93004943ce9a..5727c58376c6 100644
--- a/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
@@ -283,13 +283,13 @@ public int nioBufferCount() {
     }
 
     @Override
-    public ByteBuffer nioBuffer(int index, int length) {
-        return buffer.nioBuffer(index, length);
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        return buffer.nioBuffers(index, length);
     }
 
     @Override
-    public ByteBuffer[] nioBuffers(int index, int length) {
-        return buffer.nioBuffers(index, length);
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        return buffer.internalNioBuffer(index, length);
     }
 }
 
diff --git a/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
index 07745ec1279a..e8924ab0c75b 100644
--- a/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
@@ -760,6 +760,11 @@ public ByteBuffer[] nioBuffers(int index, int length) {
         return nioBuffers();
     }
 
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        return EMPTY_BYTE_BUFFER;
+    }
+
     @Override
     public boolean hasArray() {
         return true;
@@ -800,16 +805,6 @@ public String toString(int index, int length, Charset charset) {
         return toString(charset);
     }
 
-    @Override
-    public ByteBuf suspendIntermediaryDeallocations() {
-        return this;
-    }
-
-    @Override
-    public ByteBuf resumeIntermediaryDeallocations() {
-        return this;
-    }
-
     @Override
     public int hashCode() {
         return 0;
@@ -830,11 +825,6 @@ public String toString() {
         return str;
     }
 
-    @Override
-    public BufType type() {
-        return BufType.BYTE;
-    }
-
     @Override
     public boolean isReadable(int size) {
         checkLength(size);
diff --git a/buffer/src/main/java/io/netty/buffer/FilteredMessageBuf.java b/buffer/src/main/java/io/netty/buffer/FilteredMessageBuf.java
deleted file mode 100644
index 496814db080e..000000000000
--- a/buffer/src/main/java/io/netty/buffer/FilteredMessageBuf.java
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.buffer;
-
-import java.util.Collection;
-import java.util.Iterator;
-
-public abstract class FilteredMessageBuf implements MessageBuf<Object> {
-
-    protected final MessageBuf<Object> buf;
-
-    @SuppressWarnings("unchecked")
-    protected FilteredMessageBuf(MessageBuf<?> buf) {
-        if (buf == null) {
-            throw new NullPointerException("buf");
-        }
-        this.buf = (MessageBuf<Object>) buf;
-    }
-
-    protected abstract Object filter(Object msg);
-
-    @Override
-    public int drainTo(Collection<? super Object> c) {
-        return buf.drainTo(c);
-    }
-
-    @Override
-    public int drainTo(Collection<? super Object> c, int maxElements) {
-        return buf.drainTo(c, maxElements);
-    }
-
-    @Override
-    public BufType type() {
-        return buf.type();
-    }
-
-    @Override
-    public int maxCapacity() {
-        return buf.maxCapacity();
-    }
-
-    @Override
-    public boolean isReadable() {
-        return buf.isReadable();
-    }
-
-    @Override
-    public boolean isReadable(int size) {
-        return buf.isReadable(size);
-    }
-
-    @Override
-    public boolean isWritable() {
-        return buf.isWritable();
-    }
-
-    @Override
-    public boolean isWritable(int size) {
-        return buf.isWritable(size);
-    }
-
-    @Override
-    public boolean add(Object e) {
-        if (e == null) {
-            throw new NullPointerException("e");
-        }
-
-        e = filter(e);
-        ensureNonNull(e);
-
-        return buf.add(e);
-    }
-
-    @Override
-    public boolean offer(Object e) {
-        if (e == null) {
-            throw new NullPointerException("e");
-        }
-
-        e = filter(e);
-        ensureNonNull(e);
-
-        return buf.offer(e);
-    }
-
-    private void ensureNonNull(Object e) {
-        if (e == null) {
-            throw new IllegalStateException(getClass().getSimpleName() + ".filter() returned null");
-        }
-    }
-
-    @Override
-    public Object remove() {
-        return buf.remove();
-    }
-
-    @Override
-    public Object poll() {
-        return buf.poll();
-    }
-
-    @Override
-    public Object element() {
-        return buf.element();
-    }
-
-    @Override
-    public Object peek() {
-        return buf.peek();
-    }
-
-    @Override
-    public int size() {
-        return buf.size();
-    }
-
-    @Override
-    public boolean isEmpty() {
-        return buf.isEmpty();
-    }
-
-    @Override
-    public boolean contains(Object o) {
-        return buf.contains(o);
-    }
-
-    @Override
-    public Iterator<Object> iterator() {
-        return buf.iterator();
-    }
-
-    @Override
-    public Object[] toArray() {
-        return buf.toArray();
-    }
-
-    @Override
-    public <T> T[] toArray(T[] a) {
-        return buf.toArray(a);
-    }
-
-    @Override
-    public boolean remove(Object o) {
-        return buf.remove(o);
-    }
-
-    @Override
-    public boolean containsAll(Collection<?> c) {
-        return buf.containsAll(c);
-    }
-
-    @Override
-    public boolean addAll(Collection<?> c) {
-        int i = 0;
-        boolean added = false;
-        for (Object e: c) {
-            if (e == null) {
-                throw new NullPointerException("c[" + i + ']');
-            }
-
-            e = filter(e);
-            ensureNonNull(e);
-            added |= buf.add(e);
-        }
-        return added;
-    }
-
-    @Override
-    public boolean removeAll(Collection<?> c) {
-        return buf.removeAll(c);
-    }
-
-    @Override
-    public boolean retainAll(Collection<?> c) {
-        return buf.retainAll(c);
-    }
-
-    @Override
-    public void clear() {
-        buf.clear();
-    }
-
-    @Override
-    public int refCnt() {
-        return buf.refCnt();
-    }
-
-    @Override
-    public MessageBuf<Object> retain() {
-        buf.retain();
-        return this;
-    }
-
-    @Override
-    public MessageBuf<Object> retain(int increment) {
-        buf.retain(increment);
-        return this;
-    }
-
-    @Override
-    public boolean release() {
-        return buf.release();
-    }
-
-    @Override
-    public boolean release(int decrement) {
-        return buf.release(decrement);
-    }
-
-    @Override
-    public String toString() {
-        return getClass().getSimpleName() + '(' + buf + ')';
-    }
-}
-
diff --git a/buffer/src/main/java/io/netty/buffer/MessageBuf.java b/buffer/src/main/java/io/netty/buffer/MessageBuf.java
deleted file mode 100644
index e5d47df8e733..000000000000
--- a/buffer/src/main/java/io/netty/buffer/MessageBuf.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.buffer;
-
-import java.util.Collection;
-import java.util.Queue;
-
-/**
- * Buf which operates on messages.
- *
- * @param <T>   the type of the messages that are hold by this {@link MessageBuf}
- */
-public interface MessageBuf<T> extends Buf, Queue<T> {
-
-    /**
-     * Drain the content of the {@link MessageBuf} to the given {@link Collection}.
-     *
-     * @param c         the {@link Collection} to drain the content to
-     * @return number   the number of objects which was transfered
-     */
-    int drainTo(Collection<? super T> c);
-
-    /**
-     * Drain the content of the {@link MessageBuf} to the given {@link Collection}.
-     *
-     * @param c             the {@link Collection} to drain the content to
-     * @param maxElements   the max number of elements to drain
-     * @return number       the number of objects which was transfered
-     */
-    int drainTo(Collection<? super T> c, int maxElements);
-
-    @Override
-    MessageBuf<T> retain(int increment);
-
-    @Override
-    MessageBuf<T> retain();
-}
diff --git a/buffer/src/main/java/io/netty/buffer/PoolArena.java b/buffer/src/main/java/io/netty/buffer/PoolArena.java
index a5d3129195a3..57c4385e9206 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolArena.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java
@@ -345,7 +345,7 @@ protected void destroyChunk(PoolChunk<byte[]> chunk) {
 
         @Override
         protected PooledByteBuf<byte[]> newByteBuf(int maxCapacity) {
-            return new PooledHeapByteBuf(maxCapacity);
+            return PooledHeapByteBuf.newInstance(maxCapacity);
         }
 
         @Override
@@ -385,9 +385,9 @@ protected void destroyChunk(PoolChunk<ByteBuffer> chunk) {
         @Override
         protected PooledByteBuf<ByteBuffer> newByteBuf(int maxCapacity) {
             if (HAS_UNSAFE) {
-                return new PooledUnsafeDirectByteBuf(maxCapacity);
+                return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);
             } else {
-                return new PooledDirectByteBuf(maxCapacity);
+                return PooledDirectByteBuf.newInstance(maxCapacity);
             }
         }
 
diff --git a/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
index 1e67c88c44b4..18f7ef3d32d2 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
@@ -16,16 +16,17 @@
 
 package io.netty.buffer;
 
+import io.netty.util.Recycler;
 import io.netty.util.ResourceLeak;
+import io.netty.util.ResourceLeakDetector;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.util.ArrayDeque;
-import java.util.Queue;
 
 abstract class PooledByteBuf<T> extends AbstractReferenceCountedByteBuf {
 
     private final ResourceLeak leak;
+    private final Recycler.Handle recyclerHandle;
 
     protected PoolChunk<T> chunk;
     protected long handle;
@@ -35,11 +36,11 @@ abstract class PooledByteBuf<T> extends AbstractReferenceCountedByteBuf {
     private int maxLength;
 
     private ByteBuffer tmpNioBuf;
-    private Queue<Allocation<T>> suspendedDeallocations;
 
-    protected PooledByteBuf(int maxCapacity) {
+    protected PooledByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {
         super(maxCapacity);
         leak = leakDetector.open(this);
+        this.recyclerHandle = recyclerHandle;
     }
 
     void init(PoolChunk<T> chunk, long handle, int offset, int length, int maxLength) {
@@ -108,13 +109,7 @@ public final ByteBuf capacity(int newCapacity) {
         }
 
         // Reallocation required.
-        if (suspendedDeallocations == null) {
-            chunk.arena.reallocate(this, newCapacity, true);
-        } else {
-            Allocation<T> old = new Allocation<T>(chunk, handle);
-            chunk.arena.reallocate(this, newCapacity, false);
-            suspendedDeallocations.add(old);
-        }
+        chunk.arena.reallocate(this, newCapacity, true);
         return this;
     }
 
@@ -143,57 +138,33 @@ protected final ByteBuffer internalNioBuffer() {
 
     protected abstract ByteBuffer newInternalNioBuffer(T memory);
 
-    @Override
-    public final ByteBuf suspendIntermediaryDeallocations() {
-        ensureAccessible();
-        if (suspendedDeallocations == null) {
-            suspendedDeallocations = new ArrayDeque<Allocation<T>>(2);
-        }
-        return this;
-    }
-
-    @Override
-    public final ByteBuf resumeIntermediaryDeallocations() {
-        if (suspendedDeallocations == null) {
-            return this;
-        }
-
-        Queue<Allocation<T>> suspendedDeallocations = this.suspendedDeallocations;
-        this.suspendedDeallocations = null;
-
-        if (suspendedDeallocations.isEmpty()) {
-            return this;
-        }
-
-        for (Allocation<T> a: suspendedDeallocations) {
-            a.chunk.arena.free(a.chunk, a.handle);
-        }
-        return this;
-    }
-
     @Override
     protected final void deallocate() {
         if (handle >= 0) {
-            resumeIntermediaryDeallocations();
             final long handle = this.handle;
             this.handle = -1;
             memory = null;
             chunk.arena.free(chunk, handle);
-            leak.close();
+            if (ResourceLeakDetector.ENABLED) {
+                leak.close();
+            } else {
+                recycle();
+            }
         }
     }
 
-    protected final int idx(int index) {
-        return offset + index;
+    @SuppressWarnings("unchecked")
+    private void recycle() {
+        Recycler.Handle recyclerHandle = this.recyclerHandle;
+        if (recyclerHandle != null) {
+            setRefCnt(1);
+            ((Recycler<Object>) recycler()).recycle(this, recyclerHandle);
+        }
     }
 
-    private static final class Allocation<T> {
-        final PoolChunk<T> chunk;
-        final long handle;
+    protected abstract Recycler<?> recycler();
 
-        Allocation(PoolChunk<T> chunk, long handle) {
-            this.chunk = chunk;
-            this.handle = handle;
-        }
+    protected final int idx(int index) {
+        return offset + index;
     }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
index 9f614e8e3e8e..f6c78829f46a 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
@@ -142,7 +142,7 @@ public PooledByteBufAllocator(boolean preferDirect, int nHeapArena, int nDirectA
             heapArenas = null;
         }
 
-        if (nHeapArena > 0) {
+        if (nDirectArena > 0) {
             directArenas = newArenaArray(nDirectArena);
             for (int i = 0; i < directArenas.length; i ++) {
                 directArenas[i] = new PoolArena.DirectArena(this, pageSize, maxOrder, pageShifts, chunkSize);
diff --git a/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
index 588b5935359f..a1a02430c6e2 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java
@@ -16,6 +16,8 @@
 
 package io.netty.buffer;
 
+import io.netty.util.Recycler;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -26,8 +28,21 @@
 
 final class PooledDirectByteBuf extends PooledByteBuf<ByteBuffer> {
 
-    PooledDirectByteBuf(int maxCapacity) {
-        super(maxCapacity);
+    private static final Recycler<PooledDirectByteBuf> RECYCLER = new Recycler<PooledDirectByteBuf>() {
+        @Override
+        protected PooledDirectByteBuf newObject(Handle handle) {
+            return new PooledDirectByteBuf(handle, 0);
+        }
+    };
+
+    static PooledDirectByteBuf newInstance(int maxCapacity) {
+        PooledDirectByteBuf buf = RECYCLER.get();
+        buf.maxCapacity(maxCapacity);
+        return buf;
+    }
+
+    private PooledDirectByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {
+        super(recyclerHandle, maxCapacity);
     }
 
     @Override
@@ -242,15 +257,15 @@ public int nioBufferCount() {
     }
 
     @Override
-    public ByteBuffer nioBuffer(int index, int length) {
-        checkIndex(index, length);
-        index = idx(index);
-        return ((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length)).slice();
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        return new ByteBuffer[] { nioBuffer(index, length) };
     }
 
     @Override
-    public ByteBuffer[] nioBuffers(int index, int length) {
-        return new ByteBuffer[] { nioBuffer(index, length) };
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
+        index = idx(index);
+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
     @Override
@@ -277,4 +292,9 @@ public boolean hasMemoryAddress() {
     public long memoryAddress() {
         throw new UnsupportedOperationException();
     }
+
+    @Override
+    protected Recycler<?> recycler() {
+        return RECYCLER;
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
index 6f2432786ae0..dceca57d4acd 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java
@@ -14,6 +14,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.Recycler;
 import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
@@ -26,8 +27,21 @@
 
 final class PooledHeapByteBuf extends PooledByteBuf<byte[]> {
 
-    PooledHeapByteBuf(int maxCapacity) {
-        super(maxCapacity);
+    private static final Recycler<PooledHeapByteBuf> RECYCLER = new Recycler<PooledHeapByteBuf>() {
+        @Override
+        protected PooledHeapByteBuf newObject(Handle handle) {
+            return new PooledHeapByteBuf(handle, 0);
+        }
+    };
+
+    static PooledHeapByteBuf newInstance(int maxCapacity) {
+        PooledHeapByteBuf buf = RECYCLER.get();
+        buf.maxCapacity(maxCapacity);
+        return buf;
+    }
+
+    private PooledHeapByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {
+        super(recyclerHandle, maxCapacity);
     }
 
     @Override
@@ -218,15 +232,15 @@ public int nioBufferCount() {
     }
 
     @Override
-    public ByteBuffer nioBuffer(int index, int length) {
-        checkIndex(index, length);
-        index = idx(index);
-        return ((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length)).slice();
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        return new ByteBuffer[] { nioBuffer(index, length) };
     }
 
     @Override
-    public ByteBuffer[] nioBuffers(int index, int length) {
-        return new ByteBuffer[] { nioBuffer(index, length) };
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
+        index = idx(index);
+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
     @Override
@@ -258,4 +272,9 @@ public long memoryAddress() {
     protected ByteBuffer newInternalNioBuffer(byte[] memory) {
         return ByteBuffer.wrap(memory);
     }
+
+    @Override
+    protected Recycler<?> recycler() {
+        return RECYCLER;
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
index b1240472bb87..84a83fffdcce 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java
@@ -16,6 +16,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.Recycler;
 import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
@@ -30,10 +31,24 @@
 final class PooledUnsafeDirectByteBuf extends PooledByteBuf<ByteBuffer> {
 
     private static final boolean NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
+
+    private static final Recycler<PooledUnsafeDirectByteBuf> RECYCLER = new Recycler<PooledUnsafeDirectByteBuf>() {
+        @Override
+        protected PooledUnsafeDirectByteBuf newObject(Handle handle) {
+            return new PooledUnsafeDirectByteBuf(handle, 0);
+        }
+    };
+
+    static PooledUnsafeDirectByteBuf newInstance(int maxCapacity) {
+        PooledUnsafeDirectByteBuf buf = RECYCLER.get();
+        buf.maxCapacity(maxCapacity);
+        return buf;
+    }
+
     private long memoryAddress;
 
-    PooledUnsafeDirectByteBuf(int maxCapacity) {
-        super(maxCapacity);
+    private PooledUnsafeDirectByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {
+        super(recyclerHandle, maxCapacity);
     }
 
     @Override
@@ -279,15 +294,15 @@ public int nioBufferCount() {
     }
 
     @Override
-    public ByteBuffer nioBuffer(int index, int length) {
-        checkIndex(index, length);
-        index = idx(index);
-        return ((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length)).slice();
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        return new ByteBuffer[] { nioBuffer(index, length) };
     }
 
     @Override
-    public ByteBuffer[] nioBuffers(int index, int length) {
-        return new ByteBuffer[] { nioBuffer(index, length) };
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
+        index = idx(index);
+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
     @Override
@@ -318,4 +333,9 @@ public long memoryAddress() {
     private long addr(int index) {
         return memoryAddress + index;
     }
+
+    @Override
+    protected Recycler<?> recycler() {
+        return RECYCLER;
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/QueueBackedMessageBuf.java b/buffer/src/main/java/io/netty/buffer/QueueBackedMessageBuf.java
deleted file mode 100644
index 6c193c2a3d42..000000000000
--- a/buffer/src/main/java/io/netty/buffer/QueueBackedMessageBuf.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.buffer;
-
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.Queue;
-
-final class QueueBackedMessageBuf<T> extends AbstractMessageBuf<T> {
-
-    private Queue<T> queue;
-
-    QueueBackedMessageBuf(Queue<T> queue) {
-        super(Integer.MAX_VALUE);
-        if (queue == null) {
-            throw new NullPointerException("queue");
-        }
-        this.queue = queue;
-    }
-
-    @Override
-    public boolean offer(T e) {
-        if (e == null) {
-            throw new NullPointerException("e");
-        }
-        ensureAccessible();
-        return isWritable() && queue.offer(e);
-    }
-
-    @Override
-    public T poll() {
-        ensureAccessible();
-        return queue.poll();
-    }
-
-    @Override
-    public T peek() {
-        ensureAccessible();
-        return queue.peek();
-    }
-
-    @Override
-    public int size() {
-        return queue.size();
-    }
-
-    @Override
-    public boolean isEmpty() {
-        return queue.isEmpty();
-    }
-
-    @Override
-    public boolean contains(Object o) {
-        ensureAccessible();
-        return queue.contains(o);
-    }
-
-    @Override
-    public Iterator<T> iterator() {
-        ensureAccessible();
-        return queue.iterator();
-    }
-
-    @Override
-    public Object[] toArray() {
-        ensureAccessible();
-        return queue.toArray();
-    }
-
-    @Override
-    public <E> E[] toArray(E[] a) {
-        ensureAccessible();
-        return queue.toArray(a);
-    }
-
-    @Override
-    public boolean remove(Object o) {
-        ensureAccessible();
-        return queue.remove(o);
-    }
-
-    @Override
-    public boolean containsAll(Collection<?> c) {
-        ensureAccessible();
-        return queue.containsAll(c);
-    }
-
-    @Override
-    public boolean addAll(Collection<? extends T> c) {
-        ensureAccessible();
-        return isWritable(c.size()) && queue.addAll(c);
-    }
-
-    @Override
-    public boolean removeAll(Collection<?> c) {
-        ensureAccessible();
-        return queue.removeAll(c);
-    }
-
-    @Override
-    public boolean retainAll(Collection<?> c) {
-        ensureAccessible();
-        return queue.retainAll(c);
-    }
-
-    @Override
-    public void clear() {
-        ensureAccessible();
-        queue.clear();
-    }
-
-    @Override
-    protected void deallocate() {
-        for (T e: queue) {
-            BufUtil.release(e);
-        }
-        queue = null;
-    }
-}
diff --git a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
index 20549be5c3da..2041a5484d33 100644
--- a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
@@ -44,6 +44,16 @@ public ReadOnlyByteBuf(ByteBuf buffer) {
         setIndex(buffer.readerIndex(), buffer.writerIndex());
     }
 
+    @Override
+    public boolean isWritable() {
+        return false;
+    }
+
+    @Override
+    public boolean isWritable(int numBytes) {
+        return false;
+    }
+
     @Override
     public ByteBuf unwrap() {
         return buffer;
@@ -280,6 +290,11 @@ public ByteBuffer[] nioBuffers(int index, int length) {
         return buffer.nioBuffers(index, length);
     }
 
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        return buffer.internalNioBuffer(index, length);
+    }
+
     @Override
     public int capacity() {
         return buffer.capacity();
diff --git a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
index dd5345d63ff8..4d1de49f7b1c 100644
--- a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
@@ -278,18 +278,14 @@ public int nioBufferCount() {
     }
 
     @Override
-    public ByteBuffer nioBuffer(int index, int length) {
-        ensureAccessible();
-        if (index == 0 && length == capacity()) {
-            return buffer.duplicate();
-        } else {
-            return ((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length)).slice();
-        }
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        return new ByteBuffer[] { nioBuffer(index, length) };
     }
 
     @Override
-    public ByteBuffer[] nioBuffers(int index, int length) {
-        return new ByteBuffer[] { nioBuffer(index, length) };
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        ensureAccessible();
+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
     }
 
     @Override
@@ -316,14 +312,4 @@ public boolean hasMemoryAddress() {
     public long memoryAddress() {
         throw new UnsupportedOperationException();
     }
-
-    @Override
-    public ByteBuf suspendIntermediaryDeallocations() {
-        return this;
-    }
-
-    @Override
-    public ByteBuf resumeIntermediaryDeallocations() {
-        return this;
-    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
index 10a271eb7acb..81a0fecb7ac9 100644
--- a/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
@@ -267,4 +267,10 @@ public ByteBuffer[] nioBuffers(int index, int length) {
         checkIndex(index, length);
         return buffer.nioBuffers(index + adjustment, length);
     }
+
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
+        return buffer.internalNioBuffer(index + adjustment, length);
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
index a18c4dc1e481..a6624f99494e 100644
--- a/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
@@ -67,11 +67,6 @@ public ByteBufAllocator alloc() {
         return buf.alloc();
     }
 
-    @Override
-    public BufType type() {
-        return BufType.MESSAGE;
-    }
-
     @Override
     public int capacity() {
         return buf.capacity();
@@ -245,7 +240,7 @@ public short getUnsignedByte(int index) {
 
     @Override
     public short getShort(int index) {
-        return BufUtil.swapShort(buf.getShort(index));
+        return ByteBufUtil.swapShort(buf.getShort(index));
     }
 
     @Override
@@ -255,7 +250,7 @@ public int getUnsignedShort(int index) {
 
     @Override
     public int getMedium(int index) {
-        return BufUtil.swapMedium(buf.getMedium(index));
+        return ByteBufUtil.swapMedium(buf.getMedium(index));
     }
 
     @Override
@@ -265,7 +260,7 @@ public int getUnsignedMedium(int index) {
 
     @Override
     public int getInt(int index) {
-        return BufUtil.swapInt(buf.getInt(index));
+        return ByteBufUtil.swapInt(buf.getInt(index));
     }
 
     @Override
@@ -275,7 +270,7 @@ public long getUnsignedInt(int index) {
 
     @Override
     public long getLong(int index) {
-        return BufUtil.swapLong(buf.getLong(index));
+        return ByteBufUtil.swapLong(buf.getLong(index));
     }
 
     @Override
@@ -354,25 +349,25 @@ public ByteBuf setByte(int index, int value) {
 
     @Override
     public ByteBuf setShort(int index, int value) {
-        buf.setShort(index, BufUtil.swapShort((short) value));
+        buf.setShort(index, ByteBufUtil.swapShort((short) value));
         return this;
     }
 
     @Override
     public ByteBuf setMedium(int index, int value) {
-        buf.setMedium(index, BufUtil.swapMedium(value));
+        buf.setMedium(index, ByteBufUtil.swapMedium(value));
         return this;
     }
 
     @Override
     public ByteBuf setInt(int index, int value) {
-        buf.setInt(index, BufUtil.swapInt(value));
+        buf.setInt(index, ByteBufUtil.swapInt(value));
         return this;
     }
 
     @Override
     public ByteBuf setLong(int index, long value) {
-        buf.setLong(index, BufUtil.swapLong(value));
+        buf.setLong(index, ByteBufUtil.swapLong(value));
         return this;
     }
 
@@ -463,7 +458,7 @@ public short readUnsignedByte() {
 
     @Override
     public short readShort() {
-        return BufUtil.swapShort(buf.readShort());
+        return ByteBufUtil.swapShort(buf.readShort());
     }
 
     @Override
@@ -473,7 +468,7 @@ public int readUnsignedShort() {
 
     @Override
     public int readMedium() {
-        return BufUtil.swapMedium(buf.readMedium());
+        return ByteBufUtil.swapMedium(buf.readMedium());
     }
 
     @Override
@@ -483,7 +478,7 @@ public int readUnsignedMedium() {
 
     @Override
     public int readInt() {
-        return BufUtil.swapInt(buf.readInt());
+        return ByteBufUtil.swapInt(buf.readInt());
     }
 
     @Override
@@ -493,7 +488,7 @@ public long readUnsignedInt() {
 
     @Override
     public long readLong() {
-        return BufUtil.swapLong(buf.readLong());
+        return ByteBufUtil.swapLong(buf.readLong());
     }
 
     @Override
@@ -588,25 +583,25 @@ public ByteBuf writeByte(int value) {
 
     @Override
     public ByteBuf writeShort(int value) {
-        buf.writeShort(BufUtil.swapShort((short) value));
+        buf.writeShort(ByteBufUtil.swapShort((short) value));
         return this;
     }
 
     @Override
     public ByteBuf writeMedium(int value) {
-        buf.writeMedium(BufUtil.swapMedium(value));
+        buf.writeMedium(ByteBufUtil.swapMedium(value));
         return this;
     }
 
     @Override
     public ByteBuf writeInt(int value) {
-        buf.writeInt(BufUtil.swapInt(value));
+        buf.writeInt(ByteBufUtil.swapInt(value));
         return this;
     }
 
     @Override
     public ByteBuf writeLong(long value) {
-        buf.writeLong(BufUtil.swapLong(value));
+        buf.writeLong(ByteBufUtil.swapLong(value));
         return this;
     }
 
@@ -760,6 +755,12 @@ public ByteBuffer nioBuffer(int index, int length) {
         return buf.nioBuffer(index, length).order(order);
     }
 
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        // Do not mess with the internal buffer's byte order.
+        return buf.nioBuffer(index, length).order(order);
+    }
+
     @Override
     public ByteBuffer[] nioBuffers() {
         ByteBuffer[] nioBuffers = buf.nioBuffers();
@@ -813,18 +814,6 @@ public String toString(int index, int length, Charset charset) {
         return buf.toString(index, length, charset);
     }
 
-    @Override
-    public ByteBuf suspendIntermediaryDeallocations() {
-        buf.suspendIntermediaryDeallocations();
-        return this;
-    }
-
-    @Override
-    public ByteBuf resumeIntermediaryDeallocations() {
-        buf.resumeIntermediaryDeallocations();
-        return this;
-    }
-
     @Override
     public int refCnt() {
         return buf.refCnt();
@@ -863,14 +852,14 @@ public boolean equals(Object obj) {
             return true;
         }
         if (obj instanceof ByteBuf) {
-            return BufUtil.equals(this, (ByteBuf) obj);
+            return ByteBufUtil.equals(this, (ByteBuf) obj);
         }
         return false;
     }
 
     @Override
     public int compareTo(ByteBuf buffer) {
-        return BufUtil.compare(this, buffer);
+        return ByteBufUtil.compare(this, buffer);
     }
 
     @Override
diff --git a/buffer/src/main/java/io/netty/buffer/Unpooled.java b/buffer/src/main/java/io/netty/buffer/Unpooled.java
index 92ae8d218655..46fce0fc3af7 100644
--- a/buffer/src/main/java/io/netty/buffer/Unpooled.java
+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java
@@ -23,11 +23,10 @@
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Queue;
 
 
 /**
- * Creates a new {@link ByteBuf} or a new {@link MessageBuf} by allocating new space or by wrapping
+ * Creates a new {@link ByteBuf} by allocating new space or by wrapping
  * or copying existing byte arrays, byte buffers and a string.
  *
  * <h3>Use static import</h3>
@@ -94,39 +93,6 @@ public final class Unpooled {
      */
     public static final ByteBuf EMPTY_BUFFER = ALLOC.buffer(0, 0);
 
-    /**
-     * Creates a new {@link MessageBuf} with reasonably small initial capacity, which
-     * expands its capacity boundlessly on demand.
-     */
-    public static <T> MessageBuf<T> messageBuffer() {
-        return new DefaultMessageBuf<T>();
-    }
-
-    /**
-     * Creates a new {@link MessageBuf} with the specified {@code initialCapacity}.
-     */
-    public static <T> MessageBuf<T> messageBuffer(int initialCapacity) {
-        return new DefaultMessageBuf<T>(initialCapacity);
-    }
-
-    /**
-     * Creates a new {@link MessageBuf} with the specified {@code initialCapacity} and
-     * {@code maxCapacity}.
-     */
-    public static <T> MessageBuf<T> messageBuffer(int initialCapacity, int maxCapacity) {
-        return new DefaultMessageBuf<T>(initialCapacity, maxCapacity);
-    }
-
-    /**
-     * Creates a new {@link MessageBuf} which wraps the given {@code queue}.
-     */
-    public static <T> MessageBuf<T> wrappedBuffer(Queue<T> queue) {
-        if (queue instanceof MessageBuf) {
-            return (MessageBuf<T>) queue;
-        }
-        return new QueueBackedMessageBuf<T>(queue);
-    }
-
     /**
      * Creates a new big-endian Java heap buffer with reasonably small initial capacity, which
      * expands its capacity boundlessly on demand.
@@ -681,7 +647,7 @@ public static ByteBuf copiedBuffer(char[] array, int offset, int length, Charset
     }
 
     private static ByteBuf copiedBuffer(CharBuffer buffer, Charset charset) {
-        ByteBuffer dst = BufUtil.encodeString(buffer, charset);
+        ByteBuffer dst = ByteBufUtil.encodeString(buffer, charset);
         ByteBuf result = wrappedBuffer(dst.array());
         result.writerIndex(dst.remaining());
         return result;
diff --git a/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
index b066299297e8..d6ad1994e007 100644
--- a/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java
@@ -26,8 +26,6 @@
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
-import java.util.ArrayDeque;
-import java.util.Queue;
 
 /**
  * A NIO {@link ByteBuffer} based buffer.  It is recommended to use {@link Unpooled#directBuffer(int)}
@@ -43,7 +41,6 @@ public class UnpooledDirectByteBuf extends AbstractReferenceCountedByteBuf {
     private ByteBuffer tmpNioBuf;
     private int capacity;
     private boolean doNotFree;
-    private Queue<ByteBuffer> suspendedDeallocations;
 
     /**
      * Creates a new direct buffer.
@@ -111,11 +108,7 @@ private void setByteBuffer(ByteBuffer buffer) {
             if (doNotFree) {
                 doNotFree = false;
             } else {
-                if (suspendedDeallocations == null) {
-                    PlatformDependent.freeDirectBuffer(oldBuffer);
-                } else {
-                    suspendedDeallocations.add(oldBuffer);
-                }
+                PlatformDependent.freeDirectBuffer(oldBuffer);
             }
         }
 
@@ -477,16 +470,6 @@ public int nioBufferCount() {
         return 1;
     }
 
-    @Override
-    public ByteBuffer nioBuffer(int index, int length) {
-        ensureAccessible();
-        if (index == 0 && length == capacity()) {
-            return buffer.duplicate();
-        } else {
-            return ((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length)).slice();
-        }
-    }
-
     @Override
     public ByteBuffer[] nioBuffers(int index, int length) {
         return new ByteBuffer[] { nioBuffer(index, length) };
@@ -510,6 +493,11 @@ public ByteBuf copy(int index, int length) {
         return new UnpooledDirectByteBuf(alloc(), dst, maxCapacity());
     }
 
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
+    }
+
     private ByteBuffer internalNioBuffer() {
         ByteBuffer tmpNioBuf = this.tmpNioBuf;
         if (tmpNioBuf == null) {
@@ -527,37 +515,12 @@ protected void deallocate() {
 
         this.buffer = null;
 
-        resumeIntermediaryDeallocations();
         if (!doNotFree) {
             PlatformDependent.freeDirectBuffer(buffer);
         }
         leak.close();
     }
 
-    @Override
-    public ByteBuf suspendIntermediaryDeallocations() {
-        ensureAccessible();
-        if (suspendedDeallocations == null) {
-            suspendedDeallocations = new ArrayDeque<ByteBuffer>(2);
-        }
-        return this;
-    }
-
-    @Override
-    public ByteBuf resumeIntermediaryDeallocations() {
-        if (suspendedDeallocations == null) {
-            return this;
-        }
-
-        Queue<ByteBuffer> suspendedDeallocations = this.suspendedDeallocations;
-        this.suspendedDeallocations = null;
-
-        for (ByteBuffer buf: suspendedDeallocations) {
-            PlatformDependent.freeDirectBuffer(buf);
-        }
-        return this;
-    }
-
     @Override
     public ByteBuf unwrap() {
         return null;
diff --git a/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
index affae8f8aabb..2f3b5a6d1199 100644
--- a/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
@@ -256,6 +256,11 @@ public ByteBuffer[] nioBuffers(int index, int length) {
         return new ByteBuffer[] { nioBuffer(index, length) };
     }
 
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
+    }
+
     @Override
     public byte getByte(int index) {
         ensureAccessible();
@@ -417,16 +422,6 @@ protected void deallocate() {
         array = null;
     }
 
-    @Override
-    public ByteBuf suspendIntermediaryDeallocations() {
-        return this;
-    }
-
-    @Override
-    public ByteBuf resumeIntermediaryDeallocations() {
-        return this;
-    }
-
     @Override
     public ByteBuf unwrap() {
         return null;
diff --git a/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
index 8875613271ec..237b4e3b667d 100644
--- a/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java
@@ -26,8 +26,6 @@
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
-import java.util.ArrayDeque;
-import java.util.Queue;
 
 /**
  * A NIO {@link ByteBuffer} based buffer.  It is recommended to use {@link Unpooled#directBuffer(int)}
@@ -46,7 +44,6 @@ public class UnpooledUnsafeDirectByteBuf extends AbstractReferenceCountedByteBuf
     private ByteBuffer tmpNioBuf;
     private int capacity;
     private boolean doNotFree;
-    private Queue<ByteBuffer> suspendedDeallocations;
 
     /**
      * Creates a new direct buffer.
@@ -114,11 +111,7 @@ private void setByteBuffer(ByteBuffer buffer) {
             if (doNotFree) {
                 doNotFree = false;
             } else {
-                if (suspendedDeallocations == null) {
-                    PlatformDependent.freeDirectBuffer(oldBuffer);
-                } else {
-                    suspendedDeallocations.add(oldBuffer);
-                }
+                PlatformDependent.freeDirectBuffer(oldBuffer);
             }
         }
 
@@ -416,16 +409,6 @@ public int nioBufferCount() {
         return 1;
     }
 
-    @Override
-    public ByteBuffer nioBuffer(int index, int length) {
-        ensureAccessible();
-        if (index == 0 && length == capacity()) {
-            return buffer.duplicate();
-        } else {
-            return ((ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length)).slice();
-        }
-    }
-
     @Override
     public ByteBuffer[] nioBuffers(int index, int length) {
         return new ByteBuffer[] { nioBuffer(index, length) };
@@ -442,6 +425,11 @@ public ByteBuf copy(int index, int length) {
         return copy;
     }
 
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        return (ByteBuffer) internalNioBuffer().clear().position(index).limit(index + length);
+    }
+
     private ByteBuffer internalNioBuffer() {
         ByteBuffer tmpNioBuf = this.tmpNioBuf;
         if (tmpNioBuf == null) {
@@ -459,37 +447,12 @@ protected void deallocate() {
 
         this.buffer = null;
 
-        resumeIntermediaryDeallocations();
         if (!doNotFree) {
             PlatformDependent.freeDirectBuffer(buffer);
         }
         leak.close();
     }
 
-    @Override
-    public ByteBuf suspendIntermediaryDeallocations() {
-        ensureAccessible();
-        if (suspendedDeallocations == null) {
-            suspendedDeallocations = new ArrayDeque<ByteBuffer>(2);
-        }
-        return this;
-    }
-
-    @Override
-    public ByteBuf resumeIntermediaryDeallocations() {
-        if (suspendedDeallocations == null) {
-            return this;
-        }
-
-        Queue<ByteBuffer> suspendedDeallocations = this.suspendedDeallocations;
-        this.suspendedDeallocations = null;
-
-        for (ByteBuffer buf: suspendedDeallocations) {
-            PlatformDependent.freeDirectBuffer(buf);
-        }
-        return this;
-    }
-
     @Override
     public ByteBuf unwrap() {
         return null;
diff --git a/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
index fb8a22672276..3dd629525e54 100644
--- a/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
@@ -771,6 +771,11 @@ public ByteBuffer[] nioBuffers(int index, int length) {
         return buf.nioBuffers(index, length);
     }
 
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        return buf.internalNioBuffer(index, length);
+    }
+
     @Override
     public boolean hasArray() {
         return buf.hasArray();
@@ -796,18 +801,6 @@ public String toString(int index, int length, Charset charset) {
         return buf.toString(index, length, charset);
     }
 
-    @Override
-    public ByteBuf suspendIntermediaryDeallocations() {
-        buf.suspendIntermediaryDeallocations();
-        return this;
-    }
-
-    @Override
-    public ByteBuf resumeIntermediaryDeallocations() {
-        buf.resumeIntermediaryDeallocations();
-        return this;
-    }
-
     @Override
     public int hashCode() {
         return buf.hashCode();
@@ -838,11 +831,6 @@ public ByteBuf retain() {
         return this;
     }
 
-    @Override
-    public BufType type() {
-        return buf.type();
-    }
-
     @Override
     public boolean isReadable(int size) {
         return buf.isReadable(size);
diff --git a/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
index 584f96a6b0a4..68fd19c4b3e0 100644
--- a/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
@@ -142,20 +142,20 @@ public void testDiscardReadBytes3() {
         a.writerIndex(a.writerIndex() + 1);
         b.writerIndex(b.writerIndex() + 1);
         assertEquals(a.writerIndex(), b.writerIndex());
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
         // now discard
         a.discardReadBytes();
         b.discardReadBytes();
         assertEquals(a.readerIndex(), b.readerIndex());
         assertEquals(a.writerIndex(), b.writerIndex());
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
         a.resetReaderIndex();
         b.resetReaderIndex();
         assertEquals(a.readerIndex(), b.readerIndex());
         a.resetWriterIndex();
         b.resetWriterIndex();
         assertEquals(a.writerIndex(), b.writerIndex());
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
     }
 
     @Test
@@ -231,7 +231,7 @@ public void testSeveralBuffersEquals() {
         b = freeLater(wrappedBuffer(
                 wrappedBuffer(new byte[] { 1 }).order(order),
                 wrappedBuffer(new byte[] { 2 }).order(order)));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Same content, same firstIndex, short length.
         a = freeLater(wrappedBuffer(new byte[] { 1, 2, 3 }).order(order));
@@ -239,28 +239,28 @@ public void testSeveralBuffersEquals() {
                 wrappedBuffer(new byte[]{1}).order(order),
                 wrappedBuffer(new byte[]{2}).order(order),
                 wrappedBuffer(new byte[]{3}).order(order)));
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Same content, different firstIndex, short length.
         a = freeLater(wrappedBuffer(new byte[] { 1, 2, 3 }).order(order));
         b = freeLater(wrappedBuffer(
                 wrappedBuffer(new byte[] { 0, 1, 2, 3, 4 }, 1, 2).order(order),
                 wrappedBuffer(new byte[] { 0, 1, 2, 3, 4 }, 3, 1).order(order)));
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Different content, same firstIndex, short length.
         a = freeLater(wrappedBuffer(new byte[] { 1, 2, 3 }).order(order));
         b = freeLater(wrappedBuffer(
                 wrappedBuffer(new byte[] { 1, 2 }).order(order),
                 wrappedBuffer(new byte[] { 4 }).order(order)));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Different content, different firstIndex, short length.
         a = freeLater(wrappedBuffer(new byte[] { 1, 2, 3 }).order(order));
         b = freeLater(wrappedBuffer(
                 wrappedBuffer(new byte[] { 0, 1, 2, 4, 5 }, 1, 2).order(order),
                 wrappedBuffer(new byte[] { 0, 1, 2, 4, 5 }, 3, 1).order(order)));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Same content, same firstIndex, long length.
         a = freeLater(wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order));
@@ -268,28 +268,28 @@ public void testSeveralBuffersEquals() {
                 wrappedBuffer(new byte[] { 1, 2, 3 }).order(order),
                 wrappedBuffer(new byte[] { 4, 5, 6 }).order(order),
                 wrappedBuffer(new byte[] { 7, 8, 9, 10 }).order(order)));
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Same content, different firstIndex, long length.
         a = freeLater(wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order));
         b = freeLater(wrappedBuffer(
                 wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 1, 5).order(order),
                 wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 6, 5).order(order)));
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Different content, same firstIndex, long length.
         a = freeLater(wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order));
         b = freeLater(wrappedBuffer(
                 wrappedBuffer(new byte[] { 1, 2, 3, 4, 6 }).order(order),
                 wrappedBuffer(new byte[] { 7, 8, 5, 9, 10 }).order(order)));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Different content, different firstIndex, long length.
         a = freeLater(wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order));
         b = freeLater(wrappedBuffer(
                 wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 6, 7, 8, 5, 9, 10, 11 }, 1, 5).order(order),
                 wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 6, 7, 8, 5, 9, 10, 11 }, 6, 5).order(order)));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
     }
 
     @Test
@@ -345,7 +345,7 @@ public void testWrittenBuffersEquals() {
         // to enable writeBytes
         b.writerIndex(b.writerIndex() - 1);
         b.writeBytes(wrappedBuffer(new byte[] { 2 }).order(order));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Same content, same firstIndex, short length.
         a = wrappedBuffer(new byte[] { 1, 2, 3 }).order(order);
@@ -354,7 +354,7 @@ public void testWrittenBuffersEquals() {
         b.writerIndex(b.writerIndex() - 2);
         b.writeBytes(wrappedBuffer(new byte[] { 2 }).order(order));
         b.writeBytes(wrappedBuffer(new byte[] { 3 }).order(order));
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Same content, different firstIndex, short length.
         a = wrappedBuffer(new byte[] { 1, 2, 3 }).order(order);
@@ -362,7 +362,7 @@ public void testWrittenBuffersEquals() {
         // to enable writeBytes
         b.writerIndex(b.writerIndex() - 1);
         b.writeBytes(wrappedBuffer(new byte[] { 0, 1, 2, 3, 4 }, 3, 1).order(order));
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Different content, same firstIndex, short length.
         a = wrappedBuffer(new byte[] { 1, 2, 3 }).order(order);
@@ -370,7 +370,7 @@ public void testWrittenBuffersEquals() {
         // to enable writeBytes
         b.writerIndex(b.writerIndex() - 1);
         b.writeBytes(wrappedBuffer(new byte[] { 4 }).order(order));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Different content, different firstIndex, short length.
         a = wrappedBuffer(new byte[] { 1, 2, 3 }).order(order);
@@ -378,7 +378,7 @@ public void testWrittenBuffersEquals() {
         // to enable writeBytes
         b.writerIndex(b.writerIndex() - 1);
         b.writeBytes(wrappedBuffer(new byte[] { 0, 1, 2, 4, 5 }, 3, 1).order(order));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Same content, same firstIndex, long length.
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order);
@@ -387,7 +387,7 @@ public void testWrittenBuffersEquals() {
         b.writerIndex(b.writerIndex() - 7);
         b.writeBytes(wrappedBuffer(new byte[] { 4, 5, 6 }).order(order));
         b.writeBytes(wrappedBuffer(new byte[] { 7, 8, 9, 10 }).order(order));
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Same content, different firstIndex, long length.
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order);
@@ -395,7 +395,7 @@ public void testWrittenBuffersEquals() {
         // to enable writeBytes
         b.writerIndex(b.writerIndex() - 5);
         b.writeBytes(wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 6, 5).order(order));
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Different content, same firstIndex, long length.
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order);
@@ -403,7 +403,7 @@ public void testWrittenBuffersEquals() {
         // to enable writeBytes
         b.writerIndex(b.writerIndex() - 5);
         b.writeBytes(wrappedBuffer(new byte[] { 7, 8, 5, 9, 10 }).order(order));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Different content, different firstIndex, long length.
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }).order(order);
@@ -411,7 +411,7 @@ public void testWrittenBuffersEquals() {
         // to enable writeBytes
         b.writerIndex(b.writerIndex() - 5);
         b.writeBytes(wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 6, 7, 8, 5, 9, 10, 11 }, 6, 5).order(order));
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
     }
 
     @Test
diff --git a/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java
index 5fc1d81fa5c8..c944cdd1340e 100644
--- a/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java
@@ -174,4 +174,12 @@ public void shouldRejectSetBytes4() {
     public void shouldRejectSetBytes5() {
         unmodifiableBuffer(EMPTY_BUFFER).setBytes(0, (ByteBuffer) null);
     }
+
+    public void shouldIndicateNotWriteable() {
+        assertFalse(unmodifiableBuffer(buffer(1)).isWritable());
+    }
+
+    public void shouldIndicteNotWritableAnyNumber() {
+        assertFalse(unmodifiableBuffer(buffer(1)).isWritable(1));
+    }
 }
diff --git a/buffer/src/test/java/io/netty/buffer/UnpooledTest.java b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java
index 07859fa680d6..96c1d1c5beab 100644
--- a/buffer/src/test/java/io/netty/buffer/UnpooledTest.java
+++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java
@@ -97,7 +97,7 @@ public void testHashCode() {
         for (Entry<byte[], Integer> e: map.entrySet()) {
             assertEquals(
                     e.getValue().intValue(),
-                    BufUtil.hashCode(wrappedBuffer(e.getKey())));
+                    ByteBufUtil.hashCode(wrappedBuffer(e.getKey())));
         }
     }
 
@@ -108,47 +108,47 @@ public void testEquals() {
         // Different length.
         a = wrappedBuffer(new byte[] { 1  });
         b = wrappedBuffer(new byte[] { 1, 2 });
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Same content, same firstIndex, short length.
         a = wrappedBuffer(new byte[] { 1, 2, 3 });
         b = wrappedBuffer(new byte[] { 1, 2, 3 });
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Same content, different firstIndex, short length.
         a = wrappedBuffer(new byte[] { 1, 2, 3 });
         b = wrappedBuffer(new byte[] { 0, 1, 2, 3, 4 }, 1, 3);
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Different content, same firstIndex, short length.
         a = wrappedBuffer(new byte[] { 1, 2, 3 });
         b = wrappedBuffer(new byte[] { 1, 2, 4 });
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Different content, different firstIndex, short length.
         a = wrappedBuffer(new byte[] { 1, 2, 3 });
         b = wrappedBuffer(new byte[] { 0, 1, 2, 4, 5 }, 1, 3);
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Same content, same firstIndex, long length.
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
         b = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Same content, different firstIndex, long length.
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
         b = wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 1, 10);
-        assertTrue(BufUtil.equals(a, b));
+        assertTrue(ByteBufUtil.equals(a, b));
 
         // Different content, same firstIndex, long length.
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
         b = wrappedBuffer(new byte[] { 1, 2, 3, 4, 6, 7, 8, 5, 9, 10 });
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
 
         // Different content, different firstIndex, long length.
         a = wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });
         b = wrappedBuffer(new byte[] { 0, 1, 2, 3, 4, 6, 7, 8, 5, 9, 10, 11 }, 1, 10);
-        assertFalse(BufUtil.equals(a, b));
+        assertFalse(ByteBufUtil.equals(a, b));
     }
 
     @Test
@@ -174,11 +174,11 @@ public void testCompare() {
         for (int i = 0; i < expected.size(); i ++) {
             for (int j = 0; j < expected.size(); j ++) {
                 if (i == j) {
-                    assertEquals(0, BufUtil.compare(expected.get(i), expected.get(j)));
+                    assertEquals(0, ByteBufUtil.compare(expected.get(i), expected.get(j)));
                 } else if (i < j) {
-                    assertTrue(BufUtil.compare(expected.get(i), expected.get(j)) < 0);
+                    assertTrue(ByteBufUtil.compare(expected.get(i), expected.get(j)) < 0);
                 } else {
-                    assertTrue(BufUtil.compare(expected.get(i), expected.get(j)) > 0);
+                    assertTrue(ByteBufUtil.compare(expected.get(i), expected.get(j)) > 0);
                 }
             }
         }
@@ -217,12 +217,12 @@ public void shouldReturnEmptyBufferWhenLengthIsZero() {
 
     @Test
     public void testCompare2() {
-        assertTrue(BufUtil.compare(
+        assertTrue(ByteBufUtil.compare(
                 wrappedBuffer(new byte[]{(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF}),
                 wrappedBuffer(new byte[]{(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00}))
                 > 0);
 
-        assertTrue(BufUtil.compare(
+        assertTrue(ByteBufUtil.compare(
                 wrappedBuffer(new byte[]{(byte) 0xFF}),
                 wrappedBuffer(new byte[]{(byte) 0x00}))
                 > 0);
@@ -327,14 +327,14 @@ public void testCopiedBuffer() {
 
     @Test
     public void testHexDump() {
-        assertEquals("", BufUtil.hexDump(EMPTY_BUFFER));
+        assertEquals("", ByteBufUtil.hexDump(EMPTY_BUFFER));
 
-        assertEquals("123456", BufUtil.hexDump(wrappedBuffer(
+        assertEquals("123456", ByteBufUtil.hexDump(wrappedBuffer(
                 new byte[]{
                         0x12, 0x34, 0x56
                 })));
 
-        assertEquals("1234567890abcdef", BufUtil.hexDump(wrappedBuffer(
+        assertEquals("1234567890abcdef", ByteBufUtil.hexDump(wrappedBuffer(
                 new byte[]{
                         0x12, 0x34, 0x56, 0x78,
                         (byte) 0x90, (byte) 0xAB, (byte) 0xCD, (byte) 0xEF
@@ -343,8 +343,8 @@ public void testHexDump() {
 
     @Test
     public void testSwapMedium() {
-        assertEquals(0x563412, BufUtil.swapMedium(0x123456));
-        assertEquals(0x80, BufUtil.swapMedium(0x800000));
+        assertEquals(0x563412, ByteBufUtil.swapMedium(0x123456));
+        assertEquals(0x80, ByteBufUtil.swapMedium(0x800000));
     }
 
     @Test
@@ -584,5 +584,6 @@ public void wrappedReadOnlyDirectBuffer() {
         for (int i = 0; i < 12; i++) {
             assertEquals((byte) i, wrapped.readByte());
         }
+        wrapped.release();
     }
 }
diff --git a/codec-http/pom.xml b/codec-http/pom.xml
index f454243bc7ef..13b5e6414f1c 100644
--- a/codec-http/pom.xml
+++ b/codec-http/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-codec-http</artifactId>
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
index 20866881572e..3923302b874a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java
@@ -117,7 +117,7 @@ public static Set<Cookie> decode(String header) {
                 } else if (CookieHeaderNames.EXPIRES.equalsIgnoreCase(name)) {
                     try {
                         long maxAgeMillis =
-                            new HttpHeaderDateFormat().parse(value).getTime() -
+                            HttpHeaderDateFormat.get().parse(value).getTime() -
                             System.currentTimeMillis();
 
                         maxAge = maxAgeMillis / 1000 + (maxAgeMillis % 1000 != 0? 1 : 0);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
index 5e3fc33f030e..fd82d6e5b828 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
@@ -304,10 +304,10 @@ private static String toString(Object value) {
             return value.toString();
         }
         if (value instanceof Date) {
-            return new HttpHeaderDateFormat().format((Date) value);
+            return HttpHeaderDateFormat.get().format((Date) value);
         }
         if (value instanceof Calendar) {
-            return new HttpHeaderDateFormat().format(((Calendar) value).getTime());
+            return HttpHeaderDateFormat.get().format(((Calendar) value).getTime());
         }
         return value.toString();
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
index a91c54efa99a..8d8aef5d3ddc 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java
@@ -16,13 +16,10 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.FilteredMessageBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.CombinedChannelDuplexHandler;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.PrematureChannelClosureException;
 
 import java.util.ArrayDeque;
@@ -44,14 +41,13 @@
  * @see HttpServerCodec
  */
 public final class HttpClientCodec
-        extends CombinedChannelDuplexHandler
-        implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<HttpObject> {
+        extends CombinedChannelDuplexHandler<HttpResponseDecoder, HttpRequestEncoder> {
 
     /** A queue that is used for correlating a request and a response. */
     private final Queue<HttpMethod> queue = new ArrayDeque<HttpMethod>();
 
     /** If true, decoding stops (i.e. pass-through) */
-    private volatile boolean done;
+    private boolean done;
 
     private final AtomicLong requestResponseCounter = new AtomicLong();
     private final boolean failOnMissingResponse;
@@ -66,11 +62,11 @@ public HttpClientCodec() {
     }
 
     public void setSingleDecode(boolean singleDecode) {
-        decoder().setSingleDecode(singleDecode);
+        inboundHandler().setSingleDecode(singleDecode);
     }
 
     public boolean isSingleDecode() {
-        return decoder().isSingleDecode();
+        return inboundHandler().isSingleDecode();
     }
 
     /**
@@ -86,34 +82,11 @@ public HttpClientCodec(
         this.failOnMissingResponse = failOnMissingResponse;
     }
 
-    private Decoder decoder() {
-        return (Decoder) stateHandler();
-    }
-
-    private Encoder encoder() {
-        return (Encoder) operationHandler();
-    }
-
-    @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return decoder().newInboundBuffer(ctx);
-    }
-
-    @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        decoder().discardInboundReadBytes(ctx);
-    }
-
-    @Override
-    public MessageBuf<HttpObject> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return encoder().newOutboundBuffer(ctx);
-    }
-
     private final class Encoder extends HttpRequestEncoder {
 
         @Override
         protected void encode(
-                ChannelHandlerContext ctx, HttpObject msg, ByteBuf out) throws Exception {
+                ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {
             if (msg instanceof HttpRequest && !done) {
                 queue.offer(((HttpRequest) msg).getMethod());
             }
@@ -137,7 +110,7 @@ private final class Decoder extends HttpResponseDecoder {
 
         @Override
         protected void decode(
-                ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {
+                ChannelHandlerContext ctx, ByteBuf buffer, MessageList<Object> out) throws Exception {
             if (done) {
                 int readable = actualReadableBytes();
                 if (readable == 0) {
@@ -147,16 +120,14 @@ protected void decode(
                 }
                 out.add(buffer.readBytes(readable));
             } else {
+                int oldSize = out.size();
+                super.decode(ctx, buffer, out);
                 if (failOnMissingResponse) {
-                    out = new FilteredMessageBuf(out) {
-                        @Override
-                        protected Object filter(Object msg) {
-                            decrement(msg);
-                            return msg;
-                        }
-                    };
+                    int size = out.size();
+                    for (int i = oldSize; i < size; i++) {
+                        decrement(out.get(i));
+                    }
                 }
-                super.decode(ctx, buffer, out);
             }
         }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
index f319f8f58108..5fcef790d0e9 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.util.internal.StringUtil;
@@ -119,7 +119,7 @@ protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws
 
         return new Result(
                 targetContentEncoding,
-                new EmbeddedByteChannel(ZlibCodecFactory.newZlibEncoder(
+                new EmbeddedChannel(ZlibCodecFactory.newZlibEncoder(
                         wrapper, compressionLevel, windowBits, memLevel)));
     }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
index 2d00bf9647ba..5e5ac7368776 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java
@@ -15,21 +15,19 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.MessageList;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.MessageToMessageDecoder;
 
-import java.util.Collections;
-
 /**
  * Decodes the content of the received {@link HttpRequest} and {@link HttpContent}.
  * The original content is replaced with the new content decoded by the
- * {@link EmbeddedByteChannel}, which is created by {@link #newContentDecoder(String)}.
+ * {@link EmbeddedChannel}, which is created by {@link #newContentDecoder(String)}.
  * Once decoding is finished, the value of the <tt>'Content-Encoding'</tt>
  * header is set to the target content encoding, as returned by {@link #getTargetContentEncoding(String)}.
  * Also, the <tt>'Content-Length'</tt> header is updated to the length of the
@@ -47,20 +45,20 @@
  */
 public abstract class HttpContentDecoder extends MessageToMessageDecoder<HttpObject> {
 
-    private EmbeddedByteChannel decoder;
+    private EmbeddedChannel decoder;
     private HttpMessage message;
     private boolean decodeStarted;
     private boolean continueResponse;
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {
         if (msg instanceof HttpResponse && ((HttpResponse) msg).getStatus().code() == 100) {
 
             if (!(msg instanceof LastHttpContent)) {
                 continueResponse = true;
             }
             // 100-continue response must be passed through.
-            out.add(BufUtil.retain(msg));
+            out.add(ByteBufUtil.retain(msg));
             return;
         }
 
@@ -69,7 +67,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
                 continueResponse = false;
             }
             // 100-continue response must be passed through.
-            out.add(BufUtil.retain(msg));
+            out.add(ByteBufUtil.retain(msg));
             return;
         }
 
@@ -117,8 +115,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
                                 HttpHeaders.Names.CONTENT_LENGTH,
                                 Integer.toString(((ByteBufHolder) decoded[1]).content().readableBytes()));
                     }
-
-                    Collections.addAll(out, decoded);
+                    out.add(decoded);
                     return;
                 }
 
@@ -131,7 +128,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
             }
 
             if (decoder != null) {
-                Collections.addAll(out, decodeContent(null, c));
+                out.add(decodeContent(null, c));
             } else {
                 if (c instanceof LastHttpContent) {
                     decodeStarted = false;
@@ -175,15 +172,15 @@ private Object[] decodeContent(HttpMessage header, HttpContent c) {
     }
 
     /**
-     * Returns a new {@link EmbeddedByteChannel} that decodes the HTTP message
+     * Returns a new {@link EmbeddedChannel} that decodes the HTTP message
      * content encoded in the specified <tt>contentEncoding</tt>.
      *
      * @param contentEncoding the value of the {@code "Content-Encoding"} header
-     * @return a new {@link EmbeddedByteChannel} if the specified encoding is supported.
+     * @return a new {@link EmbeddedChannel} if the specified encoding is supported.
      *         {@code null} otherwise (alternatively, you can throw an exception
      *         to block unknown encoding).
      */
-    protected abstract EmbeddedByteChannel newContentDecoder(String contentEncoding) throws Exception;
+    protected abstract EmbeddedChannel newContentDecoder(String contentEncoding) throws Exception;
 
     /**
      * Returns the expected content encoding of the decoded content.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java
index 254a483dae26..e32847764077 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
 
@@ -26,13 +26,13 @@
  */
 public class HttpContentDecompressor extends HttpContentDecoder {
     @Override
-    protected EmbeddedByteChannel newContentDecoder(String contentEncoding) throws Exception {
+    protected EmbeddedChannel newContentDecoder(String contentEncoding) throws Exception {
         if ("gzip".equalsIgnoreCase(contentEncoding) || "x-gzip".equalsIgnoreCase(contentEncoding)) {
-            return new EmbeddedByteChannel(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));
+            return new EmbeddedChannel(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));
         }
         if ("deflate".equalsIgnoreCase(contentEncoding) || "x-deflate".equalsIgnoreCase(contentEncoding)) {
             // To be strict, 'deflate' means ZLIB, but some servers were not implemented correctly.
-            return new EmbeddedByteChannel(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
+            return new EmbeddedChannel(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
         }
 
         // 'identity' or unsupported
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
index d6be9c34c8ac..fb5b46c19a9c 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java
@@ -15,25 +15,24 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.MessageList;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.MessageToMessageCodec;
 import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.handler.codec.http.HttpHeaders.Values;
 
 import java.util.ArrayDeque;
-import java.util.Collections;
 import java.util.Queue;
 
 /**
  * Encodes the content of the outbound {@link HttpResponse} and {@link HttpContent}.
  * The original content is replaced with the new content encoded by the
- * {@link EmbeddedByteChannel}, which is created by {@link #beginEncode(HttpResponse, String)}.
+ * {@link EmbeddedChannel}, which is created by {@link #beginEncode(HttpResponse, String)}.
  * Once encoding is finished, the value of the <tt>'Content-Encoding'</tt> header
  * is set to the target content encoding, as returned by
  * {@link #beginEncode(HttpResponse, String)}.
@@ -62,7 +61,7 @@ private enum State {
 
     private final Queue<String> acceptEncodingQueue = new ArrayDeque<String>();
     private String acceptEncoding;
-    private EmbeddedByteChannel encoder;
+    private EmbeddedChannel encoder;
     private State state = State.AWAIT_HEADERS;
 
     @Override
@@ -71,18 +70,18 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, HttpRequest msg, MessageBuf<Object> out)
+    protected void decode(ChannelHandlerContext ctx, HttpRequest msg, MessageList<Object> out)
             throws Exception {
         String acceptedEncoding = msg.headers().get(HttpHeaders.Names.ACCEPT_ENCODING);
         if (acceptedEncoding == null) {
             acceptedEncoding = HttpHeaders.Values.IDENTITY;
         }
         acceptEncodingQueue.add(acceptedEncoding);
-        out.add(BufUtil.retain(msg));
+        out.add(ByteBufUtil.retain(msg));
     }
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Object> out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {
         final boolean isFull = msg instanceof HttpResponse && msg instanceof LastHttpContent;
         switch (state) {
             case AWAIT_HEADERS: {
@@ -93,7 +92,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
 
                 if (res.getStatus().code() == 100) {
                     if (isFull) {
-                        out.add(BufUtil.retain(res));
+                        out.add(ByteBufUtil.retain(res));
                     } else {
                         out.add(res);
                         // Pass through all following contents.
@@ -114,7 +113,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
                         // Set the content length to 0.
                         res.headers().remove(Names.TRANSFER_ENCODING);
                         res.headers().set(Names.CONTENT_LENGTH, "0");
-                        out.add(BufUtil.retain(res));
+                        out.add(ByteBufUtil.retain(res));
                         break;
                     }
                 }
@@ -128,7 +127,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
                         // As an unchunked response
                         res.headers().remove(Names.TRANSFER_ENCODING);
                         res.headers().set(Names.CONTENT_LENGTH, ((ByteBufHolder) res).content().readableBytes());
-                        out.add(BufUtil.retain(res));
+                        out.add(ByteBufUtil.retain(res));
                     } else {
                         // As a chunked response
                         res.headers().remove(Names.CONTENT_LENGTH);
@@ -165,7 +164,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
             case AWAIT_CONTENT: {
                 ensureContent(msg);
                 HttpContent[] encoded = encodeContent((HttpContent) msg);
-                Collections.addAll(out, encoded);
+                out.add(encoded);
                 if (encoded[encoded.length - 1] instanceof LastHttpContent) {
                     state = State.AWAIT_HEADERS;
                 }
@@ -173,7 +172,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
             }
             case PASS_THROUGH: {
                 ensureContent(msg);
-                out.add(BufUtil.retain(msg));
+                out.add(ByteBufUtil.retain(msg));
                 // Passed through all following contents of the current response.
                 if (msg instanceof LastHttpContent) {
                     state = State.AWAIT_HEADERS;
@@ -235,7 +234,7 @@ private HttpContent[] encodeContent(HttpContent c) {
      *        the value of the {@code "Accept-Encoding"} header
      *
      * @return the result of preparation, which is composed of the determined
-     *         target content encoding and a new {@link EmbeddedByteChannel} that
+     *         target content encoding and a new {@link EmbeddedChannel} that
      *         encodes the content into the target content encoding.
      *         {@code null} if {@code acceptEncoding} is unsupported or rejected
      *         and thus the content should be handled as-is (i.e. no encoding).
@@ -276,7 +275,7 @@ private void finishEncode(ByteBuf out) {
 
     private void fetchEncoderOutput(ByteBuf out) {
         for (;;) {
-            ByteBuf buf = encoder.readOutbound();
+            ByteBuf buf = (ByteBuf) encoder.readOutbound();
             if (buf == null) {
                 break;
             }
@@ -286,9 +285,9 @@ private void fetchEncoderOutput(ByteBuf out) {
 
     public static final class Result {
         private final String targetContentEncoding;
-        private final EmbeddedByteChannel contentEncoder;
+        private final EmbeddedChannel contentEncoder;
 
-        public Result(String targetContentEncoding, EmbeddedByteChannel contentEncoder) {
+        public Result(String targetContentEncoding, EmbeddedChannel contentEncoder) {
             if (targetContentEncoding == null) {
                 throw new NullPointerException("targetContentEncoding");
             }
@@ -304,7 +303,7 @@ public String targetContentEncoding() {
             return targetContentEncoding;
         }
 
-        public EmbeddedByteChannel contentEncoder() {
+        public EmbeddedChannel contentEncoder() {
             return contentEncoder;
         }
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
index 1e22cf63924f..8df847ff410a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java
@@ -37,11 +37,22 @@ final class HttpHeaderDateFormat extends SimpleDateFormat {
     private final SimpleDateFormat format1 = new HttpHeaderDateFormatObsolete1();
     private final SimpleDateFormat format2 = new HttpHeaderDateFormatObsolete2();
 
+    private static ThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal = new ThreadLocal<HttpHeaderDateFormat>() {
+        @Override
+        protected HttpHeaderDateFormat initialValue() {
+            return new HttpHeaderDateFormat();
+        }
+    };
+
+    static HttpHeaderDateFormat get() {
+        return dateFormatThreadLocal.get();
+    }
+
     /**
      * Standard date format<p>
      * Sun, 06 Nov 1994 08:49:37 GMT -> E, d MMM yyyy HH:mm:ss z
      */
-    HttpHeaderDateFormat() {
+    private HttpHeaderDateFormat() {
         super("E, dd MMM yyyy HH:mm:ss z", Locale.ENGLISH);
         setTimeZone(TimeZone.getTimeZone("GMT"));
     }
@@ -66,7 +77,7 @@ private static final class HttpHeaderDateFormatObsolete1 extends SimpleDateForma
         private static final long serialVersionUID = -3178072504225114298L;
 
         HttpHeaderDateFormatObsolete1() {
-            super("E, dd-MMM-y HH:mm:ss z", Locale.ENGLISH);
+            super("E, dd-MMM-yy HH:mm:ss z", Locale.ENGLISH);
             setTimeZone(TimeZone.getTimeZone("GMT"));
         }
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
index f83ee67fb8f8..903c214c34b5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java
@@ -750,7 +750,7 @@ public static Date getDateHeader(HttpMessage message, String name) throws ParseE
         if (value == null) {
             throw new ParseException("header not found: " + name, 0);
         }
-        return new HttpHeaderDateFormat().parse(value);
+        return HttpHeaderDateFormat.get().parse(value);
     }
 
     /**
@@ -768,7 +768,7 @@ public static Date getDateHeader(HttpMessage message, String name, Date defaultV
         }
 
         try {
-            return new HttpHeaderDateFormat().parse(value);
+            return HttpHeaderDateFormat.get().parse(value);
         } catch (ParseException e) {
             return defaultValue;
         }
@@ -782,7 +782,7 @@ public static Date getDateHeader(HttpMessage message, String name, Date defaultV
      */
     public static void setDateHeader(HttpMessage message, String name, Date value) {
         if (value != null) {
-            message.headers().set(name, new HttpHeaderDateFormat().format(value));
+            message.headers().set(name, HttpHeaderDateFormat.get().format(value));
         } else {
             message.headers().set(name, null);
         }
@@ -947,7 +947,7 @@ public static Date getDate(HttpMessage message, Date defaultValue) {
      */
     public static void setDate(HttpMessage message, Date value) {
         if (value != null) {
-            message.headers().set(Names.DATE, new HttpHeaderDateFormat().format(value));
+            message.headers().set(Names.DATE, HttpHeaderDateFormat.get().format(value));
         } else {
             message.headers().set(Names.DATE, null);
         }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
index e46103f0fc04..54d3f318d1b6 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
@@ -15,14 +15,14 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.CompositeByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
@@ -108,7 +108,7 @@ public final void setMaxCumulationBufferComponents(int maxCumulationBufferCompon
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {
         FullHttpMessage currentMessage = this.currentMessage;
 
         if (msg instanceof HttpMessage) {
@@ -129,7 +129,7 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
             if (!m.getDecoderResult().isSuccess()) {
                 removeTransferEncodingChunked(m);
                 this.currentMessage = null;
-                out.add(BufUtil.retain(m));
+                out.add(ByteBufUtil.retain(m));
                 return;
             }
             if (msg instanceof HttpRequest) {
@@ -210,8 +210,30 @@ protected void decode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Obje
         }
     }
 
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        super.channelInactive(ctx);
+
+        // release current message if it is not null as it may be a left-over
+        if (currentMessage != null) {
+            currentMessage.release();
+            currentMessage = null;
+        }
+    }
+
     @Override
     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         this.ctx = ctx;
     }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        super.handlerRemoved(ctx);
+        // release current message if it is not null as it may be a left-over as there is not much more we can do in
+        // this case
+        if (currentMessage != null) {
+            currentMessage.release();
+            currentMessage = null;
+        }
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
index dc4c78c08736..b97852d258c3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
@@ -16,10 +16,10 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
@@ -168,7 +168,7 @@ protected HttpObjectDecoder(
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageList<Object> out) throws Exception {
         switch (state()) {
         case SKIP_CONTROL_CHARS: {
             try {
@@ -206,19 +206,13 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
             }
             if (nextState == State.SKIP_CONTROL_CHARS) {
                 // No content is expected.
-                HttpObject[] parts =  reset();
-                for (HttpObject object: parts) {
-                    out.add(object);
-                }
+                reset(out);
                 return;
             }
             long contentLength = HttpHeaders.getContentLength(message, -1);
             if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {
                 content = Unpooled.EMPTY_BUFFER;
-                HttpObject[] parts =  reset();
-                for (HttpObject object: parts) {
-                    out.add(object);
-                }
+                reset(out);
                 return;
             }
 
@@ -276,10 +270,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
             return;
         }
         case READ_FIXED_LENGTH_CONTENT: {
-            HttpObject[] parts = readFixedLengthContent(buffer);
-            for (HttpObject part: parts) {
-                out.add(part);
-            }
+            readFixedLengthContent(buffer, out);
             return;
         }
         case READ_FIXED_LENGTH_CONTENT_AS_CHUNKS: {
@@ -406,10 +397,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
             LastHttpContent trailer = readTrailingHeaders(buffer);
             if (maxChunkSize == 0) {
                 // Chunked encoding disabled.
-                HttpObject[] parts =  reset();
-                for (HttpObject object: parts) {
-                    out.add(object);
-                }
+                reset(out);
                 return;
             } else {
                 reset();
@@ -432,6 +420,44 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
         }
     }
 
+    @Override
+    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
+        decode(ctx, in, out);
+
+        // Handle the last unfinished message.
+        if (message != null) {
+            // Get the length of the content received so far for the last message.
+            HttpMessage message = this.message;
+            int actualContentLength;
+            if (content != null) {
+                actualContentLength = content.readableBytes();
+            } else {
+                actualContentLength = 0;
+            }
+
+            // Check if the closure of the connection signifies the end of the content.
+            boolean prematureClosure;
+            if (isDecodingRequest()) {
+                // The last request did not wait for a response.
+                prematureClosure = true;
+            } else {
+                // Compare the length of the received content and the 'Content-Length' header.
+                // If the 'Content-Length' header is absent, the length of the content is determined by the end of the
+                // connection, so it is perfectly fine.
+                long expectedContentLength = HttpHeaders.getContentLength(message, -1);
+                prematureClosure = expectedContentLength >= 0 && actualContentLength != expectedContentLength;
+            }
+
+            if (!prematureClosure) {
+                if (actualContentLength == 0) {
+                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);
+                } else {
+                    out.add(new DefaultLastHttpContent(content));
+                }
+            }
+        }
+    }
+
     protected boolean isContentAlwaysEmpty(HttpMessage msg) {
         if (msg instanceof HttpResponse) {
             HttpResponse res = (HttpResponse) msg;
@@ -458,23 +484,30 @@ protected boolean isContentAlwaysEmpty(HttpMessage msg) {
         return false;
     }
 
-    private HttpObject[] reset() {
-        HttpMessage message = this.message;
-        ByteBuf content = this.content;
-        LastHttpContent httpContent;
+    private void reset() {
+        reset(null);
+    }
 
-        if (content == null || !content.isReadable()) {
-            httpContent = LastHttpContent.EMPTY_LAST_CONTENT;
-        } else {
-            httpContent = new DefaultLastHttpContent(content);
+    private void reset(MessageList<Object> out) {
+        if (out != null) {
+            HttpMessage message = this.message;
+            ByteBuf content = this.content;
+            LastHttpContent httpContent;
+
+            if (content == null || !content.isReadable()) {
+                httpContent = LastHttpContent.EMPTY_LAST_CONTENT;
+            } else {
+                httpContent = new DefaultLastHttpContent(content);
+            }
+
+            out.add(message);
+            out.add(httpContent);
         }
 
-        HttpObject[] messages =  { message, httpContent };
-        this.content = null;
-        this.message = null;
+        content = null;
+        message = null;
 
         checkpoint(State.SKIP_CONTROL_CHARS);
-        return messages;
     }
 
     private HttpMessage invalidMessage(Exception cause) {
@@ -506,7 +539,7 @@ private static void skipControlCharacters(ByteBuf buffer) {
         }
     }
 
-    private HttpObject[] readFixedLengthContent(ByteBuf buffer) {
+    private void readFixedLengthContent(ByteBuf buffer, MessageList<Object> out) {
         //we have a content-length so we just read the correct number of bytes
         long length = HttpHeaders.getContentLength(message, -1);
         assert length <= Integer.MAX_VALUE;
@@ -516,14 +549,16 @@ private HttpObject[] readFixedLengthContent(ByteBuf buffer) {
         }
         contentRead += toRead;
         if (length < contentRead) {
-            return new HttpObject[] {message, new DefaultHttpContent(buffer.readBytes(toRead))};
+            out.add(message);
+            out.add(new DefaultHttpContent(buffer.readBytes(toRead)));
+            return;
         }
         if (content == null) {
             content = buffer.readBytes((int) length);
         } else {
             content.writeBytes(buffer, (int) length);
         }
-        return reset();
+        reset(out);
     }
 
     private State readHeaders(ByteBuf buffer) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
index 42932eb45614..970db26f9e0e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java
@@ -17,7 +17,8 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.MessageToByteEncoder;
+import io.netty.channel.MessageList;
+import io.netty.handler.codec.MessageToMessageEncoder;
 import io.netty.util.CharsetUtil;
 
 import java.util.Map;
@@ -38,8 +39,12 @@
  * To implement the encoder of such a derived protocol, extend this class and
  * implement all abstract methods properly.
  */
-public abstract class HttpObjectEncoder<H extends HttpMessage> extends MessageToByteEncoder<HttpObject> {
-
+public abstract class HttpObjectEncoder<H extends HttpMessage> extends MessageToMessageEncoder<HttpObject> {
+    private static final byte[] CRLF = { CR, LF };
+    private static final byte[] ZERO_CRLF = { '0', CR, LF };
+    private static final ByteBuf ZERO_CRLF_CRLF_BUF =
+            unreleasableBuffer(directBuffer(5, 5).writeBytes(ZERO_CRLF).writeBytes(CRLF));
+    private static final byte[] HEADER_SEPARATOR = { COLON, SP};
     private static final int ST_INIT = 0;
     private static final int ST_CONTENT_NON_CHUNK = 1;
     private static final int ST_CONTENT_CHUNK = 2;
@@ -48,7 +53,7 @@ public abstract class HttpObjectEncoder<H extends HttpMessage> extends MessageTo
     private int state = ST_INIT;
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, HttpObject msg, ByteBuf out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {
         if (msg instanceof HttpMessage) {
             if (state != ST_INIT) {
                 throw new IllegalStateException("unexpected message type: " + msg.getClass().getSimpleName());
@@ -57,15 +62,14 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, ByteBuf out) th
             @SuppressWarnings({ "unchecked", "CastConflictsWithInstanceof" })
             H m = (H) msg;
 
+            ByteBuf buf = ctx.alloc().buffer();
             // Encode the message.
-            encodeInitialLine(out, m);
-            encodeHeaders(out, m);
-            out.writeByte(CR);
-            out.writeByte(LF);
-
+            encodeInitialLine(buf, m);
+            encodeHeaders(buf, m.headers());
+            buf.writeBytes(CRLF);
+            out.add(buf);
             state = HttpHeaders.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;
         }
-
         if (msg instanceof HttpContent) {
             if (state == ST_INIT) {
                 throw new IllegalStateException("unexpected message type: " + msg.getClass().getSimpleName());
@@ -77,7 +81,7 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, ByteBuf out) th
 
             if (state == ST_CONTENT_NON_CHUNK) {
                 if (contentLength > 0) {
-                    out.writeBytes(content, content.readerIndex(), content.readableBytes());
+                    out.add(content.retain());
                 }
 
                 if (chunk instanceof LastHttpContent) {
@@ -85,21 +89,27 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, ByteBuf out) th
                 }
             } else if (state == ST_CONTENT_CHUNK) {
                 if (contentLength > 0) {
-                    out.writeBytes(copiedBuffer(Integer.toHexString(contentLength), CharsetUtil.US_ASCII));
-                    out.writeByte(CR);
-                    out.writeByte(LF);
-                    out.writeBytes(content, content.readerIndex(), contentLength);
-                    out.writeByte(CR);
-                    out.writeByte(LF);
+                    byte[] length = Integer.toHexString(contentLength).getBytes(CharsetUtil.US_ASCII);
+                    ByteBuf buf = ctx.alloc().buffer(length.length + 2);
+                    buf.writeBytes(length);
+                    buf.writeBytes(CRLF);
+                    out.add(buf);
+                    out.add(content.retain());
+                    out.add(wrappedBuffer(CRLF));
                 }
 
                 if (chunk instanceof LastHttpContent) {
-                    out.writeByte((byte) '0');
-                    out.writeByte(CR);
-                    out.writeByte(LF);
-                    encodeTrailingHeaders(out, (LastHttpContent) chunk);
-                    out.writeByte(CR);
-                    out.writeByte(LF);
+                    HttpHeaders headers = ((LastHttpContent) chunk).trailingHeaders();
+                    if (headers.isEmpty()) {
+                        out.add(ZERO_CRLF_CRLF_BUF.duplicate());
+                    } else {
+                        ByteBuf buf = ctx.alloc().buffer();
+                        buf.writeBytes(ZERO_CRLF);
+                        encodeHeaders(buf, headers);
+                        buf.writeBytes(CRLF);
+                        out.add(buf);
+                    }
+
                     state = ST_INIT;
                 }
             } else {
@@ -108,25 +118,17 @@ protected void encode(ChannelHandlerContext ctx, HttpObject msg, ByteBuf out) th
         }
     }
 
-    private static void encodeHeaders(ByteBuf buf, HttpMessage message) {
-        for (Map.Entry<String, String> h: message.headers()) {
-            encodeHeader(buf, h.getKey(), h.getValue());
-        }
-    }
-
-    private static void encodeTrailingHeaders(ByteBuf buf, LastHttpContent trailer) {
-        for (Map.Entry<String, String> h: trailer.trailingHeaders()) {
+    private static void encodeHeaders(ByteBuf buf, HttpHeaders headers) {
+        for (Map.Entry<String, String> h: headers) {
             encodeHeader(buf, h.getKey(), h.getValue());
         }
     }
 
     private static void encodeHeader(ByteBuf buf, String header, String value) {
         buf.writeBytes(header.getBytes(CharsetUtil.US_ASCII));
-        buf.writeByte(COLON);
-        buf.writeByte(SP);
+        buf.writeBytes(HEADER_SEPARATOR);
         buf.writeBytes(value.getBytes(CharsetUtil.US_ASCII));
-        buf.writeByte(CR);
-        buf.writeByte(LF);
+        buf.writeBytes(CRLF);
     }
 
     protected abstract void encodeInitialLine(ByteBuf buf, H message) throws Exception;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
index 4e7e2bf0a68c..e4ecae84a002 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java
@@ -26,6 +26,7 @@
  */
 public class HttpRequestEncoder extends HttpObjectEncoder<HttpRequest> {
     private static final char SLASH = '/';
+    private static final byte[] CRLF = { CR, LF };
 
     @Override
     public boolean acceptOutboundMessage(Object msg) throws Exception {
@@ -47,11 +48,10 @@ protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Except
                 uri += SLASH;
             }
         }
-        buf.writeBytes(uri.getBytes("UTF-8"));
+        buf.writeBytes(uri.getBytes(CharsetUtil.UTF_8));
 
         buf.writeByte(SP);
         buf.writeBytes(request.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));
-        buf.writeByte(CR);
-        buf.writeByte(LF);
+        buf.writeBytes(CRLF);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
index 9d953900d02a..75ebbf2457f7 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java
@@ -25,6 +25,7 @@
  * a {@link ByteBuf}.
  */
 public class HttpResponseEncoder extends HttpObjectEncoder<HttpResponse> {
+    private static final byte[] CRLF = { CR, LF };
 
     @Override
     public boolean acceptOutboundMessage(Object msg) throws Exception {
@@ -38,7 +39,6 @@ protected void encodeInitialLine(ByteBuf buf, HttpResponse response) throws Exce
         buf.writeBytes(String.valueOf(response.getStatus().code()).getBytes(CharsetUtil.US_ASCII));
         buf.writeByte(SP);
         buf.writeBytes(String.valueOf(response.getStatus().reasonPhrase()).getBytes(CharsetUtil.US_ASCII));
-        buf.writeByte(CR);
-        buf.writeByte(LF);
+        buf.writeBytes(CRLF);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
index 2018362ba4de..eabe8a1e8b13 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java
@@ -15,11 +15,6 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.CombinedChannelDuplexHandler;
 
 
@@ -30,8 +25,7 @@
  * @see HttpClientCodec
  */
 public final class HttpServerCodec
-        extends CombinedChannelDuplexHandler
-        implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<HttpObject> {
+        extends CombinedChannelDuplexHandler<HttpRequestDecoder, HttpResponseEncoder> {
 
     /**
      * Creates a new instance with the default decoder options
@@ -48,27 +42,4 @@ public HttpServerCodec() {
     public HttpServerCodec(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize) {
         super(new HttpRequestDecoder(maxInitialLineLength, maxHeaderSize, maxChunkSize), new HttpResponseEncoder());
     }
-
-    private HttpRequestDecoder decoder() {
-        return (HttpRequestDecoder) stateHandler();
-    }
-
-    private HttpResponseEncoder encoder() {
-        return (HttpResponseEncoder) operationHandler();
-    }
-
-    @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return decoder().newInboundBuffer(ctx);
-    }
-
-    @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        decoder().discardInboundReadBytes(ctx);
-    }
-
-    @Override
-    public MessageBuf<HttpObject> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return encoder().newOutboundBuffer(ctx);
-    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
index b1575e470310..f46176606b1b 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java
@@ -54,7 +54,7 @@ public static String encode(Cookie cookie) {
         if (cookie.getMaxAge() != Long.MIN_VALUE) {
             if (cookie.getVersion() == 0) {
                 addUnquoted(buf, CookieHeaderNames.EXPIRES,
-                        new HttpHeaderDateFormat().format(
+                        HttpHeaderDateFormat.get().format(
                                 new Date(System.currentTimeMillis() +
                                          cookie.getMaxAge() * 1000L)));
             } else {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
index 13eeca8a6b2d..5a3af0e6adf2 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java
@@ -15,10 +15,10 @@
  */
 package io.netty.handler.codec.http.multipart;
 
-import io.netty.buffer.AbstractReferenceCounted;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelException;
 import io.netty.handler.codec.http.HttpConstants;
+import io.netty.util.AbstractReferenceCounted;
 
 import java.io.IOException;
 import java.nio.charset.Charset;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
index f3461d8f8836..bca48b770056 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
@@ -210,11 +210,19 @@ public boolean renameTo(File dest) throws IOException {
         int length = byteBuf.readableBytes();
         FileOutputStream outputStream = new FileOutputStream(dest);
         FileChannel fileChannel = outputStream.getChannel();
-        ByteBuffer byteBuffer = byteBuf.nioBuffer();
         int written = 0;
-        while (written < length) {
-            written += fileChannel.write(byteBuffer);
+        if (byteBuf.nioBufferCount() == 1) {
+            ByteBuffer byteBuffer = byteBuf.nioBuffer();
+            while (written < length) {
+                written += fileChannel.write(byteBuffer);
+            }
+        } else {
+            ByteBuffer[] byteBuffers = byteBuf.nioBuffers();
+            while (written < length) {
+                written += fileChannel.write(byteBuffers);
+            }
         }
+
         fileChannel.force(false);
         fileChannel.close();
         outputStream.close();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
index 5057ae92e585..fb65bdfffce8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec.http.multipart;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.http.HttpConstants;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
index 41ede3403e62..adf46f5f24e2 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.multipart;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpContent;
@@ -943,7 +943,7 @@ public void close() throws Exception {
      *             if the encoding is in error
      */
     @Override
-    public boolean readChunk(MessageBuf<HttpContent> buffer) throws ErrorDataEncoderException {
+    public boolean readChunk(MessageList<HttpContent> buffer) throws ErrorDataEncoderException {
         if (isLastChunkSent) {
             return false;
         } else {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
index d1d486f2d2a2..c5bd9b02d24d 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -50,7 +50,7 @@ public WebSocket00FrameDecoder(int maxFrameSize) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         // Discard all data received if closing handshake was received before.
         if (receivedClosingHandshake) {
             in.skipBytes(actualReadableBytes());
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
index 2e0be188d757..8032d5ec48d9 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java
@@ -54,9 +54,10 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
@@ -89,6 +90,7 @@ public class WebSocket08FrameDecoder extends ReplayingDecoder<WebSocket08FrameDe
     private ByteBuf framePayload;
     private int framePayloadBytesRead;
     private ByteBuf maskingKey;
+    private ByteBuf payloadBuffer;
 
     private final boolean allowExtensions;
     private final boolean maskedPayload;
@@ -118,7 +120,7 @@ public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions, i
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
 
         // Discard all data received if closing handshake was received before.
         if (receivedClosingHandshake) {
@@ -126,248 +128,267 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object>
             return;
         }
 
-        switch (state()) {
-            case FRAME_START:
-                framePayloadBytesRead = 0;
-                framePayloadLength = -1;
-                framePayload = null;
-
-                // FIN, RSV, OPCODE
-                byte b = in.readByte();
-                frameFinalFlag = (b & 0x80) != 0;
-                frameRsv = (b & 0x70) >> 4;
-                frameOpcode = b & 0x0F;
-
-                if (logger.isDebugEnabled()) {
-                    logger.debug("Decoding WebSocket Frame opCode={}", frameOpcode);
-                }
-
-                // MASK, PAYLOAD LEN 1
-                b = in.readByte();
-                boolean frameMasked = (b & 0x80) != 0;
-                int framePayloadLen1 = b & 0x7F;
+        try {
+            switch (state()) {
+                case FRAME_START:
+                    framePayloadBytesRead = 0;
+                    framePayloadLength = -1;
+                    framePayload = null;
+                    payloadBuffer = null;
+
+                    // FIN, RSV, OPCODE
+                    byte b = in.readByte();
+                    frameFinalFlag = (b & 0x80) != 0;
+                    frameRsv = (b & 0x70) >> 4;
+                    frameOpcode = b & 0x0F;
+
+                    if (logger.isDebugEnabled()) {
+                        logger.debug("Decoding WebSocket Frame opCode={}", frameOpcode);
+                    }
 
-                if (frameRsv != 0 && !allowExtensions) {
-                    protocolViolation(ctx, "RSV != 0 and no extension negotiated, RSV:" + frameRsv);
-                    return;
-                }
+                    // MASK, PAYLOAD LEN 1
+                    b = in.readByte();
+                    boolean frameMasked = (b & 0x80) != 0;
+                    int framePayloadLen1 = b & 0x7F;
 
-                if (maskedPayload && !frameMasked) {
-                    protocolViolation(ctx, "unmasked client to server frame");
-                    return;
-                }
-                if (frameOpcode > 7) { // control frame (have MSB in opcode set)
-
-                    // control frames MUST NOT be fragmented
-                    if (!frameFinalFlag) {
-                        protocolViolation(ctx, "fragmented control frame");
+                    if (frameRsv != 0 && !allowExtensions) {
+                        protocolViolation(ctx, "RSV != 0 and no extension negotiated, RSV:" + frameRsv);
                         return;
                     }
 
-                    // control frames MUST have payload 125 octets or less
-                    if (framePayloadLen1 > 125) {
-                        protocolViolation(ctx, "control frame with payload length > 125 octets");
+                    if (maskedPayload && !frameMasked) {
+                        protocolViolation(ctx, "unmasked client to server frame");
                         return;
                     }
+                    if (frameOpcode > 7) { // control frame (have MSB in opcode set)
 
-                    // check for reserved control frame opcodes
-                    if (!(frameOpcode == OPCODE_CLOSE || frameOpcode == OPCODE_PING || frameOpcode == OPCODE_PONG)) {
-                        protocolViolation(ctx, "control frame using reserved opcode " + frameOpcode);
-                        return;
-                    }
+                        // control frames MUST NOT be fragmented
+                        if (!frameFinalFlag) {
+                            protocolViolation(ctx, "fragmented control frame");
+                            return;
+                        }
 
-                    // close frame : if there is a body, the first two bytes of the
-                    // body MUST be a 2-byte unsigned integer (in network byte
-                    // order) representing a getStatus code
-                    if (frameOpcode == 8 && framePayloadLen1 == 1) {
-                        protocolViolation(ctx, "received close control frame with payload len 1");
-                        return;
+                        // control frames MUST have payload 125 octets or less
+                        if (framePayloadLen1 > 125) {
+                            protocolViolation(ctx, "control frame with payload length > 125 octets");
+                            return;
+                        }
+
+                        // check for reserved control frame opcodes
+                        if (!(frameOpcode == OPCODE_CLOSE || frameOpcode == OPCODE_PING
+                                || frameOpcode == OPCODE_PONG)) {
+                            protocolViolation(ctx, "control frame using reserved opcode " + frameOpcode);
+                            return;
+                        }
+
+                        // close frame : if there is a body, the first two bytes of the
+                        // body MUST be a 2-byte unsigned integer (in network byte
+                        // order) representing a getStatus code
+                        if (frameOpcode == 8 && framePayloadLen1 == 1) {
+                            protocolViolation(ctx, "received close control frame with payload len 1");
+                            return;
+                        }
+                    } else { // data frame
+                        // check for reserved data frame opcodes
+                        if (!(frameOpcode == OPCODE_CONT || frameOpcode == OPCODE_TEXT
+                                || frameOpcode == OPCODE_BINARY)) {
+                            protocolViolation(ctx, "data frame using reserved opcode " + frameOpcode);
+                            return;
+                        }
+
+                        // check opcode vs message fragmentation state 1/2
+                        if (fragmentedFramesCount == 0 && frameOpcode == OPCODE_CONT) {
+                            protocolViolation(ctx, "received continuation data frame outside fragmented message");
+                            return;
+                        }
+
+                        // check opcode vs message fragmentation state 2/2
+                        if (fragmentedFramesCount != 0 && frameOpcode != OPCODE_CONT && frameOpcode != OPCODE_PING) {
+                            protocolViolation(ctx,
+                                    "received non-continuation data frame while inside fragmented message");
+                            return;
+                        }
                     }
-                } else { // data frame
-                    // check for reserved data frame opcodes
-                    if (!(frameOpcode == OPCODE_CONT || frameOpcode == OPCODE_TEXT || frameOpcode == OPCODE_BINARY)) {
-                        protocolViolation(ctx, "data frame using reserved opcode " + frameOpcode);
-                        return;
+
+                    // Read frame payload length
+                    if (framePayloadLen1 == 126) {
+                        framePayloadLength = in.readUnsignedShort();
+                        if (framePayloadLength < 126) {
+                            protocolViolation(ctx, "invalid data frame length (not using minimal length encoding)");
+                            return;
+                        }
+                    } else if (framePayloadLen1 == 127) {
+                        framePayloadLength = in.readLong();
+                        // TODO: check if it's bigger than 0x7FFFFFFFFFFFFFFF, Maybe
+                        // just check if it's negative?
+
+                        if (framePayloadLength < 65536) {
+                            protocolViolation(ctx, "invalid data frame length (not using minimal length encoding)");
+                            return;
+                        }
+                    } else {
+                        framePayloadLength = framePayloadLen1;
                     }
 
-                    // check opcode vs message fragmentation state 1/2
-                    if (fragmentedFramesCount == 0 && frameOpcode == OPCODE_CONT) {
-                        protocolViolation(ctx, "received continuation data frame outside fragmented message");
+                    if (framePayloadLength > maxFramePayloadLength) {
+                        protocolViolation(ctx, "Max frame length of " + maxFramePayloadLength + " has been exceeded.");
                         return;
                     }
 
-                    // check opcode vs message fragmentation state 2/2
-                    if (fragmentedFramesCount != 0 && frameOpcode != OPCODE_CONT && frameOpcode != OPCODE_PING) {
-                        protocolViolation(ctx, "received non-continuation data frame while inside fragmented message");
-                        return;
+                    if (logger.isDebugEnabled()) {
+                        logger.debug("Decoding WebSocket Frame length={}", framePayloadLength);
                     }
-                }
 
-                // Read frame payload length
-                if (framePayloadLen1 == 126) {
-                    framePayloadLength = in.readUnsignedShort();
-                    if (framePayloadLength < 126) {
-                        protocolViolation(ctx, "invalid data frame length (not using minimal length encoding)");
-                        return;
+                    checkpoint(State.MASKING_KEY);
+                case MASKING_KEY:
+                    if (maskedPayload) {
+                        maskingKey = in.readBytes(4);
                     }
-                } else if (framePayloadLen1 == 127) {
-                    framePayloadLength = in.readLong();
-                    // TODO: check if it's bigger than 0x7FFFFFFFFFFFFFFF, Maybe
-                    // just check if it's negative?
+                    checkpoint(State.PAYLOAD);
+                case PAYLOAD:
+                    // Sometimes, the payload may not be delivered in 1 nice packet
+                    // We need to accumulate the data until we have it all
+                    int rbytes = actualReadableBytes();
+
+                    long willHaveReadByteCount = framePayloadBytesRead + rbytes;
+                    // logger.debug("Frame rbytes=" + rbytes + " willHaveReadByteCount="
+                    // + willHaveReadByteCount + " framePayloadLength=" +
+                    // framePayloadLength);
+                    if (willHaveReadByteCount == framePayloadLength) {
+                        // We have all our content so proceed to process
+                        payloadBuffer = ctx.alloc().buffer(rbytes);
+                        payloadBuffer.writeBytes(in, rbytes);
+                    } else if (willHaveReadByteCount < framePayloadLength) {
+
+                        // We don't have all our content so accumulate payload.
+                        // Returning null means we will get called back
+                        if (framePayload == null) {
+                            framePayload = ctx.alloc().buffer(toFrameLength(framePayloadLength));
+                        }
+                        framePayload.writeBytes(in, rbytes);
+                        framePayloadBytesRead += rbytes;
 
-                    if (framePayloadLength < 65536) {
-                        protocolViolation(ctx, "invalid data frame length (not using minimal length encoding)");
+                        // Return null to wait for more bytes to arrive
                         return;
+                    } else if (willHaveReadByteCount > framePayloadLength) {
+                        // We have more than what we need so read up to the end of frame
+                        // Leave the remainder in the buffer for next frame
+                        if (framePayload == null) {
+                            framePayload = ctx.alloc().buffer(toFrameLength(framePayloadLength));
+                        }
+                        framePayload.writeBytes(in, toFrameLength(framePayloadLength - framePayloadBytesRead));
                     }
-                } else {
-                    framePayloadLength = framePayloadLen1;
-                }
 
-                if (framePayloadLength > maxFramePayloadLength) {
-                    protocolViolation(ctx, "Max frame length of " + maxFramePayloadLength + " has been exceeded.");
-                    return;
-                }
+                    // Now we have all the data, the next checkpoint must be the next
+                    // frame
+                    checkpoint(State.FRAME_START);
 
-                if (logger.isDebugEnabled()) {
-                    logger.debug("Decoding WebSocket Frame length={}", framePayloadLength);
-                }
-
-                checkpoint(State.MASKING_KEY);
-            case MASKING_KEY:
-                if (maskedPayload) {
-                    maskingKey = in.readBytes(4);
-                }
-                checkpoint(State.PAYLOAD);
-            case PAYLOAD:
-                // Sometimes, the payload may not be delivered in 1 nice packet
-                // We need to accumulate the data until we have it all
-                int rbytes = actualReadableBytes();
-                ByteBuf payloadBuffer = null;
-
-                long willHaveReadByteCount = framePayloadBytesRead + rbytes;
-                // logger.debug("Frame rbytes=" + rbytes + " willHaveReadByteCount="
-                // + willHaveReadByteCount + " framePayloadLength=" +
-                // framePayloadLength);
-                if (willHaveReadByteCount == framePayloadLength) {
-                    // We have all our content so proceed to process
-                    payloadBuffer = ctx.alloc().buffer(rbytes);
-                    payloadBuffer.writeBytes(in, rbytes);
-                } else if (willHaveReadByteCount < framePayloadLength) {
-
-                    // We don't have all our content so accumulate payload.
-                    // Returning null means we will get called back
+                    // Take the data that we have in this packet
                     if (framePayload == null) {
-                        framePayload = ctx.alloc().buffer(toFrameLength(framePayloadLength));
+                        framePayload = payloadBuffer;
+                    } else if (payloadBuffer != null) {
+                        framePayload.writeBytes(payloadBuffer);
                     }
-                    framePayload.writeBytes(in, rbytes);
-                    framePayloadBytesRead += rbytes;
 
-                    // Return null to wait for more bytes to arrive
-                    return;
-                } else if (willHaveReadByteCount > framePayloadLength) {
-                    // We have more than what we need so read up to the end of frame
-                    // Leave the remainder in the buffer for next frame
-                    if (framePayload == null) {
-                        framePayload = ctx.alloc().buffer(toFrameLength(framePayloadLength));
+                    // Unmask data if needed
+                    if (maskedPayload) {
+                        unmask(framePayload);
                     }
-                    framePayload.writeBytes(in, toFrameLength(framePayloadLength - framePayloadBytesRead));
-                }
-
-                // Now we have all the data, the next checkpoint must be the next
-                // frame
-                checkpoint(State.FRAME_START);
-
-                // Take the data that we have in this packet
-                if (framePayload == null) {
-                    framePayload = payloadBuffer;
-                } else if (payloadBuffer != null) {
-                    framePayload.writeBytes(payloadBuffer);
-                }
 
-                // Unmask data if needed
-                if (maskedPayload) {
-                    unmask(framePayload);
-                }
-
-                // Processing ping/pong/close frames because they cannot be
-                // fragmented
-                if (frameOpcode == OPCODE_PING) {
-                    out.add(new PingWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                    return;
-                }
-                if (frameOpcode == OPCODE_PONG) {
-                    out.add(new PongWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                    return;
-                }
-                if (frameOpcode == OPCODE_CLOSE) {
-                    checkCloseFrameBody(ctx, framePayload);
-                    receivedClosingHandshake = true;
-                    out.add(new CloseWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                    return;
-                }
-
-                // Processing for possible fragmented messages for text and binary
-                // frames
-                String aggregatedText = null;
-                if (frameFinalFlag) {
-                    // Final frame of the sequence. Apparently ping frames are
-                    // allowed in the middle of a fragmented message
-                    if (frameOpcode != OPCODE_PING) {
-                        fragmentedFramesCount = 0;
-
-                        // Check text for UTF8 correctness
-                        if (frameOpcode == OPCODE_TEXT || fragmentedFramesText != null) {
-                            // Check UTF-8 correctness for this payload
-                            checkUTF8String(ctx, framePayload);
-
-                            // This does a second check to make sure UTF-8
-                            // correctness for entire text message
-                            aggregatedText = fragmentedFramesText.toString();
-
-                            fragmentedFramesText = null;
-                        }
+                    // Processing ping/pong/close frames because they cannot be
+                    // fragmented
+                    if (frameOpcode == OPCODE_PING) {
+                        out.add(new PingWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
+                        return;
                     }
-                } else {
-                    // Not final frame so we can expect more frames in the
-                    // fragmented sequence
-                    if (fragmentedFramesCount == 0) {
-                        // First text or binary frame for a fragmented set
-                        fragmentedFramesText = null;
-                        if (frameOpcode == OPCODE_TEXT) {
-                            checkUTF8String(ctx, framePayload);
+                    if (frameOpcode == OPCODE_PONG) {
+                        out.add(new PongWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
+                        return;
+                    }
+                    if (frameOpcode == OPCODE_CLOSE) {
+                        checkCloseFrameBody(ctx, framePayload);
+                        receivedClosingHandshake = true;
+                        out.add(new CloseWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
+                        return;
+                    }
+
+                    // Processing for possible fragmented messages for text and binary
+                    // frames
+                    String aggregatedText = null;
+                    if (frameFinalFlag) {
+                        // Final frame of the sequence. Apparently ping frames are
+                        // allowed in the middle of a fragmented message
+                        if (frameOpcode != OPCODE_PING) {
+                            fragmentedFramesCount = 0;
+
+                            // Check text for UTF8 correctness
+                            if (frameOpcode == OPCODE_TEXT || fragmentedFramesText != null) {
+                                // Check UTF-8 correctness for this payload
+                                checkUTF8String(ctx, framePayload);
+
+                                // This does a second check to make sure UTF-8
+                                // correctness for entire text message
+                                aggregatedText = fragmentedFramesText.toString();
+
+                                fragmentedFramesText = null;
+                            }
                         }
                     } else {
-                        // Subsequent frames - only check if init frame is text
-                        if (fragmentedFramesText != null) {
-                            checkUTF8String(ctx, framePayload);
+                        // Not final frame so we can expect more frames in the
+                        // fragmented sequence
+                        if (fragmentedFramesCount == 0) {
+                            // First text or binary frame for a fragmented set
+                            fragmentedFramesText = null;
+                            if (frameOpcode == OPCODE_TEXT) {
+                                checkUTF8String(ctx, framePayload);
+                            }
+                        } else {
+                            // Subsequent frames - only check if init frame is text
+                            if (fragmentedFramesText != null) {
+                                checkUTF8String(ctx, framePayload);
+                            }
                         }
-                    }
 
-                    // Increment counter
-                    fragmentedFramesCount++;
-                }
+                        // Increment counter
+                        fragmentedFramesCount++;
+                    }
 
-                // Return the frame
-                if (frameOpcode == OPCODE_TEXT) {
-                    out.add(new TextWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                    return;
-                } else if (frameOpcode == OPCODE_BINARY) {
-                    out.add(new BinaryWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
-                    return;
-                } else if (frameOpcode == OPCODE_CONT) {
-                    out.add(new ContinuationWebSocketFrame(frameFinalFlag, frameRsv, framePayload, aggregatedText));
+                    // Return the frame
+                    if (frameOpcode == OPCODE_TEXT) {
+                        out.add(new TextWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
+                        return;
+                    } else if (frameOpcode == OPCODE_BINARY) {
+                        out.add(new BinaryWebSocketFrame(frameFinalFlag, frameRsv, framePayload));
+                        return;
+                    } else if (frameOpcode == OPCODE_CONT) {
+                        out.add(new ContinuationWebSocketFrame(frameFinalFlag, frameRsv, framePayload, aggregatedText));
+                        return;
+                    } else {
+                        throw new UnsupportedOperationException("Cannot decode web socket frame with opcode: "
+                                + frameOpcode);
+                    }
+                case CORRUPT:
+                    // If we don't keep reading Netty will throw an exception saying
+                    // we can't return null if no bytes read and state not changed.
+                    in.readByte();
                     return;
-                } else {
-                    throw new UnsupportedOperationException("Cannot decode web socket frame with opcode: "
-                            + frameOpcode);
+                default:
+                    throw new Error("Shouldn't reach here.");
+            }
+        } catch (Exception e) {
+            if (payloadBuffer != null) {
+                if (payloadBuffer.refCnt() > 0) {
+                    payloadBuffer.release();
+                }
+                payloadBuffer = null;
+            }
+            if (framePayload != null) {
+                if (framePayload.refCnt() > 0) {
+                    framePayload.release();
                 }
-            case CORRUPT:
-                // If we don't keep reading Netty will throw an exception saying
-                // we can't return null if no bytes read and state not changed.
-                in.readByte();
-                return;
-            default:
-                throw new Error("Shouldn't reach here.");
+                framePayload = null;
+            }
+            throw e;
         }
     }
 
@@ -380,7 +401,7 @@ private void unmask(ByteBuf frame) {
     private void protocolViolation(ChannelHandlerContext ctx, String reason) {
         checkpoint(State.CORRUPT);
         if (ctx.channel().isActive()) {
-            ctx.flush().addListener(ChannelFutureListener.CLOSE);
+            ctx.write(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
         }
         throw new CorruptedFrameException(reason);
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
index b9e0c869e1c2..04d381aa5d39 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java
@@ -19,8 +19,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -230,11 +230,11 @@ public final void finishHandshake(Channel channel, FullHttpResponse response) {
     /**
      * Returns the decoder to use after handshake is complete.
      */
-    protected abstract ChannelInboundByteHandler newWebsocketDecoder();
+    protected abstract ChannelInboundHandler newWebsocketDecoder();
 
     /**
      * Returns the encoder to use after the handshake is complete.
      */
-    protected abstract ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder();
+    protected abstract ChannelOutboundHandler newWebSocketEncoder();
 
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
index 4fc2211625bc..b8422ac00c32 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java
@@ -17,8 +17,8 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -252,12 +252,12 @@ private static String insertSpaces(String key, int spaces) {
     }
 
     @Override
-    protected ChannelInboundByteHandler newWebsocketDecoder() {
+    protected ChannelInboundHandler newWebsocketDecoder() {
         return new WebSocket00FrameDecoder(maxFramePayloadLength());
     }
 
     @Override
-    protected ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder() {
+    protected ChannelOutboundHandler newWebSocketEncoder() {
         return new WebSocket00FrameEncoder();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
index 205ba762fef1..b85c6546966b 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -191,12 +191,12 @@ protected void verify(FullHttpResponse response) {
     }
 
     @Override
-    protected ChannelInboundByteHandler newWebsocketDecoder() {
+    protected ChannelInboundHandler newWebsocketDecoder() {
         return new WebSocket07FrameDecoder(false, allowExtensions, maxFramePayloadLength());
     }
 
     @Override
-    protected ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder() {
+    protected ChannelOutboundHandler newWebSocketEncoder() {
         return new WebSocket07FrameEncoder(true);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
index bb66d369b6b0..93b2132aa2ea 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -191,12 +191,12 @@ protected void verify(FullHttpResponse response) {
     }
 
     @Override
-    protected ChannelInboundByteHandler newWebsocketDecoder() {
+    protected ChannelInboundHandler newWebsocketDecoder() {
         return new WebSocket08FrameDecoder(false, allowExtensions, maxFramePayloadLength());
     }
 
     @Override
-    protected ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder() {
+    protected ChannelOutboundHandler newWebSocketEncoder() {
         return new WebSocket08FrameEncoder(true);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
index 9f2c4ca33655..b12ac03dde30 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -191,12 +191,12 @@ protected void verify(FullHttpResponse response) {
     }
 
     @Override
-    protected ChannelInboundByteHandler newWebsocketDecoder() {
+    protected ChannelInboundHandler newWebsocketDecoder() {
         return new WebSocket13FrameDecoder(false, allowExtensions, maxFramePayloadLength());
     }
 
     @Override
-    protected ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder() {
+    protected ChannelOutboundHandler newWebSocketEncoder() {
         return new WebSocket13FrameEncoder(true);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java
index a3d72ab96d7a..69d5af599f93 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java
@@ -16,8 +16,9 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandler;
 import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelStateHandler;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.HttpHeaders;
 
 import java.net.URI;
@@ -33,7 +34,7 @@
  * This implementation will establish the websocket connection once the connection to the remote server was complete.
  *
  * To know once a handshake was done you can intercept the
- * {@link ChannelStateHandler#userEventTriggered(ChannelHandlerContext, Object)} and check if the event was of type
+ * {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)} and check if the event was of type
  * {@link ClientHandshakeStateEvent#HANDSHAKE_ISSUED} or {@link ClientHandshakeStateEvent#HANDSHAKE_COMPLETE}.
  */
 public class WebSocketClientProtocolHandler extends WebSocketProtocolHandler {
@@ -128,12 +129,12 @@ public WebSocketClientProtocolHandler(WebSocketClientHandshaker handshaker) {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, WebSocketFrame frame, MessageList<Object> out) throws Exception {
         if (handleCloseFrames && frame instanceof CloseWebSocketFrame) {
             ctx.close();
             return;
         }
-        super.messageReceived(ctx, frame);
+        super.decode(ctx, frame, out);
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
index 6ba95fa736e1..82c39dca660e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java
@@ -18,10 +18,10 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.FullHttpResponse;
 
-class WebSocketClientProtocolHandshakeHandler extends ChannelInboundMessageHandlerAdapter<FullHttpResponse> {
+class WebSocketClientProtocolHandshakeHandler extends SimpleChannelInboundHandler<FullHttpResponse> {
     private final WebSocketClientHandshaker handshaker;
 
     public WebSocketClientProtocolHandshakeHandler(WebSocketClientHandshaker handshaker) {
@@ -45,9 +45,10 @@ public void operationComplete(ChannelFuture future) throws Exception {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {
+    protected void messageReceived(ChannelHandlerContext ctx, FullHttpResponse msg) throws Exception {
         if (!handshaker.isHandshakeComplete()) {
             handshaker.finishHandshake(ctx.channel(), msg);
+            msg.release();
             ctx.fireUserEventTriggered(
                     WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HANDSHAKE_COMPLETE);
             ctx.pipeline().remove(this);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java
index 0ff0b28ba0b8..10eb9e31f2ff 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java
@@ -17,8 +17,8 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.CompositeByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -47,7 +47,7 @@ public WebSocketFrameAggregator(int maxFrameSize) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, WebSocketFrame msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, WebSocketFrame msg, MessageList<Object> out) throws Exception {
         if (currentFrame == null) {
             tooLongFrameFound = false;
             if (msg.isFinalFragment()) {
@@ -97,4 +97,26 @@ protected void decode(ChannelHandlerContext ctx, WebSocketFrame msg, MessageBuf<
         // handler in the chain
         out.add(msg.retain());
     }
+
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        super.channelInactive(ctx);
+
+        // release current frame if it is not null as it may be a left-over
+        if (currentFrame != null) {
+            currentFrame.release();
+            currentFrame = null;
+        }
+    }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        super.handlerRemoved(ctx);
+        // release current frane if it is not null as it may be a left-over as there is not much more we can do in
+        // this case
+        if (currentFrame != null) {
+            currentFrame.release();
+            currentFrame = null;
+        }
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketProtocolHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketProtocolHandler.java
index c5014ba6d727..49ca45ec86e7 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketProtocolHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketProtocolHandler.java
@@ -17,12 +17,12 @@
 
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
-
-abstract class WebSocketProtocolHandler  extends ChannelInboundMessageHandlerAdapter<WebSocketFrame> {
+import io.netty.channel.MessageList;
+import io.netty.handler.codec.MessageToMessageDecoder;
 
+abstract class WebSocketProtocolHandler extends MessageToMessageDecoder<WebSocketFrame> {
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, WebSocketFrame frame, MessageList<Object> out) throws Exception {
         if (frame instanceof PingWebSocketFrame) {
             frame.content().retain();
             ctx.channel().write(new PongWebSocketFrame(frame.content()));
@@ -33,8 +33,7 @@ public void messageReceived(ChannelHandlerContext ctx, WebSocketFrame frame) thr
             return;
         }
 
-        frame.retain();
-        ctx.nextInboundMessageBuffer().add(frame);
+        out.add(frame.retain());
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
index 38d00d0389ea..de8c88fdfe0e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java
@@ -19,8 +19,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -267,11 +267,11 @@ protected void setSelectedSubprotocol(String value) {
     /**
      * Returns the decoder to use after handshake is complete.
      */
-    protected abstract ChannelInboundByteHandler newWebsocketDecoder();
+    protected abstract ChannelInboundHandler newWebsocketDecoder();
 
     /**
      * Returns the encoder to use after the handshake is complete.
      */
-    protected abstract ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder();
+    protected abstract ChannelOutboundHandler newWebSocketEncoder();
 
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
index 89969fde6866..73307000e38a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java
@@ -19,8 +19,8 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -183,12 +183,12 @@ public ChannelFuture close(Channel channel, CloseWebSocketFrame frame, ChannelPr
     }
 
     @Override
-    protected ChannelInboundByteHandler newWebsocketDecoder() {
+    protected ChannelInboundHandler newWebsocketDecoder() {
         return new WebSocket00FrameDecoder(maxFramePayloadLength());
     }
 
     @Override
-    protected ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder() {
+    protected ChannelOutboundHandler newWebSocketEncoder() {
         return new WebSocket00FrameEncoder();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
index 514dd1a12b75..e7b76de3a7a8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -132,12 +132,12 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
     }
 
     @Override
-    protected ChannelInboundByteHandler newWebsocketDecoder() {
+    protected ChannelInboundHandler newWebsocketDecoder() {
         return new WebSocket07FrameDecoder(true, allowExtensions, maxFramePayloadLength());
     }
 
     @Override
-    protected ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder() {
+    protected ChannelOutboundHandler newWebSocketEncoder() {
         return new WebSocket07FrameEncoder(false);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
index d465b81f1849..98bc9dd8009c 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -131,12 +131,12 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
     }
 
     @Override
-    protected ChannelInboundByteHandler newWebsocketDecoder() {
+    protected ChannelInboundHandler newWebsocketDecoder() {
         return new WebSocket08FrameDecoder(true, allowExtensions, maxFramePayloadLength());
     }
 
     @Override
-    protected ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder() {
+    protected ChannelOutboundHandler newWebSocketEncoder() {
         return new WebSocket08FrameEncoder(false);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
index 470fb86dd9ca..611294addec8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -130,12 +130,12 @@ protected FullHttpResponse newHandshakeResponse(FullHttpRequest req, HttpHeaders
     }
 
     @Override
-    protected ChannelInboundByteHandler newWebsocketDecoder() {
+    protected ChannelInboundHandler newWebsocketDecoder() {
         return new WebSocket13FrameDecoder(true, allowExtensions, maxFramePayloadLength());
     }
 
     @Override
-    protected ChannelOutboundMessageHandler<WebSocketFrame> newWebSocketEncoder() {
+    protected ChannelOutboundHandler newWebSocketEncoder() {
         return new WebSocket13FrameEncoder(false);
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
index aad5f9be07a1..ab3ec95dac23 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java
@@ -19,9 +19,11 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
-import io.netty.channel.ChannelStateHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -43,7 +45,7 @@
  * to the <tt>io.netty.example.http.websocketx.server.WebSocketServer</tt> example.
  *
  * To know once a handshake was done you can intercept the
- * {@link ChannelStateHandler#userEventTriggered(ChannelHandlerContext, Object)} and check if the event was of type
+ * {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)} and check if the event was of type
  * {@link ServerHandshakeStateEvent#HANDSHAKE_COMPLETE}.
  */
 public class WebSocketServerProtocolHandler extends WebSocketProtocolHandler {
@@ -90,14 +92,14 @@ public void handlerAdded(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, WebSocketFrame frame, MessageList<Object> out) throws Exception {
         if (frame instanceof CloseWebSocketFrame) {
             WebSocketServerHandshaker handshaker = getHandshaker(ctx);
             frame.retain();
             handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame);
             return;
         }
-        super.messageReceived(ctx, frame);
+        super.decode(ctx, frame, out);
     }
 
     @Override
@@ -120,9 +122,10 @@ static void setHandshaker(ChannelHandlerContext ctx, WebSocketServerHandshaker h
     }
 
     static ChannelHandler forbiddenHttpRequestResponder() {
-        return new ChannelInboundMessageHandlerAdapter<FullHttpRequest>() {
+        return new SimpleChannelInboundHandler<FullHttpRequest>() {
             @Override
-            public void messageReceived(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {
+            protected void messageReceived(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {
+                msg.release();
                 FullHttpResponse response =
                         new DefaultFullHttpResponse(HTTP_1_1, HttpResponseStatus.FORBIDDEN);
                 ctx.channel().write(response);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
index c30fff92e419..31e4ada4eedd 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java
@@ -18,8 +18,9 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpHeaders;
@@ -36,7 +37,7 @@
  * Handles the HTTP handshake (the HTTP Upgrade request) for {@link WebSocketServerProtocolHandler}.
  */
 class WebSocketServerProtocolHandshakeHandler
-        extends ChannelInboundMessageHandlerAdapter<FullHttpRequest> {
+        extends ChannelInboundHandlerAdapter {
 
     private final String websocketPath;
     private final String subprotocols;
@@ -50,33 +51,37 @@ public WebSocketServerProtocolHandshakeHandler(String websocketPath, String subp
     }
 
     @Override
-    public void messageReceived(final ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
-        if (req.getMethod() != GET) {
-            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
-            return;
-        }
+    public void messageReceived(final ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<FullHttpRequest> requests = msgs.cast();
+        for (int i = 0; i < requests.size(); i++) {
+            FullHttpRequest req = requests.get(i);
+            if (req.getMethod() != GET) {
+                sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, FORBIDDEN));
+                return;
+            }
 
-        final WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(
-                getWebSocketLocation(ctx.pipeline(), req, websocketPath), subprotocols, allowExtensions);
-        final WebSocketServerHandshaker handshaker = wsFactory.newHandshaker(req);
-        if (handshaker == null) {
-            WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());
-        } else {
-            final ChannelFuture handshakeFuture = handshaker.handshake(ctx.channel(), req);
-            handshakeFuture.addListener(new ChannelFutureListener() {
-                @Override
-                public void operationComplete(ChannelFuture future) throws Exception {
-                    if (!future.isSuccess()) {
-                        ctx.fireExceptionCaught(future.cause());
-                    } else {
-                        ctx.fireUserEventTriggered(
-                                WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HANDSHAKE_COMPLETE);
+            final WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(
+                    getWebSocketLocation(ctx.pipeline(), req, websocketPath), subprotocols, allowExtensions);
+            final WebSocketServerHandshaker handshaker = wsFactory.newHandshaker(req);
+            if (handshaker == null) {
+                WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());
+            } else {
+                final ChannelFuture handshakeFuture = handshaker.handshake(ctx.channel(), req);
+                handshakeFuture.addListener(new ChannelFutureListener() {
+                    @Override
+                    public void operationComplete(ChannelFuture future) throws Exception {
+                        if (!future.isSuccess()) {
+                            ctx.fireExceptionCaught(future.cause());
+                        } else {
+                            ctx.fireUserEventTriggered(
+                                    WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HANDSHAKE_COMPLETE);
+                        }
                     }
-                }
-            });
-            WebSocketServerProtocolHandler.setHandshaker(ctx, handshaker);
-            ctx.pipeline().replace(this, "WS403Responder",
-                WebSocketServerProtocolHandler.forbiddenHttpRequestResponder());
+                });
+                WebSocketServerProtocolHandler.setHandshaker(ctx, handshaker);
+                ctx.pipeline().replace(this, "WS403Responder",
+                        WebSocketServerProtocolHandler.forbiddenHttpRequestResponder());
+            }
         }
     }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
index 3897560f1281..dc1ec159e4fd 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,17 +16,16 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.DefaultByteBufHolder;
 import io.netty.buffer.Unpooled;
+import io.netty.util.IllegalReferenceCountException;
 import io.netty.util.internal.StringUtil;
 
 /**
  * The default {@link SpdyDataFrame} implementation.
  */
-public class DefaultSpdyDataFrame extends DefaultByteBufHolder implements SpdyDataFrame {
+public class DefaultSpdyDataFrame extends DefaultSpdyStreamFrame implements SpdyDataFrame {
 
-    private int streamId;
-    private boolean last;
+    private final ByteBuf data;
 
     /**
      * Creates a new instance.
@@ -44,8 +43,11 @@ public DefaultSpdyDataFrame(int streamId) {
      * @param data      the payload of the frame. Can not exceed {@link SpdyCodecUtil#SPDY_MAX_LENGTH}
      */
     public DefaultSpdyDataFrame(int streamId, ByteBuf data) {
-        super(validate(data));
-        setStreamId(streamId);
+        super(streamId);
+        if (data == null) {
+            throw new NullPointerException("data");
+        }
+        this.data = validate(data);
     }
 
     private static ByteBuf validate(ByteBuf data) {
@@ -56,51 +58,60 @@ private static ByteBuf validate(ByteBuf data) {
         return data;
     }
 
-    @Override
-    public int getStreamId() {
-        return streamId;
-    }
-
     @Override
     public SpdyDataFrame setStreamId(int streamId) {
-        if (streamId <= 0) {
-            throw new IllegalArgumentException(
-                    "Stream-ID must be positive: " + streamId);
-        }
-        this.streamId = streamId;
+        super.setStreamId(streamId);
         return this;
     }
 
     @Override
-    public boolean isLast() {
-        return last;
+    public SpdyDataFrame setLast(boolean last) {
+        super.setLast(last);
+        return this;
     }
 
     @Override
-    public SpdyDataFrame setLast(boolean last) {
-        this.last = last;
-        return this;
+    public ByteBuf content() {
+        if (data.refCnt() <= 0) {
+            throw new IllegalReferenceCountException(data.refCnt());
+        }
+        return data;
     }
 
     @Override
-    public DefaultSpdyDataFrame copy() {
-        DefaultSpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), content().copy());
+    public SpdyDataFrame copy() {
+        SpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), content().copy());
         frame.setLast(isLast());
         return frame;
     }
 
+    @Override
+    public int refCnt() {
+        return data.refCnt();
+    }
+
     @Override
     public SpdyDataFrame retain() {
-        super.retain();
+        data.retain();
         return this;
     }
 
     @Override
     public SpdyDataFrame retain(int increment) {
-        super.retain(increment);
+        data.retain(increment);
         return this;
     }
 
+    @Override
+    public boolean release() {
+        return data.release();
+    }
+
+    @Override
+    public boolean release(int decrement) {
+        return data.release(decrement);
+    }
+
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
@@ -110,7 +121,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(streamId);
+        buf.append(getStreamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Size = ");
         if (refCnt() == 0) {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java
index 26c26c261d64..6d0d379581e4 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -48,19 +48,17 @@ public DefaultSpdyGoAwayFrame(int lastGoodStreamId, int statusCode) {
      * Creates a new instance.
      *
      * @param lastGoodStreamId the Last-good-stream-ID of this frame
-     * @param status           the getStatus of this frame
+     * @param status           the status of this frame
      */
     public DefaultSpdyGoAwayFrame(int lastGoodStreamId, SpdySessionStatus status) {
         setLastGoodStreamId(lastGoodStreamId);
         setStatus(status);
     }
 
-    @Override
     public int getLastGoodStreamId() {
         return lastGoodStreamId;
     }
 
-    @Override
     public SpdyGoAwayFrame setLastGoodStreamId(int lastGoodStreamId) {
         if (lastGoodStreamId < 0) {
             throw new IllegalArgumentException("Last-good-stream-ID"
@@ -70,12 +68,10 @@ public SpdyGoAwayFrame setLastGoodStreamId(int lastGoodStreamId) {
         return this;
     }
 
-    @Override
     public SpdySessionStatus getStatus() {
         return status;
     }
 
-    @Override
     public SpdyGoAwayFrame setStatus(SpdySessionStatus status) {
         this.status = status;
         return this;
@@ -87,10 +83,10 @@ public String toString() {
         buf.append(getClass().getSimpleName());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Last-good-stream-ID = ");
-        buf.append(lastGoodStreamId);
+        buf.append(getLastGoodStreamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Status: ");
-        buf.append(status.toString());
+        buf.append(getStatus().toString());
         return buf.toString();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java
deleted file mode 100644
index 2521bc44bee6..000000000000
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec.spdy;
-
-import io.netty.util.internal.StringUtil;
-
-import java.util.Map;
-
-/**
- * The default {@link SpdyHeaderBlock} implementation.
- */
-public class DefaultSpdyHeaderBlock implements SpdyHeaderBlock {
-
-    private boolean invalid;
-    private final SpdyHeaders headers = new DefaultSpdyHeaders();
-
-    /**
-     * Creates a new instance.
-     */
-    protected DefaultSpdyHeaderBlock() {
-    }
-
-    @Override
-    public boolean isInvalid() {
-        return invalid;
-    }
-
-    @Override
-    public SpdyHeaderBlock setInvalid() {
-        invalid = true;
-        return this;
-    }
-
-    @Override
-    public SpdyHeaders headers() {
-        return headers;
-    }
-
-    protected void appendHeaders(StringBuilder buf) {
-        for (Map.Entry<String, String> e: headers().entries()) {
-            buf.append("    ");
-            buf.append(e.getKey());
-            buf.append(": ");
-            buf.append(e.getValue());
-            buf.append(StringUtil.NEWLINE);
-        }
-    }
-}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java
index 1687bf0c7357..6abb43fd736e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -15,17 +15,18 @@
  */
 package io.netty.handler.codec.spdy;
 
+import java.util.Map;
 
 import io.netty.util.internal.StringUtil;
 
 /**
  * The default {@link SpdyHeadersFrame} implementation.
  */
-public class DefaultSpdyHeadersFrame extends DefaultSpdyHeaderBlock
+public class DefaultSpdyHeadersFrame extends DefaultSpdyStreamFrame
         implements SpdyHeadersFrame {
 
-    private int streamId;
-    private boolean last;
+    private boolean invalid;
+    private final SpdyHeaders headers = new DefaultSpdyHeaders();
 
     /**
      * Creates a new instance.
@@ -33,41 +34,34 @@ public class DefaultSpdyHeadersFrame extends DefaultSpdyHeaderBlock
      * @param streamId the Stream-ID of this frame
      */
     public DefaultSpdyHeadersFrame(int streamId) {
-        setStreamId(streamId);
-    }
-
-    @Override
-    public int getStreamId() {
-        return streamId;
+        super(streamId);
     }
 
     @Override
     public SpdyHeadersFrame setStreamId(int streamId) {
-        if (streamId <= 0) {
-            throw new IllegalArgumentException(
-                    "Stream-ID must be positive: " + streamId);
-        }
-        this.streamId = streamId;
+        super.setStreamId(streamId);
         return this;
     }
 
-    @Override
-    public boolean isLast() {
-        return last;
-    }
-
     @Override
     public SpdyHeadersFrame setLast(boolean last) {
-        this.last = last;
+        super.setLast(last);
         return this;
     }
 
-    @Override
+    public boolean isInvalid() {
+        return invalid;
+    }
+
     public SpdyHeadersFrame setInvalid() {
-        super.setInvalid();
+        invalid = true;
         return this;
     }
 
+    public SpdyHeaders headers() {
+        return headers;
+    }
+
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
@@ -77,7 +71,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(streamId);
+        buf.append(getStreamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Headers:");
         buf.append(StringUtil.NEWLINE);
@@ -87,4 +81,14 @@ public String toString() {
         buf.setLength(buf.length() - StringUtil.NEWLINE.length());
         return buf.toString();
     }
+
+    protected void appendHeaders(StringBuilder buf) {
+        for (Map.Entry<String, String> e: headers().entries()) {
+            buf.append("    ");
+            buf.append(e.getKey());
+            buf.append(": ");
+            buf.append(e.getValue());
+            buf.append(StringUtil.NEWLINE);
+        }
+    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java
index 7e2ad7ac7fda..d2d6b5c09233 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -33,12 +33,10 @@ public DefaultSpdyPingFrame(int id) {
         setId(id);
     }
 
-    @Override
     public int getId() {
         return id;
     }
 
-    @Override
     public SpdyPingFrame setId(int id) {
         this.id = id;
         return this;
@@ -50,7 +48,7 @@ public String toString() {
         buf.append(getClass().getSimpleName());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> ID = ");
-        buf.append(id);
+        buf.append(getId());
         return buf.toString();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java
index e27c55a0093b..894b3cc6ba6a 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -20,9 +20,9 @@
 /**
  * The default {@link SpdyRstStreamFrame} implementation.
  */
-public class DefaultSpdyRstStreamFrame implements SpdyRstStreamFrame {
+public class DefaultSpdyRstStreamFrame extends DefaultSpdyStreamFrame
+        implements SpdyRstStreamFrame {
 
-    private int streamId;
     private SpdyStreamStatus status;
 
     /**
@@ -39,34 +39,29 @@ public DefaultSpdyRstStreamFrame(int streamId, int statusCode) {
      * Creates a new instance.
      *
      * @param streamId the Stream-ID of this frame
-     * @param status   the getStatus of this frame
+     * @param status   the status of this frame
      */
     public DefaultSpdyRstStreamFrame(int streamId, SpdyStreamStatus status) {
-        setStreamId(streamId);
+        super(streamId);
         setStatus(status);
     }
 
     @Override
-    public int getStreamId() {
-        return streamId;
+    public SpdyRstStreamFrame setStreamId(int streamId) {
+        super.setStreamId(streamId);
+        return this;
     }
 
     @Override
-    public SpdyRstStreamFrame setStreamId(int streamId) {
-        if (streamId <= 0) {
-            throw new IllegalArgumentException(
-                    "Stream-ID must be positive: " + streamId);
-        }
-        this.streamId = streamId;
+    public SpdyRstStreamFrame setLast(boolean last) {
+        super.setLast(last);
         return this;
     }
 
-    @Override
     public SpdyStreamStatus getStatus() {
         return status;
     }
 
-    @Override
     public SpdyRstStreamFrame setStatus(SpdyStreamStatus status) {
         this.status = status;
         return this;
@@ -78,10 +73,10 @@ public String toString() {
         buf.append(getClass().getSimpleName());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(streamId);
+        buf.append(getStreamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Status: ");
-        buf.append(status.toString());
+        buf.append(getStatus().toString());
         return buf.toString();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java
new file mode 100644
index 000000000000..5353699cc7eb
--- /dev/null
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.spdy;
+
+/**
+ * The default {@link SpdyStreamFrame} implementation.
+ */
+public abstract class DefaultSpdyStreamFrame implements SpdyStreamFrame {
+
+    private int streamId;
+    private boolean last;
+
+    /**
+     * Creates a new instance.
+     *
+     * @param streamId the Stream-ID of this frame
+     */
+    protected DefaultSpdyStreamFrame(int streamId) {
+        setStreamId(streamId);
+    }
+
+    public int getStreamId() {
+        return streamId;
+    }
+
+    public SpdyStreamFrame setStreamId(int streamId) {
+        if (streamId <= 0) {
+            throw new IllegalArgumentException(
+                    "Stream-ID must be positive: " + streamId);
+        }
+        this.streamId = streamId;
+        return this;
+    }
+
+    public boolean isLast() {
+        return last;
+    }
+
+    public SpdyStreamFrame setLast(boolean last) {
+        this.last = last;
+        return this;
+    }
+}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java
index e9858c674cf7..ef5b61033c7f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -20,44 +20,27 @@
 /**
  * The default {@link SpdySynReplyFrame} implementation.
  */
-public class DefaultSpdySynReplyFrame extends DefaultSpdyHeaderBlock
+public class DefaultSpdySynReplyFrame extends DefaultSpdyHeadersFrame
         implements SpdySynReplyFrame {
 
-    private int streamId;
-    private boolean last;
-
     /**
      * Creates a new instance.
      *
      * @param streamId the Stream-ID of this frame
      */
     public DefaultSpdySynReplyFrame(int streamId) {
-        setStreamId(streamId);
-    }
-
-    @Override
-    public int getStreamId() {
-        return streamId;
+        super(streamId);
     }
 
     @Override
     public SpdySynReplyFrame setStreamId(int streamId) {
-        if (streamId <= 0) {
-            throw new IllegalArgumentException(
-                    "Stream-ID must be positive: " + streamId);
-        }
-        this.streamId = streamId;
+        super.setStreamId(streamId);
         return this;
     }
 
-    @Override
-    public boolean isLast() {
-        return last;
-    }
-
     @Override
     public SpdySynReplyFrame setLast(boolean last) {
-        this.last = last;
+        super.setLast(last);
         return this;
     }
 
@@ -76,7 +59,7 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(streamId);
+        buf.append(getStreamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Headers:");
         buf.append(StringUtil.NEWLINE);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java
index 3b0d1290ad8f..c2bba9deb14e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -20,13 +20,11 @@
 /**
  * The default {@link SpdySynStreamFrame} implementation.
  */
-public class DefaultSpdySynStreamFrame extends DefaultSpdyHeaderBlock
+public class DefaultSpdySynStreamFrame extends DefaultSpdyHeadersFrame
         implements SpdySynStreamFrame {
 
-    private int streamId;
     private int associatedToStreamId;
     private byte priority;
-    private boolean last;
     private boolean unidirectional;
 
     /**
@@ -38,23 +36,26 @@ public class DefaultSpdySynStreamFrame extends DefaultSpdyHeaderBlock
      */
     public DefaultSpdySynStreamFrame(
             int streamId, int associatedToStreamId, byte priority) {
-        setStreamId(streamId);
+        super(streamId);
         setAssociatedToStreamId(associatedToStreamId);
         setPriority(priority);
     }
 
     @Override
-    public int getStreamId() {
-        return streamId;
+    public SpdySynStreamFrame setStreamId(int streamId) {
+        super.setStreamId(streamId);
+        return this;
     }
 
     @Override
-    public SpdySynStreamFrame setStreamId(int streamId) {
-        if (streamId <= 0) {
-            throw new IllegalArgumentException(
-                    "Stream-ID must be positive: " + streamId);
-        }
-        this.streamId = streamId;
+    public SpdySynStreamFrame setLast(boolean last) {
+        super.setLast(last);
+        return this;
+    }
+
+    @Override
+    public SpdySynStreamFrame setInvalid() {
+        super.setInvalid();
         return this;
     }
 
@@ -89,17 +90,6 @@ public SpdySynStreamFrame setPriority(byte priority) {
         return this;
     }
 
-    @Override
-    public boolean isLast() {
-        return last;
-    }
-
-    @Override
-    public SpdySynStreamFrame setLast(boolean last) {
-        this.last = last;
-        return this;
-    }
-
     @Override
     public boolean isUnidirectional() {
         return unidirectional;
@@ -111,12 +101,6 @@ public SpdySynStreamFrame setUnidirectional(boolean unidirectional) {
         return this;
     }
 
-    @Override
-    public SpdySynStreamFrame setInvalid() {
-        super.setInvalid();
-        return this;
-    }
-
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
@@ -128,15 +112,15 @@ public String toString() {
         buf.append(')');
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(streamId);
+        buf.append(getStreamId());
         buf.append(StringUtil.NEWLINE);
         if (associatedToStreamId != 0) {
             buf.append("--> Associated-To-Stream-ID = ");
-            buf.append(associatedToStreamId);
+            buf.append(getAssociatedToStreamId());
             buf.append(StringUtil.NEWLINE);
         }
         buf.append("--> Priority = ");
-        buf.append(priority);
+        buf.append(getPriority());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Headers:");
         buf.append(StringUtil.NEWLINE);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java
index 88d18f3c0e6b..b1905ba75d1b 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -43,9 +43,9 @@ public int getStreamId() {
 
     @Override
     public SpdyWindowUpdateFrame setStreamId(int streamId) {
-        if (streamId <= 0) {
+        if (streamId < 0) {
             throw new IllegalArgumentException(
-                    "Stream-ID must be positive: " + streamId);
+                    "Stream-ID cannot be negative: " + streamId);
         }
         this.streamId = streamId;
         return this;
@@ -73,10 +73,10 @@ public String toString() {
         buf.append(getClass().getSimpleName());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Stream-ID = ");
-        buf.append(streamId);
+        buf.append(getStreamId());
         buf.append(StringUtil.NEWLINE);
         buf.append("--> Delta-Window-Size = ");
-        buf.append(deltaWindowSize);
+        buf.append(getDeltaWindowSize());
         return buf.toString();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyControlFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyControlFrame.java
deleted file mode 100644
index 7680ef54df78..000000000000
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyControlFrame.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec.spdy;
-
-/**
- * A SPDY Protocol Control Frame
- */
-public interface SpdyControlFrame extends SpdyDataOrControlFrame {
-    // Tag interface
-}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
index 42909fe30059..ea6d5e6b1948 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -20,9 +20,9 @@
 import io.netty.buffer.Unpooled;
 
 /**
- * A SPDY Protocol Data Frame
+ * A SPDY Protocol DATA Frame
  */
-public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame, SpdyDataOrControlFrame {
+public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame {
 
     @Override
     SpdyDataFrame setStreamId(int streamID);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataOrControlFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrame.java
similarity index 91%
rename from codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataOrControlFrame.java
rename to codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrame.java
index 2d25961c00ca..df0b72f7ebdb 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataOrControlFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrame.java
@@ -13,9 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-
 package io.netty.handler.codec.spdy;
 
-public interface SpdyDataOrControlFrame {
+/**
+ * A SPDY Protocol Frame
+ */
+public interface SpdyFrame {
     // Tag interface
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
index 67b73b1fadbd..7e594b27d4a5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -15,21 +15,12 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.CombinedChannelDuplexHandler;
 
-
 /**
  * A combination of {@link SpdyFrameDecoder} and {@link SpdyFrameEncoder}.
  */
-public final class SpdyFrameCodec
-        extends CombinedChannelDuplexHandler
-        implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<SpdyDataOrControlFrame> {
-
+public final class SpdyFrameCodec extends CombinedChannelDuplexHandler<SpdyFrameDecoder, SpdyFrameEncoder> {
     /**
      * Creates a new instance with the specified {@code version} and
      * the default decoder and encoder options
@@ -51,27 +42,4 @@ public SpdyFrameCodec(
                 new SpdyFrameDecoder(version, maxChunkSize, maxHeaderSize),
                 new SpdyFrameEncoder(version, compressionLevel, windowBits, memLevel));
     }
-
-    private SpdyFrameDecoder decoder() {
-        return (SpdyFrameDecoder) stateHandler();
-    }
-
-    private SpdyFrameEncoder encoder() {
-        return (SpdyFrameEncoder) operationHandler();
-    }
-
-    @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return decoder().newInboundBuffer(ctx);
-    }
-
-    @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        decoder().discardInboundReadBytes(ctx);
-    }
-
-    @Override
-    public MessageBuf<SpdyDataOrControlFrame> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return encoder().newOutboundBuffer(ctx);
-    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
index 6a0de974d116..12df32ad96c5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java
@@ -16,16 +16,16 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 
 /**
- * Decodes {@link ByteBuf}s into SPDY Data and Control Frames.
+ * Decodes {@link ByteBuf}s into SPDY Frames.
  */
 public class SpdyFrameDecoder extends ByteToMessageDecoder {
 
@@ -37,7 +37,7 @@ public class SpdyFrameDecoder extends ByteToMessageDecoder {
 
     private State state;
     private SpdySettingsFrame spdySettingsFrame;
-    private SpdyHeaderBlock spdyHeaderBlock;
+    private SpdyHeadersFrame spdyHeadersFrame;
 
     // SPDY common header fields
     private byte flags;
@@ -94,7 +94,7 @@ public SpdyFrameDecoder(int version, int maxChunkSize, int maxHeaderSize) {
     }
 
     @Override
-    public void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    public void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         try {
             decode(ctx, in, out);
         } finally {
@@ -103,7 +103,7 @@ public void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object>
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageList<Object> out) throws Exception {
         switch(state) {
         case READ_COMMON_HEADER:
             state = readCommonHeader(buffer);
@@ -221,12 +221,12 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
 
         case READ_HEADER_BLOCK_FRAME:
             try {
-                spdyHeaderBlock = readHeaderBlockFrame(buffer);
-                if (spdyHeaderBlock != null) {
+                spdyHeadersFrame = readHeaderBlockFrame(buffer);
+                if (spdyHeadersFrame != null) {
                     if (length == 0) {
                         state = State.READ_COMMON_HEADER;
-                        Object frame = spdyHeaderBlock;
-                        spdyHeaderBlock = null;
+                        Object frame = spdyHeadersFrame;
+                        spdyHeadersFrame = null;
                         out.add(frame);
                         return;
                     }
@@ -247,15 +247,15 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
                 decodeHeaderBlock(buffer.readSlice(compressedBytes));
             } catch (Exception e) {
                 state = State.FRAME_ERROR;
-                spdyHeaderBlock = null;
+                spdyHeadersFrame = null;
                 decompressed = null;
                 ctx.fireExceptionCaught(e);
                 return;
             }
 
-            if (spdyHeaderBlock != null && spdyHeaderBlock.isInvalid()) {
-                Object frame = spdyHeaderBlock;
-                spdyHeaderBlock = null;
+            if (spdyHeadersFrame != null && spdyHeadersFrame.isInvalid()) {
+                Object frame = spdyHeadersFrame;
+                spdyHeadersFrame = null;
                 decompressed = null;
                 if (length == 0) {
                     state = State.READ_COMMON_HEADER;
@@ -265,8 +265,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
             }
 
             if (length == 0) {
-                Object frame = spdyHeaderBlock;
-                spdyHeaderBlock = null;
+                Object frame = spdyHeadersFrame;
+                spdyHeadersFrame = null;
                 state = State.READ_COMMON_HEADER;
                 out.add(frame);
                 return;
@@ -436,7 +436,7 @@ private Object readControlFrame(ByteBuf buffer) {
         }
     }
 
-    private SpdyHeaderBlock readHeaderBlockFrame(ByteBuf buffer) {
+    private SpdyHeadersFrame readHeaderBlockFrame(ByteBuf buffer) {
         int minLength;
         int streamID;
         switch (type) {
@@ -567,7 +567,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
         headerBlockDecompressor.setInput(buffer);
         headerBlockDecompressor.decode(decompressed);
 
-        if (spdyHeaderBlock == null) {
+        if (spdyHeadersFrame == null) {
             // Only decompressing data to keep decompression context in sync
             decompressed = null;
             return;
@@ -582,7 +582,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
             }
             numHeaders = readLengthField();
             if (numHeaders < 0) {
-                spdyHeaderBlock.setInvalid();
+                spdyHeadersFrame.setInvalid();
                 return;
             }
         }
@@ -601,7 +601,7 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
 
             // Recipients of a zero-length name must issue a stream error
             if (nameLength <= 0) {
-                spdyHeaderBlock.setInvalid();
+                spdyHeadersFrame.setInvalid();
                 return;
             }
             headerSize += nameLength;
@@ -621,8 +621,8 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
             String name = new String(nameBytes, "UTF-8");
 
             // Check for identically named headers
-            if (spdyHeaderBlock.headers().contains(name)) {
-                spdyHeaderBlock.setInvalid();
+            if (spdyHeadersFrame.headers().contains(name)) {
+                spdyHeadersFrame.setInvalid();
                 return;
             }
 
@@ -636,17 +636,17 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
 
             // Recipients of illegal value fields must issue a stream error
             if (valueLength < 0) {
-                spdyHeaderBlock.setInvalid();
+                spdyHeadersFrame.setInvalid();
                 return;
             }
 
             // SPDY/3 allows zero-length (empty) header values
             if (valueLength == 0) {
                 if (version < 3) {
-                    spdyHeaderBlock.setInvalid();
+                    spdyHeadersFrame.setInvalid();
                     return;
                 } else {
-                    spdyHeaderBlock.headers().add(name, "");
+                    spdyHeadersFrame.headers().add(name, "");
                     numHeaders --;
                     this.headerSize = headerSize;
                     continue;
@@ -678,16 +678,16 @@ private void decodeHeaderBlock(ByteBuf buffer) throws Exception {
                 if (index < valueBytes.length && valueBytes[index + 1] == (byte) 0) {
                     // Received multiple, in-sequence NULL characters
                     // Recipients of illegal value fields must issue a stream error
-                    spdyHeaderBlock.setInvalid();
+                    spdyHeadersFrame.setInvalid();
                     return;
                 }
                 String value = new String(valueBytes, offset, index - offset, "UTF-8");
 
                 try {
-                    spdyHeaderBlock.headers().add(name, value);
+                    spdyHeadersFrame.headers().add(name, value);
                 } catch (IllegalArgumentException e) {
                     // Name contains NULL or non-ascii characters
-                    spdyHeaderBlock.setInvalid();
+                    spdyHeadersFrame.setInvalid();
                     return;
                 }
                 index ++;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
index 6a866505dfdc..d84a40b28ff0 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -29,12 +29,12 @@
 import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
 
 /**
- * Encodes a SPDY Data or Control Frame into a {@link ByteBuf}.
+ * Encodes a SPDY Frame into a {@link ByteBuf}.
  */
-public class SpdyFrameEncoder extends MessageToByteEncoder<SpdyDataOrControlFrame> {
+public class SpdyFrameEncoder extends MessageToByteEncoder<SpdyFrame> {
 
     private final int version;
-    private volatile boolean finished;
+    private boolean finished;
     private final SpdyHeaderBlockCompressor headerBlockCompressor;
 
     /**
@@ -76,7 +76,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     }
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, SpdyDataOrControlFrame msg, ByteBuf out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, SpdyFrame msg, ByteBuf out) throws Exception {
         if (msg instanceof SpdyDataFrame) {
 
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
@@ -202,13 +202,6 @@ protected void encode(ChannelHandlerContext ctx, SpdyDataOrControlFrame msg, Byt
                 out.writeInt(spdySettingsFrame.getValue(id));
             }
 
-        } else if (msg instanceof SpdyNoOpFrame) {
-
-            out.ensureWritable(SPDY_HEADER_SIZE);
-            out.writeShort(version | 0x8000);
-            out.writeShort(SPDY_NOOP_FRAME);
-            out.writeInt(0);
-
         } else if (msg instanceof SpdyPingFrame) {
 
             SpdyPingFrame spdyPingFrame = (SpdyPingFrame) msg;
@@ -285,7 +278,7 @@ private static void setLengthField(int version, ByteBuf buffer, int writerIndex,
         }
     }
 
-    private static ByteBuf encodeHeaderBlock(int version, SpdyHeaderBlock headerFrame)
+    private static ByteBuf encodeHeaderBlock(int version, SpdyHeadersFrame headerFrame)
             throws Exception {
         Set<String> names = headerFrame.headers().names();
         int numHeaders = names.size();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java
index 2963316760e0..318c6bfe922f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * A SPDY Protocol GOAWAY Control Frame
+ * A SPDY Protocol GOAWAY Frame
  */
-public interface SpdyGoAwayFrame extends SpdyControlFrame {
+public interface SpdyGoAwayFrame extends SpdyFrame {
 
     /**
      * Returns the Last-good-stream-ID of this frame.
@@ -32,12 +32,12 @@ public interface SpdyGoAwayFrame extends SpdyControlFrame {
     SpdyGoAwayFrame setLastGoodStreamId(int lastGoodStreamId);
 
     /**
-     * Returns the getStatus of this frame.
+     * Returns the status of this frame.
      */
     SpdySessionStatus getStatus();
 
     /**
-     * Sets the getStatus of this frame.
+     * Sets the status of this frame.
      */
     SpdyGoAwayFrame setStatus(SpdySessionStatus status);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlock.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlock.java
deleted file mode 100644
index 902cce7c4e9a..000000000000
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlock.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec.spdy;
-
-
-/**
- * A SPDY Name/Value Header Block which provides common properties for
- * {@link SpdySynStreamFrame}, {@link SpdySynReplyFrame}, and
- * {@link SpdyHeadersFrame}.
- * @see SpdyHeaders
- */
-public interface SpdyHeaderBlock {
-
-    /**
-     * Returns {@code true} if this header block is invalid.
-     * A RST_STREAM frame with code PROTOCOL_ERROR should be sent.
-     */
-    boolean isInvalid();
-
-    /**
-     * Marks this header block as invalid.
-     */
-    SpdyHeaderBlock setInvalid();
-
-    /**
-     * Returns the {@link SpdyHeaders}.
-     */
-    SpdyHeaders headers();
-}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
index 6ab424cf22aa..3e073370d2f5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -27,7 +27,7 @@
 
 /**
  * Provides the constants for the standard SPDY HTTP header names and commonly
- * used utility methods that access a {@link SpdyHeaderBlock}.
+ * used utility methods that access a {@link SpdyHeadersFrame}.
  */
 public abstract class SpdyHeaders implements Iterable<Map.Entry<String, String>> {
 
@@ -166,8 +166,8 @@ private Spdy2HttpNames() { }
      *
      * @return the header value or {@code null} if there is no such header
      */
-    public static String getHeader(SpdyHeaderBlock block, String name) {
-        return block.headers().get(name);
+    public static String getHeader(SpdyHeadersFrame frame, String name) {
+        return frame.headers().get(name);
     }
 
     /**
@@ -178,8 +178,8 @@ public static String getHeader(SpdyHeaderBlock block, String name) {
      * @return the header value or the {@code defaultValue} if there is no such
      *         header
      */
-    public static String getHeader(SpdyHeaderBlock block, String name, String defaultValue) {
-        String value = block.headers().get(name);
+    public static String getHeader(SpdyHeadersFrame frame, String name, String defaultValue) {
+        String value = frame.headers().get(name);
         if (value == null) {
             return defaultValue;
         }
@@ -190,66 +190,66 @@ public static String getHeader(SpdyHeaderBlock block, String name, String defaul
      * Sets a new header with the specified name and value.  If there is an
      * existing header with the same name, the existing header is removed.
      */
-    public static void setHeader(SpdyHeaderBlock block, String name, Object value) {
-        block.headers().set(name, value);
+    public static void setHeader(SpdyHeadersFrame frame, String name, Object value) {
+        frame.headers().set(name, value);
     }
 
     /**
      * Sets a new header with the specified name and values.  If there is an
      * existing header with the same name, the existing header is removed.
      */
-    public static void setHeader(SpdyHeaderBlock block, String name, Iterable<?> values) {
-        block.headers().set(name, values);
+    public static void setHeader(SpdyHeadersFrame frame, String name, Iterable<?> values) {
+        frame.headers().set(name, values);
     }
 
     /**
      * Adds a new header with the specified name and value.
      */
-    public static void addHeader(SpdyHeaderBlock block, String name, Object value) {
-        block.headers().add(name, value);
+    public static void addHeader(SpdyHeadersFrame frame, String name, Object value) {
+        frame.headers().add(name, value);
     }
 
     /**
      * Removes the SPDY host header.
      */
-    public static void removeHost(SpdyHeaderBlock block) {
-        block.headers().remove(HttpNames.HOST);
+    public static void removeHost(SpdyHeadersFrame frame) {
+        frame.headers().remove(HttpNames.HOST);
     }
 
     /**
      * Returns the SPDY host header.
      */
-    public static String getHost(SpdyHeaderBlock block) {
-        return block.headers().get(HttpNames.HOST);
+    public static String getHost(SpdyHeadersFrame frame) {
+        return frame.headers().get(HttpNames.HOST);
     }
 
     /**
      * Set the SPDY host header.
      */
-    public static void setHost(SpdyHeaderBlock block, String host) {
-        block.headers().set(HttpNames.HOST, host);
+    public static void setHost(SpdyHeadersFrame frame, String host) {
+        frame.headers().set(HttpNames.HOST, host);
     }
 
     /**
      * Removes the HTTP method header.
      */
-    public static void removeMethod(int spdyVersion, SpdyHeaderBlock block) {
+    public static void removeMethod(int spdyVersion, SpdyHeadersFrame frame) {
         if (spdyVersion < 3) {
-            block.headers().remove(Spdy2HttpNames.METHOD);
+            frame.headers().remove(Spdy2HttpNames.METHOD);
         } else {
-            block.headers().remove(HttpNames.METHOD);
+            frame.headers().remove(HttpNames.METHOD);
         }
     }
 
     /**
      * Returns the {@link HttpMethod} represented by the HTTP method header.
      */
-    public static HttpMethod getMethod(int spdyVersion, SpdyHeaderBlock block) {
+    public static HttpMethod getMethod(int spdyVersion, SpdyHeadersFrame frame) {
         try {
             if (spdyVersion < 3) {
-                return HttpMethod.valueOf(block.headers().get(Spdy2HttpNames.METHOD));
+                return HttpMethod.valueOf(frame.headers().get(Spdy2HttpNames.METHOD));
             } else {
-                return HttpMethod.valueOf(block.headers().get(HttpNames.METHOD));
+                return HttpMethod.valueOf(frame.headers().get(HttpNames.METHOD));
             }
         } catch (Exception e) {
             return null;
@@ -259,68 +259,68 @@ public static HttpMethod getMethod(int spdyVersion, SpdyHeaderBlock block) {
     /**
      * Sets the HTTP method header.
      */
-    public static void setMethod(int spdyVersion, SpdyHeaderBlock block, HttpMethod method) {
+    public static void setMethod(int spdyVersion, SpdyHeadersFrame frame, HttpMethod method) {
         if (spdyVersion < 3) {
-            block.headers().set(Spdy2HttpNames.METHOD, method.name());
+            frame.headers().set(Spdy2HttpNames.METHOD, method.name());
         } else {
-            block.headers().set(HttpNames.METHOD, method.name());
+            frame.headers().set(HttpNames.METHOD, method.name());
         }
     }
 
     /**
      * Removes the URL scheme header.
      */
-    public static void removeScheme(int spdyVersion, SpdyHeaderBlock block) {
+    public static void removeScheme(int spdyVersion, SpdyHeadersFrame frame) {
         if (spdyVersion < 2) {
-            block.headers().remove(Spdy2HttpNames.SCHEME);
+            frame.headers().remove(Spdy2HttpNames.SCHEME);
         } else {
-            block.headers().remove(HttpNames.SCHEME);
+            frame.headers().remove(HttpNames.SCHEME);
         }
     }
 
     /**
      * Returns the value of the URL scheme header.
      */
-    public static String getScheme(int spdyVersion, SpdyHeaderBlock block) {
+    public static String getScheme(int spdyVersion, SpdyHeadersFrame frame) {
         if (spdyVersion < 3) {
-            return block.headers().get(Spdy2HttpNames.SCHEME);
+            return frame.headers().get(Spdy2HttpNames.SCHEME);
         } else {
-            return block.headers().get(HttpNames.SCHEME);
+            return frame.headers().get(HttpNames.SCHEME);
         }
     }
 
     /**
      * Sets the URL scheme header.
      */
-    public static void setScheme(int spdyVersion, SpdyHeaderBlock block, String scheme) {
+    public static void setScheme(int spdyVersion, SpdyHeadersFrame frame, String scheme) {
         if (spdyVersion < 3) {
-            block.headers().set(Spdy2HttpNames.SCHEME, scheme);
+            frame.headers().set(Spdy2HttpNames.SCHEME, scheme);
         } else {
-            block.headers().set(HttpNames.SCHEME, scheme);
+            frame.headers().set(HttpNames.SCHEME, scheme);
         }
     }
 
     /**
      * Removes the HTTP response status header.
      */
-    public static void removeStatus(int spdyVersion, SpdyHeaderBlock block) {
+    public static void removeStatus(int spdyVersion, SpdyHeadersFrame frame) {
         if (spdyVersion < 3) {
-            block.headers().remove(Spdy2HttpNames.STATUS);
+            frame.headers().remove(Spdy2HttpNames.STATUS);
         } else {
-            block.headers().remove(HttpNames.STATUS);
+            frame.headers().remove(HttpNames.STATUS);
         }
     }
 
     /**
      * Returns the {@link HttpResponseStatus} represented by the HTTP response status header.
      */
-    public static HttpResponseStatus getStatus(int spdyVersion, SpdyHeaderBlock block) {
+    public static HttpResponseStatus getStatus(int spdyVersion, SpdyHeadersFrame frame) {
         try {
             String status;
             if (spdyVersion < 3) {
-                status = block.headers().get(Spdy2HttpNames.STATUS);
+                status = frame.headers().get(Spdy2HttpNames.STATUS);
             } else {
-                status = block.headers().get(HttpNames.STATUS);
+                status = frame.headers().get(HttpNames.STATUS);
             }
             int space = status.indexOf(' ');
             if (space == -1) {
@@ -343,67 +343,67 @@ public static HttpResponseStatus getStatus(int spdyVersion, SpdyHeaderBlock bloc
     /**
      * Sets the HTTP response status header.
      */
-    public static void setStatus(int spdyVersion, SpdyHeaderBlock block, HttpResponseStatus status) {
+    public static void setStatus(int spdyVersion, SpdyHeadersFrame frame, HttpResponseStatus status) {
         if (spdyVersion < 3) {
-            block.headers().set(Spdy2HttpNames.STATUS, status.toString());
+            frame.headers().set(Spdy2HttpNames.STATUS, status.toString());
         } else {
-            block.headers().set(HttpNames.STATUS, status.toString());
+            frame.headers().set(HttpNames.STATUS, status.toString());
         }
     }
 
     /**
      * Removes the URL path header.
      */
-    public static void removeUrl(int spdyVersion, SpdyHeaderBlock block) {
+    public static void removeUrl(int spdyVersion, SpdyHeadersFrame frame) {
         if (spdyVersion < 3) {
-            block.headers().remove(Spdy2HttpNames.URL);
+            frame.headers().remove(Spdy2HttpNames.URL);
         } else {
-            block.headers().remove(HttpNames.PATH);
+            frame.headers().remove(HttpNames.PATH);
         }
     }
 
     /**
      * Returns the value of the URL path header.
      */
-    public static String getUrl(int spdyVersion, SpdyHeaderBlock block) {
+    public static String getUrl(int spdyVersion, SpdyHeadersFrame frame) {
         if (spdyVersion < 3) {
-            return block.headers().get(Spdy2HttpNames.URL);
+            return frame.headers().get(Spdy2HttpNames.URL);
         } else {
-            return block.headers().get(HttpNames.PATH);
+            return frame.headers().get(HttpNames.PATH);
         }
     }
 
     /**
      * Sets the URL path header.
      */
-    public static void setUrl(int spdyVersion, SpdyHeaderBlock block, String path) {
+    public static void setUrl(int spdyVersion, SpdyHeadersFrame frame, String path) {
         if (spdyVersion < 3) {
-            block.headers().set(Spdy2HttpNames.URL, path);
+            frame.headers().set(Spdy2HttpNames.URL, path);
         } else {
-            block.headers().set(HttpNames.PATH, path);
+            frame.headers().set(HttpNames.PATH, path);
         }
     }
 
     /**
      * Removes the HTTP version header.
      */
-    public static void removeVersion(int spdyVersion, SpdyHeaderBlock block) {
+    public static void removeVersion(int spdyVersion, SpdyHeadersFrame frame) {
         if (spdyVersion < 3) {
-            block.headers().remove(Spdy2HttpNames.VERSION);
+            frame.headers().remove(Spdy2HttpNames.VERSION);
         } else {
-            block.headers().remove(HttpNames.VERSION);
+            frame.headers().remove(HttpNames.VERSION);
         }
     }
 
     /**
      * Returns the {@link HttpVersion} represented by the HTTP version header.
      */
-    public static HttpVersion getVersion(int spdyVersion, SpdyHeaderBlock block) {
+    public static HttpVersion getVersion(int spdyVersion, SpdyHeadersFrame frame) {
         try {
             if (spdyVersion < 3) {
-                return HttpVersion.valueOf(block.headers().get(Spdy2HttpNames.VERSION));
+                return HttpVersion.valueOf(frame.headers().get(Spdy2HttpNames.VERSION));
             } else {
-                return HttpVersion.valueOf(block.headers().get(HttpNames.VERSION));
+                return HttpVersion.valueOf(frame.headers().get(HttpNames.VERSION));
             }
         } catch (Exception e) {
             return null;
@@ -413,11 +413,11 @@ public static HttpVersion getVersion(int spdyVersion, SpdyHeaderBlock block) {
     /**
      * Sets the HTTP version header.
      */
-    public static void setVersion(int spdyVersion, SpdyHeaderBlock block, HttpVersion httpVersion) {
+    public static void setVersion(int spdyVersion, SpdyHeadersFrame frame, HttpVersion httpVersion) {
         if (spdyVersion < 3) {
-            block.headers().set(Spdy2HttpNames.VERSION, httpVersion.text());
+            frame.headers().set(Spdy2HttpNames.VERSION, httpVersion.text());
         } else {
-            block.headers().set(HttpNames.VERSION, httpVersion.text());
+            frame.headers().set(HttpNames.VERSION, httpVersion.text());
         }
     }
     @Override
@@ -443,7 +443,7 @@ public Iterator<Map.Entry<String, String>> iterator() {
     public abstract  List<String> getAll(String name);
 
     /**
-     * Returns all header names and values that this block contains.
+     * Returns all header names and values that this frame contains.
      *
      * @return the {@link List} of the header name-value pairs.  An empty list
      *         if there is no header in this message.
@@ -457,7 +457,7 @@ public Iterator<Map.Entry<String, String>> iterator() {
     public abstract  boolean contains(String name);
 
     /**
-     * Returns the {@link Set} of all header names that this block contains.
+     * Returns the {@link Set} of all header names that this frame contains.
      */
     public abstract Set<String> names();
 
@@ -490,7 +490,7 @@ public Iterator<Map.Entry<String, String>> iterator() {
     public abstract SpdyHeaders remove(String name);
 
     /**
-     * Removes all headers from this block.
+     * Removes all headers from this frame.
      */
     public abstract SpdyHeaders clear();
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeadersFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeadersFrame.java
index 28a7956abb3d..7c587f969b51 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeadersFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeadersFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,17 +16,29 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * A SPDY Protocol HEADERS Control Frame
+ * A SPDY Protocol HEADERS Frame
  */
-public interface SpdyHeadersFrame extends SpdyHeaderBlock, SpdyControlFrame, SpdyStreamFrame {
+public interface SpdyHeadersFrame extends SpdyStreamFrame {
+
+    /**
+     * Returns {@code true} if this header block is invalid.
+     * A RST_STREAM frame with code PROTOCOL_ERROR should be sent.
+     */
+    boolean isInvalid();
+
+    /**
+     * Marks this header block as invalid.
+     */
+    SpdyHeadersFrame setInvalid();
+
+    /**
+     * Returns the {@link SpdyHeaders}.
+     */
+    SpdyHeaders headers();
 
     @Override
     SpdyHeadersFrame setStreamId(int streamID);
 
     @Override
     SpdyHeadersFrame setLast(boolean last);
-
-    @Override
-    SpdyHeadersFrame setInvalid();
-
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
index cfb73bf528f7..86bfea22e76d 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -15,43 +15,17 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.CombinedChannelDuplexHandler;
-import io.netty.handler.codec.http.HttpObject;
-
 
 /**
  * A combination of {@link SpdyHttpDecoder} and {@link SpdyHttpEncoder}
  */
 public final class SpdyHttpCodec
-        extends CombinedChannelDuplexHandler
-        implements ChannelInboundMessageHandler<SpdyDataOrControlFrame>, ChannelOutboundMessageHandler<HttpObject> {
-
+        extends CombinedChannelDuplexHandler<SpdyHttpDecoder, SpdyHttpEncoder> {
     /**
      * Creates a new instance with the specified decoder options.
      */
     public SpdyHttpCodec(int version, int maxContentLength) {
         super(new SpdyHttpDecoder(version, maxContentLength), new SpdyHttpEncoder(version));
     }
-
-    private SpdyHttpDecoder decoder() {
-        return (SpdyHttpDecoder) stateHandler();
-    }
-
-    private SpdyHttpEncoder encoder() {
-        return (SpdyHttpEncoder) operationHandler();
-    }
-
-    @Override
-    public MessageBuf<SpdyDataOrControlFrame> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return decoder().newInboundBuffer(ctx);
-    }
-
-    @Override
-    public MessageBuf<HttpObject> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return encoder().newOutboundBuffer(ctx);
-    }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
index ee0874f16ad3..0e256efcb6fa 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.MessageToMessageDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
@@ -37,7 +37,7 @@
  * Decodes {@link SpdySynStreamFrame}s, {@link SpdySynReplyFrame}s,
  * and {@link SpdyDataFrame}s into {@link FullHttpRequest}s and {@link FullHttpResponse}s.
  */
-public class SpdyHttpDecoder extends MessageToMessageDecoder<SpdyDataOrControlFrame> {
+public class SpdyHttpDecoder extends MessageToMessageDecoder<SpdyFrame> {
 
     private final int spdyVersion;
     private final int maxContentLength;
@@ -91,7 +91,7 @@ protected FullHttpMessage removeMessage(int streamId) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, SpdyDataOrControlFrame msg, MessageBuf<Object> out)
+    protected void decode(ChannelHandlerContext ctx, SpdyFrame msg, MessageList<Object> out)
             throws Exception {
         if (msg instanceof SpdySynStreamFrame) {
 
@@ -252,7 +252,7 @@ protected void decode(ChannelHandlerContext ctx, SpdyDataOrControlFrame msg, Mes
         }
     }
 
-    private static FullHttpRequest createHttpRequest(int spdyVersion, SpdyHeaderBlock requestFrame)
+    private static FullHttpRequest createHttpRequest(int spdyVersion, SpdyHeadersFrame requestFrame)
             throws Exception {
         // Create the first line of the request from the name/value pairs
         HttpMethod  method      = SpdyHeaders.getMethod(spdyVersion, requestFrame);
@@ -287,7 +287,7 @@ private static FullHttpRequest createHttpRequest(int spdyVersion, SpdyHeaderBloc
         return req;
     }
 
-    private static FullHttpResponse createHttpResponse(int spdyVersion, SpdyHeaderBlock responseFrame)
+    private static FullHttpResponse createHttpResponse(int spdyVersion, SpdyHeadersFrame responseFrame)
             throws Exception {
         // Create the first line of the response from the name/value pairs
         HttpResponseStatus status = SpdyHeaders.getStatus(spdyVersion, responseFrame);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
index 7400a0822721..8f44e91afd69 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.MessageToMessageEncoder;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -123,7 +123,7 @@
 public class SpdyHttpEncoder extends MessageToMessageEncoder<HttpObject> {
 
     private final int spdyVersion;
-    private volatile int currentStreamId;
+    private int currentStreamId;
 
     /**
      * Creates a new instance.
@@ -139,7 +139,7 @@ public SpdyHttpEncoder(int version) {
     }
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageBuf<Object> out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {
 
         boolean valid = false;
 
@@ -266,7 +266,7 @@ private SpdySynReplyFrame createSynReplyFrame(HttpResponse httpResponse)
         int streamID = SpdyHttpHeaders.getStreamId(httpResponse);
         SpdyHttpHeaders.removeStreamId(httpResponse);
 
-        // The Connection, Keep-Alive, Proxy-Connection, and Transfer-ENcoding
+        // The Connection, Keep-Alive, Proxy-Connection, and Transfer-Encoding
         // headers are not valid and MUST not be sent.
         httpResponse.headers().remove(HttpHeaders.Names.CONNECTION);
         httpResponse.headers().remove("Keep-Alive");
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
index cb18684d67e9..b30d8484652f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java
@@ -15,9 +15,9 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.buffer.BufUtil;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.MessageToMessageCodec;
 import io.netty.handler.codec.http.HttpMessage;
 
@@ -40,17 +40,17 @@ public boolean acceptInboundMessage(Object msg) throws Exception {
     }
 
     @Override
-    protected void encode(ChannelHandlerContext ctx, HttpMessage msg, MessageBuf<Object> out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, HttpMessage msg, MessageList<Object> out) throws Exception {
         Integer id = ids.poll();
         if (id != null && id.intValue() != NO_ID && !msg.headers().contains(SpdyHttpHeaders.Names.STREAM_ID)) {
             SpdyHttpHeaders.setStreamId(msg, id);
         }
 
-        out.add(BufUtil.retain(msg));
+        out.add(ByteBufUtil.retain(msg));
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, Object msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, Object msg, MessageList<Object> out) throws Exception {
         if (msg instanceof HttpMessage) {
             boolean contains = ((HttpMessage) msg).headers().contains(SpdyHttpHeaders.Names.STREAM_ID);
             if (!contains) {
@@ -62,6 +62,6 @@ protected void decode(ChannelHandlerContext ctx, Object msg, MessageBuf<Object>
             ids.remove(((SpdyRstStreamFrame) msg).getStreamId());
         }
 
-        out.add(BufUtil.retain(msg));
+        out.add(ByteBufUtil.retain(msg));
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyNoOpFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyNoOpFrame.java
deleted file mode 100644
index 31b6e11a0b59..000000000000
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyNoOpFrame.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec.spdy;
-
-/**
- * A SPDY Protocol NOOP Control Frame
- */
-public interface SpdyNoOpFrame extends SpdyControlFrame {
-    // Tag interface
-}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
index 9baca054ebbd..b14fec68fff5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java
@@ -15,14 +15,12 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
-import io.netty.channel.ChannelInboundMessageHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
@@ -31,11 +29,11 @@
 import javax.net.ssl.SSLEngine;
 
 /**
- * {@link ChannelInboundByteHandler} which is responsible to setup the {@link ChannelPipeline} either for
+ * {@link ChannelInboundHandler} which is responsible to setup the {@link ChannelPipeline} either for
  * HTTP or SPDY. This offers an easy way for users to support both at the same time while not care to
  * much about the low-level details.
  */
-public abstract class SpdyOrHttpChooser extends ChannelInboundByteHandlerAdapter {
+public abstract class SpdyOrHttpChooser extends ChannelInboundHandlerAdapter {
 
     // TODO: Replace with generic NPN handler
 
@@ -63,25 +61,13 @@ protected SpdyOrHttpChooser(int maxSpdyContentLength, int maxHttpContentLength)
     protected abstract SelectedProtocol getProtocol(SSLEngine engine);
 
     @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx);
-    }
-
-    @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        // No need to discard anything because this handler will be replaced with something else very quickly.
-    }
-
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> in) throws Exception {
         if (initPipeline(ctx)) {
-            ctx.nextInboundByteBuffer().writeBytes(in);
-
             // When we reached here we can remove this handler as its now clear what protocol we want to use
             // from this point on.
             ctx.pipeline().remove(this);
 
-            ctx.fireInboundBufferUpdated();
+            ctx.fireMessageReceived(in);
         }
     }
 
@@ -140,21 +126,21 @@ protected void addHttpHandlers(ChannelHandlerContext ctx) {
     }
 
     /**
-     * Create the {@link ChannelInboundMessageHandler} that is responsible for handling the http requests
+     * Create the {@link ChannelInboundHandler} that is responsible for handling the http requests
      * when the {@link SelectedProtocol} was {@link SelectedProtocol#HTTP_1_0} or
      * {@link SelectedProtocol#HTTP_1_1}
      */
-    protected abstract ChannelInboundMessageHandler<?> createHttpRequestHandlerForHttp();
+    protected abstract ChannelInboundHandler createHttpRequestHandlerForHttp();
 
     /**
-     * Create the {@link ChannelInboundMessageHandler} that is responsible for handling the http responses
+     * Create the {@link ChannelInboundHandler} that is responsible for handling the http responses
      * when the {@link SelectedProtocol} was {@link SelectedProtocol#SPDY_2} or
      * {@link SelectedProtocol#SPDY_3}.
      *
      * Bye default this getMethod will just delecate to {@link #createHttpRequestHandlerForHttp()}, but
      * sub-classes may override this to change the behaviour.
      */
-    protected ChannelInboundMessageHandler<?> createHttpRequestHandlerForSpdy() {
+    protected ChannelInboundHandler createHttpRequestHandlerForSpdy() {
         return createHttpRequestHandlerForHttp();
     }
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java
index 63c582e8da46..d2e98e67b9a3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * A SPDY Protocol PING Control Frame
+ * A SPDY Protocol PING Frame
  */
-public interface SpdyPingFrame extends SpdyControlFrame {
+public interface SpdyPingFrame extends SpdyFrame {
 
     /**
      * Returns the ID of this frame.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java
index 06af326aead0..fbab068e8daa 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyRstStreamFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,27 +16,23 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * A SPDY Protocol RST_STREAM Control Frame
+ * A SPDY Protocol RST_STREAM Frame
  */
-public interface SpdyRstStreamFrame extends SpdyControlFrame {
+public interface SpdyRstStreamFrame extends SpdyStreamFrame {
 
     /**
-     * Returns the Stream-ID of this frame.
+     * Returns the status of this frame.
      */
-    int getStreamId();
+    SpdyStreamStatus getStatus();
 
     /**
-     * Sets the Stream-ID of this frame.  The Stream-ID must be positive.
+     * Sets the status of this frame.
      */
-    SpdyControlFrame setStreamId(int streamID);
+    SpdyRstStreamFrame setStatus(SpdyStreamStatus status);
 
-    /**
-     * Returns the getStatus of this frame.
-     */
-    SpdyStreamStatus getStatus();
+    @Override
+    SpdyRstStreamFrame setStreamId(int streamId);
 
-    /**
-     * Sets the getStatus of this frame.
-     */
-    SpdyControlFrame setStatus(SpdyStreamStatus status);
+    @Override
+    SpdyRstStreamFrame setLast(boolean last);
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
index 3674b20dc48e..0de5c6dec1a4 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java
@@ -167,12 +167,12 @@ Object removePendingWrite(int streamID) {
     private static final class StreamState {
 
         private final byte priority;
-        private volatile boolean remoteSideClosed;
-        private volatile boolean localSideClosed;
+        private boolean remoteSideClosed;
+        private boolean localSideClosed;
         private boolean receivedReply;
         private final AtomicInteger sendWindowSize;
         private final AtomicInteger receiveWindowSize;
-        private volatile int receiveWindowSizeLowerBound;
+        private int receiveWindowSizeLowerBound;
         private final Queue<Object> pendingWriteQueue = new ConcurrentLinkedQueue<Object>();
 
         StreamState(
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
index 089199d99dba..9add62a38a80 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -15,15 +15,12 @@
  */
 package io.netty.handler.codec.spdy;
 
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.util.internal.EmptyArrays;
 
 import java.util.concurrent.atomic.AtomicInteger;
@@ -32,8 +29,7 @@
  * Manages streams within a SPDY session.
  */
 public class SpdySessionHandler
-        extends ChannelDuplexHandler
-        implements ChannelInboundMessageHandler<Object>, ChannelOutboundMessageHandler<Object> {
+        extends ChannelDuplexHandler {
 
     private static final SpdyProtocolException PROTOCOL_EXCEPTION = new SpdyProtocolException();
     private static final SpdyProtocolException STREAM_CLOSED = new SpdyProtocolException("Stream closed");
@@ -44,24 +40,24 @@ public class SpdySessionHandler
     }
 
     private final SpdySession spdySession = new SpdySession();
-    private volatile int lastGoodStreamId;
+    private int lastGoodStreamId;
 
-    private volatile int remoteConcurrentStreams;
-    private volatile int localConcurrentStreams;
-    private volatile int maxConcurrentStreams;
+    private int remoteConcurrentStreams;
+    private int localConcurrentStreams;
+    private int maxConcurrentStreams;
 
     private static final int DEFAULT_WINDOW_SIZE = 64 * 1024; // 64 KB default initial window size
-    private volatile int initialSendWindowSize = DEFAULT_WINDOW_SIZE;
-    private volatile int initialReceiveWindowSize = DEFAULT_WINDOW_SIZE;
+    private int initialSendWindowSize = DEFAULT_WINDOW_SIZE;
+    private int initialReceiveWindowSize = DEFAULT_WINDOW_SIZE;
 
     private final Object flowControlLock = new Object();
 
     private final AtomicInteger pings = new AtomicInteger();
 
-    private volatile boolean sentGoAwayFrame;
-    private volatile boolean receivedGoAwayFrame;
+    private boolean sentGoAwayFrame;
+    private boolean receivedGoAwayFrame;
 
-    private volatile ChannelPromise closeSessionFuture;
+    private ChannelPromise closeSessionFuture;
 
     private final boolean server;
     private final boolean flowControl;
@@ -85,21 +81,11 @@ public SpdySessionHandler(int version, boolean server) {
     }
 
     @Override
-    public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return Unpooled.messageBuffer();
-    }
-
-    @Override
-    public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return Unpooled.messageBuffer();
-    }
-
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        MessageBuf<Object> in = ctx.inboundMessageBuffer();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> in) throws Exception {
         boolean handled = false;
-        for (;;) {
-            Object msg = in.poll();
+        MessageList<Object> out = MessageList.newInstance();
+        for (int i = 0 ; i < in.size(); i++) {
+            Object msg = in.get(i);
             if (msg == null) {
                 break;
             }
@@ -108,18 +94,20 @@ public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
                 // Let the next handlers handle the buffered messages before SYN_STREAM message updates the
                 // lastGoodStreamId.
                 if (handled) {
-                    ctx.fireInboundBufferUpdated();
+                    ctx.fireMessageReceived(out);
+                    out = MessageList.newInstance();
                 }
             }
 
-            handleInboundMessage(ctx, msg);
+            handleInboundMessage(ctx, msg, out);
             handled = true;
         }
 
-        ctx.fireInboundBufferUpdated();
+        in.recycle();
+        ctx.fireMessageReceived(out);
     }
 
-    private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws Exception {
+    private void handleInboundMessage(ChannelHandlerContext ctx, Object msg, MessageList<Object> out) throws Exception {
 
         if (msg instanceof SpdyDataFrame) {
 
@@ -147,27 +135,29 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
              */
 
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-            int streamID = spdyDataFrame.getStreamId();
+            int streamId = spdyDataFrame.getStreamId();
 
             // Check if we received a data frame for a Stream-ID which is not open
-            if (!spdySession.isActiveStream(streamID)) {
-                if (streamID <= lastGoodStreamId) {
-                    issueStreamError(ctx, streamID, SpdyStreamStatus.PROTOCOL_ERROR);
+
+            if (!spdySession.isActiveStream(streamId)) {
+                if (streamId <= lastGoodStreamId) {
+                    issueStreamError(ctx, streamId, SpdyStreamStatus.PROTOCOL_ERROR, out);
                 } else if (!sentGoAwayFrame) {
-                    issueStreamError(ctx, streamID, SpdyStreamStatus.INVALID_STREAM);
+                    issueStreamError(ctx, streamId, SpdyStreamStatus.INVALID_STREAM, out);
                 }
                 return;
             }
 
             // Check if we received a data frame for a stream which is half-closed
-            if (spdySession.isRemoteSideClosed(streamID)) {
-                issueStreamError(ctx, streamID, SpdyStreamStatus.STREAM_ALREADY_CLOSED);
+
+            if (spdySession.isRemoteSideClosed(streamId)) {
+                issueStreamError(ctx, streamId, SpdyStreamStatus.STREAM_ALREADY_CLOSED, out);
                 return;
             }
 
             // Check if we received a data frame before receiving a SYN_REPLY
-            if (!isRemoteInitiatedID(streamID) && !spdySession.hasReceivedReply(streamID)) {
-                issueStreamError(ctx, streamID, SpdyStreamStatus.PROTOCOL_ERROR);
+            if (!isRemoteInitiatedID(streamId) && !spdySession.hasReceivedReply(streamId)) {
+                issueStreamError(ctx, streamId, SpdyStreamStatus.PROTOCOL_ERROR, out);
                 return;
             }
 
@@ -180,15 +170,15 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
             if (flowControl) {
                 // Update receive window size
                 int deltaWindowSize = -1 * spdyDataFrame.content().readableBytes();
-                int newWindowSize = spdySession.updateReceiveWindowSize(streamID, deltaWindowSize);
+                int newWindowSize = spdySession.updateReceiveWindowSize(streamId, deltaWindowSize);
 
                 // Window size can become negative if we sent a SETTINGS frame that reduces the
                 // size of the transfer window after the peer has written data frames.
                 // The value is bounded by the length that SETTINGS frame decrease the window.
                 // This difference is stored for the session when writing the SETTINGS frame
                 // and is cleared once we send a WINDOW_UPDATE frame.
-                if (newWindowSize < spdySession.getReceiveWindowSizeLowerBound(streamID)) {
-                    issueStreamError(ctx, streamID, SpdyStreamStatus.FLOW_CONTROL_ERROR);
+                if (newWindowSize < spdySession.getReceiveWindowSizeLowerBound(streamId)) {
+                    issueStreamError(ctx, streamId, SpdyStreamStatus.FLOW_CONTROL_ERROR, out);
                     return;
                 }
 
@@ -196,26 +186,25 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
                 // Send data frames upstream in initialReceiveWindowSize chunks
                 if (newWindowSize < 0) {
                     while (spdyDataFrame.content().readableBytes() > initialReceiveWindowSize) {
-                        SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamID,
+                        SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamId,
                                 spdyDataFrame.content().readSlice(initialReceiveWindowSize).retain());
-                        ctx.nextOutboundMessageBuffer().add(partialDataFrame);
-                        ctx.flush();
+                        ctx.write(partialDataFrame);
                     }
                 }
 
                 // Send a WINDOW_UPDATE frame if less than half the window size remains
                 if (newWindowSize <= initialReceiveWindowSize / 2 && !spdyDataFrame.isLast()) {
                     deltaWindowSize = initialReceiveWindowSize - newWindowSize;
-                    spdySession.updateReceiveWindowSize(streamID, deltaWindowSize);
+                    spdySession.updateReceiveWindowSize(streamId, deltaWindowSize);
                     SpdyWindowUpdateFrame spdyWindowUpdateFrame =
-                            new DefaultSpdyWindowUpdateFrame(streamID, deltaWindowSize);
+                            new DefaultSpdyWindowUpdateFrame(streamId, deltaWindowSize);
                     ctx.write(spdyWindowUpdateFrame);
                 }
             }
 
             // Close the remote side of the stream if this is the last frame
             if (spdyDataFrame.isLast()) {
-                halfCloseStream(streamID, true);
+                halfCloseStream(streamId, true);
             }
 
         } else if (msg instanceof SpdySynStreamFrame) {
@@ -235,18 +224,18 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
              */
 
             SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
-            int streamID = spdySynStreamFrame.getStreamId();
+            int streamId = spdySynStreamFrame.getStreamId();
 
             // Check if we received a valid SYN_STREAM frame
             if (spdySynStreamFrame.isInvalid() ||
-                !isRemoteInitiatedID(streamID) ||
-                spdySession.isActiveStream(streamID)) {
-                issueStreamError(ctx, streamID, SpdyStreamStatus.PROTOCOL_ERROR);
+                !isRemoteInitiatedID(streamId) ||
+                spdySession.isActiveStream(streamId)) {
+                issueStreamError(ctx, streamId, SpdyStreamStatus.PROTOCOL_ERROR, out);
                 return;
             }
 
             // Stream-IDs must be monotonically increasing
-            if (streamID <= lastGoodStreamId) {
+            if (streamId <= lastGoodStreamId) {
                 issueSessionError(ctx, SpdySessionStatus.PROTOCOL_ERROR);
                 return;
             }
@@ -255,8 +244,8 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
             byte priority = spdySynStreamFrame.getPriority();
             boolean remoteSideClosed = spdySynStreamFrame.isLast();
             boolean localSideClosed = spdySynStreamFrame.isUnidirectional();
-            if (!acceptStream(streamID, priority, remoteSideClosed, localSideClosed)) {
-                issueStreamError(ctx, streamID, SpdyStreamStatus.REFUSED_STREAM);
+            if (!acceptStream(streamId, priority, remoteSideClosed, localSideClosed)) {
+                issueStreamError(ctx, streamId, SpdyStreamStatus.REFUSED_STREAM, out);
                 return;
             }
 
@@ -270,27 +259,27 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
              */
 
             SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
-            int streamID = spdySynReplyFrame.getStreamId();
+            int streamId = spdySynReplyFrame.getStreamId();
 
             // Check if we received a valid SYN_REPLY frame
             if (spdySynReplyFrame.isInvalid() ||
-                isRemoteInitiatedID(streamID) ||
-                spdySession.isRemoteSideClosed(streamID)) {
-                issueStreamError(ctx, streamID, SpdyStreamStatus.INVALID_STREAM);
+                isRemoteInitiatedID(streamId) ||
+                spdySession.isRemoteSideClosed(streamId)) {
+                issueStreamError(ctx, streamId, SpdyStreamStatus.INVALID_STREAM, out);
                 return;
             }
 
             // Check if we have received multiple frames for the same Stream-ID
-            if (spdySession.hasReceivedReply(streamID)) {
-                issueStreamError(ctx, streamID, SpdyStreamStatus.STREAM_IN_USE);
+            if (spdySession.hasReceivedReply(streamId)) {
+                issueStreamError(ctx, streamId, SpdyStreamStatus.STREAM_IN_USE, out);
                 return;
             }
 
-            spdySession.receivedReply(streamID);
+            spdySession.receivedReply(streamId);
 
             // Close the remote side of the stream if this is the last frame
             if (spdySynReplyFrame.isLast()) {
-                halfCloseStream(streamID, true);
+                halfCloseStream(streamId, true);
             }
 
         } else if (msg instanceof SpdyRstStreamFrame) {
@@ -364,22 +353,22 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
         } else if (msg instanceof SpdyHeadersFrame) {
 
             SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-            int streamID = spdyHeadersFrame.getStreamId();
+            int streamId = spdyHeadersFrame.getStreamId();
 
             // Check if we received a valid HEADERS frame
             if (spdyHeadersFrame.isInvalid()) {
-                issueStreamError(ctx, streamID, SpdyStreamStatus.PROTOCOL_ERROR);
+                issueStreamError(ctx, streamId, SpdyStreamStatus.PROTOCOL_ERROR, out);
                 return;
             }
 
-            if (spdySession.isRemoteSideClosed(streamID)) {
-                issueStreamError(ctx, streamID, SpdyStreamStatus.INVALID_STREAM);
+            if (spdySession.isRemoteSideClosed(streamId)) {
+                issueStreamError(ctx, streamId, SpdyStreamStatus.INVALID_STREAM, out);
                 return;
             }
 
             // Close the remote side of the stream if this is the last frame
             if (spdyHeadersFrame.isLast()) {
-                halfCloseStream(streamID, true);
+                halfCloseStream(streamId, true);
             }
 
         } else if (msg instanceof SpdyWindowUpdateFrame) {
@@ -396,25 +385,25 @@ private void handleInboundMessage(ChannelHandlerContext ctx, Object msg) throws
 
             if (flowControl) {
                 SpdyWindowUpdateFrame spdyWindowUpdateFrame = (SpdyWindowUpdateFrame) msg;
-                int streamID = spdyWindowUpdateFrame.getStreamId();
+                int streamId = spdyWindowUpdateFrame.getStreamId();
                 int deltaWindowSize = spdyWindowUpdateFrame.getDeltaWindowSize();
 
                 // Ignore frames for half-closed streams
-                if (spdySession.isLocalSideClosed(streamID)) {
+                if (spdySession.isLocalSideClosed(streamId)) {
                     return;
                 }
 
                 // Check for numerical overflow
-                if (spdySession.getSendWindowSize(streamID) > Integer.MAX_VALUE - deltaWindowSize) {
-                    issueStreamError(ctx, streamID, SpdyStreamStatus.FLOW_CONTROL_ERROR);
+                if (spdySession.getSendWindowSize(streamId) > Integer.MAX_VALUE - deltaWindowSize) {
+                    issueStreamError(ctx, streamId, SpdyStreamStatus.FLOW_CONTROL_ERROR, out);
                     return;
                 }
 
-                updateSendWindowSize(ctx, streamID, deltaWindowSize);
+                updateSendWindowSize(streamId, deltaWindowSize, out);
             }
         }
 
-        ctx.nextInboundMessageBuffer().add(msg);
+        out.add(msg);
     }
 
     @Override
@@ -432,10 +421,10 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        MessageBuf<Object> in = ctx.outboundMessageBuffer();
-        for (;;) {
-            Object msg = in.poll();
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        MessageList<Object> out = MessageList.newInstance();
+        for (int i = 0; i < msgs.size(); i++) {
+            Object msg = msgs.get(i);
             if (msg == null) {
                 break;
             }
@@ -449,31 +438,33 @@ public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce
                     msg instanceof SpdyHeadersFrame ||
                     msg instanceof SpdyWindowUpdateFrame) {
                 try {
-                    handleOutboundMessage(ctx, msg);
+                    handleOutboundMessage(ctx, msg, out);
                 } catch (SpdyProtocolException e) {
                     if (e == PROTOCOL_EXCEPTION) {
-                        // on the case of PROTOCOL_EXCEPTION faile the promise directly
+                        // on the case of PROTOCOL_EXCEPTION, fail the promise directly
                         // See #1211
                         promise.setFailure(PROTOCOL_EXCEPTION);
                         return;
                     }
                 }
             } else {
-                ctx.nextOutboundMessageBuffer().add(msg);
+                out.add(msg);
             }
         }
-        ctx.flush(promise);
-    }
 
-    private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws Exception {
+        msgs.recycle();
+        ctx.write(out, promise);
+    }
 
+    private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg, MessageList<Object> out)
+            throws Exception {
         if (msg instanceof SpdyDataFrame) {
 
             SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-            final int streamID = spdyDataFrame.getStreamId();
+            final int streamId = spdyDataFrame.getStreamId();
 
             // Frames must not be sent on half-closed streams
-            if (spdySession.isLocalSideClosed(streamID)) {
+            if (spdySession.isLocalSideClosed(streamId)) {
                 throw PROTOCOL_EXCEPTION;
             }
 
@@ -493,11 +484,22 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws
             if (flowControl) {
                 synchronized (flowControlLock) {
                     int dataLength = spdyDataFrame.content().readableBytes();
-                    int sendWindowSize = spdySession.getSendWindowSize(streamID);
+                    int sendWindowSize = spdySession.getSendWindowSize(streamId);
 
-                    if (sendWindowSize >= dataLength) {
-                        // Window size is large enough to send entire data frame
-                        spdySession.updateSendWindowSize(streamID, -1 * dataLength);
+                    if (sendWindowSize <= 0) {
+                        // Stream is stalled -- enqueue Data frame and return
+                        spdySession.putPendingWrite(streamId, spdyDataFrame);
+                        return;
+                    } else if (sendWindowSize < dataLength) {
+                        // Stream is not stalled but we cannot send the entire frame
+                        spdySession.updateSendWindowSize(streamId, -1 * sendWindowSize);
+
+                        // Create a partial data frame whose length is the current window size
+                        SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamId,
+                                spdyDataFrame.content().readSlice(sendWindowSize).retain());
+
+                        // Enqueue the remaining data (will be the first frame queued)
+                        spdySession.putPendingWrite(streamId, spdyDataFrame);
 
                         // The transfer window size is pre-decremented when sending a data frame downstream.
                         // Close the stream on write failures that leaves the transfer window in a corrupt state.
@@ -505,26 +507,22 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws
                         // This is never sent because on write failure the connection will be closed
                         // immediately.  Commenting out just in case I misunderstood it - T
                         //
+                        //final SocketAddress remoteAddress = e.getRemoteAddress();
                         //final ChannelHandlerContext context = ctx;
                         //e.getFuture().addListener(new ChannelFutureListener() {
                         //    @Override
                         //    public void operationComplete(ChannelFuture future) throws Exception {
                         //        if (!future.isSuccess()) {
-                        //            issueStreamError(context, streamID, SpdyStreamStatus.INTERNAL_ERROR);
+                        //            issueStreamError(context, streamId, SpdyStreamStatus.INTERNAL_ERROR);
                         //        }
                         //    }
                         //});
 
-                    } else if (sendWindowSize > 0) {
-                        // Stream is not stalled but we cannot send the entire frame
-                        spdySession.updateSendWindowSize(streamID, -1 * sendWindowSize);
-
-                        // Create a partial data frame whose length is the current window size
-                        SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamID,
-                                spdyDataFrame.content().readSlice(sendWindowSize).retain());
-
-                        // Enqueue the remaining data (will be the first frame queued)
-                        spdySession.putPendingWrite(streamID, spdyDataFrame);
+                        ctx.write(partialDataFrame);
+                        return;
+                    } else {
+                        // Window size is large enough to send entire data frame
+                        spdySession.updateSendWindowSize(streamId, -1 * dataLength);
 
                         // The transfer window size is pre-decremented when sending a data frame downstream.
                         // Close the stream on write failures that leaves the transfer window in a corrupt state.
@@ -532,61 +530,53 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws
                         // This is never sent because on write failure the connection will be closed
                         // immediately.  Commenting out just in case I misunderstood it - T
                         //
-                        //final SocketAddress remoteAddress = e.getRemoteAddress();
                         //final ChannelHandlerContext context = ctx;
                         //e.getFuture().addListener(new ChannelFutureListener() {
                         //    @Override
                         //    public void operationComplete(ChannelFuture future) throws Exception {
                         //        if (!future.isSuccess()) {
-                        //            issueStreamError(context, streamID, SpdyStreamStatus.INTERNAL_ERROR);
+                        //            issueStreamError(context, streamId, SpdyStreamStatus.INTERNAL_ERROR);
                         //        }
                         //    }
                         //});
-
-                        ctx.nextOutboundMessageBuffer().add(partialDataFrame);
-                        return;
-                    } else {
-                        // Stream is stalled -- enqueue Data frame and return
-                        spdySession.putPendingWrite(streamID, spdyDataFrame);
-                        return;
                     }
                 }
             }
 
             // Close the local side of the stream if this is the last frame
             if (spdyDataFrame.isLast()) {
-                halfCloseStream(streamID, false);
+                halfCloseStream(streamId, false);
             }
 
         } else if (msg instanceof SpdySynStreamFrame) {
 
             SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
-            int streamID = spdySynStreamFrame.getStreamId();
+            int streamId = spdySynStreamFrame.getStreamId();
 
-            if (isRemoteInitiatedID(streamID)) {
+            if (isRemoteInitiatedID(streamId)) {
                 throw PROTOCOL_EXCEPTION;
             }
 
             byte priority = spdySynStreamFrame.getPriority();
             boolean remoteSideClosed = spdySynStreamFrame.isUnidirectional();
             boolean localSideClosed = spdySynStreamFrame.isLast();
-            if (!acceptStream(streamID, priority, remoteSideClosed, localSideClosed)) {
+            if (!acceptStream(streamId, priority, remoteSideClosed, localSideClosed)) {
                 throw PROTOCOL_EXCEPTION;
             }
 
         } else if (msg instanceof SpdySynReplyFrame) {
 
             SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
-            int streamID = spdySynReplyFrame.getStreamId();
+            int streamId = spdySynReplyFrame.getStreamId();
 
             // Frames must not be sent on half-closed streams
-            if (!isRemoteInitiatedID(streamID) || spdySession.isLocalSideClosed(streamID)) {
+            if (!isRemoteInitiatedID(streamId) || spdySession.isLocalSideClosed(streamId)) {
                 throw PROTOCOL_EXCEPTION;
             }
 
             // Close the local side of the stream if this is the last frame
             if (spdySynReplyFrame.isLast()) {
-                halfCloseStream(streamID, false);
+                halfCloseStream(streamId, false);
             }
 
         } else if (msg instanceof SpdyRstStreamFrame) {
@@ -639,16 +629,16 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws
         } else if (msg instanceof SpdyHeadersFrame) {
 
             SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-            int streamID = spdyHeadersFrame.getStreamId();
+            int streamId = spdyHeadersFrame.getStreamId();
 
             // Frames must not be sent on half-closed streams
-            if (spdySession.isLocalSideClosed(streamID)) {
+            if (spdySession.isLocalSideClosed(streamId)) {
                 throw PROTOCOL_EXCEPTION;
             }
 
             // Close the local side of the stream if this is the last frame
             if (spdyHeadersFrame.isLast()) {
-                halfCloseStream(streamID, false);
+                halfCloseStream(streamId, false);
             }
 
         } else if (msg instanceof SpdyWindowUpdateFrame) {
@@ -657,7 +647,7 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws
             throw PROTOCOL_EXCEPTION;
         }
 
-        ctx.nextOutboundMessageBuffer().add(msg);
+        out.add(msg);
     }
 
     /*
@@ -672,8 +662,7 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws
     private void issueSessionError(
             ChannelHandlerContext ctx, SpdySessionStatus status) {
 
-        sendGoAwayFrame(ctx, status);
-        ctx.flush().addListener(ChannelFutureListener.CLOSE);
+        sendGoAwayFrame(ctx, status).addListener(ChannelFutureListener.CLOSE);
     }
 
     /*
@@ -688,16 +677,16 @@ private void issueSessionError(
      * Note: this is only called by the worker thread
      */
     private void issueStreamError(
-            ChannelHandlerContext ctx, int streamID, SpdyStreamStatus status) {
+            ChannelHandlerContext ctx, int streamId, SpdyStreamStatus status,  MessageList<Object> in) {
+        boolean fireMessageReceived = !spdySession.isRemoteSideClosed(streamId);
+        removeStream(ctx, streamId);
 
-        boolean fireMessageReceived = !spdySession.isRemoteSideClosed(streamID);
-        removeStream(ctx, streamID);
-
-        SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame(streamID, status);
+        SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame(streamId, status);
         ctx.write(spdyRstStreamFrame);
         if (fireMessageReceived) {
-            ctx.nextInboundMessageBuffer().add(spdyRstStreamFrame);
-            ctx.fireInboundBufferUpdated();
+            in.add(spdyRstStreamFrame);
+            ctx.fireMessageReceived(in.copy());
+            in.clear();
         }
     }
 
@@ -706,8 +695,8 @@ private void issueStreamError(
      */
 
     private boolean isRemoteInitiatedID(int id) {
-        boolean serverID = SpdyCodecUtil.isServerId(id);
-        return server && !serverID || !server && serverID;
+        boolean serverId = SpdyCodecUtil.isServerId(id);
+        return server && !serverId || !server && serverId;
     }
 
     private void updateConcurrentStreams(int newConcurrentStreams, boolean remote) {
@@ -753,39 +742,39 @@ private synchronized void updateInitialReceiveWindowSize(int newInitialWindowSiz
 
     // need to synchronize accesses to sentGoAwayFrame, lastGoodStreamId, and initial window sizes
     private synchronized boolean acceptStream(
-            int streamID, byte priority, boolean remoteSideClosed, boolean localSideClosed) {
+            int streamId, byte priority, boolean remoteSideClosed, boolean localSideClosed) {
         // Cannot initiate any new streams after receiving or sending GOAWAY
         if (receivedGoAwayFrame || sentGoAwayFrame) {
             return false;
         }
 
-        int maxConcurrentStreams = this.maxConcurrentStreams; // read volatile once
+        int maxConcurrentStreams = this.maxConcurrentStreams;
         if (maxConcurrentStreams != 0 &&
            spdySession.numActiveStreams() >= maxConcurrentStreams) {
             return false;
         }
         spdySession.acceptStream(
-                streamID, priority, remoteSideClosed, localSideClosed,
+                streamId, priority, remoteSideClosed, localSideClosed,
                 initialSendWindowSize, initialReceiveWindowSize);
-        if (isRemoteInitiatedID(streamID)) {
-            lastGoodStreamId = streamID;
+        if (isRemoteInitiatedID(streamId)) {
+            lastGoodStreamId = streamId;
         }
         return true;
     }
 
-    private void halfCloseStream(int streamID, boolean remote) {
+    private void halfCloseStream(int streamId, boolean remote) {
         if (remote) {
-            spdySession.closeRemoteSide(streamID);
+            spdySession.closeRemoteSide(streamId);
         } else {
-            spdySession.closeLocalSide(streamID);
+            spdySession.closeLocalSide(streamId);
         }
         if (closeSessionFuture != null && spdySession.noActiveStreams()) {
             closeSessionFuture.trySuccess();
         }
     }
 
-    private void removeStream(ChannelHandlerContext ctx, int streamID) {
-        if (spdySession.removeStream(streamID)) {
+    private void removeStream(ChannelHandlerContext ctx, int streamId) {
+        if (spdySession.removeStream(streamId)) {
             ctx.fireExceptionCaught(STREAM_CLOSED);
         }
 
@@ -794,13 +783,13 @@ private void removeStream(ChannelHandlerContext ctx, int streamID) {
         }
     }
 
-    private void updateSendWindowSize(ChannelHandlerContext ctx, final int streamID, int deltaWindowSize) {
+    private void updateSendWindowSize(final int streamId, int deltaWindowSize, MessageList<Object> out) {
         synchronized (flowControlLock) {
-            int newWindowSize = spdySession.updateSendWindowSize(streamID, deltaWindowSize);
+            int newWindowSize = spdySession.updateSendWindowSize(streamId, deltaWindowSize);
 
             while (newWindowSize > 0) {
                 // Check if we have unblocked a stalled stream
-                SpdyDataFrame spdyDataFrame = (SpdyDataFrame) spdySession.getPendingWrite(streamID);
+                SpdyDataFrame spdyDataFrame = (SpdyDataFrame) spdySession.getPendingWrite(streamId);
                 if (spdyDataFrame == null) {
                     break;
                 }
@@ -809,8 +798,8 @@ private void updateSendWindowSize(ChannelHandlerContext ctx, final int streamID,
 
                 if (newWindowSize >= dataFrameSize) {
                     // Window size is large enough to send entire data frame
-                    spdySession.removePendingWrite(streamID);
-                    newWindowSize = spdySession.updateSendWindowSize(streamID, -1 * dataFrameSize);
+                    spdySession.removePendingWrite(streamId);
+                    newWindowSize = spdySession.updateSendWindowSize(streamId, -1 * dataFrameSize);
 
                     // The transfer window size is pre-decremented when sending a data frame downstream.
                     // Close the stream on write failures that leaves the transfer window in a corrupt state.
@@ -823,23 +812,23 @@ private void updateSendWindowSize(ChannelHandlerContext ctx, final int streamID,
                     //    @Override
                     //    public void operationComplete(ChannelFuture future) throws Exception {
                     //        if (!future.isSuccess()) {
-                    //            issueStreamError(context, streamID, SpdyStreamStatus.INTERNAL_ERROR);
+                    //            issueStreamError(context, streamId, SpdyStreamStatus.INTERNAL_ERROR);
                     //        }
                     //    }
                     //});
 
                     // Close the local side of the stream if this is the last frame
                     if (spdyDataFrame.isLast()) {
-                        halfCloseStream(streamID, false);
+                        halfCloseStream(streamId, false);
                     }
 
-                    ctx.nextOutboundMessageBuffer().add(spdyDataFrame);
+                    out.add(spdyDataFrame);
                 } else {
                     // We can send a partial frame
-                    spdySession.updateSendWindowSize(streamID, -1 * newWindowSize);
+                    spdySession.updateSendWindowSize(streamId, -1 * newWindowSize);
 
                     // Create a partial data frame whose length is the current window size
-                    SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamID,
+                    SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamId,
                             spdyDataFrame.content().readSlice(newWindowSize).retain());
 
                     // The transfer window size is pre-decremented when sending a data frame downstream.
@@ -854,12 +843,12 @@ private void updateSendWindowSize(ChannelHandlerContext ctx, final int streamID,
                     //    @Override
                     //    public void operationComplete(ChannelFuture future) throws Exception {
                     //        if (!future.isSuccess()) {
-                    //            issueStreamError(context, streamID, SpdyStreamStatus.INTERNAL_ERROR);
+                    //            issueStreamError(context, streamId, SpdyStreamStatus.INTERNAL_ERROR);
                     //        }
                     //    }
                     //});
 
-                    ctx.nextOutboundMessageBuffer().add(partialDataFrame);
+                    out.add(partialDataFrame);
 
                     newWindowSize = 0;
                 }
@@ -874,8 +863,7 @@ private void sendGoAwayFrame(ChannelHandlerContext ctx, ChannelPromise future) {
             return;
         }
 
-        sendGoAwayFrame(ctx, SpdySessionStatus.OK);
-        ChannelFuture f = ctx.flush();
+        ChannelFuture f = sendGoAwayFrame(ctx, SpdySessionStatus.OK);
         if (spdySession.noActiveStreams()) {
             f.addListener(new ClosingChannelFutureListener(ctx, future));
         } else {
@@ -885,12 +873,14 @@ private void sendGoAwayFrame(ChannelHandlerContext ctx, ChannelPromise future) {
         // FIXME: Close the connection forcibly after timeout.
     }
 
-    private synchronized void sendGoAwayFrame(
+    private synchronized ChannelFuture sendGoAwayFrame(
             ChannelHandlerContext ctx, SpdySessionStatus status) {
         if (!sentGoAwayFrame) {
             sentGoAwayFrame = true;
             SpdyGoAwayFrame spdyGoAwayFrame = new DefaultSpdyGoAwayFrame(lastGoodStreamId, status);
-            ctx.nextOutboundMessageBuffer().add(spdyGoAwayFrame);
+            return ctx.write(spdyGoAwayFrame);
+        } else {
+            return ctx.newSucceededFuture();
         }
     }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java
index 120b509eeb14..577f99f390cf 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * The SPDY session getStatus code and its description.
+ * The SPDY session status code and its description.
  */
 public class SpdySessionStatus implements Comparable<SpdySessionStatus> {
 
@@ -40,7 +40,7 @@ public class SpdySessionStatus implements Comparable<SpdySessionStatus> {
 
     /**
      * Returns the {@link SpdySessionStatus} represented by the specified code.
-     * If the specified code is a defined SPDY getStatus code, a cached instance
+     * If the specified code is a defined SPDY status code, a cached instance
      * will be returned.  Otherwise, a new instance will be returned.
      */
     public static SpdySessionStatus valueOf(int code) {
@@ -74,14 +74,14 @@ public SpdySessionStatus(int code, String statusPhrase) {
     }
 
     /**
-     * Returns the code of this getStatus.
+     * Returns the code of this status.
      */
     public int getCode() {
         return code;
     }
 
     /**
-     * Returns the getStatus phrase of this getStatus.
+     * Returns the status phrase of this status.
      */
     public String getStatusPhrase() {
         return statusPhrase;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySettingsFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySettingsFrame.java
index d60154698a29..6cdbb8afa4fd 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySettingsFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySettingsFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -18,9 +18,9 @@
 import java.util.Set;
 
 /**
- * A SPDY Protocol SETTINGS Control Frame
+ * A SPDY Protocol SETTINGS Frame
  */
-public interface SpdySettingsFrame extends SpdyControlFrame {
+public interface SpdySettingsFrame extends SpdyFrame {
 
     int SETTINGS_UPLOAD_BANDWIDTH               = 1;
     int SETTINGS_DOWNLOAD_BANDWIDTH             = 2;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamFrame.java
index 9482efd811b1..e5299f9ae957 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamFrame.java
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * A frame which is part of a stream
+ * A SPDY Protocol Frame that is associated with an individual SPDY Stream
  */
-public interface SpdyStreamFrame {
+public interface SpdyStreamFrame extends SpdyFrame {
 
     /**
      * Returns the Stream-ID of this frame.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamStatus.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamStatus.java
index 4487fa8c5235..ccb0d814d2a8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamStatus.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyStreamStatus.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * The SPDY stream getStatus code and its description.
+ * The SPDY stream status code and its description.
  */
 public class SpdyStreamStatus implements Comparable<SpdyStreamStatus> {
 
@@ -88,13 +88,13 @@ public class SpdyStreamStatus implements Comparable<SpdyStreamStatus> {
 
     /**
      * Returns the {@link SpdyStreamStatus} represented by the specified code.
-     * If the specified code is a defined SPDY getStatus code, a cached instance
+     * If the specified code is a defined SPDY status code, a cached instance
      * will be returned.  Otherwise, a new instance will be returned.
      */
     public static SpdyStreamStatus valueOf(int code) {
         if (code == 0) {
             throw new IllegalArgumentException(
-                    "0 is not a valid getStatus code for a RST_STREAM");
+                    "0 is not a valid status code for a RST_STREAM");
         }
 
         switch (code) {
@@ -136,7 +136,7 @@ public static SpdyStreamStatus valueOf(int code) {
     public SpdyStreamStatus(int code, String statusPhrase) {
         if (code == 0) {
             throw new IllegalArgumentException(
-                    "0 is not a valid getStatus code for a RST_STREAM");
+                    "0 is not a valid status code for a RST_STREAM");
         }
 
         if (statusPhrase == null) {
@@ -148,14 +148,14 @@ public SpdyStreamStatus(int code, String statusPhrase) {
     }
 
     /**
-     * Returns the code of this getStatus.
+     * Returns the code of this status.
      */
     public int getCode() {
         return code;
     }
 
     /**
-     * Returns the getStatus phrase of this getStatus.
+     * Returns the status phrase of this status.
      */
     public String getStatusPhrase() {
         return statusPhrase;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynReplyFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynReplyFrame.java
index ff399b6f4472..4bce003620e3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynReplyFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynReplyFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * A SPDY Protocol SYN_REPLY Control Frame
+ * A SPDY Protocol SYN_REPLY Frame
  */
-public interface SpdySynReplyFrame extends SpdyHeaderBlock, SpdyControlFrame, SpdyStreamFrame {
+public interface SpdySynReplyFrame extends SpdyHeadersFrame {
 
     @Override
     SpdySynReplyFrame setStreamId(int streamID);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynStreamFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynStreamFrame.java
index dba39b01c472..b4e6331f02b5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynStreamFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySynStreamFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * A SPDY Protocol SYN_STREAM Control Frame
+ * A SPDY Protocol SYN_STREAM Frame
  */
-public interface SpdySynStreamFrame extends SpdyHeaderBlock, SpdyControlFrame , SpdyStreamFrame {
+public interface SpdySynStreamFrame extends SpdyHeadersFrame {
 
     /**
      * Returns the Associated-To-Stream-ID of this frame.
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyWindowUpdateFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyWindowUpdateFrame.java
index 86fe94faa6f6..587b1f66d2e3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyWindowUpdateFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyWindowUpdateFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.spdy;
 
 /**
- * A SPDY Protocol WINDOW_UPDATE Control Frame
+ * A SPDY Protocol WINDOW_UPDATE Frame
  */
-public interface SpdyWindowUpdateFrame extends SpdyControlFrame {
+public interface SpdyWindowUpdateFrame extends SpdyFrame {
 
     /**
      * Returns the Stream-ID of this frame.
@@ -26,7 +26,7 @@ public interface SpdyWindowUpdateFrame extends SpdyControlFrame {
     int getStreamId();
 
     /**
-     * Sets the Stream-ID of this frame.  The Stream-ID must be positive.
+     * Sets the Stream-ID of this frame.  The Stream-ID cannot be negative.
      */
     SpdyWindowUpdateFrame setStreamId(int streamID);
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java
index 8192f5f580da..4c14954e11df 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java
@@ -30,7 +30,7 @@ public class CookieDecoderTest {
     public void testDecodingSingleCookieV0() {
         String cookieString = "myCookie=myValue;expires=XXX;path=/apathsomewhere;domain=.adomainsomewhere;secure;";
         cookieString = cookieString.replace("XXX",
-                new HttpHeaderDateFormat().format(new Date(System.currentTimeMillis() + 50000)));
+                HttpHeaderDateFormat.get().format(new Date(System.currentTimeMillis() + 50000)));
 
         Set<Cookie> cookies = CookieDecoder.decode(cookieString);
         assertEquals(1, cookies.size());
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/CookieEncoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/CookieEncoderTest.java
index 00aa3289c8e6..bd5149be5735 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/CookieEncoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieEncoderTest.java
@@ -27,7 +27,7 @@ public class CookieEncoderTest {
     @Test
     public void testEncodingSingleCookieV0() {
         String result = "myCookie=myValue; Expires=XXX; Path=/apathsomewhere; Domain=.adomainsomewhere; Secure";
-        DateFormat df = new HttpHeaderDateFormat();
+        DateFormat df = HttpHeaderDateFormat.get();
         Cookie cookie = new DefaultCookie("myCookie", "myValue");
         cookie.setComment("this is a Comment");
         cookie.setCommentUrl("http://aurl.com");
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java
index 5ba19f180b0c..07af776a601a 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.CodecException;
 import io.netty.handler.codec.PrematureChannelClosureException;
 import io.netty.util.CharsetUtil;
@@ -37,7 +37,7 @@ public class HttpClientCodecTest {
     @Test
     public void testFailsNotOnRequestResponse() {
         HttpClientCodec codec = new HttpClientCodec(4096, 8192, 8192, true);
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(codec);
+        EmbeddedChannel ch = new EmbeddedChannel(codec);
 
         ch.writeOutbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "http://localhost/"));
         ch.writeInbound(Unpooled.copiedBuffer(RESPONSE, CharsetUtil.ISO_8859_1));
@@ -47,7 +47,7 @@ public void testFailsNotOnRequestResponse() {
     @Test
     public void testFailsNotOnRequestResponseChunked() {
         HttpClientCodec codec = new HttpClientCodec(4096, 8192, 8192, true);
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(codec);
+        EmbeddedChannel ch = new EmbeddedChannel(codec);
 
         ch.writeOutbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "http://localhost/"));
         ch.writeInbound(Unpooled.copiedBuffer(CHUNKED_RESPONSE, CharsetUtil.ISO_8859_1));
@@ -57,7 +57,7 @@ public void testFailsNotOnRequestResponseChunked() {
     @Test
     public void testFailsOnMissingResponse() {
         HttpClientCodec codec = new HttpClientCodec(4096, 8192, 8192, true);
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(codec);
+        EmbeddedChannel ch = new EmbeddedChannel(codec);
 
         assertTrue(ch.writeOutbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,
                 "http://localhost/")));
@@ -74,7 +74,7 @@ public void testFailsOnMissingResponse() {
     @Test
     public void testFailsOnIncompleteChunkedResponse() {
         HttpClientCodec codec = new HttpClientCodec(4096, 8192, 8192, true);
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(codec);
+        EmbeddedChannel ch = new EmbeddedChannel(codec);
 
         ch.writeOutbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "http://localhost/"));
         ch.writeInbound(Unpooled.copiedBuffer(INCOMPLETE_CHUNKED_RESPONSE, CharsetUtil.ISO_8859_1));
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
index b0875f94941e..113b22cb52c8 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.handler.codec.http.HttpHeaders.Names;
 import org.junit.Test;
@@ -63,7 +63,7 @@ public void testGetTargetContentEncoding() throws Exception {
 
     @Test
     public void testEmptyContentCompression() throws Exception {
-        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new HttpContentCompressor());
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpContentCompressor());
         FullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
         req.headers().set(Names.ACCEPT_ENCODING, "deflate");
         ch.writeInbound(req);
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java
index 8e293cb412bb..dbf450bf250f 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java
@@ -19,9 +19,8 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.embedded.EmbeddedByteChannel;
-import io.netty.channel.embedded.EmbeddedMessageChannel;
-import io.netty.handler.codec.ByteToByteEncoder;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.MessageToByteEncoder;
 import io.netty.handler.codec.http.HttpHeaders.Names;
 import io.netty.handler.codec.http.HttpHeaders.Values;
 import io.netty.util.CharsetUtil;
@@ -35,9 +34,9 @@ public class HttpContentEncoderTest {
     private static final class TestEncoder extends HttpContentEncoder {
         @Override
         protected Result beginEncode(HttpResponse headers, String acceptEncoding) {
-            return new Result("test", new EmbeddedByteChannel(new ByteToByteEncoder() {
+            return new Result("test", new EmbeddedChannel(new MessageToByteEncoder<ByteBuf>() {
                 @Override
-                protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {
+                protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
                     out.writeBytes(String.valueOf(in.readableBytes()).getBytes(CharsetUtil.US_ASCII));
                     in.skipBytes(in.readableBytes());
                 }
@@ -47,7 +46,7 @@ protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {
 
     @Test
     public void testSplitContent() throws Exception {
-        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new TestEncoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new TestEncoder());
         ch.writeInbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/"));
 
         ch.writeOutbound(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK));
@@ -71,7 +70,7 @@ public void testSplitContent() throws Exception {
 
     @Test
     public void testChunkedContent() throws Exception {
-        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new TestEncoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new TestEncoder());
         ch.writeInbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/"));
 
         HttpResponse res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
@@ -98,7 +97,7 @@ public void testChunkedContent() throws Exception {
 
     @Test
     public void testFullContent() throws Exception {
-        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new TestEncoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new TestEncoder());
         ch.writeInbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/"));
 
         FullHttpResponse res = new DefaultFullHttpResponse(
@@ -116,12 +115,12 @@ public void testFullContent() throws Exception {
     }
 
     /**
-     * If the length of the content is unknown, {@link HttpContentEncoder} should not skip encoding even if the
-     * actual length is turned out to be 0.
+     * If the length of the content is unknown, {@link HttpContentEncoder} should not skip encoding the content
+     * even if the actual length is turned out to be 0.
      */
     @Test
     public void testEmptySplitContent() throws Exception {
-        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new TestEncoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new TestEncoder());
         ch.writeInbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/"));
 
         ch.writeOutbound(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK));
@@ -129,7 +128,7 @@ public void testEmptySplitContent() throws Exception {
 
         ch.writeOutbound(LastHttpContent.EMPTY_LAST_CONTENT);
         HttpContent chunk = (HttpContent) ch.readOutbound();
-        assertThat(chunk.content().isReadable(), is(false));
+        assertThat(chunk.content().toString(CharsetUtil.US_ASCII), is("0"));
         assertThat(chunk, is(instanceOf(LastHttpContent.class)));
         assertThat(ch.readOutbound(), is(nullValue()));
     }
@@ -139,7 +138,7 @@ public void testEmptySplitContent() throws Exception {
      */
     @Test
     public void testEmptyFullContent() throws Exception {
-        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new TestEncoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new TestEncoder());
         ch.writeInbound(new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/"));
 
         FullHttpResponse res = new DefaultFullHttpResponse(
@@ -162,7 +161,7 @@ public void testEmptyFullContent() throws Exception {
         assertThat(ch.readOutbound(), is(nullValue()));
     }
 
-    private static void assertEncodedResponse(EmbeddedMessageChannel ch) {
+    private static void assertEncodedResponse(EmbeddedChannel ch) {
         Object o = ch.readOutbound();
         assertThat(o, is(instanceOf(HttpResponse.class)));
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java
index a72c42024aed..5a6fe025d934 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeaderDateFormatTest.java
@@ -32,7 +32,7 @@ public class HttpHeaderDateFormatTest {
 
     @Test
     public void testParse() throws ParseException {
-        HttpHeaderDateFormat format = new HttpHeaderDateFormat();
+        HttpHeaderDateFormat format = HttpHeaderDateFormat.get();
 
         final Date parsedDateWithSingleDigitDay = format.parse("Sun, 6 Nov 1994 08:49:37 GMT");
         Assert.assertNotNull(parsedDateWithSingleDigitDay);
@@ -61,7 +61,7 @@ private Date parseDate(HttpHeaderDateFormat dateFormat, String dateStr) throws P
 
     @Test
     public void testFormat() {
-        HttpHeaderDateFormat format = new HttpHeaderDateFormat();
+        HttpHeaderDateFormat format = HttpHeaderDateFormat.get();
 
         final String formatted = format.format(DATE);
         Assert.assertNotNull(formatted);
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
index bae6eeea8aac..caa5f50fe7eb 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
@@ -32,7 +32,7 @@ public class HttpInvalidMessageTest {
 
     @Test
     public void testRequestWithBadInitialLine() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new HttpRequestDecoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpRequestDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("GET / HTTP/1.0 with extra\r\n", CharsetUtil.UTF_8));
         HttpRequest req = (HttpRequest) ch.readInbound();
         DecoderResult dr = req.getDecoderResult();
@@ -43,7 +43,7 @@ public void testRequestWithBadInitialLine() throws Exception {
 
     @Test
     public void testRequestWithBadHeader() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new HttpRequestDecoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpRequestDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("GET /maybe-something HTTP/1.0\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("Good_Name: Good Value\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("Bad=Name: Bad Value\r\n", CharsetUtil.UTF_8));
@@ -59,7 +59,7 @@ public void testRequestWithBadHeader() throws Exception {
 
     @Test
     public void testResponseWithBadInitialLine() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new HttpResponseDecoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.0 BAD_CODE Bad Server\r\n", CharsetUtil.UTF_8));
         HttpResponse res = (HttpResponse) ch.readInbound();
         DecoderResult dr = res.getDecoderResult();
@@ -70,7 +70,7 @@ public void testResponseWithBadInitialLine() throws Exception {
 
     @Test
     public void testResponseWithBadHeader() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new HttpResponseDecoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.0 200 Maybe OK\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("Good_Name: Good Value\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("Bad=Name: Bad Value\r\n", CharsetUtil.UTF_8));
@@ -86,7 +86,7 @@ public void testResponseWithBadHeader() throws Exception {
 
     @Test
     public void testBadChunk() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new HttpRequestDecoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpRequestDecoder());
         ch.writeInbound(Unpooled.copiedBuffer("GET / HTTP/1.0\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("Transfer-Encoding: chunked\r\n\r\n", CharsetUtil.UTF_8));
         ch.writeInbound(Unpooled.copiedBuffer("BAD_LENGTH\r\n", CharsetUtil.UTF_8));
@@ -101,7 +101,7 @@ public void testBadChunk() throws Exception {
         ensureInboundTrafficDiscarded(ch);
     }
 
-    private void ensureInboundTrafficDiscarded(EmbeddedByteChannel ch) {
+    private void ensureInboundTrafficDiscarded(EmbeddedChannel ch) {
         // Generate a lot of random traffic to ensure that it's discarded silently.
         byte[] data = new byte[1048576];
         rnd.nextBytes(data);
@@ -109,9 +109,10 @@ private void ensureInboundTrafficDiscarded(EmbeddedByteChannel ch) {
         ByteBuf buf = Unpooled.wrappedBuffer(data);
         for (int i = 0; i < 4096; i ++) {
             buf.setIndex(0, data.length);
-            ch.writeInbound(buf);
+            ch.writeInbound(buf.retain());
             ch.checkException();
             assertNull(ch.readInbound());
         }
+        buf.release();
     }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
index e724bc4513fa..d6f8fb46763f 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java
@@ -19,7 +19,7 @@
 import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.util.CharsetUtil;
 import org.easymock.EasyMock;
@@ -34,7 +34,7 @@ public class HttpObjectAggregatorTest {
     @Test
     public void testAggregate() {
         HttpObjectAggregator aggr = new HttpObjectAggregator(1024 * 1024);
-        EmbeddedMessageChannel embedder = new EmbeddedMessageChannel(aggr);
+        EmbeddedChannel embedder = new EmbeddedChannel(aggr);
 
         HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1,
                 HttpMethod.GET, "http://localhost");
@@ -73,7 +73,7 @@ private static void checkContentBuffer(FullHttpRequest aggregatedMessage) {
     @Test
     public void testAggregateWithTrailer() {
         HttpObjectAggregator aggr = new HttpObjectAggregator(1024 * 1024);
-        EmbeddedMessageChannel embedder = new EmbeddedMessageChannel(aggr);
+        EmbeddedChannel embedder = new EmbeddedChannel(aggr);
         HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1,
                 HttpMethod.GET, "http://localhost");
         HttpHeaders.setHeader(message, "X-Test", true);
@@ -105,7 +105,7 @@ public void testAggregateWithTrailer() {
     @Test
     public void testTooLongFrameException() {
         HttpObjectAggregator aggr = new HttpObjectAggregator(4);
-        EmbeddedMessageChannel embedder = new EmbeddedMessageChannel(aggr);
+        EmbeddedChannel embedder = new EmbeddedChannel(aggr);
         HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1,
                 HttpMethod.GET, "http://localhost");
         HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));
@@ -159,7 +159,7 @@ public void testSetMaxCumulationBufferComponentsAfterInit() throws Exception {
     @Test
     public void testAggregateTransferEncodingChunked() {
         HttpObjectAggregator aggr = new HttpObjectAggregator(1024 * 1024);
-        EmbeddedMessageChannel embedder = new EmbeddedMessageChannel(aggr);
+        EmbeddedChannel embedder = new EmbeddedChannel(aggr);
 
         HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1,
                 HttpMethod.GET, "http://localhost");
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
new file mode 100644
index 000000000000..1cd8e4202a58
--- /dev/null
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.http;
+
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.CharsetUtil;
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+public class HttpResponseDecoderTest {
+    @Test
+    public void testLastResponseWithEmptyHeaderAndEmptyContent() {
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
+        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
+
+        HttpResponse res = (HttpResponse) ch.readInbound();
+        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        assertThat(ch.readInbound(), is(nullValue()));
+
+        assertThat(ch.finish(), is(true));
+
+        LastHttpContent content = (LastHttpContent) ch.readInbound();
+        assertThat(content.content().isReadable(), is(false));
+
+        assertThat(ch.readInbound(), is(nullValue()));
+    }
+
+    @Test
+    public void testLastResponseWithoutContentLengthHeader() {
+        EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());
+        ch.writeInbound(Unpooled.copiedBuffer("HTTP/1.1 200 OK\r\n\r\n", CharsetUtil.US_ASCII));
+
+        HttpResponse res = (HttpResponse) ch.readInbound();
+        assertThat(res.getProtocolVersion(), sameInstance(HttpVersion.HTTP_1_1));
+        assertThat(res.getStatus(), is(HttpResponseStatus.OK));
+        assertThat(ch.readInbound(), is(nullValue()));
+
+        ch.writeInbound(Unpooled.wrappedBuffer(new byte[1024]));
+        HttpContent content = (HttpContent) ch.readInbound();
+        assertThat(content.content().readableBytes(), is(1024));
+
+        assertThat(ch.finish(), is(true));
+
+        LastHttpContent lastContent = (LastHttpContent) ch.readInbound();
+        assertThat(lastContent.content().isReadable(), is(false));
+
+        assertThat(ch.readInbound(), is(nullValue()));
+    }
+}
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java
index 237b30fa5669..68771595fc7c 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Assert;
 import org.junit.Test;
@@ -32,10 +32,11 @@ public void testUnfinishedChunkedHttpRequestIsLastFlag() throws Exception {
 
         int maxChunkSize = 2000;
         HttpServerCodec httpServerCodec = new HttpServerCodec(1000, 1000, maxChunkSize);
-        EmbeddedByteChannel decoderEmbedder = new EmbeddedByteChannel(httpServerCodec);
+        EmbeddedChannel decoderEmbedder = new EmbeddedChannel(httpServerCodec);
 
         int totalContentLength = maxChunkSize * 5;
-        decoderEmbedder.writeInbound(Unpooled.copiedBuffer("PUT /test HTTP/1.1\r\n" +
+        decoderEmbedder.writeInbound(Unpooled.copiedBuffer(
+                "PUT /test HTTP/1.1\r\n" +
                 "Content-Length: " + totalContentLength + "\r\n" +
                 "\r\n", CharsetUtil.UTF_8));
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java
index a78ca4c102b7..f360329a60b4 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.util.CharsetUtil;
 import org.junit.Assert;
@@ -32,7 +32,7 @@ public class WebSocketFrameAggregatorTest {
             .writeBytes(content2.duplicate()).writeBytes(content3.duplicate());
     @Test
     public void testAggregationBinary() {
-        EmbeddedMessageChannel channel = new EmbeddedMessageChannel(new WebSocketFrameAggregator(Integer.MAX_VALUE));
+        EmbeddedChannel channel = new EmbeddedChannel(new WebSocketFrameAggregator(Integer.MAX_VALUE));
         channel.writeInbound(new BinaryWebSocketFrame(true, 1, content1.copy()));
         channel.writeInbound(new BinaryWebSocketFrame(false, 0, content1.copy()));
         channel.writeInbound(new ContinuationWebSocketFrame(false, 0, content2.copy()));
@@ -42,7 +42,7 @@ public void testAggregationBinary() {
 
         Assert.assertTrue(channel.finish());
 
-        System.out.println(channel.lastInboundMessageBuffer().size());
+        System.out.println(channel.lastInboundBuffer().size());
         BinaryWebSocketFrame frame = (BinaryWebSocketFrame) channel.readInbound();
         Assert.assertTrue(frame.isFinalFragment());
         Assert.assertEquals(1, frame.rsv());
@@ -68,7 +68,7 @@ public void testAggregationBinary() {
 
     @Test
     public void testAggregationText() {
-        EmbeddedMessageChannel channel = new EmbeddedMessageChannel(new WebSocketFrameAggregator(Integer.MAX_VALUE));
+        EmbeddedChannel channel = new EmbeddedChannel(new WebSocketFrameAggregator(Integer.MAX_VALUE));
         channel.writeInbound(new TextWebSocketFrame(true, 1, content1.copy()));
         channel.writeInbound(new TextWebSocketFrame(false, 0, content1.copy()));
         channel.writeInbound(new ContinuationWebSocketFrame(false, 0, content2.copy()));
@@ -103,7 +103,7 @@ public void testAggregationText() {
 
     @Test
     public void textFrameTooBig() {
-        EmbeddedMessageChannel channel = new EmbeddedMessageChannel(new WebSocketFrameAggregator(8));
+        EmbeddedChannel channel = new EmbeddedChannel(new WebSocketFrameAggregator(8));
         channel.writeInbound(new BinaryWebSocketFrame(true, 1, content1.copy()));
         channel.writeInbound(new BinaryWebSocketFrame(false, 0, content1.copy()));
         try {
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
index 78354b607ffc..492e5cc877c5 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java
@@ -15,9 +15,8 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpHeaders.Names;
@@ -39,7 +38,7 @@ public class WebSocketServerHandshaker00Test {
 
     @Test
     public void testPerformOpeningHandshake() {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(
+        EmbeddedChannel ch = new EmbeddedChannel(
                 new HttpObjectAggregator(42), new HttpRequestDecoder(), new HttpResponseEncoder());
 
         FullHttpRequest req = new DefaultFullHttpRequest(
@@ -56,10 +55,9 @@ public void testPerformOpeningHandshake() {
         new WebSocketServerHandshaker00(
                 "ws://example.com/chat", "chat", Integer.MAX_VALUE).handshake(ch, req);
 
-        ByteBuf resBuf = ch.readOutbound();
-
-        EmbeddedByteChannel ch2 = new EmbeddedByteChannel(new HttpResponseDecoder());
-        ch2.writeInbound(resBuf);
+        EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
+        ch2.writeInbound(ch.readOutbound());
+        ch2.writeInbound(ch.readOutbound());
         HttpResponse res = (HttpResponse) ch2.readInbound();
 
         Assert.assertEquals("ws://example.com/chat", res.headers().get(Names.SEC_WEBSOCKET_LOCATION));
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
index f49ac6b10157..6b6d3c7aca42 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpHeaders.Names;
@@ -36,7 +36,7 @@ public class WebSocketServerHandshaker08Test {
 
     @Test
     public void testPerformOpeningHandshake() {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(
+        EmbeddedChannel ch = new EmbeddedChannel(
                 new HttpObjectAggregator(42), new HttpRequestDecoder(), new HttpResponseEncoder());
 
         FullHttpRequest req = new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, "/chat");
@@ -51,9 +51,9 @@ public void testPerformOpeningHandshake() {
         new WebSocketServerHandshaker08(
                 "ws://example.com/chat", "chat", false, Integer.MAX_VALUE).handshake(ch, req);
 
-        ByteBuf resBuf = ch.readOutbound();
+        ByteBuf resBuf = (ByteBuf) ch.readOutbound();
 
-        EmbeddedByteChannel ch2 = new EmbeddedByteChannel(new HttpResponseDecoder());
+        EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(resBuf);
         HttpResponse res = (HttpResponse) ch2.readInbound();
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
index 791de6a604b5..aacc460a2645 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13Test.java
@@ -16,7 +16,7 @@
 package io.netty.handler.codec.http.websocketx;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.HttpHeaders.Names;
@@ -36,7 +36,7 @@ public class WebSocketServerHandshaker13Test {
 
     @Test
     public void testPerformOpeningHandshake() {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(
+        EmbeddedChannel ch = new EmbeddedChannel(
                 new HttpObjectAggregator(42), new HttpRequestDecoder(), new HttpResponseEncoder());
 
         FullHttpRequest req = new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, "/chat");
@@ -51,9 +51,9 @@ public void testPerformOpeningHandshake() {
         new WebSocketServerHandshaker13(
                 "ws://example.com/chat", "chat", false, Integer.MAX_VALUE).handshake(ch, req);
 
-        ByteBuf resBuf = ch.readOutbound();
+        ByteBuf resBuf = (ByteBuf) ch.readOutbound();
 
-        EmbeddedByteChannel ch2 = new EmbeddedByteChannel(new HttpResponseDecoder());
+        EmbeddedChannel ch2 = new EmbeddedChannel(new HttpResponseDecoder());
         ch2.writeInbound(resBuf);
         HttpResponse res = (HttpResponse) ch2.readInbound();
 
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
index 643363fd1666..67f635122b27 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java
@@ -15,25 +15,26 @@
  */
 package io.netty.handler.codec.http.websocketx;
 
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
-import io.netty.channel.ChannelOperationHandlerAdapter;
-import io.netty.channel.ChannelOutboundMessageHandler;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.MessageList;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpRequestDecoder;
-import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseEncoder;
+import org.junit.Before;
 import org.junit.Test;
 
+import java.util.ArrayDeque;
+import java.util.Queue;
+
 import static io.netty.handler.codec.http.HttpHeaders.Values.*;
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
@@ -41,29 +42,36 @@
 
 public class WebSocketServerProtocolHandlerTest {
 
+    private final Queue<FullHttpResponse> responses = new ArrayDeque<FullHttpResponse>();
+
+    @Before
+    public void setUp() {
+        responses.clear();
+    }
+
     @Test
     public void testHttpUpgradeRequest() throws Exception {
-        EmbeddedMessageChannel ch = createChannel(new MockOutboundHandler());
+        EmbeddedChannel ch = createChannel(new MockOutboundHandler());
         ChannelHandlerContext handshakerCtx = ch.pipeline().context(WebSocketServerProtocolHandshakeHandler.class);
         writeUpgradeRequest(ch);
-        assertEquals(SWITCHING_PROTOCOLS, ((HttpResponse) ch.outboundMessageBuffer().poll()).getStatus());
+        assertEquals(SWITCHING_PROTOCOLS, responses.remove().getStatus());
         assertNotNull(WebSocketServerProtocolHandler.getHandshaker(handshakerCtx));
     }
 
     @Test
     public void testSubsequentHttpRequestsAfterUpgradeShouldReturn403() throws Exception {
-        EmbeddedMessageChannel ch = createChannel(new MockOutboundHandler());
+        EmbeddedChannel ch = createChannel();
 
         writeUpgradeRequest(ch);
-        assertEquals(SWITCHING_PROTOCOLS, ((HttpResponse) ch.outboundMessageBuffer().poll()).getStatus());
+        assertEquals(SWITCHING_PROTOCOLS, responses.remove().getStatus());
 
         ch.writeInbound(new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, "/test"));
-        assertEquals(FORBIDDEN, ((HttpResponse) ch.outboundMessageBuffer().poll()).getStatus());
+        assertEquals(FORBIDDEN, responses.remove().getStatus());
     }
 
     @Test
     public void testHttpUpgradeRequestInvalidUpgradeHeader() {
-        EmbeddedMessageChannel ch = createChannel();
+        EmbeddedChannel ch = createChannel();
         FullHttpRequest httpRequestWithEntity = new WebSocketRequestBuilder().httpVersion(HTTP_1_1)
                 .method(HttpMethod.GET)
                 .uri("/test")
@@ -74,14 +82,14 @@ public void testHttpUpgradeRequestInvalidUpgradeHeader() {
 
         ch.writeInbound(httpRequestWithEntity);
 
-        FullHttpResponse response = getHttpResponse(ch);
+        FullHttpResponse response = responses.remove();
         assertEquals(BAD_REQUEST, response.getStatus());
         assertEquals("not a WebSocket handshake request: missing upgrade", getResponseMessage(response));
     }
 
     @Test
     public void testHttpUpgradeRequestMissingWSKeyHeader() {
-        EmbeddedMessageChannel ch = createChannel();
+        EmbeddedChannel ch = createChannel();
         HttpRequest httpRequest = new WebSocketRequestBuilder().httpVersion(HTTP_1_1)
                 .method(HttpMethod.GET)
                 .uri("/test")
@@ -93,7 +101,7 @@ public void testHttpUpgradeRequestMissingWSKeyHeader() {
 
         ch.writeInbound(httpRequest);
 
-        FullHttpResponse response = getHttpResponse(ch);
+        FullHttpResponse response = responses.remove();
         assertEquals(BAD_REQUEST, response.getStatus());
         assertEquals("not a WebSocket request: missing key", getResponseMessage(response));
     }
@@ -101,22 +109,26 @@ public void testHttpUpgradeRequestMissingWSKeyHeader() {
     @Test
     public void testHandleTextFrame() {
         CustomTextFrameHandler customTextFrameHandler = new CustomTextFrameHandler();
-        EmbeddedMessageChannel ch = createChannel(customTextFrameHandler);
+        EmbeddedChannel ch = createChannel(customTextFrameHandler);
         writeUpgradeRequest(ch);
-        // Removing the HttpRequestDecoder as we are writing a TextWebSocketFrame so decoding is not neccessary.
-        ch.pipeline().remove(HttpRequestDecoder.class);
+
+        if (ch.pipeline().context(HttpRequestDecoder.class) != null) {
+            // Removing the HttpRequestDecoder because we are writing a TextWebSocketFrame and thus
+            // decoding is not neccessary.
+            ch.pipeline().remove(HttpRequestDecoder.class);
+        }
 
         ch.writeInbound(new TextWebSocketFrame("payload"));
 
         assertEquals("processed: payload", customTextFrameHandler.getContent());
     }
 
-    private static EmbeddedMessageChannel createChannel() {
+    private EmbeddedChannel createChannel() {
         return createChannel(null);
     }
 
-    private static EmbeddedMessageChannel createChannel(ChannelHandler handler) {
-        return new EmbeddedMessageChannel(
+    private EmbeddedChannel createChannel(ChannelHandler handler) {
+        return new EmbeddedChannel(
                 new WebSocketServerProtocolHandler("/test", null, false),
                 new HttpRequestDecoder(),
                 new HttpResponseEncoder(),
@@ -124,7 +136,7 @@ private static EmbeddedMessageChannel createChannel(ChannelHandler handler) {
                 handler);
     }
 
-    private static void writeUpgradeRequest(EmbeddedMessageChannel ch) {
+    private static void writeUpgradeRequest(EmbeddedChannel ch) {
         ch.writeInbound(WebSocketRequestBuilder.sucessful());
     }
 
@@ -132,31 +144,25 @@ private static String getResponseMessage(FullHttpResponse response) {
         return new String(response.content().array());
     }
 
-    private static FullHttpResponse getHttpResponse(EmbeddedMessageChannel ch) {
-        MessageBuf<Object> outbound = ch.pipeline().context(MockOutboundHandler.class).outboundMessageBuffer();
-        return (FullHttpResponse) outbound.poll();
-    }
-
-    private static class MockOutboundHandler
-        extends ChannelOperationHandlerAdapter implements ChannelOutboundMessageHandler<Object> {
-
-        @Override
-        public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
+    private class MockOutboundHandler extends ChannelOutboundHandlerAdapter {
 
         @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise future) throws Exception {
-            //NoOp
+        public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise)
+                throws Exception {
+            for (int i = 0; i < msgs.size(); i++) {
+                responses.add((FullHttpResponse) msgs.get(i));
+            }
+            promise.setSuccess();
         }
     }
 
-    private static class CustomTextFrameHandler extends ChannelInboundMessageHandlerAdapter<TextWebSocketFrame> {
+    private static class CustomTextFrameHandler extends ChannelInboundHandlerAdapter {
         private String content;
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {
-            content = "processed: " + msg.text();
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            assertEquals(1, msgs.size());
+            content = "processed: " + ((TextWebSocketFrame) msgs.get(0)).text();
         }
 
         String getContent() {
diff --git a/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
index bd18a2b6a581..701d62eb5373 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -16,8 +16,10 @@
 package io.netty.handler.codec.spdy;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
@@ -39,40 +41,25 @@ public class SpdySessionHandlerTest {
         closeMessage.setValue(closeSignal, 0);
     }
 
-    private static void assertHeaderBlock(SpdyHeaderBlock received, SpdyHeaderBlock expected) {
-        for (String name: expected.headers().names()) {
-            List<String> expectedValues = expected.headers().getAll(name);
-            List<String> receivedValues = received.headers().getAll(name);
-            assertTrue(receivedValues.containsAll(expectedValues));
-            receivedValues.removeAll(expectedValues);
-            assertTrue(receivedValues.isEmpty());
-            received.headers().remove(name);
-        }
-        assertTrue(received.headers().entries().isEmpty());
-    }
-
-    private static void assertDataFrame(Object msg, int streamID, boolean last) {
+    private static void assertDataFrame(Object msg, int streamId, boolean last) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyDataFrame);
         SpdyDataFrame spdyDataFrame = (SpdyDataFrame) msg;
-        assertEquals(spdyDataFrame.getStreamId(), streamID);
+        assertEquals(spdyDataFrame.getStreamId(), streamId);
         assertEquals(spdyDataFrame.isLast(), last);
     }
 
-    private static void assertSynReply(Object msg, int streamID, boolean last, SpdyHeaderBlock headers) {
+    private static void assertSynReply(Object msg, int streamId, boolean last, SpdyHeaders headers) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdySynReplyFrame);
-        SpdySynReplyFrame spdySynReplyFrame = (SpdySynReplyFrame) msg;
-        assertEquals(spdySynReplyFrame.getStreamId(), streamID);
-        assertEquals(spdySynReplyFrame.isLast(), last);
-        assertHeaderBlock(spdySynReplyFrame, headers);
+        assertHeaders(msg, streamId, last, headers);
     }
 
-    private static void assertRstStream(Object msg, int streamID, SpdyStreamStatus status) {
+    private static void assertRstStream(Object msg, int streamId, SpdyStreamStatus status) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyRstStreamFrame);
         SpdyRstStreamFrame spdyRstStreamFrame = (SpdyRstStreamFrame) msg;
-        assertEquals(spdyRstStreamFrame.getStreamId(), streamID);
+        assertEquals(spdyRstStreamFrame.getStreamId(), streamId);
         assertEquals(spdyRstStreamFrame.getStatus(), status);
     }
 
@@ -83,94 +70,103 @@ private static void assertPing(Object msg, int id) {
         assertEquals(spdyPingFrame.getId(), id);
     }
 
-    private static void assertGoAway(Object msg, int lastGoodStreamID) {
+    private static void assertGoAway(Object msg, int lastGoodStreamId) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyGoAwayFrame);
         SpdyGoAwayFrame spdyGoAwayFrame = (SpdyGoAwayFrame) msg;
-        assertEquals(spdyGoAwayFrame.getLastGoodStreamId(), lastGoodStreamID);
+        assertEquals(spdyGoAwayFrame.getLastGoodStreamId(), lastGoodStreamId);
     }
 
-    private static void assertHeaders(Object msg, int streamID, SpdyHeaderBlock headers) {
+    private static void assertHeaders(Object msg, int streamId, boolean last, SpdyHeaders headers) {
         assertNotNull(msg);
         assertTrue(msg instanceof SpdyHeadersFrame);
         SpdyHeadersFrame spdyHeadersFrame = (SpdyHeadersFrame) msg;
-        assertEquals(spdyHeadersFrame.getStreamId(), streamID);
-        assertHeaderBlock(spdyHeadersFrame, headers);
+        assertEquals(spdyHeadersFrame.getStreamId(), streamId);
+        assertEquals(spdyHeadersFrame.isLast(), last);
+        for (String name: headers.names()) {
+            List<String> expectedValues = headers.getAll(name);
+            List<String> receivedValues = spdyHeadersFrame.headers().getAll(name);
+            assertTrue(receivedValues.containsAll(expectedValues));
+            receivedValues.removeAll(expectedValues);
+            assertTrue(receivedValues.isEmpty());
+            spdyHeadersFrame.headers().remove(name);
+        }
+        assertTrue(spdyHeadersFrame.headers().entries().isEmpty());
     }
 
     private static void testSpdySessionHandler(int version, boolean server) {
-        EmbeddedMessageChannel sessionHandler = new EmbeddedMessageChannel(
+        EmbeddedChannel sessionHandler = new EmbeddedChannel(
                 new SpdySessionHandler(version, server), new EchoHandler(closeSignal, server));
 
         while (sessionHandler.readOutbound() != null) {
             continue;
         }
 
-        int localStreamID = server ? 1 : 2;
-        int remoteStreamID = server ? 2 : 1;
+        int localStreamId = server ? 1 : 2;
+        int remoteStreamId = server ? 2 : 1;
 
-        SpdyPingFrame localPingFrame = new DefaultSpdyPingFrame(localStreamID);
-        SpdyPingFrame remotePingFrame = new DefaultSpdyPingFrame(remoteStreamID);
+        SpdyPingFrame localPingFrame = new DefaultSpdyPingFrame(localStreamId);
+        SpdyPingFrame remotePingFrame = new DefaultSpdyPingFrame(remoteStreamId);
 
         SpdySynStreamFrame spdySynStreamFrame =
-                new DefaultSpdySynStreamFrame(localStreamID, 0, (byte) 0);
+                new DefaultSpdySynStreamFrame(localStreamId, 0, (byte) 0);
         spdySynStreamFrame.headers().set("Compression", "test");
 
-        SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(localStreamID);
+        SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame(localStreamId);
         spdyDataFrame.setLast(true);
 
         // Check if session handler returns INVALID_STREAM if it receives
         // a data frame for a Stream-ID that is not open
-        sessionHandler.writeInbound(new DefaultSpdyDataFrame(localStreamID));
-        assertRstStream(sessionHandler.readOutbound(), localStreamID, SpdyStreamStatus.INVALID_STREAM);
+        sessionHandler.writeInbound(new DefaultSpdyDataFrame(localStreamId));
+        assertRstStream(sessionHandler.readOutbound(), localStreamId, SpdyStreamStatus.INVALID_STREAM);
         assertNull(sessionHandler.readOutbound());
 
         // Check if session handler returns PROTOCOL_ERROR if it receives
         // a data frame for a Stream-ID before receiving a SYN_REPLY frame
-        sessionHandler.writeInbound(new DefaultSpdyDataFrame(remoteStreamID));
-        assertRstStream(sessionHandler.readOutbound(), remoteStreamID, SpdyStreamStatus.PROTOCOL_ERROR);
+        sessionHandler.writeInbound(new DefaultSpdyDataFrame(remoteStreamId));
+        assertRstStream(sessionHandler.readOutbound(), remoteStreamId, SpdyStreamStatus.PROTOCOL_ERROR);
         assertNull(sessionHandler.readOutbound());
-        remoteStreamID += 2;
+        remoteStreamId += 2;
 
         // Check if session handler returns PROTOCOL_ERROR if it receives
         // multiple SYN_REPLY frames for the same active Stream-ID
-        sessionHandler.writeInbound(new DefaultSpdySynReplyFrame(remoteStreamID));
+        sessionHandler.writeInbound(new DefaultSpdySynReplyFrame(remoteStreamId));
         assertNull(sessionHandler.readOutbound());
-        sessionHandler.writeInbound(new DefaultSpdySynReplyFrame(remoteStreamID));
-        assertRstStream(sessionHandler.readOutbound(), remoteStreamID, SpdyStreamStatus.STREAM_IN_USE);
+        sessionHandler.writeInbound(new DefaultSpdySynReplyFrame(remoteStreamId));
+        assertRstStream(sessionHandler.readOutbound(), remoteStreamId, SpdyStreamStatus.STREAM_IN_USE);
         assertNull(sessionHandler.readOutbound());
-        remoteStreamID += 2;
+        remoteStreamId += 2;
 
         // Check if frame codec correctly compresses/uncompresses headers
         sessionHandler.writeInbound(spdySynStreamFrame);
-        assertSynReply(sessionHandler.readOutbound(), localStreamID, false, spdySynStreamFrame);
+        assertSynReply(sessionHandler.readOutbound(), localStreamId, false, spdySynStreamFrame.headers());
         assertNull(sessionHandler.readOutbound());
-        SpdyHeadersFrame spdyHeadersFrame = new DefaultSpdyHeadersFrame(localStreamID);
+        SpdyHeadersFrame spdyHeadersFrame = new DefaultSpdyHeadersFrame(localStreamId);
 
         spdyHeadersFrame.headers().add("HEADER", "test1");
         spdyHeadersFrame.headers().add("HEADER", "test2");
 
         sessionHandler.writeInbound(spdyHeadersFrame);
-        assertHeaders(sessionHandler.readOutbound(), localStreamID, spdyHeadersFrame);
+        assertHeaders(sessionHandler.readOutbound(), localStreamId, false, spdyHeadersFrame.headers());
         assertNull(sessionHandler.readOutbound());
-        localStreamID += 2;
+        localStreamId += 2;
 
         // Check if session handler closed the streams using the number
         // of concurrent streams and that it returns REFUSED_STREAM
         // if it receives a SYN_STREAM frame it does not wish to accept
-        spdySynStreamFrame.setStreamId(localStreamID);
+        spdySynStreamFrame.setStreamId(localStreamId);
         spdySynStreamFrame.setLast(true);
         spdySynStreamFrame.setUnidirectional(true);
 
         sessionHandler.writeInbound(spdySynStreamFrame);
-        assertRstStream(sessionHandler.readOutbound(), localStreamID, SpdyStreamStatus.REFUSED_STREAM);
+        assertRstStream(sessionHandler.readOutbound(), localStreamId, SpdyStreamStatus.REFUSED_STREAM);
         assertNull(sessionHandler.readOutbound());
 
         // Check if session handler drops active streams if it receives
         // a RST_STREAM frame for that Stream-ID
-        sessionHandler.writeInbound(new DefaultSpdyRstStreamFrame(remoteStreamID, 3));
+        sessionHandler.writeInbound(new DefaultSpdyRstStreamFrame(remoteStreamId, 3));
         assertNull(sessionHandler.readOutbound());
-        remoteStreamID += 2;
+        remoteStreamId += 2;
 
         // Check if session handler honors UNIDIRECTIONAL streams
         spdySynStreamFrame.setLast(false);
@@ -181,17 +177,17 @@ private static void testSpdySessionHandler(int version, boolean server) {
         // Check if session handler returns PROTOCOL_ERROR if it receives
         // multiple SYN_STREAM frames for the same active Stream-ID
         sessionHandler.writeInbound(spdySynStreamFrame);
-        assertRstStream(sessionHandler.readOutbound(), localStreamID, SpdyStreamStatus.PROTOCOL_ERROR);
+        assertRstStream(sessionHandler.readOutbound(), localStreamId, SpdyStreamStatus.PROTOCOL_ERROR);
         assertNull(sessionHandler.readOutbound());
-        localStreamID += 2;
+        localStreamId += 2;
 
         // Check if session handler returns PROTOCOL_ERROR if it receives
         // a SYN_STREAM frame with an invalid Stream-ID
-        spdySynStreamFrame.setStreamId(localStreamID - 1);
+        spdySynStreamFrame.setStreamId(localStreamId - 1);
         sessionHandler.writeInbound(spdySynStreamFrame);
-        assertRstStream(sessionHandler.readOutbound(), localStreamID - 1, SpdyStreamStatus.PROTOCOL_ERROR);
+        assertRstStream(sessionHandler.readOutbound(), localStreamId - 1, SpdyStreamStatus.PROTOCOL_ERROR);
         assertNull(sessionHandler.readOutbound());
-        spdySynStreamFrame.setStreamId(localStreamID);
+        spdySynStreamFrame.setStreamId(localStreamId);
 
         // Check if session handler correctly limits the number of
         // concurrent streams in the SETTINGS frame
@@ -200,33 +196,33 @@ private static void testSpdySessionHandler(int version, boolean server) {
         sessionHandler.writeInbound(spdySettingsFrame);
         assertNull(sessionHandler.readOutbound());
         sessionHandler.writeInbound(spdySynStreamFrame);
-        assertRstStream(sessionHandler.readOutbound(), localStreamID, SpdyStreamStatus.REFUSED_STREAM);
+        assertRstStream(sessionHandler.readOutbound(), localStreamId, SpdyStreamStatus.REFUSED_STREAM);
         assertNull(sessionHandler.readOutbound());
         spdySettingsFrame.setValue(SpdySettingsFrame.SETTINGS_MAX_CONCURRENT_STREAMS, 4);
         sessionHandler.writeInbound(spdySettingsFrame);
         assertNull(sessionHandler.readOutbound());
         sessionHandler.writeInbound(spdySynStreamFrame);
-        assertSynReply(sessionHandler.readOutbound(), localStreamID, false, spdySynStreamFrame);
+        assertSynReply(sessionHandler.readOutbound(), localStreamId, false, spdySynStreamFrame.headers());
         assertNull(sessionHandler.readOutbound());
 
         // Check if session handler rejects HEADERS for closed streams
-        int testStreamID = spdyDataFrame.getStreamId();
+        int testStreamId = spdyDataFrame.getStreamId();
         sessionHandler.writeInbound(spdyDataFrame);
-        assertDataFrame(sessionHandler.readOutbound(), testStreamID, spdyDataFrame.isLast());
+        assertDataFrame(sessionHandler.readOutbound(), testStreamId, spdyDataFrame.isLast());
         assertNull(sessionHandler.readOutbound());
-        spdyHeadersFrame.setStreamId(testStreamID);
+        spdyHeadersFrame.setStreamId(testStreamId);
 
         sessionHandler.writeInbound(spdyHeadersFrame);
-        assertRstStream(sessionHandler.readOutbound(), testStreamID, SpdyStreamStatus.INVALID_STREAM);
+        assertRstStream(sessionHandler.readOutbound(), testStreamId, SpdyStreamStatus.INVALID_STREAM);
         assertNull(sessionHandler.readOutbound());
 
         // Check if session handler returns PROTOCOL_ERROR if it receives
         // an invalid HEADERS frame
-        spdyHeadersFrame.setStreamId(localStreamID);
+        spdyHeadersFrame.setStreamId(localStreamId);
 
         spdyHeadersFrame.setInvalid();
         sessionHandler.writeInbound(spdyHeadersFrame);
-        assertRstStream(sessionHandler.readOutbound(), localStreamID, SpdyStreamStatus.PROTOCOL_ERROR);
+        assertRstStream(sessionHandler.readOutbound(), localStreamId, SpdyStreamStatus.PROTOCOL_ERROR);
         assertNull(sessionHandler.readOutbound());
 
         // Check if session handler returns identical local PINGs
@@ -240,20 +236,20 @@ private static void testSpdySessionHandler(int version, boolean server) {
 
         // Check if session handler sends a GOAWAY frame when closing
         sessionHandler.writeInbound(closeMessage);
-        assertGoAway(sessionHandler.readOutbound(), localStreamID);
+        assertGoAway(sessionHandler.readOutbound(), localStreamId);
         assertNull(sessionHandler.readOutbound());
-        localStreamID += 2;
+        localStreamId += 2;
 
         // Check if session handler returns REFUSED_STREAM if it receives
         // SYN_STREAM frames after sending a GOAWAY frame
-        spdySynStreamFrame.setStreamId(localStreamID);
+        spdySynStreamFrame.setStreamId(localStreamId);
         sessionHandler.writeInbound(spdySynStreamFrame);
-        assertRstStream(sessionHandler.readOutbound(), localStreamID, SpdyStreamStatus.REFUSED_STREAM);
+        assertRstStream(sessionHandler.readOutbound(), localStreamId, SpdyStreamStatus.REFUSED_STREAM);
         assertNull(sessionHandler.readOutbound());
 
         // Check if session handler ignores Data frames after sending
         // a GOAWAY frame
-        spdyDataFrame.setStreamId(localStreamID);
+        spdyDataFrame.setStreamId(localStreamId);
         sessionHandler.writeInbound(spdyDataFrame);
         assertNull(sessionHandler.readOutbound());
 
@@ -278,7 +274,7 @@ public void testSpdyServerSessionHandler() {
 
     // Echo Handler opens 4 half-closed streams on session connection
     // and then sets the number of concurrent streams to 3
-    private static class EchoHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+    private static class EchoHandler extends SimpleChannelInboundHandler<Object> {
         private final int closeSignal;
         private final boolean server;
 
@@ -290,9 +286,9 @@ private static class EchoHandler extends ChannelInboundMessageHandlerAdapter<Obj
         @Override
         public void channelActive(ChannelHandlerContext ctx) throws Exception {
             // Initiate 4 new streams
-            int streamID = server ? 2 : 1;
+            int streamId = server ? 2 : 1;
             SpdySynStreamFrame spdySynStreamFrame =
-                    new DefaultSpdySynStreamFrame(streamID, 0, (byte) 0);
+                    new DefaultSpdySynStreamFrame(streamId, 0, (byte) 0);
             spdySynStreamFrame.setLast(true);
             ctx.write(spdySynStreamFrame);
             spdySynStreamFrame.setStreamId(spdySynStreamFrame.getStreamId() + 2);
@@ -310,20 +306,12 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
 
         @Override
         public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-            if (msg instanceof SpdyDataFrame ||
-                    msg instanceof SpdyPingFrame ||
-                    msg instanceof SpdyHeadersFrame) {
-
-                ctx.write(msg);
-                return;
-            }
-
             if (msg instanceof SpdySynStreamFrame) {
 
                 SpdySynStreamFrame spdySynStreamFrame = (SpdySynStreamFrame) msg;
                 if (!spdySynStreamFrame.isUnidirectional()) {
-                    int streamID = spdySynStreamFrame.getStreamId();
-                    SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamID);
+                    int streamId = spdySynStreamFrame.getStreamId();
+                    SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame(streamId);
                     spdySynReplyFrame.setLast(spdySynStreamFrame.isLast());
                     for (Map.Entry<String, String> entry: spdySynStreamFrame.headers()) {
                         spdySynReplyFrame.headers().add(entry.getKey(), entry.getValue());
@@ -334,6 +322,18 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
                 return;
             }
 
+            if (msg instanceof SpdySynReplyFrame) {
+                return;
+            }
+
+            if (msg instanceof SpdyDataFrame ||
+                    msg instanceof SpdyPingFrame ||
+                    msg instanceof SpdyHeadersFrame) {
+
+                ctx.write(msg);
+                return;
+            }
+
             if (msg instanceof SpdySettingsFrame) {
                 SpdySettingsFrame spdySettingsFrame = (SpdySettingsFrame) msg;
                 if (spdySettingsFrame.isSet(closeSignal)) {
diff --git a/codec-socks/pom.xml b/codec-socks/pom.xml
index c335ce436377..58442ebd8f71 100644
--- a/codec-socks/pom.xml
+++ b/codec-socks/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-codec-socks</artifactId>
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
index 53101ed862ca..d298fd491783 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
 
@@ -43,7 +43,7 @@ public SocksAuthRequestDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksSubnegotiationVersion.fromByte(byteBuf.readByte());
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
index 7ba8db8d94d6..01ed2c2979db 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 
 /**
@@ -40,7 +40,7 @@ public SocksAuthResponseDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, MessageBuf<Object> out)
+    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, MessageList<Object> out)
             throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
index feadc09982cb..b85df155e915 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
 
@@ -46,7 +46,7 @@ public SocksCmdRequestDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
index 3670a36dcc54..203005dd2d80 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.util.CharsetUtil;
 
@@ -46,7 +46,7 @@ public SocksCmdResponseDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
index 30102c077c65..16c0b7221d43 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 
 import java.util.ArrayList;
@@ -44,7 +44,7 @@ public SocksInitRequestDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
index 1978269363df..e5c07a2a1c8b 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.socks;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 
 /**
@@ -41,7 +41,7 @@ public SocksInitResponseDecoder() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, MessageList<Object> out) throws Exception {
         switch (state()) {
             case CHECK_PROTOCOL_VERSION: {
                 version = SocksProtocolVersion.fromByte(byteBuf.readByte());
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java
index a94bbeec24ef..ff8692a521b3 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthRequestDecoderTest.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.socks;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -28,7 +28,7 @@ public void testAuthRequestDecoder() {
         String password = "test";
         SocksAuthRequest msg = new SocksAuthRequest(username, password);
         SocksAuthRequestDecoder decoder = new SocksAuthRequestDecoder();
-        EmbeddedByteChannel embedder = new EmbeddedByteChannel(decoder);
+        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
         msg = (SocksAuthRequest) embedder.readInbound();
         assertEquals(msg.username(), username);
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
index ad88597a4d85..1604f53bb9a1 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.socks;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
@@ -29,7 +29,7 @@ private static void testSocksAuthResponseDecoderWithDifferentParams(SocksAuthSta
         logger.debug("Testing SocksAuthResponseDecoder with authStatus: " + authStatus);
         SocksAuthResponse msg = new SocksAuthResponse(authStatus);
         SocksAuthResponseDecoder decoder = new SocksAuthResponseDecoder();
-        EmbeddedByteChannel embedder = new EmbeddedByteChannel(decoder);
+        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
         msg = (SocksAuthResponse) embedder.readInbound();
         assertSame(msg.authStatus(), authStatus);
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
index 32de008844db..8ae2a726db42 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.socks;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
@@ -34,7 +34,7 @@ private static void testSocksCmdRequestDecoderWithDifferentParams(SocksCmdType c
                 " port: " + port);
         SocksCmdRequest msg = new SocksCmdRequest(cmdType, addressType, host, port);
         SocksCmdRequestDecoder decoder = new SocksCmdRequestDecoder();
-        EmbeddedByteChannel embedder = new EmbeddedByteChannel(decoder);
+        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
         if (msg.addressType() == SocksAddressType.UNKNOWN) {
             assertTrue(embedder.readInbound() instanceof UnknownSocksRequest);
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
index f058780d36dc..9f2691dc96d0 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.socks;
 
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
@@ -25,12 +25,12 @@
 public class SocksCmdResponseDecoderTest {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocksCmdResponseDecoderTest.class);
 
-    private static void testSocksCmdResponseDecoderWithDifferentParams(SocksCmdStatus cmdStatus,
-                                                                       SocksAddressType addressType) {
+    private static void testSocksCmdResponseDecoderWithDifferentParams(
+            SocksCmdStatus cmdStatus, SocksAddressType addressType) {
         logger.debug("Testing cmdStatus: " + cmdStatus + " addressType: " + addressType);
         SocksResponse msg = new SocksCmdResponse(cmdStatus, addressType);
         SocksCmdResponseDecoder decoder = new SocksCmdResponseDecoder();
-        EmbeddedByteChannel embedder = new EmbeddedByteChannel(decoder);
+        EmbeddedChannel embedder = new EmbeddedChannel(decoder);
         SocksCommonTestUtils.writeMessageIntoEmbedder(embedder, msg);
         if (addressType == SocksAddressType.UNKNOWN) {
             assertTrue(embedder.readInbound() instanceof UnknownSocksResponse);
diff --git a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java
index ade7a7e41741..f4a54dbad076 100644
--- a/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java
+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCommonTestUtils.java
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 
 final class SocksCommonTestUtils {
     /**
@@ -27,7 +27,7 @@ private SocksCommonTestUtils() {
         //NOOP
     }
 
-    public static void writeMessageIntoEmbedder(EmbeddedByteChannel embedder, SocksMessage msg) {
+    public static void writeMessageIntoEmbedder(EmbeddedChannel embedder, SocksMessage msg) {
         ByteBuf buf = Unpooled.buffer();
         msg.encodeAsByteBuf(buf);
         embedder.writeInbound(buf);
diff --git a/codec/pom.xml b/codec/pom.xml
index 006b642915c8..7d8357b5a341 100644
--- a/codec/pom.xml
+++ b/codec/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-codec</artifactId>
diff --git a/codec/src/main/java/io/netty/handler/codec/ByteToByteCodec.java b/codec/src/main/java/io/netty/handler/codec/ByteToByteCodec.java
deleted file mode 100644
index 2907e6a00a1a..000000000000
--- a/codec/src/main/java/io/netty/handler/codec/ByteToByteCodec.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelDuplexHandler;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundByteHandler;
-import io.netty.channel.ChannelPromise;
-
-/**
- * A Codec for on-the-fly encoding/decoding of bytes.
- *
- * This can be thought of as a combination of {@link ByteToByteDecoder} and {@link ByteToByteEncoder}.
- *
- * Here is an example of a {@link ByteToByteCodec} which just square {@link Integer} read from a {@link ByteBuf}.
- * <pre>
- *     public class SquareCodec extends {@link ByteToByteCodec} {
- *         {@code @Override}
- *         public void decode({@link ChannelHandlerContext} ctx, {@link ByteBuf} in, {@link ByteBuf} out)
- *                 throws {@link Exception} {
- *             if (in.readableBytes() < 4) {
- *                 return;
- *             }
- *             int value = in.readInt();
- *             out.writeInt(value * value);
- *         }
- *
- *         {@code @Overrride}
- *         public void encode({@link ChannelHandlerContext} ctx, {@link ByteBuf} in, {@link ByteBuf} out)
- *                 throws {@link Exception} {
- *             if (in.readableBytes() < 4) {
- *                 return;
- *             }
- *             int value = in.readInt();
- *             out.writeInt(value / value);
- *         }
- *     }
- * </pre>
- */
-public abstract class ByteToByteCodec
-        extends ChannelDuplexHandler
-        implements ChannelInboundByteHandler, ChannelOutboundByteHandler {
-
-    private final ByteToByteEncoder encoder = new ByteToByteEncoder() {
-        @Override
-        protected void encode(
-                ChannelHandlerContext ctx,
-                ByteBuf in, ByteBuf out) throws Exception {
-            ByteToByteCodec.this.encode(ctx, in, out);
-        }
-    };
-
-    private final ByteToByteDecoder decoder = new ByteToByteDecoder() {
-        @Override
-        protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
-            ByteToByteCodec.this.decode(ctx, in, out);
-        }
-
-        @Override
-        protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
-            ByteToByteCodec.this.decodeLast(ctx, in, out);
-        }
-    };
-
-    @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return decoder.newInboundBuffer(ctx);
-    }
-
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        decoder.inboundBufferUpdated(ctx);
-    }
-
-    @Override
-    public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return encoder.newOutboundBuffer(ctx);
-    }
-
-    @Override
-    public void flush(
-            ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        encoder.flush(ctx, promise);
-    }
-
-    @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        decoder.discardInboundReadBytes(ctx);
-    }
-
-    @Override
-    public void discardOutboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        encoder.discardOutboundReadBytes(ctx);
-    }
-
-    /**
-     * @see {@link ByteToByteEncoder#encode(ChannelHandlerContext, ByteBuf, ByteBuf)}
-     */
-    protected abstract void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception;
-
-    /**
-     * @see {@link ByteToByteDecoder#decode(ChannelHandlerContext, ByteBuf, ByteBuf)}
-     */
-    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception;
-
-    /**
-     * @see {@link ByteToByteDecoder#decodeLast(ChannelHandlerContext, ByteBuf, ByteBuf)}
-     */
-    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
-        decode(ctx, in, out);
-    }
-}
diff --git a/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java
deleted file mode 100644
index a2ad13ead7a0..000000000000
--- a/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
-
-/**
- * {@link ChannelInboundByteHandlerAdapter} which decodes bytes in a stream-like fashion from one {@link ByteBuf} to an
- * other.
- *
- * This kind of decoder is often useful for doing on-the-fly processiing like i.e. compression.
- *
- * But you can also do other things with it. For example here is an implementation which reads {@link Integer}s from
- * the input {@link ByteBuf} and square them before write them to the output {@link ByteBuf}.
- *
- * <pre>
- *     public class SquareDecoder extends {@link ByteToByteDecoder} {
- *         {@code @Override}
- *         public void decode({@link ChannelHandlerContext} ctx, {@link ByteBuf} in, {@link ByteBuf} out)
- *                 throws {@link Exception} {
- *             if (in.readableBytes() < 4) {
- *                 return;
- *             }
- *             int value = in.readInt();
- *             out.writeInt(value * value);
- *         }
- *     }
- * </pre>
- */
-public abstract class ByteToByteDecoder extends ChannelInboundByteHandlerAdapter {
-
-    private volatile boolean singleDecode;
-
-    /**
-     * If set then only one message is decoded on each {@link #inboundBufferUpdated(ChannelHandlerContext)} call.
-     * This may be useful if you need to do some protocol upgrade and want to make sure nothing is mixed up.
-     *
-     * Default is {@code false} as this has performance impacts.
-     */
-    public void setSingleDecode(boolean singleDecode) {
-        this.singleDecode = singleDecode;
-    }
-
-    /**
-     * If {@code true} then only one message is decoded on each
-     * {@link #inboundBufferUpdated(ChannelHandlerContext)} call.
-     *
-     * Default is {@code false} as this has performance impacts.
-     */
-    public boolean isSingleDecode() {
-        return singleDecode;
-    }
-
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-        callDecode(ctx, in, ctx.nextInboundByteBuffer());
-    }
-
-    @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        ByteBuf in = ctx.inboundByteBuffer();
-        ByteBuf out = ctx.nextInboundByteBuffer();
-        if (!in.isReadable()) {
-            callDecode(ctx, in, out);
-        }
-
-        int oldOutSize = out.readableBytes();
-        try {
-            decodeLast(ctx, in, out);
-        } catch (CodecException e) {
-            throw e;
-        } catch (Throwable t) {
-            throw new DecoderException(t);
-        } finally {
-            if (out.readableBytes() > oldOutSize) {
-                ctx.fireInboundBufferUpdated();
-            }
-            ctx.fireChannelInactive();
-        }
-    }
-
-    /**
-     * Call the {@link #decode(ChannelHandlerContext, ByteBuf, ByteBuf)} method until it is done.
-     */
-    private void callDecode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {
-        int oldOutSize = out.readableBytes();
-        try {
-            while (in.isReadable()) {
-                int oldInSize = in.readableBytes();
-                    decode(ctx, in, out);
-                if (oldInSize == in.readableBytes() || isSingleDecode()) {
-                    break;
-                }
-            }
-        } catch (CodecException e) {
-            throw e;
-        } catch (Throwable t) {
-            throw new DecoderException(t);
-        } finally {
-            if (out.readableBytes() > oldOutSize) {
-                ctx.fireInboundBufferUpdated();
-            }
-        }
-    }
-
-    /**
-     * Decode the from one {@link ByteBuf} to an other. This method will be called till either the input
-     * {@link ByteBuf} has nothing to read anymore or till nothing was read from the input {@link ByteBuf}.
-     *
-     * @param ctx           the {@link ChannelHandlerContext} which this {@link ByteToByteDecoder} belongs to
-     * @param in            the {@link ByteBuf} from which to read data
-     * @param out           the {@link ByteBuf} to which the decoded data will be written
-     * @throws Exception    is thrown if an error accour
-     */
-    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception;
-
-    /**
-     * Is called one last time when the {@link ChannelHandlerContext} goes in-active. Which means the
-     * {@link #channelInactive(ChannelHandlerContext)} was triggered.
-     *
-     * By default this will just call {@link #decode(ChannelHandlerContext, ByteBuf, ByteBuf)} but sub-classes may
-     * override this for some special cleanup operation.
-     */
-    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
-        decode(ctx, in, out);
-    }
-}
diff --git a/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java
deleted file mode 100644
index f1ed0f9212a7..000000000000
--- a/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundByteHandlerAdapter;
-import io.netty.channel.ChannelPromise;
-import io.netty.channel.FileRegion;
-import io.netty.channel.IncompleteFlushException;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.WritableByteChannel;
-
-/**
- * {@link ChannelOutboundByteHandlerAdapter} which encodes bytes in a stream-like fashion from one {@link ByteBuf} to an
- * other.
- *
- * This kind of decoder is often useful for doing on-the-fly processing like i.e. compression.
- *
- * But you can also do other things with it. For example here is an implementation which reads {@link Integer}s from
- * the input {@link ByteBuf} and square them before write them to the output {@link ByteBuf}.
- *
- * <pre>
- *     public class SquareEncoder extends {@link ByteToByteEncoder} {
- *         {@code @Override}
- *         public void encode({@link ChannelHandlerContext} ctx, {@link ByteBuf} in, {@link ByteBuf} out)
- *                 throws {@link Exception} {
- *             if (in.readableBytes() < 4) {
- *                 return;
- *             }
- *             int value = in.readInt();
- *             out.writeInt(value * value);
- *         }
- *     }
- * </pre>
- */
-public abstract class ByteToByteEncoder extends ChannelOutboundByteHandlerAdapter {
-
-    @Override
-    protected void flush(ChannelHandlerContext ctx, ByteBuf in, ChannelPromise promise) throws Exception {
-        ByteBuf out = ctx.nextOutboundByteBuffer();
-        boolean encoded = false;
-
-        try {
-            while (in.isReadable()) {
-                int oldInSize = in.readableBytes();
-                encode(ctx, in, out);
-                encoded = true;
-                if (oldInSize == in.readableBytes()) {
-                    break;
-                }
-            }
-        } catch (Throwable t) {
-            if (!(t instanceof CodecException)) {
-                t = new EncoderException(t);
-            }
-            if (encoded) {
-                t = new IncompleteFlushException("unable to encode all bytes", t);
-            }
-            in.discardSomeReadBytes();
-            promise.setFailure(t);
-            return;
-        }
-
-        ctx.flush(promise);
-    }
-
-    @Override
-    public void sendFile(ChannelHandlerContext ctx, FileRegion region, ChannelPromise promise) throws Exception {
-        long written = 0;
-        try {
-            for (;;) {
-                long localWritten = region.transferTo(new BufferChannel(ctx.outboundByteBuffer()), written);
-                if (localWritten == -1) {
-                    checkEOF(region, written);
-                    flush(ctx, promise);
-                    break;
-                }
-                written += localWritten;
-                if (written >= region.count()) {
-                    flush(ctx, promise);
-                    break;
-                }
-            }
-        } catch (IOException e) {
-            promise.setFailure(new EncoderException(e));
-        } finally {
-            region.release();
-        }
-    }
-
-    private static void checkEOF(FileRegion region, long writtenBytes) throws IOException {
-        if (writtenBytes < region.count()) {
-            throw new EOFException("Expected to be able to write "
-                    + region.count() + " bytes, but only wrote "
-                    + writtenBytes);
-        }
-    }
-
-    private static final class BufferChannel implements WritableByteChannel {
-        private final ByteBuf buffer;
-
-        BufferChannel(ByteBuf buffer) {
-            this.buffer = buffer;
-        }
-        @Override
-        public int write(ByteBuffer src) {
-            int bytes = src.remaining();
-            buffer.writeBytes(src);
-            return bytes;
-        }
-
-        @Override
-        public boolean isOpen() {
-            return buffer.refCnt() > 0;
-        }
-
-        @Override
-        public void close() {
-            // NOOP
-        }
-    }
-
-    /**
-     * Encodes the from one {@link ByteBuf} to an other. This method will be called till either the input
-     * {@link ByteBuf} has nothing to read anymore or till nothing was read from the input {@link ByteBuf}.
-     *
-     * @param ctx           the {@link ChannelHandlerContext} which this {@link ByteToByteDecoder} belongs to
-     * @param in            the {@link ByteBuf} from which to read data
-     * @param out           the {@link ByteBuf} to which the decoded data will be written
-     * @throws Exception    is thrown if an error accour
-     */
-    protected abstract void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception;
-}
diff --git a/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
index b44331b4b6a1..7622510c3506 100644
--- a/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java
@@ -16,16 +16,13 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.util.internal.TypeParameterMatcher;
 
-public abstract class ByteToMessageCodec<I> extends ChannelDuplexHandler
-        implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<I> {
+public abstract class ByteToMessageCodec<I> extends ChannelDuplexHandler {
 
     private final TypeParameterMatcher outboundMsgMatcher;
     private final MessageToByteEncoder<I> encoder  = new MessageToByteEncoder<I>() {
@@ -42,12 +39,12 @@ protected void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exce
 
     private final ByteToMessageDecoder decoder = new ByteToMessageDecoder() {
         @Override
-        public void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+        public void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
             ByteToMessageCodec.this.decode(ctx, in, out);
         }
 
         @Override
-        protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+        protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
             ByteToMessageCodec.this.decodeLast(ctx, in, out);
         }
     };
@@ -60,38 +57,23 @@ protected ByteToMessageCodec(Class<? extends I> outboundMessageType) {
         outboundMsgMatcher = TypeParameterMatcher.get(outboundMessageType);
     }
 
-    @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return decoder.newInboundBuffer(ctx);
-    }
-
-    @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        decoder.discardInboundReadBytes(ctx);
-    }
-
-    @Override
-    public MessageBuf<I> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return encoder.newOutboundBuffer(ctx);
+    public boolean acceptOutboundMessage(Object msg) throws Exception {
+        return outboundMsgMatcher.match(msg);
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        decoder.inboundBufferUpdated(ctx);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        decoder.messageReceived(ctx, msgs);
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        encoder.flush(ctx, promise);
-    }
-
-    public boolean acceptOutboundMessage(Object msg) throws Exception {
-        return outboundMsgMatcher.match(msg);
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        encoder.write(ctx, msgs, promise);
     }
 
     protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exception;
-    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception;
-    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception;
+    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         decode(ctx, in, out);
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
index 6366340c63ab..f0db696e2e72 100644
--- a/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
@@ -16,14 +16,15 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
+import io.netty.util.internal.StringUtil;
 
 /**
- * {@link ChannelInboundByteHandler} which decodes bytes in a stream-like fashion from one {@link ByteBuf} to an other
- * Message type.
+ * {@link ChannelInboundHandlerAdapter} which decodes bytes in a stream-like fashion from one {@link ByteBuf} to an
+ * other Message type.
  *
  * For example here is an implementation which reads all readable bytes from
  * the input {@link ByteBuf} and create a new {@link ByteBuf}.
@@ -31,22 +32,23 @@
  * <pre>
  *     public class SquareDecoder extends {@link ByteToMessageDecoder} {
  *         {@code @Override}
- *         public void decode({@link ChannelHandlerContext} ctx, {@link ByteBuf} in, {@link MessageBuf} out)
+ *         public void decode({@link ChannelHandlerContext} ctx, {@link ByteBuf} in, {@link MessageList} out)
  *                 throws {@link Exception} {
  *             out.add(in.readBytes(in.readableBytes()));
  *         }
  *     }
  * </pre>
  */
-public abstract class ByteToMessageDecoder
-    extends ChannelInboundByteHandlerAdapter {
+public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter {
 
-    private volatile boolean singleDecode;
+    protected ByteBuf cumulation;
+    private boolean singleDecode;
     private boolean decodeWasNull;
+    private MessageList<Object> out;
 
     /**
-     * If set then only one message is decoded on each {@link #inboundBufferUpdated(ChannelHandlerContext)} call.
-     * This may be useful if you need to do some protocol upgrade and want to make sure nothing is mixed up.
+     * If set then only one message is decoded on each {@link #messageReceived(ChannelHandlerContext, MessageList)}
+     * call. This may be useful if you need to do some protocol upgrade and want to make sure nothing is mixed up.
      *
      * Default is {@code false} as this has performance impacts.
      */
@@ -56,7 +58,7 @@ public void setSingleDecode(boolean singleDecode) {
 
     /**
      * If {@code true} then only one message is decoded on each
-     * {@link #inboundBufferUpdated(ChannelHandlerContext)} call.
+     * {@link #messageReceived(ChannelHandlerContext, MessageList)} call.
      *
      * Default is {@code false} as this has performance impacts.
      */
@@ -64,9 +66,117 @@ public boolean isSingleDecode() {
         return singleDecode;
     }
 
+    /**
+     * Returns the actual number of readable bytes in the internal cumulative
+     * buffer of this decoder. You usually do not need to rely on this value
+     * to write a decoder. Use it only when you must use it at your own risk.
+     * This method is a shortcut to {@link #internalBuffer() internalBuffer().readableBytes()}.
+     */
+    protected int actualReadableBytes() {
+        return internalBuffer().readableBytes();
+    }
+
+    /**
+     * Returns the internal cumulative buffer of this decoder. You usually
+     * do not need to access the internal buffer directly to write a decoder.
+     * Use it only when you must use it at your own risk.
+     */
+    protected ByteBuf internalBuffer() {
+        if (cumulation != null) {
+            return cumulation;
+        } else {
+            return Unpooled.EMPTY_BUFFER;
+        }
+    }
+
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-        callDecode(ctx, in);
+    public final void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        ByteBuf buf = internalBuffer();
+        if (buf.isReadable()) {
+            if (out == null) {
+                ctx.fireMessageReceived(buf);
+            } else {
+                out.add(buf.copy());
+            }
+            buf.clear();
+        }
+        handlerRemoved0(ctx);
+    }
+
+    /**
+     * Gets called after the {@link ByteToMessageDecoder} was removed from the actual context and it doesn't handle
+     * events anymore.
+     */
+    protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception { }
+
+    @Override
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        out = MessageList.newInstance();
+        try {
+            int size = msgs.size();
+            for (int i = 0; i < size; i ++) {
+                Object m = msgs.get(i);
+                // handler was removed in the loop so now copy over all remaining messages
+                if (ctx.isRemoved()) {
+                    out.add(msgs, i, size - i);
+                    return;
+                }
+                if (m instanceof ByteBuf) {
+                    ByteBuf data = (ByteBuf) m;
+                    if (cumulation == null) {
+                        cumulation = data;
+                        try {
+                            callDecode(ctx, data, out);
+                        } finally {
+                            if (!data.isReadable()) {
+                                cumulation = null;
+                                data.release();
+                            }
+                        }
+                    } else {
+                        try {
+                            if (cumulation.writerIndex() > cumulation.maxCapacity() - data.readableBytes()) {
+                                ByteBuf oldCumulation = cumulation;
+                                cumulation = ctx.alloc().buffer(oldCumulation.readableBytes() + data.readableBytes());
+                                cumulation.writeBytes(oldCumulation);
+                                oldCumulation.release();
+                            }
+                            cumulation.writeBytes(data);
+                            callDecode(ctx, cumulation, out);
+                        } finally {
+                            if (!cumulation.isReadable()) {
+                                cumulation.release();
+                                cumulation = null;
+                            } else {
+                                cumulation.discardSomeReadBytes();
+                            }
+                            data.release();
+                        }
+                    }
+                } else {
+                    out.add(m);
+                }
+            }
+        } catch (DecoderException e) {
+            throw e;
+        } catch (Throwable t) {
+            throw new DecoderException(t);
+        } finally {
+            // release the cumulation if the handler was removed while messages are processed
+            if (ctx.isRemoved()) {
+                if (cumulation != null) {
+                    cumulation.release();
+                    cumulation = null;
+                }
+            }
+            MessageList<Object> out = this.out;
+            this.out = null;
+            if (out.isEmpty()) {
+                decodeWasNull = true;
+            }
+            msgs.recycle();
+            ctx.fireMessageReceived(out);
+        }
     }
 
     @Override
@@ -82,35 +192,36 @@ public void channelReadSuspended(ChannelHandlerContext ctx) throws Exception {
 
     @Override
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        OutputMessageBuf out = OutputMessageBuf.get();
+        MessageList<Object> out = MessageList.newInstance();
         try {
-            ByteBuf in = ctx.inboundByteBuffer();
-            if (in.isReadable()) {
-                callDecode(ctx, in);
+            if (cumulation != null) {
+                callDecode(ctx, cumulation, out);
+                decodeLast(ctx, cumulation, out);
+            } else {
+                decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);
             }
-            decodeLast(ctx, in, out);
-        } catch (CodecException e) {
+        } catch (DecoderException e) {
             throw e;
-        } catch (Throwable cause) {
-            throw new DecoderException(cause);
+        } catch (Exception e) {
+            throw new DecoderException(e);
         } finally {
-            if (out.drainToNextInbound(ctx)) {
-                ctx.fireInboundBufferUpdated();
+            if (cumulation != null) {
+                cumulation.release();
+                cumulation = null;
             }
+
+            ctx.fireMessageReceived(out);
             ctx.fireChannelInactive();
         }
     }
 
-    protected void callDecode(ChannelHandlerContext ctx, ByteBuf in) {
-        boolean wasNull = false;
-        OutputMessageBuf out = OutputMessageBuf.get();
+    protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) {
         try {
             while (in.isReadable()) {
                 int outSize = out.size();
                 int oldInputLength = in.readableBytes();
                 decode(ctx, in, out);
                 if (outSize == out.size()) {
-                    wasNull = true;
                     if (oldInputLength == in.readableBytes()) {
                         break;
                     } else {
@@ -118,10 +229,10 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in) {
                     }
                 }
 
-                wasNull = false;
                 if (oldInputLength == in.readableBytes()) {
-                    throw new IllegalStateException(
-                         "decode() did not read anything but decoded a message.");
+                    throw new DecoderException(
+                            StringUtil.simpleClassName(getClass()) +
+                            ".decode() did not read anything but decoded a message.");
                 }
 
                 if (isSingleDecode()) {
@@ -132,15 +243,6 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in) {
             throw e;
         } catch (Throwable cause) {
             throw new DecoderException(cause);
-        } finally {
-            if (out.drainToNextInbound(ctx)) {
-                decodeWasNull = false;
-                ctx.fireInboundBufferUpdated();
-            } else {
-                if (wasNull) {
-                    decodeWasNull = true;
-                }
-            }
         }
     }
 
@@ -149,22 +251,22 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in) {
      * {@link ByteBuf} has nothing to read anymore, till nothing was read from the input {@link ByteBuf} or till
      * this method returns {@code null}.
      *
-     * @param ctx           the {@link ChannelHandlerContext} which this {@link ByteToByteDecoder} belongs to
+     * @param ctx           the {@link ChannelHandlerContext} which this {@link ByteToMessageDecoder} belongs to
      * @param in            the {@link ByteBuf} from which to read data
-     * @param out           the {@link MessageBuf} to which decoded messages should be added
+     * @param out           the {@link MessageList} to which decoded messages should be added
 
      * @throws Exception    is thrown if an error accour
      */
-    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception;
+    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception;
 
     /**
      * Is called one last time when the {@link ChannelHandlerContext} goes in-active. Which means the
      * {@link #channelInactive(ChannelHandlerContext)} was triggered.
      *
-     * By default this will just call {@link #decode(ChannelHandlerContext, ByteBuf, MessageBuf)} but sub-classes may
+     * By default this will just call {@link #decode(ChannelHandlerContext, ByteBuf, MessageList)} but sub-classes may
      * override this for some special cleanup operation.
      */
-    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         decode(ctx, in, out);
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
index 3d22a7dc8321..1a0a02d2fa02 100644
--- a/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 
 /**
  * A decoder that splits the received {@link ByteBuf}s by one or more
@@ -211,7 +211,7 @@ private boolean isSubclass() {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         Object decoded = decode(ctx, in);
         if (decoded != null) {
             out.add(decoded);
diff --git a/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
index 600c19babdda..3cc025e7118e 100644
--- a/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
@@ -16,9 +16,8 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
+import io.netty.channel.MessageList;
 
 /**
  * A decoder that splits the received {@link ByteBuf}s by the fixed number
@@ -39,51 +38,30 @@
 public class FixedLengthFrameDecoder extends ByteToMessageDecoder {
 
     private final int frameLength;
-    private final boolean allocateFullBuffer;
-
-    /**
-     * Calls {@link #FixedLengthFrameDecoder(int, boolean)} with {@code false}
-     */
-    public FixedLengthFrameDecoder(int frameLength) {
-        this(frameLength, false);
-    }
 
     /**
      * Creates a new instance.
      *
-     * @param frameLength
-     *        the length of the frame
-     * @param allocateFullBuffer
-     *        {@code true} if the cumulative {@link ByteBuf} should use the
-     *        {@link #frameLength} as its initial size
+     * @param frameLength the length of the frame
      */
-    public FixedLengthFrameDecoder(int frameLength, boolean allocateFullBuffer) {
+    public FixedLengthFrameDecoder(int frameLength) {
         if (frameLength <= 0) {
             throw new IllegalArgumentException(
                     "frameLength must be a positive integer: " + frameLength);
         }
         this.frameLength = frameLength;
-        this.allocateFullBuffer = allocateFullBuffer;
-    }
-
-    @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        if (allocateFullBuffer) {
-            return ChannelHandlerUtil.allocate(ctx, frameLength);
-        } else {
-            return super.newInboundBuffer(ctx);
-        }
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         Object decoded = decode(ctx, in);
         if (decoded != null) {
             out.add(decoded);
         }
     }
 
-    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+    protected Object decode(
+            @SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx, ByteBuf in) throws Exception {
         if (in.readableBytes() < frameLength) {
             return null;
         } else {
diff --git a/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
index b9a6e357b2e4..d554eff75981 100644
--- a/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
@@ -16,9 +16,9 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.serialization.ObjectDecoder;
 
 import java.nio.ByteOrder;
@@ -348,7 +348,7 @@ public LengthFieldBasedFrameDecoder(
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         Object decoded = decode(ctx, in);
         if (decoded != null) {
             out.add(decoded);
diff --git a/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
index 41153fc25f16..414ebb38c096 100644
--- a/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 
 /**
  * A decoder that splits the received {@link ByteBuf}s on line endings.
@@ -69,7 +69,7 @@ public LineBasedFrameDecoder(final int maxLength, final boolean stripDelimiter,
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         Object decoded = decode(ctx, in);
         if (decoded != null) {
             out.add(decoded);
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
index 9aec6d9823b9..9c19681e6670 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java
@@ -16,13 +16,16 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundMessageHandlerAdapter;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
+import io.netty.util.internal.TypeParameterMatcher;
 
 
 /**
- * {@link ChannelOutboundMessageHandlerAdapter} which encodes message in a stream-like fashion from one message to an
+ * {@link ChannelOutboundHandlerAdapter} which encodes message in a stream-like fashion from one message to an
  * {@link ByteBuf}.
  *
  *
@@ -38,27 +41,102 @@
  *     }
  * </pre>
  */
-public abstract class MessageToByteEncoder<I> extends ChannelOutboundMessageHandlerAdapter<I> {
+public abstract class MessageToByteEncoder<I> extends ChannelOutboundHandlerAdapter {
 
-    protected MessageToByteEncoder() { }
+    private final TypeParameterMatcher matcher;
+    private final boolean preferDirect;
+
+    protected MessageToByteEncoder() {
+        this(true);
+    }
 
     protected MessageToByteEncoder(Class<? extends I> outboundMessageType) {
-        super(outboundMessageType);
+        this(outboundMessageType, true);
+    }
+
+    protected MessageToByteEncoder(boolean preferDirect) {
+        matcher = TypeParameterMatcher.find(this, MessageToByteEncoder.class, "I");
+        this.preferDirect = preferDirect;
+    }
+
+    protected MessageToByteEncoder(Class<? extends I> outboundMessageType, boolean preferDirect) {
+        matcher = TypeParameterMatcher.get(outboundMessageType);
+        this.preferDirect = preferDirect;
+    }
+
+    public boolean acceptOutboundMessage(Object msg) throws Exception {
+        return matcher.match(msg);
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, I msg) throws Exception {
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        MessageList<Object> out = MessageList.newInstance();
+        boolean success = false;
+        ByteBuf buf = null;
         try {
-            encode(ctx, msg, ctx.nextOutboundByteBuffer());
-        } catch (CodecException e) {
+            int size = msgs.size();
+            for (int i = 0; i < size; i ++) {
+                // handler was removed in the loop so now copy over all remaining messages
+                if (ctx.isRemoved()) {
+                    if (buf != null && buf.isReadable())  {
+                        out.add(buf);
+                    }
+                    out.add(msgs, i, size - i);
+                    break;
+                }
+                Object m = msgs.get(i);
+                if (acceptOutboundMessage(m)) {
+                    @SuppressWarnings("unchecked")
+                    I cast = (I) m;
+                    if (buf == null) {
+                        if (preferDirect) {
+                            buf = ctx.alloc().ioBuffer();
+                        } else {
+                            buf = ctx.alloc().heapBuffer();
+                        }
+                    }
+                    try {
+                        encode(ctx, cast, buf);
+                    } finally {
+                        ByteBufUtil.release(cast);
+                    }
+                } else {
+                    if (buf != null && buf.isReadable()) {
+                        out.add(buf);
+                        buf = null;
+                    }
+
+                    out.add(m);
+                }
+            }
+
+            if (buf != null) {
+                if (buf.isReadable()) {
+                    out.add(buf);
+                    buf = null;
+                }
+            }
+
+            success = true;
+        } catch (EncoderException e) {
             throw e;
-        } catch (Exception e) {
-            throw new CodecException(e);
+        } catch (Throwable e) {
+            throw new EncoderException(e);
+        } finally {
+            msgs.recycle();
+            if (buf != null) {
+                buf.release();
+            }
+            if (success) {
+                ctx.write(out, promise);
+            } else {
+                out.releaseAllAndRecycle();
+            }
         }
     }
 
     /**
-     * Encode a message into a {@link ByteBuf}. This method will be called till the {@link MessageBuf} has
+     * Encode a message into a {@link ByteBuf}. This method will be called till the {@link MessageList} has
      * nothing left.
      *
      * @param ctx           the {@link ChannelHandlerContext} which this {@link MessageToByteEncoder} belongs to
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
index f2bd26a43bb5..cd10936950e7 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java
@@ -15,12 +15,11 @@
  */
 package io.netty.handler.codec;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.TypeParameterMatcher;
 
 /**
@@ -47,14 +46,15 @@
  *         }
  *     }
  * </pre>
+ *
+ * Be aware that you need to call {@link ReferenceCounted#retain()} on messages that are just passed through if they
+ * are of type {@link ReferenceCounted}. This is needed as the {@link MessageToMessageCodec} will call
+ * {@link ReferenceCounted#release()} on encoded / decoded messages.
  */
-public abstract class MessageToMessageCodec<INBOUND_IN, OUTBOUND_IN>
-        extends ChannelDuplexHandler
-        implements ChannelInboundMessageHandler<INBOUND_IN>,
-                   ChannelOutboundMessageHandler<OUTBOUND_IN> {
+public abstract class MessageToMessageCodec<INBOUND_IN, OUTBOUND_IN> extends ChannelDuplexHandler {
+
+    private final MessageToMessageEncoder<Object> encoder = new MessageToMessageEncoder<Object>() {
 
-    private final MessageToMessageEncoder<Object> encoder =
-            new MessageToMessageEncoder<Object>() {
         @Override
         public boolean acceptOutboundMessage(Object msg) throws Exception {
             return MessageToMessageCodec.this.acceptOutboundMessage(msg);
@@ -62,13 +62,12 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
 
         @Override
         @SuppressWarnings("unchecked")
-        protected void encode(ChannelHandlerContext ctx, Object msg, MessageBuf<Object> out) throws Exception {
+        protected void encode(ChannelHandlerContext ctx, Object msg, MessageList<Object> out) throws Exception {
             MessageToMessageCodec.this.encode(ctx, (OUTBOUND_IN) msg, out);
         }
     };
 
-    private final MessageToMessageDecoder<Object> decoder =
-            new MessageToMessageDecoder<Object>() {
+    private final MessageToMessageDecoder<Object> decoder = new MessageToMessageDecoder<Object>() {
 
         @Override
         public boolean acceptInboundMessage(Object msg) throws Exception {
@@ -77,7 +76,7 @@ public boolean acceptInboundMessage(Object msg) throws Exception {
 
         @Override
         @SuppressWarnings("unchecked")
-        protected void decode(ChannelHandlerContext ctx, Object msg, MessageBuf<Object> out) throws Exception {
+        protected void decode(ChannelHandlerContext ctx, Object msg, MessageList<Object> out) throws Exception {
             MessageToMessageCodec.this.decode(ctx, (INBOUND_IN) msg, out);
         }
     };
@@ -97,26 +96,13 @@ protected MessageToMessageCodec(
     }
 
     @Override
-    @SuppressWarnings("unchecked")
-    public MessageBuf<INBOUND_IN> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return (MessageBuf<INBOUND_IN>) decoder.newInboundBuffer(ctx);
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public MessageBuf<OUTBOUND_IN> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return (MessageBuf<OUTBOUND_IN>) encoder.newOutboundBuffer(ctx);
-    }
-
-    @Override
-    public void inboundBufferUpdated(
-            ChannelHandlerContext ctx) throws Exception {
-        decoder.inboundBufferUpdated(ctx);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        decoder.messageReceived(ctx, msgs);
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise future) throws Exception {
-        encoder.flush(ctx, future);
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        encoder.write(ctx, msgs, promise);
     }
 
     /**
@@ -137,6 +123,8 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
         return outboundMsgMatcher.match(msg);
     }
 
-    protected abstract void encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, MessageBuf<Object> out) throws Exception;
-    protected abstract void decode(ChannelHandlerContext ctx, INBOUND_IN msg, MessageBuf<Object> out) throws Exception;
+    protected abstract void encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, MessageList<Object> out)
+            throws Exception;
+    protected abstract void decode(ChannelHandlerContext ctx, INBOUND_IN msg, MessageList<Object> out)
+            throws Exception;
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
index 91d24eb4da71..e63b50647910 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
@@ -15,13 +15,16 @@
  */
 package io.netty.handler.codec;
 
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCounted;
+import io.netty.util.internal.TypeParameterMatcher;
 
 /**
- * {@link ChannelInboundMessageHandler} which decodes from one message to an other message
+ * {@link ChannelInboundHandlerAdapter} which decodes from one message to an other message.
+ *
  *
  * For example here is an implementation which decodes a {@link String} to an {@link Integer} which represent
  * the length of the {@link String}.
@@ -32,43 +35,76 @@
  *
  *         {@code @Override}
  *         public void decode({@link ChannelHandlerContext} ctx, {@link String} message,
- *                 {@link MessageBuf} out) throws {@link Exception} {
+ *                 {@link MessageList} out) throws {@link Exception} {
  *             out.add(message.length());
  *         }
  *     }
  * </pre>
  *
+ * Be aware that you need to call {@link ReferenceCounted#retain()} on messages that are just passed through if they
+ * are of type {@link ReferenceCounted}. This is needed as the {@link MessageToMessageDecoder} will call
+ * {@link ReferenceCounted#release()} on decoded messages.
+ *
  */
-public abstract class MessageToMessageDecoder<I> extends ChannelInboundMessageHandlerAdapter<I> {
+public abstract class MessageToMessageDecoder<I> extends ChannelInboundHandlerAdapter {
 
-    protected MessageToMessageDecoder() { }
+    private final TypeParameterMatcher matcher;
+
+    protected MessageToMessageDecoder() {
+        matcher = TypeParameterMatcher.find(this, MessageToMessageDecoder.class, "I");
+    }
 
     protected MessageToMessageDecoder(Class<? extends I> inboundMessageType) {
-        super(inboundMessageType);
+        matcher = TypeParameterMatcher.get(inboundMessageType);
+    }
+
+    public boolean acceptInboundMessage(Object msg) throws Exception {
+        return matcher.match(msg);
     }
 
     @Override
-    public final void messageReceived(ChannelHandlerContext ctx, I msg) throws Exception {
-        OutputMessageBuf out = OutputMessageBuf.get();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<Object> out = MessageList.newInstance();
         try {
-            decode(ctx, msg, out);
-        } catch (CodecException e) {
+            int size = msgs.size();
+            for (int i = 0; i < size; i ++) {
+                // handler was removed in the loop so now copy over all remaining messages
+                if (ctx.isRemoved()) {
+                    out.add(msgs, i, size - i);
+                    return;
+                }
+
+                Object m = msgs.get(i);
+                if (acceptInboundMessage(m)) {
+                    @SuppressWarnings("unchecked")
+                    I cast = (I) m;
+                    try {
+                        decode(ctx, cast, out);
+                    } finally {
+                        ByteBufUtil.release(cast);
+                    }
+                } else {
+                    out.add(m);
+                }
+            }
+        } catch (DecoderException e) {
             throw e;
-        } catch (Throwable cause) {
-            throw new DecoderException(cause);
+        } catch (Exception e) {
+            throw new DecoderException(e);
         } finally {
-            out.drainToNextInbound(ctx);
+            msgs.recycle();
+            ctx.fireMessageReceived(out);
         }
     }
 
     /**
-     * Decode from one message to an other. This method will be called till either the {@link MessageBuf} has
+     * Decode from one message to an other. This method will be called till either the {@link MessageList} has
      * nothing left or till this method returns {@code null}.
      *
      * @param ctx           the {@link ChannelHandlerContext} which this {@link MessageToMessageDecoder} belongs to
      * @param msg           the message to decode to an other one
-     * @param out           the {@link MessageBuf} to which decoded messages should be added
+     * @param out           the {@link MessageList} to which decoded messages should be added
      * @throws Exception    is thrown if an error accour
      */
-    protected abstract void decode(ChannelHandlerContext ctx, I msg, MessageBuf<Object> out) throws Exception;
+    protected abstract void decode(ChannelHandlerContext ctx, I msg, MessageList<Object> out) throws Exception;
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
index 4195ba9c3a7b..471d6cfd9d1f 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
@@ -15,12 +15,16 @@
  */
 package io.netty.handler.codec;
 
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundMessageHandlerAdapter;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
+import io.netty.util.ReferenceCounted;
+import io.netty.util.internal.TypeParameterMatcher;
 
 /**
- * {@link ChannelOutboundMessageHandlerAdapter} which encodes from one message to an other message
+ * {@link ChannelOutboundHandlerAdapter} which encodes from one message to an other message
  *
  * For example here is an implementation which decodes an {@link Integer} to an {@link String}.
  *
@@ -29,45 +33,82 @@
  *             {@link MessageToMessageEncoder}&lt;{@link Integer}&gt; {
  *
  *         {@code @Override}
- *         public void encode({@link ChannelHandlerContext} ctx, {@link Integer} message, {@link MessageBuf} out)
+ *         public void encode({@link ChannelHandlerContext} ctx, {@link Integer} message, {@link MessageList} out)
  *                 throws {@link Exception} {
  *             out.add(message.toString());
  *         }
  *     }
  * </pre>
  *
+ * Be aware that you need to call {@link ReferenceCounted#retain()} on messages that are just passed through if they
+ * are of type {@link ReferenceCounted}. This is needed as the {@link MessageToMessageEncoder} will call
+ * {@link ReferenceCounted#release()} on encoded messages.
  */
-public abstract class MessageToMessageEncoder<I> extends ChannelOutboundMessageHandlerAdapter<I> {
+public abstract class MessageToMessageEncoder<I> extends ChannelOutboundHandlerAdapter {
 
-    protected MessageToMessageEncoder() { }
+    private final TypeParameterMatcher matcher;
+
+    protected MessageToMessageEncoder() {
+        matcher = TypeParameterMatcher.find(this, MessageToMessageEncoder.class, "I");
+    }
 
     protected MessageToMessageEncoder(Class<? extends I> outboundMessageType) {
-        super(outboundMessageType);
+        matcher = TypeParameterMatcher.get(outboundMessageType);
+    }
+
+    public boolean acceptOutboundMessage(Object msg) throws Exception {
+        return matcher.match(msg);
     }
 
     @Override
-    public final void flush(ChannelHandlerContext ctx, I msg) throws Exception {
-        OutputMessageBuf out = OutputMessageBuf.get();
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        MessageList<Object> out = MessageList.newInstance();
+        boolean success = false;
         try {
-            encode(ctx, msg, out);
+            int size = msgs.size();
+            for (int i = 0; i < size; i ++) {
+                // handler was removed in the loop so now copy over all remaining messages
+                if (ctx.isRemoved()) {
+                    out.add(msgs, i, size - i);
+                    break;
+                }
+                Object m = msgs.get(i);
+                if (acceptOutboundMessage(m)) {
+                    @SuppressWarnings("unchecked")
+                    I cast = (I) m;
+                    try {
+                        encode(ctx, cast, out);
+                    } finally {
+                        ByteBufUtil.release(cast);
+                    }
+                } else {
+                    out.add(m);
+                }
+            }
+            success = true;
         } catch (CodecException e) {
             throw e;
-        } catch (Throwable cause) {
-            throw new EncoderException(cause);
+        } catch (Throwable t) {
+            throw new EncoderException(t);
         } finally {
-            out.drainToNextOutbound(ctx);
+            msgs.recycle();
+            if (success) {
+                ctx.write(out, promise);
+            } else {
+                out.releaseAllAndRecycle();
+            }
         }
     }
 
     /**
-     * Encode from one message to an other. This method will be called till either the {@link MessageBuf} has nothing
+     * Encode from one message to an other. This method will be called till either the {@link MessageList} has nothing
      * left or till this method returns {@code null}.
      *
      * @param ctx           the {@link ChannelHandlerContext} which this {@link MessageToMessageEncoder} belongs to
      * @param msg           the message to encode to an other one
-     * @param out           the {@link MessageBuf} into which the encoded msg should be added
+     * @param out           the {@link MessageList} into which the encoded msg should be added
      *                      needs to do some kind of aggragation
      * @throws Exception    is thrown if an error accour
      */
-    protected abstract void encode(ChannelHandlerContext ctx, I msg, MessageBuf<Object> out) throws Exception;
+    protected abstract void encode(ChannelHandlerContext ctx, I msg, MessageList<Object> out) throws Exception;
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/OutputMessageBuf.java b/codec/src/main/java/io/netty/handler/codec/OutputMessageBuf.java
deleted file mode 100644
index 5491853cbdbb..000000000000
--- a/codec/src/main/java/io/netty/handler/codec/OutputMessageBuf.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.codec;
-
-import io.netty.buffer.BufType;
-import io.netty.buffer.BufUtil;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.DefaultMessageBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelHandlerContext;
-
-final class OutputMessageBuf extends DefaultMessageBuf<Object> {
-
-    private static final ThreadLocal<OutputMessageBuf> output =
-            new ThreadLocal<OutputMessageBuf>() {
-                @Override
-                protected OutputMessageBuf initialValue() {
-                    return new OutputMessageBuf();
-                }
-
-                @Override
-                public OutputMessageBuf get() {
-                    OutputMessageBuf buf = super.get();
-                    assert buf.isEmpty();
-                    return buf;
-                }
-            };
-
-    static OutputMessageBuf get() {
-        return output.get();
-    }
-
-    private int byteBufCnt;
-
-    private OutputMessageBuf() {
-        super(2);
-    }
-
-    @Override
-    public boolean offer(Object e) {
-        boolean added =  super.offer(e);
-        if (added) {
-            if (e instanceof ByteBuf) {
-                byteBufCnt ++;
-            }
-        }
-        return added;
-    }
-
-    @Override
-    public boolean remove(Object o) {
-        boolean removed = super.remove(o);
-        if (removed) {
-            if (o instanceof ByteBuf) {
-                byteBufCnt --;
-            }
-        }
-        return removed;
-    }
-
-    @Override
-    public Object poll() {
-        Object o = super.poll();
-        if (o == null) {
-            return o;
-        }
-        if (o instanceof ByteBuf) {
-            byteBufCnt --;
-        }
-        return o;
-    }
-
-    @Override
-    public void clear() {
-        super.clear();
-        byteBufCnt = 0;
-    }
-
-    public boolean drainToNextInbound(ChannelHandlerContext ctx) {
-        final int size = size();
-        if (size == 0) {
-            return false;
-        }
-
-        final int byteBufCnt = this.byteBufCnt;
-        if (byteBufCnt == 0 || ctx.nextInboundBufferType() != BufType.BYTE) {
-            return drainTo(ctx.nextInboundMessageBuffer()) > 0;
-        }
-
-        final ByteBuf nextByteBuf = ctx.nextInboundByteBuffer();
-        if (byteBufCnt == size) {
-            // Contains only ByteBufs
-            for (Object o = poll();;) {
-                writeAndRelease(nextByteBuf, (ByteBuf) o);
-                if ((o = poll()) == null) {
-                    break;
-                }
-            }
-        } else {
-            // Contains both ByteBufs and non-ByteBufs (0 < byteBufCnt < size())
-            final MessageBuf<Object> nextMsgBuf = ctx.nextInboundMessageBuffer();
-            for (Object o = poll();;) {
-                if (o instanceof ByteBuf) {
-                    writeAndRelease(nextByteBuf, (ByteBuf) o);
-                } else {
-                    nextMsgBuf.add(o);
-                }
-
-                if ((o = poll()) == null) {
-                    break;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    public boolean drainToNextOutbound(ChannelHandlerContext ctx) {
-        final int size = size();
-        if (size == 0) {
-            return false;
-        }
-
-        final int byteBufCnt = this.byteBufCnt;
-        if (byteBufCnt == 0 || ctx.nextOutboundBufferType() != BufType.BYTE) {
-            return drainTo(ctx.nextOutboundMessageBuffer()) > 0;
-        }
-
-        final ByteBuf nextByteBuf = ctx.nextOutboundByteBuffer();
-        if (byteBufCnt == size) {
-            // Contains only ByteBufs
-            for (Object o = poll();;) {
-                writeAndRelease(nextByteBuf, (ByteBuf) o);
-                if ((o = poll()) == null) {
-                    break;
-                }
-            }
-        } else {
-            // Contains both ByteBufs and non-ByteBufs (0 < byteBufCnt < size())
-            final MessageBuf<Object> nextMsgBuf = ctx.nextOutboundMessageBuffer();
-            for (Object o = poll();;) {
-                if (o instanceof ByteBuf) {
-                    writeAndRelease(nextByteBuf, (ByteBuf) o);
-                } else {
-                    nextMsgBuf.add(o);
-                }
-
-                if ((o = poll()) == null) {
-                    break;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    private static void writeAndRelease(ByteBuf dst, ByteBuf src) {
-        try {
-            dst.writeBytes(src, src.readerIndex(), src.readableBytes());
-        } finally {
-            BufUtil.release(src);
-        }
-    }
-}
diff --git a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
index f35ab7e8b664..f1f4025cb58c 100644
--- a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
@@ -19,7 +19,9 @@
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.util.Signal;
+import io.netty.util.internal.StringUtil;
 
 /**
  * A specialized variation of {@link ByteToMessageDecoder} which enables implementation
@@ -30,7 +32,7 @@
  * implement the {@code decode()} and {@code decodeLast()} methods just like
  * all required bytes were received already, rather than checking the
  * availability of the required bytes.  For example, the following
- * {@link ByteToByteDecoder} implementation:
+ * {@link ByteToMessageDecoder} implementation:
  * <pre>
  * public class IntegerHeaderFrameDecoder extends {@link ByteToMessageDecoder}&lt;{@link ByteBuf}&gt; {
  *
@@ -226,7 +228,7 @@
  * <p>
  * If you are going to write a protocol multiplexer, you will probably want to
  * replace a {@link ReplayingDecoder} (protocol detector) with another
- * {@link ReplayingDecoder}, {@link ByteToByteDecoder}, {@link ByteToMessageDecoder} or {@link MessageToMessageDecoder}
+ * {@link ReplayingDecoder}, {@link ByteToMessageDecoder} or {@link MessageToMessageDecoder}
  * (actual protocol decoder).
  * It is not possible to achieve this simply by calling
  * {@link ChannelPipeline#replace(ChannelHandler, String, ChannelHandler)}, but
@@ -264,11 +266,9 @@ public abstract class ReplayingDecoder<S> extends ByteToMessageDecoder {
 
     static final Signal REPLAY = new Signal(ReplayingDecoder.class.getName() + ".REPLAY");
 
-    private ChannelHandlerContext ctx;
     private final ReplayingDecoderBuffer replayable = new ReplayingDecoderBuffer();
     private S state;
     private int checkpoint = -1;
-    private boolean decodeWasNull;
 
     /**
      * Creates a new instance with no initial state (i.e: {@code null}).
@@ -318,89 +318,47 @@ protected S state(S newState) {
         return oldState;
     }
 
-    /**
-     * Returns the actual number of readable bytes in the internal cumulative
-     * buffer of this decoder. You usually do not need to rely on this value
-     * to write a decoder. Use it only when you muse use it at your own risk.
-     * This method is a shortcut to {@link #internalBuffer() internalBuffer().readableBytes()}.
-     */
-    protected int actualReadableBytes() {
-        return internalBuffer().readableBytes();
-    }
-
-    /**
-     * Returns the internal cumulative buffer of this decoder. You usually
-     * do not need to access the internal buffer directly to write a decoder.
-     * Use it only when you must use it at your own risk.
-     */
-    protected ByteBuf internalBuffer() {
-        return ctx.inboundByteBuffer();
-    }
-
-    @Override
-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-        this.ctx = ctx;
-    }
-
-    @Override
-    public final void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        ByteBuf in = ctx.inboundByteBuffer();
-        final int oldReaderIndex = in.readerIndex();
-        discardInboundReadBytes0(ctx);
-        final int newReaderIndex = in.readerIndex();
-        checkpoint -= oldReaderIndex - newReaderIndex;
-    }
-
-    protected void discardInboundReadBytes0(ChannelHandlerContext ctx) throws Exception {
-        super.discardInboundReadBytes(ctx);
-    }
-
     @Override
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        OutputMessageBuf out = OutputMessageBuf.get();
+        MessageList<Object> out = MessageList.newInstance();
         try {
             replayable.terminate();
-            ByteBuf in = internalBuffer();
-            replayable.setCumulation(in);
-            if (in.isReadable()) {
-                callDecode(ctx, in);
-            }
-
+            callDecode(ctx, internalBuffer(), out);
             decodeLast(ctx, replayable, out);
         } catch (Signal replay) {
             // Ignore
             replay.expect(REPLAY);
-        } catch (CodecException e) {
+        } catch (DecoderException e) {
             throw e;
-        } catch (Throwable cause) {
-            throw new DecoderException(cause);
+        } catch (Exception e) {
+            throw new DecoderException(e);
         } finally {
-            if (out.drainToNextInbound(ctx)) {
-                ctx.fireInboundBufferUpdated();
+            if (cumulation != null) {
+                cumulation.release();
+                cumulation = null;
             }
 
+            ctx.fireMessageReceived(out);
             ctx.fireChannelInactive();
         }
     }
 
     @Override
-    protected void callDecode(ChannelHandlerContext ctx, ByteBuf buf) {
-        boolean wasNull = false;
-        ByteBuf in = internalBuffer();
+    protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) {
         replayable.setCumulation(in);
-        OutputMessageBuf out = OutputMessageBuf.get();
         try {
             while (in.isReadable()) {
                 int oldReaderIndex = checkpoint = in.readerIndex();
                 int outSize = out.size();
                 S oldState = state;
+                int oldInputLength = in.readableBytes();
                 try {
                     decode(ctx, replayable, out);
                     if (outSize == out.size()) {
-                        wasNull = true;
-                        if (oldReaderIndex == in.readerIndex() && oldState == state) {
-                            throw new IllegalStateException(
-                                    "null cannot be returned if no data is consumed and state didn't change.");
+                        if (oldInputLength == in.readableBytes() && oldState == state) {
+                            throw new DecoderException(
+                                    StringUtil.simpleClassName(getClass()) + ".decode() must consume the inbound " +
+                                    "data or change its state if it did not decode anything.");
                         } else {
                             // Previous data has been discarded or caused state transition.
                             // Probably it is reading on.
@@ -419,43 +377,20 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf buf) {
                     }
                     break;
                 }
-                wasNull = false;
 
                 if (oldReaderIndex == in.readerIndex() && oldState == state) {
-                    throw new IllegalStateException(
-                           "decode() method must consume at least one byte " +
-                           "if it returned a decoded message (caused by: " +
-                           getClass() + ')');
+                    throw new DecoderException(
+                           StringUtil.simpleClassName(getClass()) + ".decode() method must consume the inbound data " +
+                           "or change its state if it decoded something.");
                 }
                 if (isSingleDecode()) {
                     break;
                 }
             }
-        } catch (CodecException e) {
+        } catch (DecoderException e) {
             throw e;
         } catch (Throwable cause) {
             throw new DecoderException(cause);
-        } finally {
-            if (out.drainToNextInbound(ctx)) {
-                decodeWasNull = false;
-                ctx.fireInboundBufferUpdated();
-            } else {
-                if (wasNull) {
-                    decodeWasNull = true;
-                }
-            }
         }
     }
-
-    @Override
-    public void channelReadSuspended(ChannelHandlerContext ctx) throws Exception {
-        if (decodeWasNull) {
-            decodeWasNull = false;
-            if (!ctx.channel().config().isAutoRead()) {
-                ctx.read();
-            }
-        }
-
-        super.channelReadSuspended(ctx);
-    }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
index edfa277d8a8c..9f362e3bba71 100644
--- a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java
@@ -15,7 +15,6 @@
  */
 package io.netty.handler.codec;
 
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufIndexFinder;
@@ -81,11 +80,6 @@ public int maxCapacity() {
         return capacity();
     }
 
-    @Override
-    public BufType type() {
-        return BufType.BYTE;
-    }
-
     @Override
     public ByteBufAllocator alloc() {
         return buffer.alloc();
@@ -735,6 +729,12 @@ public ByteBuffer[] nioBuffers(int index, int length) {
         return buffer.nioBuffers(index, length);
     }
 
+    @Override
+    public ByteBuffer internalNioBuffer(int index, int length) {
+        checkIndex(index, length);
+        return buffer.internalNioBuffer(index, length);
+    }
+
     @Override
     public String toString(int index, int length, Charset charset) {
         checkIndex(index, length);
@@ -925,16 +925,6 @@ public boolean release(int decrement) {
         throw new UnreplayableOperationException();
     }
 
-    @Override
-    public ByteBuf suspendIntermediaryDeallocations() {
-        throw new UnreplayableOperationException();
-    }
-
-    @Override
-    public ByteBuf resumeIntermediaryDeallocations() {
-        throw new UnreplayableOperationException();
-    }
-
     @Override
     public ByteBuf unwrap() {
         throw new UnreplayableOperationException();
diff --git a/codec/src/main/java/io/netty/handler/codec/base64/Base64Decoder.java b/codec/src/main/java/io/netty/handler/codec/base64/Base64Decoder.java
index ff1eb4458d27..f8b13edaa92e 100644
--- a/codec/src/main/java/io/netty/handler/codec/base64/Base64Decoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64Decoder.java
@@ -16,10 +16,10 @@
 package io.netty.handler.codec.base64;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
@@ -59,7 +59,7 @@ public Base64Decoder(Base64Dialect dialect) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
         out.add(Base64.decode(msg, msg.readerIndex(), msg.readableBytes(), dialect));
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/base64/Base64Encoder.java b/codec/src/main/java/io/netty/handler/codec/base64/Base64Encoder.java
index b79b0fbe04bb..5af5b7106521 100644
--- a/codec/src/main/java/io/netty/handler/codec/base64/Base64Encoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64Encoder.java
@@ -18,11 +18,11 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelOutboundMessageHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
+import io.netty.handler.codec.MessageToMessageEncoder;
 
 /**
  * Encodes a {@link ByteBuf} into a Base64-encoded {@link ByteBuf}.
@@ -39,7 +39,7 @@
  * </pre>
  */
 @Sharable
-public class Base64Encoder extends ChannelOutboundMessageHandlerAdapter<ByteBuf> {
+public class Base64Encoder extends MessageToMessageEncoder<ByteBuf> {
 
     private final boolean breakLines;
     private final Base64Dialect dialect;
@@ -62,9 +62,7 @@ public Base64Encoder(boolean breakLines, Base64Dialect dialect) {
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx,
-            ByteBuf msg) throws Exception {
-        ByteBuf buf = Base64.encode(msg, msg.readerIndex(), msg.readableBytes(), breakLines, dialect);
-        ChannelHandlerUtil.addToNextOutboundBuffer(ctx, buf);
+    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
+        out.add(Base64.encode(msg, msg.readerIndex(), msg.readableBytes(), breakLines, dialect));
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
index 1d0f8acf9e98..a1d15b6d2f66 100644
--- a/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.bytes;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
 import io.netty.handler.codec.MessageToMessageDecoder;
@@ -48,9 +48,8 @@
  * </pre>
  */
 public class ByteArrayDecoder extends MessageToMessageDecoder<ByteBuf> {
-
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
         byte[] array;
         if (msg.hasArray()) {
             if (msg.arrayOffset() == 0 && msg.readableBytes() == msg.capacity()) {
diff --git a/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java
index 9a0d8bf206ab..1014084e63c0 100644
--- a/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java
@@ -19,10 +19,11 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundMessageHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
+import io.netty.handler.codec.MessageToMessageEncoder;
 
 /**
  * Encodes the requested array of bytes into a {@link ByteBuf}.
@@ -49,23 +50,9 @@
  * </pre>
  */
 @Sharable
-public class ByteArrayEncoder extends ChannelOutboundMessageHandlerAdapter<byte[]> {
-
+public class ByteArrayEncoder extends MessageToMessageEncoder<byte[]> {
     @Override
-    public void flush(ChannelHandlerContext ctx, byte[] msg) throws Exception {
-        if (msg.length == 0) {
-            return;
-        }
-
-        switch (ctx.nextOutboundBufferType()) {
-            case BYTE:
-                ctx.nextOutboundByteBuffer().writeBytes(msg);
-                break;
-            case MESSAGE:
-                ctx.nextOutboundMessageBuffer().add(Unpooled.wrappedBuffer(msg));
-                break;
-            default:
-                throw new Error();
-        }
+    protected void encode(ChannelHandlerContext ctx, byte[] msg, MessageList<Object> out) throws Exception {
+        out.add(Unpooled.wrappedBuffer(msg));
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/CompressionException.java b/codec/src/main/java/io/netty/handler/codec/compression/CompressionException.java
index 89f17b419805..167e45dd7de9 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/CompressionException.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/CompressionException.java
@@ -15,13 +15,12 @@
  */
 package io.netty.handler.codec.compression;
 
-import io.netty.handler.codec.CodecException;
+import io.netty.handler.codec.EncoderException;
 
 /**
- * An {@link CodecException} that is raised when compression or decompression
- * failed.
+ * An {@link EncoderException} that is raised when compression failed.
  */
-public class CompressionException extends CodecException {
+public class CompressionException extends EncoderException {
 
     private static final long serialVersionUID = 5603413481274811897L;
 
diff --git a/buffer/src/main/java/io/netty/buffer/IllegalBufferAccessException.java b/codec/src/main/java/io/netty/handler/codec/compression/DecompressionException.java
similarity index 51%
rename from buffer/src/main/java/io/netty/buffer/IllegalBufferAccessException.java
rename to codec/src/main/java/io/netty/handler/codec/compression/DecompressionException.java
index 52b10294a797..8fc016bf8d19 100644
--- a/buffer/src/main/java/io/netty/buffer/IllegalBufferAccessException.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/DecompressionException.java
@@ -13,28 +13,41 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
+package io.netty.handler.codec.compression;
 
-package io.netty.buffer;
+import io.netty.handler.codec.DecoderException;
 
 /**
- * An {@link IllegalStateException} raised when a user attempts to access a {@link Buf} which was freed by
- * {@link Buf#release()} } already.
+ * A {@link DecoderException} that is raised when decompression failed.
  */
-public class IllegalBufferAccessException extends IllegalStateException {
+public class DecompressionException extends DecoderException {
 
-    private static final long serialVersionUID = -6734326916218551327L;
+    private static final long serialVersionUID = 3546272712208105199L;
 
-    public IllegalBufferAccessException() { }
-
-    public IllegalBufferAccessException(String message) {
-        super(message);
+    /**
+     * Creates a new instance.
+     */
+    public DecompressionException() {
     }
 
-    public IllegalBufferAccessException(String message, Throwable cause) {
+    /**
+     * Creates a new instance.
+     */
+    public DecompressionException(String message, Throwable cause) {
         super(message, cause);
     }
 
-    public IllegalBufferAccessException(Throwable cause) {
+    /**
+     * Creates a new instance.
+     */
+    public DecompressionException(String message) {
+        super(message);
+    }
+
+    /**
+     * Creates a new instance.
+     */
+    public DecompressionException(Throwable cause) {
         super(cause);
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java
index a4dfe4a0a9d5..ca9b39dd98fa 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java
@@ -15,10 +15,11 @@
  */
 package io.netty.handler.codec.compression;
 
+import com.jcraft.jzlib.Inflater;
+import com.jcraft.jzlib.JZlib;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import com.jcraft.jzlib.JZlib;
-import com.jcraft.jzlib.Inflater;
+import io.netty.channel.MessageList;
 
 public class JZlibDecoder extends ZlibDecoder {
 
@@ -81,9 +82,7 @@ public boolean isClosed() {
     }
 
     @Override
-    protected void decode(
-            ChannelHandlerContext ctx,
-            ByteBuf in, ByteBuf out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
 
         if (!in.isReadable()) {
             return;
@@ -92,14 +91,13 @@ protected void decode(
         try {
             // Configure input.
             int inputLength = in.readableBytes();
-            boolean inHasArray = in.hasArray();
             z.avail_in = inputLength;
-            if (inHasArray) {
+            if (in.hasArray()) {
                 z.next_in = in.array();
                 z.next_in_index = in.arrayOffset() + in.readerIndex();
             } else {
                 byte[] array = new byte[inputLength];
-                in.readBytes(array);
+                in.getBytes(in.readerIndex(), array);
                 z.next_in = array;
                 z.next_in_index = 0;
             }
@@ -107,32 +105,21 @@ protected void decode(
 
             // Configure output.
             int maxOutputLength = inputLength << 1;
-            boolean outHasArray = out.hasArray();
-            if (!outHasArray) {
-                z.next_out = new byte[maxOutputLength];
-            }
+            ByteBuf decompressed = ctx.alloc().heapBuffer(maxOutputLength);
 
             try {
                 loop: for (;;) {
                     z.avail_out = maxOutputLength;
-                    if (outHasArray) {
-                        out.ensureWritable(maxOutputLength);
-                        z.next_out = out.array();
-                        z.next_out_index = out.arrayOffset() + out.writerIndex();
-                    } else {
-                        z.next_out_index = 0;
-                    }
+                    decompressed.ensureWritable(maxOutputLength);
+                    z.next_out = decompressed.array();
+                    z.next_out_index = decompressed.arrayOffset() + decompressed.writerIndex();
                     int oldNextOutIndex = z.next_out_index;
 
                     // Decompress 'in' into 'out'
                     int resultCode = z.inflate(JZlib.Z_SYNC_FLUSH);
                     int outputLength = z.next_out_index - oldNextOutIndex;
                     if (outputLength > 0) {
-                        if (outHasArray) {
-                            out.writerIndex(out.writerIndex() + outputLength);
-                        } else {
-                            out.writeBytes(z.next_out, 0, outputLength);
-                        }
+                        decompressed.writerIndex(decompressed.writerIndex() + outputLength);
                     }
 
                     switch (resultCode) {
@@ -162,8 +149,11 @@ protected void decode(
                     }
                 }
             } finally {
-                if (inHasArray) {
-                    in.skipBytes(z.next_in_index - oldNextInIndex);
+                in.skipBytes(z.next_in_index - oldNextInIndex);
+                if (decompressed.isReadable()) {
+                    out.add(decompressed);
+                } else {
+                    decompressed.release();
                 }
             }
         } finally {
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
index 9a4d57a8a056..758feb0e81b6 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java
@@ -263,8 +263,7 @@ public boolean isClosed() {
     }
 
     @Override
-    protected void encode(ChannelHandlerContext ctx,
-            ByteBuf in, ByteBuf out) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
         if (finished.get()) {
             return;
         }
@@ -280,7 +279,7 @@ protected void encode(ChannelHandlerContext ctx,
                     z.next_in_index = in.arrayOffset() + in.readerIndex();
                 } else {
                     byte[] array = new byte[inputLength];
-                    in.readBytes(array);
+                    in.getBytes(in.readerIndex(), array);
                     z.next_in = array;
                     z.next_in_index = 0;
                 }
@@ -288,16 +287,9 @@ protected void encode(ChannelHandlerContext ctx,
 
                 // Configure output.
                 int maxOutputLength = (int) Math.ceil(inputLength * 1.001) + 12;
-                boolean outHasArray = out.hasArray();
                 z.avail_out = maxOutputLength;
-                if (outHasArray) {
-                    out.ensureWritable(maxOutputLength);
-                    z.next_out = out.array();
-                    z.next_out_index = out.arrayOffset() + out.writerIndex();
-                } else {
-                    z.next_out = new byte[maxOutputLength];
-                    z.next_out_index = 0;
-                }
+                z.next_out = out.array();
+                z.next_out_index = out.arrayOffset() + out.writerIndex();
                 int oldNextOutIndex = z.next_out_index;
 
                 // Note that Z_PARTIAL_FLUSH has been deprecated.
@@ -305,9 +297,7 @@ protected void encode(ChannelHandlerContext ctx,
                 try {
                     resultCode = z.deflate(JZlib.Z_SYNC_FLUSH);
                 } finally {
-                    if (inHasArray) {
-                        in.skipBytes(z.next_in_index - oldNextInIndex);
-                    }
+                    in.skipBytes(z.next_in_index - oldNextInIndex);
                 }
 
                 if (resultCode != JZlib.Z_OK) {
@@ -316,11 +306,7 @@ protected void encode(ChannelHandlerContext ctx,
 
                 int outputLength = z.next_out_index - oldNextOutIndex;
                 if (outputLength > 0) {
-                    if (outHasArray) {
-                        out.writerIndex(out.writerIndex() + outputLength);
-                    } else {
-                        out.writeBytes(z.next_out, 0, outputLength);
-                    }
+                    out.writerIndex(out.writerIndex() + outputLength);
                 }
             } finally {
                 // Deference the external references explicitly to tell the VM that
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
index 638b9ff16f7a..e225e731e3a3 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java
@@ -255,10 +255,7 @@ private ChannelFuture finishEncode(final ChannelHandlerContext ctx, ChannelPromi
             deflater.end();
         }
 
-        ctx.nextOutboundByteBuffer().writeBytes(footer);
-        ctx.flush(promise);
-
-        return promise;
+        return ctx.write(footer, promise);
     }
 
     @Override
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
index 4fd273d81e8d..3219f0b3ce58 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
@@ -15,8 +15,8 @@
  */
 package io.netty.handler.codec.compression;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 
 import java.util.zip.CRC32;
 
@@ -381,7 +381,7 @@ private static int readPreamble(ByteBuf in) {
             }
 
             if (byteIndex >= 4) {
-                throw new CompressionException("Preamble is greater than 4 bytes");
+                throw new DecompressionException("Preamble is greater than 4 bytes");
             }
         }
 
@@ -413,19 +413,19 @@ private static int decodeLiteral(byte tag, ByteBuf in, ByteBuf out) {
             if (in.readableBytes() < 2) {
                 return NOT_ENOUGH_INPUT;
             }
-            length = BufUtil.swapShort(in.readShort());
+            length = ByteBufUtil.swapShort(in.readShort());
             break;
         case 62:
             if (in.readableBytes() < 3) {
                 return NOT_ENOUGH_INPUT;
             }
-            length = BufUtil.swapMedium(in.readUnsignedMedium());
+            length = ByteBufUtil.swapMedium(in.readUnsignedMedium());
             break;
         case 64:
             if (in.readableBytes() < 4) {
                 return NOT_ENOUGH_INPUT;
             }
-            length = BufUtil.swapInt(in.readInt());
+            length = ByteBufUtil.swapInt(in.readInt());
             break;
         default:
             length = tag >> 2 & 0x3F;
@@ -452,7 +452,7 @@ private static int decodeLiteral(byte tag, ByteBuf in, ByteBuf out) {
      * @param out The output buffer to write to
      * @return The number of bytes appended to the output buffer, or -1 to indicate
      *     "try again later"
-     * @throws CompressionException If the read offset is invalid
+     * @throws DecompressionException If the read offset is invalid
      */
     private static int decodeCopyWith1ByteOffset(byte tag, ByteBuf in, ByteBuf out, int writtenSoFar) {
         if (!in.isReadable()) {
@@ -494,7 +494,7 @@ private static int decodeCopyWith1ByteOffset(byte tag, ByteBuf in, ByteBuf out,
      *     the length and part of the offset
      * @param in The input buffer to read from
      * @param out The output buffer to write to
-     * @throws CompressionException If the read offset is invalid
+     * @throws DecompressionException If the read offset is invalid
      * @return The number of bytes appended to the output buffer, or -1 to indicate
      *     "try again later"
      */
@@ -505,7 +505,7 @@ private static int decodeCopyWith2ByteOffset(byte tag, ByteBuf in, ByteBuf out,
 
         int initialIndex = out.writerIndex();
         int length = 1 + (tag >> 2 & 0x03f);
-        int offset = BufUtil.swapShort(in.readShort());
+        int offset = ByteBufUtil.swapShort(in.readShort());
 
         validateOffset(offset, writtenSoFar);
 
@@ -540,7 +540,7 @@ private static int decodeCopyWith2ByteOffset(byte tag, ByteBuf in, ByteBuf out,
      * @param out The output buffer to write to
      * @return The number of bytes appended to the output buffer, or -1 to indicate
      *     "try again later"
-     * @throws CompressionException If the read offset is invalid
+     * @throws DecompressionException If the read offset is invalid
      */
     private static int decodeCopyWith4ByteOffset(byte tag, ByteBuf in, ByteBuf out, int writtenSoFar) {
         if (in.readableBytes() < 4) {
@@ -549,7 +549,7 @@ private static int decodeCopyWith4ByteOffset(byte tag, ByteBuf in, ByteBuf out,
 
         int initialIndex = out.writerIndex();
         int length = 1 + (tag >> 2 & 0x03F);
-        int offset = BufUtil.swapInt(in.readInt());
+        int offset = ByteBufUtil.swapInt(in.readInt());
 
         validateOffset(offset, writtenSoFar);
 
@@ -580,19 +580,19 @@ private static int decodeCopyWith4ByteOffset(byte tag, ByteBuf in, ByteBuf out,
      *
      * @param offset The offset extracted from the compressed reference
      * @param chunkSizeSoFar The number of bytes read so far from this chunk
-     * @throws CompressionException if the offset is invalid
+     * @throws DecompressionException if the offset is invalid
      */
     private static void validateOffset(int offset, int chunkSizeSoFar) {
         if (offset > Short.MAX_VALUE) {
-            throw new CompressionException("Offset exceeds maximum permissible value");
+            throw new DecompressionException("Offset exceeds maximum permissible value");
         }
 
         if (offset <= 0) {
-            throw new CompressionException("Offset is less than minimum permissible value");
+            throw new DecompressionException("Offset is less than minimum permissible value");
         }
 
         if (offset > chunkSizeSoFar) {
-            throw new CompressionException("Offset exceeds size of chunk");
+            throw new DecompressionException("Offset exceeds size of chunk");
         }
     }
 
@@ -636,7 +636,7 @@ public static int calculateChecksum(ByteBuf data, int offset, int length) {
      *
      * @param expectedChecksum The checksum decoded from the stream to compare against
      * @param data The input data to calculate the CRC32 checksum of
-     * @throws CompressionException If the calculated and supplied checksums do not match
+     * @throws DecompressionException If the calculated and supplied checksums do not match
      */
     static void validateChecksum(int expectedChecksum, ByteBuf data) {
         validateChecksum(expectedChecksum, data, data.readerIndex(), data.readableBytes());
@@ -649,12 +649,12 @@ static void validateChecksum(int expectedChecksum, ByteBuf data) {
      *
      * @param expectedChecksum The checksum decoded from the stream to compare against
      * @param data The input data to calculate the CRC32 checksum of
-     * @throws CompressionException If the calculated and supplied checksums do not match
+     * @throws DecompressionException If the calculated and supplied checksums do not match
      */
     static void validateChecksum(int expectedChecksum, ByteBuf data, int offset, int length) {
         final int actualChecksum = calculateChecksum(data, offset, length);
         if (actualChecksum != expectedChecksum) {
-            throw new CompressionException(
+            throw new DecompressionException(
                     "mismatching checksum: " + Integer.toHexString(actualChecksum) +
                             " (expected: " + Integer.toHexString(expectedChecksum) + ')');
         }
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
index 6c26d6729258..c0fa5eae8035 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java
@@ -15,10 +15,11 @@
  */
 package io.netty.handler.codec.compression;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.ByteToByteDecoder;
+import io.netty.channel.MessageList;
+import io.netty.handler.codec.ByteToMessageDecoder;
 
 import java.util.Arrays;
 
@@ -28,8 +29,14 @@
  * Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.
  *
  * See http://code.google.com/p/snappy/source/browse/trunk/framing_format.txt
+ *
+ * Note that by default, validation of the checksum header in each chunk is
+ * DISABLED for performance improvements. If performance is less of an issue,
+ * or if you would prefer the safety that checksum validation brings, please
+ * use the {@link #SnappyFramedDecoder(boolean)} constructor with the argument
+ * set to {@code true}.
  */
-public class SnappyFramedDecoder extends ByteToByteDecoder {
+public class SnappyFramedDecoder extends ByteToMessageDecoder {
     enum ChunkType {
         STREAM_IDENTIFIER,
         COMPRESSED_DATA,
@@ -48,7 +55,8 @@ enum ChunkType {
 
     /**
      * Creates a new snappy-framed decoder with validation of checksums
-     * turned off
+     * turned OFF. To turn checksum validation on, please use the alternate
+     * {@link #SnappyFramedDecoder(boolean)} constructor.
      */
     public SnappyFramedDecoder() {
         this(false);
@@ -61,14 +69,14 @@ public SnappyFramedDecoder() {
      * @param validateChecksums
      *        If true, the checksum field will be validated against the actual
      *        uncompressed data, and if the checksums do not match, a suitable
-     *        {@link CompressionException} will be thrown
+     *        {@link DecompressionException} will be thrown
      */
     public SnappyFramedDecoder(boolean validateChecksums) {
         this.validateChecksums = validateChecksums;
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         if (corrupted) {
             in.skipBytes(in.readableBytes());
             return;
@@ -85,12 +93,12 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
 
             final int chunkTypeVal = in.getUnsignedByte(idx);
             final ChunkType chunkType = mapChunkType((byte) chunkTypeVal);
-            final int chunkLength = BufUtil.swapMedium(in.getUnsignedMedium(idx + 1));
+            final int chunkLength = ByteBufUtil.swapMedium(in.getUnsignedMedium(idx + 1));
 
             switch (chunkType) {
                 case STREAM_IDENTIFIER:
                     if (chunkLength != SNAPPY.length) {
-                        throw new CompressionException("Unexpected length of stream identifier: " + chunkLength);
+                        throw new DecompressionException("Unexpected length of stream identifier: " + chunkLength);
                     }
 
                     if (inSize < 4 + SNAPPY.length) {
@@ -101,7 +109,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
                     in.skipBytes(4).readBytes(identifier);
 
                     if (!Arrays.equals(identifier, SNAPPY)) {
-                        throw new CompressionException("Unexpected stream identifier contents. Mismatched snappy " +
+                        throw new DecompressionException("Unexpected stream identifier contents. Mismatched snappy " +
                                 "protocol version?");
                     }
 
@@ -109,7 +117,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
                     break;
                 case RESERVED_SKIPPABLE:
                     if (!started) {
-                        throw new CompressionException("Received RESERVED_SKIPPABLE tag before STREAM_IDENTIFIER");
+                        throw new DecompressionException("Received RESERVED_SKIPPABLE tag before STREAM_IDENTIFIER");
                     }
 
                     if (inSize < 4 + chunkLength) {
@@ -123,14 +131,14 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
                     // The spec mandates that reserved unskippable chunks must immediately
                     // return an error, as we must assume that we cannot decode the stream
                     // correctly
-                    throw new CompressionException(
+                    throw new DecompressionException(
                             "Found reserved unskippable chunk type: 0x" + Integer.toHexString(chunkTypeVal));
                 case UNCOMPRESSED_DATA:
                     if (!started) {
-                        throw new CompressionException("Received UNCOMPRESSED_DATA tag before STREAM_IDENTIFIER");
+                        throw new DecompressionException("Received UNCOMPRESSED_DATA tag before STREAM_IDENTIFIER");
                     }
                     if (chunkLength > 65536 + 4) {
-                        throw new CompressionException("Received UNCOMPRESSED_DATA larger than 65540 bytes");
+                        throw new DecompressionException("Received UNCOMPRESSED_DATA larger than 65540 bytes");
                     }
 
                     if (inSize < 4 + chunkLength) {
@@ -139,16 +147,16 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
 
                     in.skipBytes(4);
                     if (validateChecksums) {
-                        int checksum = BufUtil.swapInt(in.readInt());
+                        int checksum = ByteBufUtil.swapInt(in.readInt());
                         validateChecksum(checksum, in, in.readerIndex(), chunkLength - 4);
                     } else {
                         in.skipBytes(4);
                     }
-                    out.writeBytes(in, chunkLength - 4);
+                    out.add(in.readSlice(chunkLength - 4).retain());
                     break;
                 case COMPRESSED_DATA:
                     if (!started) {
-                        throw new CompressionException("Received COMPRESSED_DATA tag before STREAM_IDENTIFIER");
+                        throw new DecompressionException("Received COMPRESSED_DATA tag before STREAM_IDENTIFIER");
                     }
 
                     if (inSize < 4 + chunkLength) {
@@ -156,21 +164,21 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws
                     }
 
                     in.skipBytes(4);
-                    int checksum = BufUtil.swapInt(in.readInt());
+                    int checksum = ByteBufUtil.swapInt(in.readInt());
+                    ByteBuf uncompressed = ctx.alloc().buffer(0);
                     if (validateChecksums) {
                         int oldWriterIndex = in.writerIndex();
-                        int uncompressedStart = out.writerIndex();
                         try {
                             in.writerIndex(in.readerIndex() + chunkLength - 4);
-                            snappy.decode(in, out);
+                            snappy.decode(in, uncompressed);
                         } finally {
                             in.writerIndex(oldWriterIndex);
                         }
-                        int uncompressedLength = out.writerIndex() - uncompressedStart;
-                        validateChecksum(checksum, out, uncompressedStart, uncompressedLength);
+                        validateChecksum(checksum, uncompressed, 0, uncompressed.writerIndex());
                     } else {
-                        snappy.decode(in.readSlice(chunkLength - 4), out);
+                        snappy.decode(in.readSlice(chunkLength - 4), uncompressed);
                     }
+                    out.add(uncompressed);
                     snappy.reset();
                     break;
             }
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
index b7f22a090001..b22a026c2c38 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java
@@ -15,10 +15,10 @@
  */
 package io.netty.handler.codec.compression;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.ByteToByteEncoder;
+import io.netty.handler.codec.MessageToByteEncoder;
 
 import static io.netty.handler.codec.compression.Snappy.*;
 
@@ -27,7 +27,7 @@
  *
  * See http://code.google.com/p/snappy/source/browse/trunk/framing_format.txt
  */
-public class SnappyFramedEncoder extends ByteToByteEncoder {
+public class SnappyFramedEncoder extends MessageToByteEncoder<ByteBuf> {
     /**
      * The minimum amount that we'll consider actually attempting to compress.
      * This value is preamble + the minimum length our Snappy service will
@@ -99,7 +99,7 @@ private static void setChunkLength(ByteBuf out, int lengthIdx) {
         if (chunkLength >>> 24 != 0) {
             throw new CompressionException("compressed data too large: " + chunkLength);
         }
-        out.setMedium(lengthIdx, BufUtil.swapMedium(chunkLength));
+        out.setMedium(lengthIdx, ByteBufUtil.swapMedium(chunkLength));
     }
 
     /**
@@ -109,7 +109,7 @@ private static void setChunkLength(ByteBuf out, int lengthIdx) {
      * @param chunkLength The length to write
      */
     private static void writeChunkLength(ByteBuf out, int chunkLength) {
-        out.writeMedium(BufUtil.swapMedium(chunkLength));
+        out.writeMedium(ByteBufUtil.swapMedium(chunkLength));
     }
 
     /**
@@ -119,6 +119,6 @@ private static void writeChunkLength(ByteBuf out, int chunkLength) {
      * @param out The output buffer to write the checksum to
      */
     private static void calculateAndWriteChecksum(ByteBuf slice, ByteBuf out) {
-        out.writeInt(BufUtil.swapInt(calculateChecksum(slice)));
+        out.writeInt(ByteBufUtil.swapInt(calculateChecksum(slice)));
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java
index 550de06609f4..d01bc6b4de7b 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java
@@ -16,12 +16,12 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.handler.codec.ByteToByteDecoder;
+import io.netty.handler.codec.ByteToMessageDecoder;
 
 /**
  * Decompresses a {@link ByteBuf} using the deflate algorithm.
  */
-public abstract class ZlibDecoder extends ByteToByteDecoder {
+public abstract class ZlibDecoder extends ByteToMessageDecoder {
 
     /**
      * Returns {@code true} if and only if the end of the compressed stream
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java b/codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java
index 90c1b7ff4509..932f7836d039 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java
@@ -18,12 +18,16 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.ByteToByteEncoder;
+import io.netty.handler.codec.MessageToByteEncoder;
 
 /**
  * Compresses a {@link ByteBuf} using the deflate algorithm.
  */
-public abstract class ZlibEncoder extends ByteToByteEncoder {
+public abstract class ZlibEncoder extends MessageToByteEncoder<ByteBuf> {
+
+    protected ZlibEncoder() {
+        super(false);
+    }
 
     /**
      * Returns {@code true} if and only if the end of the compressed stream
diff --git a/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java b/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
index 7af3ebd75ec6..1551203d64e7 100644
--- a/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java
@@ -16,9 +16,9 @@
 package io.netty.handler.codec.marshalling;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ReplayingDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 import org.jboss.marshalling.ByteInput;
@@ -55,7 +55,7 @@ public CompatibleMarshallingDecoder(UnmarshallerProvider provider, int maxObject
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageList<Object> out) throws Exception {
         if (discardingTooLongFrame) {
             buffer.skipBytes(actualReadableBytes());
             checkpoint();
@@ -83,7 +83,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Obje
     }
 
     @Override
-    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {
+    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf buffer, MessageList<Object> out) throws Exception {
         switch (buffer.readableBytes()) {
         case 0:
             return;
diff --git a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java
index 7bce8904972f..0e5ea7fd051d 100644
--- a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java
@@ -19,10 +19,10 @@
 import com.google.protobuf.Message;
 import com.google.protobuf.MessageLite;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
@@ -95,7 +95,7 @@ public ProtobufDecoder(MessageLite prototype, ExtensionRegistry extensionRegistr
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
         final byte[] array;
         final int offset;
         final int length = msg.readableBytes();
diff --git a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java
index 874f402af6b2..27f1e96e3c40 100644
--- a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java
@@ -19,10 +19,10 @@
 import com.google.protobuf.MessageLite;
 import com.google.protobuf.MessageLiteOrBuilder;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.LengthFieldPrepender;
 import io.netty.handler.codec.MessageToMessageEncoder;
@@ -58,10 +58,9 @@
  */
 @Sharable
 public class ProtobufEncoder extends MessageToMessageEncoder<MessageLiteOrBuilder> {
-
     @Override
-    protected void encode(ChannelHandlerContext ctx, MessageLiteOrBuilder msg, MessageBuf<Object> out)
-            throws Exception {
+    protected void encode(
+            ChannelHandlerContext ctx, MessageLiteOrBuilder msg, MessageList<Object> out) throws Exception {
         if (msg instanceof MessageLite) {
             out.add(wrappedBuffer(((MessageLite) msg).toByteArray()));
             return;
diff --git a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
index c9b005911241..b599f2ca5673 100644
--- a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
@@ -17,8 +17,8 @@
 
 import com.google.protobuf.CodedInputStream;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.CorruptedFrameException;
 
@@ -43,7 +43,7 @@ public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder {
     //      (just like LengthFieldBasedFrameDecoder)
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         in.markReaderIndex();
         final byte[] buf = new byte[5];
         for (int i = 0; i < buf.length; i ++) {
diff --git a/codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java b/codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java
index 2f465866fcf1..cfa93245837d 100644
--- a/codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/string/StringDecoder.java
@@ -16,10 +16,10 @@
 package io.netty.handler.codec.string;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.LineBasedFrameDecoder;
@@ -75,7 +75,7 @@ public StringDecoder(Charset charset) {
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageBuf<Object> out) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
         out.add(msg.toString(charset));
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java b/codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java
index af6188f0f1c7..3c2059fe660b 100644
--- a/codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java
@@ -19,9 +19,9 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundMessageHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.LineBasedFrameDecoder;
+import io.netty.handler.codec.MessageToByteEncoder;
 
 import java.nio.charset.Charset;
 
@@ -47,7 +47,7 @@
  * </pre>
  */
 @Sharable
-public class StringEncoder extends ChannelOutboundMessageHandlerAdapter<CharSequence> {
+public class StringEncoder extends MessageToByteEncoder<CharSequence> {
 
     // TODO Use CharsetEncoder instead.
     private final Charset charset;
@@ -70,20 +70,12 @@ public StringEncoder(Charset charset) {
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, CharSequence msg) throws Exception {
+    protected void encode(ChannelHandlerContext ctx, CharSequence msg, ByteBuf out) throws Exception {
         if (msg.length() == 0) {
             return;
         }
+
         ByteBuf encoded = Unpooled.copiedBuffer(msg, charset);
-        switch (ctx.nextOutboundBufferType()) {
-            case BYTE:
-                ctx.nextOutboundByteBuffer().writeBytes(encoded);
-                break;
-            case MESSAGE:
-                ctx.nextOutboundMessageBuffer().add(Unpooled.wrappedBuffer(encoded));
-                break;
-            default:
-                throw new Error();
-        }
+        out.writeBytes(encoded);
     }
 }
diff --git a/codec/src/test/java/io/netty/handler/codec/DelimiterBasedFrameDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/DelimiterBasedFrameDecoderTest.java
index 3dd695eea241..b8855d4bcd1a 100644
--- a/codec/src/test/java/io/netty/handler/codec/DelimiterBasedFrameDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/DelimiterBasedFrameDecoderTest.java
@@ -15,22 +15,21 @@
  */
 package io.netty.handler.codec;
 
-import static org.junit.Assert.*;
-
-import java.nio.charset.Charset;
-
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import java.nio.charset.Charset;
+
+import static org.junit.Assert.*;
 
 public class DelimiterBasedFrameDecoderTest {
 
     @Test
     public void testMultipleLinesStrippedDelimiters() {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new DelimiterBasedFrameDecoder(8192, true,
+        EmbeddedChannel ch = new EmbeddedChannel(new DelimiterBasedFrameDecoder(8192, true,
                 Delimiters.lineDelimiter()));
         ch.writeInbound(Unpooled.copiedBuffer("TestLine\r\ng\r\n", Charset.defaultCharset()));
         assertEquals("TestLine", ((ByteBuf) ch.readInbound()).toString(Charset.defaultCharset()));
@@ -40,7 +39,7 @@ public void testMultipleLinesStrippedDelimiters() {
 
     @Test
     public void testIncompleteLinesStrippedDelimiters() {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new DelimiterBasedFrameDecoder(8192, true,
+        EmbeddedChannel ch = new EmbeddedChannel(new DelimiterBasedFrameDecoder(8192, true,
                 Delimiters.lineDelimiter()));
         ch.writeInbound(Unpooled.copiedBuffer("Test", Charset.defaultCharset()));
         assertNull(ch.readInbound());
@@ -52,7 +51,7 @@ public void testIncompleteLinesStrippedDelimiters() {
 
     @Test
     public void testMultipleLines() {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new DelimiterBasedFrameDecoder(8192, false,
+        EmbeddedChannel ch = new EmbeddedChannel(new DelimiterBasedFrameDecoder(8192, false,
                 Delimiters.lineDelimiter()));
         ch.writeInbound(Unpooled.copiedBuffer("TestLine\r\ng\r\n", Charset.defaultCharset()));
         assertEquals("TestLine\r\n", ((ByteBuf) ch.readInbound()).toString(Charset.defaultCharset()));
@@ -62,7 +61,7 @@ public void testMultipleLines() {
 
     @Test
     public void testIncompleteLines() {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new DelimiterBasedFrameDecoder(8192, false,
+        EmbeddedChannel ch = new EmbeddedChannel(new DelimiterBasedFrameDecoder(8192, false,
                 Delimiters.lineDelimiter()));
         ch.writeInbound(Unpooled.copiedBuffer("Test", Charset.defaultCharset()));
         assertNull(ch.readInbound());
@@ -74,7 +73,7 @@ public void testIncompleteLines() {
 
     @Test
     public void testDecode() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(
+        EmbeddedChannel ch = new EmbeddedChannel(
                 new DelimiterBasedFrameDecoder(8192, true, Delimiters.lineDelimiter()));
 
         ch.writeInbound(Unpooled.copiedBuffer("first\r\nsecond\nthird", CharsetUtil.US_ASCII));
diff --git a/codec/src/test/java/io/netty/handler/codec/LineBasedFrameDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/LineBasedFrameDecoderTest.java
index 92beb69df440..dbca2dba6e06 100644
--- a/codec/src/test/java/io/netty/handler/codec/LineBasedFrameDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/LineBasedFrameDecoderTest.java
@@ -16,7 +16,7 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 
@@ -27,7 +27,7 @@
 public class LineBasedFrameDecoderTest {
     @Test
     public void testDecodeWithStrip() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new LineBasedFrameDecoder(8192, true, false));
+        EmbeddedChannel ch = new EmbeddedChannel(new LineBasedFrameDecoder(8192, true, false));
 
         ch.writeInbound(copiedBuffer("first\r\nsecond\nthird", CharsetUtil.US_ASCII));
         assertEquals("first", ((ByteBuf) ch.readInbound()).toString(CharsetUtil.US_ASCII));
@@ -37,7 +37,7 @@ public void testDecodeWithStrip() throws Exception {
 
     @Test
     public void testDecodeWithoutStrip() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new LineBasedFrameDecoder(8192, false, false));
+        EmbeddedChannel ch = new EmbeddedChannel(new LineBasedFrameDecoder(8192, false, false));
 
         ch.writeInbound(copiedBuffer("first\r\nsecond\nthird", CharsetUtil.US_ASCII));
         assertEquals("first\r\n", ((ByteBuf) ch.readInbound()).toString(CharsetUtil.US_ASCII));
@@ -47,7 +47,7 @@ public void testDecodeWithoutStrip() throws Exception {
 
     @Test
     public void testTooLongLine1() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new LineBasedFrameDecoder(16, false, false));
+        EmbeddedChannel ch = new EmbeddedChannel(new LineBasedFrameDecoder(16, false, false));
 
         try {
             ch.writeInbound(copiedBuffer("12345678901234567890\r\nfirst\nsecond", CharsetUtil.US_ASCII));
@@ -62,7 +62,7 @@ public void testTooLongLine1() throws Exception {
 
     @Test
     public void testTooLongLine2() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new LineBasedFrameDecoder(16, false, false));
+        EmbeddedChannel ch = new EmbeddedChannel(new LineBasedFrameDecoder(16, false, false));
 
         assertFalse(ch.writeInbound(copiedBuffer("12345678901234567", CharsetUtil.US_ASCII)));
         try {
@@ -78,7 +78,7 @@ public void testTooLongLine2() throws Exception {
 
     @Test
     public void testTooLongLineWithFailFast() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new LineBasedFrameDecoder(16, false, true));
+        EmbeddedChannel ch = new EmbeddedChannel(new LineBasedFrameDecoder(16, false, true));
 
         try {
             ch.writeInbound(copiedBuffer("12345678901234567", CharsetUtil.US_ASCII));
diff --git a/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
index 7c87bc0f1641..d48e89c78b90 100644
--- a/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
@@ -17,11 +17,11 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufIndexFinder;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -30,7 +30,7 @@ public class ReplayingDecoderTest {
 
     @Test
     public void testLineProtocol() {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new LineDecoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new LineDecoder());
 
         // Ordinary input
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'A' }));
@@ -56,7 +56,7 @@ private static final class LineDecoder extends ReplayingDecoder<Void> {
         }
 
         @Override
-        protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) {
+        protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) {
             ByteBuf msg = in.readBytes(in.bytesBefore(ByteBufIndexFinder.LF));
             in.skipBytes(1);
             out.add(msg);
@@ -65,7 +65,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object>
 
     @Test
     public void testReplacement() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new BloatedLineDecoder());
+        EmbeddedChannel ch = new EmbeddedChannel(new BloatedLineDecoder());
 
         // "AB" should be forwarded to LineDecoder by BloatedLineDecoder.
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[]{'A', 'B'}));
@@ -79,10 +79,11 @@ public void testReplacement() throws Exception {
         assertNull(ch.readInbound());
     }
 
-    private static final class BloatedLineDecoder extends ChannelInboundByteHandlerAdapter {
+    private static final class BloatedLineDecoder extends ChannelInboundHandlerAdapter {
         @Override
-        protected void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
             ctx.pipeline().replace(this, "less-bloated", new LineDecoder());
+            ctx.pipeline().fireMessageReceived(msgs);
         }
     }
 
@@ -90,7 +91,7 @@ protected void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throw
     public void testSingleDecode() throws Exception {
         LineDecoder decoder = new LineDecoder();
         decoder.setSingleDecode(true);
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(decoder);
+        EmbeddedChannel ch = new EmbeddedChannel(decoder);
 
         // "C\n" should be appended to "AB" so that LineDecoder decodes it correctly.
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[]{'C', '\n' , 'B', '\n'}));
diff --git a/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
index 0f390249cae5..acec3cbf4150 100644
--- a/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.bytes;
 
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.EmptyArrays;
 import org.junit.Before;
 import org.junit.Test;
@@ -31,11 +31,11 @@
 @SuppressWarnings("ZeroLengthArrayAllocation")
 public class ByteArrayDecoderTest {
 
-    private EmbeddedMessageChannel ch;
+    private EmbeddedChannel ch;
 
     @Before
     public void setUp() {
-        ch = new EmbeddedMessageChannel(new ByteArrayDecoder());
+        ch = new EmbeddedChannel(new ByteArrayDecoder());
     }
 
     @Test
diff --git a/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
index c190ee394953..9e46212819c3 100644
--- a/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java
@@ -16,7 +16,8 @@
 package io.netty.handler.codec.bytes;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.internal.EmptyArrays;
 import org.junit.Before;
 import org.junit.Test;
@@ -31,11 +32,11 @@
 @SuppressWarnings("ZeroLengthArrayAllocation")
 public class ByteArrayEncoderTest {
 
-    private EmbeddedMessageChannel ch;
+    private EmbeddedChannel ch;
 
     @Before
     public void setUp() {
-        ch = new EmbeddedMessageChannel(new ByteArrayEncoder());
+        ch = new EmbeddedChannel(new ByteArrayEncoder());
     }
 
     @Test
@@ -49,7 +50,7 @@ public void testEncode() {
     @Test
     public void testEncodeEmpty() {
         ch.writeOutbound(EmptyArrays.EMPTY_BYTES);
-        assertThat(ch.readOutbound(), nullValue());
+        assertThat((ByteBuf) ch.readOutbound(), is(Unpooled.EMPTY_BUFFER));
     }
 
     @Test
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java b/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java
index a8477f91d5ec..faecedd8599c 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java
@@ -17,9 +17,8 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import org.junit.After;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.junit.Test;
-import io.netty.channel.embedded.EmbeddedByteChannel;
 
 import static org.junit.Assert.*;
 
@@ -29,26 +28,23 @@ public class JZlibTest {
     public void testZLIB() throws Exception {
         ByteBuf data = Unpooled.wrappedBuffer("test".getBytes());
 
-        EmbeddedByteChannel chEncoder =
-          new EmbeddedByteChannel(new JZlibEncoder(ZlibWrapper.ZLIB));
+        EmbeddedChannel chEncoder = new EmbeddedChannel(new JZlibEncoder(ZlibWrapper.ZLIB));
 
         chEncoder.writeOutbound(data.copy());
         assertTrue(chEncoder.finish());
 
-        byte[] deflatedData = chEncoder.readOutbound().array();
+        ByteBuf deflatedData = (ByteBuf) chEncoder.readOutbound();
 
-        EmbeddedByteChannel chDecoderZlib =
-            new EmbeddedByteChannel(new JZlibDecoder(ZlibWrapper.ZLIB));
+        EmbeddedChannel chDecoderZlib = new EmbeddedChannel(new JZlibDecoder(ZlibWrapper.ZLIB));
 
-        chDecoderZlib.writeInbound(Unpooled.wrappedBuffer(deflatedData));
+        chDecoderZlib.writeInbound(deflatedData.copy());
         assertTrue(chDecoderZlib.finish());
 
         assertEquals(data, chDecoderZlib.readInbound());
 
-        EmbeddedByteChannel chDecoderZlibOrNone =
-            new EmbeddedByteChannel(new JZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
+        EmbeddedChannel chDecoderZlibOrNone = new EmbeddedChannel(new JZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
 
-        chDecoderZlibOrNone.writeInbound(Unpooled.wrappedBuffer(deflatedData));
+        chDecoderZlibOrNone.writeInbound(deflatedData);
         assertTrue(chDecoderZlibOrNone.finish());
 
         assertEquals(data, chDecoderZlibOrNone.readInbound());
@@ -58,26 +54,24 @@ public void testZLIB() throws Exception {
     public void testNONE() throws Exception {
         ByteBuf data = Unpooled.wrappedBuffer("test".getBytes());
 
-        EmbeddedByteChannel chEncoder =
-          new EmbeddedByteChannel(new JZlibEncoder(ZlibWrapper.NONE));
+        EmbeddedChannel chEncoder = new EmbeddedChannel(new JZlibEncoder(ZlibWrapper.NONE));
 
         chEncoder.writeOutbound(data.copy());
         assertTrue(chEncoder.finish());
 
-        byte[] deflatedData = chEncoder.readOutbound().array();
+        ByteBuf deflatedData = (ByteBuf) chEncoder.readOutbound();
 
-        EmbeddedByteChannel chDecoderZlibNone =
-            new EmbeddedByteChannel(new JZlibDecoder(ZlibWrapper.NONE));
+        EmbeddedChannel chDecoderZlibNone = new EmbeddedChannel(new JZlibDecoder(ZlibWrapper.NONE));
 
-        chDecoderZlibNone.writeInbound(Unpooled.wrappedBuffer(deflatedData));
+        chDecoderZlibNone.writeInbound(deflatedData.copy());
         assertTrue(chDecoderZlibNone.finish());
 
         assertEquals(data, chDecoderZlibNone.readInbound());
 
-        EmbeddedByteChannel chDecoderZlibOrNone =
-            new EmbeddedByteChannel(new JZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
+        EmbeddedChannel chDecoderZlibOrNone =
+            new EmbeddedChannel(new JZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
 
-        chDecoderZlibOrNone.writeInbound(Unpooled.wrappedBuffer(deflatedData));
+        chDecoderZlibOrNone.writeInbound(deflatedData);
         assertTrue(chDecoderZlibOrNone.finish());
 
         assertEquals(data, chDecoderZlibOrNone.readInbound());
@@ -87,26 +81,24 @@ public void testNONE() throws Exception {
     public void testGZIP() throws Exception {
         ByteBuf data = Unpooled.wrappedBuffer("test".getBytes());
 
-        EmbeddedByteChannel chEncoder =
-          new EmbeddedByteChannel(new JZlibEncoder(ZlibWrapper.GZIP));
+        EmbeddedChannel chEncoder = new EmbeddedChannel(new JZlibEncoder(ZlibWrapper.GZIP));
 
         chEncoder.writeOutbound(data.copy());
         assertTrue(chEncoder.finish());
 
-        byte[] deflatedData = chEncoder.readOutbound().array();
+        ByteBuf deflatedData = (ByteBuf) chEncoder.readOutbound();
 
-        EmbeddedByteChannel chDecoderGZip =
-            new EmbeddedByteChannel(new JZlibDecoder(ZlibWrapper.GZIP));
+        EmbeddedChannel chDecoderGZip = new EmbeddedChannel(new JZlibDecoder(ZlibWrapper.GZIP));
 
-        chDecoderGZip.writeInbound(Unpooled.wrappedBuffer(deflatedData));
+        chDecoderGZip.writeInbound(deflatedData.copy());
         assertTrue(chDecoderGZip.finish());
 
         assertEquals(data, chDecoderGZip.readInbound());
 
-        EmbeddedByteChannel chDecoderZlibOrNone =
-            new EmbeddedByteChannel(new JZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
+        EmbeddedChannel chDecoderZlibOrNone =
+            new EmbeddedChannel(new JZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));
 
-        chDecoderZlibOrNone.writeInbound(Unpooled.wrappedBuffer(deflatedData));
+        chDecoderZlibOrNone.writeInbound(deflatedData);
         assertTrue(chDecoderZlibOrNone.finish());
 
         assertEquals(data, chDecoderZlibOrNone.readInbound());
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java
index 37d068c34a69..2b2554430909 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java
@@ -17,21 +17,21 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
 
 public class SnappyFramedDecoderTest {
-    private EmbeddedByteChannel channel;
+    private EmbeddedChannel channel;
 
     @Before
     public void initChannel() {
-        channel = new EmbeddedByteChannel(new SnappyFramedDecoder());
+        channel = new EmbeddedChannel(new SnappyFramedDecoder());
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testReservedUnskippableChunkTypeCausesError() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             0x03, 0x01, 0x00, 0x00, 0x00
@@ -40,7 +40,7 @@ public void testReservedUnskippableChunkTypeCausesError() throws Exception {
         channel.writeInbound(in);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testInvalidStreamIdentifierLength() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             -0x80, 0x05, 0x00, 0x00, 'n', 'e', 't', 't', 'y'
@@ -49,7 +49,7 @@ public void testInvalidStreamIdentifierLength() throws Exception {
         channel.writeInbound(in);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testInvalidStreamIdentifierValue() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             -0x80, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y'
@@ -58,7 +58,7 @@ public void testInvalidStreamIdentifierValue() throws Exception {
         channel.writeInbound(in);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testReservedSkippableBeforeStreamIdentifier() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             -0x7f, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y'
@@ -67,7 +67,7 @@ public void testReservedSkippableBeforeStreamIdentifier() throws Exception {
         channel.writeInbound(in);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testUncompressedDataBeforeStreamIdentifier() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             0x01, 0x05, 0x00, 0x00, 'n', 'e', 't', 't', 'y'
@@ -76,7 +76,7 @@ public void testUncompressedDataBeforeStreamIdentifier() throws Exception {
         channel.writeInbound(in);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testCompressedDataBeforeStreamIdentifier() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             0x00, 0x05, 0x00, 0x00, 'n', 'e', 't', 't', 'y'
@@ -130,9 +130,9 @@ public void testCompressedDataDecodesAndAppendsToOut() throws Exception {
     // The following two tests differ in only the checksum provided for the literal
     // uncompressed string "netty"
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testInvalidChecksumThrowsException() throws Exception {
-        EmbeddedByteChannel channel = new EmbeddedByteChannel(new SnappyFramedDecoder(true));
+        EmbeddedChannel channel = new EmbeddedChannel(new SnappyFramedDecoder(true));
 
         // checksum here is presented as 0
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
@@ -145,7 +145,7 @@ public void testInvalidChecksumThrowsException() throws Exception {
 
     @Test
     public void testInvalidChecksumDoesNotThrowException() throws Exception {
-        EmbeddedByteChannel channel = new EmbeddedByteChannel(new SnappyFramedDecoder(true));
+        EmbeddedChannel channel = new EmbeddedChannel(new SnappyFramedDecoder(true));
 
         // checksum here is presented as -1568496083 (little endian)
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
index 661a99159c0c..52edb9a67bac 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java
@@ -16,19 +16,20 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
 
 public class SnappyFramedEncoderTest {
-    private EmbeddedByteChannel channel;
+    private EmbeddedChannel channel;
 
     @Before
     public void setUp() {
-        channel = new EmbeddedByteChannel(new SnappyFramedEncoder());
+        channel = new EmbeddedChannel(new SnappyFramedEncoder());
     }
 
     @Test
@@ -83,7 +84,17 @@ public void testStreamStartIsOnlyWrittenOnce() throws Exception {
              0x01, 0x09, 0x00, 0x00, 0x2d, -0x5a, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y',
              0x01, 0x09, 0x00, 0x00, 0x2d, -0x5a, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y',
         });
-        assertEquals(expected, channel.readOutbound());
+
+        CompositeByteBuf actual = Unpooled.compositeBuffer();
+        for (;;) {
+            ByteBuf m = (ByteBuf) channel.readOutbound();
+            if (m == null) {
+                break;
+            }
+            actual.addComponent(m);
+            actual.writerIndex(actual.writerIndex() + m.readableBytes());
+        }
+        assertEquals(expected, actual);
         in.release();
     }
 
@@ -131,5 +142,7 @@ public void testInputBufferOverseek() throws Exception {
 
         channel.writeOutbound(in);
         assertTrue(channel.finish());
+        ByteBuf out = (ByteBuf) channel.readOutbound();
+        out.release();
     }
 }
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java b/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
index f92b83c6a5b4..6b54c1d69a22 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java
@@ -16,7 +16,8 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 
@@ -116,18 +117,27 @@ private static void testIdentity(byte[] data) {
     }
 
     private static void testIdentity(ByteBuf in) {
-        EmbeddedByteChannel encoder = new EmbeddedByteChannel(new SnappyFramedEncoder());
-        EmbeddedByteChannel decoder = new EmbeddedByteChannel(new SnappyFramedDecoder());
+        EmbeddedChannel encoder = new EmbeddedChannel(new SnappyFramedEncoder());
+        EmbeddedChannel decoder = new EmbeddedChannel(new SnappyFramedDecoder());
         try {
             encoder.writeOutbound(in.copy());
-            ByteBuf compressed = encoder.readOutbound();
+            ByteBuf compressed = (ByteBuf) encoder.readOutbound();
             assertThat(compressed, is(notNullValue()));
             assertThat(compressed, is(not(in)));
-            decoder.writeInbound(compressed);
+            decoder.writeInbound(compressed.retain());
             assertFalse(compressed.isReadable());
-            compressed.discardReadBytes();
-            ByteBuf decompressed = (ByteBuf) decoder.readInbound();
+            compressed.release();
+            CompositeByteBuf decompressed = compositeBuffer();
+            for (;;) {
+                Object o = decoder.readInbound();
+                if (o == null) {
+                    break;
+                }
+                decompressed.addComponent((ByteBuf) o);
+                decompressed.writerIndex(decompressed.writerIndex() + ((ByteBuf) o).readableBytes());
+            }
             assertEquals(in, decompressed);
+            decompressed.release();
         } finally {
             // Avoids memory leak through AbstractChannel.allChannels
             encoder.close();
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/SnappyTest.java b/codec/src/test/java/io/netty/handler/codec/compression/SnappyTest.java
index 5fcc03ea606f..c7122d1913dd 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/SnappyTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyTest.java
@@ -67,7 +67,7 @@ public void testDecodeCopyWith1ByteOffset() throws Exception {
         assertEquals("Copy was not decoded correctly", expected, out);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testDecodeCopyWithTinyOffset() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             0x0b, // preamble length
@@ -80,7 +80,7 @@ public void testDecodeCopyWithTinyOffset() throws Exception {
         snappy.decode(in, out);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testDecodeCopyWithOffsetBeforeChunk() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             0x0a, // preamble length
@@ -93,7 +93,7 @@ public void testDecodeCopyWithOffsetBeforeChunk() throws Exception {
         snappy.decode(in, out);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testDecodeWithOverlyLongPreamble() throws Exception {
         ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
             -0x80, -0x80, -0x80, -0x80, 0x7f, // preamble length
@@ -187,7 +187,7 @@ public void testValidateChecksumMatches() {
         validateChecksum(maskChecksum(0x37c55159), input);
     }
 
-    @Test(expected = CompressionException.class)
+    @Test(expected = DecompressionException.class)
     public void testValidateChecksumFails() {
         ByteBuf input = Unpooled.wrappedBuffer(new byte[] {
                 'y', 't', 't', 'e', 'n'
diff --git a/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java
index f9f7e5388a69..77f7fa023284 100644
--- a/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java
@@ -15,23 +15,23 @@
  */
 package io.netty.handler.codec.frame;
 
-import static org.junit.Assert.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.util.CharsetUtil;
-
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 public class DelimiterBasedFrameDecoderTest {
 
     @Test
     public void testFailSlowTooLongFrameRecovery() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(
+        EmbeddedChannel ch = new EmbeddedChannel(
                 new DelimiterBasedFrameDecoder(1, true, false, Delimiters.nulDelimiter()));
 
         for (int i = 0; i < 2; i ++) {
@@ -51,7 +51,7 @@ public void testFailSlowTooLongFrameRecovery() throws Exception {
 
     @Test
     public void testFailFastTooLongFrameRecovery() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(
+        EmbeddedChannel ch = new EmbeddedChannel(
                 new DelimiterBasedFrameDecoder(1, Delimiters.nulDelimiter()));
 
         for (int i = 0; i < 2; i ++) {
diff --git a/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java
index 80ceb6a00978..401eed24f932 100644
--- a/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java
@@ -15,21 +15,21 @@
  */
 package io.netty.handler.codec.frame;
 
-import static org.junit.Assert.*;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
 import io.netty.handler.codec.TooLongFrameException;
 import io.netty.util.CharsetUtil;
-
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+
 public class LengthFieldBasedFrameDecoderTest {
     @Test
     public void testFailSlowTooLongFrameRecovery() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(
+        EmbeddedChannel ch = new EmbeddedChannel(
                 new LengthFieldBasedFrameDecoder(5, 0, 4, 0, 4, false));
 
         for (int i = 0; i < 2; i ++) {
@@ -49,7 +49,7 @@ public void testFailSlowTooLongFrameRecovery() throws Exception {
 
     @Test
     public void testFailFastTooLongFrameRecovery() throws Exception {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(
+        EmbeddedChannel ch = new EmbeddedChannel(
                 new LengthFieldBasedFrameDecoder(5, 0, 4, 0, 4));
 
         for (int i = 0; i < 2; i ++) {
diff --git a/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java
index 16bfa998ab84..0e8dc34af6b0 100644
--- a/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java
@@ -16,8 +16,8 @@
 package io.netty.handler.codec.frame;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.channel.IncompleteFlushException;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.EncoderException;
 import io.netty.handler.codec.LengthFieldPrepender;
 import io.netty.util.CharsetUtil;
 import org.junit.Before;
@@ -38,32 +38,32 @@ public void setUp() throws Exception {
 
     @Test
     public void testPrependLength() throws Exception {
-        final EmbeddedByteChannel ch = new EmbeddedByteChannel(new LengthFieldPrepender(4));
+        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4));
         ch.writeOutbound(msg);
-        assertThat(ch.readOutbound(), is(wrappedBuffer(new byte[]{0, 0, 0, 1, 'A'})));
+        assertThat((ByteBuf) ch.readOutbound(), is(wrappedBuffer(new byte[]{0, 0, 0, 1, 'A'})));
     }
 
     @Test
     public void testPrependLengthIncludesLengthFieldLength() throws Exception {
-        final EmbeddedByteChannel ch = new EmbeddedByteChannel(new LengthFieldPrepender(4, true));
+        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4, true));
         ch.writeOutbound(msg);
-        assertThat(ch.readOutbound(), is(wrappedBuffer(new byte[]{0, 0, 0, 5, 'A'})));
+        assertThat((ByteBuf) ch.readOutbound(), is(wrappedBuffer(new byte[]{0, 0, 0, 5, 'A'})));
     }
 
     @Test
     public void testPrependAdjustedLength() throws Exception {
-        final EmbeddedByteChannel ch = new EmbeddedByteChannel(new LengthFieldPrepender(4, -1));
+        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4, -1));
         ch.writeOutbound(msg);
-        assertThat(ch.readOutbound(), is(wrappedBuffer(new byte[]{0, 0, 0, 0, 'A'})));
+        assertThat((ByteBuf) ch.readOutbound(), is(wrappedBuffer(new byte[]{0, 0, 0, 0, 'A'})));
     }
 
     @Test
     public void testAdjustedLengthLessThanZero() throws Exception {
-        final EmbeddedByteChannel ch = new EmbeddedByteChannel(new LengthFieldPrepender(4, -2));
+        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4, -2));
         try {
             ch.writeOutbound(msg);
-            fail(IncompleteFlushException.class.getSimpleName() + " must be raised.");
-        } catch (IncompleteFlushException e) {
+            fail(EncoderException.class.getSimpleName() + " must be raised.");
+        } catch (EncoderException e) {
             // Expected
         }
     }
diff --git a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
index 3be464deff9b..1b65d5fbb0d0 100644
--- a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.jboss.marshalling.Marshaller;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.Marshalling;
@@ -39,7 +39,7 @@ public void testSimpleUnmarshalling() throws IOException {
         MarshallerFactory marshallerFactory = createMarshallerFactory();
         MarshallingConfiguration configuration = createMarshallingConfig();
 
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(createDecoder(Integer.MAX_VALUE));
+        EmbeddedChannel ch = new EmbeddedChannel(createDecoder(Integer.MAX_VALUE));
 
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         Marshaller marshaller = marshallerFactory.createMarshaller(configuration);
@@ -69,7 +69,7 @@ public void testFragmentedUnmarshalling() throws IOException {
         MarshallerFactory marshallerFactory = createMarshallerFactory();
         MarshallingConfiguration configuration = createMarshallingConfig();
 
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(createDecoder(Integer.MAX_VALUE));
+        EmbeddedChannel ch = new EmbeddedChannel(createDecoder(Integer.MAX_VALUE));
 
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         Marshaller marshaller = marshallerFactory.createMarshaller(configuration);
@@ -83,7 +83,7 @@ public void testFragmentedUnmarshalling() throws IOException {
         ByteBuf buffer = input(testBytes);
         ByteBuf slice = buffer.readSlice(2);
 
-        ch.writeInbound(slice);
+        ch.writeInbound(slice.retain());
         ch.writeInbound(buffer);
         assertTrue(ch.finish());
 
@@ -100,7 +100,7 @@ public void testTooBigObject() throws IOException {
         MarshallingConfiguration configuration = createMarshallingConfig();
 
         ChannelHandler mDecoder = createDecoder(4);
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(mDecoder);
+        EmbeddedChannel ch = new EmbeddedChannel(mDecoder);
 
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         Marshaller marshaller = marshallerFactory.createMarshaller(configuration);
@@ -113,7 +113,7 @@ public void testTooBigObject() throws IOException {
         onTooBigFrame(ch, input(testBytes));
     }
 
-    protected void onTooBigFrame(EmbeddedByteChannel ch, ByteBuf input) {
+    protected void onTooBigFrame(EmbeddedChannel ch, ByteBuf input) {
         ch.writeInbound(input);
         assertFalse(ch.isActive());
     }
diff --git a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
index dc520738e63d..f6dfa4f219c7 100644
--- a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import org.jboss.marshalling.MarshallerFactory;
 import org.jboss.marshalling.Marshalling;
 import org.jboss.marshalling.MarshallingConfiguration;
@@ -38,12 +38,12 @@ public void testMarshalling() throws IOException, ClassNotFoundException {
         final MarshallerFactory marshallerFactory = createMarshallerFactory();
         final MarshallingConfiguration configuration = createMarshallingConfig();
 
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(createEncoder());
+        EmbeddedChannel ch = new EmbeddedChannel(createEncoder());
 
         ch.writeOutbound(testObject);
         assertTrue(ch.finish());
 
-        ByteBuf buffer = ch.readOutbound();
+        ByteBuf buffer = (ByteBuf) ch.readOutbound();
 
         Unmarshaller unmarshaller = marshallerFactory.createUnmarshaller(configuration);
         unmarshaller.start(Marshalling.createByteInput(truncate(buffer).nioBuffer()));
@@ -56,7 +56,9 @@ public void testMarshalling() throws IOException, ClassNotFoundException {
 
         unmarshaller.finish();
         unmarshaller.close();
+        buffer.release();
     }
+
     protected ByteBuf truncate(ByteBuf buf) {
         return buf;
     }
diff --git a/codec/src/test/java/io/netty/handler/codec/marshalling/RiverMarshallingDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/marshalling/RiverMarshallingDecoderTest.java
index 17d7cb2d5987..b68e89a43cf3 100644
--- a/codec/src/test/java/io/netty/handler/codec/marshalling/RiverMarshallingDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/marshalling/RiverMarshallingDecoderTest.java
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.CodecException;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -40,7 +40,7 @@ protected ChannelHandler createDecoder(int maxObjectSize) {
     }
 
     @Override
-    protected void onTooBigFrame(EmbeddedByteChannel ch, ByteBuf input) {
+    protected void onTooBigFrame(EmbeddedChannel ch, ByteBuf input) {
         try {
             ch.writeInbound(input);
             fail();
diff --git a/codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingDecoderTest.java
index 6f27baf078ef..b86dcfffe136 100644
--- a/codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/marshalling/SerialMarshallingDecoderTest.java
@@ -18,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.embedded.EmbeddedByteChannel;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.CodecException;
 import io.netty.handler.codec.TooLongFrameException;
 
@@ -40,7 +40,7 @@ protected ChannelHandler createDecoder(int maxObjectSize) {
     }
 
     @Override
-    protected void onTooBigFrame(EmbeddedByteChannel ch, ByteBuf input) {
+    protected void onTooBigFrame(EmbeddedChannel ch, ByteBuf input) {
         try {
             ch.writeInbound(input);
             fail();
diff --git a/codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoderTest.java
index 65ebf5956a36..00cd74ad1c92 100644
--- a/codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoderTest.java
@@ -15,23 +15,23 @@
  */
 package io.netty.handler.codec.protobuf;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.embedded.EmbeddedChannel;
+import org.junit.Before;
+import org.junit.Test;
+
 import static io.netty.buffer.Unpooled.*;
 import static org.hamcrest.core.Is.*;
 import static org.hamcrest.core.IsNull.*;
 import static org.junit.Assert.*;
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.embedded.EmbeddedByteChannel;
-
-import org.junit.Before;
-import org.junit.Test;
 
 public class ProtobufVarint32FrameDecoderTest {
 
-    private EmbeddedByteChannel ch;
+    private EmbeddedChannel ch;
 
     @Before
     public void setUp() {
-        ch = new EmbeddedByteChannel(new ProtobufVarint32FrameDecoder());
+        ch = new EmbeddedChannel(new ProtobufVarint32FrameDecoder());
     }
 
     @Test
diff --git a/codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrependerTest.java b/codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrependerTest.java
index 681a13f11b4f..7b946f4148c7 100644
--- a/codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrependerTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrependerTest.java
@@ -15,28 +15,29 @@
  */
 package io.netty.handler.codec.protobuf;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.embedded.EmbeddedChannel;
+import org.junit.Before;
+import org.junit.Test;
+
 import static io.netty.buffer.Unpooled.*;
 import static org.hamcrest.core.Is.*;
 import static org.junit.Assert.*;
-import io.netty.channel.embedded.EmbeddedByteChannel;
-
-import org.junit.Before;
-import org.junit.Test;
 
 public class ProtobufVarint32LengthFieldPrependerTest {
 
-    private EmbeddedByteChannel ch;
+    private EmbeddedChannel ch;
 
     @Before
     public void setUp() {
-        ch = new EmbeddedByteChannel(new ProtobufVarint32LengthFieldPrepender());
+        ch = new EmbeddedChannel(new ProtobufVarint32LengthFieldPrepender());
     }
 
     @Test
     public void testTinyEncode() {
         byte[] b = { 4, 1, 1, 1, 1 };
         ch.writeOutbound(wrappedBuffer(b, 1, b.length - 1));
-        assertThat(ch.readOutbound(), is(wrappedBuffer(b)));
+        assertThat((ByteBuf) ch.readOutbound(), is(wrappedBuffer(b)));
     }
 
     @Test
@@ -48,6 +49,6 @@ public void testRegularDecode() {
         b[0] = -2;
         b[1] = 15;
         ch.writeOutbound(wrappedBuffer(b, 2, b.length - 2));
-        assertThat(ch.readOutbound(), is(wrappedBuffer(b)));
+        assertThat((ByteBuf) ch.readOutbound(), is(wrappedBuffer(b)));
     }
 }
diff --git a/common/pom.xml b/common/pom.xml
index f6291fceab23..67516ea58b3d 100644
--- a/common/pom.xml
+++ b/common/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-common</artifactId>
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
similarity index 90%
rename from buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java
rename to common/src/main/java/io/netty/util/AbstractReferenceCounted.java
index e720c56ec210..136dcf3407bd 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.buffer;
+package io.netty.util;
 
 import io.netty.util.internal.PlatformDependent;
 
@@ -68,10 +68,10 @@ public ReferenceCounted retain() {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
+                throw new IllegalReferenceCountException(0, 1);
             }
             if (refCnt == Integer.MAX_VALUE) {
-                throw new IllegalBufferAccessException("refCnt overflow");
+                throw new IllegalReferenceCountException(Integer.MAX_VALUE, 1);
             }
             if (refCntUpdater.compareAndSet(this, refCnt, refCnt + 1)) {
                 break;
@@ -89,10 +89,10 @@ public ReferenceCounted retain(int increment) {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
+                throw new IllegalReferenceCountException(0, 1);
             }
             if (refCnt > Integer.MAX_VALUE - increment) {
-                throw new IllegalBufferAccessException("refCnt overflow");
+                throw new IllegalReferenceCountException(refCnt, increment);
             }
             if (refCntUpdater.compareAndSet(this, refCnt, refCnt + increment)) {
                 break;
@@ -106,7 +106,7 @@ public final boolean release() {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt == 0) {
-                throw new IllegalBufferAccessException();
+                throw new IllegalReferenceCountException(0, -1);
             }
 
             if (refCntUpdater.compareAndSet(this, refCnt, refCnt - 1)) {
@@ -128,7 +128,7 @@ public final boolean release(int decrement) {
         for (;;) {
             int refCnt = this.refCnt;
             if (refCnt < decrement) {
-                throw new IllegalBufferAccessException();
+                throw new IllegalReferenceCountException(refCnt, -decrement);
             }
 
             if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
diff --git a/common/src/main/java/io/netty/util/IllegalReferenceCountException.java b/common/src/main/java/io/netty/util/IllegalReferenceCountException.java
new file mode 100644
index 000000000000..648bd048aaa9
--- /dev/null
+++ b/common/src/main/java/io/netty/util/IllegalReferenceCountException.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util;
+
+/**
+ * An {@link IllegalStateException} which is raised when a user attempts to access a {@link ReferenceCounted} whose
+ * reference count has been decreased to 0 (and consequently freed).
+ */
+public class IllegalReferenceCountException extends IllegalStateException {
+
+    private static final long serialVersionUID = -2507492394288153468L;
+
+    public IllegalReferenceCountException() { }
+
+    public IllegalReferenceCountException(int refCnt) {
+        this("refCnt: " + refCnt);
+    }
+
+    public IllegalReferenceCountException(int refCnt, int increment) {
+        this("refCnt: " + refCnt + ", " + (increment > 0? "increment: " + increment : "decrement: " + -increment));
+    }
+
+    public IllegalReferenceCountException(String message) {
+        super(message);
+    }
+
+    public IllegalReferenceCountException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public IllegalReferenceCountException(Throwable cause) {
+        super(cause);
+    }
+}
diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
new file mode 100644
index 000000000000..c162da01864a
--- /dev/null
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util;
+
+import java.util.IdentityHashMap;
+import java.util.Map;
+
+/**
+ * Light-weight object pool based on a thread-local stack.
+ *
+ * @param <T> the type of the pooled object
+ */
+public abstract class Recycler<T> {
+
+    private final ThreadLocal<Stack<T>> threadLocal = new ThreadLocal<Stack<T>>() {
+        @Override
+        protected Stack<T> initialValue() {
+            return new Stack<T>(Recycler.this, Thread.currentThread());
+        }
+    };
+
+    public final T get() {
+        Stack<T> stack = threadLocal.get();
+        T o = stack.pop();
+        if (o == null) {
+            o = newObject(stack);
+        }
+        return o;
+    }
+
+    public final boolean recycle(T o, Handle handle) {
+        @SuppressWarnings("unchecked")
+        Stack<T> stack = (Stack<T>) handle;
+        if (stack.parent != this) {
+            return false;
+        }
+
+        if (Thread.currentThread() != stack.thread) {
+            return false;
+        }
+
+        stack.push(o);
+        return true;
+    }
+
+    protected abstract T newObject(Handle handle);
+
+    public interface Handle { }
+
+    static final class Stack<T> implements Handle {
+
+        private static final int INITIAL_CAPACITY = 256;
+
+        final Recycler<T> parent;
+        final Thread thread;
+        private T[] elements;
+        private int size;
+        private final Map<T, Boolean> map = new IdentityHashMap<T, Boolean>(INITIAL_CAPACITY);
+
+        @SuppressWarnings({ "unchecked", "SuspiciousArrayCast" })
+        Stack(Recycler<T> parent, Thread thread) {
+            this.parent = parent;
+            this.thread = thread;
+            elements = newArray(INITIAL_CAPACITY);
+        }
+
+        T pop() {
+            int size = this.size;
+            if (size == 0) {
+                return null;
+            }
+            size --;
+            T ret = elements[size];
+            elements[size] = null;
+            map.remove(ret);
+            this.size = size;
+            return ret;
+        }
+
+        void push(T o) {
+            if (map.put(o, Boolean.TRUE) != null) {
+                throw new IllegalStateException("recycled already");
+            }
+
+            int size = this.size;
+            if (size == elements.length) {
+                T[] newElements = newArray(size << 1);
+                System.arraycopy(elements, 0, newElements, 0, size);
+                elements = newElements;
+            }
+
+            elements[size] = o;
+            this.size = size + 1;
+        }
+
+        @SuppressWarnings({ "unchecked", "SuspiciousArrayCast" })
+        private static <T> T[] newArray(int length) {
+            return (T[]) new Object[length];
+        }
+    }
+}
diff --git a/buffer/src/main/java/io/netty/buffer/ReferenceCounted.java b/common/src/main/java/io/netty/util/ReferenceCounted.java
similarity index 88%
rename from buffer/src/main/java/io/netty/buffer/ReferenceCounted.java
rename to common/src/main/java/io/netty/util/ReferenceCounted.java
index d04b15511176..ffd20aba3b65 100644
--- a/buffer/src/main/java/io/netty/buffer/ReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/ReferenceCounted.java
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.buffer;
+package io.netty.util;
 
 /**
  * A reference-counted object that requires explicit deallocation.
@@ -24,8 +24,9 @@
  * the deallocated object will usually result in an access violation.
  * </p>
  * <p>
- * If this object is a container such as {@link MessageBuf} and {@link CompositeByteBuf}, its elements whose type is
- * {@link ReferenceCounted} will also be released when this object is deallocated.
+ * If an object that implements {@link ReferenceCounted} is a container of other objects that implement
+ * {@link ReferenceCounted}, the contained objects will also be released via {@link #release()} when the container's
+ * reference count becomes 0.
  * </p>
  */
 public interface ReferenceCounted {
diff --git a/common/src/main/java/io/netty/util/ResourceLeakDetector.java b/common/src/main/java/io/netty/util/ResourceLeakDetector.java
index 26d45785e1ce..6110b467151d 100644
--- a/common/src/main/java/io/netty/util/ResourceLeakDetector.java
+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java
@@ -28,12 +28,14 @@
 
 public final class ResourceLeakDetector<T> {
 
-    private static final boolean ENABLED = SystemPropertyUtil.getBoolean("io.netty.resourceLeakDetection", false);
+    private static final boolean DISABLED = SystemPropertyUtil.getBoolean("io.netty.noResourceLeakDetection", false);
+
+    public static final boolean ENABLED = !DISABLED;
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(ResourceLeakDetector.class);
 
     static {
-        logger.debug("io.netty.resourceLeakDetection: {}", ENABLED);
+        logger.debug("io.netty.noResourceLeakDetection: {}", DISABLED);
     }
 
     private static final int DEFAULT_SAMPLING_INTERVAL = 113;
@@ -92,7 +94,7 @@ public ResourceLeakDetector(String resourceType, int samplingInterval, long maxA
     }
 
     public ResourceLeak open(T obj) {
-        if (!ENABLED || leakCheckCnt ++ % samplingInterval != 0) {
+        if (DISABLED || leakCheckCnt ++ % samplingInterval != 0) {
             return NOOP;
         }
 
diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
index 55ea87aedfcb..142220579e02 100644
--- a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
@@ -34,14 +34,19 @@ public EventExecutor next() {
         return this;
     }
 
+    @Override
+    public boolean inEventLoop() {
+        return inEventLoop(Thread.currentThread());
+    }
+
     @Override
     public Iterator<EventExecutor> iterator() {
         return new EventExecutorIterator();
     }
 
     @Override
-    public void shutdownGracefully() {
-        shutdownGracefully(2, 15, TimeUnit.SECONDS);
+    public Future<?> shutdownGracefully() {
+        return shutdownGracefully(2, 15, TimeUnit.SECONDS);
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java
index f8011102c188..61789d6c93f1 100644
--- a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java
@@ -65,8 +65,8 @@ public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialD
     }
 
     @Override
-    public void shutdownGracefully() {
-        shutdownGracefully(2, 15, TimeUnit.SECONDS);
+    public Future<?> shutdownGracefully() {
+        return shutdownGracefully(2, 15, TimeUnit.SECONDS);
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java b/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java
index 9ee3831a1d09..b6073b69cd30 100644
--- a/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java
+++ b/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java
@@ -26,16 +26,6 @@
  */
 public abstract class AbstractFuture<V> implements Future<V> {
 
-    @Override
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        return false;
-    }
-
-    @Override
-    public boolean isCancelled() {
-        return false;
-    }
-
     @Override
     public V get() throws InterruptedException, ExecutionException {
         await();
diff --git a/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java
index 97a9810bd8b6..d9c6a091f970 100644
--- a/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java
+++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java
@@ -39,7 +39,7 @@ protected EventExecutor executor() {
     }
 
     @Override
-    public Future<V> addListener(GenericFutureListener<? extends Future<V>> listener) {
+    public Future<V> addListener(GenericFutureListener<? extends Future<? super V>> listener) {
         if (listener == null) {
             throw new NullPointerException("listener");
         }
@@ -48,11 +48,11 @@ public Future<V> addListener(GenericFutureListener<? extends Future<V>> listener
     }
 
     @Override
-    public Future<V> addListeners(GenericFutureListener<? extends Future<V>>... listeners) {
+    public Future<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
         if (listeners == null) {
             throw new NullPointerException("listeners");
         }
-        for (GenericFutureListener<? extends Future<V>> l: listeners) {
+        for (GenericFutureListener<? extends Future<? super V>> l: listeners) {
             if (l == null) {
                 break;
             }
@@ -62,13 +62,13 @@ public Future<V> addListeners(GenericFutureListener<? extends Future<V>>... list
     }
 
     @Override
-    public Future<V> removeListener(GenericFutureListener<? extends Future<V>> listener) {
+    public Future<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener) {
         // NOOP
         return this;
     }
 
     @Override
-    public Future<V> removeListeners(GenericFutureListener<? extends Future<V>>... listeners) {
+    public Future<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
         // NOOP
         return this;
     }
@@ -126,4 +126,19 @@ public boolean awaitUninterruptibly(long timeoutMillis) {
     public boolean isDone() {
         return true;
     }
+
+    @Override
+    public boolean isCancellable() {
+        return false;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return false;
+    }
+
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        return false;
+    }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/CompletePromise.java b/common/src/main/java/io/netty/util/concurrent/CompletePromise.java
index f8b94b18a35f..c5eb8db2a917 100644
--- a/common/src/main/java/io/netty/util/concurrent/CompletePromise.java
+++ b/common/src/main/java/io/netty/util/concurrent/CompletePromise.java
@@ -63,22 +63,22 @@ public Promise<V> sync() throws InterruptedException {
     }
 
     @Override
-    public Promise<V> addListener(GenericFutureListener<? extends Future<V>> listener) {
+    public Promise<V> addListener(GenericFutureListener<? extends Future<? super V>> listener) {
         return (Promise<V>) super.addListener(listener);
     }
 
     @Override
-    public Promise<V> addListeners(GenericFutureListener<? extends Future<V>>... listeners) {
+    public Promise<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
         return (Promise<V>) super.addListeners(listeners);
     }
 
     @Override
-    public Promise<V> removeListener(GenericFutureListener<? extends Future<V>> listener) {
+    public Promise<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener) {
         return (Promise<V>) super.removeListener(listener);
     }
 
     @Override
-    public Promise<V> removeListeners(GenericFutureListener<? extends Future<V>>... listeners) {
+    public Promise<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
         return (Promise<V>) super.removeListeners(listeners);
     }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java b/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java
index d19f8909284a..177e08edb435 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java
@@ -58,25 +58,25 @@ public boolean tryProgress(long progress, long total) {
     }
 
     @Override
-    public ProgressivePromise<V> addListener(GenericFutureListener<? extends Future<V>> listener) {
+    public ProgressivePromise<V> addListener(GenericFutureListener<? extends Future<? super V>> listener) {
         super.addListener(listener);
         return this;
     }
 
     @Override
-    public ProgressivePromise<V> addListeners(GenericFutureListener<? extends Future<V>>... listeners) {
+    public ProgressivePromise<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
         super.addListeners(listeners);
         return this;
     }
 
     @Override
-    public ProgressivePromise<V> removeListener(GenericFutureListener<? extends Future<V>> listener) {
+    public ProgressivePromise<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener) {
         super.removeListener(listener);
         return this;
     }
 
     @Override
-    public ProgressivePromise<V> removeListeners(GenericFutureListener<? extends Future<V>>... listeners) {
+    public ProgressivePromise<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
         super.removeListeners(listeners);
         return this;
     }
diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
index 134d46897210..61a77c87ea2f 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
@@ -20,6 +20,7 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.TimeUnit;
 
 import static java.util.concurrent.TimeUnit.*;
@@ -38,6 +39,7 @@ protected Integer initialValue() {
         }
     };
     private static final Signal SUCCESS = new Signal(DefaultPromise.class.getName() + ".SUCCESS");
+    private static final Signal UNCANCELLABLE = new Signal(DefaultPromise.class.getName() + ".UNCANCELLABLE");
     private final EventExecutor executor;
 
     private volatile Object result;
@@ -69,15 +71,33 @@ protected EventExecutor executor() {
         return executor;
     }
 
+    @Override
+    public boolean isCancelled() {
+        return isCancelled0(result);
+    }
+
+    private static boolean isCancelled0(Object result) {
+        return result instanceof CauseHolder && ((CauseHolder) result).cause instanceof CancellationException;
+    }
+
+    @Override
+    public boolean isCancellable() {
+        return result == null;
+    }
+
     @Override
     public boolean isDone() {
-        return result != null;
+        return isDone0(result);
+    }
+
+    private static boolean isDone0(Object result) {
+        return result != null && result != UNCANCELLABLE;
     }
 
     @Override
     public boolean isSuccess() {
         Object result = this.result;
-        if (result == null) {
+        if (result == null || result == UNCANCELLABLE) {
             return false;
         }
         return !(result instanceof CauseHolder);
@@ -85,15 +105,15 @@ public boolean isSuccess() {
 
     @Override
     public Throwable cause() {
-        Object cause = result;
-        if (cause instanceof CauseHolder) {
-            return ((CauseHolder) cause).cause;
+        Object result = this.result;
+        if (result instanceof CauseHolder) {
+            return ((CauseHolder) result).cause;
         }
         return null;
     }
 
     @Override
-    public Promise<V> addListener(GenericFutureListener<? extends Future<V>> listener) {
+    public Promise<V> addListener(GenericFutureListener<? extends Future<? super V>> listener) {
         if (listener == null) {
             throw new NullPointerException("listener");
         }
@@ -126,12 +146,12 @@ public Promise<V> addListener(GenericFutureListener<? extends Future<V>> listene
     }
 
     @Override
-    public Promise<V> addListeners(GenericFutureListener<? extends Future<V>>... listeners) {
+    public Promise<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
         if (listeners == null) {
             throw new NullPointerException("listeners");
         }
 
-        for (GenericFutureListener<? extends Future<V>> l: listeners) {
+        for (GenericFutureListener<? extends Future<? super V>> l: listeners) {
             if (l == null) {
                 break;
             }
@@ -141,7 +161,7 @@ public Promise<V> addListeners(GenericFutureListener<? extends Future<V>>... lis
     }
 
     @Override
-    public Promise<V> removeListener(GenericFutureListener<? extends Future<V>> listener) {
+    public Promise<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener) {
         if (listener == null) {
             throw new NullPointerException("listener");
         }
@@ -164,12 +184,12 @@ public Promise<V> removeListener(GenericFutureListener<? extends Future<V>> list
     }
 
     @Override
-    public Promise<V> removeListeners(GenericFutureListener<? extends Future<V>>... listeners) {
+    public Promise<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
         if (listeners == null) {
             throw new NullPointerException("listeners");
         }
 
-        for (GenericFutureListener<? extends Future<V>> l: listeners) {
+        for (GenericFutureListener<? extends Future<? super V>> l: listeners) {
             if (l == null) {
                 break;
             }
@@ -389,6 +409,49 @@ public boolean tryFailure(Throwable cause) {
         return false;
     }
 
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        Object result = this.result;
+        if (isDone0(result) || result == UNCANCELLABLE) {
+            return false;
+        }
+
+        synchronized (this) {
+            // Allow only once.
+            result = this.result;
+            if (isDone0(result) || result == UNCANCELLABLE) {
+                return false;
+            }
+
+            this.result = new CauseHolder(new CancellationException());
+            if (hasWaiters()) {
+                notifyAll();
+            }
+        }
+
+        notifyListeners();
+        return true;
+    }
+
+    @Override
+    public boolean setUncancellable() {
+        Object result = this.result;
+        if (isDone0(result)) {
+            return isCancelled0(result);
+        }
+
+        synchronized (this) {
+            // Allow only once.
+            result = this.result;
+            if (isDone0(result)) {
+                return isCancelled0(result);
+            }
+
+            this.result = UNCANCELLABLE;
+        }
+        return true;
+    }
+
     private boolean setFailure0(Throwable cause) {
         if (isDone()) {
             return false;
diff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
index 5f447314f133..30bd90d88372 100644
--- a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
@@ -37,8 +37,10 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E
 
     /**
      * Shortcut method for {@link #shutdownGracefully(long, long, TimeUnit)} with sensible default values.
+     *
+     * @return the {@link #terminationFuture()}
      */
-    void shutdownGracefully();
+    Future<?> shutdownGracefully();
 
     /**
      * Signals this executor that the caller wants the executor to be shut down.  Once this method is called,
@@ -51,8 +53,15 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E
      * @param timeout     the maximum amount of time to wait until the executor is {@linkplain #shutdown()}
      *                    regardless if a task was submitted during the quiet period
      * @param unit        the unit of {@code quietPeriod} and {@code timeout}
+     *
+     * @return the {@link #terminationFuture()}
+     */
+    Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit);
+
+    /**
+     * Returns the {@link Future} which is notified when this executor has been terminated.
      */
-    void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit);
+    Future<?> terminationFuture();
 
     /**
      * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead.
diff --git a/common/src/main/java/io/netty/util/concurrent/Future.java b/common/src/main/java/io/netty/util/concurrent/Future.java
index f6d1c624fd47..f3cf6878f381 100644
--- a/common/src/main/java/io/netty/util/concurrent/Future.java
+++ b/common/src/main/java/io/netty/util/concurrent/Future.java
@@ -22,6 +22,7 @@
 /**
  * The result of an asynchronous operation.
  */
+@SuppressWarnings("ClassNameSameAsAncestorName")
 public interface Future<V> extends java.util.concurrent.Future<V> {
 
     /**
@@ -30,6 +31,11 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
      */
     boolean isSuccess();
 
+    /**
+     * returns {@code true} if and only if the operation can be cancelled via {@link #cancel(boolean)}.
+     */
+    boolean isCancellable();
+
     /**
      * Returns the cause of the failed I/O operation if the I/O operation has
      * failed.
@@ -46,7 +52,7 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
      * {@linkplain #isDone() done}.  If this future is already
      * completed, the specified listener is notified immediately.
      */
-    Future<V> addListener(GenericFutureListener<? extends Future<V>> listener);
+    Future<V> addListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     /**
      * Adds the specified listeners to this future.  The
@@ -54,7 +60,7 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
      * {@linkplain #isDone() done}.  If this future is already
      * completed, the specified listeners are notified immediately.
      */
-    Future<V> addListeners(GenericFutureListener<? extends Future<V>>... listeners);
+    Future<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     /**
      * Removes the specified listener from this future.
@@ -63,7 +69,7 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
      * listener is not associated with this future, this method
      * does nothing and returns silently.
      */
-    Future<V> removeListener(GenericFutureListener<? extends Future<V>> listener);
+    Future<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     /**
      * Removes the specified listeners from this future.
@@ -72,7 +78,7 @@ public interface Future<V> extends java.util.concurrent.Future<V> {
      * listeners are not associated with this future, this method
      * does nothing and returns silently.
      */
-    Future<V> removeListeners(GenericFutureListener<? extends Future<V>>... listeners);
+    Future<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     /**
      * Waits for this future until it is done, and rethrows the cause of the failure if this future
diff --git a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
new file mode 100644
index 000000000000..55ac6c4dbd3d
--- /dev/null
+++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
@@ -0,0 +1,363 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.concurrent;
+
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.util.Iterator;
+import java.util.PriorityQueue;
+import java.util.Queue;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Single-thread singleton {@link EventExecutor}.  It starts the thread automatically and stops it when there is no
+ * task pending in the task queue for 1 second.  Please note it is not scalable to schedule large number of tasks to
+ * this executor; use a dedicated executor.
+ */
+public final class GlobalEventExecutor extends AbstractEventExecutor {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(GlobalEventExecutor.class);
+
+    private static final int ST_NOT_STARTED = 1;
+    private static final int ST_STARTED = 2;
+
+    private static final long SCHEDULE_PURGE_INTERVAL = TimeUnit.SECONDS.toNanos(1);
+
+    public static final GlobalEventExecutor INSTANCE = new GlobalEventExecutor();
+
+    final Queue<Runnable> taskQueue = new LinkedBlockingQueue<Runnable>();
+    final Queue<ScheduledFutureTask<?>> delayedTaskQueue = new PriorityQueue<ScheduledFutureTask<?>>();
+    final ScheduledFutureTask<Void> purgeTask = new ScheduledFutureTask<Void>(
+            this, delayedTaskQueue, Executors.<Void>callable(new PurgeTask(), null),
+            ScheduledFutureTask.deadlineNanos(SCHEDULE_PURGE_INTERVAL), -SCHEDULE_PURGE_INTERVAL);
+
+    private final ThreadFactory threadFactory = new DefaultThreadFactory(getClass());
+    private final TaskRunner taskRunner = new TaskRunner();
+    private final Object stateLock = new Object();
+
+    volatile Thread thread;
+    private volatile int state = ST_NOT_STARTED;
+
+    private final Future<?> terminationFuture = new FailedFuture<Object>(this, new UnsupportedOperationException());
+
+    private GlobalEventExecutor() {
+        delayedTaskQueue.add(purgeTask);
+    }
+
+    @Override
+    public EventExecutorGroup parent() {
+        return null;
+    }
+
+    /**
+     * Take the next {@link Runnable} from the task queue and so will block if no task is currently present.
+     *
+     * @return {@code null} if the executor thread has been interrupted or waken up.
+     */
+    Runnable takeTask() {
+        BlockingQueue<Runnable> taskQueue = (BlockingQueue<Runnable>) this.taskQueue;
+        for (;;) {
+            ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();
+            if (delayedTask == null) {
+                Runnable task = null;
+                try {
+                    task = taskQueue.take();
+                } catch (InterruptedException e) {
+                    // Ignore
+                }
+                return task;
+            } else {
+                long delayNanos = delayedTask.delayNanos();
+                Runnable task;
+                if (delayNanos > 0) {
+                    try {
+                        task = taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);
+                    } catch (InterruptedException e) {
+                        return null;
+                    }
+                } else {
+                    task = taskQueue.poll();
+                }
+
+                if (task == null) {
+                    fetchFromDelayedQueue();
+                    task = taskQueue.poll();
+                }
+
+                if (task != null) {
+                    return task;
+                }
+            }
+        }
+    }
+
+    private void fetchFromDelayedQueue() {
+        long nanoTime = 0L;
+        for (;;) {
+            ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();
+            if (delayedTask == null) {
+                break;
+            }
+
+            if (nanoTime == 0L) {
+                nanoTime = ScheduledFutureTask.nanoTime();
+            }
+
+            if (delayedTask.deadlineNanos() <= nanoTime) {
+                delayedTaskQueue.remove();
+                taskQueue.add(delayedTask);
+            } else {
+                break;
+            }
+        }
+    }
+
+    /**
+     * Return the number of tasks that are pending for processing.
+     *
+     * <strong>Be aware that this operation may be expensive as it depends on the internal implementation of the
+     * SingleThreadEventExecutor. So use it was care!</strong>
+     */
+    public int pendingTasks() {
+        return taskQueue.size();
+    }
+
+    /**
+     * Add a task to the task queue, or throws a {@link RejectedExecutionException} if this instance was shutdown
+     * before.
+     */
+    private void addTask(Runnable task) {
+        if (task == null) {
+            throw new NullPointerException("task");
+        }
+        taskQueue.add(task);
+    }
+
+    @Override
+    public boolean inEventLoop(Thread thread) {
+        return thread == this.thread;
+    }
+
+    @Override
+    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
+        return terminationFuture();
+    }
+
+    @Override
+    public Future<?> terminationFuture() {
+        return terminationFuture;
+    }
+
+    @Override
+    @Deprecated
+    public void shutdown() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isShuttingDown() {
+        return false;
+    }
+
+    @Override
+    public boolean isShutdown() {
+        return false;
+    }
+
+    @Override
+    public boolean isTerminated() {
+        return false;
+    }
+
+    @Override
+    public boolean awaitTermination(long timeout, TimeUnit unit) {
+        return false;
+    }
+
+    @Override
+    public void execute(Runnable task) {
+        if (task == null) {
+            throw new NullPointerException("task");
+        }
+
+        boolean inEventLoop = inEventLoop();
+        if (inEventLoop) {
+            addTask(task);
+        } else {
+            startThread();
+            addTask(task);
+        }
+    }
+
+    // ScheduledExecutorService implementation
+
+    @Override
+    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
+        if (command == null) {
+            throw new NullPointerException("command");
+        }
+        if (unit == null) {
+            throw new NullPointerException("unit");
+        }
+        if (delay < 0) {
+            throw new IllegalArgumentException(
+                    String.format("delay: %d (expected: >= 0)", delay));
+        }
+        return schedule(new ScheduledFutureTask<Void>(
+                this, delayedTaskQueue, command, null, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));
+    }
+
+    @Override
+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
+        if (callable == null) {
+            throw new NullPointerException("callable");
+        }
+        if (unit == null) {
+            throw new NullPointerException("unit");
+        }
+        if (delay < 0) {
+            throw new IllegalArgumentException(
+                    String.format("delay: %d (expected: >= 0)", delay));
+        }
+        return schedule(new ScheduledFutureTask<V>(
+                this, delayedTaskQueue, callable, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
+        if (command == null) {
+            throw new NullPointerException("command");
+        }
+        if (unit == null) {
+            throw new NullPointerException("unit");
+        }
+        if (initialDelay < 0) {
+            throw new IllegalArgumentException(
+                    String.format("initialDelay: %d (expected: >= 0)", initialDelay));
+        }
+        if (period <= 0) {
+            throw new IllegalArgumentException(
+                    String.format("period: %d (expected: > 0)", period));
+        }
+
+        return schedule(new ScheduledFutureTask<Void>(
+                this, delayedTaskQueue, Executors.<Void>callable(command, null),
+                ScheduledFutureTask.deadlineNanos(unit.toNanos(initialDelay)), unit.toNanos(period)));
+    }
+
+    @Override
+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
+        if (command == null) {
+            throw new NullPointerException("command");
+        }
+        if (unit == null) {
+            throw new NullPointerException("unit");
+        }
+        if (initialDelay < 0) {
+            throw new IllegalArgumentException(
+                    String.format("initialDelay: %d (expected: >= 0)", initialDelay));
+        }
+        if (delay <= 0) {
+            throw new IllegalArgumentException(
+                    String.format("delay: %d (expected: > 0)", delay));
+        }
+
+        return schedule(new ScheduledFutureTask<Void>(
+                this, delayedTaskQueue, Executors.<Void>callable(command, null),
+                ScheduledFutureTask.deadlineNanos(unit.toNanos(initialDelay)), -unit.toNanos(delay)));
+    }
+
+    private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {
+        if (task == null) {
+            throw new NullPointerException("task");
+        }
+
+        if (inEventLoop()) {
+            delayedTaskQueue.add(task);
+        } else {
+            execute(new Runnable() {
+                @Override
+                public void run() {
+                    delayedTaskQueue.add(task);
+                }
+            });
+        }
+
+        return task;
+    }
+
+    private void startThread() {
+        synchronized (stateLock) {
+            if (state == ST_NOT_STARTED) {
+                state = ST_STARTED;
+
+                thread = threadFactory.newThread(taskRunner);
+
+                thread.start();
+            }
+        }
+    }
+
+    final class TaskRunner implements Runnable {
+        @Override
+        public void run() {
+            for (;;) {
+                Runnable task = takeTask();
+                if (task != null) {
+                    try {
+                        task.run();
+                    } catch (Throwable t) {
+                        logger.warn("Unexpected exception from the global event executor: ", t);
+                    }
+
+                    if (task != purgeTask) {
+                        continue;
+                    }
+                }
+
+                if (taskQueue.isEmpty() && delayedTaskQueue.size() == 1) {
+                    synchronized (stateLock) {
+                        // Terminate if there is no task in the queue (except the purge task).
+                        if (taskQueue.isEmpty() && delayedTaskQueue.size() == 1) {
+                            state = ST_NOT_STARTED;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private final class PurgeTask implements Runnable {
+        @Override
+        public void run() {
+            Iterator<ScheduledFutureTask<?>> i = delayedTaskQueue.iterator();
+            while (i.hasNext()) {
+                ScheduledFutureTask<?> task = i.next();
+                if (task.isCancelled()) {
+                    i.remove();
+                }
+            }
+        }
+    }
+}
diff --git a/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
index c64761edd32e..0fae5844030a 100644
--- a/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java
@@ -23,7 +23,10 @@
 public final class ImmediateEventExecutor extends AbstractEventExecutor {
     public static final ImmediateEventExecutor INSTANCE = new ImmediateEventExecutor();
 
-    private  ImmediateEventExecutor() {
+    private final Future<?> terminationFuture = new FailedFuture<Object>(
+            GlobalEventExecutor.INSTANCE, new UnsupportedOperationException());
+
+    private ImmediateEventExecutor() {
         // use static instance
     }
 
@@ -43,7 +46,14 @@ public boolean inEventLoop(Thread thread) {
     }
 
     @Override
-    public void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) { }
+    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
+        return terminationFuture();
+    }
+
+    @Override
+    public Future<?> terminationFuture() {
+        return terminationFuture;
+    }
 
     @Override
     @Deprecated
diff --git a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
index 3a7b49f1ef22..2542e653406e 100644
--- a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
@@ -31,6 +31,8 @@ public abstract class MultithreadEventExecutorGroup extends AbstractEventExecuto
 
     private final EventExecutor[] children;
     private final AtomicInteger childIndex = new AtomicInteger();
+    private final AtomicInteger terminatedChildren = new AtomicInteger();
+    private final Promise<?> terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE);
 
     /**
      * Create a new instance.
@@ -77,6 +79,19 @@ protected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactor
                 }
             }
         }
+
+        final FutureListener<Object> terminationListener = new FutureListener<Object>() {
+            @Override
+            public void operationComplete(Future<Object> future) throws Exception {
+                if (terminatedChildren.incrementAndGet() == children.length) {
+                    terminationFuture.setSuccess(null);
+                }
+            }
+        };
+
+        for (EventExecutor e: children) {
+            e.terminationFuture().addListener(terminationListener);
+        }
     }
 
     protected ThreadFactory newDefaultThreadFactory() {
@@ -119,10 +134,16 @@ protected abstract EventExecutor newChild(
             ThreadFactory threadFactory, Object... args) throws Exception;
 
     @Override
-    public void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
+    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
         for (EventExecutor l: children) {
             l.shutdownGracefully(quietPeriod, timeout, unit);
         }
+        return terminationFuture();
+    }
+
+    @Override
+    public Future<?> terminationFuture() {
+        return terminationFuture;
     }
 
     @Override
diff --git a/common/src/main/java/io/netty/util/concurrent/ProgressiveFuture.java b/common/src/main/java/io/netty/util/concurrent/ProgressiveFuture.java
index 1c903d52de19..75f5eb1830f8 100644
--- a/common/src/main/java/io/netty/util/concurrent/ProgressiveFuture.java
+++ b/common/src/main/java/io/netty/util/concurrent/ProgressiveFuture.java
@@ -22,16 +22,16 @@
 public interface ProgressiveFuture<V> extends Future<V> {
 
     @Override
-    ProgressiveFuture<V> addListener(GenericFutureListener<? extends Future<V>> listener);
+    ProgressiveFuture<V> addListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     @Override
-    ProgressiveFuture<V> addListeners(GenericFutureListener<? extends Future<V>>... listeners);
+    ProgressiveFuture<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     @Override
-    ProgressiveFuture<V> removeListener(GenericFutureListener<? extends Future<V>> listener);
+    ProgressiveFuture<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     @Override
-    ProgressiveFuture<V> removeListeners(GenericFutureListener<? extends Future<V>>... listeners);
+    ProgressiveFuture<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     @Override
     ProgressiveFuture<V> sync() throws InterruptedException;
diff --git a/common/src/main/java/io/netty/util/concurrent/ProgressivePromise.java b/common/src/main/java/io/netty/util/concurrent/ProgressivePromise.java
index 1574404d2c4e..34097ae85ed0 100644
--- a/common/src/main/java/io/netty/util/concurrent/ProgressivePromise.java
+++ b/common/src/main/java/io/netty/util/concurrent/ProgressivePromise.java
@@ -40,16 +40,16 @@ public interface ProgressivePromise<V> extends Promise<V>, ProgressiveFuture<V>
     ProgressivePromise<V> setFailure(Throwable cause);
 
     @Override
-    ProgressivePromise<V> addListener(GenericFutureListener<? extends Future<V>> listener);
+    ProgressivePromise<V> addListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     @Override
-    ProgressivePromise<V> addListeners(GenericFutureListener<? extends Future<V>>... listeners);
+    ProgressivePromise<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     @Override
-    ProgressivePromise<V> removeListener(GenericFutureListener<? extends Future<V>> listener);
+    ProgressivePromise<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     @Override
-    ProgressivePromise<V> removeListeners(GenericFutureListener<? extends Future<V>>... listeners);
+    ProgressivePromise<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     @Override
     ProgressivePromise<V> await() throws InterruptedException;
diff --git a/common/src/main/java/io/netty/util/concurrent/Promise.java b/common/src/main/java/io/netty/util/concurrent/Promise.java
index 3eda72734fcf..effb54db335b 100644
--- a/common/src/main/java/io/netty/util/concurrent/Promise.java
+++ b/common/src/main/java/io/netty/util/concurrent/Promise.java
@@ -56,17 +56,25 @@ public interface Promise<V> extends Future<V> {
      */
     boolean tryFailure(Throwable cause);
 
+    /**
+     * Make this future impossible to cancel.
+     *
+     * @return {@code true} if and only if successfully marked this future as uncancellable or it is already done
+     *         without being cancelled.  {@code false} if this future has been cancelled already.
+     */
+    boolean setUncancellable();
+
     @Override
-    Promise<V> addListener(GenericFutureListener<? extends Future<V>> listener);
+    Promise<V> addListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     @Override
-    Promise<V> addListeners(GenericFutureListener<? extends Future<V>>... listeners);
+    Promise<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     @Override
-    Promise<V> removeListener(GenericFutureListener<? extends Future<V>> listener);
+    Promise<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);
 
     @Override
-    Promise<V> removeListeners(GenericFutureListener<? extends Future<V>>... listeners);
+    Promise<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
 
     @Override
     Promise<V> await() throws InterruptedException;
diff --git a/common/src/main/java/io/netty/util/concurrent/PromiseTask.java b/common/src/main/java/io/netty/util/concurrent/PromiseTask.java
index 0f2d8ac752e3..ccb8bf1b20aa 100644
--- a/common/src/main/java/io/netty/util/concurrent/PromiseTask.java
+++ b/common/src/main/java/io/netty/util/concurrent/PromiseTask.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.RunnableFuture;
 
 class PromiseTask<V> extends DefaultPromise<V> implements RunnableFuture<V> {
+
     protected final Callable<V> task;
 
     PromiseTask(EventExecutor executor, Runnable runnable, V result) {
@@ -32,12 +33,12 @@ class PromiseTask<V> extends DefaultPromise<V> implements RunnableFuture<V> {
     }
 
     @Override
-    public int hashCode() {
+    public final int hashCode() {
         return System.identityHashCode(this);
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public final boolean equals(Object obj) {
         return this == obj;
     }
 
@@ -52,7 +53,7 @@ public void run() {
     }
 
     @Override
-    public Promise<V> setFailure(Throwable cause) {
+    public final Promise<V> setFailure(Throwable cause) {
         throw new IllegalStateException();
     }
 
@@ -62,7 +63,7 @@ protected final Promise<V> setFailureInternal(Throwable cause) {
     }
 
     @Override
-    public boolean tryFailure(Throwable cause) {
+    public final boolean tryFailure(Throwable cause) {
         return false;
     }
 
@@ -71,7 +72,7 @@ protected final boolean tryFailureInternal(Throwable cause) {
     }
 
     @Override
-    public Promise<V> setSuccess(V result) {
+    public final Promise<V> setSuccess(V result) {
         throw new IllegalStateException();
     }
 
@@ -81,11 +82,20 @@ protected final Promise<V> setSuccessInternal(V result) {
     }
 
     @Override
-    public boolean trySuccess(V result) {
+    public final boolean trySuccess(V result) {
         return false;
     }
 
     protected final boolean trySuccessInternal(V result) {
         return super.trySuccess(result);
     }
+
+    @Override
+    public final boolean setUncancellable() {
+        throw new IllegalStateException();
+    }
+
+    protected final boolean setUncancellableInternal() {
+        return super.setUncancellable();
+    }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java b/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
new file mode 100644
index 000000000000..fc7b5b4eb9ab
--- /dev/null
+++ b/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.concurrent;
+
+import java.util.Queue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Delayed;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+@SuppressWarnings("ComparableImplementedButEqualsNotOverridden")
+final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFuture<V> {
+    private static final AtomicLong nextTaskId = new AtomicLong();
+    private static final long START_TIME = System.nanoTime();
+
+    static long nanoTime() {
+        return System.nanoTime() - START_TIME;
+    }
+
+    static long deadlineNanos(long delay) {
+        return nanoTime() + delay;
+    }
+
+    private final long id = nextTaskId.getAndIncrement();
+    private final Queue<ScheduledFutureTask<?>> delayedTaskQueue;
+    private long deadlineNanos;
+    /* 0 - no repeat, >0 - repeat at fixed rate, <0 - repeat with fixed delay */
+    private final long periodNanos;
+
+    ScheduledFutureTask(
+            EventExecutor executor, Queue<ScheduledFutureTask<?>> delayedTaskQueue,
+            Runnable runnable, V result, long nanoTime) {
+
+        this(executor, delayedTaskQueue, Executors.callable(runnable, result), nanoTime);
+    }
+
+    ScheduledFutureTask(
+            EventExecutor executor, Queue<ScheduledFutureTask<?>> delayedTaskQueue,
+            Callable<V> callable, long nanoTime, long period) {
+
+        super(executor, callable);
+        if (period == 0) {
+            throw new IllegalArgumentException("period: 0 (expected: != 0)");
+        }
+        this.delayedTaskQueue = delayedTaskQueue;
+        deadlineNanos = nanoTime;
+        periodNanos = period;
+    }
+
+    ScheduledFutureTask(
+            EventExecutor executor, Queue<ScheduledFutureTask<?>> delayedTaskQueue,
+            Callable<V> callable, long nanoTime) {
+
+        super(executor, callable);
+        this.delayedTaskQueue = delayedTaskQueue;
+        deadlineNanos = nanoTime;
+        periodNanos = 0;
+    }
+
+    @Override
+    protected EventExecutor executor() {
+        return super.executor();
+    }
+
+    public long deadlineNanos() {
+        return deadlineNanos;
+    }
+
+    public long delayNanos() {
+        return Math.max(0, deadlineNanos() - nanoTime());
+    }
+
+    public long delayNanos(long currentTimeNanos) {
+        return Math.max(0, deadlineNanos() - (currentTimeNanos - START_TIME));
+    }
+
+    @Override
+    public long getDelay(TimeUnit unit) {
+        return unit.convert(delayNanos(), TimeUnit.NANOSECONDS);
+    }
+
+    @Override
+    public int compareTo(Delayed o) {
+        if (this == o) {
+            return 0;
+        }
+
+        ScheduledFutureTask<?> that = (ScheduledFutureTask<?>) o;
+        long d = deadlineNanos() - that.deadlineNanos();
+        if (d < 0) {
+            return -1;
+        } else if (d > 0) {
+            return 1;
+        } else if (id < that.id) {
+            return -1;
+        } else if (id == that.id) {
+            throw new Error();
+        } else {
+            return 1;
+        }
+    }
+
+    @Override
+    public void run() {
+        assert executor().inEventLoop();
+        try {
+            if (periodNanos == 0) {
+                if (setUncancellableInternal()) {
+                    V result = task.call();
+                    setSuccessInternal(result);
+                }
+            } else {
+                // check if is done as it may was cancelled
+                if (!isCancelled()) {
+                    task.call();
+                    if (!executor().isShutdown()) {
+                        long p = periodNanos;
+                        if (p > 0) {
+                            deadlineNanos += p;
+                        } else {
+                            deadlineNanos = nanoTime() - p;
+                        }
+                        if (!isCancelled()) {
+                            delayedTaskQueue.add(this);
+                        }
+                    }
+                }
+            }
+        } catch (Throwable cause) {
+            setFailureInternal(cause);
+        }
+    }
+}
diff --git a/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
index 403aefa5d929..c3e6e1963e7a 100644
--- a/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
@@ -27,16 +27,12 @@
 import java.util.Set;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.Delayed;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Abstract base class for {@link EventExecutor}'s that execute all its submitted tasks in a single thread.
@@ -47,9 +43,6 @@ public abstract class SingleThreadEventExecutor extends AbstractEventExecutor {
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(SingleThreadEventExecutor.class);
 
-    static final ThreadLocal<SingleThreadEventExecutor> CURRENT_EVENT_LOOP =
-            new ThreadLocal<SingleThreadEventExecutor>();
-
     private static final int ST_NOT_STARTED = 1;
     private static final int ST_STARTED = 2;
     private static final int ST_SHUTTING_DOWN = 3;
@@ -63,13 +56,6 @@ public void run() {
         }
     };
 
-    /**
-     * Return the {@link SingleThreadEventExecutor} which belongs the current {@link Thread}.
-     */
-    public static SingleThreadEventExecutor currentEventLoop() {
-        return CURRENT_EVENT_LOOP.get();
-    }
-
     private final EventExecutorGroup parent;
     private final Queue<Runnable> taskQueue;
     final Queue<ScheduledFutureTask<?>> delayedTaskQueue = new PriorityQueue<ScheduledFutureTask<?>>();
@@ -86,6 +72,8 @@ public static SingleThreadEventExecutor currentEventLoop() {
     private volatile long gracefulShutdownTimeout;
     private long gracefulShutdownStartTime;
 
+    private final Promise<?> terminationFuture = new DefaultPromise<Void>(GlobalEventExecutor.INSTANCE);
+
     /**
      * Create a new instance
      *
@@ -107,7 +95,6 @@ protected SingleThreadEventExecutor(
         thread = threadFactory.newThread(new Runnable() {
             @Override
             public void run() {
-                CURRENT_EVENT_LOOP.set(SingleThreadEventExecutor.this);
                 boolean success = false;
                 updateLastExecutionTime();
                 try {
@@ -148,6 +135,8 @@ public void run() {
                                         "An event executor terminated with " +
                                         "non-empty task queue (" + taskQueue.size() + ')');
                             }
+
+                            terminationFuture.setSuccess(null);
                         }
                     }
                 }
@@ -256,7 +245,7 @@ private void fetchFromDelayedQueue() {
             }
 
             if (nanoTime == 0L) {
-                nanoTime = nanoTime();
+                nanoTime = ScheduledFutureTask.nanoTime();
             }
 
             if (delayedTask.deadlineNanos() <= nanoTime) {
@@ -339,7 +328,7 @@ protected boolean runAllTasks() {
 
             task = pollTask();
             if (task == null) {
-                lastExecutionTime = nanoTime();
+                lastExecutionTime = ScheduledFutureTask.nanoTime();
                 return true;
             }
         }
@@ -356,7 +345,7 @@ protected boolean runAllTasks(long timeoutNanos) {
             return false;
         }
 
-        final long deadline = nanoTime() + timeoutNanos;
+        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;
         long runTasks = 0;
         long lastExecutionTime;
         for (;;) {
@@ -371,7 +360,7 @@ protected boolean runAllTasks(long timeoutNanos) {
             // Check timeout every 64 tasks because nanoTime() is relatively expensive.
             // XXX: Hard-coded value - will make it configurable if it is really a problem.
             if ((runTasks & 0x3F) == 0) {
-                lastExecutionTime = nanoTime();
+                lastExecutionTime = ScheduledFutureTask.nanoTime();
                 if (lastExecutionTime >= deadline) {
                     break;
                 }
@@ -379,7 +368,7 @@ protected boolean runAllTasks(long timeoutNanos) {
 
             task = pollTask();
             if (task == null) {
-                lastExecutionTime = nanoTime();
+                lastExecutionTime = ScheduledFutureTask.nanoTime();
                 break;
             }
         }
@@ -408,7 +397,7 @@ protected long delayNanos(long currentTimeNanos) {
      * checks.
      */
     protected void updateLastExecutionTime() {
-        lastExecutionTime = nanoTime();
+        lastExecutionTime = ScheduledFutureTask.nanoTime();
     }
 
     /**
@@ -429,11 +418,6 @@ protected void wakeup(boolean inEventLoop) {
         }
     }
 
-    @Override
-    public boolean inEventLoop() {
-        return inEventLoop(Thread.currentThread());
-    }
-
     @Override
     public boolean inEventLoop(Thread thread) {
         return thread == this.thread;
@@ -489,14 +473,14 @@ private boolean runShutdownHooks() {
         }
 
         if (ran) {
-            lastExecutionTime = nanoTime();
+            lastExecutionTime = ScheduledFutureTask.nanoTime();
         }
 
         return ran;
     }
 
     @Override
-    public void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
+    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
         if (quietPeriod < 0) {
             throw new IllegalArgumentException("quietPeriod: " + quietPeriod + " (expected >= 0)");
         }
@@ -509,7 +493,7 @@ public void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
         }
 
         if (isShuttingDown()) {
-            return;
+            return terminationFuture();
         }
 
         boolean inEventLoop = inEventLoop();
@@ -517,7 +501,7 @@ public void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
 
         synchronized (stateLock) {
             if (isShuttingDown()) {
-                return;
+                return terminationFuture();
             }
 
             gracefulShutdownQuietPeriod = unit.toNanos(quietPeriod);
@@ -544,6 +528,13 @@ public void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
         if (wakeup) {
             wakeup(inEventLoop);
         }
+
+        return terminationFuture();
+    }
+
+    @Override
+    public Future<?> terminationFuture() {
+        return terminationFuture;
     }
 
     @Override
@@ -615,7 +606,7 @@ protected boolean confirmShutdown() {
         cancelDelayedTasks();
 
         if (gracefulShutdownStartTime == 0) {
-            gracefulShutdownStartTime = nanoTime();
+            gracefulShutdownStartTime = ScheduledFutureTask.nanoTime();
         }
 
         if (runAllTasks() || runShutdownHooks()) {
@@ -629,7 +620,7 @@ protected boolean confirmShutdown() {
             return false;
         }
 
-        final long nanoTime = nanoTime();
+        final long nanoTime = ScheduledFutureTask.nanoTime();
 
         if (isShutdown() || nanoTime - gracefulShutdownStartTime > gracefulShutdownTimeout) {
             return true;
@@ -714,15 +705,6 @@ protected static void reject() {
     // ScheduledExecutorService implementation
 
     private static final long SCHEDULE_PURGE_INTERVAL = TimeUnit.SECONDS.toNanos(1);
-    private static final long START_TIME = System.nanoTime();
-    private static final AtomicLong nextTaskId = new AtomicLong();
-    private static long nanoTime() {
-        return System.nanoTime() - START_TIME;
-    }
-
-    private static long deadlineNanos(long delay) {
-        return nanoTime() + delay;
-    }
 
     @Override
     public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
@@ -736,7 +718,8 @@ public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)
             throw new IllegalArgumentException(
                     String.format("delay: %d (expected: >= 0)", delay));
         }
-        return schedule(new ScheduledFutureTask<Void>(this, command, null, deadlineNanos(unit.toNanos(delay))));
+        return schedule(new ScheduledFutureTask<Void>(
+                this, delayedTaskQueue, command, null, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));
     }
 
     @Override
@@ -751,7 +734,8 @@ public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUni
             throw new IllegalArgumentException(
                     String.format("delay: %d (expected: >= 0)", delay));
         }
-        return schedule(new ScheduledFutureTask<V>(this, callable, deadlineNanos(unit.toNanos(delay))));
+        return schedule(new ScheduledFutureTask<V>(
+                this, delayedTaskQueue, callable, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));
     }
 
     @Override
@@ -772,8 +756,8 @@ public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDela
         }
 
         return schedule(new ScheduledFutureTask<Void>(
-                this, Executors.<Void>callable(command, null),
-                deadlineNanos(unit.toNanos(initialDelay)), unit.toNanos(period)));
+                this, delayedTaskQueue, Executors.<Void>callable(command, null),
+                ScheduledFutureTask.deadlineNanos(unit.toNanos(initialDelay)), unit.toNanos(period)));
     }
 
     @Override
@@ -794,8 +778,8 @@ public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialD
         }
 
         return schedule(new ScheduledFutureTask<Void>(
-                this, Executors.<Void>callable(command, null),
-                deadlineNanos(unit.toNanos(initialDelay)), -unit.toNanos(delay)));
+                this, delayedTaskQueue, Executors.<Void>callable(command, null),
+                ScheduledFutureTask.deadlineNanos(unit.toNanos(initialDelay)), -unit.toNanos(delay)));
     }
 
     private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {
@@ -822,152 +806,13 @@ private void startThread() {
             if (state == ST_NOT_STARTED) {
                 state = ST_STARTED;
                 delayedTaskQueue.add(new ScheduledFutureTask<Void>(
-                        this, Executors.<Void>callable(new PurgeTask(), null),
-                        deadlineNanos(SCHEDULE_PURGE_INTERVAL), -SCHEDULE_PURGE_INTERVAL));
+                        this, delayedTaskQueue, Executors.<Void>callable(new PurgeTask(), null),
+                        ScheduledFutureTask.deadlineNanos(SCHEDULE_PURGE_INTERVAL), -SCHEDULE_PURGE_INTERVAL));
                 thread.start();
             }
         }
     }
 
-    private static final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFuture<V> {
-
-        @SuppressWarnings("rawtypes")
-        private static final AtomicIntegerFieldUpdater<ScheduledFutureTask> uncancellableUpdater =
-                AtomicIntegerFieldUpdater.newUpdater(ScheduledFutureTask.class, "uncancellable");
-
-        private final long id = nextTaskId.getAndIncrement();
-        private long deadlineNanos;
-        /* 0 - no repeat, >0 - repeat at fixed rate, <0 - repeat with fixed delay */
-        private final long periodNanos;
-        @SuppressWarnings("UnusedDeclaration")
-        private volatile int uncancellable;
-
-        ScheduledFutureTask(SingleThreadEventExecutor executor, Runnable runnable, V result, long nanoTime) {
-            this(executor, Executors.callable(runnable, result), nanoTime);
-        }
-
-        ScheduledFutureTask(SingleThreadEventExecutor executor, Callable<V> callable, long nanoTime, long period) {
-            super(executor, callable);
-            if (period == 0) {
-                throw new IllegalArgumentException("period: 0 (expected: != 0)");
-            }
-            deadlineNanos = nanoTime;
-            periodNanos = period;
-        }
-
-        ScheduledFutureTask(SingleThreadEventExecutor executor, Callable<V> callable, long nanoTime) {
-            super(executor, callable);
-            deadlineNanos = nanoTime;
-            periodNanos = 0;
-        }
-
-        @Override
-        protected SingleThreadEventExecutor executor() {
-            return (SingleThreadEventExecutor) super.executor();
-        }
-
-        public long deadlineNanos() {
-            return deadlineNanos;
-        }
-
-        public long delayNanos() {
-            return Math.max(0, deadlineNanos() - nanoTime());
-        }
-
-        public long delayNanos(long currentTimeNanos) {
-            return Math.max(0, deadlineNanos() - (currentTimeNanos - START_TIME));
-        }
-
-        @Override
-        public long getDelay(TimeUnit unit) {
-            return unit.convert(delayNanos(), TimeUnit.NANOSECONDS);
-        }
-
-        @Override
-        public int compareTo(Delayed o) {
-            if (this == o) {
-                return 0;
-            }
-
-            ScheduledFutureTask<?> that = (ScheduledFutureTask<?>) o;
-            long d = deadlineNanos() - that.deadlineNanos();
-            if (d < 0) {
-                return -1;
-            } else if (d > 0) {
-                return 1;
-            } else if (id < that.id) {
-                return -1;
-            } else if (id == that.id) {
-                throw new Error();
-            } else {
-                return 1;
-            }
-        }
-
-        @Override
-        public int hashCode() {
-            return super.hashCode();
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            return super.equals(obj);
-        }
-
-        @Override
-        public void run() {
-            assert executor().inEventLoop();
-            try {
-                if (periodNanos == 0) {
-                    if (setUncancellable()) {
-                        V result = task.call();
-                        setSuccessInternal(result);
-                    }
-                } else {
-                    // check if is done as it may was cancelled
-                    if (!isDone()) {
-                        task.call();
-                        if (!executor().isShutdown()) {
-                            long p = periodNanos;
-                            if (p > 0) {
-                                deadlineNanos += p;
-                            } else {
-                                deadlineNanos = nanoTime() - p;
-                            }
-                            if (!isDone()) {
-                                executor().delayedTaskQueue.add(this);
-                            }
-                        }
-                    }
-                }
-            } catch (Throwable cause) {
-                setFailureInternal(cause);
-            }
-        }
-
-        @Override
-        public boolean isCancelled() {
-            if (cause() instanceof CancellationException) {
-                return true;
-            }
-            return false;
-        }
-
-        @Override
-        public  boolean cancel(boolean mayInterruptIfRunning) {
-            if (!isDone()) {
-                if (setUncancellable()) {
-                    return tryFailureInternal(new CancellationException());
-                }
-            }
-            return false;
-        }
-
-        private boolean setUncancellable() {
-            return uncancellableUpdater.compareAndSet(this, 0, 1);
-        }
-    }
-
     private final class PurgeTask implements Runnable {
         @Override
         public void run() {
diff --git a/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java b/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
index f3c838dc496a..154322516c24 100644
--- a/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
+++ b/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java
@@ -18,20 +18,35 @@
 
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
+import javassist.ClassClassPath;
+import javassist.ClassPath;
 import javassist.ClassPool;
 import javassist.CtClass;
 import javassist.Modifier;
+import javassist.NotFoundException;
 
 import java.lang.reflect.Method;
 
-final class JavassistTypeParameterMatcherGenerator {
+public final class JavassistTypeParameterMatcherGenerator {
 
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(JavassistTypeParameterMatcherGenerator.class);
 
     private static final ClassPool classPool = new ClassPool(true);
 
-    static TypeParameterMatcher generate(Class<?> type) {
+    static {
+        classPool.appendClassPath(new ClassClassPath(NoOpTypeParameterMatcher.class));
+    }
+
+    public void appendClassPath(ClassPath classpath) {
+        classPool.appendClassPath(classpath);
+    }
+
+    public void appendClassPath(String pathname) throws NotFoundException {
+        classPool.appendClassPath(pathname);
+    }
+
+    public static TypeParameterMatcher generate(Class<?> type) {
         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
         if (classLoader == null) {
             classLoader = ClassLoader.getSystemClassLoader();
@@ -39,7 +54,7 @@ static TypeParameterMatcher generate(Class<?> type) {
         return generate(type, classLoader);
     }
 
-    static TypeParameterMatcher generate(Class<?> type, ClassLoader classLoader) {
+    public static TypeParameterMatcher generate(Class<?> type, ClassLoader classLoader) {
         final String typeName = typeName(type);
         final String className = "io.netty.util.internal.__matchers__." + typeName + "Matcher";
         try {
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 6d07a6e56fb1..398a2564f26c 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -58,7 +58,7 @@ public final class PlatformDependent {
     private static final boolean HAS_UNSAFE = hasUnsafe0();
     private static final boolean CAN_USE_CHM_V8 = HAS_UNSAFE && JAVA_VERSION < 8;
     private static final boolean DIRECT_BUFFER_PREFERRED =
-            HAS_UNSAFE && SystemPropertyUtil.getBoolean("io.netty.preferDirect", false);
+            HAS_UNSAFE && !SystemPropertyUtil.getBoolean("io.netty.noPreferDirect", false);
 
     private static final long ARRAY_BASE_OFFSET = arrayBaseOffset0();
 
@@ -66,7 +66,7 @@ public final class PlatformDependent {
 
     static {
         if (logger.isDebugEnabled()) {
-            logger.debug("io.netty.preferDirect: {}", DIRECT_BUFFER_PREFERRED);
+            logger.debug("io.netty.noPreferDirect: {}", !DIRECT_BUFFER_PREFERRED);
         }
 
         if (!hasUnsafe()) {
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index 8aaf88270d97..34a13383bf74 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -24,6 +24,7 @@
 import java.lang.reflect.Method;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 
 /**
  * The {@link PlatformDependent} operations which requires access to {@code sun.misc.*}.
@@ -32,6 +33,8 @@ final class PlatformDependent0 {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(PlatformDependent0.class);
     private static final Unsafe UNSAFE;
+    private static final boolean BIG_ENDIAN = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
+
     private static final long CLEANER_FIELD_OFFSET;
     private static final long ADDRESS_FIELD_OFFSET;
 
@@ -184,26 +187,33 @@ static byte getByte(long address) {
     static short getShort(long address) {
         if (UNALIGNED) {
             return UNSAFE.getShort(address);
-        } else {
+        } else if (BIG_ENDIAN) {
             return (short) (getByte(address) << 8 | getByte(address + 1) & 0xff);
+        } else {
+            return (short) (getByte(address + 1) << 8 | getByte(address) & 0xff);
         }
     }
 
     static int getInt(long address) {
         if (UNALIGNED) {
             return UNSAFE.getInt(address);
-        } else {
+        } else if (BIG_ENDIAN) {
             return getByte(address) << 24 |
                   (getByte(address + 1) & 0xff) << 16 |
                   (getByte(address + 2) & 0xff) <<  8 |
                    getByte(address + 3) & 0xff;
+        } else {
+            return getByte(address + 3) << 24 |
+                  (getByte(address + 2) & 0xff) << 16 |
+                  (getByte(address + 1) & 0xff) <<  8 |
+                   getByte(address) & 0xff;
         }
     }
 
     static long getLong(long address) {
         if (UNALIGNED) {
             return UNSAFE.getLong(address);
-        } else {
+        } else if (BIG_ENDIAN) {
             return (long) getByte(address) << 56 |
                   ((long) getByte(address + 1) & 0xff) << 48 |
                   ((long) getByte(address + 2) & 0xff) << 40 |
@@ -212,6 +222,15 @@ static long getLong(long address) {
                   ((long) getByte(address + 5) & 0xff) << 16 |
                   ((long) getByte(address + 6) & 0xff) <<  8 |
                    (long) getByte(address + 7) & 0xff;
+        } else {
+            return (long) getByte(address + 7) << 56 |
+                  ((long) getByte(address + 6) & 0xff) << 48 |
+                  ((long) getByte(address + 5) & 0xff) << 40 |
+                  ((long) getByte(address + 4) & 0xff) << 32 |
+                  ((long) getByte(address + 3) & 0xff) << 24 |
+                  ((long) getByte(address + 2) & 0xff) << 16 |
+                  ((long) getByte(address + 1) & 0xff) <<  8 |
+                   (long) getByte(address) & 0xff;
         }
     }
 
@@ -222,27 +241,35 @@ static void putByte(long address, byte value) {
     static void putShort(long address, short value) {
         if (UNALIGNED) {
             UNSAFE.putShort(address, value);
-        } else {
+        } else if (BIG_ENDIAN) {
             putByte(address, (byte) (value >>> 8));
             putByte(address + 1, (byte) value);
+        } else {
+            putByte(address + 1, (byte) (value >>> 8));
+            putByte(address, (byte) value);
         }
     }
 
     static void putInt(long address, int value) {
         if (UNALIGNED) {
             UNSAFE.putInt(address, value);
-        } else {
+        } else if (BIG_ENDIAN) {
             putByte(address, (byte) (value >>> 24));
             putByte(address + 1, (byte) (value >>> 16));
             putByte(address + 2, (byte) (value >>> 8));
             putByte(address + 3, (byte) value);
+        } else {
+            putByte(address + 3, (byte) (value >>> 24));
+            putByte(address + 2, (byte) (value >>> 16));
+            putByte(address + 1, (byte) (value >>> 8));
+            putByte(address, (byte) value);
         }
     }
 
     static void putLong(long address, long value) {
         if (UNALIGNED) {
             UNSAFE.putLong(address, value);
-        } else {
+        } else if (BIG_ENDIAN) {
             putByte(address, (byte) (value >>> 56));
             putByte(address + 1, (byte) (value >>> 48));
             putByte(address + 2, (byte) (value >>> 40));
@@ -251,6 +278,15 @@ static void putLong(long address, long value) {
             putByte(address + 5, (byte) (value >>> 16));
             putByte(address + 6, (byte) (value >>> 8));
             putByte(address + 7, (byte) value);
+        } else {
+            putByte(address + 7, (byte) (value >>> 56));
+            putByte(address + 6, (byte) (value >>> 48));
+            putByte(address + 5, (byte) (value >>> 40));
+            putByte(address + 4, (byte) (value >>> 32));
+            putByte(address + 3, (byte) (value >>> 24));
+            putByte(address + 2, (byte) (value >>> 16));
+            putByte(address + 1, (byte) (value >>> 8));
+            putByte(address, (byte) value);
         }
     }
 
diff --git a/common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java b/common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java
new file mode 100644
index 000000000000..cbc65df5d558
--- /dev/null
+++ b/common/src/test/java/io/netty/util/concurrent/GlobalEventExecutorTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.concurrent;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+public class GlobalEventExecutorTest {
+
+    private static final GlobalEventExecutor e = GlobalEventExecutor.INSTANCE;
+
+    @Before
+    public void setUp() throws Exception {
+        // Wait until the global executor is stopped (just in case there is a task running due to previous test cases)
+        for (;;) {
+            if (e.thread == null || !e.thread.isAlive()) {
+                break;
+            }
+
+            Thread.sleep(50);
+        }
+    }
+
+    @Test
+    public void testAutomaticStartStop() throws Exception {
+        final TestRunnable task = new TestRunnable(500);
+        e.execute(task);
+
+        // Ensure the new thread has started.
+        Thread thread = e.thread;
+        assertThat(thread, is(not(nullValue())));
+        assertThat(thread.isAlive(), is(true));
+
+        Thread.sleep(1500);
+
+        // Ensure the thread stopped itself after running the task.
+        assertThat(thread.isAlive(), is(false));
+        assertThat(task.ran.get(), is(true));
+        assertThat(e.thread, sameInstance(thread));
+
+        // Ensure another new thread starts again.
+        task.ran.set(false);
+        e.execute(task);
+        assertThat(e.thread, not(sameInstance(thread)));
+        thread = e.thread;
+
+        Thread.sleep(1500);
+
+        // Ensure the thread stopped itself after running the task.
+        assertThat(thread.isAlive(), is(false));
+        assertThat(task.ran.get(), is(true));
+        assertThat(e.thread, sameInstance(thread));
+    }
+
+    @Test
+    public void testScheduledTasks() throws Exception {
+        TestRunnable task = new TestRunnable(0);
+        ScheduledFuture<?> f = e.schedule(task, 1500, TimeUnit.MILLISECONDS);
+        f.sync();
+        assertThat(task.ran.get(), is(true));
+
+        // Ensure the thread is still running.
+        Thread thread = e.thread;
+        assertThat(thread, is(not(nullValue())));
+        assertThat(thread.isAlive(), is(true));
+
+        Thread.sleep(1500);
+
+        // Not it should be stopped.
+        assertThat(thread.isAlive(), is(false));
+        assertThat(e.thread, sameInstance(thread));
+    }
+
+    private static final class TestRunnable implements Runnable {
+        final AtomicBoolean ran = new AtomicBoolean();
+        final long delay;
+
+        TestRunnable(long delay) {
+            this.delay = delay;
+        }
+
+        @Override
+        public void run() {
+            try {
+                Thread.sleep(delay);
+                ran.set(true);
+            } catch (InterruptedException ignored) {
+                // Ignore
+            }
+        }
+    }
+}
diff --git a/example/pom.xml b/example/pom.xml
index 81adab61b948..bead2962a8f3 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-example</artifactId>
diff --git a/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java
index e86e7adf5360..878b14fb375f 100644
--- a/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java
+++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java
@@ -19,9 +19,10 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.EventLoopGroup;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
@@ -72,12 +73,15 @@ public void destroy() {
         }
     }
 
-    private static final class DiscardServerHandler extends ChannelInboundByteHandlerAdapter {
+    private static final class DiscardServerHandler extends ChannelInboundHandlerAdapter {
 
         @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-            System.out.println("Received: " + in.toString(CharsetUtil.UTF_8));
-            in.clear();
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            MessageList<ByteBuf> bufs = msgs.cast();
+            for (int i = 0; i < bufs.size(); i++) {
+                System.out.println("Received: " + bufs.get(i).toString(CharsetUtil.UTF_8));
+            }
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
index 22d1be131832..c28c57fb6e04 100644
--- a/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
+++ b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
@@ -19,7 +19,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -27,7 +28,7 @@
 /**
  * Handles a client-side channel.
  */
-public class DiscardClientHandler extends ChannelInboundByteHandlerAdapter {
+public class DiscardClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             DiscardClientHandler.class.getName());
@@ -57,10 +58,14 @@ public void channelActive(ChannelHandlerContext ctx)
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in)
-            throws Exception {
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        content.release();
+    }
+
+    @Override
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         // Server is supposed to send nothing, but if it sends something, discard it.
-        in.clear();
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
@@ -77,15 +82,9 @@ public void exceptionCaught(ChannelHandlerContext ctx,
     long counter;
 
     private void generateTraffic() {
-        // Fill the outbound buffer up to 64KiB
-        ByteBuf out = ctx.nextOutboundByteBuffer();
-        while (out.readableBytes() < 65536) {
-            out.writeBytes(content, 0, content.readableBytes());
-        }
-
         // Flush the outbound buffer to the socket.
         // Once flushed, generate the same amount of traffic again.
-        ctx.flush().addListener(trafficGenerator);
+        ctx.write(content.duplicate().retain()).addListener(trafficGenerator);
     }
 
     private final ChannelFutureListener trafficGenerator = new ChannelFutureListener() {
diff --git a/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
index 8e43955d0d78..e2386fd2d00d 100644
--- a/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
+++ b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java
@@ -15,9 +15,9 @@
  */
 package io.netty.example.discard;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -25,16 +25,15 @@
 /**
  * Handles a server-side channel.
  */
-public class DiscardServerHandler extends ChannelInboundByteHandlerAdapter {
+public class DiscardServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             DiscardServerHandler.class.getName());
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in)
-            throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         // Discard the received data silently.
-        in.clear();
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/echo/EchoClient.java b/example/src/main/java/io/netty/example/echo/EchoClient.java
index d124ac28990c..15eafffab986 100644
--- a/example/src/main/java/io/netty/example/echo/EchoClient.java
+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java
@@ -23,8 +23,6 @@
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.logging.LogLevel;
-import io.netty.handler.logging.LoggingHandler;
 
 /**
  * Sends one message when a connection is open and echoes back any received
@@ -56,7 +54,7 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
+                             //new LoggingHandler(LogLevel.INFO),
                              new EchoClientHandler(firstMessageSize));
                  }
              });
diff --git a/example/src/main/java/io/netty/example/echo/EchoClientHandler.java b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java
index ad52c616dd81..fd56fce11ebb 100644
--- a/example/src/main/java/io/netty/example/echo/EchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java
@@ -18,7 +18,8 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -28,7 +29,7 @@
  * traffic between the echo client and server by sending the first message to
  * the server.
  */
-public class EchoClientHandler extends ChannelInboundByteHandlerAdapter {
+public class EchoClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             EchoClientHandler.class.getName());
@@ -54,10 +55,8 @@ public void channelActive(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) {
-        ByteBuf out = ctx.nextOutboundByteBuffer();
-        out.writeBytes(in);
-        ctx.flush();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        ctx.write(msgs);
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/echo/EchoServer.java b/example/src/main/java/io/netty/example/echo/EchoServer.java
index ac6f14398b11..55d8d6b48aec 100644
--- a/example/src/main/java/io/netty/example/echo/EchoServer.java
+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java
@@ -51,7 +51,7 @@ public void run() throws Exception {
                  @Override
                  public void initChannel(SocketChannel ch) throws Exception {
                      ch.pipeline().addLast(
-                             new LoggingHandler(LogLevel.INFO),
+                             //new LoggingHandler(LogLevel.INFO),
                              new EchoServerHandler());
                  }
              });
diff --git a/example/src/main/java/io/netty/example/echo/EchoServerHandler.java b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java
index 4d050b073efa..110af40f70fa 100644
--- a/example/src/main/java/io/netty/example/echo/EchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java
@@ -15,10 +15,10 @@
  */
 package io.netty.example.echo;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -27,16 +27,14 @@
  * Handler implementation for the echo server.
  */
 @Sharable
-public class EchoServerHandler extends ChannelInboundByteHandlerAdapter {
+public class EchoServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             EchoServerHandler.class.getName());
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) {
-        ByteBuf out = ctx.nextOutboundByteBuffer();
-        out.writeBytes(in);
-        ctx.flush();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        ctx.write(msgs);
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java b/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
index 459e842b32c3..8ed01fa4f0fc 100644
--- a/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
+++ b/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java
@@ -16,8 +16,8 @@
 package io.netty.example.factorial;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.CorruptedFrameException;
 
@@ -32,7 +32,7 @@
 public class BigIntegerDecoder extends ByteToMessageDecoder {
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageBuf<Object> out) {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) {
         // Wait until the length prefix is available.
         if (in.readableBytes() < 5) {
             return;
diff --git a/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java b/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
index 6821590b84a6..28fd76e80f72 100644
--- a/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
+++ b/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java
@@ -15,11 +15,11 @@
  */
 package io.netty.example.factorial;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.MessageList;
+import io.netty.channel.SimpleChannelInboundHandler;
 
 import java.math.BigInteger;
 import java.util.concurrent.BlockingQueue;
@@ -34,7 +34,7 @@
  * to create a new handler instance whenever you create a new channel and insert
  * this handler to avoid a race condition.
  */
-public class FactorialClientHandler extends ChannelInboundMessageHandlerAdapter<BigInteger> {
+public class FactorialClientHandler extends SimpleChannelInboundHandler<BigInteger> {
 
     private static final Logger logger = Logger.getLogger(
             FactorialClientHandler.class.getName());
@@ -98,7 +98,7 @@ public void exceptionCaught(
     private void sendNumbers() {
         // Do not send more than 4096 numbers.
         boolean finished = false;
-        MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
+        MessageList<Object> out = MessageList.newInstance(4096);
         while (out.size() < 4096) {
             if (i <= count) {
                 out.add(Integer.valueOf(i));
@@ -109,7 +109,7 @@ private void sendNumbers() {
             }
         }
 
-        ChannelFuture f = ctx.flush();
+        ChannelFuture f = ctx.write(out);
         if (!finished) {
             f.addListener(numberSender);
         }
diff --git a/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java b/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java
index 3cc459268056..a21b765bfab7 100644
--- a/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java
+++ b/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java
@@ -16,7 +16,8 @@
 package io.netty.example.factorial;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.math.BigInteger;
 import java.util.Formatter;
@@ -30,7 +31,7 @@
  * to create a new handler instance whenever you create a new channel and insert
  * this handler  to avoid a race condition.
  */
-public class FactorialServerHandler extends ChannelInboundMessageHandlerAdapter<BigInteger> {
+public class FactorialServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             FactorialServerHandler.class.getName());
@@ -40,11 +41,16 @@ public class FactorialServerHandler extends ChannelInboundMessageHandlerAdapter<
 
     @Override
     public void messageReceived(
-            ChannelHandlerContext ctx, BigInteger msg) throws Exception {
-        // Calculate the cumulative factorial and send it to the client.
-        lastMultiplier = msg;
-        factorial = factorial.multiply(msg);
-        ctx.write(factorial);
+            ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<BigInteger> ints = msgs.cast();
+        for (int i = 0; i < ints.size(); i++) {
+            BigInteger msg = ints.get(i);
+            // Calculate the cumulative factorial and send it to the client.
+            lastMultiplier = msg;
+            factorial = factorial.multiply(msg);
+            ctx.write(factorial);
+        }
+        msgs.recycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/filetransfer/FileServer.java b/example/src/main/java/io/netty/example/filetransfer/FileServer.java
index 8b4a182722c1..efe864a9a769 100644
--- a/example/src/main/java/io/netty/example/filetransfer/FileServer.java
+++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java
@@ -18,15 +18,13 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelProgressiveFuture;
-import io.netty.channel.ChannelProgressiveFutureListener;
-import io.netty.channel.ChannelProgressivePromise;
 import io.netty.channel.DefaultFileRegion;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
@@ -94,35 +92,31 @@ public static void main(String[] args) throws Exception {
         new FileServer(port).run();
     }
 
-    private static final class FileHandler extends ChannelInboundMessageHandlerAdapter<String> {
+    private static final class FileHandler extends ChannelInboundHandlerAdapter {
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
-            File file = new File(msg);
-            if (file.exists()) {
-                if (!file.isFile()) {
-                    ctx.write("Not a file: " + file + '\n');
-                    return;
-                }
-                ctx.write(file + " " + file.length() + '\n');
-                FileRegion region = new DefaultFileRegion(new FileInputStream(file).getChannel(), 0, file.length());
-                ChannelProgressivePromise promise = ctx.newProgressivePromise();
-                promise.addListener(new ChannelProgressiveFutureListener() {
-                    @Override
-                    public void operationProgressed(ChannelProgressiveFuture f, long progress, long total) {
-                        System.err.println("progress: " + progress + " / " + total);
-                    }
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> messages) throws Exception {
+            MessageList<String> msgs = messages.cast();
+            MessageList<Object> out = MessageList.newInstance();
 
-                    @Override
-                    public void operationComplete(ChannelProgressiveFuture future) {
-                        System.err.println("file transfer complete");
+            for (int i = 0; i < msgs.size(); i++) {
+                String msg = msgs.get(i);
+                File file = new File(msg);
+                if (file.exists()) {
+                    if (!file.isFile()) {
+                        ctx.write("Not a file: " + file + '\n');
+                        return;
                     }
-                });
-
-                ctx.sendFile(region, promise);
-                ctx.write("\n");
-            } else {
-                ctx.write("File not found: " + file + '\n');
+                    ctx.write(file + " " + file.length() + '\n');
+                    FileRegion region = new DefaultFileRegion(new FileInputStream(file).getChannel(), 0, file.length());
+                    out.add(region);
+                    out.add("\n");
+                } else {
+                    out.add("File not found: " + file + '\n');
+                }
             }
+
+            msgs.recycle();
+            ctx.write(out);
         }
 
         @Override
diff --git a/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
index e9411ce8fcf0..a460789c1392 100644
--- a/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java
@@ -19,7 +19,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -27,6 +28,7 @@
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedFile;
 import io.netty.util.CharsetUtil;
 
@@ -96,7 +98,7 @@
  *
  * </pre>
  */
-public class HttpStaticFileServerHandler extends ChannelInboundMessageHandlerAdapter<FullHttpRequest> {
+public class HttpStaticFileServerHandler extends ChannelInboundHandlerAdapter {
 
     public static final String HTTP_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss zzz";
     public static final String HTTP_DATE_GMT_TIMEZONE = "GMT";
@@ -104,89 +106,96 @@ public class HttpStaticFileServerHandler extends ChannelInboundMessageHandlerAda
 
     @Override
     public void messageReceived(
-            ChannelHandlerContext ctx, FullHttpRequest request) throws Exception {
-
-        if (!request.getDecoderResult().isSuccess()) {
-            sendError(ctx, BAD_REQUEST);
-            return;
-        }
-
-        if (request.getMethod() != GET) {
-            sendError(ctx, METHOD_NOT_ALLOWED);
-            return;
-        }
-
-        final String uri = request.getUri();
-        final String path = sanitizeUri(uri);
-        if (path == null) {
-            sendError(ctx, FORBIDDEN);
-            return;
-        }
+            ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<FullHttpRequest> requests = msgs.cast();
+        for (int i = 0; i < requests.size(); i++) {
+            FullHttpRequest request = requests.get(i);
+            if (!request.getDecoderResult().isSuccess()) {
+                sendError(ctx, BAD_REQUEST);
+                continue;
+            }
 
-        File file = new File(path);
-        if (file.isHidden() || !file.exists()) {
-            sendError(ctx, NOT_FOUND);
-            return;
-        }
+            if (request.getMethod() != GET) {
+                sendError(ctx, METHOD_NOT_ALLOWED);
+                continue;
+            }
 
-        if (file.isDirectory()) {
-            if (uri.endsWith("/")) {
-                sendListing(ctx, file);
-            } else {
-                sendRedirect(ctx, uri + '/');
+            final String uri = request.getUri();
+            final String path = sanitizeUri(uri);
+            if (path == null) {
+                sendError(ctx, FORBIDDEN);
+                continue;
             }
-            return;
-        }
 
-        if (!file.isFile()) {
-            sendError(ctx, FORBIDDEN);
-            return;
-        }
+            File file = new File(path);
+            if (file.isHidden() || !file.exists()) {
+                sendError(ctx, NOT_FOUND);
+                continue;
+            }
 
-        // Cache Validation
-        String ifModifiedSince = request.headers().get(IF_MODIFIED_SINCE);
-        if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {
-            SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
-            Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);
-
-            // Only compare up to the second because the datetime format we send to the client
-            // does not have milliseconds
-            long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000;
-            long fileLastModifiedSeconds = file.lastModified() / 1000;
-            if (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) {
-                sendNotModified(ctx);
-                return;
+            if (file.isDirectory()) {
+                if (uri.endsWith("/")) {
+                    sendListing(ctx, file);
+                } else {
+                    sendRedirect(ctx, uri + '/');
+                }
+                continue;
             }
-        }
 
-        RandomAccessFile raf;
-        try {
-            raf = new RandomAccessFile(file, "r");
-        } catch (FileNotFoundException fnfe) {
-            sendError(ctx, NOT_FOUND);
-            return;
-        }
-        long fileLength = raf.length();
-
-        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
-        setContentLength(response, fileLength);
-        setContentTypeHeader(response, file);
-        setDateAndCacheHeaders(response, file);
-        if (isKeepAlive(request)) {
-            response.headers().set(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);
-        }
+            if (!file.isFile()) {
+                sendError(ctx, FORBIDDEN);
+                continue;
+            }
 
-        // Write the initial line and the header.
-        ctx.write(response);
+            // Cache Validation
+            String ifModifiedSince = request.headers().get(IF_MODIFIED_SINCE);
+            if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {
+                SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
+                Date ifModifiedSinceDate = dateFormatter.parse(ifModifiedSince);
+
+                // Only compare up to the second because the datetime format we send to the client
+                // does not have milliseconds
+                long ifModifiedSinceDateSeconds = ifModifiedSinceDate.getTime() / 1000;
+                long fileLastModifiedSeconds = file.lastModified() / 1000;
+                if (ifModifiedSinceDateSeconds == fileLastModifiedSeconds) {
+                    sendNotModified(ctx);
+                    continue;
+                }
+            }
 
-        // Write the content.
-        ChannelFuture writeFuture = ctx.write(new ChunkedFile(raf, 0, fileLength, 8192));
+            RandomAccessFile raf;
+            try {
+                raf = new RandomAccessFile(file, "r");
+            } catch (FileNotFoundException fnfe) {
+                sendError(ctx, NOT_FOUND);
+                continue;
+            }
+            long fileLength = raf.length();
+
+            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);
+            setContentLength(response, fileLength);
+            setContentTypeHeader(response, file);
+            setDateAndCacheHeaders(response, file);
+            if (isKeepAlive(request)) {
+                response.headers().set(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);
+            }
 
-        // Decide whether to close the connection or not.
-        if (!isKeepAlive(request)) {
-            // Close the connection when the whole content is written out.
-            writeFuture.addListener(ChannelFutureListener.CLOSE);
+            MessageList<Object> out = MessageList.newInstance();
+            // Write the initial line and the header.
+            out.add(response);
+            // Write the content.
+            out.add(new ChunkedFile(raf, 0, fileLength, 8192));
+            // Write the end marker
+            out.add(LastHttpContent.EMPTY_LAST_CONTENT);
+
+            ChannelFuture writeFuture = ctx.write(out);
+            // Decide whether to close the connection or not.
+            if (!isKeepAlive(request)) {
+                // Close the connection when the whole content is written out.
+                writeFuture.addListener(ChannelFutureListener.CLOSE);
+            }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java
new file mode 100644
index 000000000000..9710600a5373
--- /dev/null
+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.example.http.helloworld;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+
+/**
+ * An HTTP server that sends back the content of the received HTTP request
+ * in a pretty plaintext form.
+ */
+public class HttpHelloWorldServer {
+
+    private final int port;
+
+    public HttpHelloWorldServer(int port) {
+        this.port = port;
+    }
+
+    public void run() throws Exception {
+        // Configure the server.
+        EventLoopGroup bossGroup = new NioEventLoopGroup();
+        EventLoopGroup workerGroup = new NioEventLoopGroup();
+        try {
+            ServerBootstrap b = new ServerBootstrap();
+            b.option(ChannelOption.SO_BACKLOG, 1024);
+            b.group(bossGroup, workerGroup)
+             .channel(NioServerSocketChannel.class)
+             .childHandler(new HttpHelloWorldServerInitializer());
+
+            Channel ch = b.bind(port).sync().channel();
+            ch.closeFuture().sync();
+        } finally {
+            bossGroup.shutdownGracefully();
+            workerGroup.shutdownGracefully();
+        }
+    }
+
+    public static void main(String[] args) throws Exception {
+        int port;
+        if (args.length > 0) {
+            port = Integer.parseInt(args[0]);
+        } else {
+            port = 8080;
+        }
+        new HttpHelloWorldServer(port).run();
+    }
+}
diff --git a/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
new file mode 100644
index 000000000000..50273f3976f5
--- /dev/null
+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.example.http.helloworld;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.util.CharsetUtil;
+
+import static io.netty.handler.codec.http.HttpHeaders.Names.*;
+import static io.netty.handler.codec.http.HttpHeaders.*;
+import static io.netty.handler.codec.http.HttpResponseStatus.*;
+import static io.netty.handler.codec.http.HttpVersion.*;
+
+public class HttpHelloWorldServerHandler extends ChannelInboundHandlerAdapter {
+    private static final ByteBuf CONTENT =
+            Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello World", CharsetUtil.US_ASCII));
+
+    @Override
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<Object> out = MessageList.newInstance();
+        int size = msgs.size();
+        for (int i = 0; i < size; i++) {
+            Object msg = msgs.get(i);
+            if (msg instanceof HttpRequest) {
+                HttpRequest req = (HttpRequest) msg;
+
+                if (is100ContinueExpected(req)) {
+                    out.add(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));
+                }
+                boolean keepAlive = isKeepAlive(req);
+                FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, CONTENT.duplicate());
+                response.headers().set(CONTENT_TYPE, "text/plain");
+                response.headers().set(CONTENT_LENGTH, response.content().readableBytes());
+
+                if (!keepAlive) {
+                    out.add(response);
+                    ctx.write(out).addListener(ChannelFutureListener.CLOSE);
+                    out = MessageList.newInstance();
+                } else {
+                    out.add(response);
+                    response.headers().set(CONNECTION, Values.KEEP_ALIVE);
+                }
+            }
+        }
+        ctx.write(out);
+        msgs.releaseAllAndRecycle();
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+        cause.printStackTrace();
+        ctx.close();
+    }
+}
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerInitializer.java
similarity index 52%
rename from codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java
rename to example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerInitializer.java
index 4f75c0382a12..a1c6bbeaa38e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java
+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerInitializer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -13,15 +13,19 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.handler.codec.spdy;
+package io.netty.example.http.helloworld;
 
-/**
- * The default {@link SpdyNoOpFrame} implementation.
- */
-public class DefaultSpdyNoOpFrame implements SpdyNoOpFrame {
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.handler.codec.http.HttpServerCodec;
 
+public class HttpHelloWorldServerInitializer extends ChannelInitializer<SocketChannel> {
     @Override
-    public String toString() {
-        return getClass().getSimpleName();
+    public void initChannel(SocketChannel ch) throws Exception {
+        ChannelPipeline p = ch.pipeline();
+
+        p.addLast("codec", new HttpServerCodec());
+        p.addLast("handler", new HttpHelloWorldServerHandler());
     }
 }
diff --git a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
index 60f1c641c478..7262fde8d906 100644
--- a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java
@@ -16,49 +16,54 @@
 package io.netty.example.http.snoop;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.util.CharsetUtil;
 
-public class HttpSnoopClientHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+public class HttpSnoopClientHandler extends ChannelInboundHandlerAdapter {
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-        if (msg instanceof HttpResponse) {
-            HttpResponse response = (HttpResponse) msg;
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            Object msg = msgs.get(i);
+            if (msg instanceof HttpResponse) {
+                HttpResponse response = (HttpResponse) msg;
 
-            System.out.println("STATUS: " + response.getStatus());
-            System.out.println("VERSION: " + response.getProtocolVersion());
-            System.out.println();
+                System.out.println("STATUS: " + response.getStatus());
+                System.out.println("VERSION: " + response.getProtocolVersion());
+                System.out.println();
 
-            if (!response.headers().isEmpty()) {
-                for (String name: response.headers().names()) {
-                    for (String value: response.headers().getAll(name)) {
-                        System.out.println("HEADER: " + name + " = " + value);
+                if (!response.headers().isEmpty()) {
+                    for (String name: response.headers().names()) {
+                        for (String value: response.headers().getAll(name)) {
+                            System.out.println("HEADER: " + name + " = " + value);
+                        }
                     }
+                    System.out.println();
                 }
-                System.out.println();
-            }
 
-            if (HttpHeaders.isTransferEncodingChunked(response)) {
-                System.out.println("CHUNKED CONTENT {");
-            } else {
-                System.out.println("CONTENT {");
+                if (HttpHeaders.isTransferEncodingChunked(response)) {
+                    System.out.println("CHUNKED CONTENT {");
+                } else {
+                    System.out.println("CONTENT {");
+                }
             }
-        }
-        if (msg instanceof HttpContent) {
-            HttpContent content = (HttpContent) msg;
+            if (msg instanceof HttpContent) {
+                HttpContent content = (HttpContent) msg;
 
-            System.out.print(content.content().toString(CharsetUtil.UTF_8));
-            System.out.flush();
+                System.out.print(content.content().toString(CharsetUtil.UTF_8));
+                System.out.flush();
 
-            if (content instanceof LastHttpContent) {
-                System.out.println("} END OF CONTENT");
+                if (content instanceof LastHttpContent) {
+                    System.out.println("} END OF CONTENT");
+                }
             }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
index 59c8a2da8bb1..178aebe98409 100644
--- a/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java
@@ -17,9 +17,9 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.http.Cookie;
 import io.netty.handler.codec.http.CookieDecoder;
@@ -44,19 +44,34 @@
 import static io.netty.handler.codec.http.HttpResponseStatus.*;
 import static io.netty.handler.codec.http.HttpVersion.*;
 
-public class HttpSnoopServerHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+public class HttpSnoopServerHandler extends ChannelInboundHandlerAdapter {
 
     private HttpRequest request;
     /** Buffer that stores the response content */
     private final StringBuilder buf = new StringBuilder();
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<Object> out = MessageList.newInstance();
+        int size = msgs.size();
+        try {
+            for (int i = 0; i < size; i ++) {
+                if (!messageReceived(ctx, msgs.get(i), out)) {
+                    break;
+                }
+            }
+        } finally {
+            msgs.releaseAllAndRecycle();
+            ctx.write(out);
+        }
+    }
+
+    private boolean messageReceived(ChannelHandlerContext ctx, Object msg, MessageList<Object> out) {
         if (msg instanceof HttpRequest) {
             HttpRequest request = this.request = (HttpRequest) msg;
 
             if (is100ContinueExpected(request)) {
-                send100Continue(ctx);
+                send100Continue(out);
             }
 
             buf.setLength(0);
@@ -119,9 +134,10 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Except
                     buf.append("\r\n");
                 }
 
-                writeResponse(ctx, trailer);
+                return writeResponse(ctx, trailer, out);
             }
         }
+        return true;
     }
 
     private static void appendDecoderResult(StringBuilder buf, HttpObject o) {
@@ -135,7 +151,7 @@ private static void appendDecoderResult(StringBuilder buf, HttpObject o) {
         buf.append("\r\n");
     }
 
-    private void writeResponse(ChannelHandlerContext ctx, HttpObject currentObj) {
+    private boolean writeResponse(ChannelHandlerContext ctx, HttpObject currentObj, MessageList<Object> out) {
         // Decide whether to close the connection or not.
         boolean keepAlive = isKeepAlive(request);
         // Build the response object.
@@ -170,27 +186,18 @@ private void writeResponse(ChannelHandlerContext ctx, HttpObject currentObj) {
         }
 
         // Write the response.
-        ctx.nextOutboundMessageBuffer().add(response);
+        out.add(response);
 
-        // Close the non-keep-alive connection after the write operation is done.
-        if (!keepAlive) {
-            ctx.flush().addListener(ChannelFutureListener.CLOSE);
-        }
+        return keepAlive;
     }
 
-    private static void send100Continue(ChannelHandlerContext ctx) {
+    private static void send100Continue(MessageList<Object> out) {
         FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, CONTINUE);
-        ctx.nextOutboundMessageBuffer().add(response);
-    }
-
-    @Override
-    public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
-        ctx.flush();
+        out.add(response);
     }
 
     @Override
-    public void exceptionCaught(
-            ChannelHandlerContext ctx, Throwable cause) throws Exception {
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         cause.printStackTrace();
         ctx.close();
     }
diff --git a/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java b/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
index 0c3ee3c258bc..6c70bd6ebd3a 100644
--- a/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java
@@ -16,7 +16,8 @@
 package io.netty.example.http.upload;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpResponse;
@@ -28,50 +29,54 @@
 /**
  * Handler that just dumps the contents of the response from the server
  */
-public class HttpUploadClientHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+public class HttpUploadClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(HttpUploadClientHandler.class.getName());
 
     private boolean readingChunks;
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-        if (msg instanceof HttpResponse) {
-            HttpResponse response = (HttpResponse) msg;
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            Object msg = msgs.get(i);
+            if (msg instanceof HttpResponse) {
+                HttpResponse response = (HttpResponse) msg;
 
-            logger.info("STATUS: " + response.getStatus());
-            logger.info("VERSION: " + response.getProtocolVersion());
+                logger.info("STATUS: " + response.getStatus());
+                logger.info("VERSION: " + response.getProtocolVersion());
 
-            if (!response.headers().isEmpty()) {
-                for (String name : response.headers().names()) {
-                    for (String value : response.headers().getAll(name)) {
-                        logger.info("HEADER: " + name + " = " + value);
+                if (!response.headers().isEmpty()) {
+                    for (String name : response.headers().names()) {
+                        for (String value : response.headers().getAll(name)) {
+                            logger.info("HEADER: " + name + " = " + value);
+                        }
                     }
                 }
-            }
 
-            if (response.getStatus().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
-                readingChunks = true;
-                logger.info("CHUNKED CONTENT {");
-            } else {
-                logger.info("CONTENT {");
+                if (response.getStatus().code() == 200 && HttpHeaders.isTransferEncodingChunked(response)) {
+                    readingChunks = true;
+                    logger.info("CHUNKED CONTENT {");
+                } else {
+                    logger.info("CONTENT {");
+                }
             }
-        }
-        if (msg instanceof HttpContent) {
-            HttpContent chunk = (HttpContent) msg;
-            logger.info(chunk.content().toString(CharsetUtil.UTF_8));
+            if (msg instanceof HttpContent) {
+                HttpContent chunk = (HttpContent) msg;
+                logger.info(chunk.content().toString(CharsetUtil.UTF_8));
 
-            if (chunk instanceof LastHttpContent) {
-                if (readingChunks) {
-                    logger.info("} END OF CHUNKED CONTENT");
+                if (chunk instanceof LastHttpContent) {
+                    if (readingChunks) {
+                        logger.info("} END OF CHUNKED CONTENT");
+                    } else {
+                        logger.info("} END OF CONTENT");
+                    }
+                    readingChunks = false;
                 } else {
-                    logger.info("} END OF CONTENT");
+                    logger.info(chunk.content().toString(CharsetUtil.UTF_8));
                 }
-                readingChunks = false;
-            } else {
-                logger.info(chunk.content().toString(CharsetUtil.UTF_8));
             }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
index 629721399045..63adb8523f6f 100644
--- a/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java
@@ -15,13 +15,13 @@
  */
 package io.netty.example.http.upload;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.Cookie;
 import io.netty.handler.codec.http.CookieDecoder;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
@@ -62,7 +62,7 @@
 import static io.netty.buffer.Unpooled.*;
 import static io.netty.handler.codec.http.HttpHeaders.Names.*;
 
-public class HttpUploadServerHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+public class HttpUploadServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(HttpUploadServerHandler.class.getName());
 
@@ -96,110 +96,114 @@ public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-        if (msg instanceof HttpRequest) {
-            HttpRequest request = this.request = (HttpRequest) msg;
-            URI uri = new URI(request.getUri());
-            if (!uri.getPath().startsWith("/form")) {
-                // Write Menu
-                writeMenu(ctx);
-                return;
-            }
-            responseContent.setLength(0);
-            responseContent.append("WELCOME TO THE WILD WILD WEB SERVER\r\n");
-            responseContent.append("===================================\r\n");
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            Object msg = msgs.get(i);
+            if (msg instanceof HttpRequest) {
+                HttpRequest request = this.request = (HttpRequest) msg;
+                URI uri = new URI(request.getUri());
+                if (!uri.getPath().startsWith("/form")) {
+                    // Write Menu
+                    writeMenu(ctx);
+                    return;
+                }
+                responseContent.setLength(0);
+                responseContent.append("WELCOME TO THE WILD WILD WEB SERVER\r\n");
+                responseContent.append("===================================\r\n");
 
-            responseContent.append("VERSION: " + request.getProtocolVersion().text() + "\r\n");
+                responseContent.append("VERSION: " + request.getProtocolVersion().text() + "\r\n");
 
-            responseContent.append("REQUEST_URI: " + request.getUri() + "\r\n\r\n");
-            responseContent.append("\r\n\r\n");
+                responseContent.append("REQUEST_URI: " + request.getUri() + "\r\n\r\n");
+                responseContent.append("\r\n\r\n");
 
-            // new getMethod
-            List<Entry<String, String>> headers = request.headers().entries();
-            for (Entry<String, String> entry : headers) {
-                responseContent.append("HEADER: " + entry.getKey() + '=' + entry.getValue() + "\r\n");
-            }
-            responseContent.append("\r\n\r\n");
-
-            // new getMethod
-            Set<Cookie> cookies;
-            String value = request.headers().get(COOKIE);
-            if (value == null) {
-                cookies = Collections.emptySet();
-            } else {
-                cookies = CookieDecoder.decode(value);
-            }
-            for (Cookie cookie : cookies) {
-                responseContent.append("COOKIE: " + cookie.toString() + "\r\n");
-            }
-            responseContent.append("\r\n\r\n");
-
-            QueryStringDecoder decoderQuery = new QueryStringDecoder(request.getUri());
-            Map<String, List<String>> uriAttributes = decoderQuery.parameters();
-            for (Entry<String, List<String>> attr: uriAttributes.entrySet()) {
-                for (String attrVal: attr.getValue()) {
-                    responseContent.append("URI: " + attr.getKey() + '=' + attrVal + "\r\n");
+                // new getMethod
+                List<Entry<String, String>> headers = request.headers().entries();
+                for (Entry<String, String> entry : headers) {
+                    responseContent.append("HEADER: " + entry.getKey() + '=' + entry.getValue() + "\r\n");
                 }
-            }
-            responseContent.append("\r\n\r\n");
+                responseContent.append("\r\n\r\n");
 
-            // if GET Method: should not try to create a HttpPostRequestDecoder
-            try {
-                decoder = new HttpPostRequestDecoder(factory, request);
-            } catch (ErrorDataDecoderException e1) {
-                e1.printStackTrace();
-                responseContent.append(e1.getMessage());
-                writeResponse(ctx.channel());
-                ctx.channel().close();
-                return;
-            } catch (IncompatibleDataDecoderException e1) {
-                // GET Method: should not try to create a HttpPostRequestDecoder
-                // So OK but stop here
-                responseContent.append(e1.getMessage());
-                responseContent.append("\r\n\r\nEND OF GET CONTENT\r\n");
-                writeResponse(ctx.channel());
-                return;
-            }
+                // new getMethod
+                Set<Cookie> cookies;
+                String value = request.headers().get(COOKIE);
+                if (value == null) {
+                    cookies = Collections.emptySet();
+                } else {
+                    cookies = CookieDecoder.decode(value);
+                }
+                for (Cookie cookie : cookies) {
+                    responseContent.append("COOKIE: " + cookie.toString() + "\r\n");
+                }
+                responseContent.append("\r\n\r\n");
 
-            readingChunks = HttpHeaders.isTransferEncodingChunked(request);
-            responseContent.append("Is Chunked: " + readingChunks + "\r\n");
-            responseContent.append("IsMultipart: " + decoder.isMultipart() + "\r\n");
-            if (readingChunks) {
-                // Chunk version
-                responseContent.append("Chunks: ");
-                readingChunks = true;
-            }
-        }
+                QueryStringDecoder decoderQuery = new QueryStringDecoder(request.getUri());
+                Map<String, List<String>> uriAttributes = decoderQuery.parameters();
+                for (Entry<String, List<String>> attr: uriAttributes.entrySet()) {
+                    for (String attrVal: attr.getValue()) {
+                        responseContent.append("URI: " + attr.getKey() + '=' + attrVal + "\r\n");
+                    }
+                }
+                responseContent.append("\r\n\r\n");
 
-        // check if the decoder was constructed before
-        // if not it handles the form get
-        if (decoder != null) {
-            if (msg instanceof HttpContent) {
-                // New chunk is received
-                HttpContent chunk = (HttpContent) msg;
+                // if GET Method: should not try to create a HttpPostRequestDecoder
                 try {
-                    decoder.offer(chunk);
+                    decoder = new HttpPostRequestDecoder(factory, request);
                 } catch (ErrorDataDecoderException e1) {
                     e1.printStackTrace();
                     responseContent.append(e1.getMessage());
                     writeResponse(ctx.channel());
                     ctx.channel().close();
                     return;
-                }
-                responseContent.append('o');
-                // example of reading chunk by chunk (minimize memory usage due to
-                // Factory)
-                readHttpDataChunkByChunk();
-                // example of reading only if at the end
-                if (chunk instanceof LastHttpContent) {
-                    readHttpDataAllReceive(ctx.channel());
+                } catch (IncompatibleDataDecoderException e1) {
+                    // GET Method: should not try to create a HttpPostRequestDecoder
+                    // So OK but stop here
+                    responseContent.append(e1.getMessage());
+                    responseContent.append("\r\n\r\nEND OF GET CONTENT\r\n");
                     writeResponse(ctx.channel());
-                    readingChunks = false;
+                    return;
+                }
+
+                readingChunks = HttpHeaders.isTransferEncodingChunked(request);
+                responseContent.append("Is Chunked: " + readingChunks + "\r\n");
+                responseContent.append("IsMultipart: " + decoder.isMultipart() + "\r\n");
+                if (readingChunks) {
+                    // Chunk version
+                    responseContent.append("Chunks: ");
+                    readingChunks = true;
+                }
+            }
 
-                    reset();
+            // check if the decoder was constructed before
+            // if not it handles the form get
+            if (decoder != null) {
+                if (msg instanceof HttpContent) {
+                    // New chunk is received
+                    HttpContent chunk = (HttpContent) msg;
+                    try {
+                        decoder.offer(chunk);
+                    } catch (ErrorDataDecoderException e1) {
+                        e1.printStackTrace();
+                        responseContent.append(e1.getMessage());
+                        writeResponse(ctx.channel());
+                        ctx.channel().close();
+                        return;
+                    }
+                    responseContent.append('o');
+                    // example of reading chunk by chunk (minimize memory usage due to
+                    // Factory)
+                    readHttpDataChunkByChunk();
+                    // example of reading only if at the end
+                    if (chunk instanceof LastHttpContent) {
+                        readHttpDataAllReceive(ctx.channel());
+                        writeResponse(ctx.channel());
+                        readingChunks = false;
+
+                        reset();
+                    }
                 }
             }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     private void reset() {
diff --git a/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
index 301d5f41fc22..c106da74a389 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java
@@ -19,7 +19,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -46,21 +47,28 @@
 /**
  * Handles handshakes and messages
  */
-public class AutobahnServerHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+public class AutobahnServerHandler extends ChannelInboundHandlerAdapter {
     private static final Logger logger = Logger.getLogger(AutobahnServerHandler.class.getName());
 
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-        if (msg instanceof FullHttpRequest) {
-            handleHttpRequest(ctx, (FullHttpRequest) msg);
-        } else if (msg instanceof WebSocketFrame) {
-            handleWebSocketFrame(ctx, (WebSocketFrame) msg);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<Object> out = MessageList.newInstance(msgs.size());
+        for (int i = 0; i < msgs.size(); i++) {
+            Object msg = msgs.get(i);
+            if (msg instanceof FullHttpRequest) {
+                handleHttpRequest(ctx, (FullHttpRequest) msg);
+            } else if (msg instanceof WebSocketFrame) {
+                handleWebSocketFrame(ctx, (WebSocketFrame) msg, out);
+            }
         }
+        msgs.recycle();
+        ctx.write(out);
     }
 
-    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
+    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req)
+            throws Exception {
         // Handle a bad request.
         if (!req.getDecoderResult().isSuccess()) {
             sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));
@@ -84,24 +92,24 @@ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) t
         }
     }
 
-    private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
+    private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame, MessageList<Object> out) {
         if (logger.isLoggable(Level.FINE)) {
             logger.fine(String.format(
                     "Channel %s received %s", ctx.channel().id(), frame.getClass().getSimpleName()));
         }
 
         if (frame instanceof CloseWebSocketFrame) {
-            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
+            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame);
         } else if (frame instanceof PingWebSocketFrame) {
-            ctx.nextOutboundMessageBuffer().add(
-                    new PongWebSocketFrame(frame.isFinalFragment(), frame.rsv(), frame.content().retain()));
+            out.add(new PongWebSocketFrame(frame.isFinalFragment(), frame.rsv(), frame.content()));
         } else if (frame instanceof TextWebSocketFrame) {
-            ctx.nextOutboundMessageBuffer().add(frame.retain());
+            out.add(frame);
         } else if (frame instanceof BinaryWebSocketFrame) {
-            ctx.nextOutboundMessageBuffer().add(frame.retain());
+            out.add(frame);
         } else if (frame instanceof ContinuationWebSocketFrame) {
-            ctx.nextOutboundMessageBuffer().add(frame.retain());
+            out.add(frame);
         } else if (frame instanceof PongWebSocketFrame) {
+            frame.release();
             // Ignore
         } else {
             throw new UnsupportedOperationException(String.format("%s frame types not supported", frame.getClass()
@@ -109,13 +117,6 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
         }
     }
 
-    @Override
-    public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
-        if (handshaker != null) {
-            ctx.flush().addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
-        }
-    }
-
     private static void sendHttpResponse(
             ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) {
         // Generate an error page if response getStatus code is not OK (200).
diff --git a/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
index 82aea00e30d1..d5c271362c76 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java
@@ -40,8 +40,9 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
@@ -50,7 +51,7 @@
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
 import io.netty.util.CharsetUtil;
 
-public class WebSocketClientHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+public class WebSocketClientHandler extends ChannelInboundHandlerAdapter {
 
     private final WebSocketClientHandshaker handshaker;
     private ChannelPromise handshakeFuture;
@@ -79,31 +80,35 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-        Channel ch = ctx.channel();
-        if (!handshaker.isHandshakeComplete()) {
-            handshaker.finishHandshake(ch, (FullHttpResponse) msg);
-            System.out.println("WebSocket Client connected!");
-            handshakeFuture.setSuccess();
-            return;
-        }
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            Object msg = msgs.get(i);
+            Channel ch = ctx.channel();
+            if (!handshaker.isHandshakeComplete()) {
+                handshaker.finishHandshake(ch, (FullHttpResponse) msg);
+                System.out.println("WebSocket Client connected!");
+                handshakeFuture.setSuccess();
+                continue;
+            }
 
-        if (msg instanceof FullHttpResponse) {
-            FullHttpResponse response = (FullHttpResponse) msg;
-            throw new Exception("Unexpected FullHttpResponse (getStatus=" + response.getStatus() + ", content="
-                    + response.content().toString(CharsetUtil.UTF_8) + ')');
-        }
+            if (msg instanceof FullHttpResponse) {
+                FullHttpResponse response = (FullHttpResponse) msg;
+                throw new Exception("Unexpected FullHttpResponse (getStatus=" + response.getStatus() + ", content="
+                        + response.content().toString(CharsetUtil.UTF_8) + ')');
+            }
 
-        WebSocketFrame frame = (WebSocketFrame) msg;
-        if (frame instanceof TextWebSocketFrame) {
-            TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;
-            System.out.println("WebSocket Client received message: " + textFrame.text());
-        } else if (frame instanceof PongWebSocketFrame) {
-            System.out.println("WebSocket Client received pong");
-        } else if (frame instanceof CloseWebSocketFrame) {
-            System.out.println("WebSocket Client received closing");
-            ch.close();
+            WebSocketFrame frame = (WebSocketFrame) msg;
+            if (frame instanceof TextWebSocketFrame) {
+                TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;
+                System.out.println("WebSocket Client received message: " + textFrame.text());
+            } else if (frame instanceof PongWebSocketFrame) {
+                System.out.println("WebSocket Client received pong");
+            } else if (frame instanceof CloseWebSocketFrame) {
+                System.out.println("WebSocket Client received closing");
+                ch.close();
+            }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java b/example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java
index 7ee566d137d8..f3e62a373b9d 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/html5/CustomTextFrameHandler.java
@@ -16,10 +16,10 @@
 package io.netty.example.http.websocketx.html5;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 
-public class CustomTextFrameHandler extends ChannelInboundMessageHandlerAdapter<TextWebSocketFrame> {
+public class CustomTextFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
 
     @Override
     public void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame frame) throws Exception {
diff --git a/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
index 4eb39247abdd..0c6f130502c9 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java
@@ -20,7 +20,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -45,7 +46,7 @@
 /**
  * Handles handshakes and messages
  */
-public class WebSocketServerHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+public class WebSocketServerHandler extends ChannelInboundHandlerAdapter {
     private static final Logger logger = Logger.getLogger(WebSocketServerHandler.class.getName());
 
     private static final String WEBSOCKET_PATH = "/websocket";
@@ -53,12 +54,16 @@ public class WebSocketServerHandler extends ChannelInboundMessageHandlerAdapter<
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-        if (msg instanceof FullHttpRequest) {
-            handleHttpRequest(ctx, (FullHttpRequest) msg);
-        } else if (msg instanceof WebSocketFrame) {
-            handleWebSocketFrame(ctx, (WebSocketFrame) msg);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            Object msg = msgs.get(i);
+            if (msg instanceof FullHttpRequest) {
+                handleHttpRequest(ctx, (FullHttpRequest) msg);
+            } else if (msg instanceof WebSocketFrame) {
+                handleWebSocketFrame(ctx, (WebSocketFrame) msg);
+            }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
@@ -106,13 +111,11 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
 
         // Check for closing frame
         if (frame instanceof CloseWebSocketFrame) {
-            frame.retain();
-            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame);
+            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
             return;
         }
         if (frame instanceof PingWebSocketFrame) {
-            frame.content().retain();
-            ctx.channel().write(new PongWebSocketFrame(frame.content()));
+            ctx.channel().write(new PongWebSocketFrame(frame.content().retain()));
             return;
         }
         if (!(frame instanceof TextWebSocketFrame)) {
diff --git a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
index a49b43eafa71..050dd6200e02 100644
--- a/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
+++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java
@@ -20,7 +20,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.example.http.websocketx.server.WebSocketServerIndexPage;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -46,7 +47,7 @@
 /**
  * Handles handshakes and messages
  */
-public class WebSocketSslServerHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+public class WebSocketSslServerHandler extends ChannelInboundHandlerAdapter {
     private static final Logger logger = Logger.getLogger(WebSocketSslServerHandler.class.getName());
 
     private static final String WEBSOCKET_PATH = "/websocket";
@@ -54,12 +55,16 @@ public class WebSocketSslServerHandler extends ChannelInboundMessageHandlerAdapt
     private WebSocketServerHandshaker handshaker;
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-        if (msg instanceof FullHttpRequest) {
-            handleHttpRequest(ctx, (FullHttpRequest) msg);
-        } else if (msg instanceof WebSocketFrame) {
-            handleWebSocketFrame(ctx, (WebSocketFrame) msg);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            Object msg = msgs.get(i);
+            if (msg instanceof FullHttpRequest) {
+                handleHttpRequest(ctx, (FullHttpRequest) msg);
+            } else if (msg instanceof WebSocketFrame) {
+                handleWebSocketFrame(ctx, (WebSocketFrame) msg);
+            }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {
@@ -108,13 +113,11 @@ private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame fram
 
         // Check for closing frame
         if (frame instanceof CloseWebSocketFrame) {
-            frame.retain();
-            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame);
+            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
             return;
         }
         if (frame instanceof PingWebSocketFrame) {
-            frame.content().retain();
-            ctx.channel().write(new PongWebSocketFrame(frame.content()));
+            ctx.channel().write(new PongWebSocketFrame(frame.content().retain()));
             return;
         }
         if (!(frame instanceof TextWebSocketFrame)) {
diff --git a/example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java b/example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java
index f6129b4ee68a..c10774b64422 100644
--- a/example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java
@@ -16,13 +16,18 @@
 package io.netty.example.localecho;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
+
+public class LocalEchoClientHandler extends ChannelInboundHandlerAdapter {
 
-public class LocalEchoClientHandler extends ChannelInboundMessageHandlerAdapter<String> {
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, String msg) {
-        // Print as received
-        System.out.println(msg);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            // Print as received
+            System.out.println(msgs.get(i));
+        }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java b/example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java
index 40f3d0cfbb68..861e62d01f2e 100644
--- a/example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/localecho/LocalEchoServerHandler.java
@@ -16,14 +16,15 @@
 package io.netty.example.localecho;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
-public class LocalEchoServerHandler extends ChannelInboundMessageHandlerAdapter<String> {
+public class LocalEchoServerHandler extends ChannelInboundHandlerAdapter {
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, String msg) {
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         // Write back as received
-        ctx.write(msg);
+        ctx.write(msgs.copy());
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
index 62acef8dddd8..f4e2869237f1 100644
--- a/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java
@@ -16,7 +16,8 @@
 package io.netty.example.objectecho;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -28,7 +29,7 @@
  * ping-pong traffic between the object echo client and server by sending the
  * first message to the server.
  */
-public class ObjectEchoClientHandler extends ChannelInboundMessageHandlerAdapter<List<Integer>> {
+public class ObjectEchoClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             ObjectEchoClientHandler.class.getName());
@@ -56,9 +57,9 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, List<Integer> msg) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         // Echo back the received object to the server.
-        ctx.write(msg);
+        ctx.write(msgs);
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java b/example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java
index 712da3986a9f..f5f4d2ffc55b 100644
--- a/example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoServerHandler.java
@@ -16,9 +16,9 @@
 package io.netty.example.objectecho;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
-import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
@@ -26,16 +26,16 @@
  * Handles both client-side and server-side handler depending on which
  * constructor was called.
  */
-public class ObjectEchoServerHandler extends ChannelInboundMessageHandlerAdapter<List<Integer>> {
+public class ObjectEchoServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             ObjectEchoServerHandler.class.getName());
 
     @Override
     public void messageReceived(
-            ChannelHandlerContext ctx, List<Integer> msg) throws Exception {
+            ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         // Echo back the received object to the client.
-        ctx.write(msg);
+        ctx.write(msgs);
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java b/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
index 71a0e9305ef2..4594fea6f074 100644
--- a/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
+++ b/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java
@@ -17,13 +17,14 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.example.factorial.BigIntegerDecoder;
 import io.netty.example.factorial.FactorialServerHandler;
 import io.netty.example.factorial.NumberEncoder;
 import io.netty.example.http.snoop.HttpSnoopServerHandler;
 import io.netty.example.securechat.SecureChatSslContextFactory;
+import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.handler.codec.http.HttpContentCompressor;
@@ -37,7 +38,7 @@
  * Manipulates the current pipeline dynamically to switch protocols or enable
  * SSL or GZIP.
  */
-public class PortUnificationServerHandler extends ChannelInboundByteHandlerAdapter {
+public class PortUnificationServerHandler extends ByteToMessageDecoder {
 
     private final boolean detectSsl;
     private final boolean detectGzip;
@@ -52,7 +53,7 @@ private PortUnificationServerHandler(boolean detectSsl, boolean detectGzip) {
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
         // Will use the first five bytes to detect a protocol.
         if (in.readableBytes() < 5) {
             return;
diff --git a/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java b/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
index 614395a56ecb..cb917efd8163 100644
--- a/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java
@@ -15,14 +15,15 @@
  */
 package io.netty.example.proxy;
 
-import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
-public class HexDumpProxyBackendHandler extends ChannelInboundByteHandlerAdapter {
+public class HexDumpProxyBackendHandler extends ChannelInboundHandlerAdapter {
 
     private final Channel inboundChannel;
 
@@ -33,14 +34,12 @@ public HexDumpProxyBackendHandler(Channel inboundChannel) {
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
         ctx.read();
-        ctx.flush();
+        ctx.write(Unpooled.EMPTY_BUFFER);
     }
 
     @Override
-    public void inboundBufferUpdated(final ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-        ByteBuf out = inboundChannel.outboundByteBuffer();
-        out.writeBytes(in);
-        inboundChannel.flush().addListener(new ChannelFutureListener() {
+    public void messageReceived(final ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        inboundChannel.write(msgs).addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future) throws Exception {
                 if (future.isSuccess()) {
diff --git a/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
index ff1a50c6f514..26b83d63dcc0 100644
--- a/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java
@@ -16,16 +16,16 @@
 package io.netty.example.proxy;
 
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelOption;
-import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.channel.MessageList;
 
-public class HexDumpProxyFrontendHandler extends ChannelInboundByteHandlerAdapter {
+public class HexDumpProxyFrontendHandler extends ChannelInboundHandlerAdapter {
 
     private final String remoteHost;
     private final int remotePort;
@@ -44,7 +44,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         // Start the connection attempt.
         Bootstrap b = new Bootstrap();
         b.group(inboundChannel.eventLoop())
-         .channel(NioSocketChannel.class)
+         .channel(ctx.channel().getClass())
          .handler(new HexDumpProxyBackendHandler(inboundChannel))
          .option(ChannelOption.AUTO_READ, false);
         ChannelFuture f = b.connect(remoteHost, remotePort);
@@ -64,11 +64,9 @@ public void operationComplete(ChannelFuture future) throws Exception {
     }
 
     @Override
-    public void inboundBufferUpdated(final ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-        ByteBuf out = outboundChannel.outboundByteBuffer();
-        out.writeBytes(in);
+    public void messageReceived(final ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         if (outboundChannel.isActive()) {
-            outboundChannel.flush().addListener(new ChannelFutureListener() {
+            outboundChannel.write(msgs).addListener(new ChannelFutureListener() {
                 @Override
                 public void operationComplete(ChannelFuture future) throws Exception {
                     if (future.isSuccess()) {
@@ -100,7 +98,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
      */
     static void closeOnFlush(Channel ch) {
         if (ch.isActive()) {
-            ch.flush().addListener(ChannelFutureListener.CLOSE);
+            ch.write(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
         }
     }
 }
diff --git a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
index cd0a4a1c3bc8..640a6a8b1336 100644
--- a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
+++ b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClientHandler.java
@@ -16,21 +16,24 @@
 package io.netty.example.qotm;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.util.CharsetUtil;
 
-public class QuoteOfTheMomentClientHandler extends ChannelInboundMessageHandlerAdapter<DatagramPacket> {
+public class QuoteOfTheMomentClientHandler extends ChannelInboundHandlerAdapter {
 
     @Override
-    public void messageReceived(
-            ChannelHandlerContext ctx, DatagramPacket msg)
-            throws Exception {
-        String response = msg.content().toString(CharsetUtil.UTF_8);
-        if (response.startsWith("QOTM: ")) {
-            System.out.println("Quote of the Moment: " + response.substring(6));
-            ctx.close();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<DatagramPacket> packets = msgs.cast();
+        for (int i = 0; i < packets.size(); i++) {
+            String response = packets.get(i).content().toString(CharsetUtil.UTF_8);
+            if (response.startsWith("QOTM: ")) {
+                System.out.println("Quote of the Moment: " + response.substring(6));
+                ctx.close();
+            }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
index 514030a9ea31..ed0c54c48799 100644
--- a/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
+++ b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentServerHandler.java
@@ -17,13 +17,14 @@
 
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.util.CharsetUtil;
 
 import java.util.Random;
 
-public class QuoteOfTheMomentServerHandler extends ChannelInboundMessageHandlerAdapter<DatagramPacket> {
+public class QuoteOfTheMomentServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Random random = new Random();
 
@@ -44,12 +45,17 @@ private static String nextQuote() {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {
-        System.err.println(msg);
-        if ("QOTM?".equals(msg.content().toString(CharsetUtil.UTF_8))) {
-            ctx.write(new DatagramPacket(
-                    Unpooled.copiedBuffer("QOTM: " + nextQuote(), CharsetUtil.UTF_8), msg.sender()));
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<DatagramPacket> packets = msgs.cast();
+        for (int i = 0; i < packets.size(); i++) {
+            DatagramPacket packet = packets.get(i);
+            System.err.println(packet);
+            if ("QOTM?".equals(packet.content().toString(CharsetUtil.UTF_8))) {
+                ctx.write(new DatagramPacket(
+                        Unpooled.copiedBuffer("QOTM: " + nextQuote(), CharsetUtil.UTF_8), packet.sender()));
+            }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/rxtx/RxtxClientHandler.java b/example/src/main/java/io/netty/example/rxtx/RxtxClientHandler.java
index 01bf057bfdb8..34885c32e4b7 100644
--- a/example/src/main/java/io/netty/example/rxtx/RxtxClientHandler.java
+++ b/example/src/main/java/io/netty/example/rxtx/RxtxClientHandler.java
@@ -16,9 +16,10 @@
 package io.netty.example.rxtx;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
-public class RxtxClientHandler extends ChannelInboundMessageHandlerAdapter<String> {
+public class RxtxClientHandler extends ChannelInboundHandlerAdapter {
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) {
@@ -26,12 +27,16 @@ public void channelActive(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
-        if ("OK".equals(msg)) {
-            System.out.println("Serial port responded to AT");
-        } else {
-            System.out.println("Serial port responded with not-OK: " + msg);
+    public void messageReceived(ChannelHandlerContext ctx,  MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            String msg = msgs.get(i).toString();
+            if ("OK".equals(msg)) {
+                System.out.println("Serial port responded to AT");
+            } else {
+                System.out.println("Serial port responded with not-OK: " + msg);
+            }
         }
+        msgs.releaseAllAndRecycle();
         ctx.close();
     }
 }
diff --git a/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java b/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java
index 341cfa921da1..79ed5b2f14f9 100644
--- a/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java
@@ -16,10 +16,11 @@
 package io.netty.example.sctp;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.sctp.SctpMessage;
 
 import java.util.logging.Level;
@@ -30,7 +31,7 @@
  * traffic between the echo client and server by sending the first message to
  * the server.
  */
-public class SctpEchoClientHandler extends ChannelInboundMessageHandlerAdapter<SctpMessage> {
+public class SctpEchoClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             SctpEchoClientHandler.class.getName());
@@ -56,10 +57,8 @@ public void channelActive(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
-        MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(msg);
-        ctx.flush();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> messages) throws Exception {
+        ctx.write(messages);
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/sctp/SctpEchoServerHandler.java b/example/src/main/java/io/netty/example/sctp/SctpEchoServerHandler.java
index 3b853c739f3f..1972c56bb464 100644
--- a/example/src/main/java/io/netty/example/sctp/SctpEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/sctp/SctpEchoServerHandler.java
@@ -15,11 +15,10 @@
  */
 package io.netty.example.sctp;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
-import io.netty.channel.sctp.SctpMessage;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -28,7 +27,7 @@
  * Handler implementation for the SCTP echo server.
  */
 @Sharable
-public class SctpEchoServerHandler extends ChannelInboundMessageHandlerAdapter<SctpMessage> {
+public class SctpEchoServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             SctpEchoServerHandler.class.getName());
@@ -41,9 +40,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
-        MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(msg);
-        ctx.flush();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        ctx.write(msgs);
     }
 }
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
index 4573fd6c7578..99efe31b7271 100644
--- a/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
+++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java
@@ -16,7 +16,8 @@
 package io.netty.example.securechat;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -24,14 +25,17 @@
 /**
  * Handles a client-side channel.
  */
-public class SecureChatClientHandler extends ChannelInboundMessageHandlerAdapter<String> {
+public class SecureChatClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             SecureChatClientHandler.class.getName());
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
-        System.err.println(msg);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            System.err.println(msgs.get(i));
+        }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
index 1b8b2334e27b..2c2b28ece06b 100644
--- a/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
+++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java
@@ -17,12 +17,14 @@
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
+import io.netty.util.concurrent.GlobalEventExecutor;
 
 import java.net.InetAddress;
 import java.util.logging.Level;
@@ -31,12 +33,12 @@
 /**
  * Handles a server-side channel.
  */
-public class SecureChatServerHandler extends ChannelInboundMessageHandlerAdapter<String> {
+public class SecureChatServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             SecureChatServerHandler.class.getName());
 
-    static final ChannelGroup channels = new DefaultChannelGroup();
+    static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
 
     @Override
     public void channelActive(final ChannelHandlerContext ctx) throws Exception {
@@ -60,21 +62,26 @@ public void operationComplete(Future<Channel> future) throws Exception {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, String request) throws Exception {
-        // Send the received message to all channels but the current one.
-        for (Channel c: channels) {
-            if (c != ctx.channel()) {
-                c.write("[" + ctx.channel().remoteAddress() + "] " +
-                        request + '\n');
-            } else {
-                c.write("[you] " + request + '\n');
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> requests) throws Exception {
+        MessageList<String> msgs = requests.cast();
+        for (int i = 0; i < msgs.size(); i++) {
+            String msg = msgs.get(i);
+            // Send the received message to all channels but the current one.
+            for (Channel c: channels) {
+                if (c != ctx.channel()) {
+                    c.write("[" + ctx.channel().remoteAddress() + "] " +
+                            msg + '\n');
+                } else {
+                    c.write("[you] " + msg + '\n');
+                }
             }
-        }
 
-        // Close the connection if the client has sent 'bye'.
-        if ("bye".equals(request.toLowerCase())) {
-            ctx.close();
+            // Close the connection if the client has sent 'bye'.
+            if ("bye".equals(msg.toLowerCase())) {
+                ctx.close();
+            }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java b/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java
index 06a6a449a3eb..3cd1f7843f00 100644
--- a/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java
@@ -15,12 +15,11 @@
  */
 package io.netty.example.socksproxy;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 
 
-public final class DirectClientHandler extends ChannelInboundByteHandlerAdapter {
+public final class DirectClientHandler extends ChannelInboundHandlerAdapter {
     private static final String name = "DIRECT_CLIENT_HANDLER";
 
     public static String getName() {
@@ -42,8 +41,4 @@ public void channelActive(ChannelHandlerContext ctx) {
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable throwable) throws Exception {
         cb.onFailure(ctx, throwable);
     }
-
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
-    }
 }
diff --git a/example/src/main/java/io/netty/example/socksproxy/RelayHandler.java b/example/src/main/java/io/netty/example/socksproxy/RelayHandler.java
index b148b5d8fb94..c05f2d1494bb 100644
--- a/example/src/main/java/io/netty/example/socksproxy/RelayHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/RelayHandler.java
@@ -15,13 +15,14 @@
  */
 package io.netty.example.socksproxy;
 
-import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 
-public final class RelayHandler extends ChannelInboundByteHandlerAdapter {
+public final class RelayHandler extends ChannelInboundHandlerAdapter {
     private static final String name = "RELAY_HANDLER";
 
     public static String getName() {
@@ -36,15 +37,13 @@ public RelayHandler(Channel relayChannel) {
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
-        ctx.flush();
+        ctx.write(Unpooled.EMPTY_BUFFER);
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-        ByteBuf out = relayChannel.outboundByteBuffer();
-        out.writeBytes(in);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         if (relayChannel.isActive()) {
-            relayChannel.flush();
+            relayChannel.write(msgs);
         }
     }
 
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
index f65dcf80084b..89fb5af1d123 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java
@@ -21,15 +21,15 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.socks.SocksCmdRequest;
 import io.netty.handler.codec.socks.SocksCmdResponse;
 import io.netty.handler.codec.socks.SocksCmdStatus;
 
 @ChannelHandler.Sharable
-public final class SocksServerConnectHandler extends ChannelInboundMessageHandlerAdapter<SocksCmdRequest> {
+public final class SocksServerConnectHandler extends SimpleChannelInboundHandler<SocksCmdRequest> {
     private static final String name = "SOCKS_SERVER_CONNECT_HANDLER";
 
     public static String getName() {
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
index fdba9226d06a..19739f84ba60 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
@@ -17,7 +17,7 @@
 
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.SimpleChannelInboundHandler;
 import io.netty.handler.codec.socks.SocksAuthResponse;
 import io.netty.handler.codec.socks.SocksAuthScheme;
 import io.netty.handler.codec.socks.SocksAuthStatus;
@@ -29,7 +29,7 @@
 
 
 @ChannelHandler.Sharable
-public final class SocksServerHandler extends ChannelInboundMessageHandlerAdapter<SocksRequest> {
+public final class SocksServerHandler extends SimpleChannelInboundHandler<SocksRequest> {
     private static final String name = "SOCKS_SERVER_HANDLER";
 
     public static String getName() {
@@ -56,8 +56,7 @@ public void messageReceived(ChannelHandlerContext ctx, SocksRequest socksRequest
                 if (req.cmdType() == SocksCmdType.CONNECT) {
                     ctx.pipeline().addLast(SocksServerConnectHandler.getName(), new SocksServerConnectHandler());
                     ctx.pipeline().remove(this);
-                    ctx.nextInboundMessageBuffer().add(socksRequest);
-                    ctx.fireInboundBufferUpdated();
+                    ctx.fireMessageReceived(socksRequest);
                 } else {
                     ctx.close();
                 }
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java b/example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java
index 4e0e7b147d29..577b9debbeaa 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerUtils.java
@@ -15,6 +15,7 @@
  */
 package io.netty.example.socksproxy;
 
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFutureListener;
 
@@ -29,7 +30,7 @@ private SocksServerUtils() {
      */
     public static void closeOnFlush(Channel ch) {
         if (ch.isActive()) {
-            ch.flush().addListener(ChannelFutureListener.CLOSE);
+            ch.write(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
         }
     }
 }
diff --git a/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java b/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java
index cfb4b0e51a53..f1ef0ca9d925 100644
--- a/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java
+++ b/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java
@@ -17,7 +17,7 @@
 
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.SimpleChannelInboundHandler;
 
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -26,14 +26,13 @@
  * Handles a client-side channel.
  */
 @Sharable
-public class TelnetClientHandler extends ChannelInboundMessageHandlerAdapter<String> {
+public class TelnetClientHandler extends SimpleChannelInboundHandler<String> {
 
     private static final Logger logger = Logger.getLogger(
             TelnetClientHandler.class.getName());
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
-        // Print out the line received from the server.
+    protected void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
         System.err.println(msg);
     }
 
diff --git a/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java b/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java
index a3bf128c10a2..e871a6d326d0 100644
--- a/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java
+++ b/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java
@@ -19,7 +19,8 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.net.InetAddress;
 import java.util.Date;
@@ -30,7 +31,7 @@
  * Handles a server-side channel.
  */
 @Sharable
-public class TelnetServerHandler extends ChannelInboundMessageHandlerAdapter<String> {
+public class TelnetServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             TelnetServerHandler.class.getName());
@@ -44,28 +45,34 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, String request) throws Exception {
-        // Generate and write a response.
-        String response;
-        boolean close = false;
-        if (request.isEmpty()) {
-            response = "Please type something.\r\n";
-        } else if ("bye".equals(request.toLowerCase())) {
-            response = "Have a good day!\r\n";
-            close = true;
-        } else {
-            response = "Did you say '" + request + "'?\r\n";
-        }
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<String> requests = msgs.cast();
+        for (int i = 0; i < requests.size(); i++) {
+            String request = requests.get(i);
+
+            // Generate and write a response.
+            String response;
+            boolean close = false;
+            if (request.isEmpty()) {
+                response = "Please type something.\r\n";
+            } else if ("bye".equals(request.toLowerCase())) {
+                response = "Have a good day!\r\n";
+                close = true;
+            } else {
+                response = "Did you say '" + request + "'?\r\n";
+            }
 
-        // We do not need to write a ChannelBuffer here.
-        // We know the encoder inserted at TelnetPipelineFactory will do the conversion.
-        ChannelFuture future = ctx.write(response);
+            // We do not need to write a ChannelBuffer here.
+            // We know the encoder inserted at TelnetPipelineFactory will do the conversion.
+            ChannelFuture future = ctx.write(response);
 
-        // Close the connection after sending 'Have a good day!'
-        // if the client has sent 'bye'.
-        if (close) {
-            future.addListener(ChannelFutureListener.CLOSE);
+            // Close the connection after sending 'Have a good day!'
+            // if the client has sent 'bye'.
+            if (close) {
+                future.addListener(ChannelFutureListener.CLOSE);
+            }
         }
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java
index 4e8d401bf315..02681f8912fb 100644
--- a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java
@@ -20,9 +20,8 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
-import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
 import java.util.concurrent.TimeUnit;
@@ -34,7 +33,7 @@
  * traffic between the echo client and server by sending the first message to
  * the server on activation.
  */
-public class ByteEchoClientHandler extends ChannelInboundByteHandlerAdapter {
+public class ByteEchoClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger log = Logger.getLogger(ByteEchoClientHandler.class.getName());
 
@@ -58,13 +57,14 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void inboundBufferUpdated(final ChannelHandlerContext ctx,
-            final ByteBuf in) {
-        meter.mark(in.readableBytes());
-        final ByteBuf out = ctx.nextOutboundByteBuffer();
-        out.discardReadBytes();
-        out.writeBytes(in);
-        ctx.flush();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<ByteBuf> buffers = msgs.cast();
+
+        for (int i = 0; i < buffers.size(); i++) {
+            ByteBuf buf = buffers.get(i);
+            meter.mark(buf.readableBytes());
+        }
+        ctx.write(buffers);
     }
 
     @Override
@@ -74,11 +74,4 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
         ctx.close();
     }
 
-    @Override
-    public ByteBuf newInboundBuffer(final ChannelHandlerContext ctx)
-            throws Exception {
-        return ChannelHandlerUtil.allocate(ctx,
-                ctx.channel().config().getOption(ChannelOption.SO_RCVBUF));
-    }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java
index 1cc16e24a721..af3eebedee4f 100644
--- a/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java
@@ -15,12 +15,10 @@
  */
 package io.netty.example.udt.echo.bytes;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
-import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
 import java.util.logging.Level;
@@ -30,17 +28,13 @@
  * Handler implementation for the echo server.
  */
 @Sharable
-public class ByteEchoServerHandler extends ChannelInboundByteHandlerAdapter {
+public class ByteEchoServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger log = Logger.getLogger(ByteEchoServerHandler.class.getName());
 
     @Override
-    public void inboundBufferUpdated(final ChannelHandlerContext ctx,
-            final ByteBuf in) {
-        final ByteBuf out = ctx.nextOutboundByteBuffer();
-        out.discardReadBytes();
-        out.writeBytes(in);
-        ctx.flush();
+    public void messageReceived(final ChannelHandlerContext ctx, MessageList<Object> msgs) {
+        ctx.write(msgs);
     }
 
     @Override
@@ -55,11 +49,4 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
         log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
     }
 
-    @Override
-    public ByteBuf newInboundBuffer(final ChannelHandlerContext ctx)
-            throws Exception {
-        return ChannelHandlerUtil.allocate(ctx,
-                ctx.channel().config().getOption(ChannelOption.SO_RCVBUF));
-    }
-
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
index 18d6b8825ec6..544a3ff1eadd 100644
--- a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java
@@ -18,10 +18,10 @@
 import com.yammer.metrics.Metrics;
 import com.yammer.metrics.core.Meter;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.udt.UdtMessage;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
@@ -34,8 +34,7 @@
  * traffic between the echo client and server by sending the first message to
  * the server on activation.
  */
-public class MsgEchoClientHandler extends
-        ChannelInboundMessageHandlerAdapter<UdtMessage> {
+public class MsgEchoClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger log = Logger.getLogger(MsgEchoClientHandler.class.getName());
 
@@ -55,9 +54,7 @@ public MsgEchoClientHandler(final int messageSize) {
     @Override
     public void channelActive(final ChannelHandlerContext ctx) throws Exception {
         log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
-        final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(message);
-        ctx.flush();
+        ctx.write(message);
     }
 
     @Override
@@ -68,13 +65,13 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
     }
 
     @Override
-    public void messageReceived(final ChannelHandlerContext ctx,
-            final UdtMessage message) throws Exception {
-        final ByteBuf byteBuf = message.content();
-        meter.mark(byteBuf.readableBytes());
-        final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(message.retain());
-        ctx.flush();
-    }
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<UdtMessage> buffers = msgs.cast();
 
+        for (int i = 0; i < buffers.size(); i++) {
+            UdtMessage message = buffers.get(i);
+            meter.mark(message.content().readableBytes());
+        }
+        ctx.write(msgs);
+    }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
index fa17c441e9e1..b08e471cf0ec 100644
--- a/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java
@@ -15,11 +15,10 @@
  */
 package io.netty.example.udt.echo.message;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
-import io.netty.channel.udt.UdtMessage;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
 import java.util.logging.Level;
@@ -29,8 +28,7 @@
  * Handler implementation for the echo server.
  */
 @Sharable
-public class MsgEchoServerHandler extends
-        ChannelInboundMessageHandlerAdapter<UdtMessage> {
+public class MsgEchoServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger log = Logger.getLogger(MsgEchoServerHandler.class.getName());
 
@@ -47,10 +45,7 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void messageReceived(final ChannelHandlerContext ctx,
-            final UdtMessage message) throws Exception {
-        final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(message.retain());
-        ctx.flush();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        ctx.write(msgs);
     }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java
index 519f1d68de68..7a78961ef44a 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvous/MsgEchoPeerHandler.java
@@ -18,10 +18,10 @@
 import com.yammer.metrics.Metrics;
 import com.yammer.metrics.core.Meter;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.udt.UdtMessage;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
@@ -35,7 +35,7 @@
  * activation.
  */
 public class MsgEchoPeerHandler extends
-        ChannelInboundMessageHandlerAdapter<UdtMessage> {
+        ChannelInboundHandlerAdapter {
 
     private static final Logger log = Logger.getLogger(MsgEchoPeerHandler.class.getName());
 
@@ -55,9 +55,7 @@ public MsgEchoPeerHandler(final int messageSize) {
     @Override
     public void channelActive(final ChannelHandlerContext ctx) throws Exception {
         log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
-        final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(message);
-        ctx.flush();
+        ctx.write(message);
     }
 
     @Override
@@ -68,13 +66,13 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
     }
 
     @Override
-    public void messageReceived(final ChannelHandlerContext ctx,
-            final UdtMessage message) throws Exception {
-        final ByteBuf byteBuf = message.content();
-        meter.mark(byteBuf.readableBytes());
-        final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        out.add(message.retain());
-        ctx.flush();
-    }
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> messages) throws Exception {
+        MessageList<UdtMessage> msgs = messages.cast();
 
+        for (int i = 0; i < msgs.size(); i++) {
+            UdtMessage message = msgs.get(i);
+            meter.mark(message.content().readableBytes());
+        }
+        ctx.write(msgs);
+    }
 }
diff --git a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java
index 9452aa5648a3..3def6e7e0d6e 100644
--- a/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java
+++ b/example/src/main/java/io/netty/example/udt/echo/rendezvousBytes/ByteEchoPeerHandler.java
@@ -20,9 +20,8 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
-import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.udt.nio.NioUdtProvider;
 
 import java.util.concurrent.TimeUnit;
@@ -34,7 +33,7 @@
  * traffic between the echo client and server by sending the first message to
  * the server on activation.
  */
-public class ByteEchoPeerHandler extends ChannelInboundByteHandlerAdapter {
+public class ByteEchoPeerHandler extends ChannelInboundHandlerAdapter {
     private static final Logger log = Logger.getLogger(ByteEchoPeerHandler.class.getName());
     private final ByteBuf message;
 
@@ -48,12 +47,6 @@ public ByteEchoPeerHandler(final int messageSize) {
         }
     }
 
-    @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx,
-                ctx.channel().config().getOption(ChannelOption.SO_RCVBUF));
-    }
-
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
         log.info("ECHO active " + NioUdtProvider.socketUDT(ctx.channel()).toStringOptions());
@@ -67,10 +60,13 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     }
 
     @Override
-    protected void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-        meter.mark(in.readableBytes());
-        final ByteBuf out = ctx.nextOutboundByteBuffer();
-        out.writeBytes(in);
-        ctx.flush();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<ByteBuf> buffers = msgs.cast();
+
+        for (int i = 0; i < buffers.size(); i++) {
+            ByteBuf buf = buffers.get(i);
+            meter.mark(buf.readableBytes());
+        }
+        ctx.write(buffers);
     }
 }
diff --git a/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java b/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
index 3f61a08ce49b..ca36e1502bc7 100644
--- a/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
+++ b/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java
@@ -16,11 +16,11 @@
 package io.netty.example.uptime;
 
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.EventLoop;
+import io.netty.channel.MessageList;
 import io.netty.handler.timeout.IdleState;
 import io.netty.handler.timeout.IdleStateEvent;
 
@@ -32,7 +32,7 @@
  * connection attempt getStatus.
  */
 @Sharable
-public class UptimeClientHandler extends ChannelInboundByteHandlerAdapter {
+public class UptimeClientHandler extends ChannelInboundHandlerAdapter {
 
     private final UptimeClient client;
     private long startTime = -1;
@@ -50,9 +50,9 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         // Discard received data
-        in.clear();
+        msgs.releaseAllAndRecycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java b/example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java
index 865ed9558ae2..6bbcb0f25386 100644
--- a/example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java
+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockClientHandler.java
@@ -17,7 +17,8 @@
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.example.worldclock.WorldClockProtocol.Continent;
 import io.netty.example.worldclock.WorldClockProtocol.LocalTime;
 import io.netty.example.worldclock.WorldClockProtocol.LocalTimes;
@@ -34,7 +35,7 @@
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
 
-public class WorldClockClientHandler extends ChannelInboundMessageHandlerAdapter<LocalTimes> {
+public class WorldClockClientHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             WorldClockClientHandler.class.getName());
@@ -95,8 +96,11 @@ public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, LocalTimes msg) throws Exception {
-        answer.add(msg);
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i++) {
+            answer.add((LocalTimes) msgs.get(i));
+        }
+        msgs.recycle();
     }
 
     @Override
diff --git a/example/src/main/java/io/netty/example/worldclock/WorldClockServerHandler.java b/example/src/main/java/io/netty/example/worldclock/WorldClockServerHandler.java
index d61ada1f19fe..d90e28db8190 100644
--- a/example/src/main/java/io/netty/example/worldclock/WorldClockServerHandler.java
+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockServerHandler.java
@@ -16,7 +16,8 @@
 package io.netty.example.worldclock;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.example.worldclock.WorldClockProtocol.Continent;
 import io.netty.example.worldclock.WorldClockProtocol.DayOfWeek;
 import io.netty.example.worldclock.WorldClockProtocol.LocalTime;
@@ -31,33 +32,41 @@
 
 import static java.util.Calendar.*;
 
-public class WorldClockServerHandler extends ChannelInboundMessageHandlerAdapter<Locations> {
+public class WorldClockServerHandler extends ChannelInboundHandlerAdapter {
 
     private static final Logger logger = Logger.getLogger(
             WorldClockServerHandler.class.getName());
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, Locations locations) throws Exception {
-        long currentTime = System.currentTimeMillis();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        int size = msgs.size();
+        MessageList<Object> out = MessageList.newInstance(size);
+        for (int i = 0; i < size; i++) {
+            Locations locations = (Locations) msgs.get(i);
+            long currentTime = System.currentTimeMillis();
 
-        LocalTimes.Builder builder = LocalTimes.newBuilder();
-        for (Location l: locations.getLocationList()) {
-            TimeZone tz = TimeZone.getTimeZone(
-                    toString(l.getContinent()) + '/' + l.getCity());
-            Calendar calendar = getInstance(tz);
-            calendar.setTimeInMillis(currentTime);
+            LocalTimes.Builder builder = LocalTimes.newBuilder();
+            for (Location l: locations.getLocationList()) {
+                TimeZone tz = TimeZone.getTimeZone(
+                        toString(l.getContinent()) + '/' + l.getCity());
+                Calendar calendar = getInstance(tz);
+                calendar.setTimeInMillis(currentTime);
 
-            builder.addLocalTime(LocalTime.newBuilder().
-                    setYear(calendar.get(YEAR)).
-                    setMonth(calendar.get(MONTH) + 1).
-                    setDayOfMonth(calendar.get(DAY_OF_MONTH)).
-                    setDayOfWeek(DayOfWeek.valueOf(calendar.get(DAY_OF_WEEK))).
-                    setHour(calendar.get(HOUR_OF_DAY)).
-                    setMinute(calendar.get(MINUTE)).
-                    setSecond(calendar.get(SECOND)).build());
+                builder.addLocalTime(LocalTime.newBuilder().
+                        setYear(calendar.get(YEAR)).
+                        setMonth(calendar.get(MONTH) + 1).
+                        setDayOfMonth(calendar.get(DAY_OF_MONTH)).
+                        setDayOfWeek(DayOfWeek.valueOf(calendar.get(DAY_OF_WEEK))).
+                        setHour(calendar.get(HOUR_OF_DAY)).
+                        setMinute(calendar.get(MINUTE)).
+                        setSecond(calendar.get(SECOND)).build());
+            }
+
+            out.add(builder.build());
         }
 
-        ctx.write(builder.build());
+        msgs.recycle();
+        ctx.write(out);
     }
 
     @Override
diff --git a/handler/pom.xml b/handler/pom.xml
index 22b788328fec..c2407bb03810 100644
--- a/handler/pom.xml
+++ b/handler/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-handler</artifactId>
@@ -39,6 +39,11 @@
       <artifactId>netty-transport</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec</artifactId>
+      <version>${project.version}</version>
+    </dependency>
   </dependencies>
   
  </project>
diff --git a/handler/src/main/java/io/netty/handler/logging/ByteLoggingHandler.java b/handler/src/main/java/io/netty/handler/logging/ByteLoggingHandler.java
index dbc288ba106f..3c7aaf34481a 100644
--- a/handler/src/main/java/io/netty/handler/logging/ByteLoggingHandler.java
+++ b/handler/src/main/java/io/netty/handler/logging/ByteLoggingHandler.java
@@ -17,13 +17,11 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundByteHandler;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 
 public class ByteLoggingHandler
-        extends LoggingHandler implements ChannelInboundByteHandler, ChannelOutboundByteHandler {
+        extends LoggingHandler {
 
     private static final String NEWLINE = String.format("%n");
 
@@ -108,45 +106,26 @@ public ByteLoggingHandler(String name) {
     }
 
     @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx);
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        log(ctx, "WRITE", msgs);
+        ctx.write(msgs, promise);
     }
 
     @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        ctx.inboundByteBuffer().discardSomeReadBytes();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        log(ctx, "RECEIVED", msgs);
+        ctx.fireMessageReceived(msgs);
     }
 
-    @Override
-    public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx);
-    }
-
-    @Override
-    public void discardOutboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        ctx.outboundByteBuffer().discardSomeReadBytes();
-    }
-
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx)
-            throws Exception {
-        ByteBuf buf = ctx.inboundByteBuffer();
+    private void log(ChannelHandlerContext ctx, String message, MessageList<Object> msgs) {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, formatBuffer("RECEIVED", buf)));
-        }
-        ctx.nextInboundByteBuffer().writeBytes(buf);
-        ctx.fireInboundBufferUpdated();
-    }
-
-    @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise)
-            throws Exception {
-        ByteBuf buf = ctx.outboundByteBuffer();
-        if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, formatBuffer("WRITE", buf)));
+            for (int i = 0; i < msgs.size(); i++) {
+                Object msg = msgs.get(i);
+                if (msg instanceof ByteBuf) {
+                    logger.log(internalLevel, format(ctx, formatBuffer(message, (ByteBuf) msg)));
+                }
+            }
         }
-        ctx.nextOutboundByteBuffer().writeBytes(buf);
-        ctx.flush(promise);
     }
 
     protected String formatBuffer(String message, ByteBuf buf) {
diff --git a/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
index 145a73fecfd6..f0cefaf059e2 100644
--- a/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java
@@ -15,11 +15,13 @@
  */
 package io.netty.handler.logging;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.util.internal.logging.InternalLogLevel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -35,6 +37,66 @@ public class LoggingHandler extends ChannelDuplexHandler {
 
     private static final LogLevel DEFAULT_LEVEL = LogLevel.DEBUG;
 
+    private static final String NEWLINE = String.format("%n");
+
+    private static final String[] BYTE2HEX = new String[256];
+    private static final String[] HEXPADDING = new String[16];
+    private static final String[] BYTEPADDING = new String[16];
+    private static final char[] BYTE2CHAR = new char[256];
+
+    static {
+        int i;
+
+        // Generate the lookup table for byte-to-hex-dump conversion
+        for (i = 0; i < 10; i ++) {
+            StringBuilder buf = new StringBuilder(3);
+            buf.append(" 0");
+            buf.append(i);
+            BYTE2HEX[i] = buf.toString();
+        }
+        for (; i < 16; i ++) {
+            StringBuilder buf = new StringBuilder(3);
+            buf.append(" 0");
+            buf.append((char) ('a' + i - 10));
+            BYTE2HEX[i] = buf.toString();
+        }
+        for (; i < BYTE2HEX.length; i ++) {
+            StringBuilder buf = new StringBuilder(3);
+            buf.append(' ');
+            buf.append(Integer.toHexString(i));
+            BYTE2HEX[i] = buf.toString();
+        }
+
+        // Generate the lookup table for hex dump paddings
+        for (i = 0; i < HEXPADDING.length; i ++) {
+            int padding = HEXPADDING.length - i;
+            StringBuilder buf = new StringBuilder(padding * 3);
+            for (int j = 0; j < padding; j ++) {
+                buf.append("   ");
+            }
+            HEXPADDING[i] = buf.toString();
+        }
+
+        // Generate the lookup table for byte dump paddings
+        for (i = 0; i < BYTEPADDING.length; i ++) {
+            int padding = BYTEPADDING.length - i;
+            StringBuilder buf = new StringBuilder(padding);
+            for (int j = 0; j < padding; j ++) {
+                buf.append(' ');
+            }
+            BYTEPADDING[i] = buf.toString();
+        }
+
+        // Generate the lookup table for byte-to-char conversion
+        for (i = 0; i < BYTE2CHAR.length; i ++) {
+            if (i <= 0x1f || i >= 0x7f) {
+                BYTE2CHAR[i] = '.';
+            } else {
+                BYTE2CHAR[i] = (char) i;
+            }
+        }
+    }
+
     protected final InternalLogger logger;
     protected final InternalLogLevel internalLevel;
 
@@ -230,19 +292,100 @@ public void deregister(ChannelHandlerContext ctx,
     }
 
     @Override
-    public void read(ChannelHandlerContext ctx) {
-        ctx.read();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        logMessages(ctx, "RECEIVED", msgs);
+        ctx.fireMessageReceived(msgs);
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise)
-            throws Exception {
-        ctx.flush(promise);
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        logMessages(ctx, "WRITE", msgs);
+        ctx.write(msgs, promise);
     }
 
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx)
-            throws Exception {
-        ctx.fireInboundBufferUpdated();
+    private void logMessages(ChannelHandlerContext ctx, String message, MessageList<Object> msgs) {
+        if (logger.isEnabled(internalLevel)) {
+            int size = msgs.size();
+            for (int i = 0; i < size; i ++) {
+                Object msg = msgs.get(i);
+                if (msg instanceof ByteBuf) {
+                    logger.log(internalLevel, format(ctx, formatBuffer(message, (ByteBuf) msg)));
+                } else {
+                    // ignore
+                }
+            }
+        }
+    }
+
+    protected String formatBuffer(String message, ByteBuf buf) {
+        int length = buf.readableBytes();
+        int rows = length / 16 + (length % 15 == 0? 0 : 1) + 4;
+        StringBuilder dump = new StringBuilder(rows * 80 + message.length() + 16);
+
+        dump.append(message).append('(').append(length).append('B').append(')');
+        dump.append(
+                NEWLINE + "         +-------------------------------------------------+" +
+                        NEWLINE + "         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |" +
+                        NEWLINE + "+--------+-------------------------------------------------+----------------+");
+
+        final int startIndex = buf.readerIndex();
+        final int endIndex = buf.writerIndex();
+
+        int i;
+        for (i = startIndex; i < endIndex; i ++) {
+            int relIdx = i - startIndex;
+            int relIdxMod16 = relIdx & 15;
+            if (relIdxMod16 == 0) {
+                dump.append(NEWLINE);
+                dump.append(Long.toHexString(relIdx & 0xFFFFFFFFL | 0x100000000L));
+                dump.setCharAt(dump.length() - 9, '|');
+                dump.append('|');
+            }
+            dump.append(BYTE2HEX[buf.getUnsignedByte(i)]);
+            if (relIdxMod16 == 15) {
+                dump.append(" |");
+                for (int j = i - 15; j <= i; j ++) {
+                    dump.append(BYTE2CHAR[buf.getUnsignedByte(j)]);
+                }
+                dump.append('|');
+            }
+        }
+
+        if ((i - startIndex & 15) != 0) {
+            int remainder = length & 15;
+            dump.append(HEXPADDING[remainder]);
+            dump.append(" |");
+            for (int j = i - remainder; j < i; j ++) {
+                dump.append(BYTE2CHAR[buf.getUnsignedByte(j)]);
+            }
+            dump.append(BYTEPADDING[remainder]);
+            dump.append('|');
+        }
+
+        dump.append(
+                NEWLINE + "+--------+-------------------------------------------------+----------------+");
+
+        return dump.toString();
+    }
+
+    protected String formatBuffer(String message, Object[] msgs, int index, int length) {
+        return message + '(' + length + "): " + contentToString(msgs, index, length);
+    }
+
+    private static String contentToString(Object[] msgs, int index, int length) {
+        if (length == 0) {
+            return "[]";
+        }
+        StringBuilder sb = new StringBuilder();
+        sb.append('[');
+        for (int i = index; i < length; i++) {
+            Object msg = msgs[i];
+            sb.append(msg);
+
+            if (i + 1 < length) {
+                sb.append(", ");
+            }
+        }
+        return sb.append(']').toString();
     }
 }
diff --git a/handler/src/main/java/io/netty/handler/logging/MessageLoggingHandler.java b/handler/src/main/java/io/netty/handler/logging/MessageLoggingHandler.java
index a1a8d431e023..87377a604845 100644
--- a/handler/src/main/java/io/netty/handler/logging/MessageLoggingHandler.java
+++ b/handler/src/main/java/io/netty/handler/logging/MessageLoggingHandler.java
@@ -15,17 +15,11 @@
  */
 package io.netty.handler.logging;
 
-import io.netty.buffer.BufUtil;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 
-public class MessageLoggingHandler
-        extends LoggingHandler
-        implements ChannelInboundMessageHandler<Object>, ChannelOutboundMessageHandler<Object> {
+public class MessageLoggingHandler extends LoggingHandler {
 
     public MessageLoggingHandler() { }
 
@@ -50,54 +44,42 @@ public MessageLoggingHandler(String name) {
     }
 
     @Override
-    public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return Unpooled.messageBuffer();
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs,  ChannelPromise promise) throws Exception {
+        log("WRITE", msgs);
+        ctx.write(msgs);
     }
 
     @Override
-    public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return Unpooled.messageBuffer();
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        log("RECEIVED", msgs);
+        ctx.fireMessageReceived(msgs);
     }
 
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx)
-            throws Exception {
-        MessageBuf<Object> buf = ctx.inboundMessageBuffer();
+    private void log(String message, MessageList<Object> msgs) {
         if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, formatBuffer("RECEIVED", buf)));
+            logger.log(internalLevel, formatBuffer(message, msgs));
         }
+    }
 
-        MessageBuf<Object> out = ctx.nextInboundMessageBuffer();
-        for (;;) {
-            Object o = buf.poll();
-            if (o == null) {
-                break;
-            }
-            out.add(o);
-        }
-        ctx.fireInboundBufferUpdated();
+    protected String formatBuffer(String message, MessageList<Object> msgs) {
+        return message + '(' + msgs.size() + "): " + contentToString(msgs);
     }
 
-    @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise)
-            throws Exception {
-        MessageBuf<Object> buf = ctx.outboundMessageBuffer();
-        if (logger.isEnabled(internalLevel)) {
-            logger.log(internalLevel, format(ctx, formatBuffer("WRITE", buf)));
+    private static String contentToString(MessageList<Object> msgs) {
+        if (msgs.isEmpty()) {
+            return "[]";
         }
+        StringBuilder sb = new StringBuilder();
+        sb.append('[');
+        int size = msgs.size();
+        for (int i = 0; i < size; i++) {
+            Object msg = msgs.get(i);
+            sb.append(msg);
 
-        MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-        for (;;) {
-            Object o = buf.poll();
-            if (o == null) {
-                break;
+            if (i + 1 < size) {
+                sb.append(", ");
             }
-            out.add(o);
         }
-        ctx.flush(promise);
-    }
-
-    protected String formatBuffer(String message, MessageBuf<Object> buf) {
-        return message + '(' + buf.size() + "): " + BufUtil.contentToString(buf);
+        return sb.append(']').toString();
     }
 }
diff --git a/handler/src/main/java/io/netty/handler/ssl/SslHandler.java b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
index 63561a35f82b..60e21e7a447b 100644
--- a/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java
@@ -15,21 +15,19 @@
  */
 package io.netty.handler.ssl;
 
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelDuplexHandler;
-import io.netty.channel.ChannelFlushPromiseNotifier;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelOutboundByteHandler;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
-import io.netty.channel.ChannelStateHandler;
-import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
+import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.util.concurrent.DefaultPromise;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.Future;
@@ -44,13 +42,14 @@
 import javax.net.ssl.SSLEngineResult;
 import javax.net.ssl.SSLEngineResult.Status;
 import javax.net.ssl.SSLException;
-import java.io.EOFException;
 import java.io.IOException;
+import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.DatagramChannel;
 import java.nio.channels.SocketChannel;
-import java.nio.channels.WritableByteChannel;
+import java.util.ArrayDeque;
+import java.util.Queue;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
@@ -71,7 +70,7 @@
  * <p>
  * Beside using the handshake {@link ChannelFuture} to get notified about the completation of the handshake it's
  * also possible to detect it by implement the
- * {@link ChannelStateHandler#userEventTriggered(ChannelHandlerContext, Object)}
+ * {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}
  * method and check for a {@link SslHandshakeCompletionEvent}.
  *
  * <h3>Handshake</h3>
@@ -152,8 +151,8 @@
  * <a href="https://github.com/netty/netty/issues/832">#832</a> in our issue tracker.
  */
 public class SslHandler
-        extends ChannelDuplexHandler
-        implements ChannelInboundByteHandler, ChannelOutboundByteHandler {
+        extends ByteToMessageDecoder
+        implements ChannelOutboundHandler {
 
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(SslHandler.class);
@@ -176,15 +175,14 @@ public class SslHandler
     private volatile ChannelHandlerContext ctx;
     private final SSLEngine engine;
     private final Executor delegatedTaskExecutor;
-    private final ChannelFlushPromiseNotifier flushFutureNotifier = new ChannelFlushPromiseNotifier(true);
 
     private final boolean startTls;
     private boolean sentFirstMessage;
-    private WritableByteChannel bufferChannel;
 
     private final LazyChannelPromise handshakePromise = new LazyChannelPromise();
     private final LazyChannelPromise sslCloseFuture = new LazyChannelPromise();
     private final CloseNotifyListener closeNotifyWriteListener = new CloseNotifyListener();
+    private final Queue<PendingWrite> pendingUnencryptedWrites = new ArrayDeque<PendingWrite>();
 
     private volatile long handshakeTimeoutMillis = 10000;
     private volatile long closeNotifyTimeoutMillis = 3000;
@@ -267,7 +265,7 @@ public void setHandshakeTimeoutMillis(long handshakeTimeoutMillis) {
     }
 
     public long getCloseNotifyTimeoutMillis() {
-        return handshakeTimeoutMillis;
+        return closeNotifyTimeoutMillis;
     }
 
     public void setCloseNotifyTimeout(long closeNotifyTimeout, TimeUnit unit) {
@@ -320,7 +318,7 @@ public void run() {
                 engine.closeOutbound();
                 future.addListener(closeNotifyWriteListener);
                 try {
-                    flush(ctx, future);
+                    write(ctx, MessageList.<Object>newInstance(Unpooled.EMPTY_BUFFER), future);
                 } catch (Exception e) {
                     if (!future.tryFailure(e)) {
                         logger.warn("flush() raised a masked exception.", e);
@@ -345,23 +343,26 @@ public Future<Channel> sslCloseFuture() {
     }
 
     @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx);
+    protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {
+        if (decodeOut != null) {
+            decodeOut.release();
+        }
     }
 
     @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        ctx.inboundByteBuffer().discardSomeReadBytes();
+    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception {
+        ctx.bind(localAddress, promise);
     }
 
     @Override
-    public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx);
+    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress,
+                        ChannelPromise promise) throws Exception {
+        ctx.connect(remoteAddress, localAddress, promise);
     }
 
     @Override
-    public void discardOutboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        ctx.outboundByteBuffer().discardSomeReadBytes();
+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+        ctx.deregister(promise);
     }
 
     @Override
@@ -382,114 +383,146 @@ public void read(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public final void sendFile(ChannelHandlerContext ctx, FileRegion region, ChannelPromise promise) throws Exception {
-        if (bufferChannel == null) {
-            bufferChannel = new BufferChannel(ctx.outboundByteBuffer());
-        }
-        long written = 0;
-        try {
-            for (;;) {
-                long localWritten = region.transferTo(bufferChannel, written);
-                if (localWritten == -1) {
-                    checkEOF(region, written);
-                    flush(ctx, promise);
-                    break;
-                }
-                written += localWritten;
-                if (written >= region.count()) {
-                    flush(ctx, promise);
-                    break;
-                }
-            }
-        } catch (IOException e) {
-            promise.setFailure(e);
-        } finally {
-            region.release();
-        }
-    }
-
-    private static void checkEOF(FileRegion region, long writtenBytes) throws IOException {
-        if (writtenBytes < region.count()) {
-            throw new EOFException("Expected to be able to write "
-                    + region.count() + " bytes, but only wrote "
-                    + writtenBytes);
-        }
-    }
-
-    private static final class BufferChannel implements WritableByteChannel {
-        private final ByteBuf buffer;
-
-        BufferChannel(ByteBuf buffer) {
-            this.buffer = buffer;
-        }
-        @Override
-        public int write(ByteBuffer src) {
-            int bytes = src.remaining();
-            buffer.writeBytes(src);
-            return bytes;
-        }
-
-        @Override
-        public boolean isOpen() {
-            return buffer.refCnt() > 0;
-        }
-
-        @Override
-        public void close() {
-            // NOOP
-        }
-    }
-
-    @Override
-    public void flush(final ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        flush0(ctx, promise, false);
-    }
-
-    private void flush0(ChannelHandlerContext ctx, ChannelPromise promise, boolean internal) throws Exception {
-        final ByteBuf in = ctx.outboundByteBuffer();
-        final ByteBuf out = ctx.nextOutboundByteBuffer();
-
+    public void write(final ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise)
+            throws Exception {
         // Do not encrypt the first write request if this handler is
         // created with startTLS flag turned on.
-        if (!internal && startTls && !sentFirstMessage) {
+        if (startTls && !sentFirstMessage) {
             sentFirstMessage = true;
-            out.writeBytes(in);
-            ctx.flush(promise);
+            ctx.write(msgs, promise);
             return;
         }
-
-        if (ctx.executor() == ctx.channel().eventLoop()) {
-            flushFutureNotifier.add(promise, in.readableBytes());
-        } else {
-            synchronized (flushFutureNotifier) {
-                flushFutureNotifier.add(promise, in.readableBytes());
+        for (int i = 0; i < msgs.size(); i++) {
+            ByteBuf msg = (ByteBuf) msgs.get(i);
+            ChannelPromise cp;
+            if (i + 1 == msgs.size()) {
+                cp = promise;
+            } else {
+                cp = ctx.newPromise();
             }
+            pendingUnencryptedWrites.add(new PendingWrite(msg, cp));
         }
+        flush0(ctx);
+    }
+
+    private void flush0(ChannelHandlerContext ctx) throws SSLException {
 
         boolean unwrapLater = false;
-        int bytesConsumed = 0;
+        PendingWrite pending = null;
+        ByteBuf out = null;
         try {
             for (;;) {
-                SSLEngineResult result = wrap(engine, in, out);
-                bytesConsumed += result.bytesConsumed();
+                if (out == null) {
+                    out = ctx.alloc().buffer();
+                }
+                pending = pendingUnencryptedWrites.peek();
+                if (pending == null) {
+                    break;
+                }
+                SSLEngineResult result = wrap(engine, pending.buf, out);
+
+                if (!pending.buf.isReadable()) {
+                    pending.buf.release();
+                    pendingUnencryptedWrites.remove();
+                }
+
                 if (result.getStatus() == Status.CLOSED) {
                     // SSLEngine has been closed already.
                     // Any further write attempts should be denied.
-                    if (in.isReadable()) {
-                        in.clear();
-                        promise.setFailure(SSLENGINE_CLOSED);
+                    boolean failed = false;
+                    for (;;) {
+                        PendingWrite w = pendingUnencryptedWrites.poll();
+                        if (w == null) {
+                           break;
+                        }
+                        failed = true;
+                        w.fail(SSLENGINE_CLOSED);
+                    }
+                    if (failed) {
                         ctx.fireExceptionCaught(SSLENGINE_CLOSED);
-                        flush0(ctx, bytesConsumed, SSLENGINE_CLOSED);
-                        bytesConsumed = 0;
                     }
-                    break;
+                    return;
                 } else {
                     switch (result.getHandshakeStatus()) {
+                        case NEED_WRAP:
+                            if (!pending.buf.isReadable()) {
+                                ctx.write(out, pending.promise);
+                            } else {
+                                ctx.write(out);
+                            }
+                            out = ctx.alloc().buffer();
+                            continue;
+                        case NEED_UNWRAP:
+                            if (internalBuffer().isReadable()) {
+                                unwrapLater = true;
+                            }
+                            break;
+                        case NEED_TASK:
+                            runDelegatedTasks();
+                            continue;
+                        case FINISHED:
+                            setHandshakeSuccess();
+                            continue;
+                        case NOT_HANDSHAKING:
+                            // Workaround for TLS False Start problem reported at:
+                            // https://github.com/netty/netty/issues/1108#issuecomment-14266970
+                            if (internalBuffer().isReadable()) {
+                                unwrapLater = true;
+                            }
+                            break;
+                        default:
+                            throw new IllegalStateException("Unknown handshake status: " + result.getHandshakeStatus());
+                    }
+
+                    if (result.bytesConsumed() == 0 && result.bytesProduced() == 0) {
+                        break;
+                    }
+                }
+            }
+
+            if (unwrapLater) {
+                decode0(ctx);
+            }
+        } catch (SSLException e) {
+            setHandshakeFailure(e);
+            throw e;
+        } finally {
+            if (out != null && out.isReadable()) {
+                if (pending != null && !pending.buf.isReadable()) {
+                    ctx.write(out, pending.promise);
+                } else {
+                    ctx.write(out);
+                }
+                out = null;
+            } else if (pending != null && !pending.buf.isReadable()) {
+                pending.promise.setSuccess();
+            }
+            if (out != null) {
+                out.release();
+            }
+        }
+    }
+
+    private void flushNonAppData0(ChannelHandlerContext ctx) throws SSLException {
+        boolean unwrapLater = false;
+        ByteBuf out = null;
+        try {
+            for (;;) {
+                if (out == null) {
+                    out = ctx.alloc().buffer();
+                }
+                SSLEngineResult result = wrap(engine, Unpooled.EMPTY_BUFFER, out);
+
+                if (result.bytesProduced() > 0) {
+                    ctx.write(out);
+                    out = null;
+                }
+
+                switch (result.getHandshakeStatus()) {
                     case NEED_WRAP:
-                        ctx.flush();
                         continue;
                     case NEED_UNWRAP:
-                        if (ctx.inboundByteBuffer().isReadable()) {
+                        if (internalBuffer().isReadable()) {
                             unwrapLater = true;
                         }
                         break;
@@ -498,83 +531,38 @@ private void flush0(ChannelHandlerContext ctx, ChannelPromise promise, boolean i
                         continue;
                     case FINISHED:
                         setHandshakeSuccess();
-                        continue;
+                        // try to flush now just in case as there may be pending write tasks
+                        flush0(ctx);
+                        return;
                     case NOT_HANDSHAKING:
                         // Workaround for TLS False Start problem reported at:
                         // https://github.com/netty/netty/issues/1108#issuecomment-14266970
-                        if (ctx.inboundByteBuffer().isReadable()) {
+                        if (internalBuffer().isReadable()) {
                             unwrapLater = true;
                         }
+                        // try to flush now just in case as there may be pending write tasks
+                        flush0(ctx);
                         break;
                     default:
                         throw new IllegalStateException("Unknown handshake status: " + result.getHandshakeStatus());
-                    }
+                }
 
-                    if (result.bytesConsumed() == 0 && result.bytesProduced() == 0) {
-                        break;
-                    }
+                if (result.bytesProduced() == 0) {
+                    break;
                 }
             }
 
             if (unwrapLater) {
-                inboundBufferUpdated(ctx);
+                decode0(ctx);
             }
         } catch (SSLException e) {
             setHandshakeFailure(e);
             throw e;
-        } finally {
-            flush0(ctx, bytesConsumed);
-        }
-    }
-
-    private void flush0(final ChannelHandlerContext ctx, final int bytesConsumed) {
-        ctx.flush(ctx.newPromise().addListener(new ChannelFutureListener() {
-            @Override
-            public void operationComplete(ChannelFuture future) throws Exception {
-                if (ctx.executor() == ctx.channel().eventLoop()) {
-                    notifyFlushFutures(bytesConsumed, future);
-                } else {
-                    synchronized (flushFutureNotifier) {
-                        notifyFlushFutures(bytesConsumed, future);
-                    }
-                }
+        }  finally {
+            if (out != null) {
+                out.release();
             }
-
-            private void notifyFlushFutures(final int bytesConsumed, ChannelFuture future) {
-                if (future.isSuccess()) {
-                    flushFutureNotifier.increaseWriteCounter(bytesConsumed);
-                    flushFutureNotifier.notifyFlushFutures();
-                } else {
-                    flushFutureNotifier.notifyFlushFutures(future.cause());
-                }
-            }
-        }));
-    }
-
-    private void flush0(final ChannelHandlerContext ctx, final int bytesConsumed, final Throwable cause) {
-        ChannelFuture flushFuture = ctx.flush(ctx.newPromise().addListener(new ChannelFutureListener() {
-            @Override
-            public void operationComplete(ChannelFuture future) throws Exception {
-                if (ctx.executor() == ctx.channel().eventLoop()) {
-                    notifyFlushFutures(bytesConsumed, cause, future);
-                } else {
-                    synchronized (flushFutureNotifier) {
-                        notifyFlushFutures(bytesConsumed, cause, future);
-                    }
-                }
-            }
-
-            private void notifyFlushFutures(int bytesConsumed, Throwable cause, ChannelFuture future) {
-                flushFutureNotifier.increaseWriteCounter(bytesConsumed);
-                if (future.isSuccess()) {
-                    flushFutureNotifier.notifyFlushFutures(cause);
-                } else {
-                    flushFutureNotifier.notifyFlushFutures(cause, future.cause());
-                }
-            }
-        }));
-
-        safeClose(ctx, flushFuture, ctx.newPromise());
+        }
     }
 
     private static SSLEngineResult wrap(SSLEngine engine, ByteBuf in, ByteBuf out) throws SSLException {
@@ -597,12 +585,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         // Make sure to release SSLEngine,
         // and notify the handshake future if the connection has been closed during handshake.
         setHandshakeFailure(CHANNEL_CLOSED);
-
-        try {
-            inboundBufferUpdated(ctx);
-        } finally {
-            ctx.fireChannelInactive();
-        }
+        super.channelInactive(ctx);
     }
 
     @Override
@@ -787,8 +770,14 @@ private static int getEncryptedPacketLength(ByteBuf buffer) {
     }
 
     @Override
-    public void inboundBufferUpdated(final ChannelHandlerContext ctx) throws Exception {
-        final ByteBuf in = ctx.inboundByteBuffer();
+    public void decode(final ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {
+        decode0(ctx);
+    }
+
+    private ByteBuf decodeOut;
+
+    private void decode0(final ChannelHandlerContext ctx) throws SSLException {
+        final ByteBuf in = internalBuffer();
 
         if (in.readableBytes() < 5) {
             return;
@@ -799,7 +788,7 @@ public void inboundBufferUpdated(final ChannelHandlerContext ctx) throws Excepti
         if (packetLength == -1) {
             // Bad data - discard the buffer and raise an exception.
             NotSslRecordException e = new NotSslRecordException(
-                    "not an SSL/TLS record: " + BufUtil.hexDump(in));
+                    "not an SSL/TLS record: " + ByteBufUtil.hexDump(in));
             in.skipBytes(in.readableBytes());
             ctx.fireExceptionCaught(e);
             setHandshakeFailure(e);
@@ -808,43 +797,44 @@ public void inboundBufferUpdated(final ChannelHandlerContext ctx) throws Excepti
 
         assert packetLength > 0;
 
-        final ByteBuf out = ctx.nextInboundByteBuffer();
-
         boolean wrapLater = false;
         int bytesProduced = 0;
         try {
             loop:
             for (;;) {
-                SSLEngineResult result = unwrap(engine, in, out);
+                if (decodeOut == null) {
+                    decodeOut = ctx.alloc().buffer();
+                }
+                SSLEngineResult result = unwrap(engine, in, decodeOut);
                 bytesProduced += result.bytesProduced();
 
                 switch (result.getStatus()) {
-                case CLOSED:
-                    // notify about the CLOSED state of the SSLEngine. See #137
-                    sslCloseFuture.trySuccess(ctx.channel());
-                    break;
-                case BUFFER_UNDERFLOW:
-                    break loop;
+                    case CLOSED:
+                        // notify about the CLOSED state of the SSLEngine. See #137
+                        sslCloseFuture.trySuccess(ctx.channel());
+                        break;
+                    case BUFFER_UNDERFLOW:
+                        break loop;
                 }
 
                 switch (result.getHandshakeStatus()) {
-                case NEED_UNWRAP:
-                    break;
-                case NEED_WRAP:
-                    wrapLater = true;
-                    break;
-                case NEED_TASK:
-                    runDelegatedTasks();
-                    break;
-                case FINISHED:
-                    setHandshakeSuccess();
-                    wrapLater = true;
-                    continue;
-                case NOT_HANDSHAKING:
-                    break;
-                default:
-                    throw new IllegalStateException(
-                            "Unknown handshake status: " + result.getHandshakeStatus());
+                    case NEED_UNWRAP:
+                        break;
+                    case NEED_WRAP:
+                        wrapLater = true;
+                        break;
+                    case NEED_TASK:
+                        runDelegatedTasks();
+                        break;
+                    case FINISHED:
+                        setHandshakeSuccess();
+                        wrapLater = true;
+                        continue;
+                    case NOT_HANDSHAKING:
+                        break;
+                    default:
+                        throw new IllegalStateException(
+                                "Unknown handshake status: " + result.getHandshakeStatus());
                 }
 
                 if (result.bytesConsumed() == 0 && result.bytesProduced() == 0) {
@@ -853,14 +843,16 @@ public void inboundBufferUpdated(final ChannelHandlerContext ctx) throws Excepti
             }
 
             if (wrapLater) {
-                flush0(ctx, ctx.newPromise(), true);
+                flushNonAppData0(ctx);
             }
         } catch (SSLException e) {
             setHandshakeFailure(e);
             throw e;
         } finally {
             if (bytesProduced > 0) {
-                ctx.fireInboundBufferUpdated();
+                ByteBuf decodeOut = this.decodeOut;
+                this.decodeOut = null;
+                ctx.fireMessageReceived(decodeOut);
             }
         }
     }
@@ -935,9 +927,14 @@ private void setHandshakeFailure(Throwable cause) {
                 // closeInbound() will raise an exception with bogus truncation attack warning.
             }
         }
-
         notifyHandshakeFailure(cause);
-        flush0(ctx, 0, cause);
+        for (;;) {
+            PendingWrite write = pendingUnencryptedWrites.poll();
+            if (write == null) {
+                break;
+            }
+            write.fail(cause);
+        }
     }
 
     private void notifyHandshakeFailure(Throwable cause) {
@@ -961,7 +958,7 @@ private void closeOutboundAndChannel(
         engine.closeOutbound();
 
         ChannelPromise closeNotifyFuture = ctx.newPromise().addListener(closeNotifyWriteListener);
-        flush0(ctx, closeNotifyFuture, true);
+        write(ctx, MessageList.<Object>newInstance(Unpooled.EMPTY_BUFFER), closeNotifyFuture);
         safeClose(ctx, closeNotifyFuture, promise);
     }
 
@@ -970,7 +967,7 @@ public void handlerAdded(final ChannelHandlerContext ctx) throws Exception {
         this.ctx = ctx;
 
         if (ctx.channel().isActive()) {
-            // channelActvie() event has been fired already, which means this.channelActive() will
+            // channelActive() event has been fired already, which means this.channelActive() will
             // not be invoked. We have to initialize here instead.
             handshake0();
         } else {
@@ -1005,7 +1002,7 @@ public void operationComplete(Future<Channel> f) throws Exception {
         });
         try {
             engine.beginHandshake();
-            flush0(ctx, ctx.newPromise(), true);
+            flushNonAppData0(ctx);
         } catch (Exception e) {
             notifyHandshakeFailure(e);
         }
@@ -1024,6 +1021,7 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
                 @Override
                 public void operationComplete(Future<Channel> future) throws Exception {
                     if (!future.isSuccess()) {
+                        future.cause().printStackTrace();
                         ctx.close();
                     }
                 }
@@ -1031,7 +1029,6 @@ public void operationComplete(Future<Channel> future) throws Exception {
         }
         ctx.fireChannelActive();
     }
-
     private void safeClose(
             final ChannelHandlerContext ctx, ChannelFuture flushFuture,
             final ChannelPromise promise) {
@@ -1072,7 +1069,7 @@ public void operationComplete(ChannelFuture f)
     }
 
     private static final class CloseNotifyListener implements ChannelFutureListener {
-        volatile boolean done;
+        boolean done;
 
         @Override
         public void operationComplete(ChannelFuture future) throws Exception {
@@ -1095,4 +1092,18 @@ protected EventExecutor executor() {
             return ctx.executor();
         }
     }
+
+    private static final class PendingWrite {
+        final ByteBuf buf;
+        final ChannelPromise promise;
+        PendingWrite(ByteBuf buf, ChannelPromise promise) {
+            this.buf = buf;
+            this.promise = promise;
+        }
+
+        void fail(Throwable cause) {
+            buf.release();
+            promise.setFailure(cause);
+        }
+    }
 }
diff --git a/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java
index b2fca7be39a8..52a534a625ca 100644
--- a/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java
+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.stream;
 
-import io.netty.buffer.MessageBuf;
+import io.netty.channel.MessageList;
 
 import java.util.Queue;
 
@@ -23,6 +23,6 @@
  * {@link ChunkedInput} which reads its chunks and transfer it to a {@link Queue}
  *
  */
-public interface ChunkedMessageInput<T> extends ChunkedInput<MessageBuf<T>> {
+public interface ChunkedMessageInput<T> extends ChunkedInput<MessageList<T>> {
 
 }
diff --git a/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
index 99dd761c378a..03d819e6e96f 100644
--- a/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.stream;
 
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelDuplexHandler;
@@ -23,14 +23,15 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.nio.channels.ClosedChannelException;
+import java.util.ArrayDeque;
+import java.util.Queue;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
@@ -65,12 +66,12 @@
  * call {@link #resumeTransfer()}.
  */
 public class ChunkedWriteHandler
-        extends ChannelDuplexHandler implements ChannelOutboundMessageHandler<Object> {
+        extends ChannelDuplexHandler {
 
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(ChunkedWriteHandler.class);
 
-    private final MessageBuf<Object> queue = Unpooled.messageBuffer();
+    private final Queue<Object> queue = new ArrayDeque<Object>();
     private final int maxPendingWrites;
     private volatile ChannelHandlerContext ctx;
     private final AtomicInteger pendingWrites = new AtomicInteger();
@@ -88,11 +89,6 @@ public ChunkedWriteHandler(int maxPendingWrites) {
         this.maxPendingWrites = maxPendingWrites;
     }
 
-    @Override
-    public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return queue;
-    }
-
     @Override
     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
         this.ctx = ctx;
@@ -142,18 +138,17 @@ public void read(ChannelHandlerContext ctx) {
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        for (int i = 0; i  < msgs.size(); i++) {
+            queue.add(msgs.get(i));
+        }
+        msgs.recycle();
         queue.add(promise);
         if (isWritable() || !ctx.channel().isActive()) {
             doFlush(ctx);
         }
     }
 
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        ctx.fireInboundBufferUpdated();
-    }
-
     @Override
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         doFlush(ctx);
@@ -213,6 +208,7 @@ private void doFlush(final ChannelHandlerContext ctx) throws Exception {
             discard(ctx, null);
             return;
         }
+        MessageList<Object> messages = MessageList.newInstance();
         while (isWritable()) {
             if (currentEvent == null) {
                 currentEvent = queue.poll();
@@ -225,14 +221,16 @@ private void doFlush(final ChannelHandlerContext ctx) throws Exception {
             final Object currentEvent = this.currentEvent;
             if (currentEvent instanceof ChannelPromise) {
                 this.currentEvent = null;
-                ctx.flush((ChannelPromise) currentEvent);
+                ctx.write(messages, (ChannelPromise) currentEvent);
+                messages = MessageList.newInstance();
             } else if (currentEvent instanceof ChunkedInput) {
+                MessageList<Object> out = MessageList.newInstance();
                 final ChunkedInput<?> chunks = (ChunkedInput<?>) currentEvent;
                 boolean read;
                 boolean endOfInput;
                 boolean suspend;
                 try {
-                    read = readChunk(ctx, chunks);
+                    read = readChunk(ctx, chunks, out);
                     endOfInput = chunks.isEndOfInput();
 
                     if (!read) {
@@ -267,7 +265,7 @@ public void run() {
                 }
 
                 pendingWrites.incrementAndGet();
-                ChannelFuture f = ctx.flush();
+                ChannelFuture f = ctx.write(out);
                 if (endOfInput) {
                     this.currentEvent = null;
 
@@ -307,7 +305,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                     });
                 }
             } else {
-                ChannelHandlerUtil.addToNextOutboundBuffer(ctx, currentEvent);
+                ctx.write(currentEvent);
                 this.currentEvent = null;
             }
 
@@ -326,11 +324,16 @@ public void operationComplete(ChannelFuture future) throws Exception {
      * @throws Exception    if something goes wrong
      */
     @SuppressWarnings("unchecked")
-    protected boolean readChunk(ChannelHandlerContext ctx, ChunkedInput<?> chunks) throws Exception {
+    protected boolean readChunk(
+            @SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx,
+            ChunkedInput<?> chunks, MessageList<Object> out) throws Exception {
         if (chunks instanceof ChunkedByteInput) {
-            return ((ChunkedByteInput) chunks).readChunk(ctx.nextOutboundByteBuffer());
+            ByteBuf buf = Unpooled.buffer();
+            boolean done = ((ChunkedByteInput) chunks).readChunk(buf);
+            out.add(buf);
+            return done;
         } else if (chunks instanceof ChunkedMessageInput) {
-            return ((ChunkedMessageInput<Object>) chunks).readChunk(ctx.nextOutboundMessageBuffer());
+            return ((ChunkedMessageInput<Object>) chunks).readChunk(out);
         } else {
             throw new IllegalArgumentException("ChunkedInput instance " + chunks + " not supported");
         }
diff --git a/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
index 5ccf79480994..0afd0c9c05f1 100644
--- a/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
@@ -21,12 +21,12 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOperationHandler;
+import io.netty.channel.ChannelOutboundHandler;
 import io.netty.channel.ChannelPromise;
-import io.netty.channel.ChannelStateHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.util.concurrent.EventExecutor;
-import io.netty.channel.FileRegion;
 
 import java.net.SocketAddress;
 import java.util.concurrent.ScheduledFuture;
@@ -98,7 +98,7 @@
  * @see ReadTimeoutHandler
  * @see WriteTimeoutHandler
  */
-public class IdleStateHandler extends ChannelStateHandlerAdapter implements ChannelOperationHandler {
+public class IdleStateHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandler {
 
     private final long readerIdleTimeMillis;
     private final long writerIdleTimeMillis;
@@ -251,10 +251,10 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         lastReadTime = System.currentTimeMillis();
         firstReaderIdleEvent = firstAllIdleEvent = true;
-        ctx.fireInboundBufferUpdated();
+        ctx.fireMessageReceived(msgs);
     }
 
     @Override
@@ -263,8 +263,7 @@ public void read(ChannelHandlerContext ctx) {
     }
 
     @Override
-
-    public void flush(final ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
         promise.addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future) throws Exception {
@@ -272,8 +271,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                 firstWriterIdleEvent = firstAllIdleEvent = true;
             }
         });
-
-        ctx.flush(promise);
+        ctx.write(msgs, promise);
     }
 
     @Override
@@ -302,18 +300,6 @@ public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws
         ctx.deregister(promise);
     }
 
-    @Override
-    public void sendFile(ChannelHandlerContext ctx, FileRegion region, ChannelPromise promise) throws Exception {
-        promise.addListener(new ChannelFutureListener() {
-            @Override
-            public void operationComplete(ChannelFuture future) throws Exception {
-                lastWriteTime = System.currentTimeMillis();
-                firstWriterIdleEvent = firstAllIdleEvent = true;
-            }
-        });
-        ctx.sendFile(region, promise);
-    }
-
     private void initialize(ChannelHandlerContext ctx) {
         // Avoid the case where destroy() is called before scheduling timeouts.
         // See: https://github.com/netty/netty/issues/143
diff --git a/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
index 687445163ecb..0327906107a9 100644
--- a/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java
@@ -19,8 +19,9 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelStateHandlerAdapter;
+import io.netty.channel.MessageList;
 
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
@@ -61,7 +62,7 @@
  * @see WriteTimeoutHandler
  * @see IdleStateHandler
  */
-public class ReadTimeoutHandler extends ChannelStateHandlerAdapter {
+public class ReadTimeoutHandler extends ChannelInboundHandlerAdapter {
 
     private final long timeoutMillis;
 
@@ -144,9 +145,9 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
         lastReadTime = System.currentTimeMillis();
-        ctx.fireInboundBufferUpdated();
+        ctx.fireMessageReceived(msgs);
     }
 
     private void initialize(ChannelHandlerContext ctx) {
diff --git a/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
index a43d12feaeb7..c5f85f03becd 100644
--- a/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
+++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java
@@ -22,9 +22,9 @@
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOperationHandlerAdapter;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
-import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
 
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
@@ -65,7 +65,7 @@
  * @see ReadTimeoutHandler
  * @see IdleStateHandler
  */
-public class WriteTimeoutHandler extends ChannelOperationHandlerAdapter {
+public class WriteTimeoutHandler extends ChannelOutboundHandlerAdapter {
 
     private final long timeoutMillis;
 
@@ -102,15 +102,9 @@ public WriteTimeoutHandler(long timeout, TimeUnit unit) {
     }
 
     @Override
-    public void flush(final ChannelHandlerContext ctx, final ChannelPromise promise) throws Exception {
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
         scheduleTimeout(ctx, promise);
-        ctx.flush(promise);
-    }
-
-    @Override
-    public void sendFile(ChannelHandlerContext ctx, FileRegion region, ChannelPromise promise) throws Exception {
-        scheduleTimeout(ctx, promise);
-        super.sendFile(ctx, region, promise);
+        super.write(ctx, msgs, promise);
     }
 
     private void scheduleTimeout(final ChannelHandlerContext ctx, final ChannelPromise future) {
diff --git a/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
index 1166c407a525..b748e36c6975 100644
--- a/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
+++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
 
@@ -74,7 +75,6 @@ public abstract class AbstractTrafficShapingHandler extends ChannelDuplexHandler
 
     private static final AttributeKey<Boolean> READ_SUSPENDED = new AttributeKey<Boolean>("readSuspended");
     private static final AttributeKey<Runnable> REOPEN_TASK = new AttributeKey<Runnable>("reopenTask");
-    private static final AttributeKey<Runnable> BUFFER_UPDATE_TASK = new AttributeKey<Runnable>("bufferUpdateTask");
 
     /**
      *
@@ -210,25 +210,27 @@ private static long getTimeToWait(long limit, long bytes, long lastTime, long cu
     }
 
     @Override
-    public void inboundBufferUpdated(final ChannelHandlerContext ctx) throws Exception {
-        ByteBuf buf = ctx.nextInboundByteBuffer();
-
+    public void messageReceived(final ChannelHandlerContext ctx, final MessageList<Object> msgs) throws Exception {
+        MessageList<ByteBuf> buffers = msgs.cast();
+        long size = 0;
+        for (int i = 0; i < buffers.size(); i++) {
+           size += buffers.get(i).readableBytes();
+        }
         long curtime = System.currentTimeMillis();
-        long size = buf.readableBytes();
 
         if (trafficCounter != null) {
             trafficCounter.bytesRecvFlowControl(size);
             if (readLimit == 0) {
                 // no action
-                ctx.fireInboundBufferUpdated();
+                ctx.fireMessageReceived(msgs);
 
                 return;
             }
 
             // compute the number of ms to wait before reopening the channel
             long wait = getTimeToWait(readLimit,
-                                      trafficCounter.currentReadBytes(),
-                                      trafficCounter.lastTime(), curtime);
+                    trafficCounter.currentReadBytes(),
+                    trafficCounter.lastTime(), curtime);
             if (wait >= MINIMAL_WAIT) { // At least 10ms seems a minimal
                 // time in order to
                 // try to limit the traffic
@@ -244,45 +246,45 @@ public void inboundBufferUpdated(final ChannelHandlerContext ctx) throws Excepti
                         attr.set(reopenTask);
                     }
                     ctx.executor().schedule(reopenTask, wait,
-                                                   TimeUnit.MILLISECONDS);
+                            TimeUnit.MILLISECONDS);
                 } else {
                     // Create a Runnable to update the next handler in the chain. If one was create before it will
                     // just be reused to limit object creation
-                    Attribute<Runnable> attr  = ctx.attr(BUFFER_UPDATE_TASK);
-                    Runnable bufferUpdateTask = attr.get();
-                    if (bufferUpdateTask == null) {
-                        bufferUpdateTask = new Runnable() {
-                            @Override
-                            public void run() {
-                                ctx.fireInboundBufferUpdated();
-                            }
-                        };
-                        attr.set(bufferUpdateTask);
-                    }
+                    Runnable bufferUpdateTask = new Runnable() {
+                        @Override
+                        public void run() {
+                            ctx.fireMessageReceived(msgs);
+                        }
+                    };
                     ctx.executor().schedule(bufferUpdateTask, wait, TimeUnit.MILLISECONDS);
                     return;
                 }
             }
         }
-        ctx.fireInboundBufferUpdated();
+        ctx.fireMessageReceived(msgs);
     }
 
     @Override
     public void read(ChannelHandlerContext ctx) {
-        if (!ctx.attr(READ_SUSPENDED).get()) {
+        Boolean suspended = ctx.attr(READ_SUSPENDED).get();
+        if (suspended == null || Boolean.FALSE.equals(suspended)) {
             ctx.read();
         }
     }
 
     @Override
-    public void flush(final ChannelHandlerContext ctx, final ChannelPromise promise) throws Exception {
+    public void write(final ChannelHandlerContext ctx, final MessageList<Object> msgs, final ChannelPromise promise)
+            throws Exception {
         long curtime = System.currentTimeMillis();
-        long size = ctx.nextOutboundByteBuffer().readableBytes();
+        long size = 0;
+        for (int i = 0; i < msgs.size(); i++) {
+            size += ((ByteBuf) msgs.get(i)).readableBytes();
+        }
 
         if (trafficCounter != null) {
             trafficCounter.bytesWriteFlowControl(size);
             if (writeLimit == 0) {
-                ctx.flush(promise);
+                ctx.write(msgs, promise);
                 return;
             }
             // compute the number of ms to wait before continue with the
@@ -294,13 +296,13 @@ public void flush(final ChannelHandlerContext ctx, final ChannelPromise promise)
                 ctx.executor().schedule(new Runnable() {
                     @Override
                     public void run() {
-                        ctx.flush(promise);
+                        ctx.write(msgs, promise);
                     }
                 }, wait, TimeUnit.MILLISECONDS);
                 return;
             }
         }
-        ctx.flush(promise);
+        ctx.write(msgs, promise);
     }
 
     /**
diff --git a/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
index 99990f723168..6c5fef1c8785 100644
--- a/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
+++ b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
@@ -16,12 +16,11 @@
 package io.netty.handler.stream;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.embedded.EmbeddedByteChannel;
-import io.netty.channel.embedded.EmbeddedMessageChannel;
+import io.netty.channel.MessageList;
+import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.util.CharsetUtil;
 import org.junit.Test;
 import java.io.ByteArrayInputStream;
@@ -135,9 +134,8 @@ public void operationComplete(ChannelFuture future) throws Exception {
             }
         };
 
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new ChunkedWriteHandler());
-        ch.outboundMessageBuffer().add(input);
-        ch.flush().addListener(listener).syncUninterruptibly();
+        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
+        ch.write(input).addListener(listener).syncUninterruptibly();
         ch.checkException();
         ch.finish();
 
@@ -165,7 +163,7 @@ public void close() throws Exception {
             }
 
             @Override
-            public boolean readChunk(MessageBuf<Object> buffer) throws Exception {
+            public boolean readChunk(MessageList<Object> buffer) throws Exception {
                 if (done) {
                     return false;
                 }
@@ -175,9 +173,8 @@ public boolean readChunk(MessageBuf<Object> buffer) throws Exception {
             }
         };
 
-        EmbeddedMessageChannel ch = new EmbeddedMessageChannel(new ChunkedWriteHandler());
-        ch.outboundMessageBuffer().add(input);
-        ch.flush().syncUninterruptibly();
+        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
+        ch.write(input).syncUninterruptibly();
         ch.checkException();
         assertTrue(ch.finish());
 
@@ -186,7 +183,7 @@ public boolean readChunk(MessageBuf<Object> buffer) throws Exception {
     }
 
     private static void check(ChunkedInput<?>... inputs) {
-        EmbeddedByteChannel ch = new EmbeddedByteChannel(new ChunkedWriteHandler());
+        EmbeddedChannel ch = new EmbeddedChannel(new ChunkedWriteHandler());
 
         for (ChunkedInput<?> input: inputs) {
             ch.writeOutbound(input);
@@ -197,7 +194,7 @@ private static void check(ChunkedInput<?>... inputs) {
         int i = 0;
         int read = 0;
         for (;;) {
-            ByteBuf buffer = ch.readOutbound();
+            ByteBuf buffer = (ByteBuf) ch.readOutbound();
             if (buffer == null) {
                 break;
             }
diff --git a/microbench/pom.xml b/microbench/pom.xml
index 3405e4508381..d7689ab4f5fd 100644
--- a/microbench/pom.xml
+++ b/microbench/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-microbench</artifactId>
diff --git a/pom.xml b/pom.xml
index 7ed16c3076ba..a9cbed9309cb 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>io.netty</groupId>
   <artifactId>netty-parent</artifactId>
   <packaging>pom</packaging>
-  <version>4.0.0.CR3</version>
+  <version>4.0.0.CR4</version>
 
   <name>Netty</name>
   <url>http://netty.io/</url>
@@ -53,7 +53,7 @@
     <url>https://github.com/netty/netty</url>
     <connection>scm:git:git://github.com/netty/netty.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/netty/netty.git</developerConnection>
-    <tag>netty-4.0.0.CR3</tag>
+    <tag>netty-4.0.0.CR4</tag>
   </scm>
 
   <developers>
@@ -73,7 +73,6 @@
     <jboss.marshalling.version>1.3.17.GA</jboss.marshalling.version>
     <test.jvm.argLine>
       -server 
-      -Dio.netty.resourceLeakDetection
       -dsa -da -ea:io.netty...
       -XX:+AggressiveOpts
       -XX:+TieredCompilation
@@ -156,12 +155,12 @@
       <dependency>
         <groupId>org.slf4j</groupId>
         <artifactId>slf4j-api</artifactId>
-        <version>1.7.4</version>
+        <version>1.7.5</version>
       </dependency>
       <dependency>
         <groupId>commons-logging</groupId>
         <artifactId>commons-logging</artifactId>
-        <version>1.1.1</version>
+        <version>1.1.3</version>
       </dependency>
       <dependency>
         <groupId>log4j</groupId>
@@ -255,7 +254,7 @@
     <dependency>
       <groupId>ch.qos.logback</groupId>
       <artifactId>logback-classic</artifactId>
-      <version>1.0.10</version>
+      <version>1.0.13</version>
       <scope>test</scope>
     </dependency>
   </dependencies>
@@ -447,7 +446,7 @@
       </plugin>
       <plugin>
         <artifactId>maven-release-plugin</artifactId>
-        <version>2.4</version>
+        <version>2.4.1</version>
         <configuration>
           <useReleaseProfile>false</useReleaseProfile>
           <arguments>-P release,sonatype-oss-release,full,no-osgi</arguments>
@@ -464,12 +463,12 @@
         <!-- keep surefire and failsafe in sync -->
         <plugin>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.14</version>
+          <version>2.15</version>
         </plugin>
         <!-- keep surefire and failsafe in sync -->
         <plugin>
           <artifactId>maven-failsafe-plugin</artifactId>
-          <version>2.14</version>
+          <version>2.15</version>
         </plugin>
         <plugin>
           <artifactId>maven-clean-plugin</artifactId>
@@ -485,13 +484,14 @@
         </plugin>
         <plugin>
           <artifactId>maven-dependency-plugin</artifactId>
-          <version>2.7</version>
+          <version>2.8</version>
         </plugin>
         <plugin>
           <artifactId>maven-assembly-plugin</artifactId>
           <version>2.4</version>
         </plugin>
         <plugin>
+          <!-- Do NOT upgrade -->
           <artifactId>maven-jxr-plugin</artifactId>
           <version>2.2</version>
         </plugin>
@@ -515,7 +515,7 @@
         <plugin>
           <groupId>org.codehaus.mojo</groupId>
           <artifactId>build-helper-maven-plugin</artifactId>
-          <version>1.7</version>
+          <version>1.8</version>
         </plugin>               
 
         <!-- Workaround for the 'M2E plugin execution not covered' problem.
@@ -580,3 +580,4 @@
     </pluginManagement>
   </build>
 </project>
+
diff --git a/tarball/pom.xml b/tarball/pom.xml
index 9a301c3854ea..a9c1cf9f9642 100644
--- a/tarball/pom.xml
+++ b/tarball/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-tarball</artifactId>
diff --git a/testsuite-osgi/pom.xml b/testsuite-osgi/pom.xml
index c0c2496359b1..449857c9b7b9 100644
--- a/testsuite-osgi/pom.xml
+++ b/testsuite-osgi/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-testsuite-osgi-parent</artifactId>
diff --git a/testsuite-osgi/testsuite-osgi-deps/pom.xml b/testsuite-osgi/testsuite-osgi-deps/pom.xml
index 5f96331a34d2..3a05617ade6c 100644
--- a/testsuite-osgi/testsuite-osgi-deps/pom.xml
+++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-testsuite-osgi-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-testsuite-osgi-deps</artifactId>
diff --git a/testsuite-osgi/testsuite-osgi-exam/pom.xml b/testsuite-osgi/testsuite-osgi-exam/pom.xml
index ffa95a739f52..338aba7423b5 100644
--- a/testsuite-osgi/testsuite-osgi-exam/pom.xml
+++ b/testsuite-osgi/testsuite-osgi-exam/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-testsuite-osgi-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-testsuite-osgi-exam</artifactId>
diff --git a/testsuite-osgi/testsuite-osgi-split/pom.xml b/testsuite-osgi/testsuite-osgi-split/pom.xml
index 5e468c17016f..5b4b9c7d1835 100644
--- a/testsuite-osgi/testsuite-osgi-split/pom.xml
+++ b/testsuite-osgi/testsuite-osgi-split/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-testsuite-osgi-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-testsuite-osgi-split</artifactId>
diff --git a/testsuite/pom.xml b/testsuite/pom.xml
index 42a16048cbc7..3cd0300f2a20 100644
--- a/testsuite/pom.xml
+++ b/testsuite/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-testsuite</artifactId>
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java
index 62fecd7efe75..dd15f1df7e6e 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java
@@ -21,9 +21,9 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.MessageList;
 import io.netty.channel.sctp.SctpChannel;
 import io.netty.handler.codec.sctp.SctpInboundByteStreamHandler;
 import io.netty.handler.codec.sctp.SctpMessageCompletionHandler;
@@ -54,22 +54,12 @@ public void testSimpleEcho() throws Throwable {
     }
 
     public void testSimpleEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, Integer.MAX_VALUE);
+        testSimpleEcho0(sb, cb);
     }
 
-    @Test
-    public void testSimpleEchoWithBoundedBuffer() throws Throwable {
-        Assume.assumeTrue(TestUtils.isSctpSupported());
-        run();
-    }
-
-    public void testSimpleEchoWithBoundedBuffer(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, 4096);
-    }
-
-    private static void testSimpleEcho0(ServerBootstrap sb, Bootstrap cb, int maxInboundBufferSize) throws Throwable {
-        final EchoHandler sh = new EchoHandler(maxInboundBufferSize);
-        final EchoHandler ch = new EchoHandler(maxInboundBufferSize);
+    private static void testSimpleEcho0(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        final EchoHandler sh = new EchoHandler();
+        final EchoHandler ch = new EchoHandler();
 
         sb.childHandler(new ChannelInitializer<SctpChannel>() {
             @Override
@@ -149,21 +139,11 @@ public void initChannel(SctpChannel c) throws Exception {
         }
     }
 
-    private static class EchoHandler extends ChannelInboundByteHandlerAdapter {
-        private final int maxInboundBufferSize;
+    private static class EchoHandler extends ChannelInboundHandlerAdapter {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
 
-        EchoHandler(int maxInboundBufferSize) {
-            this.maxInboundBufferSize = maxInboundBufferSize;
-        }
-
-        @Override
-        public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ChannelHandlerUtil.allocate(ctx, 0, maxInboundBufferSize);
-        }
-
         @Override
         public void channelActive(ChannelHandlerContext ctx)
                 throws Exception {
@@ -171,22 +151,23 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void inboundBufferUpdated(
-                ChannelHandlerContext ctx, ByteBuf in)
-                throws Exception {
-            byte[] actual = new byte[in.readableBytes()];
-            in.readBytes(actual);
-
-            int lastIdx = counter;
-            for (int i = 0; i < actual.length; i++) {
-                assertEquals(data[i + lastIdx], actual[i]);
-            }
-
-            if (channel.parent() != null) {
-                channel.write(Unpooled.wrappedBuffer(actual));
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int j = 0; j < msgs.size(); j ++) {
+                ByteBuf in = (ByteBuf) msgs.get(j);
+                byte[] actual = new byte[in.readableBytes()];
+                in.readBytes(actual);
+
+                int lastIdx = counter;
+                for (int i = 0; i < actual.length; i++) {
+                    assertEquals(data[i + lastIdx], actual[i]);
+                }
+
+                if (channel.parent() != null) {
+                    channel.write(Unpooled.wrappedBuffer(actual));
+                }
+
+                counter += actual.length;
             }
-
-            counter += actual.length;
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
index a62104781e28..5a59cc8615ff 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java
@@ -19,8 +19,9 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.channel.socket.oio.OioDatagramChannel;
@@ -43,12 +44,11 @@ public void testMulticast() throws Throwable {
     public void testMulticast(Bootstrap sb, Bootstrap cb) throws Throwable {
         MulticastTestHandler mhandler = new MulticastTestHandler();
 
-        sb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {
+        sb.handler(new ChannelInboundHandlerAdapter() {
             @Override
-            public void messageReceived(
-                    ChannelHandlerContext ctx,
-                    DatagramPacket msg) throws Exception {
+            public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
                 // Nothing will be sent.
+                msgs.releaseAllAndRecycle();
             }
         });
 
@@ -92,19 +92,21 @@ public void messageReceived(
         cc.close().awaitUninterruptibly();
     }
 
-    private static final class MulticastTestHandler extends ChannelInboundMessageHandlerAdapter<DatagramPacket> {
+    private static final class MulticastTestHandler extends ChannelInboundHandlerAdapter {
         private final CountDownLatch latch = new CountDownLatch(1);
 
         private boolean done;
         private volatile boolean fail;
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {
-            if (done) {
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            if (done || msgs.size() != 1) {
                 fail = true;
             }
 
-            assertEquals(1, msg.content().readInt());
+            assertEquals(1, ((DatagramPacket) msgs.get(0)).content().readInt());
+            msgs.releaseAllAndRecycle();
+
             latch.countDown();
 
             // mark the handler as done as we only are supposed to receive one message
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
index 9e1237e96009..4ad4c9320bee 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
@@ -19,7 +19,8 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.DatagramPacket;
 import org.junit.Test;
 
@@ -38,22 +39,21 @@ public void testSimpleSend() throws Throwable {
     public void testSimpleSend(Bootstrap sb, Bootstrap cb) throws Throwable {
         final CountDownLatch latch = new CountDownLatch(1);
 
-        sb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {
+        sb.handler(new ChannelInboundHandlerAdapter() {
             @Override
-            public void messageReceived(
-                    ChannelHandlerContext ctx,
-                    DatagramPacket msg) throws Exception {
-                assertEquals(1, msg.content().readInt());
+            public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+                assertEquals(1, msgs.size());
+                assertEquals(1, ((DatagramPacket) msgs.get(0)).content().readInt());
+                msgs.releaseAllAndRecycle();
                 latch.countDown();
             }
         });
 
-        cb.handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {
+        cb.handler(new ChannelInboundHandlerAdapter() {
             @Override
-            public void messageReceived(
-                    ChannelHandlerContext ctx,
-                    DatagramPacket msg) throws Exception {
+            public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
                 // Nothing will be sent.
+                msgs.releaseAllAndRecycle();
             }
         });
 
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java
index 726a97c8a0a2..af3fe50a72ec 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java
@@ -16,11 +16,10 @@
 package io.netty.testsuite.transport.socket;
 
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelOption;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -94,7 +93,7 @@ public void testSuspendAndResumeAccept(ServerBootstrap sb) throws Throwable {
     }
 
     @ChannelHandler.Sharable
-    private static final class AcceptedChannelCounter extends ChannelInboundByteHandlerAdapter {
+    private static final class AcceptedChannelCounter extends ChannelInboundHandlerAdapter {
 
         final CountDownLatch latch;
 
@@ -106,10 +105,5 @@ private static final class AcceptedChannelCounter extends ChannelInboundByteHand
         public void channelActive(ChannelHandlerContext ctx) throws Exception {
             latch.countDown();
         }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-            // Unused
-        }
     }
 }
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketBufReleaseTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketBufReleaseTest.java
index fb16050f1607..ae02ab802db3 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketBufReleaseTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketBufReleaseTest.java
@@ -22,7 +22,8 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
 import io.netty.util.concurrent.DefaultPromise;
 import io.netty.util.concurrent.DefaultThreadFactory;
@@ -66,7 +67,7 @@ public void testBufRelease(ServerBootstrap sb, Bootstrap cb) throws Throwable {
         clientHandler.check();
     }
 
-    private static class BufWriterHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+    private static class BufWriterHandler extends ChannelInboundHandlerAdapter {
 
         private final Random random = new Random();
         private final CountDownLatch latch = new CountDownLatch(1);
@@ -95,8 +96,8 @@ public void operationComplete(ChannelFuture future) throws Exception {
         }
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-            // Discard
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            msgs.releaseAllAndRecycle();
         }
 
         public void check() throws InterruptedException {
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java
new file mode 100644
index 000000000000..8f98a20de491
--- /dev/null
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.testsuite.transport.socket;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelOption;
+import io.netty.util.internal.SystemPropertyUtil;
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+public class SocketConnectionAttemptTest extends AbstractClientSocketTest {
+
+    private static final String BAD_HOST = SystemPropertyUtil.get("io.netty.testsuite.badHost", "255.255.255.0");
+
+    @Test(timeout = 30000)
+    public void testConnectTimeout() throws Throwable {
+        run();
+    }
+
+    public void testConnectTimeout(Bootstrap cb) throws Throwable {
+        TestHandler h = new TestHandler();
+        cb.handler(h).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 2000);
+        ChannelFuture future = cb.connect(BAD_HOST, 8080);
+        try {
+            assertThat(future.await(3000), is(true));
+        } finally {
+            future.channel().close();
+        }
+    }
+
+    @Test
+    public void testConnectCancellation() throws Throwable {
+        run();
+    }
+
+    public void testConnectCancellation(Bootstrap cb) throws Throwable {
+        TestHandler h = new TestHandler();
+        cb.handler(h).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4000);
+        ChannelFuture future = cb.connect(BAD_HOST, 8080);
+        try {
+            assertThat(future.await(1000), is(false));
+            if (future.cancel(true)) {
+                assertThat(future.channel().closeFuture().await(500), is(true));
+                assertThat(future.isCancelled(), is(true));
+            } else {
+                // Cancellation not supported by the transport.
+            }
+        } finally {
+            future.channel().close();
+        }
+    }
+
+    private static class TestHandler extends ChannelInboundHandlerAdapter {
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+            cause.printStackTrace();
+        }
+    }
+}
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
index 35b4ec84bd8d..226a48a9047e 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java
@@ -21,9 +21,9 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
 import io.netty.util.concurrent.EventExecutorGroup;
@@ -54,8 +54,8 @@ public static void createGroup() {
     }
 
     @AfterClass
-    public static void destroyGroup() {
-        group.shutdownGracefully();
+    public static void destroyGroup() throws Exception {
+        group.shutdownGracefully().sync();
     }
 
     @Test(timeout = 30000)
@@ -64,34 +64,16 @@ public void testSimpleEcho() throws Throwable {
     }
 
     public void testSimpleEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, Integer.MAX_VALUE, false, false);
+        testSimpleEcho0(sb, cb, false, false);
     }
 
     @Test(timeout = 30000)
-    public void testSimpleEchoWithBridge() throws Throwable {
+    public void testSimpleEchoWithAdditionalExecutor() throws Throwable {
         run();
     }
 
-    public void testSimpleEchoWithBridge(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, Integer.MAX_VALUE, true, false);
-    }
-
-    @Test(timeout = 30000)
-    public void testSimpleEchoWithBoundedBuffer() throws Throwable {
-        run();
-    }
-
-    public void testSimpleEchoWithBoundedBuffer(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, 32, false, false);
-    }
-
-    @Test(timeout = 30000)
-    public void testSimpleEchoWithBridgedBoundedBuffer() throws Throwable {
-        run();
-    }
-
-    public void testSimpleEchoWithBridgedBoundedBuffer(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, 32, true, false);
+    public void testSimpleEchoWithAdditionalExecutor(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testSimpleEcho0(sb, cb, true, false);
     }
 
     @Test(timeout = 30000)
@@ -100,26 +82,26 @@ public void testSimpleEchoWithVoidPromise() throws Throwable {
     }
 
     public void testSimpleEchoWithVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, Integer.MAX_VALUE, false, true);
+        testSimpleEcho0(sb, cb, false, true);
     }
 
     @Test(timeout = 30000)
-    public void testSimpleEchoWithBridgeAndVoidPromise() throws Throwable {
+    public void testSimpleEchoWithAdditionalExecutorAndVoidPromise() throws Throwable {
         run();
     }
 
-    public void testSimpleEchoWithBridgeAndVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {
-        testSimpleEcho0(sb, cb, Integer.MAX_VALUE, true, true);
+    public void testSimpleEchoWithAdditionalExecutorAndVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testSimpleEcho0(sb, cb, true, true);
     }
 
     private static void testSimpleEcho0(
-            ServerBootstrap sb, Bootstrap cb, int maxInboundBufferSize, boolean bridge, boolean voidPromise)
+            ServerBootstrap sb, Bootstrap cb, boolean additionalExecutor, boolean voidPromise)
             throws Throwable {
 
-        final EchoHandler sh = new EchoHandler(maxInboundBufferSize);
-        final EchoHandler ch = new EchoHandler(maxInboundBufferSize);
+        final EchoHandler sh = new EchoHandler();
+        final EchoHandler ch = new EchoHandler();
 
-        if (bridge) {
+        if (additionalExecutor) {
             sb.childHandler(new ChannelInitializer<SocketChannel>() {
                 @Override
                 protected void initChannel(SocketChannel c) throws Exception {
@@ -199,21 +181,11 @@ protected void initChannel(SocketChannel c) throws Exception {
         }
     }
 
-    private static class EchoHandler extends ChannelInboundByteHandlerAdapter {
-        private final int maxInboundBufferSize;
+    private static class EchoHandler extends ChannelInboundHandlerAdapter {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
 
-        EchoHandler(int maxInboundBufferSize) {
-            this.maxInboundBufferSize = maxInboundBufferSize;
-        }
-
-        @Override
-        public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ChannelHandlerUtil.allocate(ctx, 0, maxInboundBufferSize);
-        }
-
         @Override
         public void channelActive(ChannelHandlerContext ctx)
                 throws Exception {
@@ -221,22 +193,24 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void inboundBufferUpdated(
-                ChannelHandlerContext ctx, ByteBuf in)
-                throws Exception {
-            byte[] actual = new byte[in.readableBytes()];
-            in.readBytes(actual);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int j = 0; j < msgs.size(); j ++) {
+                ByteBuf in = (ByteBuf) msgs.get(j);
+                byte[] actual = new byte[in.readableBytes()];
+                in.readBytes(actual);
+
+                int lastIdx = counter;
+                for (int i = 0; i < actual.length; i ++) {
+                    assertEquals(data[i + lastIdx], actual[i]);
+                }
 
-            int lastIdx = counter;
-            for (int i = 0; i < actual.length; i ++) {
-                assertEquals(data[i + lastIdx], actual[i]);
-            }
+                if (channel.parent() != null) {
+                    channel.write(Unpooled.wrappedBuffer(actual));
+                }
 
-            if (channel.parent() != null) {
-                channel.write(Unpooled.wrappedBuffer(actual));
+                counter += actual.length;
             }
-
-            counter += actual.length;
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
index 0a002c30ba81..7d5287850880 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java
@@ -20,9 +20,11 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.DefaultFileRegion;
 import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
 import org.junit.Test;
 
 import java.io.File;
@@ -69,10 +71,12 @@ private void testFileRegion0(ServerBootstrap sb, Bootstrap cb, boolean voidPromi
         out.write(data);
         out.close();
 
-        ChannelInboundByteHandlerAdapter ch = new ChannelInboundByteHandlerAdapter() {
+        ChannelInboundHandler ch = new ChannelInboundHandlerAdapter() {
+
             @Override
-            public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-                in.clear();
+            public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+                // discard
+                msgs.releaseAllAndRecycle();
             }
 
             @Override
@@ -88,12 +92,11 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         Channel sc = sb.bind().sync().channel();
 
         Channel cc = cb.connect().sync().channel();
-        FileRegion region = new DefaultFileRegion(new FileInputStream(file).getChannel(),
-                0L, file.length());
+        FileRegion region = new DefaultFileRegion(new FileInputStream(file).getChannel(), 0L, file.length());
         if (voidPromise) {
-            assertEquals(cc.voidPromise(), cc.sendFile(region, cc.voidPromise()));
+            assertEquals(cc.voidPromise(), cc.write(region, cc.voidPromise()));
         } else {
-            assertNotEquals(cc.voidPromise(), cc.sendFile(region));
+            assertNotEquals(cc.voidPromise(), cc.write(region));
         }
         while (sh.counter < data.length) {
             if (sh.exception.get() != null) {
@@ -120,7 +123,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         }
     }
 
-    private static class TestHandler extends ChannelInboundByteHandlerAdapter {
+    private static class TestHandler extends ChannelInboundHandlerAdapter {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -132,17 +135,19 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void inboundBufferUpdated(
-                ChannelHandlerContext ctx, ByteBuf in)
-                throws Exception {
-            byte[] actual = new byte[in.readableBytes()];
-            in.readBytes(actual);
-
-            int lastIdx = counter;
-            for (int i = 0; i < actual.length; i ++) {
-                assertEquals(data[i + lastIdx], actual[i]);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int j = 0; j < msgs.size(); j ++) {
+                ByteBuf in = (ByteBuf) msgs.get(j);
+                byte[] actual = new byte[in.readableBytes()];
+                in.readBytes(actual);
+
+                int lastIdx = counter;
+                for (int i = 0; i < actual.length; i ++) {
+                    assertEquals(data[i + lastIdx], actual[i]);
+                }
+                counter += actual.length;
             }
-            counter += actual.length;
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
index 206406dd0913..d25528fcf061 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFixedLengthEchoTest.java
@@ -21,8 +21,9 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.FixedLengthFrameDecoder;
 import org.junit.Test;
@@ -123,7 +124,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    private static class EchoHandler extends ChannelInboundMessageHandlerAdapter<ByteBuf> {
+    private static class EchoHandler extends ChannelInboundHandlerAdapter {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -135,24 +136,26 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void messageReceived(
-                ChannelHandlerContext ctx,
-                ByteBuf msg) throws Exception {
-            assertEquals(1024, msg.readableBytes());
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int j = 0; j < msgs.size(); j ++) {
+                ByteBuf msg = (ByteBuf) msgs.get(j);
+                assertEquals(1024, msg.readableBytes());
 
-            byte[] actual = new byte[msg.readableBytes()];
-            msg.getBytes(0, actual);
+                byte[] actual = new byte[msg.readableBytes()];
+                msg.getBytes(0, actual);
 
-            int lastIdx = counter;
-            for (int i = 0; i < actual.length; i ++) {
-                assertEquals(data[i + lastIdx], actual[i]);
-            }
+                int lastIdx = counter;
+                for (int i = 0; i < actual.length; i ++) {
+                    assertEquals(data[i + lastIdx], actual[i]);
+                }
 
-            if (channel.parent() != null) {
-                channel.write(msg.retain());
-            }
+                if (channel.parent() != null) {
+                    channel.write(msg.retain());
+                }
 
-            counter += actual.length;
+                counter += actual.length;
+            }
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
new file mode 100644
index 000000000000..e044d5815043
--- /dev/null
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.testsuite.transport.socket;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+
+public class SocketGatheringWriteTest extends AbstractSocketTest {
+
+    private static final Random random = new Random();
+    static final byte[] data = new byte[1048576];
+
+    static {
+        random.nextBytes(data);
+    }
+
+    @Test(timeout = 30000)
+    public void testGatheringWrite() throws Throwable {
+        run();
+    }
+
+    public void testGatheringWrite(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testGatheringWrite0(sb, cb, false);
+    }
+
+    @Test(timeout = 30000)
+    public void testGatheringWriteWithComposite() throws Throwable {
+        run();
+    }
+
+    public void testGatheringWriteWithComposite(ServerBootstrap sb, Bootstrap cb) throws Throwable {
+        testGatheringWrite0(sb, cb, true);
+    }
+
+    private static void testGatheringWrite0(ServerBootstrap sb, Bootstrap cb, boolean composite) throws Throwable {
+        final TestHandler sh = new TestHandler();
+        final TestHandler ch = new TestHandler();
+
+        cb.handler(ch);
+        sb.childHandler(sh);
+
+        Channel sc = sb.bind().sync().channel();
+        Channel cc = cb.connect().sync().channel();
+
+        MessageList<Object> messages = MessageList.newInstance();
+
+        for (int i = 0; i < data.length;) {
+            int length = Math.min(random.nextInt(1024 * 64), data.length - i);
+            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);
+            if (composite && i % 2 == 0) {
+                int split =  buf.readableBytes() / 2;
+                int size = buf.readableBytes() - split;
+                int oldIndex = buf.writerIndex();
+                buf.writerIndex(split);
+                ByteBuf buf2 = Unpooled.buffer(size).writeBytes(buf, split, oldIndex - split);
+                CompositeByteBuf comp = Unpooled.compositeBuffer();
+                comp.addComponent(buf).addComponent(buf2).writerIndex(length);
+                messages.add(comp);
+            } else {
+                messages.add(buf);
+            }
+            i += length;
+        }
+        assertNotEquals(cc.voidPromise(), cc.write(messages).sync());
+
+        while (sh.counter < data.length) {
+            if (sh.exception.get() != null) {
+                break;
+            }
+            if (ch.exception.get() != null) {
+                break;
+            }
+            try {
+                Thread.sleep(50);
+            } catch (InterruptedException e) {
+                // Ignore.
+            }
+        }
+        assertEquals(Unpooled.wrappedBuffer(data), sh.received);
+        sh.channel.close().sync();
+        ch.channel.close().sync();
+        sc.close().sync();
+
+        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {
+            throw sh.exception.get();
+        }
+        if (sh.exception.get() != null) {
+            throw sh.exception.get();
+        }
+        if (ch.exception.get() != null && !(ch.exception.get() instanceof IOException)) {
+            throw ch.exception.get();
+        }
+        if (ch.exception.get() != null) {
+            throw ch.exception.get();
+        }
+        assertEquals(0, ch.counter);
+    }
+
+    private static class TestHandler extends ChannelInboundHandlerAdapter {
+        volatile Channel channel;
+        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
+        volatile int counter;
+        final ByteBuf received = Unpooled.buffer();
+        @Override
+        public void channelActive(ChannelHandlerContext ctx)
+                throws Exception {
+            channel = ctx.channel();
+        }
+
+        @Override
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int j = 0; j < msgs.size(); j ++) {
+                ByteBuf in = (ByteBuf) msgs.get(j);
+                counter += in.readableBytes();
+                received.writeBytes(in);
+            }
+            msgs.releaseAllAndRecycle();
+        }
+
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx,
+                Throwable cause) throws Exception {
+            if (exception.compareAndSet(null, cause)) {
+                ctx.close();
+            }
+        }
+    }
+}
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java
index d57abd2152cb..d660df27841d 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketObjectEchoTest.java
@@ -19,8 +19,9 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.serialization.ClassResolvers;
 import io.netty.handler.codec.serialization.ObjectDecoder;
@@ -133,7 +134,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    private static class EchoHandler extends ChannelInboundMessageHandlerAdapter<String> {
+    private static class EchoHandler extends ChannelInboundHandlerAdapter {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -148,15 +149,18 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx,
-                String msg) throws Exception {
-            assertEquals(data[counter], msg);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+                String msg = (String) msgs.get(i);
+                assertEquals(data[counter], msg);
 
-            if (channel.parent() != null) {
-                channel.write(msg);
-            }
+                if (channel.parent() != null) {
+                    channel.write(msg);
+                }
 
-            counter ++;
+                counter ++;
+            }
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java
index e5e6a4df04da..f2b30237dbd8 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java
@@ -18,8 +18,9 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.ChannelInputShutdownEvent;
 import io.netty.channel.socket.SocketChannel;
 import org.junit.Test;
@@ -109,7 +110,7 @@ public void testShutdownOutputWithoutOption(ServerBootstrap sb) throws Throwable
         }
     }
 
-    private static class TestHandler extends ChannelInboundByteHandlerAdapter {
+    private static class TestHandler extends ChannelInboundHandlerAdapter {
         volatile SocketChannel ch;
         final BlockingQueue<Byte> queue = new LinkedBlockingQueue<Byte>();
         final CountDownLatch halfClosure = new CountDownLatch(1);
@@ -127,8 +128,11 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-            queue.offer(in.readByte());
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+                queue.offer(((ByteBuf) msgs.get(i)).readByte());
+            }
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java
index 5c377c31dbfb..a895c6846ed6 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java
@@ -19,7 +19,8 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.SocketChannel;
 import org.junit.Test;
 
@@ -76,7 +77,7 @@ public void testShutdownOutput(Bootstrap cb) throws Throwable {
         }
     }
 
-    private static class TestHandler extends ChannelInboundByteHandlerAdapter {
+    private static class TestHandler extends ChannelInboundHandlerAdapter {
         volatile SocketChannel ch;
         final BlockingQueue<Byte> queue = new LinkedBlockingQueue<Byte>();
 
@@ -86,8 +87,11 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-            queue.offer(in.readByte());
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+                queue.offer(((ByteBuf) msgs.get(i)).readByte());
+            }
+            msgs.releaseAllAndRecycle();
         }
     }
 }
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
index 905f315daa87..19b15bfbcb87 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSpdyEchoTest.java
@@ -17,14 +17,13 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.spdy.SpdyConstants;
 import io.netty.handler.codec.spdy.SpdyFrameDecoder;
@@ -230,13 +229,12 @@ public void initChannel(SocketChannel channel) throws Exception {
         }
     }
 
-    private static class SpdyEchoTestServerHandler extends ChannelInboundMessageHandlerAdapter<Object> {
+    private static class SpdyEchoTestServerHandler extends ChannelInboundHandlerAdapter {
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-            BufUtil.retain(msg);
-            ctx.write(msg);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            ctx.write(msgs);
         }
 
         @Override
@@ -247,7 +245,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         }
     }
 
-    private static class SpdyEchoTestClientHandler extends ChannelInboundByteHandlerAdapter {
+    private static class SpdyEchoTestClientHandler extends ChannelInboundHandlerAdapter {
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         final ByteBuf frames;
         volatile int counter;
@@ -257,16 +255,20 @@ private static class SpdyEchoTestClientHandler extends ChannelInboundByteHandler
         }
 
         @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-            byte[] actual = new byte[in.readableBytes()];
-            in.readBytes(actual);
-
-            int lastIdx = counter;
-            for (int i = 0; i < actual.length; i ++) {
-                assertEquals(frames.getByte(ignoredBytes + i + lastIdx), actual[i]);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int j = 0; j < msgs.size(); j ++) {
+                ByteBuf in = (ByteBuf) msgs.get(j);
+                byte[] actual = new byte[in.readableBytes()];
+                in.readBytes(actual);
+
+                int lastIdx = counter;
+                for (int i = 0; i < actual.length; i ++) {
+                    assertEquals(frames.getByte(ignoredBytes + i + lastIdx), actual[i]);
+                }
+
+                counter += actual.length;
             }
-
-            counter += actual.length;
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
index c90f6899e6f6..3e75430eda5b 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
@@ -15,30 +15,29 @@
  */
 package io.netty.testsuite.transport.socket;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.handler.stream.ChunkedWriteHandler;
 import io.netty.testsuite.util.BogusSslContextFactory;
 import io.netty.util.concurrent.Future;
+import org.junit.Test;
 
+import javax.net.ssl.SSLEngine;
 import java.io.IOException;
 import java.util.Random;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-import javax.net.ssl.SSLEngine;
-
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 public class SocketSslEchoTest extends AbstractSocketTest {
 
@@ -163,7 +162,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    private class EchoHandler extends ChannelInboundByteHandlerAdapter {
+    private class EchoHandler extends ChannelInboundHandlerAdapter {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -180,22 +179,24 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void inboundBufferUpdated(
-                ChannelHandlerContext ctx, ByteBuf in)
-                throws Exception {
-            byte[] actual = new byte[in.readableBytes()];
-            in.readBytes(actual);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int j = 0; j < msgs.size(); j ++) {
+                ByteBuf in = (ByteBuf) msgs.get(j);
+                byte[] actual = new byte[in.readableBytes()];
+                in.readBytes(actual);
+
+                int lastIdx = counter;
+                for (int i = 0; i < actual.length; i ++) {
+                    assertEquals(data[i + lastIdx], actual[i]);
+                }
 
-            int lastIdx = counter;
-            for (int i = 0; i < actual.length; i ++) {
-                assertEquals(data[i + lastIdx], actual[i]);
-            }
+                if (channel.parent() != null) {
+                    channel.write(Unpooled.wrappedBuffer(actual));
+                }
 
-            if (channel.parent() != null) {
-                channel.write(Unpooled.wrappedBuffer(actual));
+                counter += actual.length;
             }
-
-            counter += actual.length;
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
index 54b70d15a9bc..6d147afb1a55 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStartTlsTest.java
@@ -19,9 +19,10 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.LineBasedFrameDecoder;
 import io.netty.handler.codec.string.StringDecoder;
@@ -54,8 +55,8 @@ public static void createExecutor() {
     }
 
     @AfterClass
-    public static void shutdownExecutor() {
-        executor.shutdownGracefully();
+    public static void shutdownExecutor() throws Exception {
+        executor.shutdownGracefully().sync();
     }
 
     @Test(timeout = 30000)
@@ -142,7 +143,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    private class StartTlsClientHandler extends ChannelInboundMessageHandlerAdapter<String> {
+    private class StartTlsClientHandler extends ChannelInboundHandlerAdapter {
         private final SslHandler sslHandler;
         private Future<Channel> handshakeFuture;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
@@ -159,18 +160,22 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void messageReceived(final ChannelHandlerContext ctx, String msg) throws Exception {
-            if ("StartTlsResponse".equals(msg)) {
-                ctx.pipeline().addAfter("logger", "ssl", sslHandler);
-                handshakeFuture = sslHandler.handshakeFuture();
-                ctx.write("EncryptedRequest\n");
-                return;
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+                String msg = (String) msgs.get(i);
+                if ("StartTlsResponse".equals(msg)) {
+                    ctx.pipeline().addAfter("logger", "ssl", sslHandler);
+                    handshakeFuture = sslHandler.handshakeFuture();
+                    ctx.write("EncryptedRequest\n");
+                    continue;
+                }
+
+                assertEquals("EncryptedResponse", msg);
+                assertNotNull(handshakeFuture);
+                assertTrue(handshakeFuture.isSuccess());
+                ctx.close();
             }
-
-            assertEquals("EncryptedResponse", msg);
-            assertNotNull(handshakeFuture);
-            assertTrue(handshakeFuture.isSuccess());
-            ctx.close();
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
@@ -185,7 +190,7 @@ public void exceptionCaught(ChannelHandlerContext ctx,
         }
     }
 
-    private class StartTlsServerHandler extends ChannelInboundMessageHandlerAdapter<String> {
+    private class StartTlsServerHandler extends ChannelInboundHandlerAdapter {
         private final SslHandler sslHandler;
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
@@ -201,15 +206,19 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void messageReceived(final ChannelHandlerContext ctx, String msg) throws Exception {
-            if ("StartTlsRequest".equals(msg)) {
-                ctx.pipeline().addAfter("logger", "ssl", sslHandler);
-                ctx.write("StartTlsResponse\n");
-                return;
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+               String msg = (String) msgs.get(i);
+               if ("StartTlsRequest".equals(msg)) {
+                    ctx.pipeline().addAfter("logger", "ssl", sslHandler);
+                    ctx.write("StartTlsResponse\n");
+                    continue;
+               }
+
+               assertEquals("EncryptedRequest", msg);
+               ctx.write("EncryptedResponse\n");
             }
-
-            assertEquals("EncryptedRequest", msg);
-            ctx.write("EncryptedResponse\n");
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
index 391f567037b2..9cb3b2a8f93f 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketStringEchoTest.java
@@ -17,11 +17,11 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.BufType;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.handler.codec.DelimiterBasedFrameDecoder;
 import io.netty.handler.codec.Delimiters;
@@ -136,7 +136,7 @@ public void initChannel(SocketChannel sch) throws Exception {
         }
     }
 
-    static class StringEchoHandler extends ChannelInboundMessageHandlerAdapter<String> {
+    static class StringEchoHandler extends ChannelInboundHandlerAdapter {
         volatile Channel channel;
         final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         volatile int counter;
@@ -148,16 +148,19 @@ public void channelActive(ChannelHandlerContext ctx)
         }
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx,
-                String msg) throws Exception {
-            assertEquals(data[counter], msg);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+                String msg = (String) msgs.get(i);
+                assertEquals(data[counter], msg);
 
-            if (channel.parent() != null) {
-                String delimiter = random.nextBoolean() ? "\r\n" : "\n";
-                channel.write(msg + delimiter);
-            }
+                if (channel.parent() != null) {
+                    String delimiter = random.nextBoolean() ? "\r\n" : "\n";
+                    channel.write(msg + delimiter);
+                }
 
-            counter ++;
+                counter ++;
+            }
+            msgs.releaseAllAndRecycle();
         }
 
         @Override
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
index c3a1537c0389..1e4e59799a3a 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java
@@ -20,12 +20,9 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.EventLoopGroup;
-import io.netty.channel.aio.AioEventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.oio.OioEventLoopGroup;
 import io.netty.channel.socket.InternetProtocolFamily;
-import io.netty.channel.socket.aio.AioServerSocketChannel;
-import io.netty.channel.socket.aio.AioSocketChannel;
 import io.netty.channel.socket.nio.NioDatagramChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
@@ -33,28 +30,18 @@
 import io.netty.channel.socket.oio.OioServerSocketChannel;
 import io.netty.channel.socket.oio.OioSocketChannel;
 import io.netty.util.concurrent.DefaultThreadFactory;
-import io.netty.util.internal.PlatformDependent;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map.Entry;
 
 final class SocketTestPermutation {
-
-    // TODO: AIO transport tests fail with 'An existing connection was forcibly closed by the remote host' on Windows.
-    //       Disabling test until the root cause is known.
-    private static final boolean TEST_AIO = !PlatformDependent.isWindows();
-
     private static final int BOSSES = 2;
     private static final int WORKERS = 3;
     private static final EventLoopGroup nioBossGroup =
             new NioEventLoopGroup(BOSSES, new DefaultThreadFactory("testsuite-nio-boss", true));
     private static final EventLoopGroup nioWorkerGroup =
             new NioEventLoopGroup(WORKERS, new DefaultThreadFactory("testsuite-nio-worker", true));
-    private static final EventLoopGroup aioBossGroup =
-            new AioEventLoopGroup(BOSSES, new DefaultThreadFactory("testsuite-aio-boss", true));
-    private static final EventLoopGroup aioWorkerGroup =
-            new AioEventLoopGroup(WORKERS, new DefaultThreadFactory("testsuite-aio-worker", true));
     private static final EventLoopGroup oioBossGroup =
             new OioEventLoopGroup(Integer.MAX_VALUE, new DefaultThreadFactory("testsuite-oio-boss", true));
     private static final EventLoopGroup oioWorkerGroup =
@@ -168,15 +155,6 @@ public ServerBootstrap newInstance() {
                                             .channel(NioServerSocketChannel.class);
             }
         });
-        if (TEST_AIO) {
-            list.add(new Factory<ServerBootstrap>() {
-                @Override
-                public ServerBootstrap newInstance() {
-                    return new ServerBootstrap().group(aioBossGroup, aioWorkerGroup)
-                                                .channel(AioServerSocketChannel.class);
-                }
-            });
-        }
         list.add(new Factory<ServerBootstrap>() {
             @Override
             public ServerBootstrap newInstance() {
@@ -196,14 +174,6 @@ public Bootstrap newInstance() {
                 return new Bootstrap().group(nioWorkerGroup).channel(NioSocketChannel.class);
             }
         });
-        if (TEST_AIO) {
-            list.add(new Factory<Bootstrap>() {
-                @Override
-                public Bootstrap newInstance() {
-                    return new Bootstrap().group(aioWorkerGroup).channel(AioSocketChannel.class);
-                }
-            });
-        }
         list.add(new Factory<Bootstrap>() {
             @Override
             public Bootstrap newInstance() {
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java
new file mode 100644
index 000000000000..ac553d5242eb
--- /dev/null
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.testsuite.transport.socket;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.socket.SocketChannel;
+import org.junit.Test;
+
+public class WriteBeforeRegisteredTest extends AbstractClientSocketTest {
+
+    @Test(timeout = 30000)
+    public void testWriteBeforeConnect() throws Throwable {
+        run();
+    }
+
+    public void testWriteBeforeConnect(Bootstrap cb) throws Throwable {
+        TestHandler h = new TestHandler();
+        SocketChannel ch = null;
+        try {
+            ch = (SocketChannel) cb.handler(h).connect().channel();
+            ch.write(Unpooled.wrappedBuffer(new byte[] { 1 })).await();
+        } finally {
+            if (ch != null) {
+                ch.close();
+            }
+        }
+    }
+
+    private static class TestHandler extends ChannelInboundHandlerAdapter {
+
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+            cause.printStackTrace();
+        }
+    }
+}
diff --git a/testsuite/src/test/java/io/netty/testsuite/transport/udt/UDTClientServerConnectionTest.java b/testsuite/src/test/java/io/netty/testsuite/transport/udt/UDTClientServerConnectionTest.java
index 314f0f2b78ff..2384e428d895 100644
--- a/testsuite/src/test/java/io/netty/testsuite/transport/udt/UDTClientServerConnectionTest.java
+++ b/testsuite/src/test/java/io/netty/testsuite/transport/udt/UDTClientServerConnectionTest.java
@@ -15,14 +15,14 @@
  */
 package io.netty.testsuite.transport.udt;
 
-import static org.junit.Assert.*;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
@@ -33,13 +33,16 @@
 import io.netty.handler.codec.string.StringDecoder;
 import io.netty.handler.codec.string.StringEncoder;
 import io.netty.util.CharsetUtil;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
+import io.netty.util.concurrent.DefaultThreadFactory;
+import io.netty.util.concurrent.GlobalEventExecutor;
 import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.concurrent.ThreadFactory;
+
+import static org.junit.Assert.*;
+
 /**
  * Verify UDT connect/disconnect life cycle.
  */
@@ -64,7 +67,7 @@ static class Client implements Runnable {
         @Override
         public void run() {
             final Bootstrap boot = new Bootstrap();
-            final ThreadFactory clientFactory = new ThreadFactory("client");
+            final ThreadFactory clientFactory = new DefaultThreadFactory("client");
             final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
                     clientFactory, NioUdtProvider.BYTE_PROVIDER);
             try {
@@ -97,7 +100,7 @@ protected void initChannel(final UdtChannel ch)
             } catch (final Throwable e) {
                 log.error("Client failed.", e);
             } finally {
-                connectGroup.shutdownGracefully();
+                connectGroup.shutdownGracefully().syncUninterruptibly();
             }
         }
 
@@ -136,15 +139,12 @@ private void waitForShutdown() throws Exception {
     }
 
     static class ClientHandler extends
-            ChannelInboundMessageHandlerAdapter<String> {
+            ChannelInboundHandlerAdapter {
 
         static final Logger log = LoggerFactory.getLogger(ClientHandler.class);
 
         volatile boolean isActive;
 
-        ClientHandler() {
-        }
-
         @Override
         public void channelActive(final ChannelHandlerContext ctx)
                 throws Exception {
@@ -169,9 +169,11 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
         }
 
         @Override
-        public void messageReceived(final ChannelHandlerContext ctx,
-                final String msg) throws Exception {
-            log.info("Client received: " + msg);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+                log.info("Client received: " + msgs.get(i));
+            }
+            msgs.releaseAllAndRecycle();
         }
     }
 
@@ -179,7 +181,7 @@ static class Server implements Runnable {
 
         static final Logger log = LoggerFactory.getLogger(Server.class);
 
-        final ChannelGroup group = new DefaultChannelGroup("server group");
+        final ChannelGroup group = new DefaultChannelGroup("server group", GlobalEventExecutor.INSTANCE);
 
         final String host;
         final int port;
@@ -196,8 +198,8 @@ static class Server implements Runnable {
         @Override
         public void run() {
             final ServerBootstrap boot = new ServerBootstrap();
-            final ThreadFactory acceptFactory = new ThreadFactory("accept");
-            final ThreadFactory serverFactory = new ThreadFactory("server");
+            final ThreadFactory acceptFactory = new DefaultThreadFactory("accept");
+            final ThreadFactory serverFactory = new DefaultThreadFactory("server");
             final NioEventLoopGroup acceptGroup = new NioEventLoopGroup(1,
                     acceptFactory, NioUdtProvider.BYTE_PROVIDER);
             final NioEventLoopGroup connectGroup = new NioEventLoopGroup(1,
@@ -236,6 +238,9 @@ protected void initChannel(final UdtChannel ch)
             } finally {
                 acceptGroup.shutdownGracefully();
                 connectGroup.shutdownGracefully();
+
+                acceptGroup.terminationFuture().syncUninterruptibly();
+                connectGroup.terminationFuture().syncUninterruptibly();
             }
         }
 
@@ -255,7 +260,7 @@ void waitForActive(final boolean isActive) throws Exception {
                         }
                     }
                 } else {
-                    if (group.size() == 0) {
+                    if (group.isEmpty()) {
                         return;
                     }
                 }
@@ -282,7 +287,7 @@ void waitForShutdown() throws Exception {
     }
 
     static class ServerHandler extends
-            ChannelInboundMessageHandlerAdapter<String> {
+            ChannelInboundHandlerAdapter {
 
         static final Logger log = LoggerFactory.getLogger(ServerHandler.class);
 
@@ -320,35 +325,20 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
         }
 
         @Override
-        public void messageReceived(final ChannelHandlerContext ctx,
-                final String message) throws Exception {
-            log.info("Server received: " + message);
-        }
-    }
-
-    static class ThreadFactory implements java.util.concurrent.ThreadFactory {
-
-        static final AtomicInteger counter = new AtomicInteger();
-
-        final String name;
-
-        ThreadFactory(final String name) {
-            this.name = name;
-        }
-
-        @Override
-        public Thread newThread(final Runnable runnable) {
-            return new Thread(runnable, name + '-' + counter.getAndIncrement());
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+                log.info("Server received: " + msgs.get(i));
+            }
+            msgs.releaseAllAndRecycle();
         }
     }
-
     static final Logger log = LoggerFactory
             .getLogger(UDTClientServerConnectionTest.class);
 
     /**
      * Maximum wait time is 5 seconds.
      * <p>
-     * wait-time = {@link #WAIT_COUNT} * {@value #WAIT_SLEEP}
+     * wait-time = {@code WAIT_COUNT} * {@value #WAIT_SLEEP}
      */
     static final int WAIT_COUNT = 50;
     static final int WAIT_SLEEP = 100;
diff --git a/transport-rxtx/pom.xml b/transport-rxtx/pom.xml
index f30fa721adae..f1c9c887a1cb 100644
--- a/transport-rxtx/pom.xml
+++ b/transport-rxtx/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-transport-rxtx</artifactId>
@@ -35,11 +35,6 @@
       <artifactId>netty-buffer</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>netty-codec</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>netty-transport</artifactId>
diff --git a/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java
index 6a9d7df0329a..5b734d83cc89 100644
--- a/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java
+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 
 import java.util.Map;
 
@@ -35,6 +36,7 @@ final class DefaultRxtxChannelConfig extends DefaultChannelConfig implements Rxt
     private volatile Databits databits = Databits.DATABITS_8;
     private volatile Paritybit paritybit = Paritybit.NONE;
     private volatile int waitTime;
+    private volatile int readTimeout = 1000;
 
     public DefaultRxtxChannelConfig(RxtxChannel channel) {
         super(channel);
@@ -69,6 +71,9 @@ public <T> T getOption(ChannelOption<T> option) {
         if (option == WAIT_TIME) {
             return (T) Integer.valueOf(getWaitTimeMillis());
         }
+        if (option == READ_TIMEOUT) {
+            return (T) Integer.valueOf(getReadTimeout());
+        }
         return super.getOption(option);
     }
 
@@ -90,6 +95,8 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
             setParitybit((Paritybit) value);
         } else if (option == WAIT_TIME) {
             setWaitTimeMillis((Integer) value);
+        } else if (option == READ_TIMEOUT) {
+            setReadTimeout((Integer) value);
         } else {
             return super.setOption(option, value);
         }
@@ -176,6 +183,20 @@ public RxtxChannelConfig setWaitTimeMillis(final int waitTimeMillis) {
         return this;
     }
 
+    @Override
+    public RxtxChannelConfig setReadTimeout(int readTimeout) {
+        if (readTimeout < 0) {
+            throw new IllegalArgumentException("readTime must be >= 0");
+        }
+        this.readTimeout = readTimeout;
+        return this;
+    }
+
+    @Override
+    public int getReadTimeout() {
+        return readTimeout;
+    }
+
     @Override
     public RxtxChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
         return (RxtxChannelConfig) super.setConnectTimeoutMillis(connectTimeoutMillis);
@@ -191,13 +212,24 @@ public RxtxChannelConfig setAllocator(ByteBufAllocator allocator) {
         return (RxtxChannelConfig) super.setAllocator(allocator);
     }
 
+    @Override
+    public RxtxChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
     @Override
     public RxtxChannelConfig setAutoRead(boolean autoRead) {
         return (RxtxChannelConfig) super.setAutoRead(autoRead);
     }
 
     @Override
-    public RxtxChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        return (RxtxChannelConfig) super.setDefaultHandlerByteBufType(type);
+    public RxtxChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        return (RxtxChannelConfig) super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
+    }
+
+    @Override
+    public RxtxChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        return (RxtxChannelConfig) super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
     }
 }
diff --git a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
index 382601bbf667..b386ac113fac 100644
--- a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java
@@ -18,6 +18,7 @@
 import gnu.io.SerialPort;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 
 /**
  * A configuration class for RXTX device connections.
@@ -258,6 +259,16 @@ public static Paritybit valueOf(int value) {
      */
     RxtxChannelConfig setWaitTimeMillis(int waitTimeMillis);
 
+    /**
+     * Sets the maximal time (in ms) to block while try to read from the serial port. Default is 1000ms
+     */
+    RxtxChannelConfig setReadTimeout(int readTimout);
+
+    /**
+     * Return the maximal time (in ms) to block and wait for something to be ready to read.
+     */
+    int getReadTimeout();
+
     @Override
     RxtxChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
 
@@ -268,8 +279,8 @@ public static Paritybit valueOf(int value) {
     RxtxChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    RxtxChannelConfig setAutoRead(boolean autoRead);
+    RxtxChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    RxtxChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    RxtxChannelConfig setAutoRead(boolean autoRead);
 }
diff --git a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java
index 00c3780b2361..57bf250975bb 100644
--- a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java
+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java
@@ -45,6 +45,9 @@ public final class RxtxChannelOption<T> extends ChannelOption<T> {
     public static final RxtxChannelOption<Integer> WAIT_TIME =
             new RxtxChannelOption<Integer>("WAIT_TIME");
 
+    public static final RxtxChannelOption<Integer> READ_TIMEOUT =
+            new RxtxChannelOption<Integer>("READ_TIMEOUT");
+
     private RxtxChannelOption(String name) {
         super(name);
     }
diff --git a/transport-sctp/pom.xml b/transport-sctp/pom.xml
index 77d576538cca..9b908cb603d8 100644
--- a/transport-sctp/pom.xml
+++ b/transport-sctp/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-transport-sctp</artifactId>
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
index 687d9a3828e5..baeb008f5f69 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java
@@ -19,10 +19,10 @@
 import com.sun.nio.sctp.SctpChannel;
 import com.sun.nio.sctp.SctpStandardSocketOptions;
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.util.internal.PlatformDependent;
 
 import java.io.IOException;
@@ -186,13 +186,24 @@ public SctpChannelConfig setAllocator(ByteBufAllocator allocator) {
         return (SctpChannelConfig) super.setAllocator(allocator);
     }
 
+    @Override
+    public SctpChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
     @Override
     public SctpChannelConfig setAutoRead(boolean autoRead) {
         return (SctpChannelConfig) super.setAutoRead(autoRead);
     }
 
     @Override
-    public SctpChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        return (SctpChannelConfig) super.setDefaultHandlerByteBufType(type);
+    public SctpChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        return (SctpChannelConfig) super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
+    }
+
+    @Override
+    public SctpChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        return (SctpChannelConfig) super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
     }
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java
index f1e820bb02d4..055e6e842184 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java
@@ -20,6 +20,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.util.NetUtil;
 
 import java.io.IOException;
@@ -169,13 +170,24 @@ public SctpServerChannelConfig setAllocator(ByteBufAllocator allocator) {
         return (SctpServerChannelConfig) super.setAllocator(allocator);
     }
 
+    @Override
+    public SctpServerChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
     @Override
     public SctpServerChannelConfig setAutoRead(boolean autoRead) {
         return (SctpServerChannelConfig) super.setAutoRead(autoRead);
     }
 
     @Override
-    public SctpServerChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        return (SctpServerChannelConfig) super.setDefaultHandlerByteBufType(type);
+    public SctpServerChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        return (SctpServerChannelConfig) super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
+    }
+
+    @Override
+    public SctpServerChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        return (SctpServerChannelConfig) super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
     }
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
index 341a756f7899..7cb3da86f874 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java
@@ -15,10 +15,10 @@
  */
 package io.netty.channel.sctp;
 
+import com.sun.nio.sctp.SctpStandardSocketOptions.InitMaxStreams;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
-
-import static com.sun.nio.sctp.SctpStandardSocketOptions.*;
+import io.netty.channel.RecvByteBufAllocator;
 
 /**
  * A {@link ChannelConfig} for a {@link SctpChannel}.
@@ -106,8 +106,8 @@ public interface SctpChannelConfig extends ChannelConfig {
     SctpChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    SctpChannelConfig setAutoRead(boolean autoRead);
+    SctpChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    SctpChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    SctpChannelConfig setAutoRead(boolean autoRead);
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
index b3cebf8a9038..84b2c0350435 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
@@ -16,8 +16,8 @@
 package io.netty.channel.sctp;
 
 import com.sun.nio.sctp.MessageInfo;
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.buffer.DefaultByteBufHolder;
 
 /**
@@ -156,6 +156,6 @@ public String toString() {
         }
         return "SctpFrame{" +
                 "streamIdentifier=" + streamIdentifier + ", protocolIdentifier=" + protocolIdentifier +
-                ", data=" + BufUtil.hexDump(content()) + '}';
+                ", data=" + ByteBufUtil.hexDump(content()) + '}';
     }
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
index 26844dad7fb5..7527b46894e6 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java
@@ -15,10 +15,10 @@
  */
 package io.netty.channel.sctp;
 
+import com.sun.nio.sctp.SctpStandardSocketOptions.InitMaxStreams;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
-
-import static com.sun.nio.sctp.SctpStandardSocketOptions.*;
+import io.netty.channel.RecvByteBufAllocator;
 
 /**
  * A {@link ChannelConfig} for a {@link SctpServerChannelConfig}.
@@ -101,8 +101,8 @@ public interface SctpServerChannelConfig extends ChannelConfig {
     SctpServerChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    SctpServerChannelConfig setAutoRead(boolean autoRead);
+    SctpServerChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    SctpServerChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    SctpServerChannelConfig setAutoRead(boolean autoRead);
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
index 92f9555fd197..a2a42d31ffca 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java
@@ -19,14 +19,13 @@
 import com.sun.nio.sctp.MessageInfo;
 import com.sun.nio.sctp.NotificationHandler;
 import com.sun.nio.sctp.SctpChannel;
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.AbstractNioMessageChannel;
 import io.netty.channel.sctp.DefaultSctpChannelConfig;
 import io.netty.channel.sctp.SctpChannelConfig;
@@ -57,14 +56,13 @@
  * to understand what you need to do to use it. Also this feature is only supported on Java 7+.
  */
 public class NioSctpChannel extends AbstractNioMessageChannel implements io.netty.channel.sctp.SctpChannel {
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioSctpChannel.class);
 
     private final SctpChannelConfig config;
 
-    @SuppressWarnings("rawtypes")
-    private final NotificationHandler notificationHandler;
+    private final NotificationHandler<?> notificationHandler;
 
     private static SctpChannel newSctpChannel() {
         try {
@@ -259,9 +257,8 @@ protected void doClose() throws Exception {
         javaChannel().close();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
-    protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         SctpChannel ch = javaChannel();
         ByteBuf buffer = alloc().directBuffer(config().getReceiveBufferSize());
         boolean free = true;
@@ -287,8 +284,8 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
     }
 
     @Override
-    protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws Exception {
-        SctpMessage packet = (SctpMessage) buf.peek();
+    protected int doWriteMessages(MessageList<Object> msgs, int index, boolean lastSpin) throws Exception {
+        SctpMessage packet = (SctpMessage) msgs.get(index);
         ByteBuf data = packet.content();
         int dataLen = data.readableBytes();
         ByteBuffer nioData;
@@ -322,13 +319,10 @@ protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws E
             return 0;
         }
 
-        // Wrote a packet.
-        buf.remove();
-
         // packet was written free up buffer
         packet.release();
 
-        if (buf.isEmpty()) {
+        if (index + 1 == msgs.size()) {
             // Wrote the outbound buffer completely - clear OP_WRITE.
             if ((interestOps & SelectionKey.OP_WRITE) != 0) {
                 key.interestOps(interestOps & ~SelectionKey.OP_WRITE);
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
index a645b77a0c4e..c2e52bdc900f 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java
@@ -17,12 +17,11 @@
 
 import com.sun.nio.sctp.SctpChannel;
 import com.sun.nio.sctp.SctpServerChannel;
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.AbstractNioMessageChannel;
 import io.netty.channel.sctp.DefaultSctpServerChannelConfig;
 import io.netty.channel.sctp.SctpServerChannelConfig;
@@ -46,7 +45,7 @@
  */
 public class NioSctpServerChannel extends AbstractNioMessageChannel
         implements io.netty.channel.sctp.SctpServerChannel {
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private static SctpServerChannel newSocket() {
         try {
@@ -135,7 +134,7 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         SctpChannel ch = javaChannel().accept();
         if (ch == null) {
             return 0;
@@ -217,7 +216,7 @@ protected void doDisconnect() throws Exception {
     }
 
     @Override
-    protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws Exception {
+    protected int doWriteMessages(MessageList<Object> msgs, int index, boolean lastSpin) throws Exception {
         throw new UnsupportedOperationException();
     }
 }
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
index 72792f7a02f3..b818673285cd 100755
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java
@@ -19,14 +19,13 @@
 import com.sun.nio.sctp.MessageInfo;
 import com.sun.nio.sctp.NotificationHandler;
 import com.sun.nio.sctp.SctpChannel;
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.channel.oio.AbstractOioMessageChannel;
 import io.netty.channel.sctp.DefaultSctpChannelConfig;
 import io.netty.channel.sctp.SctpChannelConfig;
@@ -62,7 +61,7 @@ public class OioSctpChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(OioSctpChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private final SctpChannel ch;
     private final SctpChannelConfig config;
@@ -166,7 +165,7 @@ public boolean isOpen() {
     }
 
     @Override
-    protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         if (!readSelector.isOpen()) {
             return 0;
         }
@@ -213,17 +212,31 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
     }
 
     @Override
-    protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
         if (!writeSelector.isOpen()) {
-            return;
+            return 0;
         }
         final int selectedKeys = writeSelector.select(SO_TIMEOUT);
         if (selectedKeys > 0) {
             final Set<SelectionKey> writableKeys = writeSelector.selectedKeys();
-            for (SelectionKey ignored : writableKeys) {
-                SctpMessage packet = (SctpMessage) buf.poll();
+            if (writableKeys.isEmpty()) {
+                return 0;
+            }
+            Iterator<SelectionKey> writableKeysIt = writableKeys.iterator();
+            int written = 0;
+            int length = msgs.size() - index;
+
+            for (;;) {
+                if (written == length) {
+                    // all written
+                    return written;
+                }
+                writableKeysIt.next();
+                writableKeysIt.remove();
+
+                SctpMessage packet = (SctpMessage) msgs.get(index ++);
                 if (packet == null) {
-                    return;
+                    return written;
                 }
                 try {
                     ByteBuf data = packet.content();
@@ -243,12 +256,17 @@ protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
                     mi.streamNumber(packet.streamIdentifier());
 
                     ch.send(nioData, mi);
+                    written ++;
                 } finally {
                     packet.release();
                 }
+                if (!writableKeysIt.hasNext()) {
+                    return written;
+                }
             }
-            writableKeys.clear();
         }
+
+        return 0;
     }
 
     @Override
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
index 4f12c3ac227f..85b0d5b5145a 100755
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java
@@ -17,12 +17,12 @@
 
 import com.sun.nio.sctp.SctpChannel;
 import com.sun.nio.sctp.SctpServerChannel;
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.channel.oio.AbstractOioMessageChannel;
 import io.netty.channel.sctp.DefaultSctpServerChannelConfig;
 import io.netty.channel.sctp.SctpServerChannelConfig;
@@ -53,7 +53,7 @@ public class OioSctpServerChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(OioSctpServerChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private static SctpServerChannel newServerSocket() {
         try {
@@ -189,27 +189,32 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         if (!isActive()) {
             return -1;
         }
 
         SctpChannel s = null;
+        int acceptedChannels = 0;
         try {
             final int selectedKeys = selector.select(SO_TIMEOUT);
             if (selectedKeys > 0) {
-                final Set<SelectionKey> selectionKeys = selector.selectedKeys();
-                for (SelectionKey key : selectionKeys) {
-                   if (key.isAcceptable()) {
-                       s = sch.accept();
-                       if (s != null) {
-                           buf.add(new OioSctpChannel(this, null, s));
-                       }
-                   }
+                final Iterator<SelectionKey> selectionKeys = selector.selectedKeys().iterator();
+                for (;;) {
+                    SelectionKey key = selectionKeys.next();
+                    selectionKeys.remove();
+                    if (key.isAcceptable()) {
+                        s = sch.accept();
+                        if (s != null) {
+                            buf.add(new OioSctpChannel(this, null, s));
+                            acceptedChannels ++;
+                        }
+                    }
+                    if (!selectionKeys.hasNext()) {
+                        return acceptedChannels;
+                    }
                 }
-                return selectedKeys;
             }
-
         } catch (Throwable t) {
             logger.warn("Failed to create a new channel from an accepted sctp channel.", t);
             if (s != null) {
@@ -221,7 +226,7 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
             }
         }
 
-        return 0;
+        return acceptedChannels;
     }
 
     @Override
@@ -291,7 +296,11 @@ protected void doDisconnect() throws Exception {
     }
 
     @Override
-    protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
+        int size = msgs.size();
+        for (int i = index; i < size; i ++) {
+            ByteBufUtil.release(msgs.get(i));
+        }
         throw new UnsupportedOperationException();
     }
 }
diff --git a/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
index 209aad0d78d0..fb1e2bb59633 100644
--- a/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
+++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java
@@ -18,15 +18,16 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.sctp.SctpMessage;
 import io.netty.handler.codec.CodecException;
+import io.netty.handler.codec.MessageToMessageDecoder;
 
 /**
  * A ChannelHandler which receives {@link SctpMessage}s which belong to a application protocol form a specific
  * SCTP Stream  and decode it as {@link ByteBuf}.
  */
-public class SctpInboundByteStreamHandler extends ChannelInboundMessageHandlerAdapter<SctpMessage> {
+public class SctpInboundByteStreamHandler extends MessageToMessageDecoder<SctpMessage> {
     private final int protocolIdentifier;
     private final int streamIdentifier;
 
@@ -52,13 +53,11 @@ protected boolean acceptInboundMessage(SctpMessage msg) {
     }
 
     @Override
-    public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
+    protected void decode(ChannelHandlerContext ctx, SctpMessage msg, MessageList<Object> out) throws Exception {
         if (!msg.isComplete()) {
             throw new CodecException(String.format("Received SctpMessage is not complete, please add %s in the " +
                     "pipeline before this handler", SctpMessageCompletionHandler.class.getSimpleName()));
         }
-
-        ctx.nextInboundByteBuffer().writeBytes(msg.content());
-        ctx.fireInboundBufferUpdated();
+        out.add(msg.content().retain());
     }
 }
diff --git a/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java
index e84e31f26040..355d36e07640 100644
--- a/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java
+++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java
@@ -19,47 +19,30 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.MessageList;
 import io.netty.channel.sctp.SctpMessage;
+import io.netty.handler.codec.MessageToMessageDecoder;
 
 import java.util.HashMap;
 import java.util.Map;
 
 /**
- * {@link ChannelInboundMessageHandlerAdapter} which will take care of handle fragmented {@link SctpMessage}s, so
+ * {@link MessageToMessageDecoder} which will take care of handle fragmented {@link SctpMessage}s, so
  * only <strong>complete</strong> {@link SctpMessage}s will be forwarded to the next
- * {@link ChannelInboundMessageHandler}.
+ * {@link ChannelInboundHandler}.
  */
-public class SctpMessageCompletionHandler extends ChannelInboundMessageHandlerAdapter<SctpMessage> {
+public class SctpMessageCompletionHandler extends MessageToMessageDecoder<SctpMessage> {
     private final Map<Integer, ByteBuf> fragments = new HashMap<Integer, ByteBuf>();
-    private boolean assembled;
 
     @Override
-    public boolean beginMessageReceived(ChannelHandlerContext ctx) throws Exception {
-        assembled = false;
-        return super.beginMessageReceived(ctx);
-    }
-
-    @Override
-    public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
-        if (assembled) {
-            assembled = false;
-            ctx.fireInboundBufferUpdated();
-        }
-        super.endMessageReceived(ctx);
-    }
-
-    @Override
-    public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws Exception {
-
+    protected void decode(ChannelHandlerContext ctx, SctpMessage msg, MessageList<Object> out) throws Exception {
         final ByteBuf byteBuf = msg.content();
         final int protocolIdentifier = msg.protocolIdentifier();
         final int streamIdentifier = msg.streamIdentifier();
         final boolean isComplete = msg.isComplete();
 
         ByteBuf frag;
-
         if (fragments.containsKey(streamIdentifier)) {
             frag = fragments.remove(streamIdentifier);
         } else {
@@ -68,7 +51,7 @@ public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws E
 
         if (isComplete && !frag.isReadable()) {
             //data chunk is not fragmented
-            handleAssembledMessage(ctx, msg);
+            out.add(msg);
         } else if (!isComplete && frag.isReadable()) {
             //more message to complete
             fragments.put(streamIdentifier, Unpooled.wrappedBuffer(frag, byteBuf));
@@ -79,17 +62,11 @@ public void messageReceived(ChannelHandlerContext ctx, SctpMessage msg) throws E
                     protocolIdentifier,
                     streamIdentifier,
                     Unpooled.wrappedBuffer(frag, byteBuf));
-            handleAssembledMessage(ctx, assembledMsg);
+            out.add(assembledMsg);
         } else {
             //first incomplete message
             fragments.put(streamIdentifier, byteBuf);
         }
-
         byteBuf.retain();
     }
-
-    private void handleAssembledMessage(ChannelHandlerContext ctx, SctpMessage assembledMsg) {
-        ctx.nextInboundMessageBuffer().add(assembledMsg);
-        assembled = true;
-    }
 }
diff --git a/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpOutboundByteStreamHandler.java b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpOutboundByteStreamHandler.java
index f4ff1cfc79ac..09e7bbf803f4 100644
--- a/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpOutboundByteStreamHandler.java
+++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpOutboundByteStreamHandler.java
@@ -16,20 +16,17 @@
 package io.netty.handler.codec.sctp;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelOutboundByteHandlerAdapter;
-import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
 import io.netty.channel.sctp.SctpMessage;
-import io.netty.handler.codec.EncoderException;
+import io.netty.handler.codec.MessageToMessageEncoder;
 
 /**
  * A ChannelHandler which transform {@link ByteBuf} to {@link SctpMessage}  and send it through a specific stream
  * with given protocol identifier.
  *
  */
-public class SctpOutboundByteStreamHandler extends ChannelOutboundByteHandlerAdapter {
+public class SctpOutboundByteStreamHandler extends MessageToMessageEncoder<ByteBuf> {
     private final int streamIdentifier;
     private final int protocolIdentifier;
 
@@ -43,16 +40,7 @@ public SctpOutboundByteStreamHandler(int streamIdentifier, int protocolIdentifie
     }
 
     @Override
-    protected void flush(ChannelHandlerContext ctx, ByteBuf in, ChannelPromise promise) throws Exception {
-        try {
-            MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-            ByteBuf payload = Unpooled.buffer(in.readableBytes());
-            payload.writeBytes(in);
-            out.add(new SctpMessage(streamIdentifier, protocolIdentifier, payload));
-        } catch (Throwable t) {
-            ctx.fireExceptionCaught(new EncoderException(t));
-        }
-
-        ctx.flush(promise);
+    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, MessageList<Object> out) throws Exception {
+        out.add(new SctpMessage(streamIdentifier, protocolIdentifier, msg.retain()));
     }
 }
diff --git a/transport-udt/pom.xml b/transport-udt/pom.xml
index a8a48ffaa944..56b0bf78c3e4 100644
--- a/transport-udt/pom.xml
+++ b/transport-udt/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-transport-udt</artifactId>
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
index fb5ca654cf3e..5495f9792b85 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java
@@ -19,9 +19,9 @@
 import com.barchart.udt.SocketUDT;
 import com.barchart.udt.nio.ChannelUDT;
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 
 import java.io.IOException;
 import java.util.Map;
@@ -250,6 +250,12 @@ public UdtChannelConfig setAllocator(ByteBufAllocator allocator) {
         return this;
     }
 
+    @Override
+    public UdtChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
     @Override
     public UdtChannelConfig setAutoRead(boolean autoRead) {
         super.setAutoRead(autoRead);
@@ -257,8 +263,12 @@ public UdtChannelConfig setAutoRead(boolean autoRead) {
     }
 
     @Override
-    public UdtChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        super.setDefaultHandlerByteBufType(type);
-        return this;
+    public UdtChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        return (UdtChannelConfig) super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
+    }
+
+    @Override
+    public UdtChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        return (UdtChannelConfig) super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
     }
 }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java
index 315eb9203353..8437db011f63 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java
@@ -18,6 +18,7 @@
 import com.barchart.udt.nio.ChannelUDT;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
 
 import java.io.IOException;
 import java.util.Map;
@@ -153,14 +154,14 @@ public UdtServerChannelConfig setAllocator(ByteBufAllocator allocator) {
     }
 
     @Override
-    public UdtServerChannelConfig setAutoRead(boolean autoRead) {
-        super.setAutoRead(autoRead);
+    public UdtServerChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
         return this;
     }
 
     @Override
-    public UdtServerChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        super.setDefaultHandlerByteBufType(type);
+    public UdtServerChannelConfig setAutoRead(boolean autoRead) {
+        super.setAutoRead(autoRead);
         return this;
     }
 }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java b/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java
index 9bf0e50764d2..aa671933e696 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java
@@ -21,6 +21,7 @@
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
 
 /**
  * A {@link ChannelConfig} for a {@link UdtChannel}.
@@ -119,6 +120,9 @@ public interface UdtChannelConfig extends ChannelConfig {
     @Override
     UdtChannelConfig setAllocator(ByteBufAllocator allocator);
 
+    @Override
+    UdtChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
+
     @Override
     UdtChannelConfig setAutoRead(boolean autoRead);
 
@@ -161,7 +165,4 @@ public interface UdtChannelConfig extends ChannelConfig {
      * Sets {@link OptionUDT#System_Send_Buffer_Size}
      */
     UdtChannelConfig setSystemSendBufferSize(int size);
-
-    @Override
-    UdtChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java b/transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java
index 4b0666fcfb2b..6b1625f7b072 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtServerChannelConfig.java
@@ -21,6 +21,7 @@
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
 
 /**
  * A {@link ChannelConfig} for a {@link UdtServerChannel}.
@@ -53,6 +54,9 @@ public interface UdtServerChannelConfig extends UdtChannelConfig {
     @Override
     UdtServerChannelConfig setAllocator(ByteBufAllocator allocator);
 
+    @Override
+    UdtServerChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
+
     @Override
     UdtServerChannelConfig setAutoRead(boolean autoRead);
 
@@ -79,7 +83,4 @@ public interface UdtServerChannelConfig extends UdtChannelConfig {
 
     @Override
     UdtServerChannelConfig setSystemSendBufferSize(int size);
-
-    @Override
-    UdtServerChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
 }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java
index 9d247d3557a0..95ddff433943 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java
@@ -17,8 +17,8 @@
 
 import com.barchart.udt.TypeUDT;
 import com.barchart.udt.nio.ServerSocketChannelUDT;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelException;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.AbstractNioMessageChannel;
 import io.netty.channel.udt.DefaultUdtServerChannelConfig;
 import io.netty.channel.udt.UdtServerChannel;
@@ -95,8 +95,7 @@ protected void doFinishConnect() throws Exception {
     }
 
     @Override
-    protected int doWriteMessages(final MessageBuf<Object> buf,
-            final boolean lastSpin) throws Exception {
+    protected int doWriteMessages(MessageList<Object> msg, int index, boolean lastSpin) throws Exception {
         throw new UnsupportedOperationException();
     }
 
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteAcceptorChannel.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteAcceptorChannel.java
index 185b3cb5fc9c..09fe795441dc 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteAcceptorChannel.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteAcceptorChannel.java
@@ -17,30 +17,27 @@
 
 import com.barchart.udt.TypeUDT;
 import com.barchart.udt.nio.SocketChannelUDT;
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelMetadata;
+import io.netty.channel.MessageList;
 
 /**
  * Byte Channel Acceptor for UDT Streams.
  */
 public class NioUdtByteAcceptorChannel extends NioUdtAcceptorChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(
-            BufType.BYTE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     public NioUdtByteAcceptorChannel() {
         super(TypeUDT.STREAM);
     }
 
     @Override
-    protected int doReadMessages(final MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         final SocketChannelUDT channelUDT = javaChannel().accept();
         if (channelUDT == null) {
             return 0;
         } else {
-            buf.add(new NioUdtByteConnectorChannel(this, channelUDT.socketUDT()
-                    .id(), channelUDT));
+            buf.add(new NioUdtByteConnectorChannel(this, channelUDT.socketUDT().id(), channelUDT));
             return 1;
         }
     }
@@ -49,5 +46,4 @@ protected int doReadMessages(final MessageBuf<Object> buf) throws Exception {
     public ChannelMetadata metadata() {
         return METADATA;
     }
-
 }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
index f2d82c6fd21c..8ce766a5408c 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
@@ -17,11 +17,11 @@
 
 import com.barchart.udt.TypeUDT;
 import com.barchart.udt.nio.SocketChannelUDT;
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelMetadata;
+import io.netty.channel.FileRegion;
 import io.netty.channel.nio.AbstractNioByteChannel;
 import io.netty.channel.udt.DefaultUdtChannelConfig;
 import io.netty.channel.udt.UdtChannel;
@@ -31,7 +31,6 @@
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
-import java.nio.channels.SelectionKey;
 
 import static java.nio.channels.SelectionKey.*;
 
@@ -44,8 +43,7 @@ public class NioUdtByteConnectorChannel extends AbstractNioByteChannel
     private static final InternalLogger logger = InternalLoggerFactory
             .getInstance(NioUdtByteConnectorChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(
-            BufType.BYTE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private final UdtChannelConfig config;
 
@@ -144,28 +142,18 @@ protected int doReadBytes(final ByteBuf byteBuf) throws Exception {
     }
 
     @Override
-    protected int doWriteBytes(final ByteBuf byteBuf, final boolean lastSpin)
-            throws Exception {
-        final int pendingBytes = byteBuf.readableBytes();
-        final int writtenBytes = byteBuf.readBytes(javaChannel(), pendingBytes);
-        final SelectionKey key = selectionKey();
-        final int interestOps = key.interestOps();
-        if (writtenBytes >= pendingBytes) {
-            // wrote the buffer completely - clear OP_WRITE.
-            if ((interestOps & OP_WRITE) != 0) {
-                key.interestOps(interestOps & ~OP_WRITE);
-            }
-        } else {
-            // wrote partial or nothing - ensure OP_WRITE
-            if (writtenBytes > 0 || lastSpin) {
-                if ((interestOps & OP_WRITE) == 0) {
-                    key.interestOps(interestOps | OP_WRITE);
-                }
-            }
-        }
+    protected int doWriteBytes(final ByteBuf byteBuf, final boolean lastSpin) throws Exception {
+        final int expectedWrittenBytes = byteBuf.readableBytes();
+        final int writtenBytes = byteBuf.readBytes(javaChannel(), expectedWrittenBytes);
+        updateOpWrite(expectedWrittenBytes, writtenBytes, lastSpin);
         return writtenBytes;
     }
 
+    @Override
+    protected long doWriteFileRegion(FileRegion region, boolean lastSpin) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
     @Override
     public boolean isActive() {
         final SocketChannelUDT channelUDT = javaChannel();
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageAcceptorChannel.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageAcceptorChannel.java
index 12c0e63a1ec9..0ccb78592477 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageAcceptorChannel.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageAcceptorChannel.java
@@ -17,30 +17,27 @@
 
 import com.barchart.udt.TypeUDT;
 import com.barchart.udt.nio.SocketChannelUDT;
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelMetadata;
+import io.netty.channel.MessageList;
 
 /**
  * Message Channel Acceptor for UDT Datagrams.
  */
 public class NioUdtMessageAcceptorChannel extends NioUdtAcceptorChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(
-            BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     public NioUdtMessageAcceptorChannel() {
         super(TypeUDT.DATAGRAM);
     }
 
     @Override
-    protected int doReadMessages(final MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         final SocketChannelUDT channelUDT = javaChannel().accept();
         if (channelUDT == null) {
             return 0;
         } else {
-            buf.add(new NioUdtMessageConnectorChannel(this, channelUDT
-                    .socketUDT().id(), channelUDT));
+            buf.add(new NioUdtMessageConnectorChannel(this, channelUDT.socketUDT().id(), channelUDT));
             return 1;
         }
     }
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java
index c8cd60879ad7..c1fb1d39f5ac 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java
@@ -17,12 +17,11 @@
 
 import com.barchart.udt.TypeUDT;
 import com.barchart.udt.nio.SocketChannelUDT;
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelMetadata;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.AbstractNioMessageChannel;
 import io.netty.channel.udt.DefaultUdtChannelConfig;
 import io.netty.channel.udt.UdtChannel;
@@ -48,8 +47,7 @@ public class NioUdtMessageConnectorChannel extends AbstractNioMessageChannel
     private static final InternalLogger logger = InternalLoggerFactory
             .getInstance(NioUdtMessageConnectorChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(
-            BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private final UdtChannelConfig config;
 
@@ -143,7 +141,7 @@ protected void doFinishConnect() throws Exception {
     }
 
     @Override
-    protected int doReadMessages(final MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
 
         final int maximumMessageSize = config.getReceiveBufferSize();
 
@@ -171,11 +169,9 @@ protected int doReadMessages(final MessageBuf<Object> buf) throws Exception {
     }
 
     @Override
-    protected int doWriteMessages(final MessageBuf<Object> messageQueue,
-            final boolean lastSpin) throws Exception {
-
+    protected int doWriteMessages(MessageList<Object> msgs, int index, boolean lastSpin) throws Exception {
         // expects a message
-        final UdtMessage message = (UdtMessage) messageQueue.peek();
+        final UdtMessage message = (UdtMessage) msgs.get(index);
 
         final ByteBuf byteBuf = message.content();
 
@@ -208,14 +204,12 @@ protected int doWriteMessages(final MessageBuf<Object> messageQueue,
         }
 
         // wrote the message queue completely - clear OP_WRITE.
-        if (messageQueue.isEmpty()) {
+        if (index + 1 == msgs.size()) {
             if ((interestOps & OP_WRITE) != 0) {
                 key.interestOps(interestOps & ~OP_WRITE);
             }
         }
 
-        messageQueue.remove();
-
         message.release();
 
         return 1;
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
index 191060034673..260187c5d1ef 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java
@@ -16,7 +16,6 @@
 
 package io.netty.test.udt.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.udt.nio.NioUdtByteAcceptorChannel;
 import org.junit.Test;
 
@@ -29,6 +28,6 @@ public class NioUdtByteAcceptorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.BYTE, new NioUdtByteAcceptorChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtByteAcceptorChannel().metadata().hasDisconnect());
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
index 45c197bc86cd..6426ca69ada7 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java
@@ -16,11 +16,10 @@
 
 package io.netty.test.udt.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.udt.nio.NioUdtByteConnectorChannel;
 import org.junit.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
 
@@ -29,6 +28,6 @@ public class NioUdtByteConnectorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.BYTE, new NioUdtByteConnectorChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtByteConnectorChannel().metadata().hasDisconnect());
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java
index dd9fe080c5f4..8275ef4629e5 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java
@@ -19,7 +19,6 @@
 import com.yammer.metrics.Metrics;
 import com.yammer.metrics.core.Meter;
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.nio.NioUdtByteRendezvousChannel;
@@ -45,7 +44,7 @@ public class NioUdtByteRendezvousChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.BYTE, new NioUdtByteRendezvousChannel().metadata().bufferType());
+        assertFalse(new NioUdtByteRendezvousChannel().metadata().hasDisconnect());
     }
 
     /**
@@ -115,5 +114,8 @@ public void basicEcho() throws Exception {
 
         group1.shutdownGracefully();
         group2.shutdownGracefully();
+
+        group1.terminationFuture().sync();
+        group2.terminationFuture().sync();
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
index e7bdfe8089b5..a3099a8be194 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageAcceptorChannelTest.java
@@ -16,7 +16,6 @@
 
 package io.netty.test.udt.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.udt.nio.NioUdtMessageAcceptorChannel;
 import org.junit.Test;
 
@@ -29,6 +28,6 @@ public class NioUdtMessageAcceptorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.MESSAGE, new NioUdtMessageAcceptorChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtMessageAcceptorChannel().metadata().hasDisconnect());
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
index 4d5d7fe4730a..8c2e2df588f7 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageConnectorChannelTest.java
@@ -16,7 +16,6 @@
 
 package io.netty.test.udt.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.channel.udt.nio.NioUdtMessageConnectorChannel;
 import org.junit.Test;
 
@@ -29,6 +28,6 @@ public class NioUdtMessageConnectorChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.MESSAGE, new NioUdtMessageConnectorChannel().metadata().bufferType());
+        assertEquals(false, new NioUdtMessageConnectorChannel().metadata().hasDisconnect());
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageRendezvousChannelTest.java b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageRendezvousChannelTest.java
index 073943eb0d5d..082517b7ab89 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageRendezvousChannelTest.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageRendezvousChannelTest.java
@@ -19,7 +19,6 @@
 import com.yammer.metrics.Metrics;
 import com.yammer.metrics.core.Meter;
 import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.BufType;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.udt.nio.NioUdtMessageRendezvousChannel;
@@ -45,7 +44,7 @@ public class NioUdtMessageRendezvousChannelTest extends AbstractUdtTest {
      */
     @Test
     public void metadata() throws Exception {
-        assertEquals(BufType.MESSAGE, new NioUdtMessageRendezvousChannel().metadata().bufferType());
+        assertFalse(new NioUdtMessageRendezvousChannel().metadata().hasDisconnect());
     }
 
     /**
@@ -109,5 +108,8 @@ public void basicEcho() throws Exception {
 
         group1.shutdownGracefully();
         group2.shutdownGracefully();
+
+        group1.terminationFuture().sync();
+        group2.terminationFuture().sync();
     }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/util/EchoByteHandler.java b/transport-udt/src/test/java/io/netty/test/udt/util/EchoByteHandler.java
index ebaed66ea4dc..ab839cd103d5 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/util/EchoByteHandler.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/util/EchoByteHandler.java
@@ -20,9 +20,8 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandlerAdapter;
-import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.udt.nio.NioUdtProvider;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -32,7 +31,7 @@
  * traffic between the echo client and server by sending the first message to
  * the server on activation.
  */
-public class EchoByteHandler extends ChannelInboundByteHandlerAdapter {
+public class EchoByteHandler extends ChannelInboundHandlerAdapter {
 
     private static final InternalLogger log = InternalLoggerFactory.getInstance(EchoByteHandler.class);
 
@@ -62,25 +61,18 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
                 .toStringOptions());
 
         ctx.write(message);
-
-        ctx.flush();
     }
 
     @Override
-    public void inboundBufferUpdated(final ChannelHandlerContext ctx,
-            final ByteBuf in) {
-
-        if (meter != null) {
-            meter.mark(in.readableBytes());
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i ++) {
+            ByteBuf buf = (ByteBuf) msgs.get(i);
+            if (meter != null) {
+                meter.mark(buf.readableBytes());
+            }
+            buf.retain();
         }
-
-        final ByteBuf out = ctx.nextOutboundByteBuffer();
-
-        out.discardReadBytes(); // FIXME
-
-        out.writeBytes(in);
-
-        ctx.flush();
+        ctx.write(msgs);
     }
 
     @Override
@@ -91,10 +83,4 @@ public void exceptionCaught(final ChannelHandlerContext ctx,
 
         ctx.close();
     }
-
-    @Override
-    public ByteBuf newInboundBuffer(final ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx,
-                ctx.channel().config().getOption(ChannelOption.SO_RCVBUF));
-    }
 }
diff --git a/transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java b/transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java
index 7fa2c27f3fce..5ed41a28f472 100644
--- a/transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java
+++ b/transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java
@@ -18,10 +18,10 @@
 
 import com.yammer.metrics.core.Meter;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import io.netty.channel.udt.UdtMessage;
 import io.netty.channel.udt.nio.NioUdtProvider;
 import io.netty.util.internal.logging.InternalLogger;
@@ -32,8 +32,7 @@
  * between the echo peers by sending the first message to the other peer on
  * activation.
  */
-public class EchoMessageHandler extends
-        ChannelInboundMessageHandlerAdapter<UdtMessage> {
+public class EchoMessageHandler extends ChannelInboundHandlerAdapter {
 
     private static final InternalLogger log = InternalLoggerFactory.getInstance(EchoMessageHandler.class);
 
@@ -61,11 +60,7 @@ public void channelActive(final ChannelHandlerContext ctx) throws Exception {
 
         log.info("ECHO active {}", NioUdtProvider.socketUDT(ctx.channel())
                 .toStringOptions());
-
-        final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-
-        out.add(message);
-        ctx.flush();
+        ctx.write(message);
     }
 
     @Override
@@ -75,18 +70,13 @@ public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable e)
     }
 
     @Override
-    public void messageReceived(final ChannelHandlerContext ctx, final UdtMessage message) throws Exception {
-
-        final ByteBuf byteBuf = message.content();
-
-        if (meter != null) {
-            meter.mark(byteBuf.readableBytes());
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        for (int i = 0; i < msgs.size(); i ++) {
+            UdtMessage udtMsg = (UdtMessage) msgs.get(i);
+            if (meter != null) {
+                meter.mark(udtMsg.content().readableBytes());
+            }
         }
-
-        final MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-
-        message.retain();
-        out.add(message);
-        ctx.flush();
+        ctx.write(msgs);
     }
 }
diff --git a/transport/pom.xml b/transport/pom.xml
index 7d2895d77530..c3084299bdbb 100644
--- a/transport/pom.xml
+++ b/transport/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.0.0.CR3</version>
+    <version>4.0.0.CR4</version>
   </parent>
 
   <artifactId>netty-transport</artifactId>
diff --git a/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
index b767a67f9548..9565274561f6 100644
--- a/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
@@ -364,7 +364,10 @@ final ChannelHandler handler() {
         return handler;
     }
 
-    final EventLoopGroup group() {
+    /**
+     * Return the configured {@link EventLoopGroup} or {@code null} if non is configured yet.
+     */
+    public final EventLoopGroup group() {
         return group;
     }
 
diff --git a/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
index 9835c15ea248..b6d51873d9e1 100644
--- a/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
+++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
@@ -15,18 +15,16 @@
  */
 package io.netty.bootstrap;
 
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelStateHandlerAdapter;
 import io.netty.channel.EventLoopGroup;
+import io.netty.channel.MessageList;
 import io.netty.channel.ServerChannel;
 import io.netty.channel.socket.SocketChannel;
 import io.netty.util.AttributeKey;
@@ -138,6 +136,14 @@ public ServerBootstrap childHandler(ChannelHandler childHandler) {
         return this;
     }
 
+    /**
+     * Return the configured {@link EventLoopGroup} which will be used for the child channels or {@code null}
+     * if non is configured yet.
+     */
+    public EventLoopGroup childGroup() {
+        return childGroup;
+    }
+
     @Override
     void init(Channel channel) throws Exception {
         final Map<ChannelOption<?>, Object> options = options();
@@ -212,8 +218,7 @@ private static Entry<AttributeKey<?>, Object>[] newAttrArray(int size) {
         return new Entry[size];
     }
 
-    private static class ServerBootstrapAcceptor
-            extends ChannelStateHandlerAdapter implements ChannelInboundMessageHandler<Channel> {
+    private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapter {
 
         private final EventLoopGroup childGroup;
         private final ChannelHandler childHandler;
@@ -230,21 +235,12 @@ private static class ServerBootstrapAcceptor
             this.childAttrs = childAttrs;
         }
 
-        @Override
-        public MessageBuf<Channel> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
         @Override
         @SuppressWarnings("unchecked")
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) {
-            MessageBuf<Channel> in = ctx.inboundMessageBuffer();
-            for (;;) {
-                Channel child = in.poll();
-                if (child == null) {
-                    break;
-                }
-
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) {
+            int size = msgs.size();
+            for (int i = 0; i < size; i ++) {
+                Channel child = (Channel) msgs.get(i);
                 child.pipeline().addLast(childHandler);
 
                 for (Entry<ChannelOption<?>, Object> e: childOptions) {
diff --git a/transport/src/main/java/io/netty/channel/AbstractChannel.java b/transport/src/main/java/io/netty/channel/AbstractChannel.java
index f6cb4c4e87a6..c7f1a7c5364b 100644
--- a/transport/src/main/java/io/netty/channel/AbstractChannel.java
+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java
@@ -15,10 +15,10 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufHolder;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.util.DefaultAttributeMap;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
@@ -78,12 +78,12 @@ private static Integer allocateId(Channel channel) {
     private final Integer id;
     private final Unsafe unsafe;
     private final DefaultChannelPipeline pipeline;
+    private final ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer(this);
     private final ChannelFuture succeededFuture = new SucceededChannelFuture(this, null);
-    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this);
+    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);
+    private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);
     private final CloseFuture closeFuture = new CloseFuture(this);
 
-    protected final ChannelFlushPromiseNotifier flushFutureNotifier = new ChannelFlushPromiseNotifier();
-
     private volatile SocketAddress localAddress;
     private volatile SocketAddress remoteAddress;
     private volatile EventLoop eventLoop;
@@ -92,7 +92,6 @@ private static Integer allocateId(Channel channel) {
     private ClosedChannelException closedChannelException;
     private boolean inFlushNow;
     private boolean flushNowPending;
-    private FlushTask flushTaskInProgress;
 
     /** Cache for the string representation of this channel */
     private boolean strValActive;
@@ -133,6 +132,11 @@ public void operationComplete(ChannelFuture future) {
         });
     }
 
+    @Override
+    public boolean isWritable() {
+        return outboundBuffer.getWritable();
+    }
+
     @Override
     public final Integer id() {
         return id;
@@ -237,13 +241,13 @@ public ChannelFuture deregister() {
     }
 
     @Override
-    public ChannelFuture flush() {
-        return pipeline.flush();
+    public ChannelFuture write(Object msg) {
+        return pipeline.write(msg);
     }
 
     @Override
-    public ChannelFuture write(Object message) {
-        return pipeline.write(message);
+    public ChannelFuture write(MessageList<?> msgs) {
+        return pipeline.write(msgs);
     }
 
     @Override
@@ -276,30 +280,19 @@ public ChannelFuture deregister(ChannelPromise promise) {
         return pipeline.deregister(promise);
     }
 
-    @Override
-    public ByteBuf outboundByteBuffer() {
-        return pipeline.outboundByteBuffer();
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public <T> MessageBuf<T> outboundMessageBuffer() {
-        return pipeline.outboundMessageBuffer();
-    }
-
     @Override
     public void read() {
         pipeline.read();
     }
 
     @Override
-    public ChannelFuture flush(ChannelPromise promise) {
-        return pipeline.flush(promise);
+    public ChannelFuture write(Object msg, ChannelPromise promise) {
+        return pipeline.write(msg, promise);
     }
 
     @Override
-    public ChannelFuture write(Object message, ChannelPromise promise) {
-        return pipeline.write(message, promise);
+    public ChannelFuture write(MessageList<?> msgs, ChannelPromise promise) {
+        return pipeline.write(msgs, promise);
     }
 
     @Override
@@ -332,45 +325,6 @@ public Unsafe unsafe() {
         return unsafe;
     }
 
-    @Override
-    public ChannelFuture sendFile(FileRegion region) {
-        return pipeline.sendFile(region);
-    }
-
-    @Override
-    public ChannelFuture sendFile(FileRegion region, ChannelPromise promise) {
-        return pipeline.sendFile(region, promise);
-    }
-
-    // 0 - not expanded because the buffer is writable
-    // 1 - expanded because the buffer was not writable
-    // 2 - could not expand because the buffer was at its maximum although the buffer is not writable.
-    protected static int expandReadBuffer(ByteBuf byteBuf) {
-        final int writerIndex = byteBuf.writerIndex();
-        final int capacity = byteBuf.capacity();
-        if (capacity != writerIndex) {
-            return 0;
-        }
-
-        final int maxCapacity = byteBuf.maxCapacity();
-        if (capacity == maxCapacity) {
-            return 2;
-        }
-
-        // FIXME: Magic number
-        final int increment = 4096;
-
-        if (writerIndex + increment > maxCapacity) {
-            // Expand to maximum capacity.
-            byteBuf.capacity(maxCapacity);
-        } else {
-            // Expand by the increment.
-            byteBuf.ensureWritable(increment);
-        }
-
-        return 1;
-    }
-
     /**
      * Create a new {@link AbstractUnsafe} instance which will be used for the life-time of the {@link Channel}
      */
@@ -442,164 +396,19 @@ public final ChannelPromise voidPromise() {
         return voidPromise;
     }
 
-    /**
-     * Task which will flush a {@link FileRegion}
-     */
-    protected final class FlushTask {
-        private final FileRegion region;
-        private final ChannelPromise promise;
-        private FlushTask next;
-        private final AbstractUnsafe unsafe;
-
-        FlushTask(AbstractUnsafe unsafe, FileRegion region, ChannelPromise promise) {
-            this.region = region;
-            this.promise = promise;
-            this.unsafe = unsafe;
-        }
-
-        /**
-         * Mark the task as success. Multiple calls if this will throw a {@link IllegalStateException}.
-         *
-         * This also will call {@link FileRegion#release()}.
-         */
-        public void setSuccess() {
-            if (eventLoop().inEventLoop()) {
-                promise.setSuccess();
-                complete();
-            } else {
-                eventLoop().execute(new Runnable() {
-                    @Override
-                    public void run() {
-                        setSuccess();
-                    }
-                });
-            }
-        }
-
-        /**
-         * Notify the task of progress in transfer of the {@link FileRegion}.
-         */
-        public void setProgress(long progress) {
-            if (promise instanceof ChannelProgressivePromise) {
-                ((ChannelProgressivePromise) promise).setProgress(progress, region.count());
-            }
-        }
-
-        /**
-         * Mark the task as failure. Multiple calls if this will throw a {@link IllegalStateException}.
-         *
-         * This also will call {@link FileRegion#release()}.
-         */
-        public void setFailure(final Throwable cause) {
-            if (eventLoop().inEventLoop()) {
-                promise.setFailure(cause);
-                complete();
-            } else {
-                eventLoop().execute(new Runnable() {
-                    @Override
-                    public void run() {
-                        setFailure(cause);
-                    }
-                });
-            }
-        }
-
-        /**
-         * Return the {@link FileRegion} which should be flushed
-         */
-        public FileRegion region() {
-            return region;
-        }
-
-        private void complete() {
-            region.release();
-            flushTaskInProgress = next;
-            if (next != null) {
-                try {
-                    FileRegion region = next.region;
-                    if (region == null) {
-                        // no region present means the next flush task was to directly flush
-                        // the outbound buffer
-                        unsafe.flushNotifierAndFlush(next.promise);
-                    } else {
-                        // flush the region now
-                        doFlushFileRegion(next);
-                    }
-                } catch (Throwable cause) {
-                    next.promise.setFailure(cause);
-                }
-            } else {
-                // notify the flush futures
-                flushFutureNotifier.notifyFlushFutures();
-            }
-        }
-    }
-
     /**
      * {@link Unsafe} implementation which sub-classes must extend and use.
      */
     protected abstract class AbstractUnsafe implements Unsafe {
 
-        private final Runnable beginReadTask = new Runnable() {
-            @Override
-            public void run() {
-                beginRead();
-            }
-        };
-
         private final Runnable flushLaterTask = new Runnable() {
             @Override
             public void run() {
                 flushNowPending = false;
-                flush(voidPromise());
+                flush();
             }
         };
 
-        @Override
-        public final void sendFile(final FileRegion region, final ChannelPromise promise) {
-            if (outboundBufSize() > 0) {
-                flushNotifier(newPromise()).addListener(new ChannelFutureListener() {
-                    @Override
-                    public void operationComplete(ChannelFuture cf) throws Exception {
-                        sendFile0(region, promise);
-                    }
-                });
-            } else {
-                // nothing pending try to send the fileRegion now!
-                sendFile0(region, promise);
-            }
-        }
-
-        private void sendFile0(FileRegion region, ChannelPromise promise) {
-            FlushTask task = flushTaskInProgress;
-            if (task == null) {
-                flushTaskInProgress = task = new FlushTask(this, region, promise);
-                try {
-                    // the first FileRegion to flush so trigger it now!
-                    doFlushFileRegion(task);
-                } catch (Throwable cause) {
-                    region.release();
-                    promise.setFailure(cause);
-                }
-                return;
-            }
-
-            for (;;) {
-                FlushTask next = task.next;
-                if (next == null) {
-                    break;
-                }
-                task = next;
-            }
-            // there is something that needs to get flushed first so add it as next in the chain
-            task.next = new FlushTask(this, region, promise);
-        }
-
-        @Override
-        public final ChannelHandlerContext headContext() {
-            return pipeline.head;
-        }
-
         @Override
         public final SocketAddress localAddress() {
             return localAddress0();
@@ -744,7 +553,10 @@ public final void close(final ChannelPromise promise) {
                     closedChannelException = new ClosedChannelException();
                 }
 
-                flushFutureNotifier.notifyFlushFutures(closedChannelException);
+                // fail all queued messages
+                if (outboundBuffer.next()) {
+                    outboundBuffer.fail(closedChannelException);
+                }
 
                 if (wasActive && !isActive()) {
                     invokeLater(new Runnable() {
@@ -826,48 +638,12 @@ public void run() {
         }
 
         @Override
-        public void flush(final ChannelPromise promise) {
-            FlushTask task = flushTaskInProgress;
-            if (task == null) {
-                flushNotifierAndFlush(promise);
-            } else {
-                // loop over the tasks to find the last one
-                for (;;) {
-                    FlushTask t = task.next;
-                    if (t == null) {
-                        break;
-                    }
-                    task = t.next;
-                }
-                task.next = new FlushTask(this, null, promise);
-            }
+        public void write(MessageList<?> msgs, ChannelPromise promise) {
+            outboundBuffer.add(msgs, promise);
+            flush();
         }
 
-        private void flushNotifierAndFlush(ChannelPromise promise) {
-            flushNotifier(promise);
-            flush0();
-        }
-
-        private int outboundBufSize() {
-            final int bufSize;
-            final ChannelHandlerContext ctx = headContext();
-            if (metadata().bufferType() == BufType.BYTE) {
-                bufSize = ctx.outboundByteBuffer().readableBytes();
-            } else {
-                bufSize = ctx.outboundMessageBuffer().size();
-            }
-            return bufSize;
-        }
-
-        private ChannelFuture flushNotifier(ChannelPromise promise) {
-            // Append flush future to the notification list.
-            if (promise != voidPromise) {
-                flushFutureNotifier.add(promise, outboundBufSize());
-            }
-            return promise;
-        }
-
-        private void flush0() {
+        private void flush() {
             if (!inFlushNow) { // Avoid re-entrance
                 try {
                     // Flush immediately only when there's no pending flush.
@@ -877,10 +653,8 @@ private void flush0() {
                         flushNow();
                     }
                 } catch (Throwable t) {
-                    flushFutureNotifier.notifyFlushFutures(t);
-                    if (t instanceof IOException) {
-                        close(voidPromise());
-                    }
+                    outboundBuffer.fail(t);
+                    close(voidPromise());
                 }
             } else {
                 if (!flushNowPending) {
@@ -889,53 +663,83 @@ private void flush0() {
                 }
             }
         }
+
         @Override
         public final void flushNow() {
-            if (inFlushNow || flushTaskInProgress != null) {
+            if (inFlushNow) {
                 return;
             }
 
             inFlushNow = true;
-            ChannelHandlerContext ctx = headContext();
-            Throwable cause = null;
+            final ChannelOutboundBuffer outboundBuffer = AbstractChannel.this.outboundBuffer;
             try {
-                if (metadata().bufferType() == BufType.BYTE) {
-                    ByteBuf out = ctx.outboundByteBuffer();
-                    int oldSize = out.readableBytes();
-                    try {
-                        doFlushByteBuffer(out);
-                    } catch (Throwable t) {
-                        cause = t;
-                    } finally {
-                        int delta = oldSize - out.readableBytes();
-                        out.discardSomeReadBytes();
-                        flushFutureNotifier.increaseWriteCounter(delta);
+                for (;;) {
+                    ChannelPromise promise = outboundBuffer.currentPromise;
+                    if (promise == null) {
+                        if (!outboundBuffer.next()) {
+                            break;
+                        }
+                        promise = outboundBuffer.currentPromise;
                     }
-                } else {
-                    MessageBuf<Object> out = ctx.outboundMessageBuffer();
-                    int oldSize = out.size();
-                    try {
-                        doFlushMessageBuffer(out);
-                    } catch (Throwable t) {
-                        cause = t;
-                    } finally {
-                        flushFutureNotifier.increaseWriteCounter(oldSize - out.size());
+
+                    MessageList<Object> messages = outboundBuffer.currentMessages;
+                    int messageIndex = outboundBuffer.currentMessageIndex;
+                    int messageCount = messages.size();
+
+                    // Make sure the message list is not empty.
+                    if (messageCount == 0) {
+                        messages.recycle();
+                        promise.trySuccess();
+                        if (!outboundBuffer.next()) {
+                            break;
+                        } else {
+                            continue;
+                        }
                     }
-                }
 
-                if (cause == null) {
-                    flushFutureNotifier.notifyFlushFutures();
-                } else {
-                    flushFutureNotifier.notifyFlushFutures(cause);
-                    if (cause instanceof IOException) {
-                        close(voidPromise());
+                    // Make sure the promise has not been cancelled.
+                    if (promise.isCancelled()) {
+                        // If cancelled, release all unwritten messages and recycle.
+                        for (int i = messageIndex; i < messageCount; i ++) {
+                            ByteBufUtil.release(messages.get(i));
+                        }
+                        messages.recycle();
+                        if (!outboundBuffer.next()) {
+                            break;
+                        } else {
+                            continue;
+                        }
+                    }
+
+                    // Write the messages.
+                    int writtenMessages = doWrite(messages, messageIndex);
+                    outboundBuffer.currentMessageIndex = messageIndex += writtenMessages;
+                    if (messageIndex >= messageCount) {
+                        messages.recycle();
+                        promise.trySuccess();
+                        if (!outboundBuffer.next()) {
+                            break;
+                        }
+                    } else {
+                        // Could not flush the current write request completely. Try again later.
+                        break;
                     }
                 }
+            } catch (Throwable t) {
+                outboundBuffer.fail(t);
+                if (t instanceof IOException) {
+                    close(voidPromise());
+                }
             } finally {
                 inFlushNow = false;
             }
         }
 
+        @Override
+        public ChannelPromise voidPromise() {
+            return unsafeVoidPromise;
+        }
+
         protected final boolean ensureOpen(ChannelPromise promise) {
             if (isOpen()) {
                 return true;
@@ -1036,35 +840,31 @@ protected Runnable doDeregister() throws Exception {
      * Flush the content of the given {@link ByteBuf} to the remote peer.
      *
      * Sub-classes may override this as this implementation will just thrown an {@link UnsupportedOperationException}
-     */
-    protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
-        throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Flush the content of the given {@link MessageBuf} to the remote peer.
      *
-     * Sub-classes may override this as this implementation will just thrown an {@link UnsupportedOperationException}
+     * @return the number of written messages
      */
-    protected void doFlushMessageBuffer(MessageBuf<Object> buf) throws Exception {
-        throw new UnsupportedOperationException();
+    protected abstract int doWrite(MessageList<Object> msgs, int index) throws Exception;
+
+    protected static void checkEOF(FileRegion region) throws IOException {
+        if (region.transfered() < region.count()) {
+            throw new EOFException("Expected to be able to write "
+                    + region.count() + " bytes, but only wrote "
+                    + region.transfered());
+        }
     }
 
     /**
-     * Flush the content of the given {@link FlushTask} to the remote peer.
-     *
-     * Sub-classes may override this as this implementation will just thrown an {@link UnsupportedOperationException}
+     * Calculate the number of bytes a message takes up in memory. Sub-classes may override this if they use different
+     * messages then {@link ByteBuf} or {@link ByteBufHolder}. If the size can not be calculated 0 should be returned.
      */
-    protected void doFlushFileRegion(FlushTask task) throws Exception {
-        throw new UnsupportedOperationException();
-    }
-
-    protected static void checkEOF(FileRegion region, long writtenBytes) throws IOException {
-        if (writtenBytes < region.count()) {
-            throw new EOFException("Expected to be able to write "
-                    + region.count() + " bytes, but only wrote "
-                    + writtenBytes);
+    protected int calculateMessageSize(Object message) {
+        if (message instanceof ByteBuf) {
+            return ((ByteBuf) message).readableBytes();
+        }
+        if (message instanceof ByteBufHolder) {
+            return ((ByteBufHolder) message).content().readableBytes();
         }
+        return 0;
     }
 
     /**
diff --git a/transport/src/main/java/io/netty/channel/AbstractServerChannel.java b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java
index 12d5181e1fb4..9334aa676faf 100755
--- a/transport/src/main/java/io/netty/channel/AbstractServerChannel.java
+++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java
@@ -15,9 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.BufType;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 
 import java.net.SocketAddress;
 
@@ -27,13 +25,13 @@
  * <ul>
  * <li>{@link #connect(SocketAddress, ChannelPromise)}</li>
  * <li>{@link #disconnect(ChannelPromise)}</li>
- * <li>{@link #flush(ChannelPromise)}</li>
+ * <li>{@link ChannelOutboundInvoker#write(Object, ChannelPromise)}</li>
  * <li>and the shortcut methods which calls the methods mentioned above
  * </ul>
  */
 public abstract class AbstractServerChannel extends AbstractChannel implements ServerChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     /**
      * Creates a new instance.
@@ -42,18 +40,6 @@ protected AbstractServerChannel(Integer id) {
         super(null, id);
     }
 
-    @Override
-    public ByteBuf outboundByteBuffer() {
-        throw new NoSuchBufferException(String.format(
-                "%s does not have an outbound buffer.", ServerChannel.class.getSimpleName()));
-    }
-
-    @Override
-    public <T> MessageBuf<T> outboundMessageBuffer() {
-        throw new NoSuchBufferException(String.format(
-                "%s does not have an outbound buffer.", ServerChannel.class.getSimpleName()));
-    }
-
     @Override
     public ChannelMetadata metadata() {
         return METADATA;
@@ -84,22 +70,28 @@ protected AbstractUnsafe newUnsafe() {
         return new DefaultServerUnsafe();
     }
 
+    @Override
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
     private final class DefaultServerUnsafe extends AbstractUnsafe {
         @Override
-        public void flush(final ChannelPromise future) {
-            reject(future);
+        public void write(MessageList<?> msgs, ChannelPromise promise) {
+            reject(promise);
+            int size = msgs.size();
+            for (int i = 0; i < size; i ++) {
+                ByteBufUtil.release(msgs.get(i));
+            }
         }
 
         @Override
-        public void connect(
-                final SocketAddress remoteAddress, final SocketAddress localAddress,
-                final ChannelPromise future) {
-            reject(future);
+        public void connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
+            reject(promise);
         }
 
-        private void reject(ChannelPromise future) {
-            Exception cause = new UnsupportedOperationException();
-            future.setFailure(cause);
+        private void reject(ChannelPromise promise) {
+            promise.setFailure(new UnsupportedOperationException());
         }
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java b/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java
new file mode 100644
index 000000000000..4c123840b0ab
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * The {@link RecvByteBufAllocator} that automatically increases and
+ * decreases the predicted buffer size on feed back.
+ * <p>
+ * It gradually increases the expected number of readable bytes if the previous
+ * read fully filled the allocated buffer.  It gradually decreases the expected
+ * number of readable bytes if the read operation was not able to fill a certain
+ * amount of the allocated buffer two times consecutively.  Otherwise, it keeps
+ * returning the same prediction.
+ */
+public class AdaptiveRecvByteBufAllocator implements RecvByteBufAllocator {
+
+    static final int DEFAULT_MINIMUM = 64;
+    static final int DEFAULT_INITIAL = 1024;
+    static final int DEFAULT_MAXIMUM = 65536;
+
+    private static final int INDEX_INCREMENT = 4;
+    private static final int INDEX_DECREMENT = 1;
+
+    private static final int[] SIZE_TABLE;
+
+    static {
+        List<Integer> sizeTable = new ArrayList<Integer>();
+        for (int i = 1; i <= 8; i ++) {
+            sizeTable.add(i);
+        }
+
+        for (int i = 4; i < 32; i ++) {
+            long v = 1L << i;
+            long inc = v >>> 4;
+            v -= inc << 3;
+
+            for (int j = 0; j < 8; j ++) {
+                v += inc;
+                if (v > Integer.MAX_VALUE) {
+                    sizeTable.add(Integer.MAX_VALUE);
+                } else {
+                    sizeTable.add((int) v);
+                }
+            }
+        }
+
+        SIZE_TABLE = new int[sizeTable.size()];
+        for (int i = 0; i < SIZE_TABLE.length; i ++) {
+            SIZE_TABLE[i] = sizeTable.get(i);
+        }
+    }
+
+    public static final AdaptiveRecvByteBufAllocator DEFAULT = new AdaptiveRecvByteBufAllocator();
+
+    private static int getSizeTableIndex(final int size) {
+        if (size <= 16) {
+            return size - 1;
+        }
+
+        int bits = 0;
+        int v = size;
+        do {
+            v >>>= 1;
+            bits ++;
+        } while (v != 0);
+
+        final int baseIdx = bits << 3;
+        final int startIdx = baseIdx - 18;
+        final int endIdx = baseIdx - 25;
+
+        for (int i = startIdx; i >= endIdx; i --) {
+            if (size >= SIZE_TABLE[i]) {
+                return i;
+            }
+        }
+
+        throw new Error("shouldn't reach here; please file a bug report.");
+    }
+
+    private static final class HandleImpl implements Handle {
+        private final int minIndex;
+        private final int maxIndex;
+        private int index;
+        private int nextReceiveBufferSize;
+        private boolean decreaseNow;
+
+        HandleImpl(int minIndex, int maxIndex, int initial) {
+            this.minIndex = minIndex;
+            this.maxIndex = maxIndex;
+
+            index = getSizeTableIndex(initial);
+            nextReceiveBufferSize = SIZE_TABLE[index];
+        }
+
+        @Override
+        public ByteBuf allocate(ByteBufAllocator alloc) {
+            return alloc.ioBuffer(nextReceiveBufferSize);
+        }
+
+        @Override
+        public int guess() {
+            return nextReceiveBufferSize;
+        }
+
+        @Override
+        public void record(int actualReadBytes) {
+            if (actualReadBytes <= SIZE_TABLE[Math.max(0, index - INDEX_DECREMENT - 1)]) {
+                if (decreaseNow) {
+                    index = Math.max(index - INDEX_DECREMENT, minIndex);
+                    nextReceiveBufferSize = SIZE_TABLE[index];
+                    decreaseNow = false;
+                } else {
+                    decreaseNow = true;
+                }
+            } else if (actualReadBytes >= nextReceiveBufferSize) {
+                index = Math.min(index + INDEX_INCREMENT, maxIndex);
+                nextReceiveBufferSize = SIZE_TABLE[index];
+                decreaseNow = false;
+            }
+        }
+    }
+
+    private final int minIndex;
+    private final int maxIndex;
+    private final int initial;
+
+    /**
+     * Creates a new predictor with the default parameters.  With the default
+     * parameters, the expected buffer size starts from {@code 1024}, does not
+     * go down below {@code 64}, and does not go up above {@code 65536}.
+     */
+    private AdaptiveRecvByteBufAllocator() {
+        this(DEFAULT_MINIMUM, DEFAULT_INITIAL, DEFAULT_MAXIMUM);
+    }
+
+    /**
+     * Creates a new predictor with the specified parameters.
+     *
+     * @param minimum  the inclusive lower bound of the expected buffer size
+     * @param initial  the initial buffer size when no feed back was received
+     * @param maximum  the inclusive upper bound of the expected buffer size
+     */
+    public AdaptiveRecvByteBufAllocator(int minimum, int initial, int maximum) {
+        if (minimum <= 0) {
+            throw new IllegalArgumentException("minimum: " + minimum);
+        }
+        if (initial < minimum) {
+            throw new IllegalArgumentException("initial: " + initial);
+        }
+        if (maximum < initial) {
+            throw new IllegalArgumentException("maximum: " + maximum);
+        }
+
+        int minIndex = getSizeTableIndex(minimum);
+        if (SIZE_TABLE[minIndex] < minimum) {
+            this.minIndex = minIndex + 1;
+        } else {
+            this.minIndex = minIndex;
+        }
+
+        int maxIndex = getSizeTableIndex(maximum);
+        if (SIZE_TABLE[maxIndex] > maximum) {
+            this.maxIndex = maxIndex - 1;
+        } else {
+            this.maxIndex = maxIndex;
+        }
+
+        this.initial = initial;
+    }
+
+    @Override
+    public Handle newHandle() {
+        return new HandleImpl(minIndex, maxIndex, initial);
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/AddressedEnvelope.java b/transport/src/main/java/io/netty/channel/AddressedEnvelope.java
index 7ead758d7e17..ba159f9d1eb5 100644
--- a/transport/src/main/java/io/netty/channel/AddressedEnvelope.java
+++ b/transport/src/main/java/io/netty/channel/AddressedEnvelope.java
@@ -16,7 +16,7 @@
 
 package io.netty.channel;
 
-import io.netty.buffer.ReferenceCounted;
+import io.netty.util.ReferenceCounted;
 
 import java.net.SocketAddress;
 
diff --git a/transport/src/main/java/io/netty/channel/Channel.java b/transport/src/main/java/io/netty/channel/Channel.java
index fe34b3879188..f50a42ee7686 100755
--- a/transport/src/main/java/io/netty/channel/Channel.java
+++ b/transport/src/main/java/io/netty/channel/Channel.java
@@ -15,8 +15,6 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.channel.socket.ServerSocketChannel;
@@ -113,22 +111,6 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelPr
      */
     ChannelMetadata metadata();
 
-    /**
-     * Return the last {@link ByteBuf} of the {@link ChannelPipeline} which belongs to this {@link Channel}.
-     *
-     * This method may throw an {@link NoSuchBufferException} if you try to access this buffer and the
-     * {@link ChannelPipeline} does not contain any {@link ByteBuf}.
-     */
-    ByteBuf outboundByteBuffer();
-
-    /**
-     * Return the last {@link MessageBuf} of the {@link ChannelPipeline} which belongs to this {@link Channel}.
-     *
-     * This method may throw an {@link NoSuchBufferException} if you try to access this buffer and the
-     * {@link ChannelPipeline} does not contain any {@link MessageBuf}.
-     */
-    <T> MessageBuf<T> outboundMessageBuffer();
-
     /**
      * Returns the local address where this channel is bound to.  The returned
      * {@link SocketAddress} is supposed to be down-cast into more concrete
@@ -162,6 +144,14 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelPr
      */
     ChannelFuture closeFuture();
 
+    /**
+     * Returns {@code true} if and only if the I/O thread will perform the
+     * requested write operation immediately.  Any write requests made when
+     * this method returns {@code false} are queued until the I/O thread is
+     * ready to process the queued write requests.
+     */
+    boolean isWritable();
+
     /**
      * Returns an <em>internal-use-only</em> object that provides unsafe operations.
      */
@@ -172,19 +162,14 @@ public interface Channel extends AttributeMap, ChannelOutboundInvoker, ChannelPr
      * are only provided to implement the actual transport, and must be invoked from an I/O thread except for the
      * following methods:
      * <ul>
-     *   <li>{@link #headContext()}</li>
      *   <li>{@link #localAddress()}</li>
      *   <li>{@link #remoteAddress()}</li>
      *   <li>{@link #closeForcibly()}</li>
      *   <li>{@link #register(EventLoop, ChannelPromise)}</li>
+     *   <li>{@link #voidPromise()}</li>
      * </ul>
      */
     interface Unsafe {
-        /**
-         * Return the internal {@link ChannelHandlerContext} that is placed before all user handlers.
-         */
-        ChannelHandlerContext headContext();
-
         /**
          * Return the {@link SocketAddress} to which is bound local or
          * {@code null} if none.
@@ -249,10 +234,9 @@ interface Unsafe {
         void beginRead();
 
         /**
-         * Flush out all data that was buffered in the buffer of the {@link #headContext()} and was not
-         * flushed out yet. After that is done the {@link ChannelFuture} will get notified
+         * Schedules a write operation.
          */
-        void flush(ChannelPromise promise);
+        void write(MessageList<?> msgs, ChannelPromise promise);
 
         /**
          * Flush out all data now.
@@ -260,10 +244,10 @@ interface Unsafe {
         void flushNow();
 
         /**
-         * Send a {@link FileRegion} to the remote peer and notify the {@link ChannelPromise} once it completes
-         * or an error was detected. Once the {@link FileRegion} was transfered or an error was thrown it will
-         * automaticly call {@link FileRegion#release()}.
+         * Return a special ChannelPromise which can be reused and passed to the operations in {@link Unsafe}.
+         * It will never be notified of a success or error and so is only a placeholder for operations
+         * that take a {@link ChannelPromise} as argument but for which you not want to get notified.
          */
-        void sendFile(FileRegion region, ChannelPromise promise);
+        ChannelPromise voidPromise();
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelConfig.java b/transport/src/main/java/io/netty/channel/ChannelConfig.java
index ef160990f89b..b9747ae21045 100644
--- a/transport/src/main/java/io/netty/channel/ChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java
@@ -15,7 +15,6 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.socket.SocketChannelConfig;
 
@@ -63,12 +62,6 @@
  */
 public interface ChannelConfig {
 
-    enum ChannelHandlerByteBufType {
-        HEAP,
-        DIRECT,
-        PREFER_DIRECT
-    }
-
     /**
      * Return all set {@link ChannelOption}'s.
      */
@@ -158,6 +151,18 @@ enum ChannelHandlerByteBufType {
      */
     ChannelConfig setAllocator(ByteBufAllocator allocator);
 
+    /**
+     * Returns {@link RecvByteBufAllocator} which is used for the channel
+     * to allocate receive buffers.
+     */
+    RecvByteBufAllocator getRecvByteBufAllocator();
+
+    /**
+     * Set the {@link ByteBufAllocator} which is used for the channel
+     * to allocate receive buffers.
+     */
+    ChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
+
     /**
      * Returns {@code true} if and only if {@link ChannelHandlerContext#read()} will be invoked automatically so that
      * a user application doesn't need to call it at all. The default value is {@code true}.
@@ -171,21 +176,34 @@ enum ChannelHandlerByteBufType {
     ChannelConfig setAutoRead(boolean autoRead);
 
     /**
-     * Returns the {@link ChannelHandlerByteBufType} which is used to determine what kind of {@link ByteBuf} will
-     * be created by the {@link ChannelInboundByteHandler#newInboundBuffer(ChannelHandlerContext)} and
-     * {@link ChannelOutboundByteHandler#newOutboundBuffer(ChannelHandlerContext)} methods.
-     * <p>
-     * The implementation of {@link ChannelInboundByteHandler} or {@link ChannelOutboundByteHandler} may still return
-     * another {@link ByteBuf} if it depends on a special type.
-     *
-     * The default is {@link ChannelHandlerByteBufType#PREFER_DIRECT}.
+     * Returns the high water mark of the write buffer.  If the number of bytes
+     * queued in the write buffer exceeds this value, {@link Channel#isWritable()}
+     * will start to return {@code false}.
+     */
+    int getWriteBufferHighWaterMark();
+
+    /**
+     * Sets the high water mark of the write buffer.  If the number of bytes
+     * queued in the write buffer exceeds this value, {@link Channel#isWritable()}
+     * will start to return {@code false}.
+     */
+    ChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);
+
+    /**
+     * Returns the low water mark of the write buffer.  Once the number of bytes
+     * queued in the write buffer exceeded the
+     * {@linkplain #setWriteBufferHighWaterMark(int) high water mark} and then
+     * dropped down below this value, {@link Channel#isWritable()} will start to return
+     * {@code true} again.
      */
-    ChannelHandlerByteBufType getDefaultHandlerByteBufType();
+    int getWriteBufferLowWaterMark();
 
     /**
-     * Sets the {@link ChannelHandlerByteBufType} which is used to determine what kind of {@link ByteBuf} will
-     * be created by the {@link ChannelInboundByteHandler#newInboundBuffer(ChannelHandlerContext)} and
-     * {@link ChannelOutboundByteHandler#newOutboundBuffer(ChannelHandlerContext)} methods.
+     * Sets the low water mark of the write buffer.  Once the number of bytes
+     * queued in the write buffer exceeded the
+     * {@linkplain #setWriteBufferHighWaterMark(int) high water mark} and then
+     * dropped down below this value, {@link Channel#isWritable()} will start toreturn
+     * {@code true} again.
      */
-    ChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    ChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark);
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java b/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java
index 509c83ad6cfd..2a8b73bcdc43 100644
--- a/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java
+++ b/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java
@@ -18,17 +18,17 @@
 import java.net.SocketAddress;
 
 /**
- * {@link ChannelHandler} implementation which represents a combination out of a {@link ChannelStateHandler} and
- * the {@link ChannelOperationHandler}.
+ * {@link ChannelHandler} implementation which represents a combination out of a {@link ChannelInboundHandler} and
+ * the {@link ChannelOutboundHandler}.
  *
  * It is a good starting point if your {@link ChannelHandler} implementation needs to intercept operations and also
  * state updates.
  */
-public abstract class ChannelDuplexHandler extends ChannelStateHandlerAdapter implements ChannelOperationHandler {
+public class ChannelDuplexHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandler {
 
     /**
      * Calls {@link ChannelHandlerContext#bind(SocketAddress, ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -40,7 +40,7 @@ public void bind(ChannelHandlerContext ctx, SocketAddress localAddress,
 
     /**
      * Calls {@link ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -52,7 +52,7 @@ public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
 
     /**
      * Calls {@link ChannelHandlerContext#disconnect(ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -64,41 +64,33 @@ public void disconnect(ChannelHandlerContext ctx, ChannelPromise future)
 
     /**
      * Calls {@link ChannelHandlerContext#close(ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
     @Override
-    public void close(ChannelHandlerContext ctx, ChannelPromise future)
-            throws Exception {
+    public void close(ChannelHandlerContext ctx, ChannelPromise future) throws Exception {
         ctx.close(future);
     }
 
     /**
      * Calls {@link ChannelHandlerContext#close(ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
     @Override
-    public void deregister(ChannelHandlerContext ctx, ChannelPromise future)
-            throws Exception {
+    public void deregister(ChannelHandlerContext ctx, ChannelPromise future) throws Exception {
         ctx.deregister(future);
     }
 
     @Override
-    public void read(ChannelHandlerContext ctx) {
+    public void read(ChannelHandlerContext ctx) throws Exception {
         ctx.read();
     }
 
-    /**
-     * Calls {@link ChannelHandlerContext#sendFile(FileRegion, ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
-     *
-     * Sub-classes may override this method to change behavior.
-     */
     @Override
-    public void sendFile(ChannelHandlerContext ctx, FileRegion region, ChannelPromise future) throws Exception {
-        ctx.sendFile(region, future);
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        ctx.write(msgs, promise);
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelFuture.java b/transport/src/main/java/io/netty/channel/ChannelFuture.java
index 13308400fc1b..bb29e297fe92 100644
--- a/transport/src/main/java/io/netty/channel/ChannelFuture.java
+++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java
@@ -171,16 +171,16 @@ public interface ChannelFuture extends Future<Void> {
     Channel channel();
 
     @Override
-    ChannelFuture addListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelFuture addListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelFuture addListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelFuture addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
-    ChannelFuture removeListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelFuture removeListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelFuture removeListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelFuture removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
     ChannelFuture sync() throws InterruptedException;
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandler.java b/transport/src/main/java/io/netty/channel/ChannelHandler.java
index ba6061fa78b0..3d10dc4c66bd 100644
--- a/transport/src/main/java/io/netty/channel/ChannelHandler.java
+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java
@@ -15,8 +15,6 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
 
@@ -40,14 +38,8 @@
  *
  * But the most useful for developers may be:
  * <ul>
- * <li>{@link ChannelInboundByteHandlerAdapter} handles and intercepts inbound operations where the inbound message
- * type is a {@link ByteBuf}.</li>
- * <li>{@link ChannelInboundMessageHandlerAdapter} handles and intercepts inbound operations where the inbound message
- * type is a {@link MessageBuf}.</li>
- *  * <li>{@link ChannelOutboundByteHandlerAdapter} handles and intercepts outbound operations where the inbound message
- * type is a {@link ByteBuf}.</li>
- * <li>{@link ChannelOutboundMessageHandlerAdapter} handles and intercepts outbound operations where the inbound message
- * type is a {@link MessageBuf}.</li>
+ * <li>{@link ChannelInboundHandlerAdapter} handles and intercepts inbound operations</li>
+ * <li>{@link ChannelOutboundHandlerAdapter} handles and intercepts outbound operations</li>
  * </ul>
  *
  * You will also find more detailed explanation from the documentation of
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
index 35ebb2ac3286..4432c2a50dd5 100755
--- a/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
@@ -16,9 +16,6 @@
 package io.netty.channel;
 
 
-import io.netty.buffer.BufType;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
 import io.netty.util.AttributeMap;
@@ -83,7 +80,7 @@
  * as how many times it is added to pipelines, regardless if it is added to the
  * same pipeline multiple times or added to different pipelines multiple times:
  * <pre>
- * public class FactorialHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt{@link Integer}&gt {
+ * public class FactorialHandler extends {@link ChannelInboundHandlerAdapter}&lt{@link Integer}&gt {
  *
  *   private final {@link AttributeKey}&lt{@link Integer}&gt counter =
  *           new {@link AttributeKey}&lt{@link Integer}&gt("counter");
@@ -154,99 +151,11 @@ public interface ChannelHandlerContext
     ChannelHandler handler();
 
     /**
-     * Return {@code true} if the {@link ChannelHandlerContext} has an {@link ByteBuf} bound for inbound
-     * which can be used.
+     * Return {@code true} if the {@link ChannelHandler} which belongs to this {@link ChannelHandler} was removed
+     * from the {@link ChannelPipeline}. Note that this method is only meant to be called from with in the
+     * {@link EventLoop}.
      */
-    boolean hasInboundByteBuffer();
-
-    /**
-     * Return {@code true} if the {@link ChannelHandlerContext} has a {@link MessageBuf} bound for inbound
-     * which can be used.
-     */
-    boolean hasInboundMessageBuffer();
-
-    /**
-     * Return the bound {@link ByteBuf} for inbound data if {@link #hasInboundByteBuffer()} returned
-     * {@code true}. If {@link #hasInboundByteBuffer()} returned {@code false} it will throw a
-     * {@link UnsupportedOperationException}.
-     * <p/>
-     * This method can only be called from within the event-loop, otherwise it will throw an
-     * {@link IllegalStateException}.
-     */
-    ByteBuf inboundByteBuffer();
-
-    /**
-     * Return the bound {@link MessageBuf} for inbound data if {@link #hasInboundMessageBuffer()} returned
-     * {@code true}. If {@link #hasInboundMessageBuffer()} returned {@code false} it will throw a
-     * {@link UnsupportedOperationException}.
-     * <p/>
-     * This method can only be called from within the event-loop, otherwise it will throw an
-     * {@link IllegalStateException}.
-     */
-    <T> MessageBuf<T> inboundMessageBuffer();
-
-    /**
-     * Return {@code true} if the {@link ChannelHandlerContext} has an {@link ByteBuf} bound for outbound
-     * data which can be used.
-     *
-     */
-    boolean hasOutboundByteBuffer();
-
-    /**
-     * Return {@code true} if the {@link ChannelHandlerContext} has a {@link MessageBuf} bound for outbound
-     * which can be used.
-     */
-    boolean hasOutboundMessageBuffer();
-
-    /**
-     * Return the bound {@link ByteBuf} for outbound data if {@link #hasOutboundByteBuffer()} returned
-     * {@code true}. If {@link #hasOutboundByteBuffer()} returned {@code false} it will throw
-     * a {@link UnsupportedOperationException}.
-     * <p/>
-     * This method can only be called from within the event-loop, otherwise it will throw an
-     * {@link IllegalStateException}.
-     */
-    ByteBuf outboundByteBuffer();
-
-    /**
-     * Return the bound {@link MessageBuf} for outbound data if {@link #hasOutboundMessageBuffer()} returned
-     * {@code true}. If {@link #hasOutboundMessageBuffer()} returned {@code false} it will throw a
-     * {@link UnsupportedOperationException}.
-     * <p/>
-     * This method can only be called from within the event-loop, otherwise it will throw an
-     * {@link IllegalStateException}.
-     */
-    <T> MessageBuf<T> outboundMessageBuffer();
-
-    /**
-     * Return the {@link ByteBuf} of the next {@link ChannelInboundByteHandler} in the pipeline.
-     */
-    ByteBuf nextInboundByteBuffer();
-
-    /**
-     * Return the {@link MessageBuf} of the next {@link ChannelInboundMessageHandler} in the pipeline.
-     */
-    MessageBuf<Object> nextInboundMessageBuffer();
-
-    /**
-     * Return the {@link ByteBuf} of the next {@link ChannelOutboundByteHandler} in the pipeline.
-     */
-    ByteBuf nextOutboundByteBuffer();
-
-    /**
-     * Return the {@link MessageBuf} of the next {@link ChannelOutboundMessageHandler} in the pipeline.
-     */
-    MessageBuf<Object> nextOutboundMessageBuffer();
-
-    /**
-     * Return the {@link BufType} of the next {@link ChannelInboundHandler} in the pipeline.
-     */
-    BufType nextInboundBufferType();
-
-    /**
-     * Return the {@link BufType} of the next {@link ChannelOutboundHandler} in the pipeline.
-     */
-    BufType nextOutboundBufferType();
+    boolean isRemoved();
 
     @Override
     ChannelHandlerContext fireChannelRegistered();
@@ -267,8 +176,14 @@ public interface ChannelHandlerContext
     ChannelHandlerContext fireUserEventTriggered(Object event);
 
     @Override
-    ChannelHandlerContext fireInboundBufferUpdated();
+    ChannelHandlerContext fireMessageReceived(Object msg);
+
+    @Override
+    ChannelHandlerContext fireMessageReceived(MessageList<?> msgs);
 
     @Override
     ChannelHandlerContext fireChannelReadSuspended();
+
+    @Override
+    ChannelHandlerContext fireChannelWritabilityChanged();
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java b/transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java
deleted file mode 100644
index 080bb3b4d165..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.channel;
-
-import io.netty.buffer.BufType;
-import io.netty.buffer.BufUtil;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.util.Signal;
-import io.netty.util.internal.logging.InternalLogger;
-import io.netty.util.internal.logging.InternalLoggerFactory;
-
-/**
- * Utility methods for use within your {@link ChannelHandler} implementation.
- */
-public final class ChannelHandlerUtil {
-
-    public static final Signal ABORT = new Signal(ChannelHandlerUtil.class.getName() + ".ABORT");
-
-    private static final InternalLogger logger = InternalLoggerFactory.getInstance(ChannelHandlerUtil.class);
-
-    public static <T> void handleInboundBufferUpdated(
-            ChannelHandlerContext ctx, SingleInboundMessageHandler<T> handler) throws Exception {
-        MessageBuf<Object> in = ctx.inboundMessageBuffer();
-        if (in.isEmpty() || !handler.beginMessageReceived(ctx)) {
-            return;
-        }
-
-        MessageBuf<Object> out = ctx.nextInboundMessageBuffer();
-        int oldOutSize = out.size();
-        try {
-            for (;;) {
-                Object msg = in.poll();
-                if (msg == null) {
-                    break;
-                }
-
-                if (!handler.acceptInboundMessage(msg)) {
-                    out.add(msg);
-                    continue;
-                }
-
-                @SuppressWarnings("unchecked")
-                T imsg = (T) msg;
-                try {
-                    handler.messageReceived(ctx, imsg);
-                } finally {
-                    BufUtil.release(imsg);
-                }
-            }
-        } catch (Signal abort) {
-            abort.expect(ABORT);
-        } finally {
-            if (oldOutSize != out.size()) {
-                ctx.fireInboundBufferUpdated();
-            }
-
-            handler.endMessageReceived(ctx);
-        }
-    }
-
-    public static <T> void handleFlush(
-            ChannelHandlerContext ctx, ChannelPromise promise,
-            SingleOutboundMessageHandler<T> handler) throws Exception {
-
-        handleFlush(ctx, promise, true, handler);
-    }
-
-    public static <T> void handleFlush(
-            ChannelHandlerContext ctx, ChannelPromise promise, boolean closeOnFailedFlush,
-            SingleOutboundMessageHandler<T> handler) throws Exception {
-
-        MessageBuf<Object> in = ctx.outboundMessageBuffer();
-        final int inSize = in.size();
-        if (inSize == 0) {
-            ctx.flush(promise);
-            return;
-        }
-
-        boolean failed = false;
-        int processed = 0;
-        try {
-            if (!handler.beginFlush(ctx)) {
-                throw new IncompleteFlushException(
-                        "beginFlush(..) rejected the flush request by returning false. " +
-                        "none of " + inSize + " message(s) fulshed.");
-            }
-            for (;;) {
-                Object msg = in.poll();
-                if (msg == null) {
-                    break;
-                }
-
-                if (!handler.acceptOutboundMessage(msg)) {
-                    addToNextOutboundBuffer(ctx, msg);
-                    processed ++;
-                    continue;
-                }
-
-                @SuppressWarnings("unchecked")
-                T imsg = (T) msg;
-                try {
-                    handler.flush(ctx, imsg);
-                    processed ++;
-                } finally {
-                    BufUtil.release(imsg);
-                }
-            }
-        } catch (Throwable t) {
-            failed = true;
-            IncompleteFlushException pfe;
-            if (t instanceof IncompleteFlushException) {
-                pfe = (IncompleteFlushException) t;
-            } else {
-                String msg = processed + " out of " + inSize + " message(s) flushed";
-                if (t instanceof Signal) {
-                    Signal abort = (Signal) t;
-                    abort.expect(ABORT);
-                    pfe = new IncompleteFlushException("aborted: " + msg);
-                } else {
-                    pfe = new IncompleteFlushException(msg, t);
-                }
-            }
-            fail(ctx, promise, closeOnFailedFlush, pfe);
-        }
-
-        try {
-            handler.endFlush(ctx);
-
-        } catch (Throwable t) {
-            failed = true;
-            fail(ctx, promise, closeOnFailedFlush, t);
-        }
-
-        if (!failed) {
-            ctx.flush(promise);
-        }
-    }
-
-    private static void fail(
-            ChannelHandlerContext ctx, ChannelPromise promise, boolean closeOnFailedFlush, Throwable cause) {
-        if (promise.tryFailure(cause)) {
-            if (closeOnFailedFlush) {
-                ctx.close();
-            }
-        } else {
-            logger.warn("endFlush() raised a masked exception due to failed flush().", cause);
-        }
-    }
-
-    /**
-     * Allocate a {@link ByteBuf} taking the {@link ChannelConfig#getDefaultHandlerByteBufType()}
-     * setting into account.
-     */
-    public static ByteBuf allocate(ChannelHandlerContext ctx) {
-        switch(ctx.channel().config().getDefaultHandlerByteBufType()) {
-            case DIRECT:
-                return ctx.alloc().directBuffer();
-            case PREFER_DIRECT:
-                return ctx.alloc().ioBuffer();
-            case HEAP:
-                return ctx.alloc().heapBuffer();
-            default:
-                throw new IllegalStateException();
-        }
-    }
-
-    /**
-     * Allocate a {@link ByteBuf} taking the {@link ChannelConfig#getDefaultHandlerByteBufType()}
-     * setting into account.
-     */
-    public static ByteBuf allocate(ChannelHandlerContext ctx, int initialCapacity) {
-        switch(ctx.channel().config().getDefaultHandlerByteBufType()) {
-            case DIRECT:
-                return ctx.alloc().directBuffer(initialCapacity);
-            case PREFER_DIRECT:
-                return ctx.alloc().ioBuffer(initialCapacity);
-            case HEAP:
-                return ctx.alloc().heapBuffer(initialCapacity);
-            default:
-                throw new IllegalStateException();
-        }
-    }
-
-    /**
-     * Allocate a {@link ByteBuf} taking the {@link ChannelConfig#getDefaultHandlerByteBufType()}
-     * setting into account.
-     */
-    public static ByteBuf allocate(ChannelHandlerContext ctx, int initialCapacity, int maxCapacity) {
-        switch(ctx.channel().config().getDefaultHandlerByteBufType()) {
-            case DIRECT:
-                return ctx.alloc().directBuffer(initialCapacity, maxCapacity);
-            case PREFER_DIRECT:
-                return ctx.alloc().ioBuffer(initialCapacity, maxCapacity);
-            case HEAP:
-                return ctx.alloc().heapBuffer(initialCapacity, maxCapacity);
-            default:
-                throw new IllegalStateException();
-        }
-    }
-
-    /**
-     * Add the msg to the next outbound buffer in the {@link ChannelPipeline}. This takes special care of
-     * msgs that are of type {@link ByteBuf}.
-     */
-    public static boolean addToNextOutboundBuffer(ChannelHandlerContext ctx, Object msg) {
-        if (msg instanceof ByteBuf) {
-            if (ctx.nextOutboundBufferType() == BufType.BYTE) {
-                ctx.nextOutboundByteBuffer().writeBytes((ByteBuf) msg);
-                return true;
-            }
-        }
-        return ctx.nextOutboundMessageBuffer().add(msg);
-    }
-
-    /**
-     * Add the msg to the next inbound buffer in the {@link ChannelPipeline}. This takes special care of
-     * msgs that are of type {@link ByteBuf}.
-     */
-    public static boolean addToNextInboundBuffer(ChannelHandlerContext ctx, Object msg) {
-        if (msg instanceof ByteBuf) {
-            if (ctx.nextInboundBufferType() == BufType.BYTE) {
-                ctx.nextInboundByteBuffer().writeBytes((ByteBuf) msg);
-                return true;
-            }
-        }
-        return ctx.nextInboundMessageBuffer().add(msg);
-    }
-
-    private ChannelHandlerUtil() { }
-
-    public interface SingleInboundMessageHandler<T> {
-        /**
-         * Returns {@code true} if and only if the specified message can be handled by this handler.
-         *
-         * @param msg the message
-         */
-        boolean acceptInboundMessage(Object msg) throws Exception;
-
-        /**
-         * Will get notified once {@link ChannelStateHandler#inboundBufferUpdated(ChannelHandlerContext)} was called.
-         *
-         * If this method returns {@code false} no further processing of the {@link MessageBuf}
-         * will be done until the next call of {@link ChannelStateHandler#inboundBufferUpdated(ChannelHandlerContext)}.
-         *
-         * This will return {@code true} by default, and may get overriden by sub-classes for
-         * special handling.
-         *
-         * @param ctx           the {@link ChannelHandlerContext} which this {@link ChannelHandler} belongs to
-         */
-        boolean beginMessageReceived(ChannelHandlerContext ctx) throws Exception;
-
-        /**
-         * Is called once a message was received.
-         *
-         * @param ctx           the {@link ChannelHandlerContext} which this {@link ChannelHandler} belongs to
-         * @param msg           the message to handle
-         */
-        void messageReceived(ChannelHandlerContext ctx, T msg) throws Exception;
-
-        /**
-         * Is called when {@link #messageReceived(ChannelHandlerContext, Object)} returns.
-         *
-         * Super-classes may-override this for special handling.
-         *
-         * @param ctx           the {@link ChannelHandlerContext} which this {@link ChannelHandler} belongs to
-         */
-        void endMessageReceived(ChannelHandlerContext ctx) throws Exception;
-    }
-
-    public interface SingleOutboundMessageHandler<T> {
-        /**
-         * Returns {@code true} if and only if the specified message can be handled by this handler.
-         *
-         * @param msg the message
-         */
-        boolean acceptOutboundMessage(Object msg) throws Exception;
-
-        /**
-         * Will get notified once {@link ChannelOperationHandler#flush(ChannelHandlerContext, ChannelPromise)}
-         * was called.
-         *
-         * @param ctx           the {@link ChannelHandlerContext} which this {@link ChannelHandler} belongs to
-         *
-         * @return {@code true} to accept the flush request.  {@code false} to reject the flush request and
-         *         to fail the promise associated with the flush request with {@link IncompleteFlushException}.
-         */
-        boolean beginFlush(ChannelHandlerContext ctx) throws Exception;
-
-        /**
-         * Is called once a message is being flushed.
-         *
-         * @param ctx           the {@link ChannelHandlerContext} which this {@link ChannelHandler} belongs to
-         * @param msg           the message to handle
-         */
-        void flush(ChannelHandlerContext ctx, T msg) throws Exception;
-
-        /**
-         * Is called when {@link ChannelOperationHandler#flush(ChannelHandlerContext, ChannelPromise)} returns.
-         *
-         * Super-classes may-override this for special handling.
-         *
-         * @param ctx           the {@link ChannelHandlerContext} which this {@link ChannelHandler} belongs to
-         */
-        void endFlush(ChannelHandlerContext ctx) throws Exception;
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundByteHandler.java b/transport/src/main/java/io/netty/channel/ChannelInboundByteHandler.java
deleted file mode 100644
index f924cd2fda81..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelInboundByteHandler.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-
-/**
- * {@link ChannelInboundHandler} which offers a {@link ByteBuf} to store inbound data in.
- *
- */
-public interface ChannelInboundByteHandler extends ChannelInboundHandler {
-    /**
-     * {@inheritDoc}
-     * <p>
-     * An implementation should respect the {@link ChannelConfig#getDefaultHandlerByteBufType()} setting unless
-     * there's a good reason to ignore it.  If in doubt, use {@link ChannelHandlerUtil#allocate(ChannelHandlerContext)}.
-     * </p>
-     */
-    @Override
-    ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception;
-
-    /**
-     * Discards the read bytes of the inbound buffer and optionally trims its unused portion to reduce memory
-     * consumption. The most common implementation of this method will look like the following:
-     * <pre>
-     *     ctx.inboundByteBuffer().discardSomeReadBytes();
-     * </pre>
-     */
-    void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception;
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java b/transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java
deleted file mode 100644
index 4a50c5396545..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-
-
-/**
- * Abstract base class for {@link ChannelInboundByteHandler} which should be extended by the user to
- * get notified once more data is ready to get consumed from the inbound {@link ByteBuf}.
- *
- * This implementation is a good starting point for most users.
- */
-public abstract class ChannelInboundByteHandlerAdapter
-        extends ChannelStateHandlerAdapter implements ChannelInboundByteHandler {
-
-    /**
-     * Create a new unpooled {@link ByteBuf} by default. Sub-classes may override this to offer a more
-     * optimized implementation.
-     */
-    @Override
-    public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx);
-    }
-
-    @Override
-    public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        ctx.inboundByteBuffer().discardSomeReadBytes();
-    }
-
-    @Override
-    public final void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        inboundBufferUpdated(ctx, ctx.inboundByteBuffer());
-    }
-
-    /**
-     * Callback which will get notifed once the given {@link ByteBuf} received more data to read. What will be done
-     * with the data at this point is up to the implementation.
-     * Implementations may choose to read it or just let it in the buffer to read it later.
-     */
-    protected abstract void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception;
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
old mode 100644
new mode 100755
index 82e2f687bebb..a7e1817010c7
--- a/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
+++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
@@ -15,19 +15,55 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.Buf;
-
 /**
- * {@link ChannelStateHandler} which handles inbound data.
+ * {@link ChannelHandler} which adds callbacks for state changes. This allows the user
+ * to hook in to state changes easily.
  */
-interface ChannelInboundHandler extends ChannelStateHandler {
+public interface ChannelInboundHandler extends ChannelHandler {
+
+    /**
+     * The {@link Channel} of the {@link ChannelHandlerContext} was registered with its {@link EventLoop}
+     */
+    void channelRegistered(ChannelHandlerContext ctx) throws Exception;
+
+    /**
+     * The {@link Channel} of the {@link ChannelHandlerContext} was unregistered from its {@link EventLoop}
+     */
+    void channelUnregistered(ChannelHandlerContext ctx) throws Exception;
+
+    /**
+     * The {@link Channel} of the {@link ChannelHandlerContext} is now active
+     */
+    void channelActive(ChannelHandlerContext ctx) throws Exception;
+
+    /**
+     * The {@link Channel} of the {@link ChannelHandlerContext} was registered is now inactive and reached its
+     * end of lifetime.
+     */
+    void channelInactive(ChannelHandlerContext ctx) throws Exception;
+
+    /**
+     * Invoked when a {@link ChannelHandlerContext#read()} is finished and the inbound buffer of this handler will not
+     * be updated until another {@link ChannelHandlerContext#read()} request is issued.
+     */
+    void channelReadSuspended(ChannelHandlerContext ctx) throws Exception;
+
+    /**
+     * The inbound buffer of the {@link ChannelHandlerContext} was updated with new data.
+     * This means something may be ready to get processed by the actual {@link ChannelInboundHandler}
+     * implementation. It's up to the implementation to consume it or keep it in the buffer
+     * to wait for more data and consume it later.
+     */
+    void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception;
+
+    /**
+     * Gets called if an user event was triggered.
+     */
+    void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;
+
     /**
-     * Returns a new buffer which will be used to consume inbound data for the given {@link ChannelHandlerContext}.
-     * <p>
-     * Please note that this method can be called from any thread repeatatively, and thus you should neither perform
-     * stateful operation nor keep the reference of the created buffer as a member variable.  Get it always using
-     * {@link ChannelHandlerContext#inboundByteBuffer()} or {@link ChannelHandlerContext#inboundMessageBuffer()}.
-     * </p>
+     * Gets called once the writable state of a {@link Channel} changed. You can check the state with
+     * {@link Channel#isWritable()}.
      */
-    Buf newInboundBuffer(ChannelHandlerContext ctx) throws Exception;
+    void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception;
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelStateHandlerAdapter.java b/transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java
similarity index 63%
rename from transport/src/main/java/io/netty/channel/ChannelStateHandlerAdapter.java
rename to transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java
index 8a678044971f..edd0856f6eaa 100644
--- a/transport/src/main/java/io/netty/channel/ChannelStateHandlerAdapter.java
+++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java
@@ -17,17 +17,17 @@
 
 
 /**
- * Abstract base class for {@link ChannelStateHandler} implementations which provide
+ * Abstract base class for {@link ChannelInboundHandler} implementations which provide
  * implementations of all of their methods.
  *
  * This implementation just forward the operation to the next {@link ChannelHandler} in the
  * {@link ChannelPipeline}. Sub-classes may override a method implementation to change this.
  */
-public abstract class ChannelStateHandlerAdapter extends ChannelHandlerAdapter implements ChannelStateHandler {
+public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {
 
     /**
      * Calls {@link ChannelHandlerContext#fireChannelRegistered()} to forward
-     * to the next {@link ChannelStateHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -38,7 +38,7 @@ public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
 
     /**
      * Calls {@link ChannelHandlerContext#fireChannelUnregistered()} to forward
-     * to the next {@link ChannelStateHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -49,7 +49,7 @@ public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
 
     /**
      * Calls {@link ChannelHandlerContext#fireChannelActive()} to forward
-     * to the next {@link ChannelStateHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -60,7 +60,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
 
     /**
      * Calls {@link ChannelHandlerContext#fireChannelInactive()} to forward
-     * to the next {@link ChannelStateHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -70,7 +70,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
     }
     /**
      * Calls {@link ChannelHandlerContext#fireChannelReadSuspended()} to forward
-     * to the next {@link ChannelHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -79,15 +79,36 @@ public void channelReadSuspended(ChannelHandlerContext ctx) throws Exception {
         ctx.fireChannelReadSuspended();
     }
 
+    /**
+     * Calls {@link ChannelHandlerContext#fireMessageReceived(MessageList)} to forward
+     * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
+     *
+     * Sub-classes may override this method to change behavior.
+     */
+    @Override
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        ctx.fireMessageReceived(msgs);
+    }
+
     /**
      * Calls {@link ChannelHandlerContext#fireUserEventTriggered(Object)} to forward
-     * to the next {@link ChannelHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
     @Override
-    public void userEventTriggered(ChannelHandlerContext ctx, Object evt)
-            throws Exception {
+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
         ctx.fireUserEventTriggered(evt);
     }
+
+    /**
+     * Calls {@link ChannelHandlerContext#fireChannelWritabilityChanged()} to forward
+     * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
+     *
+     * Sub-classes may override this method to change behavior.
+     */
+    @Override
+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
+        ctx.fireChannelWritabilityChanged();
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java
index 2fb8118d93be..ac12c17505a7 100644
--- a/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java
+++ b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java
@@ -24,8 +24,8 @@ interface ChannelInboundInvoker {
     /**
      * A {@link Channel} was registered to its {@link EventLoop}.
      *
-     * This will result in having the  {@link ChannelStateHandler#channelRegistered(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelStateHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the  {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)} method
+     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelInboundInvoker fireChannelRegistered();
@@ -33,8 +33,8 @@ interface ChannelInboundInvoker {
     /**
      * A {@link Channel} was unregistered from its {@link EventLoop}.
      *
-     * This will result in having the  {@link ChannelStateHandler#channelUnregistered(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelStateHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the  {@link ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)} method
+     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelInboundInvoker fireChannelUnregistered();
@@ -42,8 +42,8 @@ interface ChannelInboundInvoker {
     /**
      * A {@link Channel} is active now, which means it is connected.
      *
-     * This will result in having the  {@link ChannelStateHandler#channelActive(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelStateHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the  {@link ChannelInboundHandler#channelActive(ChannelHandlerContext)} method
+     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelInboundInvoker fireChannelActive();
@@ -51,8 +51,8 @@ interface ChannelInboundInvoker {
     /**
      * A {@link Channel} is inactive now, which means it is closed.
      *
-     * This will result in having the  {@link ChannelStateHandler#channelInactive(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelStateHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the  {@link ChannelInboundHandler#channelInactive(ChannelHandlerContext)} method
+     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelInboundInvoker fireChannelInactive();
@@ -60,8 +60,8 @@ interface ChannelInboundInvoker {
     /**
      * A {@link Channel} received an {@link Throwable} in one of its inbound operations.
      *
-     * This will result in having the  {@link ChannelStateHandler#exceptionCaught(ChannelHandlerContext, Throwable)}
-     * method  called of the next  {@link ChannelStateHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the  {@link ChannelInboundHandler#exceptionCaught(ChannelHandlerContext, Throwable)}
+     * method  called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelInboundInvoker fireExceptionCaught(Throwable cause);
@@ -69,8 +69,8 @@ interface ChannelInboundInvoker {
     /**
      * A {@link Channel} received an user defined event.
      *
-     * This will result in having the  {@link ChannelStateHandler#userEventTriggered(ChannelHandlerContext, Object)}
-     * method  called of the next  {@link ChannelStateHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the  {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}
+     * method  called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelInboundInvoker fireUserEventTriggered(Object event);
@@ -78,15 +78,22 @@ interface ChannelInboundInvoker {
     /**
      * A {@link Channel} received bytes which are now ready to read from its inbound buffer.
      *
-     * This will result in having the  {@link ChannelStateHandler#inboundBufferUpdated(ChannelHandlerContext)}
-     * method  called of the next  {@link ChannelStateHandler} contained in the  {@link ChannelPipeline} of the
+     * This will result in having the {@link ChannelInboundHandler#messageReceived(ChannelHandlerContext, MessageList)}
+     * method  called of the next {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
-    ChannelInboundInvoker fireInboundBufferUpdated();
+    ChannelInboundInvoker fireMessageReceived(Object msg);
+    ChannelInboundInvoker fireMessageReceived(MessageList<?> msgs);
 
     /**
-     * Triggers an {@link ChannelStateHandler#channelReadSuspended(ChannelHandlerContext) channelReadSuspended}
-     * event to the next {@link ChannelStateHandler} in the {@link ChannelPipeline}.
+     * Triggers an {@link ChannelInboundHandler#channelReadSuspended(ChannelHandlerContext) channelReadSuspended}
+     * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
      */
     ChannelInboundInvoker fireChannelReadSuspended();
+
+    /**
+     * Triggers an {@link ChannelInboundHandler#channelWritabilityChanged(ChannelHandlerContext)}
+     * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
+     */
+    ChannelInboundInvoker fireChannelWritabilityChanged();
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandler.java b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandler.java
deleted file mode 100644
index d3e72ca069da..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandler.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-
-/**
- * Special {@link ChannelInboundHandler} which store the inbound data in a {@link MessageBuf} for futher processing.
- *
- * If your {@link ChannelOutboundMessageHandler} handles messages of type {@link ByteBuf} or {@link Object}
- * and you want to add a {@link ByteBuf} to the next buffer in the {@link ChannelPipeline} use
- * {@link ChannelHandlerUtil#addToNextInboundBuffer(ChannelHandlerContext, Object)}.
- */
-public interface ChannelInboundMessageHandler<I> extends ChannelInboundHandler {
-    @Override
-    MessageBuf<I> newInboundBuffer(ChannelHandlerContext ctx) throws Exception;
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java
deleted file mode 100644
index 79a5927be6be..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelHandlerUtil.SingleInboundMessageHandler;
-import io.netty.util.Signal;
-import io.netty.util.internal.TypeParameterMatcher;
-
-/**
- * {@link ChannelHandler} which handles inbound messages of a specific type.
- *
- * <pre>
- *     public class StringHandler extends
- *             {@link ChannelInboundMessageHandlerAdapter}&lt;{@link String}&gt; {
- *
- *         {@code @Override}
- *         public void messageReceived({@link ChannelHandlerContext} ctx, {@link String} message)
- *                 throws {@link Exception} {
- *             // Do something with the String
- *             ...
- *             ...
- *         }
- *     }
- * </pre>
- *
- * If your {@link ChannelInboundMessageHandlerAdapter} handles messages of type {@link ByteBuf} or {@link Object}
- * and you want to add a {@link ByteBuf} to the next buffer in the {@link ChannelPipeline} use
- * {@link ChannelHandlerUtil#addToNextInboundBuffer(ChannelHandlerContext, Object)}.
- *
- * <p>
- * One limitation to keep in mind is that it is not possible to detect the handled message type of you specify
- * {@code I} while instance your class. Because of this Netty does not allow to do so and will throw an Exception
- * if you try. For this cases you should handle the type detection by your self by override the
- * {@link #acceptInboundMessage(Object)} method and use {@link Object} as type parameter.
- *
- * <pre>
- *    public class GenericHandler&lt;I&gt; extends
- *             {@link ChannelInboundMessageHandlerAdapter}&lt;{@link Object}&gt; {
- *
- *         {@code @Override}
- *         public void messageReceived({@link ChannelHandlerContext} ctx, {@link Object} message)
- *                 throws {@link Exception} {
- *             I msg = (I) message;
- *             // Do something with the msg
- *             ...
- *             ...
- *         }
- *
- *         {@code @Override}
- *         public boolean acceptInboundMessage(Object msg) throws Exception {
- *             // Add your check here
- *         }
- *     }
- * </pre>
- *
- * @param <I>   The type of the messages to handle
- */
-public abstract class ChannelInboundMessageHandlerAdapter<I>
-        extends ChannelStateHandlerAdapter
-        implements ChannelInboundMessageHandler<I>, SingleInboundMessageHandler<I> {
-
-    /**
-     * Thrown by {@link #messageReceived(ChannelHandlerContext, Object)} to abort message processing.
-     */
-    protected static final Signal ABORT = ChannelHandlerUtil.ABORT;
-
-    private final TypeParameterMatcher msgMatcher;
-
-    protected ChannelInboundMessageHandlerAdapter() {
-        msgMatcher = TypeParameterMatcher.find(this, ChannelInboundMessageHandlerAdapter.class, "I");
-    }
-
-    protected ChannelInboundMessageHandlerAdapter(Class<? extends I> inboundMessageType) {
-        msgMatcher = TypeParameterMatcher.get(inboundMessageType);
-    }
-
-    @Override
-    public MessageBuf<I> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return Unpooled.messageBuffer();
-    }
-
-    @Override
-    public final void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        ChannelHandlerUtil.handleInboundBufferUpdated(ctx, this);
-    }
-
-    @Override
-    public boolean acceptInboundMessage(Object msg) throws Exception {
-        return msgMatcher.match(msg);
-    }
-
-    @Override
-    public boolean beginMessageReceived(ChannelHandlerContext ctx) throws Exception {
-        return true;
-    }
-
-    @Override
-    public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
-        // NOOP
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelInitializer.java b/transport/src/main/java/io/netty/channel/ChannelInitializer.java
index a183b01cc0a4..d03cc2e58518 100644
--- a/transport/src/main/java/io/netty/channel/ChannelInitializer.java
+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java
@@ -22,7 +22,7 @@
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 /**
- * A special {@link ChannelStateHandler} which offers an easy way to initialize a {@link Channel} once it was
+ * A special {@link ChannelInboundHandler} which offers an easy way to initialize a {@link Channel} once it was
  * registered to its {@link EventLoop}.
  *
  * Implementations are most often used in the context of {@link Bootstrap#handler(ChannelHandler)} ,
@@ -47,7 +47,7 @@
  * @param <C>   A sub-type of {@link Channel}
  */
 @Sharable
-public abstract class ChannelInitializer<C extends Channel> extends ChannelStateHandlerAdapter {
+public abstract class ChannelInitializer<C extends Channel> extends ChannelInboundHandlerAdapter {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(ChannelInitializer.class);
 
@@ -83,9 +83,4 @@ public final void channelRegistered(ChannelHandlerContext ctx)
             }
         }
     }
-
-    @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        ctx.fireInboundBufferUpdated();
-    }
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelMetadata.java b/transport/src/main/java/io/netty/channel/ChannelMetadata.java
index c5d2a2cd51ba..628ad43fdddd 100644
--- a/transport/src/main/java/io/netty/channel/ChannelMetadata.java
+++ b/transport/src/main/java/io/netty/channel/ChannelMetadata.java
@@ -15,8 +15,6 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.BufType;
-
 import java.net.SocketAddress;
 
 /**
@@ -24,33 +22,19 @@
  */
 public final class ChannelMetadata {
 
-    private final BufType bufferType;
     private final boolean hasDisconnect;
 
     /**
      * Create a new instance
      *
-     * @param bufferType        the {@link BufType} which will be used by the {@link Channel}.
      * @param hasDisconnect     {@code true} if and only if the channel has the {@code disconnect()} operation
      *                          that allows a user to disconnect and then call {@link Channel#connect(SocketAddress)}
      *                                      again, such as UDP/IP.
      */
-    public ChannelMetadata(BufType bufferType, boolean hasDisconnect) {
-        if (bufferType == null) {
-            throw new NullPointerException("bufferType");
-        }
-
-        this.bufferType = bufferType;
+    public ChannelMetadata(boolean hasDisconnect) {
         this.hasDisconnect = hasDisconnect;
     }
 
-    /**
-     * Returns the {@link BufType} which will be used by the {@link Channel}.
-     */
-    public BufType bufferType() {
-        return bufferType;
-    }
-
     /**
      * Returns {@code true} if and only if the channel has the {@code disconnect()} operation
      * that allows a user to disconnect and then call {@link Channel#connect(SocketAddress)} again,
diff --git a/transport/src/main/java/io/netty/channel/ChannelOperationHandler.java b/transport/src/main/java/io/netty/channel/ChannelOperationHandler.java
deleted file mode 100644
index 3ff70f5ce380..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelOperationHandler.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import java.net.SocketAddress;
-
-/**
- * {@link ChannelHandler} which will get notified for IO-outbound-operations.
- */
-public interface ChannelOperationHandler extends ChannelHandler {
-    /**
-     * Called once a bind operation is made.
-     *
-     * @param ctx           the {@link ChannelHandlerContext} for which the bind operation is made
-     * @param localAddress  the {@link SocketAddress} to which it should bound
-     * @param promise       the {@link ChannelPromise} to notify once the operation completes
-     * @throws Exception    thrown if an error accour
-     */
-    void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception;
-
-    /**
-     * Called once a connect operation is made.
-     *
-     * @param ctx               the {@link ChannelHandlerContext} for which the connect operation is made
-     * @param remoteAddress     the {@link SocketAddress} to which it should connect
-     * @param localAddress      the {@link SocketAddress} which is used as source on connect
-     * @param promise           the {@link ChannelPromise} to notify once the operation completes
-     * @throws Exception        thrown if an error accour
-     */
-    void connect(
-            ChannelHandlerContext ctx, SocketAddress remoteAddress,
-            SocketAddress localAddress, ChannelPromise promise) throws Exception;
-
-    /**
-     * Called once a disconnect operation is made.
-     *
-     * @param ctx               the {@link ChannelHandlerContext} for which the disconnect operation is made
-     * @param promise           the {@link ChannelPromise} to notify once the operation completes
-     * @throws Exception        thrown if an error accour
-     */
-    void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
-
-    /**
-     * Called once a close operation is made.
-     *
-     * @param ctx               the {@link ChannelHandlerContext} for which the close operation is made
-     * @param promise           the {@link ChannelPromise} to notify once the operation completes
-     * @throws Exception        thrown if an error accour
-     */
-    void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
-
-    /**
-     * Called once a deregister operation is made from the current registered {@link EventLoop}.
-     *
-     * @param ctx               the {@link ChannelHandlerContext} for which the close operation is made
-     * @param promise           the {@link ChannelPromise} to notify once the operation completes
-     * @throws Exception        thrown if an error accour
-     */
-    void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
-
-    /**
-     * Intercepts {@link ChannelHandlerContext#read()}.
-     */
-    void read(ChannelHandlerContext ctx);
-
-    /**
-     * Called once a flush operation is made and so the outbound data should be written.
-     *
-     * @param ctx               the {@link ChannelHandlerContext} for which the flush operation is made
-     * @param promise           the {@link ChannelPromise} to notify once the operation completes
-     * @throws Exception        thrown if an error accour
-     */
-    void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
-
-    /**
-     * Called once a sendFile operation is made and so the {@link FileRegion} should be transfered.
-     *
-     * @param ctx               the {@link ChannelHandlerContext} for which the flush operation is made
-     * @param region            the {@link FileRegion} to transfer
-     * @param promise           the {@link ChannelPromise} to notify once the operation completes
-     * @throws Exception        thrown if an error accour
-     */
-    void sendFile(ChannelHandlerContext ctx, FileRegion region, ChannelPromise promise) throws Exception;
-
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelOption.java b/transport/src/main/java/io/netty/channel/ChannelOption.java
index 6ad40e1dd651..f7231ee844fb 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOption.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java
@@ -35,17 +35,25 @@ public class ChannelOption<T> extends UniqueName {
 
     private static final ConcurrentMap<String, Boolean> names = PlatformDependent.newConcurrentHashMap();
 
-    public static final ChannelOption<ByteBufAllocator> ALLOCATOR = new ChannelOption<ByteBufAllocator>("ALLOCATOR");
+    public static final ChannelOption<ByteBufAllocator> ALLOCATOR =
+            new ChannelOption<ByteBufAllocator>("ALLOCATOR");
+    public static final ChannelOption<RecvByteBufAllocator> RCVBUF_ALLOCATOR =
+            new ChannelOption<RecvByteBufAllocator>("RCVBUF_ALLOCATOR");
+
     public static final ChannelOption<Integer> CONNECT_TIMEOUT_MILLIS =
             new ChannelOption<Integer>("CONNECT_TIMEOUT_MILLIS");
     public static final ChannelOption<Integer> WRITE_SPIN_COUNT =
             new ChannelOption<Integer>("WRITE_SPIN_COUNT");
+    public static final ChannelOption<Integer> WRITE_BUFFER_HIGH_WATER_MARK =
+            new ChannelOption<Integer>("WRITE_BUFFER_HIGH_WATER_MARK");
+    public static final ChannelOption<Integer> WRITE_BUFFER_LOW_WATER_MARK =
+            new ChannelOption<Integer>("WRITE_BUFFER_LOW_WATER_MARK");
+
     public static final ChannelOption<Boolean> ALLOW_HALF_CLOSURE =
             new ChannelOption<Boolean>("ALLOW_HALF_CLOSURE");
     public static final ChannelOption<Boolean> AUTO_READ =
             new ChannelOption<Boolean>("AUTO_READ");
-    public static final ChannelOption<ChannelConfig.ChannelHandlerByteBufType> DEFAULT_HANDLER_BYTEBUF_TYPE =
-            new ChannelOption<ChannelConfig.ChannelHandlerByteBufType>("DEFAULT_HANDLER_BYTEBUF_TYPE");
+
     public static final ChannelOption<Boolean> SO_BROADCAST =
             new ChannelOption<Boolean>("SO_BROADCAST");
     public static final ChannelOption<Boolean> SO_KEEPALIVE =
@@ -74,9 +82,6 @@ public class ChannelOption<T> extends UniqueName {
     public static final ChannelOption<Boolean> IP_MULTICAST_LOOP_DISABLED =
             new ChannelOption<Boolean>("IP_MULTICAST_LOOP_DISABLED");
 
-    public static final ChannelOption<Integer> UDP_RECEIVE_PACKET_SIZE =
-            new ChannelOption<Integer>("UDP_RECEIVE_PACKET_SIZE");
-
     public static final ChannelOption<Boolean> TCP_NODELAY =
             new ChannelOption<Boolean>("TCP_NODELAY");
 
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
new file mode 100644
index 000000000000..a6457a171762
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/*
+ * Written by Josh Bloch of Google Inc. and released to the public domain,
+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
+ */
+package io.netty.channel;
+
+import io.netty.buffer.ByteBufUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+final class ChannelOutboundBuffer {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(ChannelOutboundBuffer.class);
+
+    private static final int MIN_INITIAL_CAPACITY = 8;
+
+    ChannelPromise currentPromise;
+    MessageList<Object> currentMessages;
+    int currentMessageIndex;
+    private int currentMessageListSize;
+
+    private ChannelPromise[] promises;
+    private MessageList<Object>[] messages;
+
+    private int head;
+    private int tail;
+    private final AbstractChannel channel;
+
+    private int pendingOutboundBytes;
+
+    private static final AtomicIntegerFieldUpdater<ChannelOutboundBuffer> WRITABLE_UPDATER =
+            AtomicIntegerFieldUpdater.newUpdater(ChannelOutboundBuffer.class, "writable");
+
+    @SuppressWarnings("unused")
+    private volatile int writable = 1;
+
+    ChannelOutboundBuffer(AbstractChannel channel) {
+        this(channel, MIN_INITIAL_CAPACITY << 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    ChannelOutboundBuffer(AbstractChannel channel, int initialCapacity) {
+        if (initialCapacity < 0) {
+            throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: >= 0)");
+        }
+        // Find the best power of two to hold elements.
+        // Tests "<=" because arrays aren't kept full.
+        if (initialCapacity >= MIN_INITIAL_CAPACITY) {
+            initialCapacity |= initialCapacity >>>  1;
+            initialCapacity |= initialCapacity >>>  2;
+            initialCapacity |= initialCapacity >>>  4;
+            initialCapacity |= initialCapacity >>>  8;
+            initialCapacity |= initialCapacity >>> 16;
+            initialCapacity ++;
+
+            if (initialCapacity < 0) {  // Too many elements, must back off
+                initialCapacity >>>= 1; // Good luck allocating 2 ^ 30 elements
+            }
+        } else {
+            initialCapacity = MIN_INITIAL_CAPACITY;
+        }
+
+        promises = new ChannelPromise[initialCapacity];
+        messages = new MessageList[initialCapacity];
+        this.channel = channel;
+    }
+
+    @SuppressWarnings("unchecked")
+    void add(MessageList<?> msgs, ChannelPromise promise) {
+        int tail = this.tail;
+        promises[tail] = promise;
+        messages[tail] = (MessageList<Object>) msgs;
+
+        if ((this.tail = tail + 1 & promises.length - 1) == head) {
+            doubleCapacity();
+        }
+
+        incrementPendingOutboundBytes(messageListSize(msgs));
+    }
+
+    private void incrementPendingOutboundBytes(int size) {
+        if (size == 0) {
+            return;
+        }
+
+        int newWriteBufferSize = pendingOutboundBytes += size;
+        int highWaterMark = channel.config().getWriteBufferHighWaterMark();
+
+        if (newWriteBufferSize > highWaterMark) {
+            if (WRITABLE_UPDATER.compareAndSet(this, 1, 0)) {
+                channel.pipeline().fireChannelWritabilityChanged();
+            }
+        }
+    }
+
+    private void decrementPendingOutboundBytes(int size) {
+        if (size == 0) {
+            return;
+        }
+
+        int newWriteBufferSize =  pendingOutboundBytes -= size;
+        int lowWaterMark = channel.config().getWriteBufferLowWaterMark();
+
+        if (newWriteBufferSize == 0 || newWriteBufferSize < lowWaterMark) {
+
+            if (WRITABLE_UPDATER.compareAndSet(this, 0, 1)) {
+                channel.pipeline().fireChannelWritabilityChanged();
+            }
+        }
+    }
+
+    private void doubleCapacity() {
+        assert head == tail;
+
+        int p = head;
+        int n = promises.length;
+        int r = n - p; // number of elements to the right of p
+        int newCapacity = n << 1;
+        if (newCapacity < 0) {
+            throw new IllegalStateException("Sorry, deque too big");
+        }
+
+        ChannelPromise[] a1 = new ChannelPromise[newCapacity];
+        System.arraycopy(promises, p, a1, 0, r);
+        System.arraycopy(promises, 0, a1, r, p);
+        promises = a1;
+
+        @SuppressWarnings("unchecked")
+        MessageList<Object>[] a2 = new MessageList[newCapacity];
+        System.arraycopy(messages, p, a2, 0, r);
+        System.arraycopy(messages, 0, a2, r, p);
+        messages = a2;
+
+        head = 0;
+        tail = n;
+    }
+
+    boolean next() {
+        decrementPendingOutboundBytes(currentMessageListSize);
+
+        int h = head;
+
+        ChannelPromise e = promises[h]; // Element is null if deque empty
+        if (e == null) {
+            currentMessageListSize = 0;
+            currentPromise = null;
+            currentMessages = null;
+            return false;
+        }
+
+        currentPromise = e;
+        currentMessages = messages[h];
+        currentMessageIndex = 0;
+        currentMessageListSize = messageListSize(currentMessages);
+
+        promises[h] = null;
+        messages[h] = null;
+
+        head = h + 1 & promises.length - 1;
+        return true;
+    }
+
+    private int messageListSize(MessageList<?> messages) {
+        int size = 0;
+        for (int i = 0; i < messages.size(); i++) {
+            size += channel.calculateMessageSize(messages.get(i));
+        }
+        return size;
+    }
+
+    boolean getWritable() {
+        return WRITABLE_UPDATER.get(this) == 1;
+    }
+
+    int size() {
+        return tail - head & promises.length - 1;
+    }
+
+    boolean isEmpty() {
+        return head == tail;
+    }
+
+    void clear() {
+        int head = this.head;
+        int tail = this.tail;
+        if (head != tail) {
+            this.head = this.tail = 0;
+            final int mask = promises.length - 1;
+            int i = head;
+            do {
+                promises[i] = null;
+                messages[i] = null;
+                i = i + 1 & mask;
+            } while (i != tail);
+        }
+    }
+
+    void fail(Throwable cause) {
+        if (currentPromise == null) {
+            if (!next()) {
+                return;
+            }
+        }
+
+        do {
+            if (!currentPromise.tryFailure(cause)) {
+                logger.warn("Promise done already:", cause);
+            }
+
+            // Release all failed messages.
+            try {
+                for (int i = currentMessageIndex; i < currentMessages.size(); i++) {
+                    Object msg = currentMessages.get(i);
+                    ByteBufUtil.release(msg);
+                }
+            } finally {
+                currentMessages.recycle();
+            }
+        } while(next());
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundByteHandler.java b/transport/src/main/java/io/netty/channel/ChannelOutboundByteHandler.java
deleted file mode 100644
index 82b042fe0d7a..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundByteHandler.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-
-/**
- * {@link ChannelOutboundHandler} which operates on bytes which are hold in a {@link ByteBuf}.
- */
-public interface ChannelOutboundByteHandler extends ChannelOutboundHandler {
-    /**
-     * {@inheritDoc}
-     * <p>
-     * An implementation should respect the {@link ChannelConfig#getDefaultHandlerByteBufType()} setting unless
-     * there's a good reason to ignore it.  If in doubt, use {@link ChannelHandlerUtil#allocate(ChannelHandlerContext)}.
-     * </p>
-     */
-    @Override
-    ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception;
-
-    /**
-     * Discards the read bytes of the outbound buffer and optionally trims its unused portion to reduce memory
-     * consumption. The most common implementation of this method will look like the following:
-     * <pre>
-     *     ctx.outboundByteBuffer().discardSomeReadBytes();
-     * </pre>
-     */
-    void discardOutboundReadBytes(ChannelHandlerContext ctx) throws Exception;
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundByteHandlerAdapter.java b/transport/src/main/java/io/netty/channel/ChannelOutboundByteHandlerAdapter.java
deleted file mode 100644
index d5036d6e20f9..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundByteHandlerAdapter.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-
-/**
- * Abstract base class which handles outgoing bytes.
- */
-public abstract class ChannelOutboundByteHandlerAdapter
-        extends ChannelOperationHandlerAdapter implements ChannelOutboundByteHandler {
-    @Override
-    public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return ChannelHandlerUtil.allocate(ctx);
-    }
-
-    @Override
-    public void discardOutboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-        ctx.outboundByteBuffer().discardSomeReadBytes();
-    }
-
-    /**
-     * This method merely delegates the flush request to {@link #flush(ChannelHandlerContext, ByteBuf, ChannelPromise)}.
-     */
-    @Override
-    public final void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        flush(ctx, ctx.outboundByteBuffer(), promise);
-    }
-
-    /**
-     * Invoked when a flush request has been issued.
-     *
-     * @param ctx the current context
-     * @param in this handler's outbound buffer
-     * @param promise the promise associate with the current flush request
-     */
-    protected abstract void flush(ChannelHandlerContext ctx, ByteBuf in, ChannelPromise promise) throws Exception;
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java b/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
index 1bcf3325b7df..c55f9d5f5dbf 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java
@@ -15,19 +15,74 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.Buf;
+import java.net.SocketAddress;
 
 /**
- * {@link ChannelOperationHandler} which handles outbound data.
+ * {@link ChannelHandler} which will get notified for IO-outbound-operations.
  */
-interface ChannelOutboundHandler extends ChannelOperationHandler {
+public interface ChannelOutboundHandler extends ChannelHandler {
     /**
-     * Returns a new buffer which will be used to transfer outbound data for the given {@link ChannelHandlerContext}.
-     * <p>
-     * Please note that this method can be called from any thread repeatatively, and thus you should neither perform
-     * stateful operation nor keep the reference of the created buffer as a member variable.  Get it always using
-     * {@link ChannelHandlerContext#outboundByteBuffer()} or {@link ChannelHandlerContext#outboundMessageBuffer()}.
-     * </p>
+     * Called once a bind operation is made.
+     *
+     * @param ctx           the {@link ChannelHandlerContext} for which the bind operation is made
+     * @param localAddress  the {@link SocketAddress} to which it should bound
+     * @param promise       the {@link ChannelPromise} to notify once the operation completes
+     * @throws Exception    thrown if an error accour
      */
-    Buf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception;
+    void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception;
+
+    /**
+     * Called once a connect operation is made.
+     *
+     * @param ctx               the {@link ChannelHandlerContext} for which the connect operation is made
+     * @param remoteAddress     the {@link SocketAddress} to which it should connect
+     * @param localAddress      the {@link SocketAddress} which is used as source on connect
+     * @param promise           the {@link ChannelPromise} to notify once the operation completes
+     * @throws Exception        thrown if an error accour
+     */
+    void connect(
+            ChannelHandlerContext ctx, SocketAddress remoteAddress,
+            SocketAddress localAddress, ChannelPromise promise) throws Exception;
+
+    /**
+     * Called once a disconnect operation is made.
+     *
+     * @param ctx               the {@link ChannelHandlerContext} for which the disconnect operation is made
+     * @param promise           the {@link ChannelPromise} to notify once the operation completes
+     * @throws Exception        thrown if an error accour
+     */
+    void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
+
+    /**
+     * Called once a close operation is made.
+     *
+     * @param ctx               the {@link ChannelHandlerContext} for which the close operation is made
+     * @param promise           the {@link ChannelPromise} to notify once the operation completes
+     * @throws Exception        thrown if an error accour
+     */
+    void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
+
+    /**
+     * Called once a deregister operation is made from the current registered {@link EventLoop}.
+     *
+     * @param ctx               the {@link ChannelHandlerContext} for which the close operation is made
+     * @param promise           the {@link ChannelPromise} to notify once the operation completes
+     * @throws Exception        thrown if an error accour
+     */
+    void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
+
+    /**
+     * Intercepts {@link ChannelHandlerContext#read()}.
+     */
+    void read(ChannelHandlerContext ctx) throws Exception;
+
+    /**
+     * Called once a flush operation is made and so the outbound data should be written.
+     *
+     *
+     * @param ctx               the {@link ChannelHandlerContext} for which the flush operation is made
+     * @param promise           the {@link ChannelPromise} to notify once the operation completes
+     * @throws Exception        thrown if an error accour
+     */
+    void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception;
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelOperationHandlerAdapter.java b/transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java
similarity index 68%
rename from transport/src/main/java/io/netty/channel/ChannelOperationHandlerAdapter.java
rename to transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java
index 7b314b0396a5..abc11403befb 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOperationHandlerAdapter.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java
@@ -18,14 +18,14 @@
 import java.net.SocketAddress;
 
 /**
- * Skelton implementation of a {@link ChannelOperationHandler}. This implementation just forwards each method call via
+ * Skelton implementation of a {@link ChannelOutboundHandler}. This implementation just forwards each method call via
  * the {@link ChannelHandlerContext}.
  */
-public abstract class ChannelOperationHandlerAdapter extends ChannelHandlerAdapter implements ChannelOperationHandler {
+public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {
 
     /**
      * Calls {@link ChannelHandlerContext#bind(SocketAddress, ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -37,7 +37,7 @@ public void bind(ChannelHandlerContext ctx, SocketAddress localAddress,
 
     /**
      * Calls {@link ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -49,7 +49,7 @@ public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
 
     /**
      * Calls {@link ChannelHandlerContext#disconnect(ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -61,7 +61,7 @@ public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise)
 
     /**
      * Calls {@link ChannelHandlerContext#close(ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
@@ -73,35 +73,28 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise)
 
     /**
      * Calls {@link ChannelHandlerContext#close(ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
     @Override
-    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise)
-            throws Exception {
+    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
         ctx.deregister(promise);
     }
 
     /**
      * Calls {@link ChannelHandlerContext#read()} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
+     * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.
      *
      * Sub-classes may override this method to change behavior.
      */
     @Override
-    public void read(ChannelHandlerContext ctx) {
+    public void read(ChannelHandlerContext ctx) throws Exception {
         ctx.read();
     }
 
-    /**
-     * Calls {@link ChannelHandlerContext#sendFile(FileRegion, ChannelPromise)} to forward
-     * to the next {@link ChannelOperationHandler} in the {@link ChannelPipeline}.
-     *
-     * Sub-classes may override this method to change behavior.
-     */
     @Override
-    public void sendFile(ChannelHandlerContext ctx, FileRegion region, ChannelPromise promise) throws Exception {
-        ctx.sendFile(region, promise);
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        ctx.write(msgs, promise);
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
index ed922b20e096..4f16f90aecff 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
@@ -29,8 +29,8 @@ interface ChannelOutboundInvoker {
      * completes, either because the operation was successful or because of an error.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
+     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture bind(SocketAddress localAddress);
@@ -44,8 +44,8 @@ interface ChannelOutboundInvoker {
      * will be used.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture connect(SocketAddress remoteAddress);
@@ -56,8 +56,8 @@ interface ChannelOutboundInvoker {
      * an error.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);
@@ -67,8 +67,8 @@ interface ChannelOutboundInvoker {
      * either because the operation was successful or because of an error.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture disconnect();
@@ -81,8 +81,8 @@ interface ChannelOutboundInvoker {
      * After it is closed it is not possible to reuse it again.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture close();
@@ -93,31 +93,12 @@ interface ChannelOutboundInvoker {
      * an error.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture deregister();
 
-    /**
-     * Request to flush all pending data which belongs to this ChannelOutboundInvoker and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     * <p>
-     * Be aware that the flush could be only partially successful. In such cases the {@link ChannelFuture} will be
-     * failed with an {@link IncompleteFlushException}. So if you are interested to know if it was partial successful
-     * you need to check if the returned {@link ChannelFuture#cause()} returns an instance of
-     * {@link IncompleteFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or
-     * {@link #flush()} to flush the rest of the data or just close the connection via {@link #close(ChannelPromise)} or
-     * {@link #close()}  if it is not possible to recover.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOperationHandler#flush(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture flush();
-
     /**
      * Request to write a message via this ChannelOutboundInvoker and notify the {@link ChannelFuture}
      * once the operation completes, either because the operation was successful or because of an error.
@@ -131,22 +112,12 @@ interface ChannelOutboundInvoker {
      * or {@link #close()} if it is not possible to recover.
      * <p>
      * This will result in having the message added to the outbound buffer of the next {@link ChannelOutboundHandler}
-     * and the {@link ChannelOperationHandler#flush(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * and the {@link ChannelOutboundHandler#flush(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
-    ChannelFuture write(Object message);
-
-    /**
-     * Request to send a {@link FileRegion} via this ChannelOutboundInvoker and notify the {@link ChannelFuture}
-     * once the operation completes, either because the operation was successful or because of an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOperationHandler#sendFile(ChannelHandlerContext, FileRegion, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture sendFile(FileRegion region);
+    ChannelFuture write(Object msg);
+    ChannelFuture write(MessageList<?> msgs);
 
     /**
      * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
@@ -155,8 +126,8 @@ interface ChannelOutboundInvoker {
      * The given {@link ChannelPromise} will be notified.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
+     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise);
@@ -173,8 +144,8 @@ interface ChannelOutboundInvoker {
      * will be used.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise);
@@ -187,8 +158,8 @@ interface ChannelOutboundInvoker {
      * The given {@link ChannelPromise} will be notified and also returned.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
@@ -200,8 +171,8 @@ interface ChannelOutboundInvoker {
      * The given {@link ChannelPromise} will be notified.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture disconnect(ChannelPromise promise);
@@ -215,8 +186,8 @@ interface ChannelOutboundInvoker {
      * The given {@link ChannelPromise} will be notified.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture close(ChannelPromise promise);
@@ -229,48 +200,26 @@ interface ChannelOutboundInvoker {
      * The given {@link ChannelPromise} will be notified.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     ChannelFuture deregister(ChannelPromise promise);
 
     /**
      * Request to Read data from the {@link Channel} into the first inbound buffer, triggers an
-     * {@link ChannelStateHandler#inboundBufferUpdated(ChannelHandlerContext) inboundBufferUpdated} event if data was
+     * {@link ChannelInboundHandler#inboundBufferUpdated(ChannelHandlerContext) inboundBufferUpdated} event if data was
      * read, and triggers an
-     * {@link ChannelStateHandler#channelReadSuspended(ChannelHandlerContext) channelReadSuspended} event so the
+     * {@link ChannelInboundHandler#channelReadSuspended(ChannelHandlerContext) channelReadSuspended} event so the
      * handler can decide to continue reading.  If there's a pending read operation already, this method does nothing.
      * <p>
      * This will result in having the
-     * {@link ChannelOperationHandler#read(ChannelHandlerContext)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link ChannelOutboundHandler#read(ChannelHandlerContext)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
     void read();
 
-    /**
-     * Request to flush all pending data which belongs to this ChannelOutboundInvoker and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     * <p>
-     * Be aware that the flush could be only partially successful. In such cases the {@link ChannelFuture} will be
-     * failed with an {@link IncompleteFlushException}. So if you are interested to know if it was partial successful
-     * you need to check if the returned {@link ChannelFuture#cause()} returns an instance of
-     * {@link IncompleteFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or
-     * {@link #flush()} to flush the rest of the data or just close the connection via {@link #close(ChannelPromise)} or
-     * {@link #close()}  if it is not possible to recover.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOperationHandler#flush(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     *
-     */
-    ChannelFuture flush(ChannelPromise promise);
-
     /**
      * Request to write a message via this ChannelOutboundInvoker and notify the {@link ChannelFuture}
      * once the operation completes, either because the operation was successful or because of an error.
@@ -286,22 +235,10 @@ interface ChannelOutboundInvoker {
      * The given {@link ChannelPromise} will be notified.
      * <p>
      * This will result in having the message added to the outbound buffer of the next {@link ChannelOutboundHandler}
-     * and the {@link ChannelOperationHandler#flush(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture write(Object message, ChannelPromise promise);
-
-    /**
-     * Request to send a {@link FileRegion} via this ChannelOutboundInvoker and notify the {@link ChannelFuture}
-     * once the operation completes, either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOperationHandler#sendFile(ChannelHandlerContext, FileRegion, ChannelPromise)}
-     * method called of the next {@link ChannelOperationHandler} contained in the  {@link ChannelPipeline} of the
+     * and the {@link ChannelOutboundHandler#flush(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
      * {@link Channel}.
      */
-    ChannelFuture sendFile(FileRegion region, ChannelPromise promise);
+    ChannelFuture write(Object msg, ChannelPromise promise);
+    ChannelFuture write(MessageList<?> msgs, ChannelPromise promise);
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandler.java b/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandler.java
deleted file mode 100644
index eb2a1ad4be64..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandler.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-
-/**
- * ChannelOutboundHandler implementation which operates on messages of a specific type
- * by pass them in a {@link MessageBuf} and consume then from there.
- *
- * If your {@link ChannelOutboundMessageHandler} handles messages of type {@link ByteBuf} or {@link Object}
- * and you want to add a {@link ByteBuf} to the next buffer in the {@link ChannelPipeline} use
- * {@link ChannelHandlerUtil#addToNextOutboundBuffer(ChannelHandlerContext, Object)}.
- *
- * @param <I>   the message type
- */
-public interface ChannelOutboundMessageHandler<I> extends ChannelOutboundHandler {
-    @Override
-    MessageBuf<I> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception;
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java b/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java
deleted file mode 100644
index 4889e035a562..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelHandlerUtil.SingleOutboundMessageHandler;
-import io.netty.util.Signal;
-import io.netty.util.internal.TypeParameterMatcher;
-
-/**
- * Abstract base class which handles messages of a specific type.
- *
- * If your {@link ChannelOutboundMessageHandlerAdapter} handles messages of type {@link ByteBuf} or {@link Object}
- * and you want to add a {@link ByteBuf} to the next buffer in the {@link ChannelPipeline} use
- * {@link ChannelHandlerUtil#addToNextOutboundBuffer(ChannelHandlerContext, Object)}.
- *
- * <p>
- * One limitation to keep in mind is that it is not possible to detect the handled message type of you specify
- * {@code I} while instance your class. Because of this Netty does not allow to do so and will throw an Exception
- * if you try. For this cases you should handle the type detection by your self by override the
- * {@link #acceptOutboundMessage(Object)} method and use {@link Object} as type parameter.
- *
- * <pre>
- *    public class GenericHandler&lt;I&gt; extends
- *             {@link ChannelOutboundMessageHandlerAdapter}&lt;{@link Object}&gt; {
- *
- *         {@code @Override}
- *         public void flush({@link ChannelHandlerContext} ctx, {@link Object} message)
- *                 throws {@link Exception} {
- *             I msg = (I) message;
- *             // Do something with the msg
- *             ...
- *             ...
- *         }
- *
- *         {@code @Override}
- *         public boolean acceptOutboundMessage(Object msg) throws Exception {
- *             // Add your check here
- *         }
- *     }
- * </pre>
- * @param <I>   The type of the messages to handle
- */
-public abstract class ChannelOutboundMessageHandlerAdapter<I>
-        extends ChannelOperationHandlerAdapter
-        implements ChannelOutboundMessageHandler<I>, SingleOutboundMessageHandler<I> {
-
-    /**
-     * Thrown by {@link #flush(ChannelHandlerContext, Object)} to abort message processing.
-     */
-    protected static final Signal ABORT = ChannelHandlerUtil.ABORT;
-
-    private final TypeParameterMatcher msgMatcher;
-    private boolean closeOnFailedFlush = true;
-
-    protected ChannelOutboundMessageHandlerAdapter() {
-        msgMatcher = TypeParameterMatcher.find(this, ChannelOutboundMessageHandlerAdapter.class, "I");
-    }
-
-    protected ChannelOutboundMessageHandlerAdapter(Class<? extends I> outboundMessageType) {
-        msgMatcher = TypeParameterMatcher.get(outboundMessageType);
-    }
-
-    protected final boolean isCloseOnFailedFlush() {
-        return closeOnFailedFlush;
-    }
-
-    protected final void setCloseOnFailedFlush(boolean closeOnFailedFlush) {
-        this.closeOnFailedFlush = closeOnFailedFlush;
-    }
-
-    @Override
-    public MessageBuf<I> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-        return Unpooled.messageBuffer();
-    }
-
-    @Override
-    public final void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        ChannelHandlerUtil.handleFlush(ctx, promise, isCloseOnFailedFlush(), this);
-    }
-
-    @Override
-    public boolean acceptOutboundMessage(Object msg) throws Exception {
-        return msgMatcher.match(msg);
-    }
-
-    @Override
-    public boolean beginFlush(ChannelHandlerContext ctx) throws Exception {
-        return true;
-    }
-
-    @Override
-    public void endFlush(ChannelHandlerContext ctx) throws Exception { }
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelPipeline.java b/transport/src/main/java/io/netty/channel/ChannelPipeline.java
index f9f7944dd04d..26eb38705395 100644
--- a/transport/src/main/java/io/netty/channel/ChannelPipeline.java
+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java
@@ -15,9 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.Buf;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
 import io.netty.util.concurrent.EventExecutorGroup;
 
 import java.io.InputStream;
@@ -176,46 +174,6 @@
 public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundInvoker,
         Iterable<Entry<String, ChannelHandler>> {
 
-    /**
-     * Return the bound {@link MessageBuf} of the first {@link ChannelInboundMessageHandler} in the
-     * {@link ChannelPipeline}. If no {@link ChannelInboundMessageHandler} exists in the {@link ChannelPipeline}
-     * it will throw a {@link UnsupportedOperationException}.
-     * <p/>
-     * This method can only be called from within the event-loop, otherwise it will throw an
-     * {@link IllegalStateException}.
-     */
-    <T> MessageBuf<T> inboundMessageBuffer();
-
-    /**
-     * Return the bound {@link ByteBuf} of the first {@link ChannelInboundByteHandler} in the
-     * {@link ChannelPipeline}. If no {@link ChannelInboundByteHandler} exists in the {@link ChannelPipeline}
-     * it will throw a {@link UnsupportedOperationException}.
-     * <p/>
-     * This method can only be called from within the event-loop, otherwise it will throw an
-     * {@link IllegalStateException}.
-     */
-    ByteBuf inboundByteBuffer();
-
-    /**
-     * Return the bound {@link MessageBuf} of the first {@link ChannelOutboundMessageHandler} in the
-     * {@link ChannelPipeline}. If no {@link ChannelOutboundMessageHandler} exists in the {@link ChannelPipeline}
-     * it will throw a {@link UnsupportedOperationException}.
-     * <p/>
-     * This method can only be called from within the event-loop, otherwise it will throw an
-     * {@link IllegalStateException}.
-     */
-    <T> MessageBuf<T> outboundMessageBuffer();
-
-    /**
-     * Return the bound {@link ByteBuf} of the first {@link ChannelOutboundByteHandler} in the
-     * {@link ChannelPipeline}. If no {@link ChannelOutboundByteHandler} exists in the {@link ChannelPipeline}
-     * it will throw a {@link UnsupportedOperationException}.
-     * <p/>
-     * This method can only be called from within the event-loop, otherwise it will throw an
-     * {@link IllegalStateException}.
-     */
-    ByteBuf outboundByteBuffer();
-
     /**
      * Inserts a {@link ChannelHandler} at the first position of this pipeline.
      *
@@ -381,9 +339,7 @@ public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundI
     ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers);
 
     /**
-     * Removes the specified {@link ChannelHandler} from this pipeline
-     * and transfer the content of its {@link Buf} to the next
-     * {@link ChannelHandler} in the {@link ChannelPipeline}.
+     * Removes the specified {@link ChannelHandler} from this pipeline.
      *
      * @param  handler          the {@link ChannelHandler} to remove
      *
@@ -395,9 +351,7 @@ public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundI
     ChannelPipeline remove(ChannelHandler handler);
 
     /**
-     * Removes the {@link ChannelHandler} with the specified name from this
-     * pipeline and transfer the content of its {@link Buf} to the next
-     * {@link ChannelHandler} in the {@link ChannelPipeline}.
+     * Removes the {@link ChannelHandler} with the specified name from this pipeline.
      *
      * @param  name             the name under which the {@link ChannelHandler} was stored.
      *
@@ -411,9 +365,7 @@ public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundI
     ChannelHandler remove(String name);
 
     /**
-     * Removes the {@link ChannelHandler} of the specified type from this
-     * pipeline and transfer the content of its {@link Buf} to the next
-     * {@link ChannelHandler} in the {@link ChannelPipeline}.
+     * Removes the {@link ChannelHandler} of the specified type from this pipeline.
      *
      * @param <T>           the type of the handler
      * @param handlerType   the type of the handler
@@ -430,9 +382,6 @@ public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundI
     /**
      * Removes the first {@link ChannelHandler} in this pipeline.
      *
-     * All the remaining content in the {@link Buf) (if any) of the {@link ChannelHandler}
-     * will be discarded.
-     *
      * @return the removed handler
      *
      * @throws NoSuchElementException
@@ -443,9 +392,6 @@ public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundI
     /**
      * Removes the last {@link ChannelHandler} in this pipeline.
      *
-     * All the remaining content in the {@link Buf) (if any) of the {@link ChannelHandler}
-     * will be discarded.
-     *
      * @return the removed handler
      *
      * @throws NoSuchElementException
@@ -454,9 +400,7 @@ public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundI
     ChannelHandler removeLast();
 
     /**
-     * Replaces the specified {@link ChannelHandler} with a new handler in
-     * this pipeline and transfer the content of its {@link Buf} to the next
-     * {@link ChannelHandler} in the {@link ChannelPipeline}.
+     * Replaces the specified {@link ChannelHandler} with a new handler in this pipeline.
      *
      * @param  oldHandler    the {@link ChannelHandler} to be replaced
      * @param  newName       the name under which the replacement should be added
@@ -476,9 +420,7 @@ public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundI
     ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);
 
     /**
-     * Replaces the {@link ChannelHandler} of the specified name with a new
-     * handler in this pipeline and transfer the content of its {@link Buf} to the next
-     * {@link ChannelHandler} in the {@link ChannelPipeline}.
+     * Replaces the {@link ChannelHandler} of the specified name with a new handler in this pipeline.
      *
      * @param  oldName       the name of the {@link ChannelHandler} to be replaced
      * @param  newName       the name under which the replacement should be added
@@ -498,9 +440,7 @@ public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundI
     ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler);
 
     /**
-     * Replaces the {@link ChannelHandler} of the specified type with a new
-     * handler in this pipeline and transfer the content of its {@link Buf} to the next
-     * {@link ChannelHandler} in the {@link ChannelPipeline}.
+     * Replaces the {@link ChannelHandler} of the specified type with a new handler in this pipeline.
      *
      * @param  oldHandlerType   the type of the handler to be removed
      * @param  newName          the name under which the replacement should be added
@@ -631,8 +571,14 @@ <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
     ChannelPipeline fireUserEventTriggered(Object event);
 
     @Override
-    ChannelPipeline fireInboundBufferUpdated();
+    ChannelPipeline fireMessageReceived(Object msg);
+
+    @Override
+    ChannelPipeline fireMessageReceived(MessageList<?> msgs);
 
     @Override
     ChannelPipeline fireChannelReadSuspended();
+
+    @Override
+    ChannelPipeline fireChannelWritabilityChanged();
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelProgressiveFuture.java b/transport/src/main/java/io/netty/channel/ChannelProgressiveFuture.java
index abd261bf882f..c33ab9a4d25b 100644
--- a/transport/src/main/java/io/netty/channel/ChannelProgressiveFuture.java
+++ b/transport/src/main/java/io/netty/channel/ChannelProgressiveFuture.java
@@ -24,16 +24,16 @@
  */
 public interface ChannelProgressiveFuture extends ChannelFuture, ProgressiveFuture<Void> {
     @Override
-    ChannelProgressiveFuture addListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelProgressiveFuture addListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelProgressiveFuture addListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelProgressiveFuture addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
-    ChannelProgressiveFuture removeListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelProgressiveFuture removeListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelProgressiveFuture removeListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelProgressiveFuture removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
     ChannelProgressiveFuture sync() throws InterruptedException;
diff --git a/transport/src/main/java/io/netty/channel/ChannelProgressivePromise.java b/transport/src/main/java/io/netty/channel/ChannelProgressivePromise.java
index 4b3744bd3f4b..b665b7d4e390 100644
--- a/transport/src/main/java/io/netty/channel/ChannelProgressivePromise.java
+++ b/transport/src/main/java/io/netty/channel/ChannelProgressivePromise.java
@@ -25,16 +25,16 @@
 public interface ChannelProgressivePromise extends ProgressivePromise<Void>, ChannelProgressiveFuture, ChannelPromise {
 
     @Override
-    ChannelProgressivePromise addListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelProgressivePromise addListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelProgressivePromise addListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelProgressivePromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
-    ChannelProgressivePromise removeListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelProgressivePromise removeListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelProgressivePromise removeListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelProgressivePromise removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
     ChannelProgressivePromise sync() throws InterruptedException;
diff --git a/transport/src/main/java/io/netty/channel/ChannelPromise.java b/transport/src/main/java/io/netty/channel/ChannelPromise.java
index 31d284654c12..b808c6395a3c 100644
--- a/transport/src/main/java/io/netty/channel/ChannelPromise.java
+++ b/transport/src/main/java/io/netty/channel/ChannelPromise.java
@@ -38,16 +38,16 @@ public interface ChannelPromise extends ChannelFuture, Promise<Void> {
     ChannelPromise setFailure(Throwable cause);
 
     @Override
-    ChannelPromise addListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelPromise addListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelPromise addListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelPromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
-    ChannelPromise removeListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelPromise removeListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelPromise removeListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelPromise removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
     ChannelPromise sync() throws InterruptedException;
diff --git a/transport/src/main/java/io/netty/channel/ChannelStateHandler.java b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java
deleted file mode 100755
index 9ce18bcaff88..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelStateHandler.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-/**
- * {@link ChannelHandler} which adds callbacks for state changes. This allows the user
- * to hook in to state changes easily.
- */
-public interface ChannelStateHandler extends ChannelHandler {
-
-    /**
-     * The {@link Channel} of the {@link ChannelHandlerContext} was registered with its {@link EventLoop}
-     */
-    void channelRegistered(ChannelHandlerContext ctx) throws Exception;
-
-    /**
-     * The {@link Channel} of the {@link ChannelHandlerContext} was unregistered from its {@link EventLoop}
-     */
-    void channelUnregistered(ChannelHandlerContext ctx) throws Exception;
-
-    /**
-     * The {@link Channel} of the {@link ChannelHandlerContext} is now active
-     */
-    void channelActive(ChannelHandlerContext ctx) throws Exception;
-
-    /**
-     * The {@link Channel} of the {@link ChannelHandlerContext} was registered is now inactive and reached its
-     * end of lifetime.
-     */
-    void channelInactive(ChannelHandlerContext ctx) throws Exception;
-
-    /**
-     * Invoked when a {@link ChannelHandlerContext#read()} is finished and the inbound buffer of this handler will not
-     * be updated until another {@link ChannelHandlerContext#read()} request is issued.
-     */
-    void channelReadSuspended(ChannelHandlerContext ctx) throws Exception;
-
-    /**
-     * The inbound buffer of the {@link ChannelHandlerContext} was updated with new data.
-     * This means something may be ready to get processed by the actual {@link ChannelStateHandler}
-     * implementation. It's up to the implementation to consume it or keep it in the buffer
-     * to wait for more data and consume it later.
-     */
-    void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception;
-
-    /**
-     * Gets called if an user event was triggered.
-     */
-    void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;
-}
diff --git a/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java b/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
index ab7faf2e6c50..34dd384fa85b 100644
--- a/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
+++ b/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
@@ -18,17 +18,18 @@
 import java.net.SocketAddress;
 
 /**
- *  Combines a {@link ChannelStateHandler} and a {@link ChannelOperationHandler} into one {@link ChannelHandler}.
+ *  Combines a {@link ChannelInboundHandler} and a {@link ChannelOutboundHandler} into one {@link ChannelHandler}.
  *
  */
-public class CombinedChannelDuplexHandler extends ChannelDuplexHandler {
+public class CombinedChannelDuplexHandler<I extends ChannelInboundHandler, O extends ChannelOutboundHandler>
+        extends ChannelDuplexHandler {
 
-    private ChannelStateHandler stateHandler;
-    private ChannelOperationHandler operationHandler;
+    private I inboundHandler;
+    private O outboundHandler;
 
     /**
      * Creates a new uninitialized instance. A class that extends this handler must invoke
-     * {@link #init(ChannelStateHandler, ChannelOperationHandler)} before adding this handler into a
+     * {@link #init(ChannelInboundHandler, ChannelOutboundHandler)} before adding this handler into a
      * {@link ChannelPipeline}.
      */
     protected CombinedChannelDuplexHandler() { }
@@ -36,8 +37,8 @@ protected CombinedChannelDuplexHandler() { }
     /**
      * Creates a new instance that combines the specified two handlers into one.
      */
-    public CombinedChannelDuplexHandler(ChannelStateHandler stateHandler, ChannelOperationHandler operationHandler) {
-        init(stateHandler, operationHandler);
+    public CombinedChannelDuplexHandler(I inboundHandler, O outboundHandler) {
+        init(inboundHandler, outboundHandler);
     }
 
     /**
@@ -48,141 +49,110 @@ public CombinedChannelDuplexHandler(ChannelStateHandler stateHandler, ChannelOpe
      * @throws IllegalArgumentException if the specified handlers cannot be combined into one due to a conflict
      *                                  in the type hierarchy
      */
-    protected final void init(ChannelStateHandler stateHandler, ChannelOperationHandler operationHandler) {
-        validate(stateHandler, operationHandler);
-        this.stateHandler = stateHandler;
-        this.operationHandler = operationHandler;
+    protected final void init(I inboundHandler, O outboundHandler) {
+        validate(inboundHandler, outboundHandler);
+        this.inboundHandler = inboundHandler;
+        this.outboundHandler = outboundHandler;
     }
 
     @SuppressWarnings("InstanceofIncompatibleInterface")
-    private void validate(ChannelStateHandler stateHandler, ChannelOperationHandler operationHandler) {
-        if (this.stateHandler != null) {
+    private void validate(I inboundHandler, O outboundHandler) {
+        if (this.inboundHandler != null) {
             throw new IllegalStateException(
                     "init() can not be invoked if " + CombinedChannelDuplexHandler.class.getSimpleName() +
                             " was constructed with non-default constructor.");
         }
 
-        if (stateHandler == null) {
-            throw new NullPointerException("stateHandler");
+        if (inboundHandler == null) {
+            throw new NullPointerException("inboundHandler");
         }
-        if (operationHandler == null) {
-            throw new NullPointerException("operationHandler");
+        if (outboundHandler == null) {
+            throw new NullPointerException("outboundHandler");
         }
-        if (stateHandler instanceof ChannelOperationHandler) {
+        if (inboundHandler instanceof ChannelOutboundHandler) {
             throw new IllegalArgumentException(
-                    "stateHandler must not implement " +
-                    ChannelOperationHandler.class.getSimpleName() + " to get combined.");
+                    "inboundHandler must not implement " +
+                    ChannelOutboundHandler.class.getSimpleName() + " to get combined.");
         }
-        if (operationHandler instanceof ChannelStateHandler) {
+        if (outboundHandler instanceof ChannelInboundHandler) {
             throw new IllegalArgumentException(
-                    "operationHandler must not implement " +
-                    ChannelStateHandler.class.getSimpleName() + " to get combined.");
-        }
-
-        if (stateHandler instanceof ChannelInboundByteHandler && !(this instanceof ChannelInboundByteHandler)) {
-            throw new IllegalStateException(
-                    getClass().getSimpleName() + " must implement " + ChannelInboundByteHandler.class.getSimpleName() +
-                    " if stateHandler implements " + ChannelInboundByteHandler.class.getSimpleName());
-        }
-
-        if (stateHandler instanceof ChannelInboundMessageHandler && !(this instanceof ChannelInboundMessageHandler)) {
-            throw new IllegalStateException(
-                    getClass().getSimpleName() + " must implement " +
-                    ChannelInboundMessageHandler.class.getSimpleName() + " if stateHandler implements " +
-                    ChannelInboundMessageHandler.class.getSimpleName());
-        }
-
-        if (operationHandler instanceof ChannelOutboundByteHandler && !(this instanceof ChannelOutboundByteHandler)) {
-            throw new IllegalStateException(
-                    getClass().getSimpleName() + " must implement " +
-                    ChannelOutboundByteHandler.class.getSimpleName() + " if operationHandler implements " +
-                    ChannelOutboundByteHandler.class.getSimpleName());
-        }
-
-        if (operationHandler instanceof ChannelOutboundMessageHandler &&
-            !(this instanceof ChannelOutboundMessageHandler)) {
-            throw new IllegalStateException(
-                    getClass().getSimpleName() + " must implement " +
-                    ChannelOutboundMessageHandler.class.getSimpleName() + " if operationHandler implements " +
-                    ChannelOutboundMessageHandler.class.getSimpleName());
+                    "outboundHandler must not implement " +
+                    ChannelInboundHandler.class.getSimpleName() + " to get combined.");
         }
     }
 
-    protected final ChannelStateHandler stateHandler() {
-        return stateHandler;
+    protected final I inboundHandler() {
+        return inboundHandler;
     }
 
-    protected final ChannelOperationHandler operationHandler() {
-        return operationHandler;
+    protected final O outboundHandler() {
+        return outboundHandler;
     }
 
     @Override
     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-        if (stateHandler == null) {
+        if (inboundHandler == null) {
             throw new IllegalStateException(
                     "init() must be invoked before being added to a " + ChannelPipeline.class.getSimpleName() +
                             " if " +  CombinedChannelDuplexHandler.class.getSimpleName() +
                             " was constructed with the default constructor.");
         }
         try {
-            stateHandler.handlerAdded(ctx);
+            inboundHandler.handlerAdded(ctx);
         } finally {
-            operationHandler.handlerAdded(ctx);
+            outboundHandler.handlerAdded(ctx);
         }
     }
 
     @Override
     public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
         try {
-            stateHandler.handlerRemoved(ctx);
+            inboundHandler.handlerRemoved(ctx);
         } finally {
-            operationHandler.handlerRemoved(ctx);
+            outboundHandler.handlerRemoved(ctx);
         }
     }
 
     @Override
     public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
-        stateHandler.channelRegistered(ctx);
+        inboundHandler.channelRegistered(ctx);
     }
 
     @Override
     public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
-        stateHandler.channelUnregistered(ctx);
+        inboundHandler.channelUnregistered(ctx);
     }
 
     @Override
     public void channelActive(ChannelHandlerContext ctx) throws Exception {
-        stateHandler.channelActive(ctx);
+        inboundHandler.channelActive(ctx);
     }
 
     @Override
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        stateHandler.channelInactive(ctx);
+        inboundHandler.channelInactive(ctx);
     }
 
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        stateHandler.exceptionCaught(ctx, cause);
+        inboundHandler.exceptionCaught(ctx, cause);
     }
 
     @Override
     public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
-        stateHandler.userEventTriggered(ctx, evt);
+        inboundHandler.userEventTriggered(ctx, evt);
     }
 
     @Override
-    public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        stateHandler.inboundBufferUpdated(ctx);
-        if (stateHandler instanceof ChannelInboundByteHandler) {
-            ((ChannelInboundByteHandler) stateHandler).discardInboundReadBytes(ctx);
-        }
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        inboundHandler.messageReceived(ctx, msgs);
     }
 
     @Override
     public void bind(
             ChannelHandlerContext ctx,
             SocketAddress localAddress, ChannelPromise promise) throws Exception {
-        operationHandler.bind(ctx, localAddress, promise);
+        outboundHandler.bind(ctx, localAddress, promise);
     }
 
     @Override
@@ -190,36 +160,31 @@ public void connect(
             ChannelHandlerContext ctx,
             SocketAddress remoteAddress, SocketAddress localAddress,
             ChannelPromise promise) throws Exception {
-        operationHandler.connect(ctx, remoteAddress, localAddress, promise);
+        outboundHandler.connect(ctx, remoteAddress, localAddress, promise);
     }
 
     @Override
     public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        operationHandler.disconnect(ctx, promise);
+        outboundHandler.disconnect(ctx, promise);
     }
 
     @Override
     public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        operationHandler.close(ctx, promise);
+        outboundHandler.close(ctx, promise);
     }
 
     @Override
     public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        operationHandler.deregister(ctx, promise);
-    }
-
-    @Override
-    public void read(ChannelHandlerContext ctx) {
-        operationHandler.read(ctx);
+        outboundHandler.deregister(ctx, promise);
     }
 
     @Override
-    public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-        operationHandler.flush(ctx, promise);
+    public void read(ChannelHandlerContext ctx) throws Exception {
+        outboundHandler.read(ctx);
     }
 
     @Override
-    public void sendFile(ChannelHandlerContext ctx, FileRegion region, ChannelPromise promise) throws Exception {
-        operationHandler.sendFile(ctx, region, promise);
+    public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+        outboundHandler.write(ctx, msgs, promise);
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java
index 92a1c4774fac..4557aa393875 100644
--- a/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java
+++ b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java
@@ -52,25 +52,25 @@ protected EventExecutor executor() {
     }
 
     @Override
-    public ChannelFuture addListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public ChannelFuture addListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         super.addListener(listener);
         return this;
     }
 
     @Override
-    public ChannelFuture addListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public ChannelFuture addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         super.addListeners(listeners);
         return this;
     }
 
     @Override
-    public ChannelFuture removeListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public ChannelFuture removeListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         super.removeListener(listener);
         return this;
     }
 
     @Override
-    public ChannelFuture removeListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public ChannelFuture removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         super.removeListeners(listeners);
         return this;
     }
diff --git a/transport/src/main/java/io/netty/channel/CompleteChannelPromise.java b/transport/src/main/java/io/netty/channel/CompleteChannelPromise.java
index c46bdc287764..5af2a0103e0f 100644
--- a/transport/src/main/java/io/netty/channel/CompleteChannelPromise.java
+++ b/transport/src/main/java/io/netty/channel/CompleteChannelPromise.java
@@ -67,22 +67,22 @@ public ChannelPromise awaitUninterruptibly() {
     }
 
     @Override
-    public ChannelPromise addListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public ChannelPromise addListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         return (ChannelPromise) super.addListener(listener);
     }
 
     @Override
-    public ChannelPromise addListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public ChannelPromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         return (ChannelPromise) super.addListeners(listeners);
     }
 
     @Override
-    public ChannelPromise removeListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public ChannelPromise removeListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         return (ChannelPromise) super.removeListener(listener);
     }
 
     @Override
-    public ChannelPromise removeListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public ChannelPromise removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         return (ChannelPromise) super.removeListeners(listeners);
     }
 
diff --git a/transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java b/transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java
index a9a544c03cd0..3b8b90d73079 100644
--- a/transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java
+++ b/transport/src/main/java/io/netty/channel/DefaultAddressedEnvelope.java
@@ -16,8 +16,8 @@
 
 package io.netty.channel;
 
-import io.netty.buffer.BufUtil;
-import io.netty.buffer.ReferenceCounted;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.util.ReferenceCounted;
 import io.netty.util.internal.StringUtil;
 
 import java.net.SocketAddress;
@@ -82,24 +82,24 @@ public int refCnt() {
 
     @Override
     public AddressedEnvelope<M, A> retain() {
-        BufUtil.retain(message);
+        ByteBufUtil.retain(message);
         return this;
     }
 
     @Override
     public AddressedEnvelope<M, A> retain(int increment) {
-        BufUtil.retain(message, increment);
+        ByteBufUtil.retain(message, increment);
         return this;
     }
 
     @Override
     public boolean release() {
-        return BufUtil.release(message);
+        return ByteBufUtil.release(message);
     }
 
     @Override
     public boolean release(int decrement) {
-        return BufUtil.release(message, decrement);
+        return ByteBufUtil.release(message, decrement);
     }
 
     @Override
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
index febf689089f6..3138aeba67bf 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java
@@ -31,15 +31,18 @@
 public class DefaultChannelConfig implements ChannelConfig {
 
     private static final ByteBufAllocator DEFAULT_ALLOCATOR = PooledByteBufAllocator.DEFAULT;
+    private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = AdaptiveRecvByteBufAllocator.DEFAULT;
     private static final int DEFAULT_CONNECT_TIMEOUT = 30000;
 
     protected final Channel channel;
 
-    private volatile ChannelHandlerByteBufType handlerByteBufType = ChannelHandlerByteBufType.PREFER_DIRECT;
     private volatile ByteBufAllocator allocator = DEFAULT_ALLOCATOR;
+    private volatile RecvByteBufAllocator rcvBufAllocator = DEFAULT_RCVBUF_ALLOCATOR;
     private volatile int connectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT;
     private volatile int writeSpinCount = 16;
     private volatile boolean autoRead = true;
+    private volatile int writeBufferHighWaterMark = 64 * 1024;
+    private volatile int writeBufferLowWaterMark = 32 * 1024;
 
     public DefaultChannelConfig(Channel channel) {
         if (channel == null) {
@@ -50,8 +53,7 @@ public DefaultChannelConfig(Channel channel) {
 
     @Override
     public Map<ChannelOption<?>, Object> getOptions() {
-        return getOptions(null, CONNECT_TIMEOUT_MILLIS, WRITE_SPIN_COUNT, ALLOCATOR, AUTO_READ,
-                DEFAULT_HANDLER_BYTEBUF_TYPE);
+        return getOptions(null, CONNECT_TIMEOUT_MILLIS, WRITE_SPIN_COUNT, ALLOCATOR, AUTO_READ, RCVBUF_ALLOCATOR);
     }
 
     protected Map<ChannelOption<?>, Object> getOptions(
@@ -98,12 +100,12 @@ public <T> T getOption(ChannelOption<T> option) {
         if (option == ALLOCATOR) {
             return (T) getAllocator();
         }
+        if (option == RCVBUF_ALLOCATOR) {
+            return (T) getRecvByteBufAllocator();
+        }
         if (option == AUTO_READ) {
             return (T) Boolean.valueOf(isAutoRead());
         }
-        if (option == DEFAULT_ALLOCATOR) {
-            return (T) getDefaultHandlerByteBufType();
-        }
 
         return null;
     }
@@ -118,10 +120,10 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
             setWriteSpinCount((Integer) value);
         } else if (option == ALLOCATOR) {
             setAllocator((ByteBufAllocator) value);
+        } else if (option == RCVBUF_ALLOCATOR) {
+            setRecvByteBufAllocator((RecvByteBufAllocator) value);
         } else if (option == AUTO_READ) {
             setAutoRead((Boolean) value);
-        } else if (option == DEFAULT_HANDLER_BYTEBUF_TYPE) {
-            setDefaultHandlerByteBufType((ChannelHandlerByteBufType) value);
         } else {
             return false;
         }
@@ -180,6 +182,20 @@ public ChannelConfig setAllocator(ByteBufAllocator allocator) {
         return this;
     }
 
+    @Override
+    public RecvByteBufAllocator getRecvByteBufAllocator() {
+        return rcvBufAllocator;
+    }
+
+    @Override
+    public ChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        if (allocator == null) {
+            throw new NullPointerException("allocator");
+        }
+        rcvBufAllocator = allocator;
+        return this;
+    }
+
     @Override
     public boolean isAutoRead() {
         return autoRead;
@@ -196,13 +212,44 @@ public ChannelConfig setAutoRead(boolean autoRead) {
     }
 
     @Override
-    public ChannelHandlerByteBufType getDefaultHandlerByteBufType() {
-        return handlerByteBufType;
+    public int getWriteBufferHighWaterMark() {
+        return writeBufferHighWaterMark;
     }
 
     @Override
-    public ChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType handlerByteBufType) {
-        this.handlerByteBufType = handlerByteBufType;
+    public ChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        if (writeBufferHighWaterMark < getWriteBufferLowWaterMark()) {
+            throw new IllegalArgumentException(
+                    "writeBufferHighWaterMark cannot be less than " +
+                            "writeBufferLowWaterMark (" + getWriteBufferLowWaterMark() + "): " +
+                            writeBufferHighWaterMark);
+        }
+        if (writeBufferHighWaterMark < 0) {
+            throw new IllegalArgumentException(
+                    "writeBufferHighWaterMark must be >= 0");
+        }
+        this.writeBufferHighWaterMark = writeBufferHighWaterMark;
+        return this;
+    }
+
+    @Override
+    public int getWriteBufferLowWaterMark() {
+        return writeBufferLowWaterMark;
+    }
+
+    @Override
+    public ChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        if (writeBufferLowWaterMark > getWriteBufferHighWaterMark()) {
+            throw new IllegalArgumentException(
+                    "writeBufferLowWaterMark cannot be greater than " +
+                            "writeBufferHighWaterMark (" + getWriteBufferHighWaterMark() + "): " +
+                            writeBufferLowWaterMark);
+        }
+        if (writeBufferLowWaterMark < 0) {
+            throw new IllegalArgumentException(
+                    "writeBufferLowWaterMark must be >= 0");
+        }
+        this.writeBufferLowWaterMark = writeBufferLowWaterMark;
         return this;
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
index 9d2717279159..b16b5bdcc869 100755
--- a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
@@ -15,34 +15,17 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.Buf;
-import io.netty.buffer.BufType;
-import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.util.DefaultAttributeMap;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.EventExecutorGroup;
-import io.netty.util.concurrent.Future;
-import io.netty.util.internal.PlatformDependent;
 
 import java.net.SocketAddress;
-import java.nio.channels.ClosedChannelException;
-import java.util.Queue;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 import static io.netty.channel.DefaultChannelPipeline.*;
 
 final class DefaultChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext {
 
-    private static final int FLAG_REMOVED = 1;
-    private static final int FLAG_FREED = 2;
-    private static final int FLAG_FREED_INBOUND = 4;
-    private static final int FLAG_FREED_OUTBOUND = 8;
-
     volatile DefaultChannelHandlerContext next;
     volatile DefaultChannelHandlerContext prev;
 
@@ -50,54 +33,17 @@ final class DefaultChannelHandlerContext extends DefaultAttributeMap implements
     private final DefaultChannelPipeline pipeline;
     private final String name;
     private final ChannelHandler handler;
+    private boolean removed;
 
     // Will be set to null if no child executor should be used, otherwise it will be set to the
     // child executor.
     final EventExecutor executor;
     private ChannelFuture succeededFuture;
 
-    private final MessageBuf<Object> inMsgBuf;
-    private final ByteBuf inByteBuf;
-    private MessageBuf<Object> outMsgBuf;
-    private ByteBuf outByteBuf;
-    private short callDepth;
-    private short flags;
-
-    // When the two handlers run in a different thread and they are next to each other,
-    // each other's buffers can be accessed at the same time resulting in a race condition.
-    // To avoid such situation, we lazily creates an additional thread-safe buffer called
-    // 'bridge' so that the two handlers access each other's buffer only via the bridges.
-    // The content written into a bridge is flushed into the actual buffer by flushBridge().
-    //
-    // Note we use an AtomicReferenceFieldUpdater for atomic operations on these to save memory. This will save us
-    // 64 bytes per Bridge.
-    @SuppressWarnings("UnusedDeclaration")
-    private volatile Queue<Object> inBridge;
-    @SuppressWarnings("UnusedDeclaration")
-    private volatile Queue<Object> outBridge;
-    @SuppressWarnings("UnusedDeclaration")
-    private volatile NextBridgeFeeder nextInBridgeFeeder;
-    @SuppressWarnings("UnusedDeclaration")
-    private volatile NextBridgeFeeder nextOutBridgeFeeder;
-
-    @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, Queue> IN_BRIDGE_UPDATER =
-            AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class, Queue.class, "inBridge");
-    @SuppressWarnings("rawtypes")
-    private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, Queue> OUT_BRIDGE_UPDATER =
-            AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class, Queue.class, "outBridge");
-    private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, NextBridgeFeeder>
-            NEXT_IN_BRIDGE_FEEDER = AtomicReferenceFieldUpdater.newUpdater(
-                    DefaultChannelHandlerContext.class, NextBridgeFeeder.class, "nextInBridgeFeeder");
-    private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, NextBridgeFeeder>
-            NEXT_OUT_BRIDGE_FEEDER = AtomicReferenceFieldUpdater.newUpdater(
-                    DefaultChannelHandlerContext.class, NextBridgeFeeder.class, "nextOutBridgeFeeder");
-
     // Lazily instantiated tasks used to trigger events to a handler with different executor.
-    private Runnable invokeInboundBufferUpdatedTask;
-    private Runnable fireInboundBufferUpdated0Task;
     private Runnable invokeChannelReadSuspendedTask;
     private Runnable invokeRead0Task;
+    private Runnable invokeChannelWritableStateChangedTask;
 
     @SuppressWarnings("unchecked")
     DefaultChannelHandlerContext(
@@ -127,340 +73,6 @@ final class DefaultChannelHandlerContext extends DefaultAttributeMap implements
         } else {
             executor = null;
         }
-
-        if (handler instanceof ChannelInboundHandler) {
-            Buf buf;
-            try {
-                buf = ((ChannelInboundHandler) handler).newInboundBuffer(this);
-            } catch (Exception e) {
-                throw new ChannelPipelineException(
-                        handler.getClass().getSimpleName() + ".newInboundBuffer() raised an exception.", e);
-            }
-
-            if (buf instanceof ByteBuf) {
-                inByteBuf = (ByteBuf) buf;
-                inMsgBuf = null;
-            } else if (buf instanceof MessageBuf) {
-                inMsgBuf = (MessageBuf<Object>) buf;
-                inByteBuf = null;
-            } else {
-                throw new ChannelPipelineException(
-                        handler.getClass().getSimpleName() + ".newInboundBuffer() returned neither " +
-                        ByteBuf.class.getSimpleName() + " nor " + MessageBuf.class.getSimpleName() + ": " + buf);
-            }
-        } else {
-            inByteBuf = null;
-            inMsgBuf = null;
-        }
-
-        if (handler instanceof ChannelOutboundHandler) {
-            Buf buf;
-            try {
-                buf = ((ChannelOutboundHandler) handler).newOutboundBuffer(this);
-            } catch (Exception e) {
-                throw new ChannelPipelineException(
-                        handler.getClass().getSimpleName() + ".newOutboundBuffer() raised an exception.", e);
-            }
-
-            if (buf instanceof ByteBuf) {
-                outByteBuf = (ByteBuf) buf;
-            } else if (buf instanceof MessageBuf) {
-                @SuppressWarnings("unchecked")
-                MessageBuf<Object> msgBuf = (MessageBuf<Object>) buf;
-                outMsgBuf = msgBuf;
-            } else {
-                throw new ChannelPipelineException(
-                        handler.getClass().getSimpleName() + ".newOutboundBuffer() returned neither " +
-                        ByteBuf.class.getSimpleName() + " nor " + MessageBuf.class.getSimpleName() + ": " + buf);
-            }
-        }
-    }
-
-    DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, String name, HeadHandler handler) {
-        channel = pipeline.channel;
-        this.pipeline = pipeline;
-        this.name = name;
-        this.handler = handler;
-        executor = null;
-        inByteBuf = null;
-        inMsgBuf = null;
-    }
-
-    DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, String name, TailHandler handler) {
-        channel = pipeline.channel;
-        this.pipeline = pipeline;
-        this.name = name;
-        this.handler = handler;
-        executor = null;
-        inByteBuf = handler.byteSink;
-        inMsgBuf = handler.msgSink;
-        outByteBuf = null;
-        outMsgBuf = null;
-    }
-
-    void forwardBufferContentAndFree(
-            final DefaultChannelHandlerContext forwardPrev, final DefaultChannelHandlerContext forwardNext) {
-
-        boolean flush = false;
-        boolean inboundBufferUpdated = false;
-        try {
-            if (!isOutboundFreed()) {
-                if (hasOutboundByteBuffer() && outboundByteBuffer().isReadable()) {
-                    ByteBuf forwardPrevBuf;
-                    if (forwardPrev.hasOutboundByteBuffer()) {
-                        forwardPrevBuf = forwardPrev.outboundByteBuffer();
-                    } else {
-                        forwardPrevBuf = forwardPrev.nextOutboundByteBuffer();
-                    }
-                    forwardPrevBuf.writeBytes(outboundByteBuffer());
-                    flush = true;
-                }
-                if (hasOutboundMessageBuffer() && !outboundMessageBuffer().isEmpty()) {
-                    MessageBuf<Object> forwardPrevBuf;
-                    if (forwardPrev.hasOutboundMessageBuffer()) {
-                        forwardPrevBuf = forwardPrev.outboundMessageBuffer();
-                    } else {
-                        forwardPrevBuf = forwardPrev.nextOutboundMessageBuffer();
-                    }
-                    if (outboundMessageBuffer().drainTo(forwardPrevBuf) > 0) {
-                        flush = true;
-                    }
-                }
-            }
-
-            if (!isInboundFreed()) {
-                if (hasInboundByteBuffer() && inboundByteBuffer().isReadable()) {
-                    ByteBuf forwardNextBuf;
-                    if (forwardNext.hasInboundByteBuffer()) {
-                        forwardNextBuf = forwardNext.inboundByteBuffer();
-                    } else {
-                        forwardNextBuf = forwardNext.nextInboundByteBuffer();
-                    }
-                    forwardNextBuf.writeBytes(inboundByteBuffer());
-                    inboundBufferUpdated = true;
-                }
-                if (hasInboundMessageBuffer() && !inboundMessageBuffer().isEmpty()) {
-                    MessageBuf<Object> forwardNextBuf;
-                    if (forwardNext.hasInboundMessageBuffer()) {
-                        forwardNextBuf = forwardNext.inboundMessageBuffer();
-                    } else {
-                        forwardNextBuf = forwardNext.nextInboundMessageBuffer();
-                    }
-                    if (inboundMessageBuffer().drainTo(forwardNextBuf) > 0) {
-                        inboundBufferUpdated = true;
-                    }
-                }
-            }
-        } finally {
-            flags |= FLAG_REMOVED;
-            freeAllIfRemoved();
-        }
-
-        if (flush) {
-            EventExecutor executor = executor();
-            Thread currentThread = Thread.currentThread();
-            if (executor.inEventLoop(currentThread)) {
-                invokePrevFlush(newPromise(), currentThread, findContextOutboundInclusive(forwardPrev));
-            } else {
-                executor.execute(new Runnable() {
-                    @Override
-                    public void run() {
-                        invokePrevFlush(newPromise(), Thread.currentThread(),
-                                findContextOutboundInclusive(forwardPrev));
-                    }
-                });
-            }
-        }
-
-        if (inboundBufferUpdated) {
-            EventExecutor executor = executor();
-            if (executor.inEventLoop()) {
-                fireInboundBufferUpdated0(findContextInboundInclusive(forwardNext));
-            } else {
-                executor.execute(new Runnable() {
-                    @Override
-                    public void run() {
-                        fireInboundBufferUpdated0(findContextInboundInclusive(forwardNext));
-                    }
-                });
-            }
-        }
-    }
-
-    private static DefaultChannelHandlerContext findContextOutboundInclusive(DefaultChannelHandlerContext ctx) {
-        if (ctx.handler() instanceof ChannelOperationHandler) {
-            return ctx;
-        }
-        return ctx.findContextOutbound();
-    }
-
-    private static DefaultChannelHandlerContext findContextInboundInclusive(DefaultChannelHandlerContext ctx) {
-        if (ctx.handler() instanceof ChannelStateHandler) {
-            return ctx;
-        }
-        return ctx.findContextInbound();
-    }
-
-    void clearBuffer() {
-        if (hasOutboundByteBuffer()) {
-            outboundByteBuffer().clear();
-        }
-        if (hasOutboundMessageBuffer()) {
-            outboundMessageBuffer().clear();
-        }
-        if (hasInboundByteBuffer()) {
-            inboundByteBuffer().clear();
-        }
-        if (hasInboundMessageBuffer()) {
-            inboundMessageBuffer().clear();
-        }
-    }
-
-    void initHeadHandler() {
-        // Must be called for the head handler.
-        EventExecutor executor = executor();
-        if (executor.inEventLoop()) {
-            HeadHandler h = (HeadHandler) handler;
-            if (h.initialized) {
-                return;
-            }
-
-            h.init(this);
-            h.initialized = true;
-            outByteBuf = h.byteSink;
-            outMsgBuf = h.msgSink;
-        } else {
-            Future<?> f = executor.submit(new Runnable() {
-                @Override
-                public void run() {
-                    initHeadHandler();
-                }
-            });
-
-            boolean interrupted = false;
-            try {
-                while (!f.isDone()) {
-                    try {
-                        f.get();
-                    } catch (InterruptedException e) {
-                        interrupted = true;
-                    } catch (ExecutionException e) {
-                        PlatformDependent.throwException(e);
-                    }
-                }
-            } finally {
-                if (interrupted) {
-                    Thread.currentThread().interrupt();
-                }
-            }
-        }
-    }
-
-    private boolean flushInboundBridge() {
-        Queue<Object> inBridge = this.inBridge;
-        if (inBridge == null) {
-            return true;
-        }
-        return flushBridge(inBridge, inMsgBuf, inByteBuf);
-    }
-
-    private boolean flushOutboundBridge() {
-        Queue<Object> outBridge = this.outBridge;
-        if (outBridge == null) {
-            return true;
-        }
-        return flushBridge(outBridge, outMsgBuf, outByteBuf);
-    }
-
-    private static boolean flushBridge(Queue<Object> bridge, MessageBuf<Object> msgBuf, ByteBuf byteBuf) {
-        if (bridge == null) {
-            return true;
-        }
-
-        boolean nextBufferHadEnoughRoom = true;
-        for (;;) {
-            Object o = bridge.peek();
-            if (o == null) {
-                break;
-            }
-
-            try {
-                if (o instanceof Object[]) {
-                    Object[] data = (Object[]) o;
-                    int i;
-                    for (i = 0; i < data.length; i ++) {
-                        Object m = data[i];
-                        if (m == null) {
-                            break;
-                        }
-
-                        if (msgBuf.offer(m)) {
-                            data[i] = null;
-                        } else {
-                            System.arraycopy(data, i, data, 0, data.length - i);
-                            for (int j = i + 1; j < data.length; j ++) {
-                                data[j] = null;
-                            }
-                            nextBufferHadEnoughRoom = false;
-                            break;
-                        }
-                    }
-                } else if (o instanceof ByteBuf) {
-                    ByteBuf data = (ByteBuf) o;
-                    if (byteBuf.writerIndex() > byteBuf.maxCapacity() - data.readableBytes()) {
-                        // The target buffer is not going to be able to accept all data in the bridge.
-                        byteBuf.capacity(byteBuf.maxCapacity());
-                        byteBuf.writeBytes(data, byteBuf.writableBytes());
-                        nextBufferHadEnoughRoom = false;
-                        break;
-                    } else {
-                        try {
-                            byteBuf.writeBytes(data);
-                        } finally {
-                            data.release();
-                        }
-                    }
-                } else {
-                    throw new Error();
-                }
-            } finally {
-                if (nextBufferHadEnoughRoom) {
-                    Object removed = bridge.remove();
-                    assert removed == o;
-                }
-            }
-        }
-
-        return nextBufferHadEnoughRoom;
-    }
-
-    private boolean isInboundFreed() {
-        return (flags & FLAG_FREED_INBOUND) != 0;
-    }
-
-    private boolean isOutboundFreed() {
-        return (flags & FLAG_FREED_OUTBOUND) != 0;
-    }
-
-    private void freeAllIfRemoved() {
-        if (callDepth != 0) {
-            // Free only when the current context's handler is not being called.
-            return;
-        }
-
-        final int flags = this.flags;
-        if ((flags & FLAG_REMOVED) != 0 && (flags & FLAG_FREED) == 0) { // Removed, but not freed yet
-            try {
-                safeFree(inByteBuf);
-                safeFree(inMsgBuf);
-                safeFree(outByteBuf);
-                safeFree(outMsgBuf);
-            } finally {
-                this.flags = (short) (flags | FLAG_FREED | FLAG_FREED_INBOUND | FLAG_FREED_OUTBOUND);
-                freeNextInboundBridgeFeeder();
-                freeNextOutboundBridgeFeeder();
-            }
-        }
     }
 
     void freeInbound() {
@@ -478,14 +90,6 @@ public void run() {
     }
 
     private void freeInbound0() {
-        try {
-            safeFree(inByteBuf);
-            safeFree(inMsgBuf);
-        } finally {
-            flags |= FLAG_FREED_INBOUND;
-            freeNextInboundBridgeFeeder();
-        }
-
         if (next != null) {
             DefaultChannelHandlerContext nextCtx = findContextInbound();
             nextCtx.freeInbound();
@@ -494,90 +98,36 @@ private void freeInbound0() {
             // to head (inclusive) to trigger handlerRemoved(). If the removed handler has an outbound buffer, free it,
             // too.  Note that the tail handler is excluded because it's neither an outbound buffer and it doesn't
             // do anything in handlerRemoved().
-            pipeline.tail.prev.freeOutboundAndRemove();
+            pipeline.tail.prev.teardown();
         }
     }
 
+    void teardownAll() {
+        pipeline.tail.prev.teardown();
+    }
+
     /** Invocation initiated by {@link #freeInbound0()} after freeing all inbound buffers. */
-    private void freeOutboundAndRemove() {
+    private void teardown() {
         EventExecutor executor = executor();
         if (executor.inEventLoop()) {
-            freeOutboundAndRemove0();
+            teardown0();
         } else {
             executor.execute(new Runnable() {
                 @Override
                 public void run() {
-                    freeOutboundAndRemove0();
+                    teardown0();
                 }
             });
         }
     }
 
-    private void freeOutboundAndRemove0() {
-        if (handler instanceof ChannelOperationHandler) {
-            // Outbound handler - free the buffers / bridge feeders
-            try {
-                safeFree(outByteBuf);
-                safeFree(outMsgBuf);
-            } finally {
-                // We also OR FLAG_FREED because at this point we are sure both inbound and outbound were freed.
-                flags |= FLAG_FREED | FLAG_FREED_OUTBOUND;
-                freeNextOutboundBridgeFeeder();
-            }
-        }
-
+    private void teardown0() {
         DefaultChannelHandlerContext prev = this.prev;
         if (prev != null) {
             synchronized (pipeline) {
-                pipeline.remove0(this, false);
-            }
-            prev.freeOutboundAndRemove();
-        }
-    }
-
-    private void freeNextInboundBridgeFeeder() {
-        // Release the bridge feeder
-        NextBridgeFeeder feeder;
-        feeder = nextInBridgeFeeder;
-        if (feeder != null) {
-            feeder.release();
-            nextInBridgeFeeder = null;
-        }
-
-        // Warn if the bridge has unflushed elements.
-        if (logger.isWarnEnabled()) {
-            Queue<Object> bridge;
-            bridge = inBridge;
-            if (bridge != null && !bridge.isEmpty()) {
-                logger.warn("inbound bridge not empty - bug?: {}", bridge.size());
-            }
-        }
-    }
-
-    private void freeNextOutboundBridgeFeeder() {
-        // Release the bridge feeder
-        NextBridgeFeeder feeder = nextOutBridgeFeeder;
-        if (feeder != null) {
-            feeder.release();
-            nextOutBridgeFeeder = null;
-        }
-
-        // Warn if the bridge has unflushed elements.
-        if (logger.isWarnEnabled()) {
-            Queue<Object> bridge = outBridge;
-            if (bridge != null && !bridge.isEmpty()) {
-                logger.warn("outbound bridge not empty - bug?: {}", bridge.size());
-            }
-        }
-    }
-
-    private static void safeFree(Buf buf) {
-        if (buf != null) {
-            try {
-                buf.release();
-            } catch (Exception e) {
-                logger.warn("Failed to release a handler buffer.", e);
+                pipeline.remove0(this);
             }
+            prev.teardown();
         }
     }
 
@@ -615,164 +165,6 @@ public String name() {
         return name;
     }
 
-    @Override
-    public boolean hasInboundByteBuffer() {
-        return inByteBuf != null;
-    }
-
-    @Override
-    public boolean hasInboundMessageBuffer() {
-        return inMsgBuf != null;
-    }
-
-    @Override
-    public ByteBuf inboundByteBuffer() {
-        if (inByteBuf == null) {
-            throw new NoSuchBufferException(String.format(
-                    "the handler '%s' has no inbound byte buffer; it does not implement %s.",
-                    name, ChannelInboundByteHandler.class.getSimpleName()));
-        }
-        return inByteBuf;
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public <T> MessageBuf<T> inboundMessageBuffer() {
-        if (inMsgBuf == null) {
-            throw new NoSuchBufferException(String.format(
-                    "the handler '%s' has no inbound message buffer; it does not implement %s.",
-                    name, ChannelInboundMessageHandler.class.getSimpleName()));
-        }
-        return (MessageBuf<T>) inMsgBuf;
-    }
-
-    @Override
-    public boolean hasOutboundByteBuffer() {
-        return outByteBuf != null;
-    }
-
-    @Override
-    public boolean hasOutboundMessageBuffer() {
-        return outMsgBuf != null;
-    }
-
-    @Override
-    public ByteBuf outboundByteBuffer() {
-        if (outByteBuf == null) {
-            throw new NoSuchBufferException(String.format(
-                    "the handler '%s' has no outbound byte buffer; it does not implement %s.",
-                    name, ChannelOutboundByteHandler.class.getSimpleName()));
-        }
-        return outByteBuf;
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public <T> MessageBuf<T> outboundMessageBuffer() {
-        if (outMsgBuf == null) {
-            throw new NoSuchBufferException(String.format(
-                    "the handler '%s' has no outbound message buffer; it does not implement %s.",
-                    name, ChannelOutboundMessageHandler.class.getSimpleName()));
-        }
-        return (MessageBuf<T>) outMsgBuf;
-    }
-
-    @Override
-    public ByteBuf nextInboundByteBuffer() {
-        DefaultChannelHandlerContext ctx = next;
-        for (;;) {
-            if (ctx.hasInboundByteBuffer()) {
-                Thread currentThread = Thread.currentThread();
-                if (ctx.executor().inEventLoop(currentThread)) {
-                    return ctx.inByteBuf;
-                }
-                if (executor().inEventLoop(currentThread)) {
-                    return nextInBridgeFeeder().byteBuf;
-                }
-                throw new IllegalStateException("nextInboundByteBuffer() called from outside the eventLoop");
-            }
-            ctx = ctx.next;
-        }
-    }
-
-    @Override
-    public MessageBuf<Object> nextInboundMessageBuffer() {
-        DefaultChannelHandlerContext ctx = next;
-        for (;;) {
-            if (ctx.hasInboundMessageBuffer()) {
-                Thread currentThread = Thread.currentThread();
-                if (ctx.executor().inEventLoop(currentThread)) {
-                    return ctx.inMsgBuf;
-                }
-                if (executor().inEventLoop(currentThread)) {
-                    return nextInBridgeFeeder().msgBuf;
-                }
-                throw new IllegalStateException("nextInboundMessageBuffer() called from outside the eventLoop");
-            }
-            ctx = ctx.next;
-        }
-    }
-
-    private NextBridgeFeeder nextInBridgeFeeder() {
-        NextBridgeFeeder feeder = nextInBridgeFeeder;
-        if (feeder == null) {
-            feeder = new NextInboundBridgeFeeder();
-            if (!NEXT_IN_BRIDGE_FEEDER.compareAndSet(this, null, feeder)) {
-                feeder.release();
-                feeder = nextInBridgeFeeder;
-            }
-        }
-        return feeder;
-    }
-
-    @Override
-    public ByteBuf nextOutboundByteBuffer() {
-        DefaultChannelHandlerContext ctx = prev;
-        for (;;) {
-            if (ctx.hasOutboundByteBuffer()) {
-                Thread currentThread = Thread.currentThread();
-                if (ctx.executor().inEventLoop(currentThread)) {
-                    return ctx.outboundByteBuffer();
-                }
-                if (executor().inEventLoop(currentThread)) {
-                    return nextOutBridgeFeeder().byteBuf;
-                }
-                throw new IllegalStateException("nextOutboundByteBuffer() called from outside the eventLoop");
-            }
-            ctx = ctx.prev;
-        }
-    }
-
-    @Override
-    public MessageBuf<Object> nextOutboundMessageBuffer() {
-        DefaultChannelHandlerContext ctx = prev;
-        for (;;) {
-            if (ctx.hasOutboundMessageBuffer()) {
-                Thread currentThread = Thread.currentThread();
-                if (ctx.executor().inEventLoop(currentThread)) {
-                    return ctx.outboundMessageBuffer();
-                }
-                if (executor().inEventLoop(currentThread)) {
-                    return nextOutBridgeFeeder().msgBuf;
-                }
-                throw new IllegalStateException("nextOutboundMessageBuffer() called from outside the eventLoop");
-            }
-            ctx = ctx.prev;
-        }
-    }
-
-    private NextBridgeFeeder nextOutBridgeFeeder() {
-        NextBridgeFeeder feeder = nextOutBridgeFeeder;
-        if (feeder == null) {
-            feeder = new NextOutboundBridgeFeeder();
-            if (!NEXT_OUT_BRIDGE_FEEDER.compareAndSet(this, null, feeder)) {
-                feeder.release();
-                feeder = nextOutBridgeFeeder;
-            }
-        }
-        return feeder;
-    }
-
     @Override
     public ChannelHandlerContext fireChannelRegistered() {
         final DefaultChannelHandlerContext next = findContextInbound();
@@ -791,14 +183,10 @@ public void run() {
     }
 
     private void invokeChannelRegistered() {
-        callDepth ++;
         try {
-            ((ChannelStateHandler) handler()).channelRegistered(this);
+            ((ChannelInboundHandler) handler()).channelRegistered(this);
         } catch (Throwable t) {
             notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
         }
     }
 
@@ -820,13 +208,10 @@ public void run() {
     }
 
     private void invokeChannelUnregistered() {
-        callDepth ++;
         try {
-            ((ChannelStateHandler) handler()).channelUnregistered(this);
+            ((ChannelInboundHandler) handler()).channelUnregistered(this);
         } catch (Throwable t) {
             notifyHandlerException(t);
-        } finally {
-            callDepth --;
         }
     }
 
@@ -848,14 +233,10 @@ public void run() {
     }
 
     private void invokeChannelActive() {
-        callDepth ++;
         try {
-            ((ChannelStateHandler) handler()).channelActive(this);
+            ((ChannelInboundHandler) handler()).channelActive(this);
         } catch (Throwable t) {
             notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
         }
     }
 
@@ -877,14 +258,10 @@ public void run() {
     }
 
     private void invokeChannelInactive() {
-        callDepth ++;
         try {
-            ((ChannelStateHandler) handler()).channelInactive(this);
+            ((ChannelInboundHandler) handler()).channelInactive(this);
         } catch (Throwable t) {
             notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
         }
     }
 
@@ -921,7 +298,6 @@ public void run() {
 
     private void invokeExceptionCaught0(Throwable cause) {
         ChannelHandler handler = handler();
-        callDepth ++;
         try {
             handler.exceptionCaught(this, cause);
         } catch (Throwable t) {
@@ -930,9 +306,6 @@ private void invokeExceptionCaught0(Throwable cause) {
                         "An exception was thrown by a user handler's " +
                         "exceptionCaught() method while handling the following exception:", cause);
             }
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
         }
     }
 
@@ -958,121 +331,96 @@ public void run() {
     }
 
     private void invokeUserEventTriggered(Object event) {
-        ChannelStateHandler handler = (ChannelStateHandler) handler();
-
-        callDepth ++;
+        ChannelInboundHandler handler = (ChannelInboundHandler) handler();
         try {
             handler.userEventTriggered(this, event);
         } catch (Throwable t) {
             notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
         }
     }
 
     @Override
-    public ChannelHandlerContext fireInboundBufferUpdated() {
-        EventExecutor executor = executor();
+    public ChannelHandlerContext fireMessageReceived(Object msg) {
+        if (msg == null) {
+            throw new NullPointerException("msg");
+        }
+        return fireMessageReceived(MessageList.newInstance(msg));
+    }
+
+    @Override
+    public ChannelHandlerContext fireMessageReceived(final MessageList<?> msgs) {
+        if (msgs == null) {
+            throw new NullPointerException("msgs");
+        }
+
+        if (msgs.isEmpty()) {
+            msgs.recycle();
+            return this;
+        }
+
+        final DefaultChannelHandlerContext next = findContextInbound();
+        EventExecutor executor = next.executor();
         if (executor.inEventLoop()) {
-            fireInboundBufferUpdated0(findContextInbound());
+            next.invokeMessageReceived(msgs);
         } else {
-            Runnable task = fireInboundBufferUpdated0Task;
-            if (task == null) {
-                fireInboundBufferUpdated0Task = task = new Runnable() {
-                    @Override
-                    public void run() {
-                        fireInboundBufferUpdated0(findContextInbound());
-                    }
-                };
-            }
-            executor.execute(task);
+            executor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    next.invokeMessageReceived(msgs);
+                }
+            });
         }
         return this;
     }
 
-    private void fireInboundBufferUpdated0(final DefaultChannelHandlerContext next) {
-        feedNextInBridge();
-        // This comparison is safe because this method is always executed from the executor.
-        if (next.executor == executor) {
-            next.invokeInboundBufferUpdated();
+    private void invokeMessageReceived(MessageList<?> msgs) {
+        ChannelInboundHandler handler = (ChannelInboundHandler) handler();
+        try {
+            handler.messageReceived(this, msgs.cast());
+        } catch (Throwable t) {
+            notifyHandlerException(t);
+        }
+    }
+
+    @Override
+    public ChannelHandlerContext fireChannelReadSuspended() {
+        final DefaultChannelHandlerContext next = findContextInbound();
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeChannelReadSuspended();
         } else {
-            Runnable task = next.invokeInboundBufferUpdatedTask;
+            Runnable task = next.invokeChannelReadSuspendedTask;
             if (task == null) {
-                next.invokeInboundBufferUpdatedTask = task = new Runnable() {
+                next.invokeChannelReadSuspendedTask = task = new Runnable() {
                     @Override
                     public void run() {
-                        next.invokeInboundBufferUpdated();
+                        next.invokeChannelReadSuspended();
                     }
                 };
             }
-            next.executor().execute(task);
-        }
-    }
-
-    private void feedNextInBridge() {
-        NextBridgeFeeder feeder = nextInBridgeFeeder;
-        if (feeder != null) {
-            feeder.feed();
+            executor.execute(task);
         }
+        return this;
     }
 
-    private void invokeInboundBufferUpdated() {
-        if (isInboundFreed()) {
-            return;
-        }
-
-        ChannelStateHandler handler = (ChannelStateHandler) handler();
-        if (handler instanceof ChannelInboundHandler) {
-            for (;;) {
-                callDepth ++;
-                try {
-                    boolean flushedAll = flushInboundBridge();
-                    handler.inboundBufferUpdated(this);
-                    if (flushedAll) {
-                        break;
-                    }
-                } catch (Throwable t) {
-                    notifyHandlerException(t);
-                    break;
-                } finally {
-                    callDepth --;
-                    if (handler instanceof ChannelInboundByteHandler && !isInboundFreed()) {
-                        try {
-                            ((ChannelInboundByteHandler) handler).discardInboundReadBytes(this);
-                        } catch (Throwable t) {
-                            notifyHandlerException(t);
-                        }
-                    }
-                    freeAllIfRemoved();
-                }
-
-                if (isInboundFreed()) {
-                    break;
-                }
-            }
-        } else {
-            callDepth ++;
-            try {
-                handler.inboundBufferUpdated(this);
-            } catch (Throwable t) {
-                notifyHandlerException(t);
-            } finally {
-                callDepth --;
-            }
+    private void invokeChannelReadSuspended() {
+        try {
+            ((ChannelInboundHandler) handler()).channelReadSuspended(this);
+        } catch (Throwable t) {
+            notifyHandlerException(t);
         }
     }
 
     @Override
-    public ChannelHandlerContext fireChannelReadSuspended() {
+    public ChannelHandlerContext fireChannelWritabilityChanged() {
         final DefaultChannelHandlerContext next = findContextInbound();
         EventExecutor executor = next.executor();
         if (executor.inEventLoop()) {
-            next.invokeChannelReadSuspended();
+            next.invokeChannelWritabilityChanged();
         } else {
-            Runnable task = next.invokeChannelReadSuspendedTask;
+            Runnable task = next.invokeChannelWritableStateChangedTask;
             if (task == null) {
-                next.invokeChannelReadSuspendedTask = task = new Runnable() {
+                next.invokeChannelWritableStateChangedTask = task = new Runnable() {
                     @Override
                     public void run() {
                         next.invokeChannelReadSuspended();
@@ -1084,15 +432,11 @@ public void run() {
         return this;
     }
 
-    private void invokeChannelReadSuspended() {
-        callDepth ++;
+    private void invokeChannelWritabilityChanged() {
         try {
-            ((ChannelStateHandler) handler()).channelReadSuspended(this);
+            ((ChannelInboundHandler) handler()).channelWritabilityChanged(this);
         } catch (Throwable t) {
             notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
         }
     }
 
@@ -1127,13 +471,13 @@ public ChannelFuture deregister() {
     }
 
     @Override
-    public ChannelFuture flush() {
-        return flush(newPromise());
+    public ChannelFuture write(Object msg) {
+        return write(msg, newPromise());
     }
 
     @Override
-    public ChannelFuture write(Object message) {
-        return write(message, newPromise());
+    public ChannelFuture write(MessageList<?> msgs) {
+        return write(msgs, newPromise());
     }
 
     @Override
@@ -1161,14 +505,10 @@ public void run() {
     }
 
     private void invokeBind0(SocketAddress localAddress, ChannelPromise promise) {
-        callDepth ++;
         try {
-            ((ChannelOperationHandler) handler()).bind(this, localAddress, promise);
+            ((ChannelOutboundHandler) handler()).bind(this, localAddress, promise);
         } catch (Throwable t) {
-            notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
+            notifyOutboundHandlerException(t, promise);
         }
     }
 
@@ -1204,14 +544,10 @@ public void run() {
     }
 
     private void invokeConnect0(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
-        callDepth ++;
         try {
-            ((ChannelOperationHandler) handler()).connect(this, remoteAddress, localAddress, promise);
+            ((ChannelOutboundHandler) handler()).connect(this, remoteAddress, localAddress, promise);
         } catch (Throwable t) {
-            notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
+            notifyOutboundHandlerException(t, promise);
         }
     }
 
@@ -1245,14 +581,10 @@ public void run() {
     }
 
     private void invokeDisconnect0(ChannelPromise promise) {
-        callDepth ++;
         try {
-            ((ChannelOperationHandler) handler()).disconnect(this, promise);
+            ((ChannelOutboundHandler) handler()).disconnect(this, promise);
         } catch (Throwable t) {
-            notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
+            notifyOutboundHandlerException(t, promise);
         }
     }
 
@@ -1279,14 +611,10 @@ public void run() {
     }
 
     private void invokeClose0(ChannelPromise promise) {
-        callDepth ++;
         try {
-            ((ChannelOperationHandler) handler()).close(this, promise);
+            ((ChannelOutboundHandler) handler()).close(this, promise);
         } catch (Throwable t) {
-            notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
+            notifyOutboundHandlerException(t, promise);
         }
     }
 
@@ -1313,14 +641,10 @@ public void run() {
     }
 
     private void invokeDeregister0(ChannelPromise promise) {
-        callDepth ++;
         try {
-            ((ChannelOperationHandler) handler()).deregister(this, promise);
+            ((ChannelOutboundHandler) handler()).deregister(this, promise);
         } catch (Throwable t) {
-            notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
+            notifyOutboundHandlerException(t, promise);
         }
     }
 
@@ -1348,124 +672,37 @@ public void run() {
     }
 
     private void invokeRead0() {
-        callDepth ++;
         try {
-            ((ChannelOperationHandler) handler()).read(this);
+            ((ChannelOutboundHandler) handler()).read(this);
         } catch (Throwable t) {
             notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
         }
     }
 
     @Override
-    public ChannelFuture flush(final ChannelPromise promise) {
-        validateFuture(promise, true);
-
-        EventExecutor executor = executor();
-        Thread currentThread = Thread.currentThread();
-        if (executor.inEventLoop(currentThread)) {
-            invokePrevFlush(promise, currentThread, findContextOutbound());
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    invokePrevFlush(promise, Thread.currentThread(), findContextOutbound());
-                }
-            });
-        }
-
-        return promise;
-    }
-
-    private void invokePrevFlush(ChannelPromise promise, Thread currentThread, DefaultChannelHandlerContext prev) {
-        feedNextOutBridge();
-        prev.invokeFlush(promise, currentThread);
-    }
-
-    private void feedNextOutBridge() {
-        NextBridgeFeeder feeder = nextOutBridgeFeeder;
-        if (feeder != null) {
-            feeder.feed();
-        }
-    }
-
-    private ChannelFuture invokeFlush(final ChannelPromise promise, Thread currentThread) {
-        EventExecutor executor = executor();
-        if (executor.inEventLoop(currentThread)) {
-            invokeFlush0(promise);
-        } else {
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    invokeFlush0(promise);
-                }
-            });
-        }
-
-        return promise;
-    }
-
-    private void invokeFlush0(ChannelPromise promise) {
-        if (isOutboundFreed()) {
-            promise.setFailure(new ChannelPipelineException(
-                    "Unable to flush as outbound buffer of next handler was freed already"));
-            return;
-        }
-
-        Channel channel = channel();
-        if (!channel.isActive() && !channel.isRegistered()) {
-            promise.setFailure(new ClosedChannelException());
-            return;
-        }
-
-        ChannelOperationHandler handler = (ChannelOperationHandler) handler();
-        if (handler instanceof ChannelOutboundHandler) {
-            flushOutboundBridge();
-        }
-
-        callDepth ++;
-        try {
-            handler.flush(this, promise);
-        } catch (Throwable t) {
-            notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            if (handler instanceof ChannelOutboundByteHandler && !isOutboundFreed()) {
-                try {
-                    ((ChannelOutboundByteHandler) handler).discardOutboundReadBytes(this);
-                } catch (Throwable t) {
-                    notifyHandlerException(t);
-                }
-            }
-            freeAllIfRemoved();
+    public ChannelFuture write(Object msg, final ChannelPromise promise) {
+        if (msg == null) {
+            throw new NullPointerException("msg");
         }
+        return write(MessageList.newInstance(msg), promise);
     }
 
     @Override
-    public ChannelFuture sendFile(FileRegion region) {
-        return sendFile(region, newPromise());
+    public ChannelFuture write(MessageList<?> msgs, ChannelPromise promise) {
+        return findContextOutbound().invokeWrite(msgs, promise);
     }
 
-    @Override
-    public ChannelFuture sendFile(FileRegion region, ChannelPromise promise) {
-        if (region == null) {
-            throw new NullPointerException("region");
-        }
+    private ChannelFuture invokeWrite(final MessageList<?> msgs, final ChannelPromise promise) {
         validateFuture(promise, true);
-        return findContextOutbound().invokeSendFile(region, promise);
-    }
 
-    private ChannelFuture invokeSendFile(final FileRegion region, final ChannelPromise promise) {
         EventExecutor executor = executor();
         if (executor.inEventLoop()) {
-            invokeSendFile0(region, promise);
+            invokeWrite0(msgs, promise);
         } else {
             executor.execute(new Runnable() {
                 @Override
                 public void run() {
-                    invokeSendFile0(region, promise);
+                    invokeWrite0(msgs, promise);
                 }
             });
         }
@@ -1473,105 +710,27 @@ public void run() {
         return promise;
     }
 
-    private void invokeSendFile0(FileRegion region, ChannelPromise promise) {
-        ChannelOperationHandler handler = (ChannelOperationHandler) handler();
-        if (handler instanceof ChannelOutboundHandler) {
-            flushOutboundBridge();
-        }
-
-        callDepth ++;
+    private void invokeWrite0(MessageList<?> msgs, ChannelPromise promise) {
+        ChannelOutboundHandler handler = (ChannelOutboundHandler) handler();
         try {
-            handler.sendFile(this, region, promise);
+            handler.write(this, msgs.cast(), promise);
         } catch (Throwable t) {
-            notifyHandlerException(t);
-        } finally {
-            callDepth --;
-            freeAllIfRemoved();
+            notifyOutboundHandlerException(t, promise);
         }
     }
 
-    @Override
-    public ChannelFuture write(final Object message, final ChannelPromise promise) {
-        if (message instanceof FileRegion) {
-            return sendFile((FileRegion) message, promise);
-        }
-
-        if (message == null) {
-            throw new NullPointerException("message");
-        }
-        validateFuture(promise, true);
-
-        DefaultChannelHandlerContext ctx = prev;
-        EventExecutor executor;
-        final boolean msgBuf;
-
-        if (message instanceof ByteBuf) {
-            for (;;) {
-                if (ctx.hasOutboundByteBuffer()) {
-                    msgBuf = false;
-                    executor = ctx.executor();
-                    break;
-                }
-
-                if (ctx.hasOutboundMessageBuffer()) {
-                    msgBuf = true;
-                    executor = ctx.executor();
-                    break;
-                }
-
-                ctx = ctx.prev;
-            }
-        } else {
-            msgBuf = true;
-            for (;;) {
-                if (ctx.hasOutboundMessageBuffer()) {
-                    executor = ctx.executor();
-                    break;
-                }
-
-                ctx = ctx.prev;
-            }
-        }
-
-        if (executor.inEventLoop()) {
-            ctx.write0(message, promise, msgBuf);
-            return promise;
-        }
-
-        final DefaultChannelHandlerContext ctx0 = ctx;
-        executor.execute(new Runnable() {
-            @Override
-            public void run() {
-                ctx0.write0(message, promise, msgBuf);
-            }
-        });
-
-        return promise;
-    }
-
-    private void write0(Object message, ChannelPromise promise, boolean msgBuf) {
-        Channel channel = channel();
-        if (!channel.isRegistered() && !channel.isActive()) {
-            promise.setFailure(new ClosedChannelException());
+    private static void notifyOutboundHandlerException(Throwable cause, ChannelPromise promise) {
+        // only try to fail the promise if its not a VoidChannelPromise, as
+        // the VoidChannelPromise would also fire the cause through the pipeline
+        if (promise instanceof VoidChannelPromise) {
             return;
         }
 
-        if (isOutboundFreed()) {
-            promise.setFailure(new ChannelPipelineException(
-                    "Unable to write as outbound buffer of next handler was freed already"));
-            return;
-        }
-        if (msgBuf) {
-            outboundMessageBuffer().add(message);
-        } else {
-            ByteBuf buf = (ByteBuf) message;
-            try {
-                outboundByteBuffer().writeBytes(buf, buf.readerIndex(), buf.readableBytes());
-            } finally {
-                buf.release();
+        if (!promise.tryFailure(cause)) {
+            if (logger.isWarnEnabled()) {
+                logger.warn("Failed to fail the promise because it's done already: {}", promise, cause);
             }
         }
-        invokeFlush0(promise);
     }
 
     private void notifyHandlerException(Throwable cause) {
@@ -1651,172 +810,32 @@ private void validateFuture(ChannelFuture future, boolean allowUnsafe) {
     }
 
     private DefaultChannelHandlerContext findContextInbound() {
-        DefaultChannelHandlerContext ctx = this;
-        do {
-            ctx = ctx.next;
-        } while (!(ctx.handler() instanceof ChannelStateHandler));
-        return ctx;
-    }
-
-    @Override
-    public BufType nextInboundBufferType() {
         DefaultChannelHandlerContext ctx = this;
         do {
             ctx = ctx.next;
         } while (!(ctx.handler() instanceof ChannelInboundHandler));
-
-        if (ctx.handler() instanceof ChannelInboundByteHandler) {
-            return BufType.BYTE;
-        }  else {
-            return BufType.MESSAGE;
-        }
-    }
-
-    @Override
-    public BufType nextOutboundBufferType() {
-        DefaultChannelHandlerContext ctx = this;
-        do {
-            ctx = ctx.prev;
-        } while (!(ctx.handler() instanceof ChannelOutboundHandler));
-
-        if (ctx.handler() instanceof ChannelOutboundByteHandler) {
-            return BufType.BYTE;
-        }  else {
-            return BufType.MESSAGE;
-        }
+        return ctx;
     }
 
     private DefaultChannelHandlerContext findContextOutbound() {
         DefaultChannelHandlerContext ctx = this;
         do {
             ctx = ctx.prev;
-        } while (!(ctx.handler() instanceof ChannelOperationHandler));
+        } while (!(ctx.handler() instanceof ChannelOutboundHandler));
         return ctx;
     }
 
-    private abstract class NextBridgeFeeder {
-        final MessageBuf<Object> msgBuf;
-        final ByteBuf byteBuf;
-
-        protected NextBridgeFeeder() {
-            msgBuf = Unpooled.messageBuffer();
-            byteBuf = ChannelHandlerUtil.allocate(DefaultChannelHandlerContext.this);
-        }
-
-        final void feed() {
-            int dataLen = byteBuf.readableBytes();
-            if (dataLen != 0) {
-                ByteBuf data;
-                if (byteBuf.isDirect()) {
-                    data = alloc().directBuffer(dataLen, dataLen);
-                } else {
-                    data = alloc().heapBuffer(dataLen, dataLen);
-                }
-
-                byteBuf.readBytes(data).discardSomeReadBytes();
-                nextByteBridge().add(data);
-            }
-
-            if (!msgBuf.isEmpty()) {
-                Object[] data = msgBuf.toArray();
-                msgBuf.clear();
-                nextMessageBridge().add(data);
-            }
-        }
-
-        final void release() {
-            byteBuf.release();
-            msgBuf.release();
-        }
-
-        protected abstract Queue<Object> nextByteBridge();
-        protected abstract Queue<Object> nextMessageBridge();
-    }
-
-    private final class NextInboundBridgeFeeder extends NextBridgeFeeder {
-        @Override
-        protected Queue<Object> nextByteBridge() {
-            DefaultChannelHandlerContext ctx = next;
-            for (;;) {
-                if (ctx.hasInboundByteBuffer()) {
-                    break;
-                }
-                ctx = ctx.next;
-            }
-
-            return bridge(ctx);
-        }
-
-        @Override
-        protected Queue<Object> nextMessageBridge() {
-            DefaultChannelHandlerContext ctx = next;
-            for (;;) {
-                if (ctx.hasInboundMessageBuffer()) {
-                    break;
-                }
-                ctx = ctx.next;
-            }
-
-            return bridge(ctx);
-        }
-
-        private Queue<Object> bridge(DefaultChannelHandlerContext ctx) {
-            Queue<Object> bridge = ctx.inBridge;
-            if (bridge == null) {
-                Queue<Object> newBridge = new ConcurrentLinkedQueue<Object>();
-                if (IN_BRIDGE_UPDATER.compareAndSet(ctx, null, newBridge)) {
-                    bridge = newBridge;
-                } else {
-                    bridge = ctx.inBridge;
-                }
-            }
-            return bridge;
-        }
+    @Override
+    public ChannelPromise voidPromise() {
+        return channel.voidPromise();
     }
 
-    private final class NextOutboundBridgeFeeder extends NextBridgeFeeder {
-        @Override
-        protected Queue<Object> nextByteBridge() {
-            DefaultChannelHandlerContext ctx = prev;
-            for (;;) {
-                if (ctx.hasOutboundByteBuffer()) {
-                    break;
-                }
-                ctx = ctx.prev;
-            }
-
-            return bridge(ctx);
-        }
-
-        @Override
-        protected Queue<Object> nextMessageBridge() {
-            DefaultChannelHandlerContext ctx = prev;
-            for (;;) {
-                if (ctx.hasOutboundMessageBuffer()) {
-                    break;
-                }
-                ctx = ctx.prev;
-            }
-
-            return bridge(ctx);
-        }
-
-        private Queue<Object> bridge(DefaultChannelHandlerContext ctx) {
-            Queue<Object> bridge = ctx.outBridge;
-            if (bridge == null) {
-                Queue<Object> newBridge = new ConcurrentLinkedQueue<Object>();
-                if (OUT_BRIDGE_UPDATER.compareAndSet(ctx, null, newBridge)) {
-                    bridge = newBridge;
-                } else {
-                    bridge = ctx.outBridge;
-                }
-            }
-            return bridge;
-        }
+    void setRemoved() {
+        removed = true;
     }
 
     @Override
-    public ChannelPromise voidPromise() {
-        return channel.voidPromise();
+    public boolean isRemoved() {
+        return removed;
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
index 60d9bc8dda6a..4a099291a4f3 100755
--- a/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
@@ -15,11 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.Buf;
-import io.netty.buffer.BufUtil;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.Channel.Unsafe;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.EventExecutorGroup;
@@ -77,21 +73,10 @@ public DefaultChannelPipeline(Channel channel) {
         this.channel = channel;
 
         TailHandler tailHandler = new TailHandler();
-        tail = new DefaultChannelHandlerContext(this, generateName(tailHandler), tailHandler);
-
-        HeadHandler headHandler;
-        switch (channel.metadata().bufferType()) {
-        case BYTE:
-            headHandler = new ByteHeadHandler(channel.unsafe());
-            break;
-        case MESSAGE:
-            headHandler = new MessageHeadHandler(channel.unsafe());
-            break;
-        default:
-            throw new Error("unknown buffer type: " + channel.metadata().bufferType());
-        }
+        tail = new DefaultChannelHandlerContext(this, null, generateName(tailHandler), tailHandler);
 
-        head = new DefaultChannelHandlerContext(this, generateName(headHandler), headHandler);
+        HeadHandler headHandler = new HeadHandler(channel.unsafe());
+        head = new DefaultChannelHandlerContext(this, null, generateName(headHandler), headHandler);
 
         head.next = tail;
         tail.prev = head;
@@ -331,14 +316,14 @@ private DefaultChannelHandlerContext remove(final DefaultChannelHandlerContext c
 
         synchronized (this) {
             if (!ctx.channel().isRegistered() || ctx.executor().inEventLoop()) {
-                remove0(ctx, true);
+                remove0(ctx);
                 return ctx;
             } else {
                future = ctx.executor().submit(new Runnable() {
                    @Override
                    public void run() {
                        synchronized (DefaultChannelPipeline.this) {
-                           remove0(ctx, true);
+                           remove0(ctx);
                        }
                    }
                });
@@ -354,14 +339,13 @@ public void run() {
         return context;
     }
 
-    void remove0(DefaultChannelHandlerContext ctx, boolean forward) {
+    void remove0(DefaultChannelHandlerContext ctx) {
         DefaultChannelHandlerContext prev = ctx.prev;
         DefaultChannelHandlerContext next = ctx.next;
         prev.next = next;
         next.prev = prev;
         name2ctx.remove(ctx.name());
-
-        callHandlerRemoved(ctx, prev, next, forward);
+        callHandlerRemoved(ctx);
     }
 
     @Override
@@ -458,11 +442,15 @@ private void replace0(DefaultChannelHandlerContext oldCtx, String newName,
         }
         name2ctx.put(newName, newCtx);
 
+        // update the reference to the replacement so forward of buffered content will work correctly
+        oldCtx.prev = newCtx;
+        oldCtx.next = newCtx;
+
         // Invoke newHandler.handlerAdded() first (i.e. before oldHandler.handlerRemoved() is invoked)
         // because callHandlerRemoved() will trigger inboundBufferUpdated() or flush() on newHandler and those
         // event handlers must be called after handlerAdded().
         callHandlerAdded(newCtx);
-        callHandlerRemoved(oldCtx, newCtx, newCtx, true);
+        callHandlerRemoved(oldCtx);
     }
 
     private static void checkMultiplicity(ChannelHandlerContext ctx) {
@@ -517,40 +505,24 @@ private void callHandlerAdded0(final ChannelHandlerContext ctx) {
         }
     }
 
-    private void callHandlerRemoved(
-            final DefaultChannelHandlerContext ctx, final DefaultChannelHandlerContext ctxPrev,
-            final DefaultChannelHandlerContext ctxNext, final boolean forward) {
+    private void callHandlerRemoved(final DefaultChannelHandlerContext ctx) {
         if (ctx.channel().isRegistered() && !ctx.executor().inEventLoop()) {
             ctx.executor().execute(new Runnable() {
                 @Override
                 public void run() {
-                    callHandlerRemoved0(ctx, ctxPrev, ctxNext, forward);
+                    callHandlerRemoved0(ctx);
                 }
             });
             return;
         }
-        callHandlerRemoved0(ctx, ctxPrev, ctxNext, forward);
+        callHandlerRemoved0(ctx);
     }
 
-    private void callHandlerRemoved0(
-            final DefaultChannelHandlerContext ctx, DefaultChannelHandlerContext ctxPrev,
-            DefaultChannelHandlerContext ctxNext, boolean forward) {
-
-        final ChannelHandler handler = ctx.handler();
-
-        // Finish removal by forwarding buffer content and freeing the buffers.
-        if (forward) {
-            try {
-                ctx.forwardBufferContentAndFree(ctxPrev, ctxNext);
-            } catch (Throwable t) {
-                fireExceptionCaught(new ChannelPipelineException(
-                        "failed to forward buffer content of " + ctx.handler().getClass().getName(), t));
-            }
-        }
-
+    private void callHandlerRemoved0(final DefaultChannelHandlerContext ctx) {
         // Notify the complete removal.
         try {
-            handler.handlerRemoved(ctx);
+            ctx.handler().handlerRemoved(ctx);
+            ctx.setRemoved();
         } catch (Throwable t) {
             fireExceptionCaught(new ChannelPipelineException(
                     ctx.handler().getClass().getName() + ".handlerRemoved() has thrown an exception.", t));
@@ -586,8 +558,8 @@ private static void waitForFuture(Future<?> future) {
 
     @Override
     public ChannelHandler first() {
-        DefaultChannelHandlerContext first = head.next;
-        if (first == head) {
+        ChannelHandlerContext first = firstContext();
+        if (first == null) {
             return null;
         }
         return first.handler();
@@ -595,6 +567,10 @@ public ChannelHandler first() {
 
     @Override
     public ChannelHandlerContext firstContext() {
+        DefaultChannelHandlerContext first = head.next;
+        if (first == head) {
+            return null;
+        }
         return head.next;
     }
 
@@ -749,31 +725,8 @@ public String toString() {
         return buf.toString();
     }
 
-    @Override
-    @SuppressWarnings("unchecked")
-    public <T> MessageBuf<T> inboundMessageBuffer() {
-        return (MessageBuf<T>) head.nextInboundMessageBuffer();
-    }
-
-    @Override
-    public ByteBuf inboundByteBuffer() {
-        return head.nextInboundByteBuffer();
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public <T> MessageBuf<T> outboundMessageBuffer() {
-        return (MessageBuf<T>) tail.nextOutboundMessageBuffer();
-    }
-
-    @Override
-    public ByteBuf outboundByteBuffer() {
-        return tail.nextOutboundByteBuffer();
-    }
-
     @Override
     public ChannelPipeline fireChannelRegistered() {
-        head.initHeadHandler();
         head.fireChannelRegistered();
         return this;
     }
@@ -791,7 +744,6 @@ public ChannelPipeline fireChannelUnregistered() {
 
     @Override
     public ChannelPipeline fireChannelActive() {
-        head.initHeadHandler();
         head.fireChannelActive();
 
         if (channel.config().isAutoRead()) {
@@ -824,8 +776,14 @@ public ChannelPipeline fireUserEventTriggered(Object event) {
     }
 
     @Override
-    public ChannelPipeline fireInboundBufferUpdated() {
-        head.fireInboundBufferUpdated();
+    public ChannelPipeline fireMessageReceived(Object msg) {
+        head.fireMessageReceived(msg);
+        return this;
+    }
+
+    @Override
+    public ChannelPipeline fireMessageReceived(MessageList<?> msgs) {
+        head.fireMessageReceived(msgs);
         return this;
     }
 
@@ -838,6 +796,12 @@ public ChannelPipeline fireChannelReadSuspended() {
         return this;
     }
 
+    @Override
+    public ChannelPipeline fireChannelWritabilityChanged() {
+        head.fireChannelWritabilityChanged();
+        return this;
+    }
+
     @Override
     public ChannelFuture bind(SocketAddress localAddress) {
         return tail.bind(localAddress);
@@ -869,13 +833,13 @@ public ChannelFuture deregister() {
     }
 
     @Override
-    public ChannelFuture flush() {
-        return tail.flush();
+    public ChannelFuture write(Object msg) {
+        return tail.write(msg);
     }
 
     @Override
-    public ChannelFuture write(Object message) {
-        return tail.write(message);
+    public ChannelFuture write(MessageList<?> msgs) {
+        return tail.write(msgs);
     }
 
     @Override
@@ -914,23 +878,13 @@ public void read() {
     }
 
     @Override
-    public ChannelFuture flush(ChannelPromise promise) {
-        return tail.flush(promise);
-    }
-
-    @Override
-    public ChannelFuture sendFile(FileRegion region) {
-        return tail.sendFile(region);
-    }
-
-    @Override
-    public ChannelFuture sendFile(FileRegion region, ChannelPromise promise) {
-        return tail.sendFile(region, promise);
+    public ChannelFuture write(Object msg, ChannelPromise promise) {
+        return tail.write(msg, promise);
     }
 
     @Override
-    public ChannelFuture write(Object message, ChannelPromise promise) {
-        return tail.write(message, promise);
+    public ChannelFuture write(MessageList<?> msgs, ChannelPromise promise) {
+        return tail.write(msgs, promise);
     }
 
     private void checkDuplicateName(String name) {
@@ -969,9 +923,6 @@ private DefaultChannelHandlerContext getContextOrDie(Class<? extends ChannelHand
     // A special catch-all handler that handles both bytes and messages.
     static final class TailHandler implements ChannelInboundHandler {
 
-        final ByteBuf byteSink = Unpooled.buffer(0);
-        final MessageBuf<Object> msgSink = Unpooled.messageBuffer(0);
-
         @Override
         public void channelRegistered(ChannelHandlerContext ctx) throws Exception { }
 
@@ -987,6 +938,9 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception { }
         @Override
         public void channelReadSuspended(ChannelHandlerContext ctx) throws Exception { }
 
+        @Override
+        public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception { }
+
         @Override
         public void handlerAdded(ChannelHandlerContext ctx) throws Exception { }
 
@@ -1004,86 +958,56 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         }
 
         @Override
-        public Buf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            throw new Error();
-        }
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            int length = msgs.size();
+            if (length == 0) {
+                return;
+            }
 
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-            int byteSinkSize = byteSink.readableBytes();
-            if (byteSinkSize != 0) {
-                byteSink.clear();
-                logger.warn(
-                        "Discarded {} inbound byte(s) that reached at the tail of the pipeline. " +
-                        "Please check your pipeline configuration.", byteSinkSize);
+            for (int i = 0; i < length; i ++) {
+                Object m = msgs.get(i);
+                logger.debug(
+                        "Discarded inbound message {} that reached at the tail of the pipeline. " +
+                                "Please check your pipeline configuration.", m);
+
+                ByteBufUtil.release(m);
             }
 
-            int msgSinkSize = msgSink.size();
-            if (msgSinkSize != 0) {
-                MessageBuf<Object> in = msgSink;
-                for (;;) {
-                    Object m = in.poll();
-                    if (m == null) {
-                        break;
-                    }
-                    BufUtil.release(m);
-                    logger.debug(
-                            "Discarded inbound message {} that reached at the tail of the pipeline. " +
-                                    "Please check your pipeline configuration.", m);
-                }
+            if (length != 1) {
                 logger.warn(
                         "Discarded {} inbound message(s) that reached at the tail of the pipeline. " +
-                        "Please check your pipeline configuration.", msgSinkSize);
+                        "Please check your pipeline configuration.", length);
             }
         }
     }
 
-    abstract static class HeadHandler implements ChannelOutboundHandler {
+    static final class HeadHandler implements ChannelOutboundHandler {
 
         protected final Unsafe unsafe;
-        ByteBuf byteSink;
-        MessageBuf<Object> msgSink;
-        boolean initialized;
 
         protected HeadHandler(Unsafe unsafe) {
             this.unsafe = unsafe;
         }
 
-        void init(ChannelHandlerContext ctx) {
-            assert !initialized;
-            switch (ctx.channel().metadata().bufferType()) {
-            case BYTE:
-                byteSink = ctx.alloc().ioBuffer();
-                msgSink = Unpooled.messageBuffer(0);
-                break;
-            case MESSAGE:
-                byteSink = Unpooled.buffer(0);
-                msgSink = Unpooled.messageBuffer();
-                break;
-            default:
-                throw new Error();
-            }
-        }
-
         @Override
-        public final void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
             // NOOP
         }
 
         @Override
-        public final void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
             // NOOP
         }
 
         @Override
-        public final void bind(
+        public void bind(
                 ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)
                 throws Exception {
             unsafe.bind(localAddress, promise);
         }
 
         @Override
-        public final void connect(
+        public void connect(
                 ChannelHandlerContext ctx,
                 SocketAddress remoteAddress, SocketAddress localAddress,
                 ChannelPromise promise) throws Exception {
@@ -1091,34 +1015,29 @@ public final void connect(
         }
 
         @Override
-        public final void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+        public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
             unsafe.disconnect(promise);
         }
 
         @Override
-        public final void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+        public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
             unsafe.close(promise);
         }
 
         @Override
-        public final void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+        public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
             unsafe.deregister(promise);
         }
 
         @Override
-        public final void read(ChannelHandlerContext ctx) {
+        public void read(ChannelHandlerContext ctx) {
             unsafe.beginRead();
         }
 
         @Override
-        public final void sendFile(
-                ChannelHandlerContext ctx, FileRegion region, ChannelPromise promise) throws Exception {
-            unsafe.sendFile(region, promise);
-        }
-
-        @Override
-        public final Buf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            throw new Error();
+        public void write(
+                ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
+            unsafe.write(msgs, promise);
         }
 
         @Override
@@ -1126,62 +1045,4 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
             ctx.fireExceptionCaught(cause);
         }
     }
-
-    private static final class ByteHeadHandler extends HeadHandler {
-
-        private ByteHeadHandler(Unsafe unsafe) {
-            super(unsafe);
-        }
-
-        @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-            int discardedMessages = 0;
-            MessageBuf<Object> in = msgSink;
-            for (;;) {
-                Object m = in.poll();
-                if (m == null) {
-                    break;
-                }
-
-                if (m instanceof ByteBuf) {
-                    ByteBuf src = (ByteBuf) m;
-                    byteSink.writeBytes(src, src.readerIndex(), src.readableBytes());
-                } else {
-                    logger.debug(
-                            "Discarded outbound message {} that reached at the head of the pipeline. " +
-                                    "Please check your pipeline configuration.", m);
-                    discardedMessages ++;
-                }
-
-                BufUtil.release(m);
-            }
-
-            if (discardedMessages != 0) {
-                logger.warn(
-                        "Discarded {} outbound message(s) that reached at the head of the pipeline. " +
-                        "Please check your pipeline configuration.", discardedMessages);
-            }
-
-            unsafe.flush(promise);
-        }
-    }
-
-    private static final class MessageHeadHandler extends HeadHandler {
-
-        private MessageHeadHandler(Unsafe unsafe) {
-            super(unsafe);
-        }
-
-        @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-            int byteSinkSize = byteSink.readableBytes();
-            if (byteSinkSize != 0) {
-                byteSink.clear();
-                logger.warn(
-                        "Discarded {} outbound byte(s) that reached at the head of the pipeline. " +
-                                "Please check your pipeline configuration.", byteSinkSize);
-            }
-            unsafe.flush(promise);
-        }
-    }
 }
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java b/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java
index 00dcb4b5f295..4b101e0cc080 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java
@@ -97,25 +97,26 @@ public ChannelProgressivePromise setProgress(long progress, long total) {
     }
 
     @Override
-    public ChannelProgressivePromise addListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public ChannelProgressivePromise addListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         super.addListener(listener);
         return this;
     }
 
     @Override
-    public ChannelProgressivePromise addListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public ChannelProgressivePromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         super.addListeners(listeners);
         return this;
     }
 
     @Override
-    public ChannelProgressivePromise removeListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public ChannelProgressivePromise removeListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         super.removeListener(listener);
         return this;
     }
 
     @Override
-    public ChannelProgressivePromise removeListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public ChannelProgressivePromise removeListeners(
+            GenericFutureListener<? extends Future<? super Void>>... listeners) {
         super.removeListeners(listeners);
         return this;
     }
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java
index d6f4d2f1964c..3d763472812f 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java
@@ -89,25 +89,25 @@ public ChannelPromise setFailure(Throwable cause) {
     }
 
     @Override
-    public ChannelPromise addListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public ChannelPromise addListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         super.addListener(listener);
         return this;
     }
 
     @Override
-    public ChannelPromise addListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public ChannelPromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         super.addListeners(listeners);
         return this;
     }
 
     @Override
-    public ChannelPromise removeListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public ChannelPromise removeListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         super.removeListener(listener);
         return this;
     }
 
     @Override
-    public ChannelPromise removeListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public ChannelPromise removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         super.removeListeners(listeners);
         return this;
     }
diff --git a/transport/src/main/java/io/netty/channel/DefaultFileRegion.java b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java
index dbc84db4286c..b3d47f8703ab 100644
--- a/transport/src/main/java/io/netty/channel/DefaultFileRegion.java
+++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java
@@ -15,7 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.AbstractReferenceCounted;
+import io.netty.util.AbstractReferenceCounted;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -33,6 +33,7 @@ public class DefaultFileRegion extends AbstractReferenceCounted implements FileR
     private final FileChannel file;
     private final long position;
     private final long count;
+    private long transfered;
 
     /**
      * Create a new instance
@@ -66,6 +67,11 @@ public long count() {
         return count;
     }
 
+    @Override
+    public long transfered() {
+        return transfered;
+    }
+
     @Override
     public long transferTo(WritableByteChannel target, long position) throws IOException {
         long count = this.count - position;
@@ -78,7 +84,11 @@ public long transferTo(WritableByteChannel target, long position) throws IOExcep
             return 0L;
         }
 
-        return file.transferTo(this.position + position, count, target);
+        long written = file.transferTo(this.position + position, count, target);
+        if (written > 0) {
+            transfered += written;
+        }
+        return written;
     }
 
     @Override
diff --git a/transport/src/main/java/io/netty/channel/FileRegion.java b/transport/src/main/java/io/netty/channel/FileRegion.java
index 5201939cbe00..fe4fcdd4ba26 100644
--- a/transport/src/main/java/io/netty/channel/FileRegion.java
+++ b/transport/src/main/java/io/netty/channel/FileRegion.java
@@ -15,7 +15,7 @@
  */
 package io.netty.channel;
 
-import io.netty.buffer.ReferenceCounted;
+import io.netty.util.ReferenceCounted;
 
 import java.io.IOException;
 import java.nio.channels.FileChannel;
@@ -59,6 +59,11 @@ public interface FileRegion extends ReferenceCounted {
      */
     long position();
 
+    /**
+     * Return the bytes which was transfered already
+     */
+    long transfered();
+
     /**
      * Returns the number of bytes to transfer.
      */
diff --git a/transport/src/main/java/io/netty/channel/FixedRecvByteBufAllocator.java b/transport/src/main/java/io/netty/channel/FixedRecvByteBufAllocator.java
new file mode 100644
index 000000000000..b4087bae6603
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/FixedRecvByteBufAllocator.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+
+
+/**
+ * The {@link RecvByteBufAllocator} that always yields the same buffer
+ * size prediction.  This predictor ignores the feed back from the I/O thread.
+ */
+public class FixedRecvByteBufAllocator implements RecvByteBufAllocator {
+
+    private static final class HandleImpl implements Handle {
+
+        private final int bufferSize;
+
+        HandleImpl(int bufferSize) {
+            this.bufferSize = bufferSize;
+        }
+
+        @Override
+        public ByteBuf allocate(ByteBufAllocator alloc) {
+            return alloc.ioBuffer(bufferSize);
+        }
+
+        @Override
+        public int guess() {
+            return bufferSize;
+        }
+
+        @Override
+        public void record(int actualReadBytes) { }
+    }
+
+    private final Handle handle;
+
+    /**
+     * Creates a new predictor that always returns the same prediction of
+     * the specified buffer size.
+     */
+    public FixedRecvByteBufAllocator(int bufferSize) {
+        if (bufferSize <= 0) {
+            throw new IllegalArgumentException(
+                    "bufferSize must greater than 0: " + bufferSize);
+        }
+
+        handle = new HandleImpl(bufferSize);
+    }
+
+    @Override
+    public Handle newHandle() {
+        return handle;
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/MessageList.java b/transport/src/main/java/io/netty/channel/MessageList.java
new file mode 100644
index 000000000000..cba1c8c05452
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/MessageList.java
@@ -0,0 +1,460 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.util.Recycler;
+import io.netty.util.Recycler.Handle;
+import io.netty.util.Signal;
+import io.netty.util.internal.PlatformDependent;
+
+import java.util.Arrays;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+public final class MessageList<T> implements Iterable<T> {
+
+    private static final int DEFAULT_INITIAL_CAPACITY = 8;
+    private static final int MIN_INITIAL_CAPACITY = 4;
+
+    private static final Recycler<MessageList<?>> RECYCLER = new Recycler<MessageList<?>>() {
+        @Override
+        protected MessageList<?> newObject(Handle handle) {
+            return new MessageList<Object>(handle);
+        }
+    };
+
+    /**
+     * Create a new empty {@link MessageList} instance
+     */
+    public static <T> MessageList<T> newInstance() {
+        return newInstance(DEFAULT_INITIAL_CAPACITY);
+    }
+
+    /**
+     * Create a new empty {@link MessageList} instance with the given capacity.
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> MessageList<T> newInstance(int minCapacity) {
+        MessageList<T> ret = (MessageList<T>) RECYCLER.get();
+        ret.ensureCapacity(minCapacity);
+        ret.modifications = 0;
+        return ret;
+    }
+
+    /**
+     * Create a new {@link MessageList} instance which holds the given value
+     */
+    public static <T> MessageList<T> newInstance(T value) {
+        MessageList<T> ret = newInstance(MIN_INITIAL_CAPACITY);
+        ret.add(value);
+        return ret;
+    }
+
+    /**
+     * Call {@link ByteBufUtil#retain(Object)} on all messages in this {@link MessageList} and return itself.
+     */
+    public MessageList<T> retainAll() {
+        int size = this.size;
+        for (int i = 0; i < size; i ++) {
+            ByteBufUtil.retain(elements[i]);
+        }
+        return this;
+    }
+
+    /**
+     * Call {@link ByteBufUtil#retain(Object), int} on all messages in this {@link MessageList} and return itself.
+     */
+    public MessageList<T> retainAll(int increment) {
+        int size = this.size;
+        for (int i = 0; i < size; i ++) {
+            ByteBufUtil.retain(elements[i], increment);
+        }
+        return this;
+    }
+
+    /**
+     * Call {@link ByteBufUtil#release(Object)} on all messages in this {@link MessageList} and return {@code true}
+     * if all messages were released.
+     */
+    public boolean releaseAll() {
+        boolean releasedAll = true;
+        int size = this.size;
+        for (int i = 0; i < size; i++) {
+            releasedAll &= ByteBufUtil.release(elements[i]);
+        }
+        return releasedAll;
+    }
+
+    /**
+     * Call {@link ByteBufUtil#release(Object, int)} on all messages in this {@link MessageList} and return
+     * {@code true} if all messages were released.
+     */
+    public boolean releaseAll(int decrement) {
+        boolean releasedAll = true;
+        int size = this.size;
+        for (int i = 0; i < size; i++) {
+            releasedAll &= ByteBufUtil.release(elements[i], decrement);
+        }
+        return releasedAll;
+    }
+
+    /**
+     * Short-cut for calling {@link #releaseAll()} and {@link #recycle()}. Returns {@code true} if both return
+     * {@code true}.
+     */
+    public boolean releaseAllAndRecycle() {
+        return releaseAll() && recycle();
+    }
+
+    /**
+     * Short-cut for calling {@link #releaseAll(int)} and {@link #recycle()}. Returns {@code true} if both return
+     * {@code true}.
+     */
+    public boolean releaseAllAndRecycle(int decrement) {
+        return releaseAll(decrement) && recycle();
+    }
+
+    /**
+     * Clear and recycle this instance.
+     */
+    public boolean recycle() {
+        clear();
+        return RECYCLER.recycle(this, handle);
+    }
+
+    private final Handle handle;
+    private T[] elements;
+    private int size;
+    private int modifications;
+    private boolean byteBufsOnly = true;
+
+    MessageList(Handle handle) {
+        this(handle, DEFAULT_INITIAL_CAPACITY);
+    }
+
+    MessageList(Handle handle, int initialCapacity) {
+        this.handle = handle;
+        initialCapacity = normalizeCapacity(initialCapacity);
+        elements = newArray(initialCapacity);
+    }
+
+    private MessageList(Handle handle, T[] elements, int size) {
+        this.handle = handle;
+        this.elements = elements;
+        this.size = size;
+    }
+
+    /**
+     * Return the current size of this {@link MessageList} and so how many messages it holds.
+     */
+    public int size() {
+        return size;
+    }
+
+    /**
+     * Return {@code true} if this {@link MessageList} is empty and so contains no messages.
+     */
+    public boolean isEmpty() {
+        return size == 0;
+    }
+
+    /**
+     * Return the message on the given index. This method will throw an {@link IndexOutOfBoundsException} if there is
+     * no message stored in the given index.
+     */
+    public T get(int index) {
+        checkExclusive(index);
+        return elements[index];
+    }
+
+    /**
+     * Sets the message on the given index.
+     */
+    public MessageList<T> set(int index, T value) {
+        checkExclusive(index);
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+        elements[index] = value;
+        return this;
+    }
+
+    /**
+     * Add the message to this {@link MessageList} and return itself.
+     */
+    public MessageList<T> add(T value) {
+        if (value == null) {
+            throw new NullPointerException("value");
+        }
+        modifications++;
+        int oldSize = size;
+        int newSize = oldSize + 1;
+        ensureCapacity(newSize);
+        elements[oldSize] = value;
+        size = newSize;
+        if (byteBufsOnly && !(value instanceof ByteBuf)) {
+            byteBufsOnly = false;
+        }
+        return this;
+    }
+
+    /**
+     * Add the messages contained in the array to this {@link MessageList} and return itself.
+     */
+    public MessageList<T> add(T[] src) {
+        if (src == null) {
+            throw new NullPointerException("src");
+        }
+        return add(src, 0, src.length);
+    }
+
+    /**
+     * Add the messages contained in the array, using the given src index and src length, to this {@link MessageList}
+     * and return itself.
+     */
+    public MessageList<T> add(T[] src, int srcIdx, int srcLen) {
+        checkElements(src, srcIdx, srcLen);
+
+        modifications++;
+        int oldSize = size;
+        int newSize = oldSize + srcLen;
+        ensureCapacity(newSize);
+        System.arraycopy(src, srcIdx, elements, oldSize, srcLen);
+        size = newSize;
+        if (byteBufsOnly) {
+            for (int i = srcIdx; i < srcIdx; i++) {
+                if (!(src[i] instanceof ByteBuf)) {
+                    byteBufsOnly = false;
+                    break;
+                }
+            }
+        }
+
+        return this;
+    }
+
+    /**
+     * Add the messages contained in the given {@link MessageList} to this {@link MessageList} and return itself.
+     */
+    public MessageList<T> add(MessageList<T> src) {
+        return add(src, 0, src.size());
+    }
+
+    /**
+     * Add the messages contained in the given {@link MessageList}, using the given src index and src length, to this
+     * {@link MessageList} and return itself.
+     */
+    public MessageList<T> add(MessageList<T>  src, int srcIdx, int srcLen) {
+        return add(src.elements, srcIdx, srcLen);
+    }
+
+    /**
+     * Clear all messages and return itself.
+     */
+    public MessageList<T> clear() {
+        modifications++;
+        Arrays.fill(elements, 0, size, null);
+        byteBufsOnly = true;
+        size = 0;
+        return this;
+    }
+
+    /**
+     * Create a new copy all messages of this {@link MessageList} and return it.
+     */
+    public MessageList<T> copy() {
+        return new MessageList<T>(handle, elements.clone(), size);
+    }
+
+    /**
+     * Create a new copy all messages of this {@link MessageList}, starting at the given index and using the given len,
+     * and return it.
+     */
+    public MessageList<T> copy(int index, int length) {
+        checkRange(index, length);
+        MessageList<T> copy = new MessageList<T>(handle, length);
+        System.arraycopy(elements, index, copy.elements, 0, length);
+        copy.size = length;
+        return copy;
+    }
+
+    @SuppressWarnings("unchecked")
+    public <U> MessageList<U> cast() {
+        return (MessageList<U>) this;
+    }
+
+    public boolean forEach(MessageListProcessor<? super T> proc) {
+        if (proc == null) {
+            throw new NullPointerException("proc");
+        }
+
+        @SuppressWarnings("unchecked")
+        MessageListProcessor<T> p = (MessageListProcessor<T>) proc;
+
+        int size = this.size;
+        try {
+            for (int i = 0; i < size; i ++) {
+                i += p.process(this, i, elements[i]);
+            }
+        } catch (Signal abort) {
+            abort.expect(MessageListProcessor.ABORT);
+            return false;
+        } catch (Exception e) {
+            PlatformDependent.throwException(e);
+        }
+
+        return true;
+    }
+
+    public boolean forEach(int index, int length, MessageListProcessor<? super T> proc) {
+        checkRange(index, length);
+        if (proc == null) {
+            throw new NullPointerException("proc");
+        }
+
+        @SuppressWarnings("unchecked")
+        MessageListProcessor<T> p = (MessageListProcessor<T>) proc;
+
+        int end = index + length;
+        try {
+            for (int i = index; i < end;) {
+                i += p.process(this, i, elements[i]);
+            }
+        } catch (Signal abort) {
+            abort.expect(MessageListProcessor.ABORT);
+            return false;
+        } catch (Exception e) {
+            PlatformDependent.throwException(e);
+        }
+
+        return true;
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return new MessageListIterator();
+    }
+
+    /**
+     * Returns {@code true} if all messages contained in this {@link MessageList} are assignment-compatible with the
+     * object represented by this {@link Class}.
+     */
+    public boolean containsOnly(Class<?> clazz) {
+        if (clazz == ByteBuf.class) {
+            return byteBufsOnly;
+        }
+        for (int i = 0; i < size; i++) {
+            if (!clazz.isInstance(elements[i])) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private void ensureCapacity(int capacity) {
+        if (elements.length >= capacity) {
+            return;
+        }
+
+        T[] newElements = newArray(normalizeCapacity(capacity));
+        System.arraycopy(elements, 0, newElements, 0, size);
+        elements = newElements;
+    }
+
+    private static int normalizeCapacity(int initialCapacity) {
+        if (initialCapacity <= MIN_INITIAL_CAPACITY) {
+            initialCapacity = MIN_INITIAL_CAPACITY;
+        } else {
+            initialCapacity |= initialCapacity >>>  1;
+            initialCapacity |= initialCapacity >>>  2;
+            initialCapacity |= initialCapacity >>>  4;
+            initialCapacity |= initialCapacity >>>  8;
+            initialCapacity |= initialCapacity >>> 16;
+            initialCapacity ++;
+
+            if (initialCapacity < 0) {
+                initialCapacity >>>= 1;
+            }
+        }
+        return initialCapacity;
+    }
+
+    @SuppressWarnings({ "unchecked", "SuspiciousArrayCast" })
+    private T[] newArray(int initialCapacity) {
+        return (T[]) new Object[initialCapacity];
+    }
+
+    private void checkExclusive(int index) {
+        if (index >= size) {
+            throw new IndexOutOfBoundsException(String.valueOf(index));
+        }
+    }
+
+    private void checkRange(int index, int length) {
+        if (index + length > size) {
+            throw new IndexOutOfBoundsException("index: " + index + ", length: " + length + ", size: " + size);
+        }
+    }
+
+    private void checkElements(T[] src, int srcIdx, int srcLen) {
+        if (src == null) {
+            throw new NullPointerException("src");
+        }
+        int end = srcIdx + srcLen;
+        for (int i = srcIdx; i < end; i ++) {
+            if (src[i] == null) {
+                throw new NullPointerException("src[" + i + ']');
+            }
+        }
+    }
+
+    private final class MessageListIterator implements Iterator<T> {
+        private int index;
+        private int expectedModifications = modifications;
+
+        private void checkConcurrentModifications() {
+            if (expectedModifications != modifications) {
+                throw new ConcurrentModificationException();
+            }
+            if (index > size) {
+                throw new ConcurrentModificationException();
+            }
+        }
+
+        @Override
+        public boolean hasNext() {
+            return index < size;
+        }
+
+        @Override
+        public T next() {
+            checkConcurrentModifications();
+            if (hasNext()) {
+                return elements[index++];
+            }
+            throw new NoSuchElementException();
+        }
+
+        @Override
+        public void remove() {
+           throw new UnsupportedOperationException("Read-Only");
+        }
+    }
+}
diff --git a/buffer/src/main/java/io/netty/buffer/BufType.java b/transport/src/main/java/io/netty/channel/MessageListProcessor.java
similarity index 51%
rename from buffer/src/main/java/io/netty/buffer/BufType.java
rename to transport/src/main/java/io/netty/channel/MessageListProcessor.java
index 8b9ffd06740e..37cd20d87a90 100644
--- a/buffer/src/main/java/io/netty/buffer/BufType.java
+++ b/transport/src/main/java/io/netty/channel/MessageListProcessor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012 The Netty Project
+ * Copyright 2013 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -13,19 +13,19 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.buffer;
 
-/**
- * The type of the Buf
- */
-public enum BufType {
-    /**
-     * Operates on bytes.
-     */
-    BYTE,
+package io.netty.channel;
+
+import io.netty.util.Signal;
+
+public interface MessageListProcessor<T> {
+
+    Signal ABORT = new Signal(MessageListProcessor.class.getName() + ".ABORT");
 
     /**
-     * Operates on messages, which can be of any kind.
+     * @return the number of elements processed. {@link MessageList#forEach(MessageListProcessor)} will determine
+     *         the index of the next element to be processed based on this value.  Usually, an implementation will
+     *         return {@code 1} to advance the index by {@code 1}.
      */
-    MESSAGE
+    int process(MessageList<T> messages, int index, T value) throws Exception;
 }
diff --git a/transport/src/main/java/io/netty/channel/RecvByteBufAllocator.java b/transport/src/main/java/io/netty/channel/RecvByteBufAllocator.java
new file mode 100644
index 000000000000..371207a9f0f9
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/RecvByteBufAllocator.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2012 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+
+/**
+ * Allocates a new receive buffer whose capacity is probably large enough to read all inbound data and small enough
+ * not to waste its space.
+ */
+public interface RecvByteBufAllocator {
+
+    /**
+     * Creates a new handle.  The handle provides the actual operations and keeps the internal information which is
+     * required for predicting an optimal buffer capacity.
+     */
+    Handle newHandle();
+
+    public interface Handle {
+        /**
+         * Creates a new receive buffer whose capacity is probably large enough to read all inbound data and small
+         * enough not to waste its space.
+         */
+        ByteBuf allocate(ByteBufAllocator alloc);
+
+        /**
+         * Similar to {@link #allocate(ByteBufAllocator)} except that it does not allocate anything but just tells the
+         * capacity.
+         */
+        int guess();
+
+        /**
+         * Records the the actual number of read bytes in the previous read operation so that the allocator allocates
+         * the buffer with potentially more correct capacity.
+         *
+         * @param actualReadBytes the actual number of read bytes in the previous read operation
+         */
+        void record(int actualReadBytes);
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java b/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
new file mode 100644
index 000000000000..6e788a6eb95e
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+import io.netty.util.internal.TypeParameterMatcher;
+
+/**
+ * {@link ChannelInboundHandlerAdapter} which allows to explicit only handle a specific type of messages.
+ *
+ * For example here is an implementation which only handle {@link String} messages.
+ *
+ * <pre>
+ *     public class StringHandler extends
+ *             {@link SimpleChannelInboundHandler}&lt;{@link String}&gt; {
+ *
+ *         {@code @Override}
+ *         public void messageReceived({@link ChannelHandlerContext} ctx, {@link String} message)
+ *                 throws {@link Exception} {
+ *             System.out.println(message);
+ *         }
+ *     }
+ * </pre>
+ *
+ */
+public abstract class SimpleChannelInboundHandler<I> extends ChannelInboundHandlerAdapter {
+
+    private final TypeParameterMatcher matcher;
+
+    protected SimpleChannelInboundHandler() {
+        matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, "I");
+    }
+
+    protected SimpleChannelInboundHandler(Class<? extends I> inboundMessageType) {
+        matcher = TypeParameterMatcher.get(inboundMessageType);
+    }
+
+    public boolean acceptInboundMessage(Object msg) throws Exception {
+        return matcher.match(msg);
+    }
+
+    @Override
+    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+        MessageList<Object> unaccepted = MessageList.newInstance();
+        int size = msgs.size();
+        try {
+            for (int i = 0; i < size; i++) {
+                Object msg = msgs.get(i);
+                if (!ctx.isRemoved() && acceptInboundMessage(msg)) {
+                    if (!unaccepted.isEmpty()) {
+                        ctx.fireMessageReceived(unaccepted);
+                        unaccepted = MessageList.newInstance();
+                    }
+
+                    @SuppressWarnings("unchecked")
+                    I imsg = (I) msg;
+                    messageReceived(ctx, imsg);
+                } else {
+                    unaccepted.add(msg);
+                }
+            }
+        } finally {
+            msgs.recycle();
+            ctx.fireMessageReceived(unaccepted);
+        }
+    }
+
+    /**
+     * Is called for each message of type {@link I}.
+     *
+     * @param ctx           the {@link ChannelHandlerContext} which this {@link SimpleChannelInboundHandler}
+     *                      belongs to
+     * @param msg           the message to handle
+     * @throws Exception    is thrown if an error accour
+     */
+    protected abstract void messageReceived(ChannelHandlerContext ctx, I msg) throws Exception;
+}
diff --git a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
index 63fccea25ed0..a3a3d11b345f 100644
--- a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
@@ -57,7 +57,7 @@ protected void run() {
             Channel ch = this.ch;
             if (isShuttingDown()) {
                 if (ch != null) {
-                    ch.unsafe().close(ch.voidPromise());
+                    ch.unsafe().close(ch.unsafe().voidPromise());
                 }
                 if (confirmShutdown()) {
                     break;
diff --git a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
index 120f53d2e630..b0a32f42bae5 100644
--- a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
@@ -17,7 +17,12 @@
 
 
 import io.netty.util.concurrent.AbstractEventExecutorGroup;
+import io.netty.util.concurrent.DefaultPromise;
 import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
+import io.netty.util.concurrent.GlobalEventExecutor;
+import io.netty.util.concurrent.Promise;
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.ReadOnlyIterator;
@@ -28,6 +33,7 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 
@@ -44,6 +50,18 @@ public class ThreadPerChannelEventLoopGroup extends AbstractEventExecutorGroup i
     final Queue<ThreadPerChannelEventLoop> idleChildren = new ConcurrentLinkedQueue<ThreadPerChannelEventLoop>();
     private final ChannelException tooManyChannels;
 
+    private volatile boolean shuttingDown;
+    private final Promise<?> terminationFuture = new DefaultPromise<Void>(GlobalEventExecutor.INSTANCE);
+    private final FutureListener<Object> childTerminationListener = new FutureListener<Object>() {
+        @Override
+        public void operationComplete(Future<Object> future) throws Exception {
+            // Inefficient, but works.
+            if (isTerminated()) {
+                terminationFuture.setSuccess(null);
+            }
+        }
+    };
+
     /**
      * Create a new {@link ThreadPerChannelEventLoopGroup} with no limit in place.
      */
@@ -117,24 +135,45 @@ public EventLoop next() {
     }
 
     @Override
-    public void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
+    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
+        shuttingDown = true;
+
         for (EventLoop l: activeChildren) {
             l.shutdownGracefully(quietPeriod, timeout, unit);
         }
         for (EventLoop l: idleChildren) {
             l.shutdownGracefully(quietPeriod, timeout, unit);
         }
+
+        // Notify the future if there was no children.
+        if (isTerminated()) {
+            terminationFuture.trySuccess(null);
+        }
+
+        return terminationFuture();
+    }
+
+    @Override
+    public Future<?> terminationFuture() {
+        return terminationFuture;
     }
 
     @Override
     @Deprecated
     public void shutdown() {
+        shuttingDown = true;
+
         for (EventLoop l: activeChildren) {
             l.shutdown();
         }
         for (EventLoop l: idleChildren) {
             l.shutdown();
         }
+
+        // Notify the future if there was no children.
+        if (isTerminated()) {
+            terminationFuture.trySuccess(null);
+        }
     }
 
     @Override
@@ -237,12 +276,17 @@ public ChannelFuture register(Channel channel, ChannelPromise promise) {
     }
 
     private EventLoop nextChild() throws Exception {
+        if (shuttingDown) {
+            throw new RejectedExecutionException("shutting down");
+        }
+
         ThreadPerChannelEventLoop loop = idleChildren.poll();
         if (loop == null) {
             if (maxChannels > 0 && activeChildren.size() >= maxChannels) {
                 throw tooManyChannels;
             }
             loop = newChild(childArgs);
+            loop.terminationFuture().addListener(childTerminationListener);
         }
         activeChildren.add(loop);
         return loop;
diff --git a/transport/src/main/java/io/netty/channel/VoidChannelPromise.java b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java
index b4cc69e48801..dd836ca91667 100644
--- a/transport/src/main/java/io/netty/channel/VoidChannelPromise.java
+++ b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java
@@ -19,44 +19,47 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.TimeUnit;
 
 final class VoidChannelPromise extends AbstractFuture<Void> implements ChannelPromise {
 
     private final Channel channel;
+    private final boolean fireException;
 
     /**
      * Creates a new instance.
      *
      * @param channel the {@link Channel} associated with this future
      */
-    public VoidChannelPromise(Channel channel) {
+    public VoidChannelPromise(Channel channel, boolean fireException) {
         if (channel == null) {
             throw new NullPointerException("channel");
         }
         this.channel = channel;
+        this.fireException = fireException;
     }
 
     @Override
-    public VoidChannelPromise addListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public VoidChannelPromise addListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         fail();
         return this;
     }
 
     @Override
-    public VoidChannelPromise addListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public VoidChannelPromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         fail();
         return this;
     }
 
     @Override
-    public VoidChannelPromise removeListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public VoidChannelPromise removeListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         // NOOP
         return this;
     }
 
     @Override
-    public VoidChannelPromise removeListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public VoidChannelPromise removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         // NOOP
         return this;
     }
@@ -114,6 +117,21 @@ public boolean isSuccess() {
         return false;
     }
 
+    @Override
+    public boolean setUncancellable() {
+        return true;
+    }
+
+    @Override
+    public boolean isCancellable() {
+        return false;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return false;
+    }
+
     @Override
     public Throwable cause() {
         return null;
@@ -132,7 +150,9 @@ public VoidChannelPromise syncUninterruptibly() {
     }
     @Override
     public VoidChannelPromise setFailure(Throwable cause) {
-        channel.pipeline().fireExceptionCaught(cause);
+        if (fireException) {
+            channel.pipeline().fireExceptionCaught(cause);
+        }
         return this;
     }
 
@@ -143,7 +163,17 @@ public VoidChannelPromise setSuccess() {
 
     @Override
     public boolean tryFailure(Throwable cause) {
-        channel.pipeline().fireExceptionCaught(cause);
+        if (fireException) {
+            channel.pipeline().fireExceptionCaught(cause);
+        }
+        return false;
+    }
+
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        if (fireException) {
+            channel.pipeline().fireExceptionCaught(new CancellationException());
+        }
         return false;
     }
 
diff --git a/transport/src/main/java/io/netty/channel/aio/AbstractAioChannel.java b/transport/src/main/java/io/netty/channel/aio/AbstractAioChannel.java
deleted file mode 100755
index 5802545aace6..000000000000
--- a/transport/src/main/java/io/netty/channel/aio/AbstractAioChannel.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.aio;
-
-import io.netty.channel.AbstractChannel;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelPromise;
-import io.netty.channel.ConnectTimeoutException;
-import io.netty.channel.EventLoop;
-
-import java.net.ConnectException;
-import java.net.SocketAddress;
-import java.nio.channels.AsynchronousChannel;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Abstract base class for {@link Channel} implementations that use the new {@link AsynchronousChannel} which is part
- * of NIO.2.
- */
-public abstract class AbstractAioChannel extends AbstractChannel {
-
-    protected volatile AsynchronousChannel ch;
-
-    /**
-     * The future of the current connection attempt.  If not null, subsequent
-     * connection attempts will fail.
-     */
-    protected ChannelPromise connectPromise;
-    protected ScheduledFuture<?> connectTimeoutFuture;
-    private SocketAddress requestedRemoteAddress;
-
-    /**
-     * Creates a new instance.
-     *
-     * @param id
-     *        the unique non-negative integer ID of this channel.
-     *        Specify {@code null} to auto-generate a unique negative integer
-     *        ID.
-     * @param parent
-     *        the parent of this channel. {@code null} if there's no parent.
-     * @param ch
-     *        the {@link AsynchronousChannel} which will handle the IO or {@code null} if not created yet.
-     */
-    protected AbstractAioChannel(Channel parent, Integer id, AsynchronousChannel ch) {
-        super(parent, id);
-        this.ch = ch;
-    }
-
-    /**
-     * Return the underlying {@link AsynchronousChannel}. Be aware this should only be called after it was set as
-     * otherwise it will throw an {@link IllegalStateException}.
-     */
-    protected AsynchronousChannel javaChannel() {
-        if (ch == null) {
-            throw new IllegalStateException("Try to access Channel before eventLoop was registered");
-        }
-        return ch;
-    }
-
-    @Override
-    public boolean isOpen() {
-        if (ch == null) {
-            return true;
-        }
-        return ch.isOpen();
-    }
-
-    @Override
-    protected boolean isCompatible(EventLoop loop) {
-        return loop instanceof AioEventLoop;
-    }
-
-    @Override
-    protected AbstractUnsafe newUnsafe() {
-        return new DefaultAioUnsafe();
-    }
-
-    protected final class DefaultAioUnsafe extends AbstractUnsafe {
-
-        @Override
-        public void connect(final SocketAddress remoteAddress,
-                final SocketAddress localAddress, final ChannelPromise promise) {
-            if (!ensureOpen(promise)) {
-                return;
-            }
-
-            try {
-                if (connectPromise != null) {
-                    throw new IllegalStateException("connection attempt already made");
-                }
-                connectPromise = promise;
-                requestedRemoteAddress = remoteAddress;
-
-                doConnect(remoteAddress, localAddress, promise);
-
-                // Schedule connect timeout.
-                int connectTimeoutMillis = config().getConnectTimeoutMillis();
-                if (connectTimeoutMillis > 0) {
-                    connectTimeoutFuture = eventLoop().schedule(new Runnable() {
-                        @Override
-                        public void run() {
-                            ChannelPromise connectFuture = connectPromise;
-                            ConnectTimeoutException cause =
-                                    new ConnectTimeoutException("connection timed out: " + remoteAddress);
-                            if (connectFuture != null && connectFuture.tryFailure(cause)) {
-                                close(voidPromise());
-                            }
-                        }
-                    }, connectTimeoutMillis, TimeUnit.MILLISECONDS);
-                }
-            } catch (Throwable t) {
-                if (t instanceof ConnectException) {
-                    Throwable newT = new ConnectException(t.getMessage() + ": " + remoteAddress);
-                    newT.setStackTrace(t.getStackTrace());
-                    t = newT;
-                }
-                promise.setFailure(t);
-                closeIfClosed();
-            }
-        }
-
-        public void connectFailed(Throwable t) {
-            if (t instanceof ConnectException) {
-                Throwable newT = new ConnectException(t.getMessage() + ": " + requestedRemoteAddress);
-                newT.setStackTrace(t.getStackTrace());
-                t = newT;
-            }
-            connectPromise.setFailure(t);
-            closeIfClosed();
-        }
-
-        public void connectSuccess() {
-            assert eventLoop().inEventLoop();
-            assert connectPromise != null;
-            try {
-                connectPromise.setSuccess();
-                pipeline().fireChannelActive();
-            } catch (Throwable t) {
-                connectPromise.setFailure(t);
-                closeIfClosed();
-            } finally {
-                connectTimeoutFuture.cancel(false);
-                connectPromise = null;
-            }
-        }
-    }
-
-    /**
-     * Connect to the remote peer using the given localAddress if one is specified or {@code null} otherwise.
-     */
-    protected abstract void doConnect(SocketAddress remoteAddress,
-            SocketAddress localAddress, ChannelPromise connectPromise);
-
-}
diff --git a/transport/src/main/java/io/netty/channel/aio/AioCompletionHandler.java b/transport/src/main/java/io/netty/channel/aio/AioCompletionHandler.java
deleted file mode 100644
index ceaa84eecc62..000000000000
--- a/transport/src/main/java/io/netty/channel/aio/AioCompletionHandler.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.aio;
-
-import io.netty.channel.Channel;
-import io.netty.channel.EventLoop;
-
-import java.nio.channels.CompletionHandler;
-
-/**
- * Special {@link CompletionHandler} which makes sure that the callback methods gets executed in the {@link EventLoop}
- */
-public abstract class AioCompletionHandler<V, A extends Channel> implements CompletionHandler<V, A> {
-
-    /**
-     * See {@link CompletionHandler#completed(Object, Object)}
-     */
-    protected abstract void completed0(V result, A channel);
-
-    /**
-     * Set {@link CompletionHandler#failed(Throwable, Object)}
-     */
-    protected abstract void failed0(Throwable exc, A channel);
-
-    // According to JDK AIO documentation, the ExecutorService a user specified must not call the Runnable given by
-    // JDK AIO implementation directly.  However, we violates that rull by calling Runnable.run() directly for
-    // optimization purposes, and it can result in infinite recursion in combination with the fact that the JDK AIO
-    // implementation often makes recursive invocations.  Therefore, we must make sure we don't go too deep in the
-    // stack.
-    private static final int MAX_STACK_DEPTH = 8;
-    private static final ThreadLocal<Integer> STACK_DEPTH = new ThreadLocal<Integer>() {
-        @Override
-        protected Integer initialValue() {
-            return 0;
-        }
-    };
-
-    @Override
-    public final void completed(final V result, final A channel) {
-        EventLoop loop = channel.eventLoop();
-        if (loop.inEventLoop()) {
-            Integer d = STACK_DEPTH.get();
-            if (d < MAX_STACK_DEPTH) {
-                STACK_DEPTH.set(d + 1);
-                try {
-                    completed0(result, channel);
-                } finally {
-                    STACK_DEPTH.set(d);
-                }
-            } else {
-                // schedule it with a special runnable to make sure we keep the right
-                // order and exist the recursive call to prevent stackoverflow
-                loop.execute(new AioEventLoop.RecursionBreakingRunnable() {
-                    @Override
-                    public void run() {
-                        completed0(result, channel);
-                    }
-                });
-            }
-        } else {
-            loop.execute(new Runnable() {
-                @Override
-                public void run() {
-                    completed0(result, channel);
-                }
-            });
-        }
-    }
-
-    @Override
-    public final void failed(final Throwable exc, final A channel) {
-        EventLoop loop = channel.eventLoop();
-        if (loop.inEventLoop()) {
-            Integer d = STACK_DEPTH.get();
-            if (d < MAX_STACK_DEPTH) {
-                STACK_DEPTH.set(d + 1);
-                try {
-                    failed0(exc, channel);
-                } finally {
-                    STACK_DEPTH.set(d);
-                }
-            } else {
-                // schedule it with a special runnable to make sure we keep the right
-                // order and exist the recursive call to prevent stackoverflow
-                loop.execute(new AioEventLoop.RecursionBreakingRunnable() {
-                    @Override
-                    public void run() {
-                        failed0(exc, channel);
-                    }
-                });
-            }
-        } else {
-            loop.execute(new Runnable() {
-                @Override
-                public void run() {
-                    failed0(exc, channel);
-                }
-            });
-        }
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/aio/AioEventLoop.java b/transport/src/main/java/io/netty/channel/aio/AioEventLoop.java
deleted file mode 100644
index 4f116c20c198..000000000000
--- a/transport/src/main/java/io/netty/channel/aio/AioEventLoop.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.aio;
-
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelPromise;
-import io.netty.channel.SingleThreadEventLoop;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.IdentityHashMap;
-import java.util.Queue;
-import java.util.Set;
-import java.util.concurrent.LinkedBlockingDeque;
-import java.util.concurrent.ThreadFactory;
-
-/**
- * {@link SingleThreadEventLoop} implementations which will handle AIO {@link Channel}s.
- */
-final class AioEventLoop extends SingleThreadEventLoop {
-
-    private final Set<Channel> channels = Collections.newSetFromMap(new IdentityHashMap<Channel, Boolean>());
-    private LinkedBlockingDeque<Runnable> taskQueue;
-
-    private final ChannelFutureListener registrationListener = new ChannelFutureListener() {
-        @Override
-        public void operationComplete(ChannelFuture future) throws Exception {
-            if (!future.isSuccess()) {
-                return;
-            }
-
-            Channel ch = future.channel();
-            channels.add(ch);
-            ch.closeFuture().addListener(deregistrationListener);
-        }
-    };
-
-    private final ChannelFutureListener deregistrationListener = new ChannelFutureListener() {
-        @Override
-        public void operationComplete(ChannelFuture future) throws Exception {
-            channels.remove(future.channel());
-        }
-    };
-
-    AioEventLoop(AioEventLoopGroup parent, ThreadFactory threadFactory) {
-        super(parent, threadFactory, true);
-    }
-
-    @Override
-    public ChannelFuture register(Channel channel) {
-        return super.register(channel).addListener(registrationListener);
-    }
-
-    @Override
-    public ChannelFuture register(Channel channel, ChannelPromise future) {
-        return super.register(channel, future).addListener(registrationListener);
-    }
-
-    @Override
-    protected void run() {
-        for (;;) {
-            Runnable task = takeTask();
-            if (task != null) {
-                task.run();
-                updateLastExecutionTime();
-            }
-
-            if (isShuttingDown()) {
-                closeAll();
-                if (confirmShutdown()) {
-                    break;
-                }
-            }
-        }
-    }
-
-    private void closeAll() {
-        Collection<Channel> channels = new ArrayList<Channel>(this.channels.size());
-        for (Channel ch: this.channels) {
-            channels.add(ch);
-        }
-
-        for (Channel ch: channels) {
-            ch.unsafe().close(ch.voidPromise());
-        }
-    }
-
-    @Override
-    protected Queue<Runnable> newTaskQueue() {
-        // use a Deque as we need to be able to also add tasks on the first position.
-        taskQueue = new LinkedBlockingDeque<Runnable>();
-        return taskQueue;
-    }
-
-    @Override
-    protected void addTask(Runnable task) {
-        if (task instanceof RecursionBreakingRunnable) {
-            if (task == null) {
-                throw new NullPointerException("task");
-            }
-            if (isTerminated()) {
-                reject();
-            }
-            // put the task at the first postion of the queue as we just schedule it to
-            // break the recursive operation
-            taskQueue.addFirst(task);
-        } else {
-            super.addTask(task);
-        }
-    }
-
-    /**
-     * Special Runnable which is used by {@link AioCompletionHandler} to break a recursive call and so prevent
-     * from StackOverFlowError. When a task is executed that implement it needs to put on the first position of
-     * the queue to guaranteer execution order and break the recursive call.
-     */
-    interface RecursionBreakingRunnable extends Runnable {
-        // Marker interface
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/aio/AioEventLoopGroup.java b/transport/src/main/java/io/netty/channel/aio/AioEventLoopGroup.java
deleted file mode 100644
index a08a791863ec..000000000000
--- a/transport/src/main/java/io/netty/channel/aio/AioEventLoopGroup.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.aio;
-
-import io.netty.channel.Channel;
-import io.netty.channel.EventLoopException;
-import io.netty.channel.MultithreadEventLoopGroup;
-import io.netty.util.concurrent.EventExecutor;
-
-import java.io.IOException;
-import java.nio.channels.AsynchronousChannelGroup;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.AbstractExecutorService;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-
-/**
- * {@link AioEventLoopGroup} implementation which will handle AIO {@link Channel} implementations.
- *
- */
-public class AioEventLoopGroup extends MultithreadEventLoopGroup {
-    private final AioExecutorService groupExecutor = new AioExecutorService();
-    private final AsynchronousChannelGroup group;
-
-    public AsynchronousChannelGroup channelGroup() {
-        return group;
-    }
-
-    /**
-     * Create a new instance which use the default number of threads of {@link #DEFAULT_EVENT_LOOP_THREADS}.
-     */
-    public AioEventLoopGroup() {
-        this(DEFAULT_EVENT_LOOP_THREADS);
-    }
-
-    /**
-     * Create a new instance
-     *
-     * @param nThreads          the number of threads that will be used by this instance
-     */
-    public AioEventLoopGroup(int nThreads) {
-        this(nThreads, null);
-    }
-
-    /**
-     * Create a new instance.
-     *
-     * @param nThreads          the number of threads that will be used by this instance
-     * @param threadFactory     the ThreadFactory to use, or {@code null} if the default should be used.
-     */
-    public AioEventLoopGroup(int nThreads, ThreadFactory threadFactory) {
-        super(nThreads, threadFactory);
-        try {
-            group = AsynchronousChannelGroup.withThreadPool(groupExecutor);
-        } catch (IOException e) {
-            throw new EventLoopException("Failed to create an AsynchronousChannelGroup", e);
-        }
-    }
-
-    @Override
-    @Deprecated
-    @SuppressWarnings("deprecation")
-    public void shutdown() {
-        boolean interrupted = false;
-
-        // Tell JDK not to accept any more registration request.  Note that the threads are not really shut down yet.
-        try {
-            group.shutdownNow();
-        } catch (IOException e) {
-            throw new EventLoopException("failed to shut down a channel group", e);
-        }
-
-        // Wait until JDK propagates the shutdown request on AsynchronousChannelGroup to the ExecutorService.
-        // JDK will probably submit some final tasks to the ExecutorService before shutting down the ExecutorService,
-        // so we have to ensure all tasks submitted by JDK are executed before calling super.shutdown() to really
-        // shut down event loop threads.
-        while (!groupExecutor.isTerminated()) {
-            try {
-                groupExecutor.awaitTermination(1, TimeUnit.HOURS);
-            } catch (InterruptedException e) {
-                interrupted = true;
-            }
-        }
-
-        // Close all connections and shut down event loop threads.
-        super.shutdown();
-
-        if (interrupted) {
-            Thread.currentThread().interrupt();
-        }
-    }
-
-    @Override
-    protected EventExecutor newChild(ThreadFactory threadFactory, Object... args) throws Exception {
-        return new AioEventLoop(this, threadFactory);
-    }
-
-    private static final class AioExecutorService extends AbstractExecutorService {
-
-        // It does not shut down the underlying EventExecutor - it merely pretends to be shut down.
-        // The actual shut down is done by EventLoopGroup and EventLoop implementation.
-        private final CountDownLatch latch = new CountDownLatch(1);
-
-        @Override
-        public void shutdown() {
-            latch.countDown();
-        }
-
-        @Override
-        public List<Runnable> shutdownNow() {
-            shutdown();
-            return Collections.emptyList();
-        }
-
-        @Override
-        public boolean isShutdown() {
-            return latch.getCount() == 0;
-        }
-
-        @Override
-        public boolean isTerminated() {
-            return isShutdown();
-        }
-
-        @Override
-        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-            return latch.await(timeout, unit);
-        }
-
-        @Override
-        public void execute(Runnable command) {
-            command.run();
-        }
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/aio/package-info.java b/transport/src/main/java/io/netty/channel/aio/package-info.java
deleted file mode 100644
index f21c64e56afa..000000000000
--- a/transport/src/main/java/io/netty/channel/aio/package-info.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-/**
- * <a href="http://en.wikipedia.org/wiki/New_I/O">NIO2</a>-based channel
- * API implementation - recommended for a large number of connections (&gt;= 1000).
- *
- * NIO2 is only supported on Java 7+.
- */
-package io.netty.channel.aio;
diff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedByteChannel.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedByteChannel.java
deleted file mode 100644
index 421a3b30ca0e..000000000000
--- a/transport/src/main/java/io/netty/channel/embedded/EmbeddedByteChannel.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.embedded;
-
-import io.netty.buffer.BufType;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelMetadata;
-import io.netty.channel.ChannelPipeline;
-
-
-/**
- * Embedded {@link Channel} which operates on bytes
- */
-public class EmbeddedByteChannel extends AbstractEmbeddedChannel<ByteBuf> {
-
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);
-
-    /**
-     * Create a new instance with the given {@link ChannelHandler}s in the {@link ChannelPipeline}
-     */
-    public EmbeddedByteChannel(ChannelHandler... handlers) {
-        super(Unpooled.buffer(), handlers);
-    }
-
-    @Override
-    public ChannelMetadata metadata() {
-        return METADATA;
-    }
-
-    @Override
-    public ByteBuf inboundBuffer() {
-        return pipeline().inboundByteBuffer();
-    }
-
-    @Override
-    public ByteBuf lastOutboundBuffer() {
-        return (ByteBuf) lastOutboundBuffer;
-    }
-
-    @Override
-    public ByteBuf readOutbound() {
-        if (!lastOutboundBuffer().isReadable()) {
-            return null;
-        }
-        try {
-            return lastOutboundBuffer().readBytes(lastOutboundBuffer().readableBytes());
-        } finally {
-            lastOutboundBuffer().clear();
-        }
-    }
-
-    @Override
-    protected void writeInbound0(ByteBuf data) {
-        inboundBuffer().writeBytes(data);
-    }
-
-    @Override
-    protected boolean hasReadableOutboundBuffer() {
-        return lastOutboundBuffer().isReadable();
-    }
-
-    @Override
-    protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
-        lastOutboundBuffer().writeBytes(buf);
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/embedded/AbstractEmbeddedChannel.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
similarity index 55%
rename from transport/src/main/java/io/netty/channel/embedded/AbstractEmbeddedChannel.java
rename to transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
index f9508096523a..54862aea6234 100755
--- a/transport/src/main/java/io/netty/channel/embedded/AbstractEmbeddedChannel.java
+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
@@ -15,92 +15,81 @@
  */
 package io.netty.channel.embedded;
 
-import io.netty.buffer.Buf;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelInboundMessageHandler;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
-import io.netty.channel.ChannelStateHandlerAdapter;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.EventLoop;
+import io.netty.channel.MessageList;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.net.SocketAddress;
 import java.nio.channels.ClosedChannelException;
+import java.util.ArrayDeque;
+import java.util.Queue;
 
 /**
  * Base class for {@link Channel} implementations that are used in an embedded fashion.
- *
- * @param <O>  the type of data that can be written to this {@link Channel}
  */
-public abstract class AbstractEmbeddedChannel<O> extends AbstractChannel {
+public class EmbeddedChannel extends AbstractChannel {
+
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(EmbeddedChannel.class);
 
-    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractEmbeddedChannel.class);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private final EmbeddedEventLoop loop = new EmbeddedEventLoop();
     private final ChannelConfig config = new DefaultChannelConfig(this);
     private final SocketAddress localAddress = new EmbeddedSocketAddress();
     private final SocketAddress remoteAddress = new EmbeddedSocketAddress();
-    private final MessageBuf<Object> lastInboundMessageBuffer = Unpooled.messageBuffer().retain(2);
-    private final ByteBuf lastInboundByteBuffer = Unpooled.buffer().retain(2);
-    protected final Object lastOutboundBuffer;
+    private final Queue<Object> lastInboundBuffer = new ArrayDeque<Object>();
+    private final Queue<Object> lastOutboundBuffer = new ArrayDeque<Object>();
     private Throwable lastException;
     private int state; // 0 = OPEN, 1 = ACTIVE, 2 = CLOSED
 
     /**
      * Create a new instance
      *
-     * @param lastOutboundBuffer    the last outbound buffer which will hold all the written data
-     * @param handlers              the @link ChannelHandler}s which will be add in the {@link ChannelPipeline}
+     * @param handlers the @link ChannelHandler}s which will be add in the {@link ChannelPipeline}
      */
-    AbstractEmbeddedChannel(Object lastOutboundBuffer, ChannelHandler... handlers) {
+    public EmbeddedChannel(ChannelHandler... handlers) {
         super(null, null);
 
         if (handlers == null) {
             throw new NullPointerException("handlers");
         }
 
-        this.lastOutboundBuffer = lastOutboundBuffer;
-
         int nHandlers = 0;
-        boolean hasBuffer = false;
         ChannelPipeline p = pipeline();
         for (ChannelHandler h: handlers) {
             if (h == null) {
                 break;
             }
             nHandlers ++;
-            ChannelHandlerContext ctx = p.addLast(h).context(h);
-
-            if (ctx.hasInboundByteBuffer() || ctx.hasOutboundByteBuffer()
-                    || ctx.hasInboundMessageBuffer() || ctx.hasOutboundMessageBuffer()) {
-                hasBuffer = true;
-            }
+            p.addLast(h);
         }
 
         if (nHandlers == 0) {
             throw new IllegalArgumentException("handlers is empty.");
         }
 
-        if (!hasBuffer) {
-            throw new IllegalArgumentException("handlers does not provide any buffers.");
-        }
-
-        p.addLast(new LastInboundMessageHandler(), new LastInboundByteHandler());
+        p.addLast(new LastInboundHandler());
         loop.register(this);
     }
 
+    @Override
+    public ChannelMetadata metadata() {
+        return METADATA;
+    }
+
     @Override
     public ChannelConfig config() {
         return config;
@@ -117,33 +106,87 @@ public boolean isActive() {
     }
 
     /**
-     * Return the last inbound {@link MessageBuf} which will hold all the {@link Object}s that where received
-     * by this {@link Channel}
+     * Returns the buffer which holds all the {@link Object}s that were received by this {@link Channel}.
      */
-    public MessageBuf<Object> lastInboundMessageBuffer() {
-        return lastInboundMessageBuffer;
+    public Queue<Object> lastInboundBuffer() {
+        return lastInboundBuffer;
     }
 
     /**
-     * Return the last inbound {@link ByteBuf} which will hold all the bytes that where received
-     * by this {@link Channel}
+     * Returns the buffer which holds all the {@link Object}s that were written by this {@link Channel}.
      */
-    public ByteBuf lastInboundByteBuffer() {
-        return lastInboundByteBuffer;
+    public Queue<Object> lastOutboundBuffer() {
+        return lastOutboundBuffer;
     }
 
     /**
      * Return received data from this {@link Channel}
      */
     public Object readInbound() {
-        if (lastInboundByteBuffer.isReadable()) {
-            try {
-                return lastInboundByteBuffer.readBytes(lastInboundByteBuffer.readableBytes());
-            } finally {
-                lastInboundByteBuffer.clear();
-            }
+        return lastInboundBuffer.poll();
+    }
+
+    /**
+     * Read data froum the outbound. This may return {@code null} if nothing is readable.
+     */
+    public Object readOutbound() {
+        return lastOutboundBuffer.poll();
+    }
+
+    /**
+     * Write messages to the inbound of this {@link Channel}.
+     *
+     * @param msgs the messages to be written
+     *
+     * @return {@code true} if the write operation did add something to the the inbound buffer
+     */
+    public boolean writeInbound(Object... msgs) {
+        ensureOpen();
+        if (msgs.length == 0) {
+            return !lastInboundBuffer.isEmpty();
+        }
+        MessageList<Object> list = MessageList.newInstance(msgs.length);
+        list.add(msgs);
+        pipeline().fireMessageReceived(list);
+        runPendingTasks();
+        checkException();
+        return !lastInboundBuffer.isEmpty();
+    }
+
+    /**
+     * Write messages to the outbound of this {@link Channel}.
+     *
+     * @param msgs              the messages to be written
+     * @return bufferReadable   returns {@code true} if the write operation did add something to the the outbound buffer
+     */
+    public boolean writeOutbound(Object... msgs) {
+        ensureOpen();
+        if (msgs.length == 0) {
+            return !lastOutboundBuffer.isEmpty();
+        }
+        MessageList<Object> list = MessageList.newInstance(msgs.length);
+        list.add(msgs);
+        ChannelFuture future = write(list);
+        assert future.isDone();
+        if (future.cause() != null) {
+            recordException(future.cause());
         }
-        return lastInboundMessageBuffer.poll();
+        runPendingTasks();
+        checkException();
+        return !lastOutboundBuffer.isEmpty();
+    }
+
+    /**
+     * Mark this {@link Channel} as finished. Any futher try to write data to it will fail.
+     *
+     *
+     * @return bufferReadable returns {@code true} if any of the used buffers has something left to read
+     */
+    public boolean finish() {
+        close();
+        runPendingTasks();
+        checkException();
+        return !lastInboundBuffer.isEmpty() || !lastOutboundBuffer.isEmpty();
     }
 
     /**
@@ -244,120 +287,34 @@ protected boolean isFlushPending() {
         return false;
     }
 
-    /**
-     * Read data froum the outbound. This may return {@code null} if nothing is readable.
-     */
-    public abstract O readOutbound();
-
-    /**
-     * Return the inbound buffer in which inbound messages are stored.
-     */
-    public abstract Buf inboundBuffer();
-
-    /**
-     * Return the last outbound buffer in which all the written outbound messages are stored.
-     */
-    public abstract Buf lastOutboundBuffer();
-
-    /**
-     * Mark this {@link Channel} as finished. Any futher try to write data to it will fail.
-     *
-     *
-     * @return bufferReadable returns {@code true} if any of the used buffers has something left to read
-     */
-    public boolean finish() {
-        close();
-        runPendingTasks();
-        checkException();
-        return lastInboundByteBuffer().isReadable() || !lastInboundMessageBuffer().isEmpty() ||
-                hasReadableOutboundBuffer();
-    }
-
-    /**
-     * Write data to the inbound of this {@link Channel}.
-     *
-     * @param data              data that should be written
-     * @return bufferReadable   returns {@code true} if the write operation did add something to the the inbound buffer
-     */
-    public boolean writeInbound(O data) {
-        ensureOpen();
-        writeInbound0(data);
-        pipeline().fireInboundBufferUpdated();
-        runPendingTasks();
-        checkException();
-        return lastInboundByteBuffer().isReadable() || !lastInboundMessageBuffer().isEmpty();
-    }
-
-    /**
-     * Write data to the outbound of this {@link Channel}.
-     *
-     * @param data              data that should be written
-     * @return bufferReadable   returns {@code true} if the write operation did add something to the the outbound buffer
-     */
-    public boolean writeOutbound(Object data) {
-        ensureOpen();
-        ChannelFuture future = write(data);
-        assert future.isDone();
-        if (future.cause() != null) {
-            recordException(future.cause());
+    @Override
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
+        int size = msgs.size();
+        for (int i = index; i < size; i ++) {
+            lastOutboundBuffer.add(msgs.get(i));
         }
-        runPendingTasks();
-        checkException();
-        return hasReadableOutboundBuffer();
+        return size - index;
     }
 
-    /**
-     * Returns {@code true} if the outbound buffer hold some data which can be read
-     */
-    protected abstract boolean hasReadableOutboundBuffer();
-
-    /**
-     * Add the data to the inbound buffer.
-     */
-    protected abstract void writeInbound0(O data);
-
     private class DefaultUnsafe extends AbstractUnsafe {
         @Override
-        public void connect(SocketAddress remoteAddress,
-                SocketAddress localAddress, ChannelPromise promise) {
+        public void connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
             promise.setSuccess();
         }
     }
 
-    private final class LastInboundMessageHandler extends ChannelStateHandlerAdapter
-            implements ChannelInboundMessageHandler<Object> {
+    private final class LastInboundHandler extends ChannelInboundHandlerAdapter {
         @Override
-        public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return lastInboundMessageBuffer;
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-            // Do nothing.
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            int size = msgs.size();
+            for (int i = 0; i < size; i ++) {
+                lastInboundBuffer.add(msgs.get(i));
+            }
         }
 
         @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
-                throws Exception {
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
             recordException(cause);
         }
     }
-
-    private final class LastInboundByteHandler extends ChannelStateHandlerAdapter
-            implements ChannelInboundByteHandler {
-        @Override
-        public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return lastInboundByteBuffer;
-        }
-
-        @Override
-        public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-            // nothing
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-            // No nothing
-        }
-    }
 }
diff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
index 4f2ea60ee131..dc7892501c85 100644
--- a/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
@@ -21,6 +21,7 @@
 import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.concurrent.AbstractEventExecutor;
+import io.netty.util.concurrent.Future;
 
 import java.util.ArrayDeque;
 import java.util.Queue;
@@ -50,11 +51,20 @@ void runTasks() {
     }
 
     @Override
-    public void shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) { }
+    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Future<?> terminationFuture() {
+        throw new UnsupportedOperationException();
+    }
 
     @Override
     @Deprecated
-    public void shutdown() { }
+    public void shutdown() {
+        throw new UnsupportedOperationException();
+    }
 
     @Override
     public boolean isShuttingDown() {
diff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedMessageChannel.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedMessageChannel.java
deleted file mode 100644
index ecb9b447c42d..000000000000
--- a/transport/src/main/java/io/netty/channel/embedded/EmbeddedMessageChannel.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.embedded;
-
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelMetadata;
-import io.netty.channel.ChannelPipeline;
-
-/**
- * Embedded {@link Channel} which operates on messages which can be of any time.
- */
-public class EmbeddedMessageChannel extends AbstractEmbeddedChannel<Object> {
-
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
-
-    /**
-     * Create a new instance with the given {@link ChannelHandler}s in the {@link ChannelPipeline}
-     */
-    public EmbeddedMessageChannel(ChannelHandler... handlers) {
-        super(Unpooled.messageBuffer(), handlers);
-    }
-
-    @Override
-    public ChannelMetadata metadata() {
-        return METADATA;
-    }
-
-    @Override
-    public MessageBuf<Object> inboundBuffer() {
-        return pipeline().inboundMessageBuffer();
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public MessageBuf<Object> lastOutboundBuffer() {
-        return (MessageBuf<Object>) lastOutboundBuffer;
-    }
-
-    @Override
-    public Object readOutbound() {
-        return lastOutboundBuffer().poll();
-    }
-
-    @Override
-    protected void writeInbound0(Object data) {
-        inboundBuffer().add(data);
-    }
-
-    @Override
-    protected boolean hasReadableOutboundBuffer() {
-        return !lastOutboundBuffer().isEmpty();
-    }
-
-    @Override
-    protected void doFlushMessageBuffer(MessageBuf<Object> buf) throws Exception {
-        buf.drainTo(lastOutboundBuffer());
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/group/ChannelGroup.java b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
index a8230de2aa97..b034d943776d 100644
--- a/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
@@ -20,9 +20,9 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelStateHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.EventLoop;
-import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
 import io.netty.channel.ServerChannel;
 import io.netty.util.CharsetUtil;
 
@@ -78,7 +78,7 @@
  *     b.releaseExternalResources();
  * }
  *
- * public class MyHandler extends {@link ChannelStateHandlerAdapter} {
+ * public class MyHandler extends {@link ChannelInboundHandlerAdapter} {
  *     {@code @Override}
  *     public void channelActive({@link ChannelHandlerContext} ctx) {
  *         // closed on shutdown.
@@ -117,23 +117,17 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
     ChannelGroupFuture write(Object message);
 
     /**
-     * Writes the specified {@link FileRegion} to all {@link Channel}s in this
-     * group. Please note that this operation is asynchronous as
-     * {@link Channel#sendFile(FileRegion)} is.
-     *
-     * @return the {@link ChannelGroupFuture} instance that notifies when
-     *         the operation is done for all channels
-     */
-    ChannelGroupFuture sendFile(FileRegion region);
-
-    /**
-     * Flush all {@link Channel} in this group. Please note that this operation
-     * is asynchronous as {@link Channel#flush()} is.
+     * Writes the specified {@code messages} to all {@link Channel}s in this
+     * group. If the specified {@code messages} are an instance of
+     * {@link ByteBuf}, it is automatically
+     * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race
+     * condition. Please note that this operation is asynchronous as
+     * {@link Channel#write(Object)} is.
      *
      * @return the {@link ChannelGroupFuture} instance that notifies when
      *         the operation is done for all channels
      */
-    ChannelGroupFuture flush();
+    ChannelGroupFuture write(MessageList<Object> messages);
 
     /**
      * Disconnects all {@link Channel}s in this group from their remote peers.
diff --git a/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java b/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java
index db2f6a0c8cc0..ac83f7e84681 100644
--- a/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java
+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java
@@ -151,16 +151,16 @@ public interface ChannelGroupFuture extends Future<Void>, Iterable<ChannelFuture
     boolean isPartialFailure();
 
     @Override
-    ChannelGroupFuture addListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelGroupFuture addListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelGroupFuture addListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelGroupFuture addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
-    ChannelGroupFuture removeListener(GenericFutureListener<? extends Future<Void>> listener);
+    ChannelGroupFuture removeListener(GenericFutureListener<? extends Future<? super Void>> listener);
 
     @Override
-    ChannelGroupFuture removeListeners(GenericFutureListener<? extends Future<Void>>... listeners);
+    ChannelGroupFuture removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners);
 
     @Override
     ChannelGroupFuture await() throws InterruptedException;
diff --git a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
index 930aa6894ec9..66bc90e80129 100644
--- a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
@@ -15,14 +15,13 @@
  */
 package io.netty.channel.group;
 
-import io.netty.buffer.BufUtil;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
 import io.netty.channel.ServerChannel;
 import io.netty.util.concurrent.EventExecutor;
-import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.internal.PlatformDependent;
 
 import java.util.AbstractSet;
@@ -51,13 +50,6 @@ public void operationComplete(ChannelFuture future) throws Exception {
         }
     };
 
-    /**
-     * Creates a new group with a generated name.
-     */
-    public DefaultChannelGroup() {
-        this("group-0x" + Integer.toHexString(nextId.incrementAndGet()));
-    }
-
     /**
      * Creates a new group with a generated name amd the provided {@link EventExecutor} to notify the
      * {@link ChannelGroupFuture}s.
@@ -66,15 +58,6 @@ public DefaultChannelGroup(EventExecutor executor) {
         this("group-0x" + Integer.toHexString(nextId.incrementAndGet()), executor);
     }
 
-    /**
-     * Creates a new group with the specified {@code name}.  Please note that
-     * different groups can have the same name, which means no duplicate check
-     * is done against group names.
-     */
-    public DefaultChannelGroup(String name) {
-        this(name, ImmediateEventExecutor.INSTANCE);
-    }
-
     /**
      * Creates a new group with the specified {@code name} and {@link EventExecutor} to notify the
      * {@link ChannelGroupFuture}s.  Please note that different groups can have the same name, which means no
@@ -233,37 +216,27 @@ public ChannelGroupFuture write(Object message) {
 
         Map<Integer, ChannelFuture> futures = new LinkedHashMap<Integer, ChannelFuture>(size());
         for (Channel c: nonServerChannels.values()) {
-            BufUtil.retain(message);
+            ByteBufUtil.retain(message);
             futures.put(c.id(), c.write(message));
         }
 
-        BufUtil.release(message);
+        ByteBufUtil.release(message);
         return new DefaultChannelGroupFuture(this, futures, executor);
     }
 
     @Override
-    public ChannelGroupFuture sendFile(FileRegion region) {
-        if (region == null) {
-            throw new NullPointerException("region");
+    public ChannelGroupFuture write(MessageList<Object> messages) {
+        if (messages == null) {
+            throw new NullPointerException("messages");
         }
 
         Map<Integer, ChannelFuture> futures = new LinkedHashMap<Integer, ChannelFuture>(size());
         for (Channel c: nonServerChannels.values()) {
-            BufUtil.retain(region);
-            futures.put(c.id(), c.sendFile(region));
-        }
-
-        BufUtil.release(region);
-        return new DefaultChannelGroupFuture(this, futures, executor);
-    }
-
-    @Override
-    public ChannelGroupFuture flush() {
-        Map<Integer, ChannelFuture> futures = new LinkedHashMap<Integer, ChannelFuture>(size());
-        for (Channel c: nonServerChannels.values()) {
-            futures.put(c.id(), c.flush());
+            MessageList<Object> messagesCopy = messages.retainAll().copy();
+            futures.put(c.id(), c.write(messagesCopy));
         }
 
+        messages.releaseAllAndRecycle();
         return new DefaultChannelGroupFuture(this, futures, executor);
     }
 
diff --git a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
index 1b3dbb2bb5a3..9400a19c1e70 100644
--- a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java
@@ -153,25 +153,26 @@ public synchronized boolean isPartialFailure() {
     }
 
     @Override
-    public DefaultChannelGroupFuture addListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public DefaultChannelGroupFuture addListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         super.addListener(listener);
         return this;
     }
 
     @Override
-    public DefaultChannelGroupFuture addListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public DefaultChannelGroupFuture addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
         super.addListeners(listeners);
         return this;
     }
 
     @Override
-    public DefaultChannelGroupFuture removeListener(GenericFutureListener<? extends Future<Void>> listener) {
+    public DefaultChannelGroupFuture removeListener(GenericFutureListener<? extends Future<? super Void>> listener) {
         super.removeListener(listener);
         return this;
     }
 
     @Override
-    public DefaultChannelGroupFuture removeListeners(GenericFutureListener<? extends Future<Void>>... listeners) {
+    public DefaultChannelGroupFuture removeListeners(
+            GenericFutureListener<? extends Future<? super Void>>... listeners) {
         super.removeListeners(listeners);
         return this;
     }
@@ -236,7 +237,7 @@ public boolean tryFailure(Throwable cause) {
     @Override
     protected void checkDeadLock() {
         EventExecutor e = executor();
-        if (e != null && !(e instanceof ImmediateEventExecutor) && e.inEventLoop()) {
+        if (e != null && e != ImmediateEventExecutor.INSTANCE && e.inEventLoop()) {
             throw new BlockingOperationException();
         }
     }
diff --git a/transport/src/main/java/io/netty/channel/local/LocalChannel.java b/transport/src/main/java/io/netty/channel/local/LocalChannel.java
index 7142304223dd..116f6905c19a 100755
--- a/transport/src/main/java/io/netty/channel/local/LocalChannel.java
+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java
@@ -15,8 +15,6 @@
  */
 package io.netty.channel.local;
 
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelConfig;
@@ -26,6 +24,7 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.EventLoop;
+import io.netty.channel.MessageList;
 import io.netty.channel.SingleThreadEventLoop;
 import io.netty.util.concurrent.SingleThreadEventExecutor;
 
@@ -34,20 +33,45 @@
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.ConnectionPendingException;
 import java.nio.channels.NotYetConnectedException;
-import java.util.Collections;
+import java.util.ArrayDeque;
+import java.util.Queue;
 
 /**
  * A {@link Channel} for the local transport.
  */
 public class LocalChannel extends AbstractChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
+
+    private static final int MAX_READER_STACK_DEPTH = 8;
+    private static final ThreadLocal<Integer> READER_STACK_DEPTH = new ThreadLocal<Integer>() {
+        @Override
+        protected Integer initialValue() {
+            return 0;
+        }
+    };
 
     private final ChannelConfig config = new DefaultChannelConfig(this);
+    private final Queue<MessageList<Object>> inboundBuffer = new ArrayDeque<MessageList<Object>>();
+    private final Runnable readTask = new Runnable() {
+        @Override
+        public void run() {
+            ChannelPipeline pipeline = pipeline();
+            for (;;) {
+                MessageList<Object> m = inboundBuffer.poll();
+                if (m == null) {
+                    break;
+                }
+                pipeline.fireMessageReceived(m);
+            }
+            pipeline.fireChannelReadSuspended();
+        }
+    };
+
     private final Runnable shutdownHook = new Runnable() {
         @Override
         public void run() {
-            unsafe().close(voidPromise());
+            unsafe().close(unsafe().voidPromise());
         }
     };
 
@@ -198,7 +222,7 @@ protected void doPreClose() throws Exception {
     protected void doClose() throws Exception {
         LocalChannel peer = this.peer;
         if (peer != null && peer.isActive()) {
-            peer.unsafe().close(voidPromise());
+            peer.unsafe().close(unsafe().voidPromise());
             this.peer = null;
         }
     }
@@ -206,7 +230,7 @@ protected void doClose() throws Exception {
     @Override
     protected Runnable doDeregister() throws Exception {
         if (isOpen()) {
-            unsafe().close(voidPromise());
+            unsafe().close(unsafe().voidPromise());
         }
         ((SingleThreadEventExecutor) eventLoop()).removeShutdownHook(shutdownHook);
         return null;
@@ -219,18 +243,34 @@ protected void doBeginRead() throws Exception {
         }
 
         ChannelPipeline pipeline = pipeline();
-        MessageBuf<Object> buf = pipeline.inboundMessageBuffer();
-        if (buf.isEmpty()) {
+        Queue<MessageList<Object>> inboundBuffer = this.inboundBuffer;
+        if (inboundBuffer.isEmpty()) {
             readInProgress = true;
             return;
         }
 
-        pipeline.fireInboundBufferUpdated();
-        pipeline.fireChannelReadSuspended();
+        final Integer stackDepth = READER_STACK_DEPTH.get();
+        if (stackDepth < MAX_READER_STACK_DEPTH) {
+            READER_STACK_DEPTH.set(stackDepth + 1);
+            try {
+                for (;;) {
+                    MessageList<Object> received = inboundBuffer.poll();
+                    if (received == null) {
+                        break;
+                    }
+                    pipeline.fireMessageReceived(received);
+                }
+                pipeline.fireChannelReadSuspended();
+            } finally {
+                READER_STACK_DEPTH.set(stackDepth);
+            }
+        } else {
+            eventLoop().execute(readTask);
+        }
     }
 
     @Override
-    protected void doFlushMessageBuffer(MessageBuf<Object> buf) throws Exception {
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
         if (state < 2) {
             throw new NotYetConnectedException();
         }
@@ -241,28 +281,37 @@ protected void doFlushMessageBuffer(MessageBuf<Object> buf) throws Exception {
         final LocalChannel peer = this.peer;
         final ChannelPipeline peerPipeline = peer.pipeline();
         final EventLoop peerLoop = peer.eventLoop();
+        final int size = msgs.size();
+
+        // Use a copy because the original msgs will be recycled by AbstractChannel.
+        final MessageList<Object> msgsCopy = msgs.copy();
 
         if (peerLoop == eventLoop()) {
-            buf.drainTo(peerPipeline.inboundMessageBuffer());
+            peer.inboundBuffer.add(msgsCopy);
             finishPeerRead(peer, peerPipeline);
         } else {
-            final Object[] msgs = buf.toArray();
-            buf.clear();
             peerLoop.execute(new Runnable() {
                 @Override
                 public void run() {
-                    MessageBuf<Object> buf = peerPipeline.inboundMessageBuffer();
-                    Collections.addAll(buf, msgs);
+                    peer.inboundBuffer.add(msgsCopy);
                     finishPeerRead(peer, peerPipeline);
                 }
             });
         }
+
+        return size - index;
     }
 
     private static void finishPeerRead(LocalChannel peer, ChannelPipeline peerPipeline) {
         if (peer.readInProgress) {
             peer.readInProgress = false;
-            peerPipeline.fireInboundBufferUpdated();
+            for (;;) {
+                MessageList<Object> received = peer.inboundBuffer.poll();
+                if (received == null) {
+                    break;
+                }
+                peerPipeline.fireMessageReceived(received);
+            }
             peerPipeline.fireChannelReadSuspended();
         }
     }
diff --git a/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
index c0c36ba09a41..7f0aabdac5d1 100755
--- a/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
+++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java
@@ -15,17 +15,19 @@
  */
 package io.netty.channel.local;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.AbstractServerChannel;
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.DefaultChannelConfig;
 import io.netty.channel.EventLoop;
+import io.netty.channel.MessageList;
 import io.netty.channel.ServerChannel;
 import io.netty.channel.SingleThreadEventLoop;
 import io.netty.util.concurrent.SingleThreadEventExecutor;
 
 import java.net.SocketAddress;
+import java.util.ArrayDeque;
+import java.util.Queue;
 
 /**
  * A {@link ServerChannel} for the local transport which allows in VM communication.
@@ -33,10 +35,11 @@
 public class LocalServerChannel extends AbstractServerChannel {
 
     private final ChannelConfig config = new DefaultChannelConfig(this);
+    private final Queue<Object> inboundBuffer = new ArrayDeque<Object>();
     private final Runnable shutdownHook = new Runnable() {
         @Override
         public void run() {
-            unsafe().close(voidPromise());
+            unsafe().close(unsafe().voidPromise());
         }
     };
 
@@ -138,13 +141,15 @@ protected void doBeginRead() throws Exception {
         }
 
         ChannelPipeline pipeline = pipeline();
-        MessageBuf<Object> buf = pipeline.inboundMessageBuffer();
-        if (buf.isEmpty()) {
+        Queue<Object> inboundBuffer = this.inboundBuffer;
+        if (inboundBuffer.isEmpty()) {
             acceptInProgress = true;
             return;
         }
 
-        pipeline.fireInboundBufferUpdated();
+        Object[] messages = inboundBuffer.toArray();
+        inboundBuffer.clear();
+        pipeline.fireMessageReceived(messages);
         pipeline.fireChannelReadSuspended();
     }
 
@@ -157,10 +162,19 @@ LocalChannel serve(final LocalChannel peer) {
     private void serve0(final LocalChannel child) {
         if (eventLoop().inEventLoop()) {
             final ChannelPipeline pipeline = pipeline();
-            pipeline.inboundMessageBuffer().add(child);
+            inboundBuffer.add(child);
             if (acceptInProgress) {
                 acceptInProgress = false;
-                pipeline.fireInboundBufferUpdated();
+                MessageList<Object> messages = MessageList.newInstance();
+                for (;;) {
+                    Object m = inboundBuffer.poll();
+                    if (m == null) {
+                        break;
+                    }
+                    messages.add(m);
+                }
+                inboundBuffer.clear();
+                pipeline.fireMessageReceived(messages);
                 pipeline.fireChannelReadSuspended();
             }
         } else {
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
index b2918e246d89..5208dd8e9a23 100755
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
@@ -17,15 +17,18 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.socket.ChannelInputShutdownEvent;
+import io.netty.util.internal.StringUtil;
 
 import java.io.IOException;
-import java.nio.channels.ClosedChannelException;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
-import java.nio.channels.WritableByteChannel;
 
 /**
  * {@link AbstractNioChannel} base class for {@link Channel}s that operate on bytes.
@@ -50,72 +53,53 @@ protected AbstractNioUnsafe newUnsafe() {
     }
 
     private final class NioByteUnsafe extends AbstractNioUnsafe {
+        private RecvByteBufAllocator.Handle allocHandle;
+
         @Override
         public void read() {
             assert eventLoop().inEventLoop();
             final SelectionKey key = selectionKey();
-            if (!config().isAutoRead()) {
-                // only remove readInterestOp if needed
-                key.interestOps(key.interestOps() & ~readInterestOp);
+            final ChannelConfig config = config();
+            if (!config.isAutoRead()) {
+                int interestOps = key.interestOps();
+                if ((interestOps & readInterestOp) != 0) {
+                    // only remove readInterestOp if needed
+                    key.interestOps(interestOps & ~readInterestOp);
+                }
             }
 
             final ChannelPipeline pipeline = pipeline();
-            final ByteBuf byteBuf = pipeline.inboundByteBuffer();
+
+            RecvByteBufAllocator.Handle allocHandle = this.allocHandle;
+            if (allocHandle == null) {
+                this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();
+            }
+
+            ByteBuf byteBuf = allocHandle.allocate(config.getAllocator());
             boolean closed = false;
-            boolean read = false;
-            boolean firedChannelReadSuspended = false;
+            Throwable exception = null;
             try {
-                expandReadBuffer(byteBuf);
-                loop: for (;;) {
-                    int localReadAmount = doReadBytes(byteBuf);
-                    if (localReadAmount > 0) {
-                        read = true;
-                    } else if (localReadAmount < 0) {
-                        closed = true;
-                        break;
-                    }
-
-                    switch (expandReadBuffer(byteBuf)) {
-                    case 0:
-                        // Read all - stop reading.
-                        break loop;
-                    case 1:
-                        // Keep reading until everything is read.
-                        break;
-                    case 2:
-                        // Let the inbound handler drain the buffer and continue reading.
-                        if (read) {
-                            read = false;
-                            pipeline.fireInboundBufferUpdated();
-                            if (!byteBuf.isWritable()) {
-                                throw new IllegalStateException(
-                                        "an inbound handler whose buffer is full must consume at " +
-                                        "least one byte.");
-                            }
-                        }
-                        if (!config().isAutoRead()) {
-                            // stop reading until next Channel.read() call
-                            // See https://github.com/netty/netty/issues/1363
-                            break loop;
-                        }
-                    }
+                int localReadAmount = doReadBytes(byteBuf);
+                if (localReadAmount < 0) {
+                    closed = true;
                 }
             } catch (Throwable t) {
-                if (read) {
-                    read = false;
-                    pipeline.fireInboundBufferUpdated();
+                exception = t;
+            } finally {
+                int readBytes = byteBuf.readableBytes();
+                allocHandle.record(readBytes);
+                if (readBytes != 0) {
+                    pipeline.fireMessageReceived(byteBuf);
+                } else {
+                    byteBuf.release();
                 }
 
-                if (t instanceof IOException) {
-                    closed = true;
-                } else if (!closed) {
-                    firedChannelReadSuspended = true;
-                    pipeline.fireChannelReadSuspended();
-                }
-                pipeline().fireExceptionCaught(t);
-            } finally {
-                if (read) {
-                    pipeline.fireInboundBufferUpdated();
+                if (exception != null) {
+                    if (exception instanceof IOException) {
+                        closed = true;
+                    }
+
+                    pipeline().fireExceptionCaught(exception);
                 }
 
                 if (closed) {
@@ -128,7 +112,7 @@ public void read() {
                             close(voidPromise());
                         }
                     }
-                } else if (!firedChannelReadSuspended) {
+                } else {
                     pipeline.fireChannelReadSuspended();
                 }
             }
@@ -136,92 +120,77 @@ public void read() {
     }
 
     @Override
-    protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
-        for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
-            int localFlushedAmount = doWriteBytes(buf, i == 0);
-            if (localFlushedAmount > 0) {
-                break;
-            }
-            if (!buf.isReadable()) {
-                // Reset reader/writerIndex to 0 if the buffer is empty.
-                buf.clear();
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
+        int size = msgs.size();
+        int writeIndex = index;
+        for (;;) {
+            if (writeIndex >= size) {
                 break;
             }
-        }
-    }
-
-    @Override
-    protected void doFlushFileRegion(final FlushTask task) throws Exception {
-        if (javaChannel() instanceof WritableByteChannel) {
-            TransferTask transferTask = new TransferTask(task, (WritableByteChannel) javaChannel());
-            transferTask.transfer();
-        } else {
-            throw new UnsupportedOperationException("Underlying Channel is not of instance "
-                    + WritableByteChannel.class);
-        }
-    }
-
-    private final class TransferTask implements NioTask<SelectableChannel> {
-        private long writtenBytes;
-        private final FlushTask task;
-        private final WritableByteChannel wch;
-
-        TransferTask(FlushTask task, WritableByteChannel wch) {
-            this.task = task;
-            this.wch = wch;
-        }
+            Object msg = msgs.get(writeIndex);
+            if (msg instanceof ByteBuf) {
+                ByteBuf buf = (ByteBuf) msg;
+                if (!buf.isReadable()) {
+                    buf.release();
+                    writeIndex++;
+                    continue;
+                }
+                boolean done = false;
+                for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
+                    int localFlushedAmount = doWriteBytes(buf, i == 0);
+                    if (localFlushedAmount == 0) {
+                        break;
+                    }
 
-        void transfer() {
-            try {
-                for (;;) {
-                    long localWrittenBytes = task.region().transferTo(wch, writtenBytes);
-                    if (localWrittenBytes == 0) {
-                        // reschedule for write once the channel is writable again
-                        eventLoop().executeWhenWritable(
-                                AbstractNioByteChannel.this, this);
-                        return;
-                    } else if (localWrittenBytes == -1) {
-                        checkEOF(task.region(), writtenBytes);
-                        task.setSuccess();
-                        return;
-                    } else {
-                        writtenBytes += localWrittenBytes;
-                        task.setProgress(writtenBytes);
-
-                        if (writtenBytes >= task.region().count()) {
-                            task.setSuccess();
-                            return;
-                        }
+                    if (!buf.isReadable()) {
+                        done = true;
+                        break;
                     }
                 }
-            } catch (Throwable cause) {
-                task.setFailure(cause);
-            }
-        }
 
-        @Override
-        public void channelReady(SelectableChannel ch, SelectionKey key) throws Exception {
-            transfer();
-        }
-
-        @Override
-        public void channelUnregistered(SelectableChannel ch, Throwable cause) throws Exception {
-            if (cause != null) {
-                task.setFailure(cause);
-                return;
-            }
+                if (done) {
+                    buf.release();
+                    writeIndex++;
+                } else {
+                    break;
+                }
+            } else if (msg instanceof FileRegion) {
+                FileRegion region = (FileRegion) msg;
+                boolean done = false;
+                for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
+                    long localFlushedAmount = doWriteFileRegion(region, i == 0);
+                    if (localFlushedAmount == 0) {
+                        break;
+                    }
+                    if (region.transfered() >= region.count()) {
+                        done = true;
+                        break;
+                    }
+                }
 
-            if (writtenBytes < task.region().count()) {
-                if (!isOpen()) {
-                    task.setFailure(new ClosedChannelException());
+                if (done) {
+                    region.release();
+                    writeIndex++;
                 } else {
-                    task.setFailure(new IllegalStateException(
-                            "Channel was unregistered before the region could be fully written"));
+                    break;
                 }
+            } else {
+                throw new UnsupportedOperationException("unsupported message type: " + StringUtil.simpleClassName(msg));
             }
         }
+        return writeIndex - index;
     }
 
+    /**
+     * Write a {@link FileRegion}
+     *
+     * @param region        the {@link FileRegion} from which the bytes should be written
+     * @param lastSpin      {@code true} if this is the last write try
+     * @return amount       the amount of written bytes
+     * @throws Exception    thrown if an error accour
+     */
+    protected abstract long doWriteFileRegion(FileRegion region, boolean lastSpin) throws Exception;
+
     /**
      * Read bytes into the given {@link ByteBuf} and return the amount.
      */
@@ -236,4 +205,26 @@ public void channelUnregistered(SelectableChannel ch, Throwable cause) throws Ex
      */
     protected abstract int doWriteBytes(ByteBuf buf, boolean lastSpin) throws Exception;
 
+    protected final void updateOpWrite(long expectedWrittenBytes, long writtenBytes, boolean lastSpin) {
+        if (writtenBytes >= expectedWrittenBytes) {
+            final SelectionKey key = selectionKey();
+            final int interestOps = key.interestOps();
+            // Wrote the outbound buffer completely - clear OP_WRITE.
+            if ((interestOps & SelectionKey.OP_WRITE) != 0) {
+                key.interestOps(interestOps & ~SelectionKey.OP_WRITE);
+            }
+        } else {
+            // 1) Wrote nothing: buffer is full obviously - set OP_WRITE
+            // 2) Wrote partial data:
+            //    a) lastSpin is false: no need to set OP_WRITE because the caller will try again immediately.
+            //    b) lastSpin is true: set OP_WRITE because the caller will not try again.
+            if (writtenBytes == 0 || lastSpin) {
+                final SelectionKey key = selectionKey();
+                final int interestOps = key.interestOps();
+                if ((interestOps & SelectionKey.OP_WRITE) == 0) {
+                    key.interestOps(interestOps | SelectionKey.OP_WRITE);
+                }
+            }
+        }
+    }
 }
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
index cf8f0896b5e2..ca0204a8460d 100755
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
@@ -18,6 +18,8 @@
 import io.netty.channel.AbstractChannel;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.ConnectTimeoutException;
 import io.netty.channel.EventLoop;
@@ -191,6 +193,19 @@ public void run() {
                             }
                         }, connectTimeoutMillis, TimeUnit.MILLISECONDS);
                     }
+
+                    promise.addListener(new ChannelFutureListener() {
+                        @Override
+                        public void operationComplete(ChannelFuture future) throws Exception {
+                            if (future.isCancelled()) {
+                                if (connectTimeoutFuture != null) {
+                                    connectTimeoutFuture.cancel(false);
+                                }
+                                connectPromise = null;
+                                close(voidPromise());
+                            }
+                        }
+                    });
                 }
             } catch (Throwable t) {
                 if (t instanceof ConnectException) {
@@ -198,15 +213,19 @@ public void run() {
                     newT.setStackTrace(t.getStackTrace());
                     t = newT;
                 }
-                promise.setFailure(t);
                 closeIfClosed();
+                promise.tryFailure(t);
             }
         }
 
         @Override
         public void finishConnect() {
+            // Note this method is invoked by the event loop only if the connection attempt was
+            // neither cancelled nor timed out.
+
             assert eventLoop().inEventLoop();
             assert connectPromise != null;
+
             try {
                 boolean wasActive = isActive();
                 doFinishConnect();
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
index 97f109d082b5..180cf07024e5 100755
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
@@ -15,9 +15,9 @@
  */
 package io.netty.channel.nio;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 
 import java.io.IOException;
 import java.nio.channels.SelectableChannel;
@@ -47,84 +47,81 @@ public void read() {
             assert eventLoop().inEventLoop();
             final SelectionKey key = selectionKey();
             if (!config().isAutoRead()) {
-                // only remove readInterestOp if needed
-                key.interestOps(key.interestOps() & ~readInterestOp);
+                int interestOps = key.interestOps();
+                if ((interestOps & readInterestOp) != 0) {
+                    // only remove readInterestOp if needed
+                    key.interestOps(interestOps & ~readInterestOp);
+                }
             }
 
             final ChannelPipeline pipeline = pipeline();
-            final MessageBuf<Object> msgBuf = pipeline.inboundMessageBuffer();
             boolean closed = false;
-            boolean read = false;
-            boolean firedChannelReadSuspended = false;
-            try {
-                for (;;) {
-                    int localReadAmount = doReadMessages(msgBuf);
-                    if (localReadAmount > 0) {
-                        read = true;
-                    } else if (localReadAmount == 0) {
-                        break;
-                    } else if (localReadAmount < 0) {
-                        closed = true;
-                        break;
+            MessageList<Object> msgBuf = MessageList.newInstance();
+            Throwable exception = null;
+            loop: for (;;) {
+                try {
+                    for (;;) {
+                        int localRead = doReadMessages(msgBuf);
+                        if (localRead == 0) {
+                            break loop;
+                        }
+                        if (localRead < 0) {
+                            closed = true;
+                            break loop;
+                        }
+                        if (!config().isAutoRead()) {
+                            break loop;
+                        }
                     }
+                } catch (Throwable t) {
+                    exception = t;
+                    break;
                 }
-            } catch (Throwable t) {
-                if (read) {
-                    read = false;
-                    pipeline.fireInboundBufferUpdated();
-                }
+            }
+
+            pipeline.fireMessageReceived(msgBuf);
 
-                if (t instanceof IOException) {
+            if (exception != null) {
+                if (exception instanceof IOException) {
                     closed = true;
-                } else if (!closed) {
-                    firedChannelReadSuspended = true;
-                    pipeline.fireChannelReadSuspended();
                 }
 
-                pipeline().fireExceptionCaught(t);
-            } finally {
-                if (read) {
-                    pipeline.fireInboundBufferUpdated();
-                }
-                if (closed && isOpen()) {
+                pipeline().fireExceptionCaught(exception);
+            }
+
+            if (closed) {
+                if (isOpen()) {
                     close(voidPromise());
-                } else if (!firedChannelReadSuspended) {
-                    pipeline.fireChannelReadSuspended();
                 }
+            } else {
+                pipeline.fireChannelReadSuspended();
             }
         }
     }
 
     @Override
-    protected void doFlushMessageBuffer(MessageBuf<Object> buf) throws Exception {
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
         final int writeSpinCount = config().getWriteSpinCount() - 1;
-        while (!buf.isEmpty()) {
-            boolean wrote = false;
-            for (int i = writeSpinCount; i >= 0; i --) {
-                int localFlushedAmount = doWriteMessages(buf, i == 0);
-                if (localFlushedAmount > 0) {
-                    wrote = true;
-                    break;
-                }
-            }
-
-            if (!wrote) {
-                break;
+        for (int i = writeSpinCount; i >= 0; i --) {
+            int written = doWriteMessages(msgs, index, i == 0);
+            if (written > 0) {
+                return written;
             }
         }
+        return 0;
     }
 
     /**
-     * Read messages into the given {@link MessageBuf} and return the amount.
+     * Read messages into the given array and return the amount which was read.
      */
-    protected abstract int doReadMessages(MessageBuf<Object> buf) throws Exception;
+    protected abstract int doReadMessages(MessageList<Object> buf) throws Exception;
 
     /**
-     * Write messages form the given {@link MessageBuf} to the underlying {@link java.nio.channels.Channel}.
-     * @param buf           the {@link MessageBuf} from which the bytes should be written
+     * Write messages to the underlying {@link java.nio.channels.Channel}.
+     * @param msg           Object to write
      * @param lastSpin      {@code true} if this is the last write try
-     * @return amount       the amount of written bytes
+     * @return written      the amount of written messages
      * @throws Exception    thrown if an error accour
      */
-    protected abstract int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws Exception;
+    protected abstract int doWriteMessages(MessageList<Object> msg, int index, boolean lastSpin) throws Exception;
 }
diff --git a/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
index 24188b5521c5..dfd6efd8011c 100644
--- a/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
@@ -26,6 +26,7 @@
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.io.IOException;
+import java.lang.reflect.Field;
 import java.nio.channels.CancelledKeyException;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
@@ -51,6 +52,8 @@ public final class NioEventLoop extends SingleThreadEventLoop {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioEventLoop.class);
 
     private static final int CLEANUP_INTERVAL = 256; // XXX Hard-coded value, but won't need customization.
+    private static final boolean DISABLE_KEYSET_OPTIMIZATION =
+            SystemPropertyUtil.getBoolean("io.netty.noKeySetOptimization", false);
 
     private static final int MIN_PREMATURE_SELECTOR_RETURNS = 3;
     private static final int SELECTOR_AUTO_REBUILD_THRESHOLD;
@@ -81,6 +84,7 @@ public final class NioEventLoop extends SingleThreadEventLoop {
         SELECTOR_AUTO_REBUILD_THRESHOLD = selectorAutoRebuildThreshold;
 
         if (logger.isDebugEnabled()) {
+            logger.debug("io.netty.noKeySetOptimization: {}", DISABLE_KEYSET_OPTIMIZATION);
             logger.debug("io.netty.selectorAutoRebuildThreshold: {}", SELECTOR_AUTO_REBUILD_THRESHOLD);
         }
     }
@@ -89,6 +93,7 @@ public final class NioEventLoop extends SingleThreadEventLoop {
      * The NIO {@link Selector}.
      */
     Selector selector;
+    private SelectedSelectionKeySet selectedKeys;
 
     private final SelectorProvider provider;
 
@@ -115,11 +120,40 @@ public final class NioEventLoop extends SingleThreadEventLoop {
     }
 
     private Selector openSelector() {
+        final Selector selector;
         try {
-            return provider.openSelector();
+            selector = provider.openSelector();
         } catch (IOException e) {
             throw new ChannelException("failed to open a new selector", e);
         }
+
+        if (DISABLE_KEYSET_OPTIMIZATION) {
+            return selector;
+        }
+
+        try {
+            SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();
+
+            Class<?> selectorImplClass =
+                    Class.forName("sun.nio.ch.SelectorImpl", false, ClassLoader.getSystemClassLoader());
+            selectorImplClass.isAssignableFrom(selector.getClass());
+            Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys");
+            Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys");
+
+            selectedKeysField.setAccessible(true);
+            publicSelectedKeysField.setAccessible(true);
+
+            selectedKeysField.set(selector, selectedKeySet);
+            publicSelectedKeysField.set(selector, selectedKeySet);
+
+            selectedKeys = selectedKeySet;
+            logger.trace("Instrumented an optimized java.util.Set into: {}", selector);
+        } catch (Throwable t) {
+            selectedKeys = null;
+            logger.trace("Failed to instrument an optimized java.util.Set into: {}", selector, t);
+        }
+
+        return selector;
     }
 
     @Override
@@ -243,7 +277,7 @@ public void run() {
                         logger.warn("Failed to re-register a Channel to the new Selector.", e);
                         if (a instanceof AbstractNioChannel) {
                             AbstractNioChannel ch = (AbstractNioChannel) a;
-                            ch.unsafe().close(ch.voidPromise());
+                            ch.unsafe().close(ch.unsafe().voidPromise());
                         } else {
                             @SuppressWarnings("unchecked")
                             NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;
@@ -319,7 +353,12 @@ protected void run() {
                 cancelledKeys = 0;
 
                 final long ioStartTime = System.nanoTime();
-                processSelectedKeys();
+                needsToSelectAgain = false;
+                if (selectedKeys != null) {
+                    processSelectedKeysOptimized(selectedKeys.flip());
+                } else {
+                    processSelectedKeysPlain(selector.selectedKeys());
+                }
                 final long ioTime = System.nanoTime() - ioStartTime;
 
                 final int ioRatio = this.ioRatio;
@@ -372,9 +411,7 @@ protected Runnable pollTask() {
         return task;
     }
 
-    private void processSelectedKeys() {
-        needsToSelectAgain = false;
-        Set<SelectionKey> selectedKeys = selector.selectedKeys();
+    private void processSelectedKeysPlain(Set<SelectionKey> selectedKeys) {
         // check if the set is empty and if so just return to not create garbage by
         // creating a new Iterator every time even if there is nothing to process.
         // See https://github.com/netty/netty/issues/597
@@ -414,11 +451,34 @@ private void processSelectedKeys() {
         }
     }
 
+    private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
+        for (int i = 0;; i ++) {
+            final SelectionKey k = selectedKeys[i];
+            if (k == null) {
+                break;
+            }
+
+            final Object a = k.attachment();
+
+            if (a instanceof AbstractNioChannel) {
+                processSelectedKey(k, (AbstractNioChannel) a);
+            } else {
+                @SuppressWarnings("unchecked")
+                NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;
+                processSelectedKey(k, task);
+            }
+
+            if (needsToSelectAgain) {
+                selectAgain();
+            }
+        }
+    }
+
     private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
         final NioUnsafe unsafe = ch.unsafe();
         if (!k.isValid()) {
             // close the channel if the key is not valid anymore
-            unsafe.close(ch.voidPromise());
+            unsafe.close(unsafe.voidPromise());
             return;
         }
 
@@ -448,7 +508,7 @@ private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
             if (readyOps != -1 && (readyOps & SelectionKey.OP_WRITE) != 0) {
                 unregisterWritableTasks(ch);
             }
-            unsafe.close(ch.voidPromise());
+            unsafe.close(unsafe.voidPromise());
         }
     }
 
@@ -518,7 +578,7 @@ private void closeAll() {
 
         for (AbstractNioChannel ch: channels) {
             unregisterWritableTasks(ch);
-            ch.unsafe().close(ch.voidPromise());
+            ch.unsafe().close(ch.unsafe().voidPromise());
         }
     }
 
@@ -583,6 +643,7 @@ private void select() throws IOException {
                             selectCnt);
 
                     rebuildSelector();
+                    selector = this.selector;
 
                     // Select again to populate selectedKeys.
                     selector.selectNow();
diff --git a/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java b/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java
new file mode 100644
index 000000000000..36ed9dafa06e
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.channel.nio;
+
+import java.nio.channels.SelectionKey;
+import java.util.AbstractSet;
+import java.util.Iterator;
+
+final class SelectedSelectionKeySet extends AbstractSet<SelectionKey> {
+
+    private SelectionKey[] keysA;
+    private int keysASize;
+    private SelectionKey[] keysB;
+    private int keysBSize;
+    private boolean isA = true;
+
+    SelectedSelectionKeySet() {
+        keysA = new SelectionKey[1024];
+        keysB = keysA.clone();
+    }
+
+    @Override
+    public boolean add(SelectionKey o) {
+        if (o == null) {
+            return false;
+        }
+
+        if (isA) {
+            int size = keysASize;
+            keysA[size ++] = o;
+            keysASize = size;
+            if (size == keysA.length) {
+                doubleCapacityA();
+            }
+        } else {
+            int size = keysBSize;
+            keysB[size ++] = o;
+            keysBSize = size;
+            if (size == keysB.length) {
+                doubleCapacityB();
+            }
+        }
+
+        return true;
+    }
+
+    private void doubleCapacityA() {
+        SelectionKey[] newKeysA = new SelectionKey[keysA.length << 1];
+        System.arraycopy(keysA, 0, newKeysA, 0, keysASize);
+        keysA = newKeysA;
+    }
+
+    private void doubleCapacityB() {
+        SelectionKey[] newKeysB = new SelectionKey[keysB.length << 1];
+        System.arraycopy(keysB, 0, newKeysB, 0, keysBSize);
+        keysB = newKeysB;
+    }
+
+    SelectionKey[] flip() {
+        if (isA) {
+            isA = false;
+            keysA[keysASize] = null;
+            keysBSize = 0;
+            return keysA;
+        } else {
+            isA = true;
+            keysB[keysBSize] = null;
+            keysASize = 0;
+            return keysB;
+        }
+    }
+
+    @Override
+    public int size() {
+        if (isA) {
+            return keysASize;
+        } else {
+            return keysBSize;
+        }
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return false;
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return false;
+    }
+
+    @Override
+    public Iterator<SelectionKey> iterator() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
index e1e243a26374..70dbf61bd28f 100755
--- a/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
@@ -15,13 +15,15 @@
  */
 package io.netty.channel.oio;
 
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
 import io.netty.channel.socket.ChannelInputShutdownEvent;
+import io.netty.util.internal.StringUtil;
 
 import java.io.IOException;
 
@@ -31,7 +33,7 @@
 public abstract class AbstractOioByteChannel extends AbstractOioChannel {
 
     private volatile boolean inputShutdown;
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     /**
      * @see AbstractOioByteChannel#AbstractOioByteChannel(Channel, Integer)
@@ -72,7 +74,9 @@ protected void doRead() {
         }
 
         final ChannelPipeline pipeline = pipeline();
-        final ByteBuf byteBuf = pipeline.inboundByteBuffer();
+
+        // TODO: calculate size as in 3.x
+        ByteBuf byteBuf = alloc().buffer();
         boolean closed = false;
         boolean read = false;
         boolean firedInboundBufferSuspeneded = false;
@@ -96,12 +100,8 @@ protected void doRead() {
                     if (capacity == maxCapacity) {
                         if (read) {
                             read = false;
-                            pipeline.fireInboundBufferUpdated();
-                            if (!byteBuf.isWritable()) {
-                                throw new IllegalStateException(
-                                        "an inbound handler whose buffer is full must consume at " +
-                                                "least one byte.");
-                            }
+                            pipeline.fireMessageReceived(byteBuf);
+                            byteBuf = alloc().buffer();
                         }
                     } else {
                         final int writerIndex = byteBuf.writerIndex();
@@ -121,7 +121,7 @@ protected void doRead() {
         } catch (Throwable t) {
             if (read) {
                 read = false;
-                pipeline.fireInboundBufferUpdated();
+                pipeline.fireMessageReceived(byteBuf);
             }
 
             if (t instanceof IOException) {
@@ -135,7 +135,10 @@ protected void doRead() {
             }
         } finally {
             if (read) {
-                pipeline.fireInboundBufferUpdated();
+                pipeline.fireMessageReceived(byteBuf);
+            } else {
+                // nothing read into the buffer so release it
+                byteBuf.release();
             }
             if (closed) {
                 inputShutdown = true;
@@ -143,7 +146,7 @@ protected void doRead() {
                     if (Boolean.TRUE.equals(config().getOption(ChannelOption.ALLOW_HALF_CLOSURE))) {
                         pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
                     } else {
-                        unsafe().close(voidPromise());
+                        unsafe().close(unsafe().voidPromise());
                     }
                 }
             } else if (!firedInboundBufferSuspeneded) {
@@ -153,11 +156,31 @@ protected void doRead() {
     }
 
     @Override
-    protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
-        while (buf.isReadable()) {
-            doWriteBytes(buf);
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
+        int size = msgs.size();
+        int writeIndex = index;
+        for (;;) {
+            if (writeIndex >= size) {
+                break;
+            }
+            Object msg = msgs.get(writeIndex);
+            if (msg instanceof ByteBuf) {
+                ByteBuf buf = (ByteBuf) msg;
+                while (buf.isReadable()) {
+                    doWriteBytes(buf);
+                }
+                buf.release();
+                writeIndex++;
+            } else if (msg instanceof FileRegion) {
+                FileRegion region = (FileRegion) msg;
+                doWriteFileRegion(region);
+                region.release();
+                writeIndex++;
+            } else {
+                throw new UnsupportedOperationException("unsupported message type: " + StringUtil.simpleClassName(msg));
+            }
         }
-        buf.clear();
+        return writeIndex - index;
     }
 
     /**
@@ -182,4 +205,12 @@ protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
      * @throws Exception    is thrown if an error accoured
      */
     protected abstract void doWriteBytes(ByteBuf buf) throws Exception;
+
+    /**
+     * Write the data which is hold by the {@link FileRegion} to the underlying Socket.
+     *
+     * @param region        the {@link FileRegion} which holds the data to transfer
+     * @throws Exception    is thrown if an error accoured
+     */
+    protected abstract void doWriteFileRegion(FileRegion region) throws Exception;
 }
diff --git a/transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java b/transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java
index 05d78a7f1b8b..8d36f2b295dd 100644
--- a/transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioChannel.java
@@ -62,6 +62,11 @@ public void connect(
                 return;
             }
 
+            if (!promise.setUncancellable()) {
+                close(voidPromise());
+                return;
+            }
+
             try {
                 boolean wasActive = isActive();
                 doConnect(remoteAddress, localAddress);
@@ -75,8 +80,8 @@ public void connect(
                     newT.setStackTrace(t.getStackTrace());
                     t = newT;
                 }
-                promise.setFailure(t);
                 closeIfClosed();
+                promise.setFailure(t);
             }
         }
     }
diff --git a/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java b/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java
index 3826f8046080..36ae20987b4d 100755
--- a/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java
@@ -15,9 +15,9 @@
  */
 package io.netty.channel.oio;
 
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelPipeline;
+import io.netty.channel.MessageList;
 
 import java.io.IOException;
 
@@ -26,9 +26,6 @@
  */
 public abstract class AbstractOioMessageChannel extends AbstractOioChannel {
 
-    /**
-     * @see AbstractOioChannel#AbstractOioChannel(Channel, Integer)
-     */
     protected AbstractOioMessageChannel(Channel parent, Integer id) {
         super(parent, id);
     }
@@ -36,63 +33,39 @@ protected AbstractOioMessageChannel(Channel parent, Integer id) {
     @Override
     protected void doRead() {
         final ChannelPipeline pipeline = pipeline();
-        final MessageBuf<Object> msgBuf = pipeline.inboundMessageBuffer();
         boolean closed = false;
-        boolean read = false;
-        boolean firedChannelReadSuspended = false;
+        MessageList<Object> msgs = MessageList.newInstance();
+        Throwable exception = null;
         try {
-            int localReadAmount = doReadMessages(msgBuf);
-            if (localReadAmount > 0) {
-                read = true;
-            } else if (localReadAmount < 0) {
+            int localReadAmount = doReadMessages(msgs);
+            if (localReadAmount < 0) {
                 closed = true;
             }
         } catch (Throwable t) {
-            if (read) {
-                read = false;
-                pipeline.fireInboundBufferUpdated();
-            }
-            firedChannelReadSuspended = true;
-            pipeline.fireChannelReadSuspended();
-            pipeline.fireExceptionCaught(t);
-            if (t instanceof IOException) {
-                unsafe().close(voidPromise());
-            }
-        } finally {
-            if (read) {
-                pipeline.fireInboundBufferUpdated();
-            }
-            if (!firedChannelReadSuspended) {
-                pipeline.fireChannelReadSuspended();
-            }
-            if (closed && isOpen()) {
-                unsafe().close(voidPromise());
+            exception = t;
+        }
+
+        pipeline.fireMessageReceived(msgs);
+
+        if (exception != null) {
+            if (exception instanceof IOException) {
+                closed = true;
             }
+
+            pipeline().fireExceptionCaught(exception);
         }
-    }
 
-    @Override
-    protected void doFlushMessageBuffer(MessageBuf<Object> buf) throws Exception {
-        while (!buf.isEmpty()) {
-            doWriteMessages(buf);
+        if (closed) {
+            if (isOpen()) {
+                unsafe().close(unsafe().voidPromise());
+            }
+        } else {
+            pipeline.fireChannelReadSuspended();
         }
     }
 
     /**
-     * Read Objects from the underlying Socket.
-     *
-     * @param buf           the {@link MessageBuf} into which the read objects will be written
-     * @return amount       the number of objects read. This may return a negative amount if the underlying
-     *                      Socket was closed
-     * @throws Exception    is thrown if an error accoured
-     */
-    protected abstract int doReadMessages(MessageBuf<Object> buf) throws Exception;
-
-    /**
-     * Write the Objects which is hold by the {@link MessageBuf} to the underlying Socket.
-     *
-     * @param buf           the {@link MessageBuf} which holds the data to transfer
-     * @throws Exception    is thrown if an error accoured
+     * Read messages into the given array and return the amount which was read.
      */
-    protected abstract void doWriteMessages(MessageBuf<Object> buf) throws Exception;
+    protected abstract int doReadMessages(MessageList<Object> msgs) throws Exception;
 }
diff --git a/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java b/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java
index b71f900348c5..dd0d3ab29401 100644
--- a/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
+import io.netty.channel.FileRegion;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -95,7 +96,7 @@ protected void doWriteBytes(ByteBuf buf) throws Exception {
     }
 
     @Override
-    protected void doFlushFileRegion(FlushTask task) throws Exception {
+    protected void doWriteFileRegion(FileRegion region) throws Exception {
         OutputStream os = this.os;
         if (os == null) {
             throw new NotYetConnectedException();
@@ -106,17 +107,14 @@ protected void doFlushFileRegion(FlushTask task) throws Exception {
 
         long written = 0;
         for (;;) {
-            long localWritten = task.region().transferTo(outChannel, written);
+            long localWritten = region.transferTo(outChannel, written);
             if (localWritten == -1) {
-                checkEOF(task.region(), written);
-                task.setSuccess();
+                checkEOF(region);
                 return;
             }
             written += localWritten;
-            task.setProgress(written);
 
-            if (written >= task.region().count()) {
-                task.setSuccess();
+            if (written >= region.count()) {
                 return;
             }
         }
diff --git a/transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java b/transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java
index 9d98ab16e12b..40ed4140b594 100644
--- a/transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java
+++ b/transport/src/main/java/io/netty/channel/socket/ChannelInputShutdownEvent.java
@@ -16,11 +16,11 @@
 package io.netty.channel.socket;
 
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelStateHandler;
+import io.netty.channel.ChannelInboundHandler;
 
 /**
  * Special event which will be fired and passed to the
- * {@link ChannelStateHandler#userEventTriggered(ChannelHandlerContext, Object)} methods once the input of
+ * {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)} methods once the input of
  * a {@link SocketChannel} was shutdown and the {@link SocketChannelConfig#isAllowHalfClosure()} method returns
  * {@code true}.
  */
diff --git a/transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java
index 3ab48b8aebbe..a626712376f4 100644
--- a/transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
 
 import java.net.InetAddress;
 import java.net.NetworkInterface;
@@ -54,8 +55,6 @@
  * <td>{@link ChannelOption#IP_MULTICAST_TTL}</td><td>{@link #setTimeToLive(int)}</td>
  * </tr><tr>
  * <td>{@link ChannelOption#IP_TOS}</td><td>{@link #setTrafficClass(int)}</td>
- * </tr><tr>
- * <td>{@link ChannelOption#UDP_RECEIVE_PACKET_SIZE}</td><td>{@link #setReceivePacketSize(int)}</td>
  * </tr>
  * </table>
  */
@@ -81,18 +80,6 @@ public interface DatagramChannelConfig extends ChannelConfig {
      */
     DatagramChannelConfig setReceiveBufferSize(int receiveBufferSize);
 
-    /**
-     * Gets the size of the {@link DatagramPacket#data()} which will be used to store the received data.
-     * This should match the maximal packet size that you expect to receive.
-     */
-    int getReceivePacketSize();
-
-    /**
-     * Sets the size of the {@link DatagramPacket#data()} which will be used to store the received data.
-     * This should match the maximal packet size that you expect to receive.
-     */
-    DatagramChannelConfig setReceivePacketSize(int receivePacketSize);
-
     /**
      * Gets the {@link StandardSocketOptions#IP_TOS} option.
      */
@@ -178,8 +165,8 @@ public interface DatagramChannelConfig extends ChannelConfig {
     DatagramChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    DatagramChannelConfig setAutoRead(boolean autoRead);
+    DatagramChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    DatagramChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    DatagramChannelConfig setAutoRead(boolean autoRead);
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
index 559a70c74c7b..a542754a0ed7 100644
--- a/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java
@@ -16,10 +16,11 @@
 package io.netty.channel.socket;
 
 import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.FixedRecvByteBufAllocator;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -41,10 +42,9 @@ public class DefaultDatagramChannelConfig extends DefaultChannelConfig implement
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultDatagramChannelConfig.class);
 
-    private static final int DEFAULT_RECEIVE_PACKET_SIZE = 2048;
+    private static final RecvByteBufAllocator DEFAULT_RCVBUF_ALLOCATOR = new FixedRecvByteBufAllocator(2048);
 
     private final DatagramSocket javaSocket;
-    private volatile int receivePacketSize = DEFAULT_RECEIVE_PACKET_SIZE;
 
     /**
      * Creates a new instance.
@@ -55,6 +55,7 @@ public DefaultDatagramChannelConfig(DatagramChannel channel, DatagramSocket java
             throw new NullPointerException("javaSocket");
         }
         this.javaSocket = javaSocket;
+        setRecvByteBufAllocator(DEFAULT_RCVBUF_ALLOCATOR);
     }
 
     @Override
@@ -62,7 +63,7 @@ public Map<ChannelOption<?>, Object> getOptions() {
         return getOptions(
                 super.getOptions(),
                 SO_BROADCAST, SO_RCVBUF, SO_SNDBUF, SO_REUSEADDR, IP_MULTICAST_LOOP_DISABLED,
-                IP_MULTICAST_ADDR, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_TOS, UDP_RECEIVE_PACKET_SIZE);
+                IP_MULTICAST_ADDR, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_TOS);
     }
 
     @SuppressWarnings("unchecked")
@@ -77,9 +78,6 @@ public <T> T getOption(ChannelOption<T> option) {
         if (option == SO_SNDBUF) {
             return (T) Integer.valueOf(getSendBufferSize());
         }
-        if (option == UDP_RECEIVE_PACKET_SIZE) {
-            return (T) Integer.valueOf(getReceivePacketSize());
-        }
         if (option == SO_REUSEADDR) {
             return (T) Boolean.valueOf(isReuseAddress());
         }
@@ -126,8 +124,6 @@ public <T> boolean setOption(ChannelOption<T> option, T value) {
             setTimeToLive((Integer) value);
         } else if (option == IP_TOS) {
             setTrafficClass((Integer) value);
-        } else if (option == UDP_RECEIVE_PACKET_SIZE) {
-            setReceivePacketSize((Integer) value);
         } else {
             return super.setOption(option, value);
         }
@@ -305,21 +301,6 @@ public DatagramChannelConfig setSendBufferSize(int sendBufferSize) {
         return this;
     }
 
-    @Override
-    public int getReceivePacketSize() {
-        return receivePacketSize;
-    }
-
-    @Override
-    public DatagramChannelConfig setReceivePacketSize(int receivePacketSize) {
-        if (receivePacketSize <= 0) {
-            throw new IllegalArgumentException(
-                    String.format("receivePacketSize: %d (expected: > 0)", receivePacketSize));
-        }
-        this.receivePacketSize = receivePacketSize;
-        return this;
-    }
-
     @Override
     public int getTimeToLive() {
         if (javaSocket instanceof MulticastSocket) {
@@ -381,13 +362,24 @@ public DatagramChannelConfig setAllocator(ByteBufAllocator allocator) {
         return (DatagramChannelConfig) super.setAllocator(allocator);
     }
 
+    @Override
+    public DatagramChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
     @Override
     public DatagramChannelConfig setAutoRead(boolean autoRead) {
         return (DatagramChannelConfig) super.setAutoRead(autoRead);
     }
 
     @Override
-    public DatagramChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        return (DatagramChannelConfig) super.setDefaultHandlerByteBufType(type);
+    public DatagramChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        return (DatagramChannelConfig) super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
+    }
+
+    @Override
+    public DatagramChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        return (DatagramChannelConfig) super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java
index e97752bf0dc1..02a92e89bfbb 100644
--- a/transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.util.NetUtil;
 
 import java.net.ServerSocket;
@@ -158,13 +159,24 @@ public ServerSocketChannelConfig setAllocator(ByteBufAllocator allocator) {
         return (ServerSocketChannelConfig) super.setAllocator(allocator);
     }
 
+    @Override
+    public ServerSocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
     @Override
     public ServerSocketChannelConfig setAutoRead(boolean autoRead) {
         return (ServerSocketChannelConfig) super.setAutoRead(autoRead);
     }
 
     @Override
-    public ServerSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        return (ServerSocketChannelConfig) super.setDefaultHandlerByteBufType(type);
+    public ServerSocketChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        return (ServerSocketChannelConfig) super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
+    }
+
+    @Override
+    public ServerSocketChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        return (ServerSocketChannelConfig) super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/DefaultSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/DefaultSocketChannelConfig.java
index bbe14c825bfb..62cefb889909 100644
--- a/transport/src/main/java/io/netty/channel/socket/DefaultSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/DefaultSocketChannelConfig.java
@@ -20,6 +20,7 @@
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.util.internal.PlatformDependent;
 
 import java.net.Socket;
@@ -293,13 +294,24 @@ public SocketChannelConfig setAllocator(ByteBufAllocator allocator) {
         return (SocketChannelConfig) super.setAllocator(allocator);
     }
 
+    @Override
+    public SocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
+        return this;
+    }
+
     @Override
     public SocketChannelConfig setAutoRead(boolean autoRead) {
         return (SocketChannelConfig) super.setAutoRead(autoRead);
     }
 
     @Override
-    public SocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        return (SocketChannelConfig) super.setDefaultHandlerByteBufType(type);
+    public SocketChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark) {
+        return (SocketChannelConfig) super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);
+    }
+
+    @Override
+    public SocketChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark) {
+        return (SocketChannelConfig) super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java
index 95c5ecc378fe..d9cf203ad19d 100644
--- a/transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/ServerSocketChannelConfig.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
+import io.netty.channel.RecvByteBufAllocator;
 
 import java.net.ServerSocket;
 import java.net.StandardSocketOptions;
@@ -92,8 +93,8 @@ public interface ServerSocketChannelConfig extends ChannelConfig {
     ServerSocketChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    ServerSocketChannelConfig setAutoRead(boolean autoRead);
+    ServerSocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    ServerSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    ServerSocketChannelConfig setAutoRead(boolean autoRead);
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
index 8dc827324a23..1a0aa2a8d011 100644
--- a/transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java
@@ -18,8 +18,9 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandler;
 import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelStateHandler;
+import io.netty.channel.RecvByteBufAllocator;
 
 import java.net.Socket;
 import java.net.StandardSocketOptions;
@@ -149,7 +150,7 @@ public interface SocketChannelConfig extends ChannelConfig {
      * Sets whether the channel should not close itself when its remote peer shuts down output to
      * make the connection half-closed.  If {@code true} the connection is not closed when the
      * remote peer shuts down output. Instead,
-     * {@link ChannelStateHandler#userEventTriggered(ChannelHandlerContext, Object)}
+     * {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}
      * is invoked with a {@link ChannelInputShutdownEvent} object. If {@code false}, the connection
      * is closed automatically.
      */
@@ -165,8 +166,8 @@ public interface SocketChannelConfig extends ChannelConfig {
     SocketChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    SocketChannelConfig setAutoRead(boolean autoRead);
+    SocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    SocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    SocketChannelConfig setAutoRead(boolean autoRead);
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java
deleted file mode 100755
index 89a6e9936581..000000000000
--- a/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.socket.aio;
-
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
-import io.netty.channel.ChannelException;
-import io.netty.channel.ChannelMetadata;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelPromise;
-import io.netty.channel.EventLoop;
-import io.netty.channel.aio.AbstractAioChannel;
-import io.netty.channel.aio.AioCompletionHandler;
-import io.netty.channel.aio.AioEventLoopGroup;
-import io.netty.channel.socket.ServerSocketChannel;
-import io.netty.channel.socket.ServerSocketChannelConfig;
-import io.netty.util.internal.logging.InternalLogger;
-import io.netty.util.internal.logging.InternalLoggerFactory;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.nio.channels.AsynchronousChannelGroup;
-import java.nio.channels.AsynchronousCloseException;
-import java.nio.channels.AsynchronousServerSocketChannel;
-import java.nio.channels.AsynchronousSocketChannel;
-
-/**
- * {@link ServerSocketChannel} implementation which uses NIO2.
- *
- * NIO2 is only supported on Java 7+.
- */
-public class AioServerSocketChannel extends AbstractAioChannel implements ServerSocketChannel {
-
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
-
-    private static final AcceptHandler ACCEPT_HANDLER = new AcceptHandler();
-    private static final InternalLogger logger =
-            InternalLoggerFactory.getInstance(AioServerSocketChannel.class);
-
-    private final AioServerSocketChannelConfig config;
-    private boolean acceptInProgress;
-    private boolean closed;
-
-    private static AsynchronousServerSocketChannel newSocket(AsynchronousChannelGroup group) {
-        try {
-            return AsynchronousServerSocketChannel.open(group);
-        } catch (IOException e) {
-            throw new ChannelException("Failed to open a socket.", e);
-        }
-    }
-
-    /**
-     * Create a new instance which has not yet attached an {@link AsynchronousServerSocketChannel}. The
-     * {@link AsynchronousServerSocketChannel} will be attached after it was this instance was registered to an
-     * {@link EventLoop}.
-     */
-    public AioServerSocketChannel() {
-        super(null, null, null);
-        config = new AioServerSocketChannelConfig(this);
-    }
-
-    /**
-     * Create a new instance from the given {@link AsynchronousServerSocketChannel}.
-     *
-     * @param channel    the {@link AsynchronousServerSocketChannel} which is used by this instance
-     */
-    public AioServerSocketChannel(AsynchronousServerSocketChannel channel) {
-        super(null, null, channel);
-        config = new AioServerSocketChannelConfig(this, channel);
-    }
-
-    @Override
-    public InetSocketAddress localAddress() {
-        return (InetSocketAddress) super.localAddress();
-    }
-
-    @Override
-    public InetSocketAddress remoteAddress() {
-        return (InetSocketAddress) super.remoteAddress();
-    }
-
-    @Override
-    protected AsynchronousServerSocketChannel javaChannel() {
-        return (AsynchronousServerSocketChannel) super.javaChannel();
-    }
-
-    @Override
-    public boolean isActive() {
-        return ch != null && javaChannel().isOpen() && localAddress0() != null;
-    }
-
-    @Override
-    public ChannelMetadata metadata() {
-        return METADATA;
-    }
-
-    @Override
-    protected SocketAddress localAddress0() {
-        if (ch == null) {
-            return null;
-        }
-        try {
-            return javaChannel().getLocalAddress();
-        } catch (IOException e) {
-            throw new ChannelException(e);
-        }
-    }
-
-    @Override
-    protected SocketAddress remoteAddress0() {
-        return null;
-    }
-
-    @Override
-    protected void doBind(SocketAddress localAddress) throws Exception {
-        AsynchronousServerSocketChannel ch = javaChannel();
-        ch.bind(localAddress, config.getBacklog());
-    }
-
-    @Override
-    protected void doBeginRead() {
-        if (acceptInProgress) {
-            return;
-        }
-
-        acceptInProgress = true;
-        javaChannel().accept(this, ACCEPT_HANDLER);
-    }
-
-    @Override
-    protected void doClose() throws Exception {
-        if (!closed) {
-            closed = true;
-            javaChannel().close();
-        }
-    }
-
-    @Override
-    protected boolean isFlushPending() {
-        return false;
-    }
-
-    @Override
-    protected void doConnect(
-            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
-        promise.setFailure(new UnsupportedOperationException());
-    }
-
-    @Override
-    protected void doDisconnect() throws Exception {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    protected Runnable doRegister() throws Exception {
-        Runnable task = super.doRegister();
-        if (ch == null) {
-            AsynchronousServerSocketChannel channel =
-                    newSocket(((AioEventLoopGroup) eventLoop().parent()).channelGroup());
-            ch = channel;
-            config.assign(channel);
-        }
-        return task;
-    }
-
-    private static final class AcceptHandler
-            extends AioCompletionHandler<AsynchronousSocketChannel, AioServerSocketChannel> {
-
-        @Override
-        protected void completed0(AsynchronousSocketChannel ch, AioServerSocketChannel channel) {
-            channel.acceptInProgress = false;
-
-            ChannelPipeline pipeline = channel.pipeline();
-            MessageBuf<Object> buffer = pipeline.inboundMessageBuffer();
-
-            if (buffer.refCnt() == 0) {
-                try {
-                    ch.close();
-                } catch (IOException e) {
-                    logger.warn(
-                            "Failed to close a socket which was accepted while its server socket is being closed",
-                            e);
-                }
-                return;
-            }
-
-            // create the socket add it to the buffer and fire the event
-            buffer.add(new AioSocketChannel(channel, null, ch));
-            pipeline.fireInboundBufferUpdated();
-            pipeline.fireChannelReadSuspended();
-        }
-
-        @Override
-        protected void failed0(Throwable t, AioServerSocketChannel channel) {
-            channel.acceptInProgress = false;
-            boolean asyncClosed = false;
-            if (t instanceof AsynchronousCloseException) {
-                asyncClosed = true;
-                channel.closed = true;
-            }
-            // check if the exception was thrown because the channel was closed before
-            // log something
-            if (channel.isOpen() && ! asyncClosed) {
-                logger.warn("Failed to create a new channel from an accepted socket.", t);
-                channel.pipeline().fireExceptionCaught(t);
-            }
-        }
-    }
-
-    @Override
-    public ServerSocketChannelConfig config() {
-        return config;
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java
deleted file mode 100644
index be909e8affbe..000000000000
--- a/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java
+++ /dev/null
@@ -1,232 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.socket.aio;
-
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.ChannelException;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.DefaultChannelConfig;
-import io.netty.channel.socket.ServerSocketChannelConfig;
-import io.netty.util.NetUtil;
-import io.netty.util.internal.PlatformDependent;
-
-import java.io.IOException;
-import java.net.SocketOption;
-import java.net.StandardSocketOptions;
-import java.nio.channels.AsynchronousServerSocketChannel;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static io.netty.channel.ChannelOption.*;
-
-/**
- * The Async {@link ServerSocketChannelConfig} implementation.
- */
-final class AioServerSocketChannelConfig extends DefaultChannelConfig implements ServerSocketChannelConfig {
-
-    private final AtomicReference<AsynchronousServerSocketChannel> javaChannel
-            = new AtomicReference<AsynchronousServerSocketChannel>();
-    private volatile int backlog = NetUtil.SOMAXCONN;
-    private Map<SocketOption<?>, Object> options = PlatformDependent.newConcurrentHashMap();
-    private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;
-    private static final boolean DEFAULT_SO_REUSEADDR = false;
-
-    /**
-     * Creates a new instance with no {@link AsynchronousServerSocketChannel} assigned to it.
-     *
-     * You should call {@link #assign(AsynchronousServerSocketChannel)} to assign a
-     * {@link AsynchronousServerSocketChannel} to it and have the configuration set on it.
-     */
-    AioServerSocketChannelConfig(AioServerSocketChannel channel) {
-        super(channel);
-    }
-
-    /**
-     * Creates a new instance with the given {@link AsynchronousServerSocketChannel} assigned to it.
-     */
-    AioServerSocketChannelConfig(AioServerSocketChannel channel, AsynchronousServerSocketChannel javaChannel) {
-        super(channel);
-        this.javaChannel.set(javaChannel);
-    }
-
-    @Override
-    public Map<ChannelOption<?>, Object> getOptions() {
-        return getOptions(super.getOptions(), SO_RCVBUF, SO_REUSEADDR, SO_BACKLOG);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public <T> T getOption(ChannelOption<T> option) {
-        if (option == SO_RCVBUF) {
-            return (T) Integer.valueOf(getReceiveBufferSize());
-        }
-        if (option == SO_REUSEADDR) {
-            return (T) Boolean.valueOf(isReuseAddress());
-        }
-        if (option == SO_BACKLOG) {
-            return (T) Integer.valueOf(getBacklog());
-        }
-
-        return super.getOption(option);
-    }
-
-    @Override
-    public <T> boolean setOption(ChannelOption<T> option, T value) {
-        validate(option, value);
-
-        if (option == SO_RCVBUF) {
-            setReceiveBufferSize((Integer) value);
-        } else if (option == SO_REUSEADDR) {
-            setReuseAddress((Boolean) value);
-        } else if (option == SO_BACKLOG) {
-            setBacklog((Integer) value);
-        } else {
-            return super.setOption(option, value);
-        }
-
-        return true;
-    }
-
-    @Override
-    public boolean isReuseAddress() {
-        return (Boolean) getOption(StandardSocketOptions.SO_REUSEADDR, DEFAULT_SO_REUSEADDR);
-    }
-
-    @Override
-    public AioServerSocketChannelConfig setReuseAddress(boolean reuseAddress) {
-        setOption(StandardSocketOptions.SO_REUSEADDR, reuseAddress);
-        return this;
-    }
-
-    @Override
-    public int getReceiveBufferSize() {
-        return (Integer) getOption(StandardSocketOptions.SO_RCVBUF, DEFAULT_SND_BUF_SIZE);
-    }
-
-    @Override
-    public AioServerSocketChannelConfig setReceiveBufferSize(int receiveBufferSize) {
-        setOption(StandardSocketOptions.SO_RCVBUF, receiveBufferSize);
-        return this;
-    }
-
-    @Override
-    public AioServerSocketChannelConfig setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getBacklog() {
-        return backlog;
-    }
-
-    @Override
-    public AioServerSocketChannelConfig setBacklog(int backlog) {
-        if (backlog < 0) {
-            throw new IllegalArgumentException("backlog: " + backlog);
-        }
-        this.backlog = backlog;
-        return this;
-    }
-
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private Object getOption(SocketOption option, Object defaultValue) {
-        if (javaChannel.get() == null) {
-            Object value = options.get(option);
-            if (value == null) {
-                return defaultValue;
-            } else {
-                return value;
-            }
-        }
-
-        try {
-            return javaChannel.get().getOption(option);
-        } catch (IOException e) {
-            throw new ChannelException(e);
-        }
-    }
-
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private void setOption(SocketOption option, Object defaultValue) {
-        if (javaChannel.get() == null) {
-            options.put(option, defaultValue);
-            return;
-        }
-        try {
-            javaChannel.get().setOption(option, defaultValue);
-        } catch (IOException e) {
-            throw new ChannelException(e);
-        }
-    }
-
-    /**
-     * Assing the given {@link AsynchronousServerSocketChannel} to this instance
-     */
-    void assign(AsynchronousServerSocketChannel javaChannel) {
-        if (javaChannel == null) {
-            throw new NullPointerException("javaChannel");
-        }
-        if (this.javaChannel.compareAndSet(null, javaChannel)) {
-            propagateOptions();
-        }
-    }
-
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private void propagateOptions() {
-        for (SocketOption option: options.keySet()) {
-            Object value = options.remove(option);
-            if (value != null) {
-                try {
-                    javaChannel.get().setOption(option, value);
-                } catch (IOException e) {
-                    throw new ChannelException(e);
-                }
-            }
-        }
-        // not needed anymore
-        options = null;
-    }
-
-    @Override
-    public AioServerSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
-        super.setConnectTimeoutMillis(connectTimeoutMillis);
-        return this;
-    }
-
-    @Override
-    public AioServerSocketChannelConfig setWriteSpinCount(int writeSpinCount) {
-        super.setWriteSpinCount(writeSpinCount);
-        return this;
-    }
-
-    @Override
-    public AioServerSocketChannelConfig setAllocator(ByteBufAllocator allocator) {
-        super.setAllocator(allocator);
-        return this;
-    }
-
-    @Override
-    public AioServerSocketChannelConfig setAutoRead(boolean autoRead) {
-        super.setAutoRead(autoRead);
-        return this;
-    }
-
-    @Override
-    public ServerSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        super.setDefaultHandlerByteBufType(type);
-        return this;
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
deleted file mode 100755
index c954eaf1763e..000000000000
--- a/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java
+++ /dev/null
@@ -1,597 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.socket.aio;
-
-import io.netty.buffer.BufType;
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelException;
-import io.netty.channel.ChannelFlushPromiseNotifier;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelMetadata;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.ChannelPromise;
-import io.netty.channel.EventLoop;
-import io.netty.channel.aio.AbstractAioChannel;
-import io.netty.channel.aio.AioCompletionHandler;
-import io.netty.channel.aio.AioEventLoopGroup;
-import io.netty.channel.socket.ChannelInputShutdownEvent;
-import io.netty.channel.socket.ServerSocketChannel;
-import io.netty.channel.socket.SocketChannel;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.AsynchronousChannelGroup;
-import java.nio.channels.AsynchronousSocketChannel;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.CompletionHandler;
-import java.nio.channels.InterruptedByTimeoutException;
-import java.nio.channels.WritableByteChannel;
-import java.util.concurrent.TimeUnit;
-
-
-/**
- * {@link SocketChannel} implementation which uses NIO2.
- *
- * NIO2 is only supported on Java 7+.
- */
-public class AioSocketChannel extends AbstractAioChannel implements SocketChannel {
-
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);
-
-    private static final CompletionHandler<Void, AioSocketChannel> CONNECT_HANDLER  = new ConnectHandler();
-    private static final CompletionHandler<Integer, AioSocketChannel> WRITE_HANDLER = new WriteHandler<Integer>();
-    private static final CompletionHandler<Integer, AioSocketChannel> READ_HANDLER = new ReadHandler<Integer>();
-    private static final CompletionHandler<Long, AioSocketChannel> GATHERING_WRITE_HANDLER = new WriteHandler<Long>();
-    private static final CompletionHandler<Long, AioSocketChannel> SCATTERING_READ_HANDLER = new ReadHandler<Long>();
-
-    private static AsynchronousSocketChannel newSocket(AsynchronousChannelGroup group) {
-        try {
-            return AsynchronousSocketChannel.open(group);
-        } catch (IOException e) {
-            throw new ChannelException("Failed to open a socket.", e);
-        }
-    }
-
-    private final DefaultAioSocketChannelConfig config;
-    private volatile boolean inputShutdown;
-    private volatile boolean outputShutdown;
-
-    private boolean readInProgress;
-    private boolean inDoBeginRead;
-    private boolean readAgain;
-
-    private static final int NO_WRITE_IN_PROGRESS = 0;
-    private static final int WRITE_IN_PROGRESS = 1;
-    private static final int WRITE_FAILED = -2;
-
-    private int writeInProgress;
-    private boolean inDoFlushByteBuffer;
-
-    /**
-     * Create a new instance which has not yet attached an {@link AsynchronousSocketChannel}. The
-     * {@link AsynchronousSocketChannel} will be attached after it was this instance was registered to an
-     * {@link EventLoop}.
-     */
-    public AioSocketChannel() {
-        this(null, null, null);
-    }
-
-    /**
-     * Create a new instance from the given {@link AsynchronousSocketChannel}.
-     *
-     * @param parent
-     *        the parent of this channel. {@code null} if there's no parent.
-     * @param id
-     *        the unique non-negative integer ID of this channel.
-     *        Specify {@code null} to auto-generate a unique negative integer
-     *        ID.
-     * @param ch
-     *        the {@link AsynchronousSocketChannel} which is used by this instance
-     */
-    AioSocketChannel(
-            AioServerSocketChannel parent, Integer id, AsynchronousSocketChannel ch) {
-        super(parent, id, ch);
-        config = new DefaultAioSocketChannelConfig(this, ch);
-    }
-
-    @Override
-    public InetSocketAddress localAddress() {
-        return (InetSocketAddress) super.localAddress();
-    }
-
-    @Override
-    public InetSocketAddress remoteAddress() {
-        return (InetSocketAddress) super.remoteAddress();
-    }
-
-    @Override
-    public ServerSocketChannel parent() {
-        return (ServerSocketChannel) super.parent();
-    }
-
-    @Override
-    public boolean isActive() {
-        return ch != null && javaChannel().isOpen() && remoteAddress0() != null;
-    }
-
-    @Override
-    protected AsynchronousSocketChannel javaChannel() {
-        return (AsynchronousSocketChannel) super.javaChannel();
-    }
-
-    @Override
-    public ChannelMetadata metadata() {
-        return METADATA;
-    }
-
-    @Override
-    public boolean isInputShutdown() {
-        return inputShutdown;
-    }
-
-    @Override
-    public boolean isOutputShutdown() {
-        return outputShutdown;
-    }
-
-    @Override
-    public ChannelFuture shutdownOutput() {
-        return shutdownOutput(newPromise());
-    }
-
-    @Override
-    public ChannelFuture shutdownOutput(final ChannelPromise promise) {
-        EventLoop loop = eventLoop();
-        if (loop.inEventLoop()) {
-            try {
-                javaChannel().shutdownOutput();
-                outputShutdown = true;
-                promise.setSuccess();
-            } catch (Throwable t) {
-                promise.setFailure(t);
-            }
-        } else {
-            loop.execute(new Runnable() {
-                @Override
-                public void run() {
-                    shutdownOutput(promise);
-                }
-            });
-        }
-        return promise;
-    }
-
-    @Override
-    protected void doConnect(SocketAddress remoteAddress, SocketAddress localAddress, final ChannelPromise promise) {
-        if (localAddress != null) {
-            try {
-                javaChannel().bind(localAddress);
-            } catch (IOException e) {
-                promise.setFailure(e);
-                return;
-            }
-        }
-
-        javaChannel().connect(remoteAddress, this, CONNECT_HANDLER);
-    }
-
-    @Override
-    protected InetSocketAddress localAddress0() {
-        if (ch == null) {
-            return null;
-        }
-        try {
-            return (InetSocketAddress) javaChannel().getLocalAddress();
-        } catch (IOException e) {
-            return null;
-        }
-    }
-
-    @Override
-    protected InetSocketAddress remoteAddress0() {
-        if (ch == null) {
-            return null;
-        }
-        try {
-            return (InetSocketAddress) javaChannel().getRemoteAddress();
-        } catch (IOException e) {
-            return null;
-        }
-    }
-
-    @Override
-    protected Runnable doRegister() throws Exception {
-        super.doRegister();
-        if (ch == null) {
-            ch = newSocket(((AioEventLoopGroup) eventLoop().parent()).channelGroup());
-            config.assign(javaChannel());
-        }
-
-        return null;
-    }
-
-    @Override
-    protected void doBind(SocketAddress localAddress) throws Exception {
-        javaChannel().bind(localAddress);
-    }
-
-    @Override
-    protected void doDisconnect() throws Exception {
-        doClose();
-    }
-
-    @Override
-    protected void doClose() throws Exception {
-        javaChannel().close();
-        inputShutdown = true;
-        outputShutdown = true;
-    }
-
-    @Override
-    protected boolean isFlushPending() {
-        return false;
-    }
-
-    @Override
-    protected void doFlushByteBuffer(ByteBuf buf) throws Exception {
-        if (inDoFlushByteBuffer || writeInProgress != NO_WRITE_IN_PROGRESS) {
-            return;
-        }
-
-        inDoFlushByteBuffer = true;
-
-        try {
-            if (buf.isReadable()) {
-                for (;;) {
-                    if (buf.refCnt() == 0) {
-                        break;
-                    }
-                    // Ensure the readerIndex of the buffer is 0 before beginning an async write.
-                    // Otherwise, JDK can write into a wrong region of the buffer when a handler calls
-                    // discardReadBytes() later, modifying the readerIndex and the writerIndex unexpectedly.
-                    buf.discardReadBytes();
-
-                    writeInProgress = WRITE_IN_PROGRESS;
-                    if (buf.nioBufferCount() == 1) {
-                        javaChannel().write(
-                                buf.nioBuffer(), config.getWriteTimeout(), TimeUnit.MILLISECONDS, this, WRITE_HANDLER);
-                    } else {
-                        ByteBuffer[] buffers = buf.nioBuffers(buf.readerIndex(), buf.readableBytes());
-                        if (buffers.length == 1) {
-                            javaChannel().write(
-                                    buffers[0], config.getWriteTimeout(), TimeUnit.MILLISECONDS, this, WRITE_HANDLER);
-                        } else {
-                            javaChannel().write(
-                                    buffers, 0, buffers.length, config.getWriteTimeout(), TimeUnit.MILLISECONDS,
-                                    this, GATHERING_WRITE_HANDLER);
-                        }
-                    }
-
-                    if (writeInProgress != NO_WRITE_IN_PROGRESS) {
-                        if (writeInProgress == WRITE_FAILED) {
-                            // failed because of an exception so reset state and break out of the loop now
-                            // See #1242
-                            writeInProgress = NO_WRITE_IN_PROGRESS;
-                            break;
-                        }
-                        // JDK decided to write data (or notify handler) later.
-                        buf.suspendIntermediaryDeallocations();
-                        break;
-                    }
-
-                    // JDK performed the write operation immediately and notified the handler.
-                    // We know this because we set asyncWriteInProgress to false in the handler.
-                    if (!buf.isReadable()) {
-                        // There's nothing left in the buffer. No need to retry writing.
-                        break;
-                    }
-
-                    // There's more to write. Continue the loop.
-                }
-            } else {
-                flushFutureNotifier.notifyFlushFutures();
-            }
-        } finally {
-            inDoFlushByteBuffer = false;
-        }
-    }
-
-    @Override
-    protected void doFlushFileRegion(FlushTask task) throws Exception {
-        task.region().transferTo(new WritableByteChannelAdapter(task), 0);
-    }
-
-    @Override
-    protected void doBeginRead() {
-        if (inDoBeginRead) {
-            readAgain = true;
-            return;
-        }
-
-        if (readInProgress || inputShutdown) {
-            return;
-        }
-
-        inDoBeginRead = true;
-        try {
-            for (;;) {
-                if (inputShutdown) {
-                    break;
-                }
-
-                ByteBuf byteBuf = pipeline().inboundByteBuffer();
-                expandReadBuffer(byteBuf);
-
-                readInProgress = true;
-                if (byteBuf.nioBufferCount() == 1) {
-                    // Get a ByteBuffer view on the ByteBuf
-                    ByteBuffer buffer = byteBuf.nioBuffer(byteBuf.writerIndex(), byteBuf.writableBytes());
-                    javaChannel().read(
-                            buffer, config.getReadTimeout(), TimeUnit.MILLISECONDS, this, READ_HANDLER);
-                } else {
-                    ByteBuffer[] buffers = byteBuf.nioBuffers(byteBuf.writerIndex(), byteBuf.writableBytes());
-                    if (buffers.length == 1) {
-                        javaChannel().read(
-                                buffers[0], config.getReadTimeout(), TimeUnit.MILLISECONDS, this, READ_HANDLER);
-                    } else {
-                        javaChannel().read(
-                                buffers, 0, buffers.length, config.getReadTimeout(), TimeUnit.MILLISECONDS,
-                                this, SCATTERING_READ_HANDLER);
-                    }
-                }
-
-                if (readInProgress) {
-                    // JDK decided to read data (or notify handler) later.
-                    break;
-                }
-
-                if (readAgain) {
-                    // User requested the read operation.
-                    readAgain = false;
-                    continue;
-                }
-
-                break;
-            }
-        } finally {
-            inDoBeginRead = false;
-        }
-    }
-
-    private static final class WriteHandler<T extends Number> extends AioCompletionHandler<T, AioSocketChannel> {
-
-        @Override
-        protected void completed0(T result, AioSocketChannel channel) {
-            channel.writeInProgress = NO_WRITE_IN_PROGRESS;
-
-            ByteBuf buf = channel.unsafe().headContext().outboundByteBuffer();
-            if (buf.refCnt() == 0) {
-                return;
-            }
-
-            buf.resumeIntermediaryDeallocations();
-
-            int writtenBytes = result.intValue();
-            if (writtenBytes > 0) {
-                // Update the readerIndex with the amount of read bytes
-                buf.readerIndex(buf.readerIndex() + writtenBytes);
-            }
-
-            if (channel.inDoFlushByteBuffer) {
-                // JDK performed the write operation immediately and notified this handler immediately.
-                // doFlushByteBuffer() will do subsequent write operations if necessary for us.
-                return;
-            }
-
-            // Update the write counter and notify flush futures only when the handler is called outside of
-            // unsafe().flushNow() because flushNow() will do that for us.
-            ChannelFlushPromiseNotifier notifier = channel.flushFutureNotifier;
-            notifier.increaseWriteCounter(writtenBytes);
-            notifier.notifyFlushFutures();
-
-            // Stop flushing if disconnected.
-            if (!channel.isActive()) {
-                return;
-            }
-
-            if (buf.isReadable()) {
-                channel.unsafe().flushNow();
-            }
-        }
-
-        @Override
-        protected void failed0(Throwable cause, AioSocketChannel channel) {
-            channel.writeInProgress = WRITE_FAILED;
-            channel.flushFutureNotifier.notifyFlushFutures(cause);
-
-            // Check if the exception was raised because of an InterruptedByTimeoutException which means that the
-            // write timeout was hit. In that case we should close the channel as it may be unusable anyway.
-            //
-            // See http://openjdk.java.net/projects/nio/javadoc/java/nio/channels/AsynchronousSocketChannel.html
-            if (cause instanceof InterruptedByTimeoutException) {
-                channel.unsafe().close(channel.voidPromise());
-            }
-        }
-    }
-
-    private static final class ReadHandler<T extends Number> extends AioCompletionHandler<T, AioSocketChannel> {
-
-        @Override
-        protected void completed0(T result, AioSocketChannel channel) {
-            channel.readInProgress = false;
-
-            if (channel.inputShutdown) {
-                // Channel has been closed during read. Because the inbound buffer has been deallocated already,
-                // there's no way to let a user handler access it unfortunately.
-                return;
-            }
-
-            final ChannelPipeline pipeline = channel.pipeline();
-            final ByteBuf byteBuf = pipeline.inboundByteBuffer();
-
-            boolean closed = false;
-            boolean read = false;
-            boolean firedChannelReadSuspended = false;
-            try {
-                int localReadAmount = result.intValue();
-                if (localReadAmount > 0) {
-                    // Set the writerIndex of the buffer correctly to the
-                    // current writerIndex + read amount of bytes.
-                    //
-                    // This is needed as the ByteBuffer and the ByteBuf does not share
-                    // each others index
-                    byteBuf.writerIndex(byteBuf.writerIndex() + localReadAmount);
-
-                    read = true;
-                } else if (localReadAmount < 0) {
-                    closed = true;
-                }
-            } catch (Throwable t) {
-                if (read) {
-                    read = false;
-                    pipeline.fireInboundBufferUpdated();
-                }
-
-                if (!closed && channel.isOpen()) {
-                    firedChannelReadSuspended = true;
-                    pipeline.fireChannelReadSuspended();
-                }
-
-                pipeline.fireExceptionCaught(t);
-            } finally {
-                if (read) {
-                    pipeline.fireInboundBufferUpdated();
-                }
-
-                // Double check because fireInboundBufferUpdated() might have triggered the closure by a user handler.
-                if (closed || !channel.isOpen()) {
-                    channel.inputShutdown = true;
-                    if (channel.isOpen()) {
-                        if (channel.config().isAllowHalfClosure()) {
-                            pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
-                        } else {
-                            channel.unsafe().close(channel.voidPromise());
-                        }
-                    }
-                } else if (!firedChannelReadSuspended) {
-                    pipeline.fireChannelReadSuspended();
-                }
-            }
-        }
-
-        @Override
-        protected void failed0(Throwable t, AioSocketChannel channel) {
-            channel.readInProgress = false;
-            if (t instanceof ClosedChannelException) {
-                channel.inputShutdown = true;
-                return;
-            }
-
-            channel.pipeline().fireExceptionCaught(t);
-
-            // Check if the exception was raised because of an InterruptedByTimeoutException which means that the
-            // write timeout was hit. In that case we should close the channel as it may be unusable anyway.
-            //
-            // See http://openjdk.java.net/projects/nio/javadoc/java/nio/channels/AsynchronousSocketChannel.html
-            if (t instanceof IOException || t instanceof InterruptedByTimeoutException) {
-                channel.unsafe().close(channel.voidPromise());
-            }
-        }
-    }
-
-    private static final class ConnectHandler extends AioCompletionHandler<Void, AioSocketChannel> {
-
-        @Override
-        protected void completed0(Void result, AioSocketChannel channel) {
-            ((DefaultAioUnsafe) channel.unsafe()).connectSuccess();
-        }
-
-        @Override
-        protected void failed0(Throwable exc, AioSocketChannel channel) {
-            ((DefaultAioUnsafe) channel.unsafe()).connectFailed(exc);
-        }
-    }
-
-    @Override
-    public AioSocketChannelConfig config() {
-        return config;
-    }
-
-    private final class WritableByteChannelAdapter implements WritableByteChannel {
-        private final FlushTask task;
-        private long written;
-
-        public WritableByteChannelAdapter(FlushTask task) {
-            this.task = task;
-        }
-
-        @Override
-        public int write(final ByteBuffer src) {
-            javaChannel().write(src, AioSocketChannel.this, new AioCompletionHandler<Integer, Channel>() {
-
-                @Override
-                public void completed0(Integer result, Channel attachment) {
-                    try {
-                        if (result == 0) {
-                            javaChannel().write(src, AioSocketChannel.this, this);
-                            return;
-                        }
-                        if (result == -1) {
-                            checkEOF(task.region(), written);
-                            task.setSuccess();
-                            return;
-                        }
-                        written += result;
-
-                        task.setProgress(written);
-
-                        if (written >= task.region().count()) {
-                            task.setSuccess();
-                            return;
-                        }
-                        if (src.hasRemaining()) {
-                            javaChannel().write(src, AioSocketChannel.this, this);
-                        } else {
-                            task.region().transferTo(WritableByteChannelAdapter.this, written);
-                        }
-                    } catch (Throwable cause) {
-                        task.setFailure(cause);
-                    }
-                }
-
-                @Override
-                public void failed0(Throwable exc, Channel attachment) {
-                    task.setFailure(exc);
-                }
-            });
-            return 0;
-        }
-
-        @Override
-        public boolean isOpen() {
-            return javaChannel().isOpen();
-        }
-
-        @Override
-        public void close() throws IOException {
-            javaChannel().close();
-        }
-    }
-
-}
diff --git a/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannelConfig.java
deleted file mode 100644
index 951e1f9093b1..000000000000
--- a/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannelConfig.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.socket.aio;
-
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.socket.SocketChannelConfig;
-
-import java.nio.channels.InterruptedByTimeoutException;
-
-
-/**
- * Special {@link SocketChannelConfig} which is used for the {@link AioSocketChannel} to expose extra configuration
- * possiblilites.
- *
- * In addition to the options provided by {@link SocketChannelConfig},
- * {@link AioSocketChannelConfig} allows the following options in the option map:
- *
- * <table border="1" cellspacing="0" cellpadding="6">
- * <tr>
- * <th>Name</th><th>Associated setter method</th>
- * </tr><tr>
- * <td>{@link ChannelOption#AIO_READ_TIMEOUT}</td><td>{@link #setReadTimeout(long)}</td>
- * </tr><tr>
- * <td>{@link ChannelOption#AIO_WRITE_TIMEOUT}</td><td>{@link #setWriteTimeout(long)}</td>
- * </tr>
- * </table>
- */
-public interface AioSocketChannelConfig extends SocketChannelConfig {
-
-    /**
-     * Return the read timeout in milliseconds after which a {@link InterruptedByTimeoutException} will get thrown.
-     * Once such an exception was detected it will get propagated to the handlers first. After that the channel
-     * will get closed as it may be in an unknown state.
-     *
-     * To disable it just use {@code 0}.
-     */
-    AioSocketChannelConfig setReadTimeout(long readTimeoutInMillis);
-
-    /**
-     * Return the write timeout in milliseconds after which a {@link InterruptedByTimeoutException} will get thrown.
-     * Once such an exception was detected it will get propagated to the handlers first. After that the channel
-     * will get closed as it may be in an unknown state.
-     *
-     * To disable it just use {@code 0}.
-     */
-    AioSocketChannelConfig setWriteTimeout(long writeTimeoutInMillis);
-
-    /**
-     * Return the read timeout in milliseconds after which a {@link InterruptedByTimeoutException} will get thrown.
-     *
-     * The default is {@code 0}
-     */
-    long getReadTimeout();
-
-    /**
-     * Return the write timeout in milliseconds after which a {@link InterruptedByTimeoutException} will get thrown.
-     *
-     * The default is {@code 0}
-     */
-    long getWriteTimeout();
-
-    @Override
-    AioSocketChannelConfig setTcpNoDelay(boolean tcpNoDelay);
-
-    @Override
-    AioSocketChannelConfig setSoLinger(int soLinger);
-
-    @Override
-    AioSocketChannelConfig setSendBufferSize(int sendBufferSize);
-
-    @Override
-    AioSocketChannelConfig setReceiveBufferSize(int receiveBufferSize);
-
-    @Override
-    AioSocketChannelConfig setKeepAlive(boolean keepAlive);
-
-    @Override
-    AioSocketChannelConfig setTrafficClass(int trafficClass);
-
-    @Override
-    AioSocketChannelConfig setReuseAddress(boolean reuseAddress);
-
-    @Override
-    AioSocketChannelConfig setPerformancePreferences(int connectionTime, int latency, int bandwidth);
-
-    @Override
-    AioSocketChannelConfig setAllowHalfClosure(boolean allowHalfClosure);
-
-    @Override
-    AioSocketChannelConfig setWriteSpinCount(int writeSpinCount);
-
-    @Override
-    AioSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);
-
-    @Override
-    AioSocketChannelConfig setAllocator(ByteBufAllocator allocator);
-
-    @Override
-    AioSocketChannelConfig setAutoRead(boolean autoRead);
-
-    @Override
-    AioSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
-}
diff --git a/transport/src/main/java/io/netty/channel/socket/aio/DefaultAioSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/aio/DefaultAioSocketChannelConfig.java
deleted file mode 100644
index 1f88dc78d566..000000000000
--- a/transport/src/main/java/io/netty/channel/socket/aio/DefaultAioSocketChannelConfig.java
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel.socket.aio;
-
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.channel.ChannelException;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.DefaultChannelConfig;
-import io.netty.util.internal.PlatformDependent;
-
-import java.io.IOException;
-import java.net.SocketOption;
-import java.net.StandardSocketOptions;
-import java.nio.channels.NetworkChannel;
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static io.netty.channel.ChannelOption.*;
-
-/**
- * The default {@link AioSocketChannelConfig} implementation.
- */
-final class DefaultAioSocketChannelConfig extends DefaultChannelConfig
-                                        implements AioSocketChannelConfig {
-
-    private final AtomicReference<NetworkChannel> javaChannel = new AtomicReference<NetworkChannel>();
-    private volatile boolean allowHalfClosure;
-    private volatile long readTimeoutInMillis;
-    private volatile long writeTimeoutInMillis;
-    private Map<SocketOption<?>, Object> options = PlatformDependent.newConcurrentHashMap();
-    private static final int DEFAULT_RCV_BUF_SIZE = 32 * 1024;
-    private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;
-    private static final int DEFAULT_SO_LINGER = -1;
-    private static final boolean DEFAULT_SO_KEEP_ALIVE = false;
-    private static final int DEFAULT_IP_TOS = 0;
-    private static final boolean DEFAULT_SO_REUSEADDR = false;
-    private static final boolean DEFAULT_TCP_NODELAY = false;
-
-    /**
-     * Creates a new instance with no {@link NetworkChannel} assigned to it.
-     *
-     * You should call {@link #assign(NetworkChannel)} to assign a {@link NetworkChannel} to it and
-     * have the configuration set on it.
-     */
-    DefaultAioSocketChannelConfig(AioSocketChannel channel) {
-        super(channel);
-        enableTcpNoDelay();
-    }
-
-    /**
-     * Creates a new instance with the given {@link NetworkChannel} assigned to it.
-     */
-    DefaultAioSocketChannelConfig(AioSocketChannel channel, NetworkChannel javaChannel) {
-        super(channel);
-        this.javaChannel.set(javaChannel);
-        enableTcpNoDelay();
-    }
-
-    private void enableTcpNoDelay() {
-        // Enable TCP_NODELAY by default if possible.
-        if (PlatformDependent.canEnableTcpNoDelayByDefault()) {
-            try {
-                setTcpNoDelay(true);
-            } catch (Exception e) {
-                // Ignore.
-            }
-        }
-    }
-
-    @Override
-    public Map<ChannelOption<?>, Object> getOptions() {
-        return getOptions(
-                super.getOptions(),
-                SO_RCVBUF, SO_SNDBUF, TCP_NODELAY, SO_KEEPALIVE, SO_REUSEADDR, SO_LINGER, IP_TOS,
-                AIO_READ_TIMEOUT, AIO_WRITE_TIMEOUT, ALLOW_HALF_CLOSURE);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public <T> T getOption(ChannelOption<T> option) {
-        if (option == SO_RCVBUF) {
-            return (T) Integer.valueOf(getReceiveBufferSize());
-        }
-        if (option == SO_SNDBUF) {
-            return (T) Integer.valueOf(getSendBufferSize());
-        }
-        if (option == TCP_NODELAY) {
-            return (T) Boolean.valueOf(isTcpNoDelay());
-        }
-        if (option == SO_KEEPALIVE) {
-            return (T) Boolean.valueOf(isKeepAlive());
-        }
-        if (option == SO_REUSEADDR) {
-            return (T) Boolean.valueOf(isReuseAddress());
-        }
-        if (option == SO_LINGER) {
-            return (T) Integer.valueOf(getSoLinger());
-        }
-        if (option == IP_TOS) {
-            return (T) Integer.valueOf(getTrafficClass());
-        }
-        if (option == AIO_READ_TIMEOUT) {
-            return (T) Long.valueOf(getReadTimeout());
-        }
-        if (option == AIO_WRITE_TIMEOUT) {
-            return (T) Long.valueOf(getWriteTimeout());
-        }
-        if (option == ALLOW_HALF_CLOSURE) {
-            return (T) Boolean.valueOf(isAllowHalfClosure());
-        }
-
-        return super.getOption(option);
-    }
-
-    @Override
-    public <T> boolean setOption(ChannelOption<T> option, T value) {
-        validate(option, value);
-
-        if (option == SO_RCVBUF) {
-            setReceiveBufferSize((Integer) value);
-        } else if (option == SO_SNDBUF) {
-            setSendBufferSize((Integer) value);
-        } else if (option == TCP_NODELAY) {
-            setTcpNoDelay((Boolean) value);
-        } else if (option == SO_KEEPALIVE) {
-            setKeepAlive((Boolean) value);
-        } else if (option == SO_REUSEADDR) {
-            setReuseAddress((Boolean) value);
-        } else if (option == SO_LINGER) {
-            setSoLinger((Integer) value);
-        } else if (option == IP_TOS) {
-            setTrafficClass((Integer) value);
-        } else if (option == AIO_READ_TIMEOUT) {
-            setReadTimeout((Long) value);
-        } else if (option == AIO_WRITE_TIMEOUT) {
-            setWriteTimeout((Long) value);
-        } else if (option == ALLOW_HALF_CLOSURE) {
-            setAllowHalfClosure((Boolean) value);
-        } else {
-            return super.setOption(option, value);
-        }
-
-        return true;
-    }
-
-    @Override
-    public int getReceiveBufferSize() {
-        return (Integer) getOption(StandardSocketOptions.SO_RCVBUF, DEFAULT_RCV_BUF_SIZE);
-    }
-
-    @Override
-    public int getSendBufferSize() {
-        return (Integer) getOption(StandardSocketOptions.SO_SNDBUF, DEFAULT_SND_BUF_SIZE);
-    }
-
-    @Override
-    public int getSoLinger() {
-        return (Integer) getOption(StandardSocketOptions.SO_LINGER, DEFAULT_SO_LINGER);
-    }
-
-    @Override
-    public int getTrafficClass() {
-        return (Integer) getOption(StandardSocketOptions.IP_TOS, DEFAULT_IP_TOS);
-    }
-
-    @Override
-    public boolean isKeepAlive() {
-        return (Boolean) getOption(StandardSocketOptions.SO_KEEPALIVE, DEFAULT_SO_KEEP_ALIVE);
-    }
-
-    @Override
-    public boolean isReuseAddress() {
-        return (Boolean) getOption(StandardSocketOptions.SO_REUSEADDR, DEFAULT_SO_REUSEADDR);
-    }
-
-    @Override
-    public boolean isTcpNoDelay() {
-        return (Boolean) getOption(StandardSocketOptions.TCP_NODELAY, DEFAULT_TCP_NODELAY);
-    }
-
-    @Override
-    public AioSocketChannelConfig setKeepAlive(boolean keepAlive) {
-        setOption(StandardSocketOptions.SO_KEEPALIVE, keepAlive);
-        return this;
-    }
-
-    @Override
-    public AioSocketChannelConfig setPerformancePreferences(
-            int connectionTime, int latency, int bandwidth) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public AioSocketChannelConfig setReceiveBufferSize(int receiveBufferSize) {
-        setOption(StandardSocketOptions.SO_RCVBUF, receiveBufferSize);
-        return this;
-    }
-
-    @Override
-    public AioSocketChannelConfig setReuseAddress(boolean reuseAddress) {
-        setOption(StandardSocketOptions.SO_REUSEADDR, reuseAddress);
-        return this;
-    }
-
-    @Override
-    public AioSocketChannelConfig setSendBufferSize(int sendBufferSize) {
-        setOption(StandardSocketOptions.SO_SNDBUF, sendBufferSize);
-        return this;
-    }
-
-    @Override
-    public AioSocketChannelConfig setSoLinger(int soLinger) {
-        setOption(StandardSocketOptions.SO_LINGER, soLinger);
-        return this;
-    }
-
-    @Override
-    public AioSocketChannelConfig setTcpNoDelay(boolean tcpNoDelay) {
-        setOption(StandardSocketOptions.TCP_NODELAY, tcpNoDelay);
-        return this;
-    }
-
-    @Override
-    public AioSocketChannelConfig setTrafficClass(int trafficClass) {
-        setOption(StandardSocketOptions.IP_TOS, trafficClass);
-        return this;
-    }
-
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private Object getOption(SocketOption option, Object defaultValue) {
-        if (javaChannel.get() == null) {
-            Object value = options.get(option);
-            if (value == null) {
-                return defaultValue;
-            } else {
-                return value;
-            }
-        }
-
-        try {
-            return javaChannel.get().getOption(option);
-        } catch (IOException e) {
-            throw new ChannelException(e);
-        }
-    }
-
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private void setOption(SocketOption option, Object defaultValue) {
-        if (javaChannel.get() == null) {
-            options.put(option, defaultValue);
-            return;
-        }
-        try {
-            javaChannel.get().setOption(option, defaultValue);
-        } catch (IOException e) {
-            throw new ChannelException(e);
-        }
-    }
-
-    @Override
-    public AioSocketChannelConfig setReadTimeout(long readTimeoutInMillis) {
-        if (readTimeoutInMillis < 0) {
-            throw new IllegalArgumentException("readTimeoutInMillis: " + readTimeoutInMillis);
-        }
-        this.readTimeoutInMillis = readTimeoutInMillis;
-        return this;
-    }
-
-    @Override
-    public AioSocketChannelConfig setWriteTimeout(long writeTimeoutInMillis) {
-        if (writeTimeoutInMillis < 0) {
-            throw new IllegalArgumentException("writeTimeoutInMillis: " + writeTimeoutInMillis);
-        }
-        this.writeTimeoutInMillis = writeTimeoutInMillis;
-        return this;
-    }
-
-    @Override
-    public long getReadTimeout() {
-        return readTimeoutInMillis;
-    }
-
-    @Override
-    public long getWriteTimeout() {
-        return writeTimeoutInMillis;
-    }
-
-    @Override
-    public boolean isAllowHalfClosure() {
-        return allowHalfClosure;
-    }
-
-    @Override
-    public AioSocketChannelConfig setAllowHalfClosure(boolean allowHalfClosure) {
-        this.allowHalfClosure = allowHalfClosure;
-        return this;
-    }
-
-    /**
-     * Assing the given {@link NetworkChannel} to this instance
-     */
-    void assign(NetworkChannel javaChannel) {
-        if (javaChannel == null) {
-            throw new NullPointerException("javaChannel");
-        }
-        if (this.javaChannel.compareAndSet(null, javaChannel)) {
-            propagateOptions();
-        }
-    }
-
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private void propagateOptions() {
-        for (SocketOption option: options.keySet()) {
-            Object value = options.remove(option);
-            if (value != null) {
-                try {
-                    javaChannel.get().setOption(option, value);
-                } catch (IOException e) {
-                    throw new ChannelException(e);
-                }
-            }
-        }
-        // not needed anymore
-        options = null;
-    }
-
-    @Override
-    public AioSocketChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {
-        return (AioSocketChannelConfig) super.setConnectTimeoutMillis(connectTimeoutMillis);
-    }
-
-    @Override
-    public AioSocketChannelConfig setWriteSpinCount(int writeSpinCount) {
-        return (AioSocketChannelConfig) super.setWriteSpinCount(writeSpinCount);
-    }
-
-    @Override
-    public AioSocketChannelConfig setAllocator(ByteBufAllocator allocator) {
-        return (AioSocketChannelConfig) super.setAllocator(allocator);
-    }
-
-    @Override
-    public AioSocketChannelConfig setAutoRead(boolean autoRead) {
-        return (AioSocketChannelConfig) super.setAutoRead(autoRead);
-    }
-
-    @Override
-    public AioSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        return (AioSocketChannelConfig) super.setDefaultHandlerByteBufType(type);
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/socket/aio/package-info.java b/transport/src/main/java/io/netty/channel/socket/aio/package-info.java
deleted file mode 100644
index 3f652125b506..000000000000
--- a/transport/src/main/java/io/netty/channel/socket/aio/package-info.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright 2012 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-/**
- * <a href="http://en.wikipedia.org/wiki/New_I/O">NIO2</a>-based socket channel
- * API implementation - recommended for a large number of connections (&gt;= 1000).
- *
- * NIO2 is only supported on Java 7+.
- */
-package io.netty.channel.socket.aio;
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
index 3c0072d7046e..def2ea368a14 100755
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java
@@ -15,17 +15,17 @@
  */
 package io.netty.channel.socket.nio;
 
-import io.netty.buffer.BufType;
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.AddressedEnvelope;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.nio.AbstractNioMessageChannel;
 import io.netty.channel.socket.DatagramChannelConfig;
 import io.netty.channel.socket.DatagramPacket;
@@ -59,12 +59,14 @@
 public final class NioDatagramChannel
         extends AbstractNioMessageChannel implements io.netty.channel.socket.DatagramChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, true);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(true);
 
     private final DatagramChannelConfig config;
     private final Map<InetAddress, List<MembershipKey>> memberships =
             new HashMap<InetAddress, List<MembershipKey>>();
 
+    private RecvByteBufAllocator.Handle allocHandle;
+
     private static DatagramChannel newSocket() {
         try {
             return DatagramChannel.open();
@@ -198,9 +200,14 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         DatagramChannel ch = javaChannel();
-        ByteBuf data = alloc().directBuffer(config().getReceivePacketSize());
+        DatagramChannelConfig config = config();
+        RecvByteBufAllocator.Handle allocHandle = this.allocHandle;
+        if (allocHandle == null) {
+            this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();
+        }
+        ByteBuf data = allocHandle.allocate(config.getAllocator());
         boolean free = true;
         try {
             ByteBuffer nioData = data.nioBuffer(data.writerIndex(), data.writableBytes());
@@ -210,7 +217,10 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
                 return 0;
             }
 
-            data.writerIndex(data.writerIndex() + nioData.position());
+            int readBytes = nioData.position();
+            data.writerIndex(data.writerIndex() + readBytes);
+            allocHandle.record(readBytes);
+
             buf.add(new DatagramPacket(data, localAddress(), remoteAddress));
             free = false;
             return 1;
@@ -225,8 +235,8 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
     }
 
     @Override
-    protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws Exception {
-        final Object o = buf.peek();
+    protected int doWriteMessages(MessageList<Object> msgs, int index, boolean lastSpin) throws Exception {
+        final Object o = msgs.get(index);
         final Object m;
         final ByteBuf data;
         final SocketAddress remoteAddress;
@@ -245,7 +255,7 @@ protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws E
         } else if (m instanceof ByteBuf) {
             data = (ByteBuf) m;
         } else {
-            BufUtil.release(buf.remove());
+            ByteBufUtil.release(o);
             throw new ChannelException("unsupported message type: " + StringUtil.simpleClassName(o));
         }
 
@@ -283,9 +293,9 @@ protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws E
         }
 
         // Wrote a packet - free the message.
-        BufUtil.release(buf.remove());
+        ByteBufUtil.release(o);
 
-        if (buf.isEmpty()) {
+        if (index + 1 == msgs.size()) {
             // Wrote the outbound buffer completely - clear OP_WRITE.
             if ((interestOps & SelectionKey.OP_WRITE) != 0) {
                 key.interestOps(interestOps & ~SelectionKey.OP_WRITE);
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
index b9028a70d17c..72e8b7eac95b 100755
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java
@@ -15,10 +15,9 @@
  */
 package io.netty.channel.socket.nio;
 
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelMetadata;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.AbstractNioMessageChannel;
 import io.netty.channel.socket.DefaultServerSocketChannelConfig;
 import io.netty.channel.socket.ServerSocketChannelConfig;
@@ -39,7 +38,7 @@
 public class NioServerSocketChannel extends AbstractNioMessageChannel
                              implements io.netty.channel.socket.ServerSocketChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioServerSocketChannel.class);
 
@@ -108,7 +107,7 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         SocketChannel ch = javaChannel().accept();
 
         try {
@@ -152,7 +151,7 @@ protected void doDisconnect() throws Exception {
     }
 
     @Override
-    protected int doWriteMessages(MessageBuf<Object> buf, boolean lastSpin) throws Exception {
+    protected int doWriteMessages(MessageList<Object> msgs, int index, boolean lastSpin) throws Exception {
         throw new UnsupportedOperationException();
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
index 92f6b77cc1e5..76da0a373e56 100755
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
@@ -15,7 +15,6 @@
  */
 package io.netty.channel.socket.nio;
 
-import io.netty.buffer.BufType;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
@@ -23,6 +22,8 @@
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
+import io.netty.channel.FileRegion;
+import io.netty.channel.MessageList;
 import io.netty.channel.nio.AbstractNioByteChannel;
 import io.netty.channel.socket.DefaultSocketChannelConfig;
 import io.netty.channel.socket.ServerSocketChannel;
@@ -33,6 +34,7 @@
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.nio.ByteBuffer;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.SocketChannel;
 
@@ -41,11 +43,28 @@
  */
 public class NioSocketChannel extends AbstractNioByteChannel implements io.netty.channel.socket.SocketChannel {
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioSocketChannel.class);
 
-    private final SocketChannelConfig config;
+    // Buffers to use for Gathering writes
+    private static final ThreadLocal<ByteBuffer[]> BUFFERS = new ThreadLocal<ByteBuffer[]>() {
+        @Override
+        protected ByteBuffer[] initialValue() {
+            return new ByteBuffer[128];
+        }
+    };
+
+    private static ByteBuffer[] getNioBufferArray() {
+        return BUFFERS.get();
+    }
+
+    private static ByteBuffer[] doubleNioBufferArray(ByteBuffer[] array, int size) {
+        ByteBuffer[] newArray = new ByteBuffer[array.length << 1];
+        System.arraycopy(array, 0, newArray, 0, size);
+        BUFFERS.set(newArray);
+        return newArray;
+    }
 
     private static SocketChannel newSocket() {
         try {
@@ -55,6 +74,8 @@ private static SocketChannel newSocket() {
         }
     }
 
+    private final SocketChannelConfig config;
+
     /**
      * Create a new instance
      */
@@ -230,30 +251,114 @@ protected int doReadBytes(ByteBuf byteBuf) throws Exception {
     protected int doWriteBytes(ByteBuf buf, boolean lastSpin) throws Exception {
         final int expectedWrittenBytes = buf.readableBytes();
         final int writtenBytes = buf.readBytes(javaChannel(), expectedWrittenBytes);
+        updateOpWrite(expectedWrittenBytes, writtenBytes, lastSpin);
+        return writtenBytes;
+    }
 
-        final SelectionKey key = selectionKey();
-        final int interestOps = key.interestOps();
-        if (writtenBytes >= expectedWrittenBytes) {
-            // Wrote the outbound buffer completely - clear OP_WRITE.
-            if ((interestOps & SelectionKey.OP_WRITE) != 0) {
-                key.interestOps(interestOps & ~SelectionKey.OP_WRITE);
+    @Override
+    protected long doWriteFileRegion(FileRegion region, boolean lastSpin) throws Exception {
+        final long position = region.transfered();
+        final long expectedWrittenBytes = region.count() - position;
+        final long writtenBytes = region.transferTo(javaChannel(), position);
+        updateOpWrite(expectedWrittenBytes, writtenBytes, lastSpin);
+        return writtenBytes;
+    }
+
+    @Override
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
+        int size = msgs.size();
+
+        // Do non-gathering write for a single buffer case.
+        if (size <= 1 || !msgs.containsOnly(ByteBuf.class)) {
+            return super.doWrite(msgs, index);
+        }
+
+        MessageList<ByteBuf> bufs = msgs.cast();
+
+        ByteBuffer[] nioBuffers = getNioBufferArray();
+        int nioBufferCnt = 0;
+        long expectedWrittenBytes = 0;
+        for (int i = index; i < size; i++) {
+            ByteBuf buf = bufs.get(i);
+            int readerIndex = buf.readerIndex();
+            int readableBytes = buf.readableBytes();
+            expectedWrittenBytes += readableBytes;
+
+            if (buf.isDirect()) {
+                int count = buf.nioBufferCount();
+                if (count == 1) {
+                    if (nioBufferCnt == nioBuffers.length) {
+                        nioBuffers = doubleNioBufferArray(nioBuffers, nioBufferCnt);
+                    }
+                    nioBuffers[nioBufferCnt ++] = buf.internalNioBuffer(readerIndex, readableBytes);
+                } else {
+                    ByteBuffer[] nioBufs = buf.nioBuffers();
+                    if (nioBufferCnt + nioBufs.length == nioBuffers.length + 1) {
+                        nioBuffers = doubleNioBufferArray(nioBuffers, nioBufferCnt);
+                    }
+                    for (ByteBuffer nioBuf: nioBufs) {
+                        if (nioBuf == null) {
+                            break;
+                        }
+                        nioBuffers[nioBufferCnt ++] = nioBuf;
+                    }
+                }
+            } else {
+                ByteBuf directBuf = alloc().directBuffer(readableBytes);
+                directBuf.writeBytes(buf, readerIndex, readableBytes);
+                buf.release();
+                bufs.set(i, directBuf);
+                if (nioBufferCnt == nioBuffers.length) {
+                    nioBuffers = doubleNioBufferArray(nioBuffers, nioBufferCnt);
+                }
+                nioBuffers[nioBufferCnt ++] = directBuf.internalNioBuffer(0, readableBytes);
+            }
+        }
+
+        long writtenBytes = 0;
+        boolean done = false;
+        for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
+            final long localWrittenBytes = javaChannel().write(nioBuffers, 0, nioBufferCnt);
+            updateOpWrite(expectedWrittenBytes, localWrittenBytes, i == 0);
+            if (localWrittenBytes == 0) {
+                break;
+            }
+            expectedWrittenBytes -= localWrittenBytes;
+            writtenBytes += localWrittenBytes;
+            if (expectedWrittenBytes == 0) {
+                done = true;
+                break;
             }
+        }
+
+        if (done) {
+            // release buffers
+            for (int i = index; i < size; i++) {
+                ByteBuf buf = bufs.get(i);
+                buf.release();
+            }
+            return size - index;
         } else {
-            // Wrote something or nothing.
-            // a) If wrote something, the caller will not retry.
-            //    - Set OP_WRITE so that the event loop calls flushForcibly() later.
-            // b) If wrote nothing:
-            //    1) If 'lastSpin' is false, the caller will call this method again real soon.
-            //       - Do not update OP_WRITE.
-            //    2) If 'lastSpin' is true, the caller will not retry.
-            //       - Set OP_WRITE so that the event loop calls flushForcibly() later.
-            if (writtenBytes > 0 || lastSpin) {
-                if ((interestOps & SelectionKey.OP_WRITE) == 0) {
-                    key.interestOps(interestOps | SelectionKey.OP_WRITE);
+            // Did not write all buffers completely.
+            // Release the fully written buffers and update the indexes of the partially written buffer.
+            int writtenBufs = 0;
+            for (int i = index; i < size; i++) {
+                ByteBuf buf = bufs.get(i);
+                int readable = buf.readableBytes();
+                if (readable < writtenBytes) {
+                    writtenBufs ++;
+                    buf.release();
+                    writtenBytes -= readable;
+                } else if (readable > writtenBytes) {
+                    buf.readerIndex(buf.readerIndex() + (int) writtenBytes);
+                    break;
+                } else { // readable == writtenBytes
+                    writtenBufs ++;
+                    buf.release();
+                    break;
                 }
             }
+            return writtenBufs;
         }
-
-        return writtenBytes;
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
index 99370e4b86c0..223ad2a513a4 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioServerSocketChannelConfig.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.socket.DefaultServerSocketChannelConfig;
 import io.netty.channel.socket.ServerSocketChannel;
 
@@ -126,14 +127,14 @@ public OioServerSocketChannelConfig setAllocator(ByteBufAllocator allocator) {
     }
 
     @Override
-    public OioServerSocketChannelConfig setAutoRead(boolean autoRead) {
-        super.setAutoRead(autoRead);
+    public OioServerSocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
         return this;
     }
 
     @Override
-    public OioServerSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        super.setDefaultHandlerByteBufType(type);
+    public OioServerSocketChannelConfig setAutoRead(boolean autoRead) {
+        super.setAutoRead(autoRead);
         return this;
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
index f0d4472d136a..5c4f6df25b79 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.socket.DefaultSocketChannelConfig;
 import io.netty.channel.socket.SocketChannel;
 
@@ -154,14 +155,14 @@ public OioSocketChannelConfig setAllocator(ByteBufAllocator allocator) {
     }
 
     @Override
-    public OioSocketChannelConfig setAutoRead(boolean autoRead) {
-        super.setAutoRead(autoRead);
+    public OioSocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator) {
+        super.setRecvByteBufAllocator(allocator);
         return this;
     }
 
     @Override
-    public OioSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type) {
-        super.setDefaultHandlerByteBufType(type);
+    public OioSocketChannelConfig setAutoRead(boolean autoRead) {
+        super.setAutoRead(autoRead);
         return this;
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
index f1c7605ae51d..1d329105e7bf 100755
--- a/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java
@@ -15,17 +15,17 @@
  */
 package io.netty.channel.socket.oio;
 
-import io.netty.buffer.BufType;
-import io.netty.buffer.BufUtil;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.AddressedEnvelope;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.MessageList;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.oio.AbstractOioMessageChannel;
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.channel.socket.DatagramChannelConfig;
@@ -59,12 +59,14 @@ public class OioDatagramChannel extends AbstractOioMessageChannel
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(OioDatagramChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, true);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(true);
 
     private final MulticastSocket socket;
     private final DatagramChannelConfig config;
     private final java.net.DatagramPacket tmpPacket = new java.net.DatagramPacket(EmptyArrays.EMPTY_BYTES, 0);
 
+    private RecvByteBufAllocator.Handle allocHandle;
+
     private static MulticastSocket newSocket() {
         try {
             return new MulticastSocket(null);
@@ -199,13 +201,17 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
-        int packetSize = config().getReceivePacketSize();
-        ByteBuf data = alloc().heapBuffer(packetSize);
-        boolean free = true;
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
+        DatagramChannelConfig config = config();
+        RecvByteBufAllocator.Handle allocHandle = this.allocHandle;
+        if (allocHandle == null) {
+            this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();
+        }
 
+        ByteBuf data = config.getAllocator().heapBuffer(allocHandle.guess());
+        boolean free = true;
         try {
-            tmpPacket.setData(data.array(), data.arrayOffset(), packetSize);
+            tmpPacket.setData(data.array(), data.arrayOffset(), data.capacity());
             socket.receive(tmpPacket);
 
             InetSocketAddress remoteAddr = (InetSocketAddress) tmpPacket.getSocketAddress();
@@ -213,7 +219,9 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
                 remoteAddr = remoteAddress();
             }
 
-            buf.add(new DatagramPacket(data.writerIndex(tmpPacket.getLength()), localAddress(), remoteAddr));
+            int readBytes = tmpPacket.getLength();
+            allocHandle.record(readBytes);
+            buf.add(new DatagramPacket(data.writerIndex(readBytes), localAddress(), remoteAddr));
             free = false;
             return 1;
         } catch (SocketTimeoutException e) {
@@ -235,8 +243,8 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
     }
 
     @Override
-    protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
-        final Object o = buf.poll();
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
+        final Object o = msgs.get(index);
         final Object m;
         final ByteBuf data;
         final SocketAddress remoteAddress;
@@ -255,7 +263,7 @@ protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
         } else if (m instanceof ByteBuf) {
             data = (ByteBuf) m;
         } else {
-            BufUtil.release(buf.remove());
+            ByteBufUtil.release(o);
             throw new ChannelException("unsupported message type: " + StringUtil.simpleClassName(o));
         }
 
@@ -272,8 +280,9 @@ protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
                 tmpPacket.setData(tmp);
             }
             socket.send(tmpPacket);
+            return 1;
         } finally {
-            BufUtil.release(o);
+            ByteBufUtil.release(o);
         }
     }
 
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
index 6e40fb97d334..374181a03cc0 100755
--- a/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java
@@ -15,10 +15,10 @@
  */
 package io.netty.channel.socket.oio;
 
-import io.netty.buffer.BufType;
-import io.netty.buffer.MessageBuf;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelMetadata;
+import io.netty.channel.MessageList;
 import io.netty.channel.oio.AbstractOioMessageChannel;
 import io.netty.channel.socket.ServerSocketChannel;
 import io.netty.util.internal.logging.InternalLogger;
@@ -44,7 +44,7 @@ public class OioServerSocketChannel extends AbstractOioMessageChannel
     private static final InternalLogger logger =
         InternalLoggerFactory.getInstance(OioServerSocketChannel.class);
 
-    private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.MESSAGE, false);
+    private static final ChannelMetadata METADATA = new ChannelMetadata(false);
 
     private static ServerSocket newServerSocket() {
         try {
@@ -155,7 +155,7 @@ protected void doClose() throws Exception {
     }
 
     @Override
-    protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
+    protected int doReadMessages(MessageList<Object> buf) throws Exception {
         if (socket.isClosed()) {
             return -1;
         }
@@ -183,6 +183,15 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {
         return 0;
     }
 
+    @Override
+    protected int doWrite(MessageList<Object> msgs, int index) throws Exception {
+        int size = msgs.size();
+        for (int i = index; i < size; i ++) {
+            ByteBufUtil.release(msgs.get(i));
+        }
+        throw new UnsupportedOperationException();
+    }
+
     @Override
     protected void doConnect(
             SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
@@ -198,9 +207,4 @@ protected SocketAddress remoteAddress0() {
     protected void doDisconnect() throws Exception {
         throw new UnsupportedOperationException();
     }
-
-    @Override
-    protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {
-        throw new UnsupportedOperationException();
-    }
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannelConfig.java
index 34ade6cb94bc..7595f63040a5 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannelConfig.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.socket.ServerSocketChannelConfig;
 
 
@@ -71,8 +72,8 @@ public interface OioServerSocketChannelConfig extends ServerSocketChannelConfig
     OioServerSocketChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    OioServerSocketChannelConfig setAutoRead(boolean autoRead);
+    OioServerSocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    OioServerSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    OioServerSocketChannelConfig setAutoRead(boolean autoRead);
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannelConfig.java
index d18db6a109f6..ac1a481552c0 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannelConfig.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelConfig;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
 import io.netty.channel.socket.SocketChannelConfig;
 
 /**
@@ -86,8 +87,8 @@ public interface OioSocketChannelConfig extends SocketChannelConfig {
     OioSocketChannelConfig setAllocator(ByteBufAllocator allocator);
 
     @Override
-    OioSocketChannelConfig setAutoRead(boolean autoRead);
+    OioSocketChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator);
 
     @Override
-    OioSocketChannelConfig setDefaultHandlerByteBufType(ChannelHandlerByteBufType type);
+    OioSocketChannelConfig setAutoRead(boolean autoRead);
 }
diff --git a/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
index ad630b5d37b1..efcadfb6a1af 100644
--- a/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
+++ b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
@@ -17,9 +17,8 @@
 package io.netty.bootstrap;
 
 import io.netty.channel.ChannelHandler.Sharable;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandler;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
@@ -38,7 +37,7 @@ public void testBindDeadLock() throws Exception {
         EventLoopGroup groupB = new LocalEventLoopGroup(1);
 
         try {
-            ChannelInboundMessageHandler<Object> dummyHandler = new DummyHandler();
+            ChannelInboundHandler dummyHandler = new DummyHandler();
 
             final Bootstrap bootstrapA = new Bootstrap();
             bootstrapA.group(groupA);
@@ -75,6 +74,8 @@ public void run() {
         } finally {
             groupA.shutdownGracefully();
             groupB.shutdownGracefully();
+            groupA.terminationFuture().sync();
+            groupB.terminationFuture().sync();
         }
     }
 
@@ -84,7 +85,7 @@ public void testConnectDeadLock() throws Exception {
         EventLoopGroup groupB = new LocalEventLoopGroup(1);
 
         try {
-            ChannelInboundMessageHandler<Object> dummyHandler = new DummyHandler();
+            ChannelInboundHandler dummyHandler = new DummyHandler();
 
             final Bootstrap bootstrapA = new Bootstrap();
             bootstrapA.group(groupA);
@@ -121,14 +122,11 @@ public void run() {
         } finally {
             groupA.shutdownGracefully();
             groupB.shutdownGracefully();
+            groupA.terminationFuture().sync();
+            groupB.terminationFuture().sync();
         }
     }
 
     @Sharable
-    private static final class DummyHandler extends ChannelInboundMessageHandlerAdapter<Object> {
-        @Override
-        public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-            // NOOP
-        }
-    }
+    private static final class DummyHandler extends ChannelInboundHandlerAdapter { }
 }
diff --git a/transport/src/test/java/io/netty/channel/AbstractEventLoopTest.java b/transport/src/test/java/io/netty/channel/AbstractEventLoopTest.java
index d318b9d6890c..d9c3f45c83b1 100644
--- a/transport/src/test/java/io/netty/channel/AbstractEventLoopTest.java
+++ b/transport/src/test/java/io/netty/channel/AbstractEventLoopTest.java
@@ -39,7 +39,6 @@ public void testReregister() {
         ServerBootstrap bootstrap = new ServerBootstrap();
         ChannelFuture future = bootstrap.channel(newChannel()).group(group)
                 .childHandler(new ChannelInitializer<SocketChannel>() {
-
                     @Override
                     public void initChannel(SocketChannel ch) throws Exception {
                     }
@@ -61,27 +60,11 @@ public void initChannel(ServerSocketChannel ch) throws Exception {
         assertSame(executor, future.channel().pipeline().context(TestChannelHandler2.class).executor());
     }
 
-    private static final class TestChannelHandler extends ChannelDuplexHandler {
-        @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-            ctx.flush(promise);
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-            ctx.fireInboundBufferUpdated();
-        }
-    }
+    private static final class TestChannelHandler extends ChannelDuplexHandler { }
 
     private static final class TestChannelHandler2 extends ChannelDuplexHandler {
         @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-            ctx.flush(promise);
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-        }
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception { }
     }
 
     protected abstract EventLoopGroup newEventLoopGroup();
diff --git a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
index 805bdc25c01d..beb6fa0a36bd 100644
--- a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
+++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
@@ -18,15 +18,12 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.ReferenceCounted;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalChannel;
 import io.netty.channel.local.LocalEventLoopGroup;
 import io.netty.channel.local.LocalServerChannel;
+import io.netty.util.ReferenceCounted;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.Test;
@@ -36,7 +33,6 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static org.junit.Assert.*;
@@ -49,22 +45,22 @@ public class DefaultChannelPipelineTest {
     private Channel peer;
 
     @AfterClass
-    public static void afterClass() {
-        group.shutdownGracefully();
+    public static void afterClass() throws Exception {
+        group.shutdownGracefully().sync();
     }
 
     private void setUp(final ChannelHandler... handlers) throws Exception {
         final AtomicReference<Channel> peerRef = new AtomicReference<Channel>();
         ServerBootstrap sb = new ServerBootstrap();
         sb.group(group).channel(LocalServerChannel.class);
-        sb.childHandler(new ChannelInboundMessageHandlerAdapter<Object>() {
+        sb.childHandler(new ChannelInboundHandlerAdapter() {
             @Override
             public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
                 peerRef.set(ctx.channel());
             }
 
             @Override
-            public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
+            public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
                 // Swallow.
             }
         });
@@ -97,76 +93,6 @@ public void tearDown() throws Exception {
         }
     }
 
-    @Test
-    public void testMessageCatchAllInboundSink() throws Exception {
-        final AtomicBoolean forwarded = new AtomicBoolean();
-
-        setUp(new ChannelInboundMessageHandlerAdapter<Object>() {
-            @Override
-            public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-                forwarded.set(ctx.nextInboundMessageBuffer().add(msg));
-            }
-
-            @Override
-            public void endMessageReceived(ChannelHandlerContext ctx) throws Exception {
-                ctx.fireInboundBufferUpdated();
-            }
-        });
-
-        peer.write(new Object()).sync();
-
-        assertTrue(forwarded.get());
-    }
-
-    @Test
-    public void testByteCatchAllInboundSink() throws Exception {
-        final AtomicBoolean forwarded = new AtomicBoolean();
-        setUp(new ChannelInboundByteHandlerAdapter() {
-            @Override
-            protected void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-                ByteBuf out = ctx.nextInboundByteBuffer();
-                out.writeBytes(in);
-                forwarded.set(true);
-                ctx.fireInboundBufferUpdated();
-            }
-        });
-
-        // Not using peer.write() because the pipeline will convert the bytes into a message automatically.
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                self.pipeline().inboundByteBuffer().writeByte(0);
-                self.pipeline().fireInboundBufferUpdated();
-            }
-        }).sync();
-
-        assertTrue(forwarded.get());
-    }
-
-    @Test
-    public void testByteCatchAllOutboundSink() throws Exception {
-        final AtomicBoolean forwarded = new AtomicBoolean();
-        setUp(new ChannelOutboundByteHandlerAdapter() {
-            @Override
-            protected void flush(ChannelHandlerContext ctx, ByteBuf in, ChannelPromise promise) throws Exception {
-                ByteBuf out = ctx.nextOutboundByteBuffer();
-                out.writeBytes(in);
-                forwarded.set(true);
-                ctx.flush(promise);
-            }
-        });
-
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                self.pipeline().outboundByteBuffer().writeByte(0);
-                self.pipeline().flush();
-            }
-        }).sync();
-
-        assertTrue(forwarded.get());
-    }
-
     @Test
     public void testFreeCalled() throws Exception {
         final CountDownLatch free = new CountDownLatch(1);
@@ -214,18 +140,22 @@ public boolean release(int decrement) {
         assertTrue(handler.called);
     }
 
-    private static final class StringInboundHandler extends ChannelInboundMessageHandlerAdapter<String> {
+    private static final class StringInboundHandler extends ChannelInboundHandlerAdapter {
         boolean called;
 
         @Override
-        public boolean acceptInboundMessage(Object msg) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
             called = true;
-            return super.acceptInboundMessage(msg);
-        }
+            MessageList<Object> out = MessageList.newInstance();
+            for (int i = 0; i < msgs.size(); i ++) {
+                Object m = msgs.get(i);
+                if (!(m instanceof String)) {
+                    out.add(m);
+                }
+            }
 
-        @Override
-        public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
-            fail();
+            msgs.recycle();
+            ctx.fireMessageReceived(out);
         }
     }
 
@@ -347,154 +277,59 @@ public void testChannelHandlerContextOrder() {
         verifyContextNumber(pipeline, 8);
     }
 
-    @Test(timeout = 100000)
-    public void testRemoveAndForwardInboundByte() throws Exception {
-        final ChannelInboundByteHandlerImpl handler1 = new ChannelInboundByteHandlerImpl();
-        final ChannelInboundByteHandlerImpl handler2 = new ChannelInboundByteHandlerImpl();
-
-        setUp(handler1, handler2);
-
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                ChannelPipeline p = self.pipeline();
-                p.context(handler1).inboundByteBuffer().writeLong(8);
-                assertEquals(8, p.context(handler1).inboundByteBuffer().readableBytes());
-                assertEquals(0, p.context(handler2).inboundByteBuffer().readableBytes());
-                p.remove(handler1);
-                assertEquals(8, p.context(handler2).inboundByteBuffer().readableBytes());
-            }
-        }).sync();
-
-        assertTrue(handler2.updated);
-    }
-
-    @Test(timeout = 100000)
-    public void testReplaceAndForwardInboundByte() throws Exception {
-        final ChannelInboundByteHandlerImpl handler1 = new ChannelInboundByteHandlerImpl();
-        final ChannelInboundByteHandlerImpl handler2 = new ChannelInboundByteHandlerImpl();
-
-        setUp(handler1);
-
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                ChannelPipeline p = self.pipeline();
-                p.context(handler1).inboundByteBuffer().writeLong(8);
-                assertEquals(8, p.context(handler1).inboundByteBuffer().readableBytes());
-                p.replace(handler1, "handler2", handler2);
-                assertEquals(8, p.context(handler2).inboundByteBuffer().readableBytes());
-            }
-        }).sync();
-
-        assertTrue(handler2.updated);
-    }
-
-    @Test(timeout = 10000)
-    public void testRemoveAndForwardOutboundByte() throws Exception {
-        final ChannelOutboundByteHandlerImpl handler1 = new ChannelOutboundByteHandlerImpl();
-        final ChannelOutboundByteHandlerImpl handler2 = new ChannelOutboundByteHandlerImpl();
-
-        setUp(handler1, handler2);
-
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                ChannelPipeline p = self.pipeline();
-                p.context(handler2).outboundByteBuffer().writeLong(8);
-                assertEquals(8, p.context(handler2).outboundByteBuffer().readableBytes());
-                assertEquals(0, p.context(handler1).outboundByteBuffer().readableBytes());
-                self.pipeline().remove(handler2);
-                assertEquals(8, p.context(handler1).outboundByteBuffer().readableBytes());
-            }
-        }).sync();
-
-        assertTrue(handler1.flushed);
-    }
-
-    @Test(timeout = 10000)
-    public void testReplaceAndForwardOutboundByte() throws Exception {
-        final ChannelOutboundByteHandlerImpl handler1 = new ChannelOutboundByteHandlerImpl();
-        final ChannelOutboundByteHandlerImpl handler2 = new ChannelOutboundByteHandlerImpl();
-
-        setUp(handler1);
-
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                ChannelPipeline p = self.pipeline();
-                p.context(handler1).outboundByteBuffer().writeLong(8);
-                assertEquals(8, p.context(handler1).outboundByteBuffer().readableBytes());
-                p.replace(handler1, "handler2", handler2);
-                assertEquals(8, p.context(handler2).outboundByteBuffer().readableBytes());
-            }
-        }).sync();
-
-        assertTrue(handler2.flushed);
-    }
-
     @Test(timeout = 10000)
-    public void testReplaceAndForwardDuplexByte() throws Exception {
-        final ByteHandlerImpl handler1 = new ByteHandlerImpl();
-        final ByteHandlerImpl handler2 = new ByteHandlerImpl();
-
-        setUp(handler1);
-
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                ChannelPipeline p = self.pipeline();
-                p.context(handler1).outboundByteBuffer().writeLong(8);
-                p.context(handler1).inboundByteBuffer().writeLong(8);
-
-                assertEquals(8, p.context(handler1).outboundByteBuffer().readableBytes());
-                assertEquals(8, p.context(handler1).inboundByteBuffer().readableBytes());
+    public void testLifeCycleAwareness() throws Exception {
+        setUp();
 
-                p.replace(handler1, "handler2", handler2);
-                assertEquals(8, p.context(handler2).outboundByteBuffer().readableBytes());
-                assertEquals(8, p.context(handler2).inboundByteBuffer().readableBytes());
-            }
-        }).sync();
+        ChannelPipeline p = self.pipeline();
 
-        assertTrue(((ChannelInboundByteHandlerImpl) handler2.stateHandler()).updated);
-        assertTrue(((ChannelOutboundByteHandlerImpl) handler2.operationHandler()).flushed);
-    }
+        final List<LifeCycleAwareTestHandler> handlers = new ArrayList<LifeCycleAwareTestHandler>();
+        final int COUNT = 20;
+        final CountDownLatch addLatch = new CountDownLatch(COUNT);
+        for (int i = 0; i < COUNT; i++) {
+            final LifeCycleAwareTestHandler handler = new LifeCycleAwareTestHandler("handler-" + i);
 
-    @Test(timeout = 10000)
-    public void testRemoveAndForwardDuplexByte() throws Exception {
-        final ChannelOutboundByteHandlerImpl handler1 = new ChannelOutboundByteHandlerImpl();
-        final ByteHandlerImpl handler2 = new ByteHandlerImpl();
-        final ChannelInboundByteHandlerImpl handler3 = new ChannelInboundByteHandlerImpl();
+            // Add handler.
+            p.addFirst(handler.name, handler);
+            self.eventLoop().execute(new Runnable() {
+                @Override
+                public void run() {
+                    // Validate handler life-cycle methods called.
+                    handler.validate(true, false);
 
-        setUp(handler1, handler2, handler3);
+                    // Store handler into the list.
+                    handlers.add(handler);
 
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                ChannelPipeline p = self.pipeline();
-                p.context(handler2).outboundByteBuffer().writeLong(8);
-                p.context(handler2).inboundByteBuffer().writeLong(8);
+                    addLatch.countDown();
+                }
+            });
+        }
+        addLatch.await();
 
-                assertEquals(8, p.context(handler2).outboundByteBuffer().readableBytes());
-                assertEquals(8, p.context(handler2).inboundByteBuffer().readableBytes());
+        // Change the order of remove operations over all handlers in the pipeline.
+        Collections.shuffle(handlers);
 
-                assertEquals(0, p.context(handler1).outboundByteBuffer().readableBytes());
-                assertEquals(0, p.context(handler3).inboundByteBuffer().readableBytes());
+        final CountDownLatch removeLatch = new CountDownLatch(COUNT);
 
-                p.remove(handler2);
-                assertEquals(8, p.context(handler1).outboundByteBuffer().readableBytes());
-                assertEquals(8, p.context(handler3).inboundByteBuffer().readableBytes());
-            }
-        }).sync();
+        for (final LifeCycleAwareTestHandler handler : handlers) {
+            assertSame(handler, p.remove(handler.name));
 
-        assertTrue(handler1.flushed);
-        assertTrue(handler3.updated);
+            self.eventLoop().execute(new Runnable() {
+                @Override
+                public void run() {
+                    // Validate handler life-cycle methods called.
+                    handler.validate(true, true);
+                    removeLatch.countDown();
+                }
+            });
+        }
+        removeLatch.await();
     }
 
-    @Test(timeout = 10000)
-    public void testRemoveAndForwardInboundMessage() throws Exception {
-        final ChannelInboundMessageHandlerImpl handler1 = new ChannelInboundMessageHandlerImpl();
-        final ChannelInboundMessageHandlerImpl handler2 = new ChannelInboundMessageHandlerImpl();
+    @Test(timeout = 100000)
+    public void testRemoveAndForwardInbound() throws Exception {
+        final BufferedTestHandler handler1 = new BufferedTestHandler();
+        final BufferedTestHandler handler2 = new BufferedTestHandler();
 
         setUp(handler1, handler2);
 
@@ -502,42 +337,20 @@ public void testRemoveAndForwardInboundMessage() throws Exception {
             @Override
             public void run() {
                 ChannelPipeline p = self.pipeline();
-                p.context(handler1).inboundMessageBuffer().add(new Object());
-                assertEquals(1, p.context(handler1).inboundMessageBuffer().size());
-                assertEquals(0, p.context(handler2).inboundMessageBuffer().size());
+                handler1.inboundBuffer.add(8);
+                assertEquals(8, handler1.inboundBuffer.get(0));
+                assertTrue(handler2.inboundBuffer.isEmpty());
                 p.remove(handler1);
-                assertEquals(1, p.context(handler2).inboundMessageBuffer().size());
-            }
-        }).sync();
-
-        assertTrue(handler2.updated);
-    }
-
-    @Test(timeout = 10000)
-    public void testReplaceAndForwardInboundMessage() throws Exception {
-        final ChannelInboundMessageHandlerImpl handler1 = new ChannelInboundMessageHandlerImpl();
-        final ChannelInboundMessageHandlerImpl handler2 = new ChannelInboundMessageHandlerImpl();
-
-        setUp(handler1);
-
-        self.eventLoop().submit(new Runnable() {
-            @Override
-            public void run() {
-                ChannelPipeline p = self.pipeline();
-                p.context(handler1).inboundMessageBuffer().add(new Object());
-                assertEquals(1, p.context(handler1).inboundMessageBuffer().size());
-                p.replace(handler1, "handler2", handler2);
-                assertEquals(1, p.context(handler2).inboundMessageBuffer().size());
+                assertEquals(1, handler2.inboundBuffer.size());
+                assertEquals(8, handler2.inboundBuffer.get(0));
             }
         }).sync();
-
-        assertTrue(handler2.updated);
     }
 
     @Test(timeout = 10000)
-    public void testRemoveAndForwardOutboundMessage() throws Exception {
-        final ChannelOutboundMessageHandlerImpl handler1 = new ChannelOutboundMessageHandlerImpl();
-        final ChannelOutboundMessageHandlerImpl handler2 = new ChannelOutboundMessageHandlerImpl();
+    public void testRemoveAndForwardOutbound() throws Exception {
+        final BufferedTestHandler handler1 = new BufferedTestHandler();
+        final BufferedTestHandler handler2 = new BufferedTestHandler();
 
         setUp(handler1, handler2);
 
@@ -545,21 +358,20 @@ public void testRemoveAndForwardOutboundMessage() throws Exception {
             @Override
             public void run() {
                 ChannelPipeline p = self.pipeline();
-                p.context(handler2).outboundMessageBuffer().add(new Object());
-                assertEquals(1, p.context(handler2).outboundMessageBuffer().size());
-                assertEquals(0, p.context(handler1).outboundMessageBuffer().size());
+                handler2.outboundBuffer.add(8);
+                assertEquals(8, handler2.outboundBuffer.get(0));
+                assertTrue(handler1.outboundBuffer.isEmpty());
                 p.remove(handler2);
-                assertEquals(1, p.context(handler1).outboundMessageBuffer().size());
+                assertEquals(1, handler1.outboundBuffer.size());
+                assertEquals(8, handler1.outboundBuffer.get(0));
             }
         }).sync();
-
-        assertTrue(handler1.flushed);
     }
 
     @Test(timeout = 10000)
-    public void testReplaceAndForwardOutboundMessage() throws Exception {
-        final ChannelOutboundMessageHandlerImpl handler1 = new ChannelOutboundMessageHandlerImpl();
-        final ChannelOutboundMessageHandlerImpl handler2 = new ChannelOutboundMessageHandlerImpl();
+    public void testReplaceAndForwardOutbound() throws Exception {
+        final BufferedTestHandler handler1 = new BufferedTestHandler();
+        final BufferedTestHandler handler2 = new BufferedTestHandler();
 
         setUp(handler1);
 
@@ -567,20 +379,19 @@ public void testReplaceAndForwardOutboundMessage() throws Exception {
             @Override
             public void run() {
                 ChannelPipeline p = self.pipeline();
-                p.context(handler1).outboundMessageBuffer().add(new Object());
-                assertEquals(1, p.context(handler1).outboundMessageBuffer().size());
+                handler1.outboundBuffer.add(8);
+                assertEquals(8, handler1.outboundBuffer.get(0));
+                assertTrue(handler2.outboundBuffer.isEmpty());
                 p.replace(handler1, "handler2", handler2);
-                assertEquals(1, p.context(handler2).outboundMessageBuffer().size());
+                assertEquals(8, handler2.outboundBuffer.get(0));
             }
         }).sync();
-
-        assertTrue(handler2.flushed);
     }
 
     @Test(timeout = 10000)
-    public void testReplaceAndForwardDuplexMessage() throws Exception {
-        final MessageHandlerImpl handler1 = new MessageHandlerImpl();
-        final MessageHandlerImpl handler2 = new MessageHandlerImpl();
+    public void testReplaceAndForwardInboundAndOutbound() throws Exception {
+        final BufferedTestHandler handler1 = new BufferedTestHandler();
+        final BufferedTestHandler handler2 = new BufferedTestHandler();
 
         setUp(handler1);
 
@@ -588,27 +399,26 @@ public void testReplaceAndForwardDuplexMessage() throws Exception {
             @Override
             public void run() {
                 ChannelPipeline p = self.pipeline();
-                p.context(handler1).outboundMessageBuffer().add(new Object());
-                p.context(handler1).inboundMessageBuffer().add(new Object());
+                handler1.inboundBuffer.add(8);
+                handler1.outboundBuffer.add(8);
 
-                assertEquals(1, p.context(handler1).outboundMessageBuffer().size());
-                assertEquals(1, p.context(handler1).inboundMessageBuffer().size());
+                assertEquals(8, handler1.inboundBuffer.get(0));
+                assertEquals(8, handler1.outboundBuffer.get(0));
+                assertTrue(handler2.inboundBuffer.isEmpty());
+                assertTrue(handler2.outboundBuffer.isEmpty());
 
                 p.replace(handler1, "handler2", handler2);
-                assertEquals(1, p.context(handler2).outboundMessageBuffer().size());
-                assertEquals(1, p.context(handler2).inboundMessageBuffer().size());
+                assertEquals(8, handler2.outboundBuffer.get(0));
+                assertEquals(8, handler2.inboundBuffer.get(0));
             }
         }).sync();
-
-        assertTrue(((ChannelInboundMessageHandlerImpl) handler2.stateHandler()).updated);
-        assertTrue(((ChannelOutboundMessageHandlerImpl) handler2.operationHandler()).flushed);
     }
 
     @Test(timeout = 10000)
-    public void testRemoveAndForwardDuplexMessage() throws Exception {
-        final ChannelOutboundMessageHandlerImpl handler1 = new ChannelOutboundMessageHandlerImpl();
-        final MessageHandlerImpl handler2 = new MessageHandlerImpl();
-        final ChannelInboundMessageHandlerImpl handler3 = new ChannelInboundMessageHandlerImpl();
+    public void testRemoveAndForwardInboundOutbound() throws Exception {
+        final BufferedTestHandler handler1 = new BufferedTestHandler();
+        final BufferedTestHandler handler2 = new BufferedTestHandler();
+        final BufferedTestHandler handler3 = new BufferedTestHandler();
 
         setUp(handler1, handler2, handler3);
 
@@ -616,72 +426,20 @@ public void testRemoveAndForwardDuplexMessage() throws Exception {
             @Override
             public void run() {
                 ChannelPipeline p = self.pipeline();
-                p.context(handler2).outboundMessageBuffer().add(new Object());
-                p.context(handler2).inboundMessageBuffer().add(new Object());
+                handler2.inboundBuffer.add(8);
+                handler2.outboundBuffer.add(8);
 
-                assertEquals(1, p.context(handler2).outboundMessageBuffer().size());
-                assertEquals(1, p.context(handler2).inboundMessageBuffer().size());
+                assertEquals(8, handler2.inboundBuffer.get(0));
+                assertEquals(8, handler2.outboundBuffer.get(0));
 
-                assertEquals(0, p.context(handler1).outboundMessageBuffer().size());
-                assertEquals(0, p.context(handler3).inboundMessageBuffer().size());
+                assertEquals(0, handler1.outboundBuffer.size());
+                assertEquals(0, handler3.inboundBuffer.size());
 
                 p.remove(handler2);
-                assertEquals(1, p.context(handler1).outboundMessageBuffer().size());
-                assertEquals(1, p.context(handler3).inboundMessageBuffer().size());
+                assertEquals(8, handler3.inboundBuffer.get(0));
+                assertEquals(8, handler1.outboundBuffer.get(0));
             }
         }).sync();
-
-        assertTrue(handler1.flushed);
-        assertTrue(handler3.updated);
-    }
-
-    @Test(timeout = 10000)
-    public void testLifeCycleAwareness() throws Exception {
-        setUp();
-
-        ChannelPipeline p = self.pipeline();
-
-        final List<LifeCycleAwareTestHandler> handlers = new ArrayList<LifeCycleAwareTestHandler>();
-        final int COUNT = 20;
-        final CountDownLatch addLatch = new CountDownLatch(COUNT);
-        for (int i = 0; i < COUNT; i++) {
-            final LifeCycleAwareTestHandler handler = new LifeCycleAwareTestHandler("handler-" + i);
-
-            // Add handler.
-            p.addFirst(handler.name, handler);
-            self.eventLoop().execute(new Runnable() {
-                @Override
-                public void run() {
-                    // Validate handler life-cycle methods called.
-                    handler.validate(true, false);
-
-                    // Store handler into the list.
-                    handlers.add(handler);
-
-                    addLatch.countDown();
-                }
-            });
-        }
-        addLatch.await();
-
-        // Change the order of remove operations over all handlers in the pipeline.
-        Collections.shuffle(handlers);
-
-        final CountDownLatch removeLatch = new CountDownLatch(COUNT);
-
-        for (final LifeCycleAwareTestHandler handler : handlers) {
-            assertSame(handler, p.remove(handler.name));
-
-            self.eventLoop().execute(new Runnable() {
-                @Override
-                public void run() {
-                    // Validate handler life-cycle methods called.
-                    handler.validate(true, true);
-                    removeLatch.countDown();
-                }
-            });
-        }
-        removeLatch.await();
     }
 
     private static int next(DefaultChannelHandlerContext ctx) {
@@ -727,109 +485,37 @@ private static ChannelHandler newHandler() {
     }
 
     @Sharable
-    private static class TestHandler extends ChannelDuplexHandler {
-        @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-            ctx.flush(promise);
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-            ctx.fireInboundBufferUpdated();
-        }
-    }
-
-    private static final class ChannelInboundByteHandlerImpl extends ChannelInboundByteHandlerAdapter {
-        boolean updated;
-
-        @Override
-        protected void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
-            updated = true;
-        }
-    }
-
-    private static final class ChannelOutboundByteHandlerImpl extends ChannelOutboundByteHandlerAdapter {
-        boolean flushed;
-
-        @Override
-        protected void flush(ChannelHandlerContext ctx, ByteBuf in, ChannelPromise promise) throws Exception {
-            promise.setSuccess();
-            flushed = true;
-        }
-    }
-
-    private static final class ChannelInboundMessageHandlerImpl extends ChannelStateHandlerAdapter
-            implements ChannelInboundMessageHandler<Object> {
-        boolean updated;
-        @Override
-        public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-            updated = true;
-        }
-    }
-
-    private static final class ChannelOutboundMessageHandlerImpl extends ChannelOperationHandlerAdapter
-            implements ChannelOutboundMessageHandler<Object> {
-        boolean flushed;
-        @Override
-        public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-            promise.setSuccess();
-            flushed = true;
-        }
-    }
+    private static class TestHandler extends ChannelDuplexHandler { }
 
-    private static final class ByteHandlerImpl extends CombinedChannelDuplexHandler
-            implements ChannelInboundByteHandler, ChannelOutboundByteHandler {
-        ByteHandlerImpl() {
-            super(new ChannelInboundByteHandlerImpl(), new ChannelOutboundByteHandlerImpl());
-        }
+    private static class BufferedTestHandler extends ChannelDuplexHandler {
+        final MessageList<Object> inboundBuffer = MessageList.newInstance();
+        final MessageList<Object> outboundBuffer = MessageList.newInstance();
 
         @Override
-        public ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ((ChannelInboundByteHandler) stateHandler()).newInboundBuffer(ctx);
-        }
-
-        @Override
-        public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-            ((ChannelInboundByteHandler) stateHandler()).discardInboundReadBytes(ctx);
-        }
-
-        @Override
-        public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ((ChannelOutboundByteHandler) operationHandler()).newOutboundBuffer(ctx);
-        }
-
-        @Override
-        public void discardOutboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-            ((ChannelOutboundByteHandler) operationHandler()).discardOutboundReadBytes(ctx);
-        }
-    }
-
-    private static final class MessageHandlerImpl extends CombinedChannelDuplexHandler
-            implements ChannelInboundMessageHandler<Object>, ChannelOutboundMessageHandler<Object> {
-        MessageHandlerImpl() {
-            super(new ChannelInboundMessageHandlerImpl(), new ChannelOutboundMessageHandlerImpl());
+        public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise)
+                throws Exception {
+            for (int i = 0; i < msgs.size(); i++) {
+                outboundBuffer.add(msgs.get(i));
+            }
+            msgs.recycle();
         }
 
-        @SuppressWarnings("unchecked")
         @Override
-        public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ((ChannelInboundMessageHandler<Object>) stateHandler()).newInboundBuffer(ctx);
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i++) {
+                inboundBuffer.add(msgs.get(i));
+            }
+            msgs.recycle();
         }
 
-        @SuppressWarnings("unchecked")
         @Override
-        public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ((ChannelOutboundMessageHandler<Object>) operationHandler()).newOutboundBuffer(ctx);
+        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+            if (!inboundBuffer.isEmpty()) {
+                ctx.fireMessageReceived(inboundBuffer);
+            }
+            if (!outboundBuffer.isEmpty()) {
+                ctx.write(outboundBuffer);
+            }
         }
     }
 
diff --git a/transport/src/test/java/io/netty/channel/group/DefaultChannnelGroupTest.java b/transport/src/test/java/io/netty/channel/group/DefaultChannnelGroupTest.java
index 99876ae26600..2681e6bc8150 100644
--- a/transport/src/test/java/io/netty/channel/group/DefaultChannnelGroupTest.java
+++ b/transport/src/test/java/io/netty/channel/group/DefaultChannnelGroupTest.java
@@ -18,33 +18,30 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelStateHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.util.concurrent.GlobalEventExecutor;
 import org.junit.Test;
 
 public class DefaultChannnelGroupTest {
 
     // Test for #1183
     @Test
-    public void testNotThrowBlockingOperationException() {
+    public void testNotThrowBlockingOperationException() throws Exception {
         EventLoopGroup bossGroup = new NioEventLoopGroup();
         EventLoopGroup workerGroup = new NioEventLoopGroup();
 
-        final ChannelGroup allChannels = new DefaultChannelGroup();
+        final ChannelGroup allChannels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
 
         ServerBootstrap b = new ServerBootstrap();
         b.group(bossGroup, workerGroup);
-        b.childHandler(new ChannelStateHandlerAdapter() {
+        b.childHandler(new ChannelInboundHandlerAdapter() {
             @Override
             public void channelActive(ChannelHandlerContext ctx) {
                 allChannels.add(ctx.channel());
             }
-
-            @Override
-            public void inboundBufferUpdated(ChannelHandlerContext ctx) {
-            }
         });
         b.channel(NioServerSocketChannel.class);
 
@@ -57,5 +54,7 @@ public void inboundBufferUpdated(ChannelHandlerContext ctx) {
 
         bossGroup.shutdownGracefully();
         workerGroup.shutdownGracefully();
+        bossGroup.terminationFuture().sync();
+        workerGroup.terminationFuture().sync();
     }
 }
diff --git a/transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java b/transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
index 17a1bc9393ce..13f43c7089b6 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalChannelRegistryTest.java
@@ -19,9 +19,10 @@
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.EventLoopGroup;
+import io.netty.channel.MessageList;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.junit.Test;
@@ -70,8 +71,7 @@ public void initChannel(LocalChannel ch) throws Exception {
                 @Override
                 public void run() {
                     // Send a message event up the pipeline.
-                    cc.pipeline().inboundMessageBuffer().add("Hello, World");
-                    cc.pipeline().fireInboundBufferUpdated();
+                    cc.pipeline().fireMessageReceived("Hello, World");
                     latch.countDown();
                 }
             });
@@ -88,13 +88,18 @@ public void run() {
             assertNull(String.format(
                     "Expected null, got channel '%s' for local address '%s'",
                     LocalChannelRegistry.get(addr), addr), LocalChannelRegistry.get(addr));
+
+            serverGroup.terminationFuture().sync();
+            clientGroup.terminationFuture().sync();
         }
     }
 
-    static class TestHandler extends ChannelInboundMessageHandlerAdapter<String> {
+    static class TestHandler extends ChannelInboundHandlerAdapter {
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, String msg) throws Exception {
-            logger.info(String.format("Received mesage: %s", msg));
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            for (int i = 0; i < msgs.size(); i ++) {
+                logger.info(String.format("Received mesage: %s", msgs.get(i)));
+            }
         }
     }
 }
diff --git a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
index 01c741d756ab..29381476dfe7 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest.java
@@ -17,20 +17,14 @@
 
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.MessageBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerUtil;
-import io.netty.channel.ChannelInboundByteHandler;
-import io.netty.channel.ChannelInboundMessageHandler;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOutboundByteHandler;
-import io.netty.channel.ChannelOutboundMessageHandler;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoopGroup;
+import io.netty.channel.MessageList;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
 import io.netty.util.concurrent.DefaultThreadFactory;
 import io.netty.util.concurrent.EventExecutorGroup;
@@ -44,7 +38,6 @@
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
 public class LocalTransportThreadModelTest {
@@ -62,9 +55,9 @@ public static void init() {
           .childHandler(new ChannelInitializer<LocalChannel>() {
               @Override
               public void initChannel(LocalChannel ch) throws Exception {
-                  ch.pipeline().addLast(new ChannelInboundMessageHandlerAdapter<Object>() {
+                  ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                     @Override
-                    public void messageReceived(ChannelHandlerContext ctx, Object msg) {
+                    public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) {
                         // Discard
                     }
                   });
@@ -75,8 +68,8 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) {
     }
 
     @AfterClass
-    public static void destroy() {
-        group.shutdownGracefully();
+    public static void destroy() throws Exception {
+        group.shutdownGracefully().sync();
     }
 
     @Test(timeout = 30000)
@@ -107,15 +100,15 @@ public void testStagedExecution() throws Throwable {
         l.register(ch).sync().channel().connect(localAddr).sync();
 
         // Fire inbound events from all possible starting points.
-        ch.pipeline().fireInboundBufferUpdated();
-        ch.pipeline().context(h1).fireInboundBufferUpdated();
-        ch.pipeline().context(h2).fireInboundBufferUpdated();
-        ch.pipeline().context(h3).fireInboundBufferUpdated();
+        ch.pipeline().fireMessageReceived("1");
+        ch.pipeline().context(h1).fireMessageReceived("2");
+        ch.pipeline().context(h2).fireMessageReceived("3");
+        ch.pipeline().context(h3).fireMessageReceived("4");
         // Fire outbound events from all possible starting points.
-        ch.pipeline().flush();
-        ch.pipeline().context(h3).flush();
-        ch.pipeline().context(h2).flush();
-        ch.pipeline().context(h1).flush().sync();
+        ch.pipeline().write("5");
+        ch.pipeline().context(h3).write("6");
+        ch.pipeline().context(h2).write("7");
+        ch.pipeline().context(h1).write("8").sync();
 
         ch.close().sync();
 
@@ -222,14 +215,14 @@ public void testStagedExecution() throws Throwable {
             l.shutdownGracefully();
             e1.shutdownGracefully();
             e2.shutdownGracefully();
-            l.awaitTermination(5, TimeUnit.SECONDS);
-            e1.awaitTermination(5, TimeUnit.SECONDS);
-            e2.awaitTermination(5, TimeUnit.SECONDS);
+
+            l.terminationFuture().sync();
+            e1.terminationFuture().sync();
+            e2.terminationFuture().sync();
         }
     }
 
     @Test(timeout = 30000)
-    @Ignore("regression test")
     public void testConcurrentMessageBufferAccess() throws Throwable {
         EventLoopGroup l = new LocalEventLoopGroup(4, new DefaultThreadFactory("l"));
         EventExecutorGroup e1 = new DefaultEventExecutorGroup(4, new DefaultThreadFactory("e1"));
@@ -270,11 +263,11 @@ public void testConcurrentMessageBufferAccess() throws Throwable {
                 ch.eventLoop().execute(new Runnable() {
                     @Override
                     public void run() {
-                        MessageBuf<Object> buf = ch.pipeline().inboundMessageBuffer();
+                        MessageList<Object> msgs = MessageList.newInstance(end - start);
                         for (int j = start; j < end; j ++) {
-                            buf.add(Integer.valueOf(j));
+                            msgs.add(Integer.valueOf(j));
                         }
-                        ch.pipeline().fireInboundBufferUpdated();
+                        ch.pipeline().fireMessageReceived(msgs);
                     }
                 });
             }
@@ -310,11 +303,12 @@ public void run() {
                 ch.pipeline().context(h6).executor().execute(new Runnable() {
                     @Override
                     public void run() {
-                        MessageBuf<Object> buf = ch.pipeline().outboundMessageBuffer();
+                        MessageList<Object> msgs = MessageList.newInstance(end - start);
                         for (int j = start; j < end; j ++) {
-                            buf.add(Integer.valueOf(j));
+                            msgs.add(Integer.valueOf(j));
                         }
-                        ch.pipeline().flush();
+
+                        ch.pipeline().write(msgs);
                     }
                 });
             }
@@ -350,13 +344,17 @@ public void run() {
             e3.shutdownGracefully();
             e4.shutdownGracefully();
             e5.shutdownGracefully();
+
+            l.terminationFuture().sync();
+            e1.terminationFuture().sync();
+            e2.terminationFuture().sync();
+            e3.terminationFuture().sync();
+            e4.terminationFuture().sync();
+            e5.terminationFuture().sync();
         }
     }
 
-    private static class ThreadNameAuditor
-            extends ChannelDuplexHandler
-            implements ChannelInboundMessageHandler<Object>,
-                       ChannelOutboundMessageHandler<Object> {
+    private static class ThreadNameAuditor extends ChannelDuplexHandler {
 
         private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
 
@@ -364,40 +362,21 @@ private static class ThreadNameAuditor
         private final Queue<String> outboundThreadNames = new ConcurrentLinkedQueue<String>();
         private final Queue<String> removalThreadNames = new ConcurrentLinkedQueue<String>();
 
-        @Override
-        public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
         @Override
         public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
             removalThreadNames.add(Thread.currentThread().getName());
         }
 
         @Override
-        public void inboundBufferUpdated(
-                ChannelHandlerContext ctx) throws Exception {
-            ctx.inboundMessageBuffer().clear();
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
             inboundThreadNames.add(Thread.currentThread().getName());
-            ctx.fireInboundBufferUpdated();
+            ctx.fireMessageReceived(msgs);
         }
 
         @Override
-        public void read(ChannelHandlerContext ctx) {
-            ctx.read();
-        }
-
-        @Override
-        public void flush(ChannelHandlerContext ctx,
-                          ChannelPromise future) throws Exception {
-            ctx.outboundMessageBuffer().clear();
+        public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise future) throws Exception {
             outboundThreadNames.add(Thread.currentThread().getName());
-            ctx.flush(future);
+            ctx.write(msgs, future);
         }
 
         @Override
@@ -413,8 +392,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
      * Converts integers into a binary stream.
      */
     private static class MessageForwarder1
-            extends ChannelDuplexHandler
-            implements ChannelInboundMessageHandler<Integer>, ChannelOutboundByteHandler {
+            extends ChannelDuplexHandler {
 
         private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         private volatile int inCnt;
@@ -422,23 +400,7 @@ private static class MessageForwarder1
         private volatile Thread t;
 
         @Override
-        public MessageBuf<Integer> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public ByteBuf newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return ChannelHandlerUtil.allocate(ctx);
-        }
-
-        @Override
-        public void discardOutboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-            // NOOP
-        }
-
-        @Override
-        public void inboundBufferUpdated(
-                ChannelHandlerContext ctx) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
             Thread t = this.t;
             if (t == null) {
                 this.t = Thread.currentThread();
@@ -446,55 +408,44 @@ public void inboundBufferUpdated(
                 Assert.assertSame(t, Thread.currentThread());
             }
 
-            MessageBuf<Integer> in = ctx.inboundMessageBuffer();
-            ByteBuf out = ctx.nextInboundByteBuffer();
-
-            for (;;) {
-                Integer msg = in.poll();
-                if (msg == null) {
-                    break;
-                }
+            ByteBuf out = ctx.alloc().buffer(msgs.size() * 4);
 
+            for (int i = 0; i < msgs.size(); i ++) {
+                int m = ((Integer) msgs.get(i)).intValue();
                 int expected = inCnt ++;
-                Assert.assertEquals(expected, msg.intValue());
-                if (out.maxCapacity() - out.writerIndex() < 4) {
-                    // Next inbound buffer is full - attempt to flush some data.
-                    ctx.fireInboundBufferUpdated();
-                }
-                out.writeInt(msg);
+                Assert.assertEquals(expected, m);
+                out.writeInt(m);
             }
 
-            ctx.fireInboundBufferUpdated();
+            ctx.fireMessageReceived(out);
         }
 
         @Override
-        public void read(ChannelHandlerContext ctx) {
-            ctx.read();
-        }
-
-        @Override
-        public void flush(ChannelHandlerContext ctx,
-                ChannelPromise future) throws Exception {
+        public void write(ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise future) throws Exception {
             Assert.assertSame(t, Thread.currentThread());
 
             // Don't let the write request go to the server-side channel - just swallow.
             boolean swallow = this == ctx.pipeline().first();
 
-            ByteBuf in = ctx.outboundByteBuffer();
-            MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-            while (in.readableBytes() >= 4) {
-                int msg = in.readInt();
-                int expected = outCnt ++;
-                Assert.assertEquals(expected, msg);
-                if (!swallow) {
-                    out.add(msg);
+            for (int i = 0; i < msgs.size(); i ++) {
+                ByteBuf m = (ByteBuf) msgs.get(i);
+                int count = m.readableBytes() / 4;
+                MessageList<Integer> out = MessageList.newInstance(count);
+                for (int j = 0; j < count; j ++) {
+                    int actual = m.readInt();
+                    int expected = outCnt ++;
+                    Assert.assertEquals(expected, actual);
+                    if (!swallow) {
+                        out.add(actual);
+                    }
+                }
+                m.release();
+
+                if (swallow) {
+                    future.setSuccess();
+                } else {
+                    ctx.write(out);
                 }
-            }
-            in.discardSomeReadBytes();
-            if (swallow) {
-                future.setSuccess();
-            } else {
-                ctx.flush(future);
             }
         }
 
@@ -510,9 +461,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     /**
      * Converts a binary stream into integers.
      */
-    private static class MessageForwarder2
-            extends ChannelDuplexHandler
-            implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<Integer> {
+    private static class MessageForwarder2 extends ChannelDuplexHandler {
 
         private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         private volatile int inCnt;
@@ -520,25 +469,7 @@ private static class MessageForwarder2
         private volatile Thread t;
 
         @Override
-        public ByteBuf newInboundBuffer(
-                ChannelHandlerContext ctx) throws Exception {
-            return ctx.alloc().buffer();
-        }
-
-        @Override
-        public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {
-            ctx.inboundByteBuffer().discardSomeReadBytes();
-        }
-
-        @Override
-        public MessageBuf<Integer> newOutboundBuffer(
-                ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public void inboundBufferUpdated(
-                ChannelHandlerContext ctx) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
             Thread t = this.t;
             if (t == null) {
                 this.t = Thread.currentThread();
@@ -546,49 +477,35 @@ public void inboundBufferUpdated(
                 Assert.assertSame(t, Thread.currentThread());
             }
 
-            ByteBuf in = ctx.inboundByteBuffer();
-            MessageBuf<Object> out = ctx.nextInboundMessageBuffer();
-            while (in.readableBytes() >= 4) {
-                int msg = in.readInt();
-                int expected = inCnt ++;
-                Assert.assertEquals(expected, msg);
-                out.add(msg);
+            for (int i = 0; i < msgs.size(); i ++) {
+                ByteBuf m = (ByteBuf) msgs.get(i);
+                int count = m.readableBytes() / 4;
+                MessageList<Integer> out = MessageList.newInstance(count);
+                for (int j = 0; j < count; j ++) {
+                    int actual = m.readInt();
+                    int expected = inCnt ++;
+                    Assert.assertEquals(expected, actual);
+                    out.add(actual);
+                }
+                m.release();
+                ctx.fireMessageReceived(out);
             }
-            in.discardReadBytes();
-            ctx.fireInboundBufferUpdated();
         }
 
         @Override
-        public void read(ChannelHandlerContext ctx) {
-            ctx.read();
-        }
-
-        @Override
-        public void flush(final ChannelHandlerContext ctx,
-                ChannelPromise future) throws Exception {
+        public void write(
+                ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
             Assert.assertSame(t, Thread.currentThread());
 
-            MessageBuf<Integer> in = ctx.outboundMessageBuffer();
-            ByteBuf out = ctx.nextOutboundByteBuffer();
-
-            for (;;) {
-                Integer msg = in.poll();
-                if (msg == null) {
-                    break;
-                }
-
+            ByteBuf out = ctx.alloc().buffer(msgs.size() * 4);
+            for (int i = 0; i < msgs.size(); i ++) {
+                int m = (Integer) msgs.get(i);
                 int expected = outCnt ++;
-                Assert.assertEquals(expected, msg.intValue());
-
-                if (out.maxCapacity() - out.writerIndex() < 4) {
-                    // Next outbound buffer is full - attempt to flush some data.
-                    ctx.flush();
-                }
-
-                out.writeInt(msg);
+                Assert.assertEquals(expected, m);
+                out.writeInt(m);
             }
 
-            ctx.flush(future);
+            ctx.write(out);
         }
 
         @Override
@@ -603,9 +520,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     /**
      * Simply forwards the received object to the next handler.
      */
-    private static class MessageForwarder3
-            extends ChannelDuplexHandler
-            implements ChannelInboundMessageHandler<Object>, ChannelOutboundMessageHandler<Object> {
+    private static class MessageForwarder3 extends ChannelDuplexHandler {
 
         private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         private volatile int inCnt;
@@ -613,17 +528,7 @@ private static class MessageForwarder3
         private volatile Thread t;
 
         @Override
-        public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
             Thread t = this.t;
             if (t == null) {
                 this.t = Thread.currentThread();
@@ -631,44 +536,25 @@ public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
                 Assert.assertSame(t, Thread.currentThread());
             }
 
-            MessageBuf<Object> in = ctx.inboundMessageBuffer();
-            MessageBuf<Object> out = ctx.nextInboundMessageBuffer();
-            for (;;) {
-                Object msg = in.poll();
-                if (msg == null) {
-                    break;
-                }
-
+            for (int i = 0; i < msgs.size(); i ++) {
+                int actual = (Integer) msgs.get(i);
                 int expected = inCnt ++;
-                Assert.assertEquals(expected, msg);
-                out.add(msg);
+                Assert.assertEquals(expected, actual);
             }
-            ctx.fireInboundBufferUpdated();
-        }
-
-        @Override
-        public void read(ChannelHandlerContext ctx) {
-            ctx.read();
+            ctx.fireMessageReceived(msgs);
         }
 
         @Override
-        public void flush(ChannelHandlerContext ctx,
-                ChannelPromise future) throws Exception {
+        public void write(
+                ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
             Assert.assertSame(t, Thread.currentThread());
 
-            MessageBuf<Object> in = ctx.outboundMessageBuffer();
-            MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-            for (;;) {
-                Object msg = in.poll();
-                if (msg == null) {
-                    break;
-                }
-
+            for (int i = 0; i < msgs.size(); i ++) {
+                int actual = (Integer) msgs.get(i);
                 int expected = outCnt ++;
-                Assert.assertEquals(expected, msg);
-                out.add(msg);
+                Assert.assertEquals(expected, actual);
             }
-            ctx.flush(future);
+            ctx.write(msgs, promise);
         }
 
         @Override
@@ -683,9 +569,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
     /**
      * Discards all received messages.
      */
-    private static class MessageDiscarder
-            extends ChannelDuplexHandler
-            implements ChannelInboundMessageHandler<Object>, ChannelOutboundMessageHandler<Object> {
+    private static class MessageDiscarder extends ChannelDuplexHandler {
 
         private final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
         private volatile int inCnt;
@@ -693,17 +577,7 @@ private static class MessageDiscarder
         private volatile Thread t;
 
         @Override
-        public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {
-            return Unpooled.messageBuffer();
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
             Thread t = this.t;
             if (t == null) {
                 this.t = Thread.currentThread();
@@ -711,40 +585,24 @@ public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
                 Assert.assertSame(t, Thread.currentThread());
             }
 
-            MessageBuf<Object> in = ctx.inboundMessageBuffer();
-            for (;;) {
-                Object msg = in.poll();
-                if (msg == null) {
-                    break;
-                }
+            for (int i = 0; i < msgs.size(); i ++) {
+                int actual = (Integer) msgs.get(i);
                 int expected = inCnt ++;
-                Assert.assertEquals(expected, msg);
+                Assert.assertEquals(expected, actual);
             }
         }
 
         @Override
-        public void read(ChannelHandlerContext ctx) {
-            ctx.read();
-        }
-
-        @Override
-        public void flush(ChannelHandlerContext ctx,
-                ChannelPromise future) throws Exception {
+        public void write(
+                ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
             Assert.assertSame(t, Thread.currentThread());
 
-            MessageBuf<Object> in = ctx.outboundMessageBuffer();
-            MessageBuf<Object> out = ctx.nextOutboundMessageBuffer();
-            for (;;) {
-                Object msg = in.poll();
-                if (msg == null) {
-                    break;
-                }
-
+            for (int i = 0; i < msgs.size(); i ++) {
+                int actual = (Integer) msgs.get(i);
                 int expected = outCnt ++;
-                Assert.assertEquals(expected, msg);
-                out.add(msg);
+                Assert.assertEquals(expected, actual);
             }
-            ctx.flush(future);
+            ctx.write(msgs, promise);
         }
 
         @Override
diff --git a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java
index fba75ce1355c..174bf7e0414b 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest2.java
@@ -17,15 +17,14 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.buffer.MessageBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MessageList;
 import org.junit.Test;
 
-import java.util.Iterator;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.junit.Assert.*;
@@ -73,30 +72,11 @@ public void testSocketReuse() throws InterruptedException {
     public void close(final Channel localChannel, final LocalHander localRegistrationHandler) {
         // we want to make sure we actually shutdown IN the event loop
         if (localChannel.eventLoop().inEventLoop()) {
-            MessageBuf<Object> outboundMessageBuffer =
-                    localChannel.pipeline().outboundMessageBuffer();
-            if (!outboundMessageBuffer.isEmpty()) {
-                System.err.println("NOT EMPTY TO SEND!");
-            }
-
             // Wait until all messages are flushed before closing the channel.
             if (localRegistrationHandler.lastWriteFuture != null) {
                 localRegistrationHandler.lastWriteFuture.awaitUninterruptibly();
             }
 
-            MessageBuf<Object> inboundMessageBuffer =
-                    localChannel.pipeline().inboundMessageBuffer();
-            if (!inboundMessageBuffer.isEmpty()) {
-                // sometimes we close the pipeline before everything on it has been notified/received.
-                // we want these messages, since they are in our queue.
-                Iterator<Object> iterator = inboundMessageBuffer.iterator();
-                while (iterator.hasNext()) {
-                    Object next = iterator.next();
-                    System.err.println("DEFERRED on close: " + next);
-                    iterator.remove();
-                }
-            }
-
             localChannel.close();
             return;
         }
@@ -113,7 +93,7 @@ public void run() {
     }
 
     @Sharable
-    static class LocalHander extends ChannelInboundMessageHandlerAdapter<Object> {
+    static class LocalHander extends ChannelInboundHandlerAdapter {
         private final String name;
 
         public volatile ChannelFuture lastWriteFuture;
@@ -132,8 +112,9 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception {
-            count.incrementAndGet();
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
+            count.addAndGet(msgs.size());
+            msgs.recycle();
         }
     }
 }
diff --git a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java
index ccc01297b278..8c8d39b06cba 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalTransportThreadModelTest3.java
@@ -20,10 +20,11 @@
 import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoopGroup;
+import io.netty.channel.MessageList;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
 import io.netty.util.concurrent.DefaultThreadFactory;
 import io.netty.util.concurrent.EventExecutorGroup;
@@ -50,8 +51,8 @@ enum EventType {
         ACTIVE,
         UNREGISTERED,
         REGISTERED,
-        INBOUND_BUFFER_UPDATED,
-        FLUSH,
+        MESSAGE_RECEIVED,
+        WRITE,
         READ
     }
 
@@ -68,9 +69,10 @@ public static void init() {
                 .childHandler(new ChannelInitializer<LocalChannel>() {
                     @Override
                     public void initChannel(LocalChannel ch) throws Exception {
-                        ch.pipeline().addLast(new ChannelInboundMessageHandlerAdapter<Object>() {
+                        ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                             @Override
-                            public void messageReceived(ChannelHandlerContext ctx, Object msg) {
+                            public void messageReceived(
+                                    ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
                                 // Discard
                             }
                         });
@@ -81,8 +83,8 @@ public void messageReceived(ChannelHandlerContext ctx, Object msg) {
     }
 
     @AfterClass
-    public static void destroy() {
-        group.shutdownGracefully();
+    public static void destroy() throws Exception {
+        group.shutdownGracefully().sync();
     }
 
     @Test(timeout = 60000)
@@ -176,8 +178,8 @@ public void run() {
                     case EXCEPTION_CAUGHT:
                         ch.pipeline().fireExceptionCaught(cause);
                         break;
-                    case INBOUND_BUFFER_UPDATED:
-                        ch.pipeline().fireInboundBufferUpdated();
+                    case MESSAGE_RECEIVED:
+                        ch.pipeline().fireMessageReceived("");
                         break;
                     case READ_SUSPEND:
                         ch.pipeline().fireChannelReadSuspended();
@@ -185,8 +187,8 @@ public void run() {
                     case USER_EVENT:
                         ch.pipeline().fireUserEventTriggered("");
                         break;
-                    case FLUSH:
-                        ch.pipeline().flush();
+                    case WRITE:
+                        ch.pipeline().write("");
                         break;
                     case READ:
                         ch.pipeline().read();
@@ -220,6 +222,13 @@ public void run() {
             e3.shutdownGracefully();
             e4.shutdownGracefully();
             e5.shutdownGracefully();
+
+            l.terminationFuture().sync();
+            e1.terminationFuture().sync();
+            e2.terminationFuture().sync();
+            e3.terminationFuture().sync();
+            e4.terminationFuture().sync();
+            e5.terminationFuture().sync();
         }
     }
 
@@ -227,11 +236,11 @@ private static LinkedList<EventType> events(boolean inbound, int size) {
         EventType[] events;
         if (inbound) {
             events = new EventType[] {
-                    EventType.USER_EVENT, EventType.INBOUND_BUFFER_UPDATED, EventType.READ_SUSPEND,
+                    EventType.USER_EVENT, EventType.MESSAGE_RECEIVED, EventType.READ_SUSPEND,
                     EventType.EXCEPTION_CAUGHT};
         } else {
             events = new EventType[] {
-                    EventType.READ, EventType.FLUSH, EventType.EXCEPTION_CAUGHT };
+                    EventType.READ, EventType.WRITE, EventType.EXCEPTION_CAUGHT };
         }
 
         Random random = new Random();
@@ -243,17 +252,7 @@ private static LinkedList<EventType> events(boolean inbound, int size) {
     }
 
     @ChannelHandler.Sharable
-    private static final class EventForwarder extends ChannelDuplexHandler {
-        @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
-            ctx.flush(promise);
-        }
-
-        @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
-            ctx.fireInboundBufferUpdated();
-        }
-    }
+    private static final class EventForwarder extends ChannelDuplexHandler { }
 
     private static final class EventRecorder extends ChannelDuplexHandler {
         private final Queue<EventType> events;
@@ -304,16 +303,17 @@ public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
         }
 
         @Override
-        public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {
+        public void messageReceived(ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
             if (inbound) {
-                events.add(EventType.INBOUND_BUFFER_UPDATED);
+                events.add(EventType.MESSAGE_RECEIVED);
             }
         }
 
         @Override
-        public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
+        public void write(
+                ChannelHandlerContext ctx, MessageList<Object> msgs, ChannelPromise promise) throws Exception {
             if (!inbound) {
-                events.add(EventType.FLUSH);
+                events.add(EventType.WRITE);
             }
         }
 
diff --git a/transport/src/test/java/io/netty/channel/nio/NioDatagramChannelTest.java b/transport/src/test/java/io/netty/channel/nio/NioDatagramChannelTest.java
index 283b37fd3b37..7f20b876ae84 100644
--- a/transport/src/test/java/io/netty/channel/nio/NioDatagramChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/nio/NioDatagramChannelTest.java
@@ -17,12 +17,13 @@
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundMessageHandlerAdapter;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelOption;
+import io.netty.channel.MessageList;
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.channel.socket.DatagramChannel;
-import io.netty.channel.socket.DatagramPacket;
 import io.netty.channel.socket.nio.NioDatagramChannel;
+import io.netty.util.concurrent.GlobalEventExecutor;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -35,18 +36,18 @@ public class NioDatagramChannelTest {
      * Test try to reproduce issue #1335
      */
     @Test
-    public void testBindMultiple() {
-        DefaultChannelGroup channelGroup = new DefaultChannelGroup();
+    public void testBindMultiple() throws Exception {
+        DefaultChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
         NioEventLoopGroup group = new NioEventLoopGroup();
         try {
             for (int i = 0; i < 100; i++) {
                 Bootstrap udpBootstrap = new Bootstrap();
                 udpBootstrap.group(group).channel(NioDatagramChannel.class)
                         .option(ChannelOption.SO_BROADCAST, true)
-                        .handler(new ChannelInboundMessageHandlerAdapter<DatagramPacket>() {
+                        .handler(new ChannelInboundHandlerAdapter() {
                             @Override
-                            public void messageReceived(ChannelHandlerContext ctx, DatagramPacket msg)
-                                    throws Exception {
+                            public void messageReceived(
+                                    ChannelHandlerContext ctx, MessageList<Object> msgs) throws Exception {
                                 // noop
                             }
                         });
@@ -56,8 +57,8 @@ public void messageReceived(ChannelHandlerContext ctx, DatagramPacket msg)
             }
             Assert.assertEquals(100, channelGroup.size());
         } finally {
-            channelGroup.close().syncUninterruptibly();
-            group.shutdownGracefully();
+            channelGroup.close().sync();
+            group.shutdownGracefully().sync();
         }
     }
 }