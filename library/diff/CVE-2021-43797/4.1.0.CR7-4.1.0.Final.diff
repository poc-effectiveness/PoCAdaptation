diff --git a/all/pom.xml b/all/pom.xml
index f46c8debfd21..17c0fa46aafd 100644
--- a/all/pom.xml
+++ b/all/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-all</artifactId>
diff --git a/buffer/pom.xml b/buffer/pom.xml
index d65879f1e3ea..7dec877336c8 100644
--- a/buffer/pom.xml
+++ b/buffer/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-buffer</artifactId>
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
index f6872e9d8472..5b1d29c347c6 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
@@ -16,6 +16,7 @@
 package io.netty.buffer;
 
 import io.netty.util.ByteProcessor;
+import io.netty.util.CharsetUtil;
 import io.netty.util.IllegalReferenceCountException;
 import io.netty.util.ResourceLeakDetector;
 import io.netty.util.internal.PlatformDependent;
@@ -57,11 +58,8 @@ public abstract class AbstractByteBuf extends ByteBuf {
     int writerIndex;
     private int markedReaderIndex;
     private int markedWriterIndex;
-
     private int maxCapacity;
 
-    private SwappedByteBuf swappedBuf;
-
     protected AbstractByteBuf(int maxCapacity) {
         if (maxCapacity < 0) {
             throw new IllegalArgumentException("maxCapacity: " + maxCapacity + " (expected: >= 0)");
@@ -69,6 +67,20 @@ protected AbstractByteBuf(int maxCapacity) {
         this.maxCapacity = maxCapacity;
     }
 
+    @Override
+    public boolean isReadOnly() {
+        return false;
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public ByteBuf asReadOnly() {
+        if (isReadOnly()) {
+            return this;
+        }
+        return Unpooled.unmodifiableBuffer(this);
+    }
+
     @Override
     public int maxCapacity() {
         return maxCapacity;
@@ -308,12 +320,7 @@ public ByteBuf order(ByteOrder endianness) {
         if (endianness == order()) {
             return this;
         }
-
-        SwappedByteBuf swappedBuf = this.swappedBuf;
-        if (swappedBuf == null) {
-            this.swappedBuf = swappedBuf = newSwappedByteBuf();
-        }
-        return swappedBuf;
+        return newSwappedByteBuf();
     }
 
     /**
@@ -477,6 +484,19 @@ public ByteBuf getBytes(int index, ByteBuf dst, int length) {
         return this;
     }
 
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        // TODO: We could optimize this for UTF8 and US_ASCII
+        return toString(index, length, charset);
+    }
+
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        CharSequence sequence = getCharSequence(readerIndex, length, charset);
+        readerIndex += length;
+        return sequence;
+    }
+
     @Override
     public ByteBuf setByte(int index, int value) {
         checkIndex(index);
@@ -643,6 +663,23 @@ public ByteBuf setZero(int index, int length) {
         return this;
     }
 
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        if (charset.equals(CharsetUtil.UTF_8)) {
+            ensureWritable(ByteBufUtil.utf8MaxBytes(sequence));
+            return ByteBufUtil.writeUtf8(this, index, sequence, sequence.length());
+        }
+        if (charset.equals(CharsetUtil.US_ASCII)) {
+            int len = sequence.length();
+            ensureWritable(len);
+            return ByteBufUtil.writeAscii(this, index, sequence, len);
+        }
+        byte[] bytes = sequence.toString().getBytes(charset);
+        ensureWritable(bytes.length);
+        setBytes(index, bytes);
+        return bytes.length;
+    }
+
     @Override
     public byte readByte() {
         checkReadableBytes0(1);
@@ -799,6 +836,13 @@ public ByteBuf readSlice(int length) {
         return slice;
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        ByteBuf slice = retainedSlice(readerIndex, length);
+        readerIndex += length;
+        return slice;
+    }
+
     @Override
     public ByteBuf readBytes(byte[] dst, int dstIndex, int length) {
         checkReadableBytes(length);
@@ -1105,6 +1149,13 @@ public ByteBuf writeZero(int length) {
         return this;
     }
 
+    @Override
+    public int writeCharSequence(CharSequence sequence, Charset charset) {
+        int written = setCharSequence(writerIndex, sequence, charset);
+        writerIndex += written;
+        return written;
+    }
+
     @Override
     public ByteBuf copy() {
         return copy(readerIndex, readableBytes());
@@ -1115,16 +1166,31 @@ public ByteBuf duplicate() {
         return new DuplicatedAbstractByteBuf(this);
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        return duplicate().retain();
+    }
+
     @Override
     public ByteBuf slice() {
         return slice(readerIndex, readableBytes());
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        return slice().retain();
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         return new SlicedAbstractByteBuf(this, index, length);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        return slice(index, length).retain();
+    }
+
     @Override
     public ByteBuffer nioBuffer() {
         return nioBuffer(readerIndex, readableBytes());
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
index e385fa2c3165..34e2b3a0190a 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java
@@ -21,7 +21,10 @@
 /**
  * Abstract base class for {@link ByteBuf} implementations that wrap another
  * {@link ByteBuf}.
+ *
+ * @deprecated Do not use.
  */
+@Deprecated
 public abstract class AbstractDerivedByteBuf extends AbstractByteBuf {
 
     protected AbstractDerivedByteBuf(int maxCapacity) {
@@ -67,6 +70,11 @@ public final boolean release(int decrement) {
         return unwrap().release(decrement);
     }
 
+    @Override
+    public boolean isReadOnly() {
+        return unwrap().isReadOnly();
+    }
+
     @Override
     public ByteBuffer internalNioBuffer(int index, int length) {
         return nioBuffer(index, length);
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java
new file mode 100644
index 000000000000..b66b88cfa1c0
--- /dev/null
+++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.buffer;
+
+import io.netty.util.Recycler.Handle;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * Abstract base class for derived {@link ByteBuf} implementations.
+ */
+abstract class AbstractPooledDerivedByteBuf<T> extends AbstractReferenceCountedByteBuf {
+
+    private final Handle<AbstractPooledDerivedByteBuf<T>> recyclerHandle;
+    private AbstractByteBuf buffer;
+
+    @SuppressWarnings("unchecked")
+    AbstractPooledDerivedByteBuf(Handle<? extends AbstractPooledDerivedByteBuf<T>> recyclerHandle) {
+        super(0);
+        this.recyclerHandle = (Handle<AbstractPooledDerivedByteBuf<T>>) recyclerHandle;
+    }
+
+    @Override
+    public final AbstractByteBuf unwrap() {
+        return buffer;
+    }
+
+    final <U extends AbstractPooledDerivedByteBuf<T>> U init(
+            AbstractByteBuf buffer, int readerIndex, int writerIndex, int maxCapacity) {
+
+        buffer.retain();
+        this.buffer = buffer;
+
+        boolean success = false;
+        try {
+            maxCapacity(maxCapacity);
+            setIndex(readerIndex, writerIndex);
+            setRefCnt(1);
+
+            @SuppressWarnings("unchecked")
+            final U castThis = (U) this;
+            success = true;
+            return castThis;
+        } finally {
+            if (!success) {
+                this.buffer = null;
+                buffer.release();
+            }
+        }
+    }
+
+    @Override
+    protected final void deallocate() {
+        recyclerHandle.recycle(this);
+        unwrap().release();
+    }
+
+    @Override
+    public final ByteBufAllocator alloc() {
+        return unwrap().alloc();
+    }
+
+    @Override
+    @Deprecated
+    public final ByteOrder order() {
+        return unwrap().order();
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return unwrap().isReadOnly();
+    }
+
+    @Override
+    public final boolean isDirect() {
+        return unwrap().isDirect();
+    }
+
+    @Override
+    public boolean hasArray() {
+        return unwrap().hasArray();
+    }
+
+    @Override
+    public byte[] array() {
+        return unwrap().array();
+    }
+
+    @Override
+    public boolean hasMemoryAddress() {
+        return unwrap().hasMemoryAddress();
+    }
+
+    @Override
+    public final int nioBufferCount() {
+        return unwrap().nioBufferCount();
+    }
+
+    @Override
+    public final ByteBuffer internalNioBuffer(int index, int length) {
+        return nioBuffer(index, length);
+    }
+
+    @Override
+    public final ByteBuf retainedDuplicate() {
+        return PooledDuplicatedByteBuf.newInstance(this, readerIndex(), writerIndex());
+    }
+
+    @Override
+    public final ByteBuf retainedSlice() {
+        final int index = readerIndex();
+        return retainedSlice(index, writerIndex() - index);
+    }
+
+    @Override
+    public final ByteBuf retainedSlice(int index, int length) {
+        return PooledSlicedByteBuf.newInstance(this, index, length, index);
+    }
+}
diff --git a/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
index 749f0ca0d069..9bb6ca02c11a 100644
--- a/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java
@@ -76,24 +76,48 @@ public ByteBuf slice() {
         return new AdvancedLeakAwareByteBuf(super.slice(), leak);
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.retainedSlice(), leak);
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         recordLeakNonRefCountingOperation(leak);
         return new AdvancedLeakAwareByteBuf(super.slice(index, length), leak);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.retainedSlice(index, length), leak);
+    }
+
     @Override
     public ByteBuf duplicate() {
         recordLeakNonRefCountingOperation(leak);
         return new AdvancedLeakAwareByteBuf(super.duplicate(), leak);
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.retainedDuplicate(), leak);
+    }
+
     @Override
     public ByteBuf readSlice(int length) {
         recordLeakNonRefCountingOperation(leak);
         return new AdvancedLeakAwareByteBuf(super.readSlice(length), leak);
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.readRetainedSlice(length), leak);
+    }
+
     @Override
     public ByteBuf discardReadBytes() {
         recordLeakNonRefCountingOperation(leak);
@@ -244,6 +268,12 @@ public int getBytes(int index, GatheringByteChannel out, int length) throws IOEx
         return super.getBytes(index, out, length);
     }
 
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.getCharSequence(index, length, charset);
+    }
+
     @Override
     public ByteBuf setBoolean(int index, boolean value) {
         recordLeakNonRefCountingOperation(leak);
@@ -352,6 +382,12 @@ public ByteBuf setZero(int index, int length) {
         return super.setZero(index, length);
     }
 
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.setCharSequence(index, sequence, charset);
+    }
+
     @Override
     public boolean readBoolean() {
         recordLeakNonRefCountingOperation(leak);
@@ -484,6 +520,12 @@ public int readBytes(GatheringByteChannel out, int length) throws IOException {
         return super.readBytes(out, length);
     }
 
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.readCharSequence(length, charset);
+    }
+
     @Override
     public ByteBuf skipBytes(int length) {
         recordLeakNonRefCountingOperation(leak);
@@ -844,6 +886,12 @@ public ByteBuf writeLongLE(long value) {
         return super.writeLongLE(value);
     }
 
+    @Override
+    public int writeCharSequence(CharSequence sequence, Charset charset) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.writeCharSequence(sequence, charset);
+    }
+
     @Override
     public int getBytes(int index, FileChannel out, long position, int length) throws IOException {
         recordLeakNonRefCountingOperation(leak);
@@ -868,6 +916,12 @@ public int writeBytes(FileChannel in, long position, int length) throws IOExcept
         return super.writeBytes(in, position, length);
     }
 
+    @Override
+    public ByteBuf asReadOnly() {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);
+    }
+
     @Override
     public ByteBuf retain() {
         leak.record();
diff --git a/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java
index 70777ae70f33..932a0e70a65c 100644
--- a/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java
@@ -58,24 +58,60 @@ public ByteBuf slice() {
         return new AdvancedLeakAwareByteBuf(super.slice(), leak);
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.retainedSlice(), leak);
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         recordLeakNonRefCountingOperation(leak);
         return new AdvancedLeakAwareByteBuf(super.slice(index, length), leak);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.retainedSlice(index, length), leak);
+    }
+
     @Override
     public ByteBuf duplicate() {
         recordLeakNonRefCountingOperation(leak);
         return new AdvancedLeakAwareByteBuf(super.duplicate(), leak);
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.retainedDuplicate(), leak);
+    }
+
     @Override
     public ByteBuf readSlice(int length) {
         recordLeakNonRefCountingOperation(leak);
         return new AdvancedLeakAwareByteBuf(super.readSlice(length), leak);
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.readRetainedSlice(length), leak);
+    }
+
+    @Override
+    public ByteBuf asReadOnly() {
+        recordLeakNonRefCountingOperation(leak);
+        return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        recordLeakNonRefCountingOperation(leak);
+        return super.isReadOnly();
+    }
+
     @Override
     public CompositeByteBuf discardReadBytes() {
         recordLeakNonRefCountingOperation(leak);
@@ -226,6 +262,12 @@ public int getBytes(int index, GatheringByteChannel out, int length) throws IOEx
         return super.getBytes(index, out, length);
     }
 
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.getCharSequence(index, length, charset);
+    }
+
     @Override
     public CompositeByteBuf setBoolean(int index, boolean value) {
         recordLeakNonRefCountingOperation(leak);
@@ -466,6 +508,12 @@ public int readBytes(GatheringByteChannel out, int length) throws IOException {
         return super.readBytes(out, length);
     }
 
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.readCharSequence(length, charset);
+    }
+
     @Override
     public CompositeByteBuf skipBytes(int length) {
         recordLeakNonRefCountingOperation(leak);
@@ -580,6 +628,12 @@ public CompositeByteBuf writeZero(int length) {
         return super.writeZero(length);
     }
 
+    @Override
+    public int writeCharSequence(CharSequence sequence, Charset charset) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.writeCharSequence(sequence, charset);
+    }
+
     @Override
     public int indexOf(int fromIndex, int toIndex, byte value) {
         recordLeakNonRefCountingOperation(leak);
@@ -760,6 +814,12 @@ public ByteBuf setLongLE(int index, long value) {
         return super.setLongLE(index, value);
     }
 
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.setCharSequence(index, sequence, charset);
+    }
+
     @Override
     public short readShortLE() {
         recordLeakNonRefCountingOperation(leak);
@@ -857,15 +917,39 @@ public CompositeByteBuf addComponents(int cIndex, ByteBuf... buffers) {
     }
 
     @Override
-    public CompositeByteBuf removeComponent(int cIndex) {
+    public CompositeByteBuf addComponents(int cIndex, Iterable<ByteBuf> buffers) {
         recordLeakNonRefCountingOperation(leak);
-        return super.removeComponent(cIndex);
+        return super.addComponents(cIndex, buffers);
     }
 
     @Override
-    public CompositeByteBuf addComponents(int cIndex, Iterable<ByteBuf> buffers) {
+    public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {
         recordLeakNonRefCountingOperation(leak);
-        return super.addComponents(cIndex, buffers);
+        return super.addComponent(increaseWriterIndex, buffer);
+    }
+
+    @Override
+    public CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.addComponents(increaseWriterIndex, buffers);
+    }
+
+    @Override
+    public CompositeByteBuf addComponents(boolean increaseWriterIndex, Iterable<ByteBuf> buffers) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.addComponents(increaseWriterIndex, buffers);
+    }
+
+    @Override
+    public CompositeByteBuf addComponent(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.addComponent(increaseWriterIndex, cIndex, buffer);
+    }
+
+    @Override
+    public CompositeByteBuf removeComponent(int cIndex) {
+        recordLeakNonRefCountingOperation(leak);
+        return super.removeComponent(cIndex);
     }
 
     @Override
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBuf.java b/buffer/src/main/java/io/netty/buffer/ByteBuf.java
index 42c1962aedc3..e72fb21f34c2 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java
@@ -194,17 +194,31 @@
  *
  * <h3>Derived buffers</h3>
  *
- * You can create a view of an existing buffer by calling either
- * {@link #duplicate()}, {@link #slice()} or {@link #slice(int, int)}.
+ * You can create a view of an existing buffer by calling one of the following methods:
+ * <ul>
+ *   <li>{@link #duplicate()}</li>
+ *   <li>{@link #slice()}</li>
+ *   <li>{@link #slice(int, int)}</li>
+ *   <li>{@link #readSlice(int)}</li>
+ *   <li>{@link #retainedDuplicate()}</li>
+ *   <li>{@link #retainedSlice()}</li>
+ *   <li>{@link #retainedSlice(int, int)}</li>
+ *   <li>{@link #readRetainedSlice(int)}</li>
+ * </ul>
  * A derived buffer will have an independent {@link #readerIndex() readerIndex},
  * {@link #writerIndex() writerIndex} and marker indexes, while it shares
  * other internal data representation, just like a NIO buffer does.
  * <p>
  * In case a completely fresh copy of an existing buffer is required, please
  * call {@link #copy()} method instead.
- * <p>
- * Also be aware that obtaining derived buffers will NOT call {@link #retain()} and so the
- * reference count will NOT be increased.
+ *
+ * <h4>Non-retained and retained derived buffers</h4>
+ *
+ * Note that the {@link #duplicate()}, {@link #slice()}, {@link #slice(int, int)} and {@link #readSlice(int)} does NOT
+ * call {@link #retain()} on the returned derived buffer, and thus its reference count will NOT be increased. If you
+ * need to create a derived buffer with increased reference count, consider using {@link #retainedDuplicate()},
+ * {@link #retainedSlice()}, {@link #retainedSlice(int, int)} and {@link #readRetainedSlice(int)} which may return
+ * a buffer implementation that produces less garbage.
  *
  * <h3>Conversion to existing JDK types</h3>
  *
@@ -267,6 +281,7 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      * @deprecated use the Little Endian accessors, e.g. {@code getShortLE}, {@code getIntLE}
      * instead of creating a buffer with swapped {@code endianness}.
      */
+    @Deprecated
     public abstract ByteOrder order();
 
     /**
@@ -280,6 +295,7 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      * @deprecated use the Little Endian accessors, e.g. {@code getShortLE}, {@code getIntLE}
      * instead of creating a buffer with swapped {@code endianness}.
      */
+    @Deprecated
     public abstract ByteBuf order(ByteOrder endianness);
 
     /**
@@ -295,6 +311,16 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract boolean isDirect();
 
+    /**
+     * Returns {@code true} if and only if this buffer is read-only.
+     */
+    public abstract boolean isReadOnly();
+
+    /**
+     * Returns a read-only version of this buffer.
+     */
+    public abstract ByteBuf asReadOnly();
+
     /**
      * Returns the {@code readerIndex} of this buffer.
      */
@@ -901,6 +927,17 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract int getBytes(int index, FileChannel out, long position, int length) throws IOException;
 
+    /**
+     * Gets a {@link CharSequence} with the given length at the given index.
+     *
+     * @param length the length to read
+     * @param charset that should be used
+     * @return the sequence
+     * @throws IndexOutOfBoundsException
+     *         if {@code length} is greater than {@code this.readableBytes}
+     */
+    public abstract CharSequence getCharSequence(int index, int length, Charset charset);
+
     /**
      * Sets the specified boolean at the specified absolute {@code index} in this
      * buffer.
@@ -1235,6 +1272,19 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract ByteBuf setZero(int index, int length);
 
+    /**
+     * Writes the specified {@link CharSequence} at the current {@code writerIndex} and increases
+     * the {@code writerIndex} by the written bytes.
+     *
+     * @param index on which the sequence should be written
+     * @param sequence to write
+     * @param charset that should be used.
+     * @return the written number of bytes.
+     * @throws IndexOutOfBoundsException
+     *         if {@code this.writableBytes} is not large enough to write the whole sequence
+     */
+    public abstract int setCharSequence(int index, CharSequence sequence, Charset charset);
+
     /**
      * Gets a boolean at the current {@code readerIndex} and increases
      * the {@code readerIndex} by {@code 1} in this buffer.
@@ -1455,6 +1505,24 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract ByteBuf readSlice(int length);
 
+    /**
+     * Returns a new retained slice of this buffer's sub-region starting at the current
+     * {@code readerIndex} and increases the {@code readerIndex} by the size
+     * of the new slice (= {@code length}).
+     * <p>
+     * Note that this method returns a {@linkplain #retain() retained} buffer unlike {@link #readSlice(int)}.
+     * This method behaves similarly to {@code readSlice(...).retain()} except that this method may return
+     * a buffer implementation that produces less garbage.
+     *
+     * @param length the size of the new slice
+     *
+     * @return the newly created slice
+     *
+     * @throws IndexOutOfBoundsException
+     *         if {@code length} is greater than {@code this.readableBytes}
+     */
+    public abstract ByteBuf readRetainedSlice(int length);
+
     /**
      * Transfers this buffer's data to the specified destination starting at
      * the current {@code readerIndex} until the destination becomes
@@ -1567,6 +1635,18 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract int readBytes(GatheringByteChannel out, int length) throws IOException;
 
+    /**
+     * Gets a {@link CharSequence} with the given length at the current {@code readerIndex}
+     * and increases the {@code readerIndex} by the given length.
+     *
+     * @param length the length to read
+     * @param charset that should be used
+     * @return the sequence
+     * @throws IndexOutOfBoundsException
+     *         if {@code length} is greater than {@code this.readableBytes}
+     */
+    public abstract CharSequence readCharSequence(int length, Charset charset);
+
     /**
      * Transfers this buffer's data starting at the current {@code readerIndex}
      * to the specified channel starting at the given file position.
@@ -1873,6 +1953,19 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract ByteBuf writeZero(int length);
 
+    /**
+     * Writes the specified {@link CharSequence} at the current {@code writerIndex} and increases
+     * the {@code writerIndex} by the written bytes.
+     * in this buffer.
+     *
+     * @param sequence to write
+     * @param charset that should be used
+     * @return the written number of bytes
+     * @throws IndexOutOfBoundsException
+     *         if {@code this.writableBytes} is not large enough to write the whole sequence
+     */
+    public abstract int writeCharSequence(CharSequence sequence, Charset charset);
+
     /**
      * Locates the first occurrence of the specified {@code value} in this
      * buffer.  The search takes place from the specified {@code fromIndex}
@@ -1999,6 +2092,20 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract ByteBuf slice();
 
+    /**
+     * Returns a retained slice of this buffer's readable bytes. Modifying the content
+     * of the returned buffer or this buffer affects each other's content
+     * while they maintain separate indexes and marks.  This method is
+     * identical to {@code buf.slice(buf.readerIndex(), buf.readableBytes())}.
+     * This method does not modify {@code readerIndex} or {@code writerIndex} of
+     * this buffer.
+     * <p>
+     * Note that this method returns a {@linkplain #retain() retained} buffer unlike {@link #slice()}.
+     * This method behaves similarly to {@code slice().retain()} except that this method may return
+     * a buffer implementation that produces less garbage.
+     */
+    public abstract ByteBuf retainedSlice();
+
     /**
      * Returns a slice of this buffer's sub-region. Modifying the content of
      * the returned buffer or this buffer affects each other's content while
@@ -2011,6 +2118,19 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract ByteBuf slice(int index, int length);
 
+    /**
+     * Returns a retained slice of this buffer's sub-region. Modifying the content of
+     * the returned buffer or this buffer affects each other's content while
+     * they maintain separate indexes and marks.
+     * This method does not modify {@code readerIndex} or {@code writerIndex} of
+     * this buffer.
+     * <p>
+     * Note that this method returns a {@linkplain #retain() retained} buffer unlike {@link #slice(int, int)}.
+     * This method behaves similarly to {@code slice(...).retain()} except that this method may return
+     * a buffer implementation that produces less garbage.
+     */
+    public abstract ByteBuf retainedSlice(int index, int length);
+
     /**
      * Returns a buffer which shares the whole region of this buffer.
      * Modifying the content of the returned buffer or this buffer affects
@@ -2024,6 +2144,20 @@ public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {
      */
     public abstract ByteBuf duplicate();
 
+    /**
+     * Returns a retained buffer which shares the whole region of this buffer.
+     * Modifying the content of the returned buffer or this buffer affects
+     * each other's content while they maintain separate indexes and marks.
+     * This method is identical to {@code buf.slice(0, buf.capacity())}.
+     * This method does not modify {@code readerIndex} or {@code writerIndex} of
+     * this buffer.
+     * <p>
+     * Note that this method returns a {@linkplain #retain() retained} buffer unlike {@link #slice(int, int)}.
+     * This method behaves similarly to {@code duplicate().retain()} except that this method may return
+     * a buffer implementation that produces less garbage.
+     */
+    public abstract ByteBuf retainedDuplicate();
+
     /**
      * Returns the maximum number of NIO {@link ByteBuffer}s that consist this buffer.  Note that {@link #nioBuffers()}
      * or {@link #nioBuffers(int, int)} might return a less number of {@link ByteBuffer}s.
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
index c78cb6a45975..9a4f5976958f 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java
@@ -28,15 +28,27 @@ public interface ByteBufHolder extends ReferenceCounted {
     ByteBuf content();
 
     /**
-     * Create a deep copy of this {@link ByteBufHolder}.
+     * Creates a deep copy of this {@link ByteBufHolder}.
      */
     ByteBufHolder copy();
 
     /**
-     * Duplicate the {@link ByteBufHolder}. Be aware that this will not automatically call {@link #retain()}.
+     * Duplicates this {@link ByteBufHolder}. Be aware that this will not automatically call {@link #retain()}.
      */
     ByteBufHolder duplicate();
 
+    /**
+     * Duplicates this {@link ByteBufHolder}. This method returns a retained duplicate unlike {@link #duplicate()}.
+     *
+     * @see ByteBuf#retainedDuplicate()
+     */
+    ByteBufHolder retainedDuplicate();
+
+    /**
+     * Returns a new {@link ByteBufHolder} which contains the specified {@code content}.
+     */
+    ByteBufHolder replace(ByteBuf content);
+
     @Override
     ByteBufHolder retain();
 
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java
index e70d67b3bd0e..4e9ce6d488d6 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java
@@ -21,11 +21,13 @@
 /**
  * @deprecated Use {@link ByteProcessor}.
  */
+@Deprecated
 public interface ByteBufProcessor extends ByteProcessor {
 
     /**
      * @deprecated Use {@link ByteProcessor#FIND_NUL}.
      */
+    @Deprecated
     ByteBufProcessor FIND_NUL = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -36,6 +38,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_NON_NUL}.
      */
+    @Deprecated
     ByteBufProcessor FIND_NON_NUL = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -46,6 +49,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_CR}.
      */
+    @Deprecated
     ByteBufProcessor FIND_CR = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -56,6 +60,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_NON_CR}.
      */
+    @Deprecated
     ByteBufProcessor FIND_NON_CR = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -66,6 +71,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_LF}.
      */
+    @Deprecated
     ByteBufProcessor FIND_LF = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -76,6 +82,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_NON_LF}.
      */
+    @Deprecated
     ByteBufProcessor FIND_NON_LF = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -86,6 +93,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_CRLF}.
      */
+    @Deprecated
     ByteBufProcessor FIND_CRLF = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -96,6 +104,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_NON_CRLF}.
      */
+    @Deprecated
     ByteBufProcessor FIND_NON_CRLF = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -106,6 +115,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_LINEAR_WHITESPACE}.
      */
+    @Deprecated
     ByteBufProcessor FIND_LINEAR_WHITESPACE = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
@@ -116,6 +126,7 @@ public boolean process(byte value) throws Exception {
     /**
      * @deprecated Use {@link ByteProcessor#FIND_NON_LINEAR_WHITESPACE}.
      */
+    @Deprecated
     ByteBufProcessor FIND_NON_LINEAR_WHITESPACE = new ByteBufProcessor() {
         @Override
         public boolean process(byte value) throws Exception {
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
index 3e231285a005..60a9c3b5a617 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
@@ -365,7 +365,7 @@ private static int lastIndexOf(ByteBuf buffer, int fromIndex, int toIndex, byte
      */
     public static ByteBuf writeUtf8(ByteBufAllocator alloc, CharSequence seq) {
         // UTF-8 uses max. 3 bytes per char, so calculate the worst case.
-        ByteBuf buf = alloc.buffer(seq.length() * MAX_BYTES_PER_CHAR_UTF8);
+        ByteBuf buf = alloc.buffer(utf8MaxBytes(seq));
         writeUtf8(buf, seq);
         return buf;
     }
@@ -378,11 +378,14 @@ public static ByteBuf writeUtf8(ByteBufAllocator alloc, CharSequence seq) {
      */
     public static int writeUtf8(ByteBuf buf, CharSequence seq) {
         final int len = seq.length();
-        buf.ensureWritable(len * MAX_BYTES_PER_CHAR_UTF8);
+        buf.ensureWritable(utf8MaxBytes(seq));
 
         for (;;) {
             if (buf instanceof AbstractByteBuf) {
-                return writeUtf8((AbstractByteBuf) buf, seq, len);
+                AbstractByteBuf byteBuf = (AbstractByteBuf) buf;
+                int written = writeUtf8(byteBuf, byteBuf.writerIndex, seq, len);
+                byteBuf.writerIndex += written;
+                return written;
             } else if (buf instanceof WrappedByteBuf) {
                 // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path.
                 buf = buf.unwrap();
@@ -395,9 +398,8 @@ public static int writeUtf8(ByteBuf buf, CharSequence seq) {
     }
 
     // Fast-Path implementation
-    private static int writeUtf8(AbstractByteBuf buffer, CharSequence seq, int len) {
-        int oldWriterIndex = buffer.writerIndex;
-        int writerIndex = oldWriterIndex;
+    static int writeUtf8(AbstractByteBuf buffer, int writerIndex, CharSequence seq, int len) {
+        int oldWriterIndex = writerIndex;
 
         // We can use the _set methods as these not need to do any index checks and reference checks.
         // This is possible as we called ensureWritable(...) before.
@@ -440,11 +442,16 @@ private static int writeUtf8(AbstractByteBuf buffer, CharSequence seq, int len)
                 buffer._setByte(writerIndex++, (byte) (0x80 | (c & 0x3f)));
             }
         }
-        // update the writerIndex without any extra checks for performance reasons
-        buffer.writerIndex = writerIndex;
         return writerIndex - oldWriterIndex;
     }
 
+    /**
+     * Returns max bytes length of UTF8 character sequence.
+     */
+    public static int utf8MaxBytes(CharSequence seq) {
+        return seq.length() * MAX_BYTES_PER_CHAR_UTF8;
+    }
+
     /**
      * Encode a {@link CharSequence} in <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a> and write
      * it to a {@link ByteBuf} allocated with {@code alloc}.
@@ -476,8 +483,10 @@ public static int writeAscii(ByteBuf buf, CharSequence seq) {
         } else {
             for (;;) {
                 if (buf instanceof AbstractByteBuf) {
-                    writeAscii((AbstractByteBuf) buf, seq, len);
-                    break;
+                    AbstractByteBuf byteBuf = (AbstractByteBuf) buf;
+                    int written = writeAscii(byteBuf, byteBuf.writerIndex, seq, len);
+                    byteBuf.writerIndex += written;
+                    return written;
                 } else if (buf instanceof WrappedByteBuf) {
                     // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path.
                     buf = buf.unwrap();
@@ -490,16 +499,14 @@ public static int writeAscii(ByteBuf buf, CharSequence seq) {
     }
 
     // Fast-Path implementation
-    private static void writeAscii(AbstractByteBuf buffer, CharSequence seq, int len) {
-        int writerIndex = buffer.writerIndex;
+    static int writeAscii(AbstractByteBuf buffer, int writerIndex, CharSequence seq, int len) {
 
         // We can use the _set methods as these not need to do any index checks and reference checks.
         // This is possible as we called ensureWritable(...) before.
         for (int i = 0; i < len; i++) {
             buffer._setByte(writerIndex++, (byte) seq.charAt(i));
         }
-        // update the writerIndex without any extra checks for performance reasons
-        buffer.writerIndex = writerIndex;
+        return len;
     }
 
     /**
@@ -930,7 +937,7 @@ static final class ThreadLocalUnsafeDirectByteBuf extends UnpooledUnsafeDirectBy
         private static final Recycler<ThreadLocalUnsafeDirectByteBuf> RECYCLER =
                 new Recycler<ThreadLocalUnsafeDirectByteBuf>() {
                     @Override
-                    protected ThreadLocalUnsafeDirectByteBuf newObject(Handle handle) {
+                    protected ThreadLocalUnsafeDirectByteBuf newObject(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {
                         return new ThreadLocalUnsafeDirectByteBuf(handle);
                     }
                 };
@@ -941,9 +948,9 @@ static ThreadLocalUnsafeDirectByteBuf newInstance() {
             return buf;
         }
 
-        private final Handle handle;
+        private final Handle<ThreadLocalUnsafeDirectByteBuf> handle;
 
-        private ThreadLocalUnsafeDirectByteBuf(Handle handle) {
+        private ThreadLocalUnsafeDirectByteBuf(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {
             super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);
             this.handle = handle;
         }
@@ -954,7 +961,7 @@ protected void deallocate() {
                 super.deallocate();
             } else {
                 clear();
-                RECYCLER.recycle(this, handle);
+                handle.recycle(this);
             }
         }
     }
@@ -963,7 +970,7 @@ static final class ThreadLocalDirectByteBuf extends UnpooledDirectByteBuf {
 
         private static final Recycler<ThreadLocalDirectByteBuf> RECYCLER = new Recycler<ThreadLocalDirectByteBuf>() {
             @Override
-            protected ThreadLocalDirectByteBuf newObject(Handle handle) {
+            protected ThreadLocalDirectByteBuf newObject(Handle<ThreadLocalDirectByteBuf> handle) {
                 return new ThreadLocalDirectByteBuf(handle);
             }
         };
@@ -974,9 +981,9 @@ static ThreadLocalDirectByteBuf newInstance() {
             return buf;
         }
 
-        private final Handle handle;
+        private final Handle<ThreadLocalDirectByteBuf> handle;
 
-        private ThreadLocalDirectByteBuf(Handle handle) {
+        private ThreadLocalDirectByteBuf(Handle<ThreadLocalDirectByteBuf> handle) {
             super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);
             this.handle = handle;
         }
@@ -987,7 +994,7 @@ protected void deallocate() {
                 super.deallocate();
             } else {
                 clear();
-                RECYCLER.recycle(this, handle);
+                handle.recycle(this);
             }
         }
     }
diff --git a/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
index 42e4f3013744..05ceb4adfff7 100644
--- a/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java
@@ -79,7 +79,7 @@ public CompositeByteBuf(ByteBufAllocator alloc, boolean direct, int maxNumCompon
         this.maxNumComponents = maxNumComponents;
         components = newList(maxNumComponents);
 
-        addComponents0(0, buffers);
+        addComponents0(false, 0, buffers);
         consolidateIfNeeded();
         setIndex(0, capacity());
     }
@@ -100,7 +100,7 @@ public CompositeByteBuf(
         this.maxNumComponents = maxNumComponents;
         components = newList(maxNumComponents);
 
-        addComponents0(0, buffers);
+        addComponents0(false, 0, buffers);
         consolidateIfNeeded();
         setIndex(0, capacity());
     }
@@ -122,24 +122,21 @@ private static List<Component> newList(int maxNumComponents) {
      * Add the given {@link ByteBuf}.
      * <p>
      * Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuf}.
-     * If you need to have it increased you need to handle it by your own.
+     * If you need to have it increased use {@link #addComponent(boolean, ByteBuf)}.
      * <p>
      * {@link ByteBuf#release()} ownership of {@code buffer} is transfered to this {@link CompositeByteBuf}.
      * @param buffer the {@link ByteBuf} to add. {@link ByteBuf#release()} ownership is transfered to this
      * {@link CompositeByteBuf}.
      */
     public CompositeByteBuf addComponent(ByteBuf buffer) {
-        checkNotNull(buffer, "buffer");
-        addComponent0(components.size(), buffer);
-        consolidateIfNeeded();
-        return this;
+        return addComponent(false, buffer);
     }
 
     /**
      * Add the given {@link ByteBuf}s.
      * <p>
      * Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuf}.
-     * If you need to have it increased you need to handle it by your own.
+     * If you need to have it increased use {@link #addComponents(boolean, ByteBuf[])}.
      * <p>
      * {@link ByteBuf#release()} ownership of all {@link ByteBuf} objects in {@code buffers} is transfered to this
      * {@link CompositeByteBuf}.
@@ -147,16 +144,14 @@ public CompositeByteBuf addComponent(ByteBuf buffer) {
      * ownership of all {@link ByteBuf} objects is transfered to this {@link CompositeByteBuf}.
      */
     public CompositeByteBuf addComponents(ByteBuf... buffers) {
-        addComponents0(components.size(), buffers);
-        consolidateIfNeeded();
-        return this;
+        return addComponents(false, buffers);
     }
 
     /**
      * Add the given {@link ByteBuf}s.
      * <p>
      * Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuf}.
-     * If you need to have it increased you need to handle it by your own.
+     * If you need to have it increased use {@link #addComponents(boolean, Iterable)}.
      * <p>
      * {@link ByteBuf#release()} ownership of all {@link ByteBuf} objects in {@code buffers} is transfered to this
      * {@link CompositeByteBuf}.
@@ -164,16 +159,14 @@ public CompositeByteBuf addComponents(ByteBuf... buffers) {
      * ownership of all {@link ByteBuf} objects is transfered to this {@link CompositeByteBuf}.
      */
     public CompositeByteBuf addComponents(Iterable<ByteBuf> buffers) {
-        addComponents0(components.size(), buffers);
-        consolidateIfNeeded();
-        return this;
+        return addComponents(false, buffers);
     }
 
     /**
      * Add the given {@link ByteBuf} on the specific index.
      * <p>
      * Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuf}.
-     * If you need to have it increased you need to handle it by your own.
+     * If you need to have it increased use {@link #addComponent(boolean, int, ByteBuf)}.
      * <p>
      * {@link ByteBuf#release()} ownership of {@code buffer} is transfered to this {@link CompositeByteBuf}.
      * @param cIndex the index on which the {@link ByteBuf} will be added.
@@ -181,8 +174,66 @@ public CompositeByteBuf addComponents(Iterable<ByteBuf> buffers) {
      * {@link CompositeByteBuf}.
      */
     public CompositeByteBuf addComponent(int cIndex, ByteBuf buffer) {
+        return addComponent(false, cIndex, buffer);
+    }
+
+    /**
+     * Add the given {@link ByteBuf} and increase the {@code writerIndex} if {@code increaseWriterIndex} is
+     * {@code true}.
+     *
+     * {@link ByteBuf#release()} ownership of {@code buffer} is transfered to this {@link CompositeByteBuf}.
+     * @param buffer the {@link ByteBuf} to add. {@link ByteBuf#release()} ownership is transfered to this
+     * {@link CompositeByteBuf}.
+     */
+    public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {
+        checkNotNull(buffer, "buffer");
+        addComponent0(increaseWriterIndex, components.size(), buffer);
+        consolidateIfNeeded();
+        return this;
+    }
+
+    /**
+     * Add the given {@link ByteBuf}s and increase the {@code writerIndex} if {@code increaseWriterIndex} is
+     * {@code true}.
+     *
+     * {@link ByteBuf#release()} ownership of all {@link ByteBuf} objects in {@code buffers} is transfered to this
+     * {@link CompositeByteBuf}.
+     * @param buffers the {@link ByteBuf}s to add. {@link ByteBuf#release()} ownership of all {@link ByteBuf#release()}
+     * ownership of all {@link ByteBuf} objects is transfered to this {@link CompositeByteBuf}.
+     */
+    public CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) {
+        addComponents0(increaseWriterIndex, components.size(), buffers);
+        consolidateIfNeeded();
+        return this;
+    }
+
+    /**
+     * Add the given {@link ByteBuf}s and increase the {@code writerIndex} if {@code increaseWriterIndex} is
+     * {@code true}.
+     *
+     * {@link ByteBuf#release()} ownership of all {@link ByteBuf} objects in {@code buffers} is transfered to this
+     * {@link CompositeByteBuf}.
+     * @param buffers the {@link ByteBuf}s to add. {@link ByteBuf#release()} ownership of all {@link ByteBuf#release()}
+     * ownership of all {@link ByteBuf} objects is transfered to this {@link CompositeByteBuf}.
+     */
+    public CompositeByteBuf addComponents(boolean increaseWriterIndex, Iterable<ByteBuf> buffers) {
+        addComponents0(increaseWriterIndex, components.size(), buffers);
+        consolidateIfNeeded();
+        return this;
+    }
+
+    /**
+     * Add the given {@link ByteBuf} on the specific index and increase the {@code writerIndex}
+     * if {@code increaseWriterIndex} is {@code true}.
+     *
+     * {@link ByteBuf#release()} ownership of {@code buffer} is transfered to this {@link CompositeByteBuf}.
+     * @param cIndex the index on which the {@link ByteBuf} will be added.
+     * @param buffer the {@link ByteBuf} to add. {@link ByteBuf#release()} ownership is transfered to this
+     * {@link CompositeByteBuf}.
+     */
+    public CompositeByteBuf addComponent(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {
         checkNotNull(buffer, "buffer");
-        addComponent0(cIndex, buffer);
+        addComponent0(increaseWriterIndex, cIndex, buffer);
         consolidateIfNeeded();
         return this;
     }
@@ -190,7 +241,7 @@ public CompositeByteBuf addComponent(int cIndex, ByteBuf buffer) {
     /**
      * Precondition is that {@code buffer != null}.
      */
-    private int addComponent0(int cIndex, ByteBuf buffer) {
+    private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {
         assert buffer != null;
         boolean wasAdded = false;
         try {
@@ -217,6 +268,9 @@ private int addComponent0(int cIndex, ByteBuf buffer) {
                     updateComponentOffsets(cIndex);
                 }
             }
+            if (increaseWriterIndex) {
+                writerIndex(writerIndex() + buffer.readableBytes());
+            }
             return cIndex;
         } finally {
             if (!wasAdded) {
@@ -240,12 +294,12 @@ private int addComponent0(int cIndex, ByteBuf buffer) {
      * ownership of all {@link ByteBuf} objects is transfered to this {@link CompositeByteBuf}.
      */
     public CompositeByteBuf addComponents(int cIndex, ByteBuf... buffers) {
-        addComponents0(cIndex, buffers);
+        addComponents0(false, cIndex, buffers);
         consolidateIfNeeded();
         return this;
     }
 
-    private int addComponents0(int cIndex, ByteBuf... buffers) {
+    private int addComponents0(boolean increaseWriterIndex, int cIndex, ByteBuf... buffers) {
         checkNotNull(buffers, "buffers");
         int i = 0;
         try {
@@ -259,7 +313,7 @@ private int addComponents0(int cIndex, ByteBuf... buffers) {
                 if (b == null) {
                     break;
                 }
-                cIndex = addComponent0(cIndex, b) + 1;
+                cIndex = addComponent0(increaseWriterIndex, cIndex, b) + 1;
                 int size = components.size();
                 if (cIndex > size) {
                     cIndex = size;
@@ -294,15 +348,15 @@ private int addComponents0(int cIndex, ByteBuf... buffers) {
      * {@link CompositeByteBuf}.
      */
     public CompositeByteBuf addComponents(int cIndex, Iterable<ByteBuf> buffers) {
-        addComponents0(cIndex, buffers);
+        addComponents0(false, cIndex, buffers);
         consolidateIfNeeded();
         return this;
     }
 
-    private int addComponents0(int cIndex, Iterable<ByteBuf> buffers) {
+    private int addComponents0(boolean increaseIndex, int cIndex, Iterable<ByteBuf> buffers) {
         if (buffers instanceof ByteBuf) {
             // If buffers also implements ByteBuf (e.g. CompositeByteBuf), it has to go to addComponent(ByteBuf).
-            return addComponent0(cIndex, (ByteBuf) buffers);
+            return addComponent0(increaseIndex, cIndex, (ByteBuf) buffers);
         }
         checkNotNull(buffers, "buffers");
 
@@ -329,7 +383,7 @@ private int addComponents0(int cIndex, Iterable<ByteBuf> buffers) {
         }
 
         Collection<ByteBuf> col = (Collection<ByteBuf>) buffers;
-        return addComponents0(cIndex, col.toArray(new ByteBuf[col.size()]));
+        return addComponents0(increaseIndex, cIndex, col.toArray(new ByteBuf[col.size()]));
     }
 
     /**
@@ -596,13 +650,13 @@ public CompositeByteBuf capacity(int newCapacity) {
             if (nComponents < maxNumComponents) {
                 padding = allocBuffer(paddingLength);
                 padding.setIndex(0, paddingLength);
-                addComponent0(components.size(), padding);
+                addComponent0(false, components.size(), padding);
             } else {
                 padding = allocBuffer(paddingLength);
                 padding.setIndex(0, paddingLength);
                 // FIXME: No need to create a padding buffer and consolidate.
                 // Just create a big single buffer and put the current content there.
-                addComponent0(components.size(), padding);
+                addComponent0(false, components.size(), padding);
                 consolidateIfNeeded();
             }
         } else if (newCapacity < oldCapacity) {
diff --git a/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
index ef39045dcdd3..1e19a5eacbe4 100644
--- a/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
+++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java
@@ -41,14 +41,46 @@ public ByteBuf content() {
         return data;
     }
 
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This method calls {@code replace(content().copy())} by default.
+     */
     @Override
     public ByteBufHolder copy() {
-        return new DefaultByteBufHolder(data.copy());
+        return replace(data.copy());
     }
 
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This method calls {@code replace(content().duplicate())} by default.
+     */
     @Override
     public ByteBufHolder duplicate() {
-        return new DefaultByteBufHolder(data.duplicate());
+        return replace(data.duplicate());
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This method calls {@code replace(content().retainedDuplicate())} by default.
+     */
+    @Override
+    public ByteBufHolder retainedDuplicate() {
+        return replace(data.retainedDuplicate());
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Override this method to return a new instance of this object whose content is set to the specified
+     * {@code content}. The default implementation of {@link #copy()}, {@link #duplicate()} and
+     * {@link #retainedDuplicate()} invokes this method to create a copy.
+     */
+    @Override
+    public ByteBufHolder replace(ByteBuf content) {
+        return new DefaultByteBufHolder(content);
     }
 
     @Override
@@ -102,4 +134,20 @@ protected final String contentToString() {
     public String toString() {
         return StringUtil.simpleClassName(this) + '(' + contentToString() + ')';
     }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o instanceof ByteBufHolder) {
+            return data.equals(((ByteBufHolder) o).content());
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return data.hashCode();
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/DuplicatedAbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/DuplicatedAbstractByteBuf.java
index d49e960d5dae..c80d7485653c 100644
--- a/buffer/src/main/java/io/netty/buffer/DuplicatedAbstractByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/DuplicatedAbstractByteBuf.java
@@ -20,61 +20,102 @@
  * is of type {@link AbstractByteBuf}.
  */
 final class DuplicatedAbstractByteBuf extends DuplicatedByteBuf {
-    public DuplicatedAbstractByteBuf(AbstractByteBuf buffer) {
+    DuplicatedAbstractByteBuf(AbstractByteBuf buffer) {
         super(buffer);
     }
 
+    @Override
+    public AbstractByteBuf unwrap() {
+        return (AbstractByteBuf) super.unwrap();
+    }
+
     @Override
     protected byte _getByte(int index) {
-        return unwrap0()._getByte(index);
+        return unwrap()._getByte(index);
     }
 
     @Override
     protected short _getShort(int index) {
-        return unwrap0()._getShort(index);
+        return unwrap()._getShort(index);
+    }
+
+    @Override
+    protected short _getShortLE(int index) {
+        return unwrap()._getShortLE(index);
     }
 
     @Override
     protected int _getUnsignedMedium(int index) {
-        return unwrap0()._getUnsignedMedium(index);
+        return unwrap()._getUnsignedMedium(index);
+    }
+
+    @Override
+    protected int _getUnsignedMediumLE(int index) {
+        return unwrap()._getUnsignedMediumLE(index);
     }
 
     @Override
     protected int _getInt(int index) {
-        return unwrap0()._getInt(index);
+        return unwrap()._getInt(index);
+    }
+
+    @Override
+    protected int _getIntLE(int index) {
+        return unwrap()._getIntLE(index);
     }
 
     @Override
     protected long _getLong(int index) {
-        return unwrap0()._getLong(index);
+        return unwrap()._getLong(index);
+    }
+
+    @Override
+    protected long _getLongLE(int index) {
+        return unwrap()._getLongLE(index);
     }
 
     @Override
     protected void _setByte(int index, int value) {
-        unwrap0()._setByte(index, value);
+        unwrap()._setByte(index, value);
     }
 
     @Override
     protected void _setShort(int index, int value) {
-        unwrap0()._setShort(index, value);
+        unwrap()._setShort(index, value);
+    }
+
+    @Override
+    protected void _setShortLE(int index, int value) {
+        unwrap()._setShortLE(index, value);
     }
 
     @Override
     protected void _setMedium(int index, int value) {
-        unwrap0()._setMedium(index, value);
+        unwrap()._setMedium(index, value);
+    }
+
+    @Override
+    protected void _setMediumLE(int index, int value) {
+        unwrap()._setMediumLE(index, value);
     }
 
     @Override
     protected void _setInt(int index, int value) {
-        unwrap0()._setInt(index, value);
+        unwrap()._setInt(index, value);
+    }
+
+    @Override
+    protected void _setIntLE(int index, int value) {
+        unwrap()._setIntLE(index, value);
     }
 
     @Override
     protected void _setLong(int index, long value) {
-        unwrap0()._setLong(index, value);
+        unwrap()._setLong(index, value);
     }
 
-    private AbstractByteBuf unwrap0() {
-        return (AbstractByteBuf) unwrap();
+    @Override
+    protected void _setLongLE(int index, long value) {
+        unwrap()._setLongLE(index, value);
     }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
index 3ebe1f68eb54..69b157017250 100644
--- a/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java
@@ -26,17 +26,23 @@
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 
-
 /**
  * A derived buffer which simply forwards all data access requests to its
  * parent.  It is recommended to use {@link ByteBuf#duplicate()} instead
  * of calling the constructor explicitly.
+ *
+ * @deprecated Do not use.
  */
+@Deprecated
 public class DuplicatedByteBuf extends AbstractDerivedByteBuf {
 
     private final ByteBuf buffer;
 
     public DuplicatedByteBuf(ByteBuf buffer) {
+        this(buffer, buffer.readerIndex(), buffer.writerIndex());
+    }
+
+    DuplicatedByteBuf(ByteBuf buffer, int readerIndex, int writerIndex) {
         super(buffer.maxCapacity());
 
         if (buffer instanceof DuplicatedByteBuf) {
@@ -45,7 +51,7 @@ public DuplicatedByteBuf(ByteBuf buffer) {
             this.buffer = buffer;
         }
 
-        setIndex(buffer.readerIndex(), buffer.writerIndex());
+        setIndex(readerIndex, writerIndex);
         markReaderIndex();
         markWriterIndex();
     }
@@ -57,306 +63,346 @@ public ByteBuf unwrap() {
 
     @Override
     public ByteBufAllocator alloc() {
-        return buffer.alloc();
+        return unwrap().alloc();
     }
 
     @Override
+    @Deprecated
     public ByteOrder order() {
-        return buffer.order();
+        return unwrap().order();
     }
 
     @Override
     public boolean isDirect() {
-        return buffer.isDirect();
+        return unwrap().isDirect();
     }
 
     @Override
     public int capacity() {
-        return buffer.capacity();
+        return unwrap().capacity();
     }
 
     @Override
     public ByteBuf capacity(int newCapacity) {
-        buffer.capacity(newCapacity);
+        unwrap().capacity(newCapacity);
         return this;
     }
 
     @Override
     public boolean hasArray() {
-        return buffer.hasArray();
+        return unwrap().hasArray();
     }
 
     @Override
     public byte[] array() {
-        return buffer.array();
+        return unwrap().array();
     }
 
     @Override
     public int arrayOffset() {
-        return buffer.arrayOffset();
+        return unwrap().arrayOffset();
     }
 
     @Override
     public boolean hasMemoryAddress() {
-        return buffer.hasMemoryAddress();
+        return unwrap().hasMemoryAddress();
     }
 
     @Override
     public long memoryAddress() {
-        return buffer.memoryAddress();
+        return unwrap().memoryAddress();
     }
 
     @Override
     public byte getByte(int index) {
-        return buffer.getByte(index);
+        return unwrap().getByte(index);
     }
 
     @Override
     protected byte _getByte(int index) {
-        return buffer.getByte(index);
+        return unwrap().getByte(index);
     }
 
     @Override
     public short getShort(int index) {
-        return buffer.getShort(index);
+        return unwrap().getShort(index);
     }
 
     @Override
     protected short _getShort(int index) {
-        return buffer.getShort(index);
+        return unwrap().getShort(index);
+    }
+
+    @Override
+    public short getShortLE(int index) {
+        return unwrap().getShortLE(index);
     }
 
     @Override
     protected short _getShortLE(int index) {
-        return buffer.getShortLE(index);
+        return unwrap().getShortLE(index);
     }
 
     @Override
     public int getUnsignedMedium(int index) {
-        return buffer.getUnsignedMedium(index);
+        return unwrap().getUnsignedMedium(index);
     }
 
     @Override
     protected int _getUnsignedMedium(int index) {
-        return buffer.getUnsignedMedium(index);
+        return unwrap().getUnsignedMedium(index);
+    }
+
+    @Override
+    public int getUnsignedMediumLE(int index) {
+        return unwrap().getUnsignedMediumLE(index);
     }
 
     @Override
     protected int _getUnsignedMediumLE(int index) {
-        return buffer.getUnsignedMediumLE(index);
+        return unwrap().getUnsignedMediumLE(index);
     }
 
     @Override
     public int getInt(int index) {
-        return buffer.getInt(index);
+        return unwrap().getInt(index);
     }
 
     @Override
     protected int _getInt(int index) {
-        return buffer.getInt(index);
+        return unwrap().getInt(index);
+    }
+
+    @Override
+    public int getIntLE(int index) {
+        return unwrap().getIntLE(index);
     }
 
     @Override
     protected int _getIntLE(int index) {
-        return buffer.getIntLE(index);
+        return unwrap().getIntLE(index);
     }
 
     @Override
     public long getLong(int index) {
-        return buffer.getLong(index);
+        return unwrap().getLong(index);
     }
 
     @Override
     protected long _getLong(int index) {
-        return buffer.getLong(index);
+        return unwrap().getLong(index);
+    }
+
+    @Override
+    public long getLongLE(int index) {
+        return unwrap().getLongLE(index);
     }
 
     @Override
     protected long _getLongLE(int index) {
-        return buffer.getLongLE(index);
+        return unwrap().getLongLE(index);
     }
 
     @Override
     public ByteBuf copy(int index, int length) {
-        return buffer.copy(index, length);
+        return unwrap().copy(index, length);
     }
 
     @Override
     public ByteBuf slice(int index, int length) {
-        return buffer.slice(index, length);
+        return unwrap().slice(index, length);
     }
 
     @Override
     public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
-        buffer.getBytes(index, dst, dstIndex, length);
+        unwrap().getBytes(index, dst, dstIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
-        buffer.getBytes(index, dst, dstIndex, length);
+        unwrap().getBytes(index, dst, dstIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf getBytes(int index, ByteBuffer dst) {
-        buffer.getBytes(index, dst);
+        unwrap().getBytes(index, dst);
         return this;
     }
 
     @Override
     public ByteBuf setByte(int index, int value) {
-        buffer.setByte(index, value);
+        unwrap().setByte(index, value);
         return this;
     }
 
     @Override
     protected void _setByte(int index, int value) {
-        buffer.setByte(index, value);
+        unwrap().setByte(index, value);
     }
 
     @Override
     public ByteBuf setShort(int index, int value) {
-        buffer.setShort(index, value);
+        unwrap().setShort(index, value);
         return this;
     }
 
     @Override
     protected void _setShort(int index, int value) {
-        buffer.setShort(index, value);
+        unwrap().setShort(index, value);
+    }
+
+    @Override
+    public ByteBuf setShortLE(int index, int value) {
+        unwrap().setShortLE(index, value);
+        return this;
     }
 
     @Override
     protected void _setShortLE(int index, int value) {
-        buffer.setShortLE(index, value);
+        unwrap().setShortLE(index, value);
     }
 
     @Override
     public ByteBuf setMedium(int index, int value) {
-        buffer.setMedium(index, value);
+        unwrap().setMedium(index, value);
         return this;
     }
 
     @Override
     protected void _setMedium(int index, int value) {
-        buffer.setMedium(index, value);
+        unwrap().setMedium(index, value);
+    }
+
+    @Override
+    public ByteBuf setMediumLE(int index, int value) {
+        unwrap().setMediumLE(index, value);
+        return this;
     }
 
     @Override
     protected void _setMediumLE(int index, int value) {
-        buffer.setMediumLE(index, value);
+        unwrap().setMediumLE(index, value);
     }
 
     @Override
     public ByteBuf setInt(int index, int value) {
-        buffer.setInt(index, value);
+        unwrap().setInt(index, value);
         return this;
     }
 
     @Override
     protected void _setInt(int index, int value) {
-        buffer.setInt(index, value);
+        unwrap().setInt(index, value);
+    }
+
+    @Override
+    public ByteBuf setIntLE(int index, int value) {
+        unwrap().setIntLE(index, value);
+        return this;
     }
 
     @Override
     protected void _setIntLE(int index, int value) {
-        buffer.setIntLE(index, value);
+        unwrap().setIntLE(index, value);
     }
 
     @Override
     public ByteBuf setLong(int index, long value) {
-        buffer.setLong(index, value);
+        unwrap().setLong(index, value);
         return this;
     }
 
     @Override
     protected void _setLong(int index, long value) {
-        buffer.setLong(index, value);
+        unwrap().setLong(index, value);
+    }
+
+    @Override
+    public ByteBuf setLongLE(int index, long value) {
+        unwrap().setLongLE(index, value);
+        return this;
     }
 
     @Override
     protected void _setLongLE(int index, long value) {
-        buffer.setLongLE(index, value);
+        unwrap().setLongLE(index, value);
     }
 
     @Override
     public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
-        buffer.setBytes(index, src, srcIndex, length);
+        unwrap().setBytes(index, src, srcIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
-        buffer.setBytes(index, src, srcIndex, length);
+        unwrap().setBytes(index, src, srcIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf setBytes(int index, ByteBuffer src) {
-        buffer.setBytes(index, src);
+        unwrap().setBytes(index, src);
         return this;
     }
 
     @Override
     public ByteBuf getBytes(int index, OutputStream out, int length)
             throws IOException {
-        buffer.getBytes(index, out, length);
+        unwrap().getBytes(index, out, length);
         return this;
     }
 
     @Override
     public int getBytes(int index, GatheringByteChannel out, int length)
             throws IOException {
-        return buffer.getBytes(index, out, length);
+        return unwrap().getBytes(index, out, length);
     }
 
     @Override
     public int getBytes(int index, FileChannel out, long position, int length)
             throws IOException {
-        return buffer.getBytes(index, out, position, length);
+        return unwrap().getBytes(index, out, position, length);
     }
 
     @Override
     public int setBytes(int index, InputStream in, int length)
             throws IOException {
-        return buffer.setBytes(index, in, length);
+        return unwrap().setBytes(index, in, length);
     }
 
     @Override
     public int setBytes(int index, ScatteringByteChannel in, int length)
             throws IOException {
-        return buffer.setBytes(index, in, length);
+        return unwrap().setBytes(index, in, length);
     }
 
     @Override
     public int setBytes(int index, FileChannel in, long position, int length)
             throws IOException {
-        return buffer.setBytes(index, in, position, length);
+        return unwrap().setBytes(index, in, position, length);
     }
 
     @Override
     public int nioBufferCount() {
-        return buffer.nioBufferCount();
+        return unwrap().nioBufferCount();
     }
 
     @Override
     public ByteBuffer[] nioBuffers(int index, int length) {
-        return buffer.nioBuffers(index, length);
-    }
-
-    @Override
-    public ByteBuffer internalNioBuffer(int index, int length) {
-        return nioBuffer(index, length);
+        return unwrap().nioBuffers(index, length);
     }
 
     @Override
     public int forEachByte(int index, int length, ByteProcessor processor) {
-        return buffer.forEachByte(index, length, processor);
+        return unwrap().forEachByte(index, length, processor);
     }
 
     @Override
     public int forEachByteDesc(int index, int length, ByteProcessor processor) {
-        return buffer.forEachByteDesc(index, length, processor);
+        return unwrap().forEachByteDesc(index, length, processor);
     }
 }
 
diff --git a/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
index ca67db07f57f..07dc18c269c6 100644
--- a/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java
@@ -95,6 +95,16 @@ public ByteBuf unwrap() {
         return null;
     }
 
+    @Override
+    public ByteBuf asReadOnly() {
+        return Unpooled.unmodifiableBuffer(this);
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return false;
+    }
+
     @Override
     public boolean isDirect() {
         return true;
@@ -381,6 +391,12 @@ public int getBytes(int index, FileChannel out, long position, int length) {
         return 0;
     }
 
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        checkIndex(index, length);
+        return null;
+    }
+
     @Override
     public ByteBuf setBoolean(int index, boolean value) {
         throw new IndexOutOfBoundsException();
@@ -499,6 +515,11 @@ public ByteBuf setZero(int index, int length) {
         return checkIndex(index, length);
     }
 
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        throw new IndexOutOfBoundsException();
+    }
+
     @Override
     public boolean readBoolean() {
         throw new IndexOutOfBoundsException();
@@ -609,6 +630,11 @@ public ByteBuf readSlice(int length) {
         return checkLength(length);
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        return checkLength(length);
+    }
+
     @Override
     public ByteBuf readBytes(ByteBuf dst) {
         return checkLength(dst.writableBytes());
@@ -656,6 +682,12 @@ public int readBytes(FileChannel out, long position, int length) {
         return 0;
     }
 
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        checkLength(length);
+        return null;
+    }
+
     @Override
     public ByteBuf skipBytes(int length) {
         return checkLength(length);
@@ -779,6 +811,11 @@ public ByteBuf writeZero(int length) {
         return checkLength(length);
     }
 
+    @Override
+    public int writeCharSequence(CharSequence sequence, Charset charset) {
+        throw new IndexOutOfBoundsException();
+    }
+
     @Override
     public int indexOf(int fromIndex, int toIndex, byte value) {
         checkIndex(fromIndex);
@@ -840,16 +877,31 @@ public ByteBuf slice() {
         return this;
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        return this;
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         return checkIndex(index, length);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        return checkIndex(index, length);
+    }
+
     @Override
     public ByteBuf duplicate() {
         return this;
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        return this;
+    }
+
     @Override
     public int nioBufferCount() {
         return 1;
diff --git a/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
index 268f75cb369e..a1296895535e 100644
--- a/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java
@@ -49,7 +49,7 @@ final class FixedCompositeByteBuf extends AbstractReferenceCountedByteBuf {
             order = ByteOrder.BIG_ENDIAN;
             nioBufferCount = 1;
             capacity = 0;
-            direct = buffers[0].isDirect();
+            direct = false;
         } else {
             ByteBuf b = buffers[0];
             this.buffers = new Object[buffers.length];
diff --git a/buffer/src/main/java/io/netty/buffer/PoolArena.java b/buffer/src/main/java/io/netty/buffer/PoolArena.java
index e5d799d4865d..27bac5d206ff 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolArena.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java
@@ -254,7 +254,7 @@ void free(PoolChunk<T> chunk, long handle, int normCapacity, PoolThreadCache cac
             int size = chunk.chunkSize();
             destroyChunk(chunk);
             activeBytesHuge.add(-size);
-            deallocationsHuge.decrement();
+            deallocationsHuge.increment();
         } else {
             SizeClass sizeClass = sizeClass(normCapacity);
             if (cache != null && cache.add(this, chunk, handle, normCapacity, sizeClass)) {
diff --git a/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
index 68953a1a4e8d..fb044c851a2c 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
@@ -457,18 +457,18 @@ private  void freeEntry(Entry entry) {
         }
 
         static final class Entry<T> {
-            final Handle recyclerHandle;
+            final Handle<Entry<?>> recyclerHandle;
             PoolChunk<T> chunk;
             long handle = -1;
 
-            Entry(Handle recyclerHandle) {
+            Entry(Handle<Entry<?>> recyclerHandle) {
                 this.recyclerHandle = recyclerHandle;
             }
 
             void recycle() {
                 chunk = null;
                 handle = -1;
-                RECYCLER.recycle(this, recyclerHandle);
+                recyclerHandle.recycle(this);
             }
         }
 
@@ -482,8 +482,9 @@ private static Entry newEntry(PoolChunk<?> chunk, long handle) {
 
         @SuppressWarnings("rawtypes")
         private static final Recycler<Entry> RECYCLER = new Recycler<Entry>() {
+            @SuppressWarnings("unchecked")
             @Override
-            protected Entry newObject(Handle handle) {
+            protected Entry newObject(Handle<Entry> handle) {
                 return new Entry(handle);
             }
         };
diff --git a/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
index 6b348e4a358b..f28be1ae7eaa 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
@@ -136,6 +136,22 @@ public final ByteBuf unwrap() {
         return null;
     }
 
+    @Override
+    public final ByteBuf retainedDuplicate() {
+        return PooledDuplicatedByteBuf.newInstance(this, readerIndex(), writerIndex());
+    }
+
+    @Override
+    public final ByteBuf retainedSlice() {
+        final int index = readerIndex();
+        return retainedSlice(index, writerIndex() - index);
+    }
+
+    @Override
+    public final ByteBuf retainedSlice(int index, int length) {
+        return PooledSlicedByteBuf.newInstance(this, index, length, index);
+    }
+
     protected final ByteBuffer internalNioBuffer() {
         ByteBuffer tmpNioBuf = this.tmpNioBuf;
         if (tmpNioBuf == null) {
diff --git a/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
index 7869e7fab5d1..9fbcce999abd 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java
@@ -209,7 +209,7 @@ private static <T> PoolArena<T>[] newArenaArray(int size) {
 
     private static int validateAndCalculatePageShifts(int pageSize) {
         if (pageSize < MIN_PAGE_SIZE) {
-            throw new IllegalArgumentException("pageSize: " + pageSize + " (expected: " + MIN_PAGE_SIZE + "+)");
+            throw new IllegalArgumentException("pageSize: " + pageSize + " (expected: " + MIN_PAGE_SIZE + ")");
         }
 
         if ((pageSize & pageSize - 1) != 0) {
diff --git a/buffer/src/main/java/io/netty/buffer/PooledDuplicatedByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledDuplicatedByteBuf.java
new file mode 100644
index 000000000000..d9a8219cbdeb
--- /dev/null
+++ b/buffer/src/main/java/io/netty/buffer/PooledDuplicatedByteBuf.java
@@ -0,0 +1,360 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.buffer;
+
+import io.netty.util.ByteProcessor;
+import io.netty.util.Recycler;
+import io.netty.util.Recycler.Handle;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.ScatteringByteChannel;
+
+final class PooledDuplicatedByteBuf extends AbstractPooledDerivedByteBuf<PooledDuplicatedByteBuf> {
+
+    private static final Recycler<PooledDuplicatedByteBuf> RECYCLER = new Recycler<PooledDuplicatedByteBuf>() {
+        @Override
+        protected PooledDuplicatedByteBuf newObject(Handle<PooledDuplicatedByteBuf> handle) {
+            return new PooledDuplicatedByteBuf(handle);
+        }
+    };
+
+    static PooledDuplicatedByteBuf newInstance(AbstractByteBuf buffer, int readerIndex, int writerIndex) {
+        final PooledDuplicatedByteBuf duplicate = RECYCLER.get();
+        duplicate.init(buffer, readerIndex, writerIndex, buffer.maxCapacity());
+        duplicate.markReaderIndex();
+        duplicate.markWriterIndex();
+
+        return duplicate;
+    }
+
+    private PooledDuplicatedByteBuf(Handle<PooledDuplicatedByteBuf> handle) {
+        super(handle);
+    }
+
+    @Override
+    public int capacity() {
+        return unwrap().capacity();
+    }
+
+    @Override
+    public ByteBuf capacity(int newCapacity) {
+        unwrap().capacity(newCapacity);
+        return this;
+    }
+
+    @Override
+    public int arrayOffset() {
+        return unwrap().arrayOffset();
+    }
+
+    @Override
+    public long memoryAddress() {
+        return unwrap().memoryAddress();
+    }
+
+    @Override
+    public ByteBuffer nioBuffer(int index, int length) {
+        return unwrap().nioBuffer(index, length);
+    }
+
+    @Override
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        return unwrap().nioBuffers(index, length);
+    }
+
+    @Override
+    public ByteBuf copy(int index, int length) {
+        return unwrap().copy(index, length);
+    }
+
+    @Override
+    public byte getByte(int index) {
+        return unwrap().getByte(index);
+    }
+
+    @Override
+    protected byte _getByte(int index) {
+        return unwrap()._getByte(index);
+    }
+
+    @Override
+    public short getShort(int index) {
+        return unwrap().getShort(index);
+    }
+
+    @Override
+    protected short _getShort(int index) {
+        return unwrap()._getShort(index);
+    }
+
+    @Override
+    public short getShortLE(int index) {
+        return unwrap().getShortLE(index);
+    }
+
+    @Override
+    protected short _getShortLE(int index) {
+        return unwrap()._getShortLE(index);
+    }
+
+    @Override
+    public int getUnsignedMedium(int index) {
+        return unwrap().getUnsignedMedium(index);
+    }
+
+    @Override
+    protected int _getUnsignedMedium(int index) {
+        return unwrap()._getUnsignedMedium(index);
+    }
+
+    @Override
+    public int getUnsignedMediumLE(int index) {
+        return unwrap().getUnsignedMediumLE(index);
+    }
+
+    @Override
+    protected int _getUnsignedMediumLE(int index) {
+        return unwrap()._getUnsignedMediumLE(index);
+    }
+
+    @Override
+    public int getInt(int index) {
+        return unwrap().getInt(index);
+    }
+
+    @Override
+    protected int _getInt(int index) {
+        return unwrap()._getInt(index);
+    }
+
+    @Override
+    public int getIntLE(int index) {
+        return unwrap().getIntLE(index);
+    }
+
+    @Override
+    protected int _getIntLE(int index) {
+        return unwrap()._getIntLE(index);
+    }
+
+    @Override
+    public long getLong(int index) {
+        return unwrap().getLong(index);
+    }
+
+    @Override
+    protected long _getLong(int index) {
+        return unwrap()._getLong(index);
+    }
+
+    @Override
+    public long getLongLE(int index) {
+        return unwrap().getLongLE(index);
+    }
+
+    @Override
+    protected long _getLongLE(int index) {
+        return unwrap()._getLongLE(index);
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
+        unwrap().getBytes(index, dst, dstIndex, length);
+        return this;
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
+        unwrap().getBytes(index, dst, dstIndex, length);
+        return this;
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, ByteBuffer dst) {
+        unwrap().getBytes(index, dst);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setByte(int index, int value) {
+        unwrap().setByte(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setByte(int index, int value) {
+        unwrap()._setByte(index, value);
+    }
+
+    @Override
+    public ByteBuf setShort(int index, int value) {
+        unwrap().setShort(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setShort(int index, int value) {
+        unwrap()._setShort(index, value);
+    }
+
+    @Override
+    public ByteBuf setShortLE(int index, int value) {
+        unwrap().setShortLE(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setShortLE(int index, int value) {
+        unwrap()._setShortLE(index, value);
+    }
+
+    @Override
+    public ByteBuf setMedium(int index, int value) {
+        unwrap().setMedium(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setMedium(int index, int value) {
+        unwrap()._setMedium(index, value);
+    }
+
+    @Override
+    public ByteBuf setMediumLE(int index, int value) {
+        unwrap().setMediumLE(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setMediumLE(int index, int value) {
+        unwrap()._setMediumLE(index, value);
+    }
+
+    @Override
+    public ByteBuf setInt(int index, int value) {
+        unwrap().setInt(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setInt(int index, int value) {
+        unwrap()._setInt(index, value);
+    }
+
+    @Override
+    public ByteBuf setIntLE(int index, int value) {
+        unwrap().setIntLE(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setIntLE(int index, int value) {
+        unwrap()._setIntLE(index, value);
+    }
+
+    @Override
+    public ByteBuf setLong(int index, long value) {
+        unwrap().setLong(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setLong(int index, long value) {
+        unwrap()._setLong(index, value);
+    }
+
+    @Override
+    public ByteBuf setLongLE(int index, long value) {
+        unwrap().setLongLE(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setLongLE(int index, long value) {
+        unwrap().setLongLE(index, value);
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
+        unwrap().setBytes(index, src, srcIndex, length);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
+        unwrap().setBytes(index, src, srcIndex, length);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, ByteBuffer src) {
+        unwrap().setBytes(index, src);
+        return this;
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, OutputStream out, int length)
+            throws IOException {
+        unwrap().getBytes(index, out, length);
+        return this;
+    }
+
+    @Override
+    public int getBytes(int index, GatheringByteChannel out, int length)
+            throws IOException {
+        return unwrap().getBytes(index, out, length);
+    }
+
+    @Override
+    public int getBytes(int index, FileChannel out, long position, int length)
+            throws IOException {
+        return unwrap().getBytes(index, out, position, length);
+    }
+
+    @Override
+    public int setBytes(int index, InputStream in, int length)
+            throws IOException {
+        return unwrap().setBytes(index, in, length);
+    }
+
+    @Override
+    public int setBytes(int index, ScatteringByteChannel in, int length)
+            throws IOException {
+        return unwrap().setBytes(index, in, length);
+    }
+
+    @Override
+    public int setBytes(int index, FileChannel in, long position, int length)
+            throws IOException {
+        return unwrap().setBytes(index, in, position, length);
+    }
+
+    @Override
+    public int forEachByte(int index, int length, ByteProcessor processor) {
+        return unwrap().forEachByte(index, length, processor);
+    }
+
+    @Override
+    public int forEachByteDesc(int index, int length, ByteProcessor processor) {
+        return unwrap().forEachByteDesc(index, length, processor);
+    }
+}
diff --git a/buffer/src/main/java/io/netty/buffer/PooledSlicedByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledSlicedByteBuf.java
new file mode 100644
index 000000000000..3a974a4668d5
--- /dev/null
+++ b/buffer/src/main/java/io/netty/buffer/PooledSlicedByteBuf.java
@@ -0,0 +1,418 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.buffer;
+
+import io.netty.util.ByteProcessor;
+import io.netty.util.Recycler;
+import io.netty.util.Recycler.Handle;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.ScatteringByteChannel;
+
+import static io.netty.util.internal.MathUtil.isOutOfBounds;
+
+final class PooledSlicedByteBuf extends AbstractPooledDerivedByteBuf<PooledSlicedByteBuf> {
+
+    private static final Recycler<PooledSlicedByteBuf> RECYCLER = new Recycler<PooledSlicedByteBuf>() {
+        @Override
+        protected PooledSlicedByteBuf newObject(Handle<PooledSlicedByteBuf> handle) {
+            return new PooledSlicedByteBuf(handle);
+        }
+    };
+
+    static PooledSlicedByteBuf newInstance(AbstractByteBuf buffer, int index, int length, int adjustment) {
+        if (isOutOfBounds(index, length, buffer.capacity())) {
+            throw new IndexOutOfBoundsException(buffer + ".slice(" + index + ", " + length + ')');
+        }
+
+        final PooledSlicedByteBuf slice = RECYCLER.get();
+        slice.init(buffer, 0, length, length);
+        slice.discardMarks();
+        slice.adjustment = adjustment;
+
+        return slice;
+    }
+
+    private int adjustment;
+
+    private PooledSlicedByteBuf(Handle<PooledSlicedByteBuf> handle) {
+        super(handle);
+    }
+
+    @Override
+    public int capacity() {
+        return maxCapacity();
+    }
+
+    @Override
+    public ByteBuf capacity(int newCapacity) {
+        return reject();
+    }
+
+    @Override
+    public int arrayOffset() {
+        return idx(unwrap().arrayOffset());
+    }
+
+    @Override
+    public long memoryAddress() {
+        return unwrap().memoryAddress() + adjustment;
+    }
+
+    @Override
+    public ByteBuffer nioBuffer(int index, int length) {
+        checkIndex0(index, length);
+        return unwrap().nioBuffer(idx(index), length);
+    }
+
+    @Override
+    public ByteBuffer[] nioBuffers(int index, int length) {
+        checkIndex0(index, length);
+        return unwrap().nioBuffers(idx(index), length);
+    }
+
+    @Override
+    public ByteBuf copy(int index, int length) {
+        checkIndex0(index, length);
+        return unwrap().copy(idx(index), length);
+    }
+
+    @Override
+    public byte getByte(int index) {
+        checkIndex0(index, 1);
+        return unwrap().getByte(idx(index));
+    }
+
+    @Override
+    protected byte _getByte(int index) {
+        return unwrap()._getByte(idx(index));
+    }
+
+    @Override
+    public short getShort(int index) {
+        checkIndex0(index, 2);
+        return unwrap().getShort(idx(index));
+    }
+
+    @Override
+    protected short _getShort(int index) {
+        return unwrap()._getShort(idx(index));
+    }
+
+    @Override
+    public short getShortLE(int index) {
+        checkIndex0(index, 2);
+        return unwrap().getShortLE(idx(index));
+    }
+
+    @Override
+    protected short _getShortLE(int index) {
+        return unwrap()._getShortLE(idx(index));
+    }
+
+    @Override
+    public int getUnsignedMedium(int index) {
+        checkIndex0(index, 3);
+        return unwrap().getUnsignedMedium(idx(index));
+    }
+
+    @Override
+    protected int _getUnsignedMedium(int index) {
+        return unwrap()._getUnsignedMedium(idx(index));
+    }
+
+    @Override
+    public int getUnsignedMediumLE(int index) {
+        checkIndex0(index, 3);
+        return unwrap().getUnsignedMediumLE(idx(index));
+    }
+
+    @Override
+    protected int _getUnsignedMediumLE(int index) {
+        return unwrap()._getUnsignedMediumLE(idx(index));
+    }
+
+    @Override
+    public int getInt(int index) {
+        checkIndex0(index, 4);
+        return unwrap().getInt(idx(index));
+    }
+
+    @Override
+    protected int _getInt(int index) {
+        return unwrap()._getInt(idx(index));
+    }
+
+    @Override
+    public int getIntLE(int index) {
+        checkIndex0(index, 4);
+        return unwrap().getIntLE(idx(index));
+    }
+
+    @Override
+    protected int _getIntLE(int index) {
+        return unwrap()._getIntLE(idx(index));
+    }
+
+    @Override
+    public long getLong(int index) {
+        checkIndex0(index, 8);
+        return unwrap().getLong(idx(index));
+    }
+
+    @Override
+    protected long _getLong(int index) {
+        return unwrap()._getLong(idx(index));
+    }
+
+    @Override
+    public long getLongLE(int index) {
+        checkIndex0(index, 8);
+        return unwrap().getLongLE(idx(index));
+    }
+
+    @Override
+    protected long _getLongLE(int index) {
+        return unwrap()._getLongLE(idx(index));
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
+        checkIndex0(index, length);
+        unwrap().getBytes(idx(index), dst, dstIndex, length);
+        return this;
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
+        checkIndex0(index, length);
+        unwrap().getBytes(idx(index), dst, dstIndex, length);
+        return this;
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, ByteBuffer dst) {
+        checkIndex0(index, dst.remaining());
+        unwrap().getBytes(idx(index), dst);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setByte(int index, int value) {
+        checkIndex0(index, 1);
+        unwrap().setByte(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setByte(int index, int value) {
+        unwrap()._setByte(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setShort(int index, int value) {
+        checkIndex0(index, 2);
+        unwrap().setShort(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setShort(int index, int value) {
+        unwrap()._setShort(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setShortLE(int index, int value) {
+        checkIndex0(index, 2);
+        unwrap().setShortLE(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setShortLE(int index, int value) {
+        unwrap()._setShortLE(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setMedium(int index, int value) {
+        checkIndex0(index, 3);
+        unwrap().setMedium(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setMedium(int index, int value) {
+        unwrap()._setMedium(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setMediumLE(int index, int value) {
+        checkIndex0(index, 3);
+        unwrap().setMediumLE(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setMediumLE(int index, int value) {
+        unwrap()._setMediumLE(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setInt(int index, int value) {
+        checkIndex0(index, 4);
+        unwrap().setInt(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setInt(int index, int value) {
+        unwrap()._setInt(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setIntLE(int index, int value) {
+        checkIndex0(index, 4);
+        unwrap().setIntLE(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setIntLE(int index, int value) {
+        unwrap()._setIntLE(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setLong(int index, long value) {
+        checkIndex0(index, 8);
+        unwrap().setLong(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setLong(int index, long value) {
+        unwrap()._setLong(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setLongLE(int index, long value) {
+        checkIndex0(index, 8);
+        unwrap().setLongLE(idx(index), value);
+        return this;
+    }
+
+    @Override
+    protected void _setLongLE(int index, long value) {
+        unwrap().setLongLE(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
+        checkIndex0(index, length);
+        unwrap().setBytes(idx(index), src, srcIndex, length);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
+        checkIndex0(index, length);
+        unwrap().setBytes(idx(index), src, srcIndex, length);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setBytes(int index, ByteBuffer src) {
+        checkIndex0(index, src.remaining());
+        unwrap().setBytes(idx(index), src);
+        return this;
+    }
+
+    @Override
+    public ByteBuf getBytes(int index, OutputStream out, int length)
+            throws IOException {
+        checkIndex0(index, length);
+        unwrap().getBytes(idx(index), out, length);
+        return this;
+    }
+
+    @Override
+    public int getBytes(int index, GatheringByteChannel out, int length)
+            throws IOException {
+        checkIndex0(index, length);
+        return unwrap().getBytes(idx(index), out, length);
+    }
+
+    @Override
+    public int getBytes(int index, FileChannel out, long position, int length)
+            throws IOException {
+        checkIndex0(index, length);
+        return unwrap().getBytes(idx(index), out, position, length);
+    }
+
+    @Override
+    public int setBytes(int index, InputStream in, int length)
+            throws IOException {
+        checkIndex0(index, length);
+        return unwrap().setBytes(idx(index), in, length);
+    }
+
+    @Override
+    public int setBytes(int index, ScatteringByteChannel in, int length)
+            throws IOException {
+        checkIndex0(index, length);
+        return unwrap().setBytes(idx(index), in, length);
+    }
+
+    @Override
+    public int setBytes(int index, FileChannel in, long position, int length)
+            throws IOException {
+        checkIndex0(index, length);
+        return unwrap().setBytes(idx(index), in, position, length);
+    }
+
+    @Override
+    public int forEachByte(int index, int length, ByteProcessor processor) {
+        checkIndex0(index, length);
+        int ret = unwrap().forEachByte(idx(index), length, processor);
+        if (ret < adjustment) {
+            return -1;
+        }
+        return ret - adjustment;
+    }
+
+    @Override
+    public int forEachByteDesc(int index, int length, ByteProcessor processor) {
+        checkIndex0(index, length);
+        int ret = unwrap().forEachByteDesc(idx(index), length, processor);
+        if (ret < adjustment) {
+            return -1;
+        }
+        return ret - adjustment;
+    }
+
+    private int idx(int index) {
+        return index + adjustment;
+    }
+
+    private static ByteBuf reject() {
+        throw new UnsupportedOperationException("sliced buffer");
+    }
+}
diff --git a/buffer/src/main/java/io/netty/buffer/PooledUnsafeHeapByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledUnsafeHeapByteBuf.java
index 1219fed5139a..f1fad7c9e405 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledUnsafeHeapByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeHeapByteBuf.java
@@ -1,7 +1,9 @@
 /*
  * Copyright 2015 The Netty Project
  *
- * The Netty Project licenses this file tothe License at:
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -46,21 +48,41 @@ protected short _getShort(int index) {
         return UnsafeByteBufUtil.getShort(memory, idx(index));
     }
 
+    @Override
+    protected short _getShortLE(int index) {
+        return UnsafeByteBufUtil.getShortLE(memory, idx(index));
+    }
+
     @Override
     protected int _getUnsignedMedium(int index) {
         return UnsafeByteBufUtil.getUnsignedMedium(memory, idx(index));
     }
 
+    @Override
+    protected int _getUnsignedMediumLE(int index) {
+        return UnsafeByteBufUtil.getUnsignedMediumLE(memory, idx(index));
+    }
+
     @Override
     protected int _getInt(int index) {
         return UnsafeByteBufUtil.getInt(memory, idx(index));
     }
 
+    @Override
+    protected int _getIntLE(int index) {
+        return UnsafeByteBufUtil.getIntLE(memory, idx(index));
+    }
+
     @Override
     protected long _getLong(int index) {
         return UnsafeByteBufUtil.getLong(memory, idx(index));
     }
 
+    @Override
+    protected long _getLongLE(int index) {
+        return UnsafeByteBufUtil.getLongLE(memory, idx(index));
+    }
+
     @Override
     protected void _setByte(int index, int value) {
         UnsafeByteBufUtil.setByte(memory, idx(index), value);
@@ -71,22 +93,43 @@ protected void _setShort(int index, int value) {
         UnsafeByteBufUtil.setShort(memory, idx(index), value);
     }
 
+    @Override
+    protected void _setShortLE(int index, int value) {
+        UnsafeByteBufUtil.setShortLE(memory, idx(index), value);
+    }
+
     @Override
     protected void _setMedium(int index, int value) {
         UnsafeByteBufUtil.setMedium(memory, idx(index), value);
     }
 
+    @Override
+    protected void _setMediumLE(int index, int value) {
+        UnsafeByteBufUtil.setMediumLE(memory, idx(index), value);
+    }
+
     @Override
     protected void _setInt(int index, int value) {
         UnsafeByteBufUtil.setInt(memory, idx(index), value);
     }
 
+    @Override
+    protected void _setIntLE(int index, int value) {
+        UnsafeByteBufUtil.setIntLE(memory, idx(index), value);
+    }
+
     @Override
     protected void _setLong(int index, long value) {
         UnsafeByteBufUtil.setLong(memory, idx(index), value);
     }
 
     @Override
+    protected void _setLongLE(int index, long value) {
+        UnsafeByteBufUtil.setLongLE(memory, idx(index), value);
+    }
+
+    @Override
+    @Deprecated
     protected SwappedByteBuf newSwappedByteBuf() {
         if (PlatformDependent.isUnaligned()) {
             // Only use if unaligned access is supported otherwise there is no gain.
diff --git a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
index ace37e78e37a..bb5617e0bfab 100644
--- a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java
@@ -31,7 +31,10 @@
  * A derived buffer which forbids any write requests to its parent.  It is
  * recommended to use {@link Unpooled#unmodifiableBuffer(ByteBuf)}
  * instead of calling the constructor explicitly.
+ *
+ * @deprecated Do not use.
  */
+@Deprecated
 public class ReadOnlyByteBuf extends AbstractDerivedByteBuf {
 
     private final ByteBuf buffer;
@@ -47,6 +50,11 @@ public ReadOnlyByteBuf(ByteBuf buffer) {
         setIndex(buffer.readerIndex(), buffer.writerIndex());
     }
 
+    @Override
+    public boolean isReadOnly() {
+        return true;
+    }
+
     @Override
     public boolean isWritable() {
         return false;
@@ -64,17 +72,18 @@ public ByteBuf unwrap() {
 
     @Override
     public ByteBufAllocator alloc() {
-        return buffer.alloc();
+        return unwrap().alloc();
     }
 
     @Override
+    @Deprecated
     public ByteOrder order() {
-        return buffer.order();
+        return unwrap().order();
     }
 
     @Override
     public boolean isDirect() {
-        return buffer.isDirect();
+        return unwrap().isDirect();
     }
 
     @Override
@@ -142,6 +151,11 @@ protected void _setShort(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setShortLE(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setShortLE(int index, int value) {
         throw new ReadOnlyBufferException();
@@ -157,6 +171,11 @@ protected void _setMedium(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setMediumLE(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setMediumLE(int index, int value) {
         throw new ReadOnlyBufferException();
@@ -172,6 +191,11 @@ protected void _setInt(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setIntLE(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setIntLE(int index, int value) {
         throw new ReadOnlyBufferException();
@@ -187,6 +211,11 @@ protected void _setLong(int index, long value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setLongLE(int index, long value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setLongLE(int index, long value) {
         throw new ReadOnlyBufferException();
@@ -210,37 +239,37 @@ public int setBytes(int index, FileChannel in, long position, int length) {
     @Override
     public int getBytes(int index, GatheringByteChannel out, int length)
             throws IOException {
-        return buffer.getBytes(index, out, length);
+        return unwrap().getBytes(index, out, length);
     }
 
     @Override
     public int getBytes(int index, FileChannel out, long position, int length)
             throws IOException {
-        return buffer.getBytes(index, out, position, length);
+        return unwrap().getBytes(index, out, position, length);
     }
 
     @Override
     public ByteBuf getBytes(int index, OutputStream out, int length)
             throws IOException {
-        buffer.getBytes(index, out, length);
+        unwrap().getBytes(index, out, length);
         return this;
     }
 
     @Override
     public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
-        buffer.getBytes(index, dst, dstIndex, length);
+        unwrap().getBytes(index, dst, dstIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
-        buffer.getBytes(index, dst, dstIndex, length);
+        unwrap().getBytes(index, dst, dstIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf getBytes(int index, ByteBuffer dst) {
-        buffer.getBytes(index, dst);
+        unwrap().getBytes(index, dst);
         return this;
     }
 
@@ -251,117 +280,132 @@ public ByteBuf duplicate() {
 
     @Override
     public ByteBuf copy(int index, int length) {
-        return buffer.copy(index, length);
+        return unwrap().copy(index, length);
     }
 
     @Override
     public ByteBuf slice(int index, int length) {
-        return Unpooled.unmodifiableBuffer(buffer.slice(index, length));
+        return Unpooled.unmodifiableBuffer(unwrap().slice(index, length));
     }
 
     @Override
     public byte getByte(int index) {
-        return _getByte(index);
+        return unwrap().getByte(index);
     }
 
     @Override
     protected byte _getByte(int index) {
-        return buffer.getByte(index);
+        return unwrap().getByte(index);
     }
 
     @Override
     public short getShort(int index) {
-        return _getShort(index);
+        return unwrap().getShort(index);
     }
 
     @Override
     protected short _getShort(int index) {
-        return buffer.getShort(index);
+        return unwrap().getShort(index);
+    }
+
+    @Override
+    public short getShortLE(int index) {
+        return unwrap().getShortLE(index);
     }
 
     @Override
     protected short _getShortLE(int index) {
-        return buffer.getShortLE(index);
+        return unwrap().getShortLE(index);
     }
 
     @Override
     public int getUnsignedMedium(int index) {
-        return _getUnsignedMedium(index);
+        return unwrap().getUnsignedMedium(index);
     }
 
     @Override
     protected int _getUnsignedMedium(int index) {
-        return buffer.getUnsignedMedium(index);
+        return unwrap().getUnsignedMedium(index);
+    }
+
+    @Override
+    public int getUnsignedMediumLE(int index) {
+        return unwrap().getUnsignedMediumLE(index);
     }
 
     @Override
     protected int _getUnsignedMediumLE(int index) {
-        return buffer.getUnsignedMediumLE(index);
+        return unwrap().getUnsignedMediumLE(index);
     }
 
     @Override
     public int getInt(int index) {
-        return _getInt(index);
+        return unwrap().getInt(index);
     }
 
     @Override
     protected int _getInt(int index) {
-        return buffer.getInt(index);
+        return unwrap().getInt(index);
+    }
+
+    @Override
+    public int getIntLE(int index) {
+        return unwrap().getIntLE(index);
     }
 
     @Override
     protected int _getIntLE(int index) {
-        return buffer.getIntLE(index);
+        return unwrap().getIntLE(index);
     }
 
     @Override
     public long getLong(int index) {
-        return _getLong(index);
+        return unwrap().getLong(index);
     }
 
     @Override
     protected long _getLong(int index) {
-        return buffer.getLong(index);
+        return unwrap().getLong(index);
+    }
+
+    @Override
+    public long getLongLE(int index) {
+        return unwrap().getLongLE(index);
     }
 
     @Override
     protected long _getLongLE(int index) {
-        return buffer.getLongLE(index);
+        return unwrap().getLongLE(index);
     }
 
     @Override
     public int nioBufferCount() {
-        return buffer.nioBufferCount();
+        return unwrap().nioBufferCount();
     }
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
-        return buffer.nioBuffer(index, length).asReadOnlyBuffer();
+        return unwrap().nioBuffer(index, length).asReadOnlyBuffer();
     }
 
     @Override
     public ByteBuffer[] nioBuffers(int index, int length) {
-        return buffer.nioBuffers(index, length);
-    }
-
-    @Override
-    public ByteBuffer internalNioBuffer(int index, int length) {
-        return nioBuffer(index, length);
+        return unwrap().nioBuffers(index, length);
     }
 
     @Override
     public int forEachByte(int index, int length, ByteProcessor processor) {
-        return buffer.forEachByte(index, length, processor);
+        return unwrap().forEachByte(index, length, processor);
     }
 
     @Override
     public int forEachByteDesc(int index, int length, ByteProcessor processor) {
-        return buffer.forEachByteDesc(index, length, processor);
+        return unwrap().forEachByteDesc(index, length, processor);
     }
 
     @Override
     public int capacity() {
-        return buffer.capacity();
+        return unwrap().capacity();
     }
 
     @Override
diff --git a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
index e7bea4913a2b..eb0abdf20983 100644
--- a/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java
@@ -73,6 +73,12 @@ protected short _getShort(int index) {
         return buffer.getShort(index);
     }
 
+    @Override
+    public short getShortLE(int index) {
+        ensureAccessible();
+        return _getShortLE(index);
+    }
+
     @Override
     protected short _getShortLE(int index) {
         return ByteBufUtil.swapShort(buffer.getShort(index));
@@ -91,6 +97,12 @@ protected int _getUnsignedMedium(int index) {
                getByte(index + 2) & 0xff;
     }
 
+    @Override
+    public int getUnsignedMediumLE(int index) {
+        ensureAccessible();
+        return _getUnsignedMediumLE(index);
+    }
+
     @Override
     protected int _getUnsignedMediumLE(int index) {
         return getByte(index)      & 0xff       |
@@ -109,6 +121,12 @@ protected int _getInt(int index) {
         return buffer.getInt(index);
     }
 
+    @Override
+    public int getIntLE(int index) {
+        ensureAccessible();
+        return _getIntLE(index);
+    }
+
     @Override
     protected int _getIntLE(int index) {
         return ByteBufUtil.swapInt(buffer.getInt(index));
@@ -125,6 +143,12 @@ protected long _getLong(int index) {
         return buffer.getLong(index);
     }
 
+    @Override
+    public long getLongLE(int index) {
+        ensureAccessible();
+        return _getLongLE(index);
+    }
+
     @Override
     protected long _getLongLE(int index) {
         return ByteBufUtil.swapLong(buffer.getLong(index));
@@ -176,46 +200,91 @@ public ByteBuf getBytes(int index, ByteBuffer dst) {
         return this;
     }
 
+    @Override
+    public ByteBuf setByte(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setByte(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setShort(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setShort(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setShortLE(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setShortLE(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setMedium(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setMedium(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setMediumLE(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setMediumLE(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setInt(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setInt(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setIntLE(int index, int value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setIntLE(int index, int value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setLong(int index, long value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setLong(int index, long value) {
         throw new ReadOnlyBufferException();
     }
 
+    @Override
+    public ByteBuf setLongLE(int index, long value) {
+        throw new ReadOnlyBufferException();
+    }
+
     @Override
     protected void _setLongLE(int index, long value) {
         throw new ReadOnlyBufferException();
@@ -246,6 +315,11 @@ public ByteBuf unwrap() {
         return null;
     }
 
+    @Override
+    public boolean isReadOnly() {
+        return buffer.isReadOnly();
+    }
+
     @Override
     public boolean isDirect() {
         return buffer.isDirect();
diff --git a/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
index 0a9fe3f20b78..b14cb5d7af8e 100644
--- a/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
@@ -72,18 +72,43 @@ public ByteBuf slice() {
         return new SimpleLeakAwareByteBuf(super.slice(), leak);
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        return new SimpleLeakAwareByteBuf(super.retainedSlice(), leak);
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         return new SimpleLeakAwareByteBuf(super.slice(index, length), leak);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        return new SimpleLeakAwareByteBuf(super.retainedSlice(index, length), leak);
+    }
+
     @Override
     public ByteBuf duplicate() {
         return new SimpleLeakAwareByteBuf(super.duplicate(), leak);
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        return new SimpleLeakAwareByteBuf(super.retainedDuplicate(), leak);
+    }
+
     @Override
     public ByteBuf readSlice(int length) {
         return new SimpleLeakAwareByteBuf(super.readSlice(length), leak);
     }
+
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        return new SimpleLeakAwareByteBuf(super.readRetainedSlice(length), leak);
+    }
+
+    @Override
+    public ByteBuf asReadOnly() {
+        return new SimpleLeakAwareByteBuf(super.asReadOnly(), leak);
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareCompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareCompositeByteBuf.java
index bede44fee5db..6def3c96125e 100644
--- a/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareCompositeByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareCompositeByteBuf.java
@@ -62,18 +62,43 @@ public ByteBuf slice() {
         return new SimpleLeakAwareByteBuf(super.slice(), leak);
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        return new SimpleLeakAwareByteBuf(super.retainedSlice(), leak);
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         return new SimpleLeakAwareByteBuf(super.slice(index, length), leak);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        return new SimpleLeakAwareByteBuf(super.retainedSlice(index, length), leak);
+    }
+
     @Override
     public ByteBuf duplicate() {
         return new SimpleLeakAwareByteBuf(super.duplicate(), leak);
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        return new SimpleLeakAwareByteBuf(super.retainedDuplicate(), leak);
+    }
+
     @Override
     public ByteBuf readSlice(int length) {
         return new SimpleLeakAwareByteBuf(super.readSlice(length), leak);
     }
+
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        return new SimpleLeakAwareByteBuf(super.readRetainedSlice(length), leak);
+    }
+
+    @Override
+    public ByteBuf asReadOnly() {
+        return new SimpleLeakAwareByteBuf(super.asReadOnly(), leak);
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/SlicedAbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/SlicedAbstractByteBuf.java
index 8ff68ff67521..77d4a6b7cec0 100644
--- a/buffer/src/main/java/io/netty/buffer/SlicedAbstractByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SlicedAbstractByteBuf.java
@@ -25,57 +25,98 @@ final class SlicedAbstractByteBuf extends SlicedByteBuf {
         super(buffer, index, length);
     }
 
+    @Override
+    public AbstractByteBuf unwrap() {
+        return (AbstractByteBuf) super.unwrap();
+    }
+
     @Override
     protected byte _getByte(int index) {
-        return unwrap0()._getByte(idx(index));
+        return unwrap()._getByte(idx(index));
     }
 
     @Override
     protected short _getShort(int index) {
-        return unwrap0()._getShort(idx(index));
+        return unwrap()._getShort(idx(index));
+    }
+
+    @Override
+    protected short _getShortLE(int index) {
+        return unwrap()._getShortLE(idx(index));
     }
 
     @Override
     protected int _getUnsignedMedium(int index) {
-        return unwrap0()._getUnsignedMedium(idx(index));
+        return unwrap()._getUnsignedMedium(idx(index));
+    }
+
+    @Override
+    protected int _getUnsignedMediumLE(int index) {
+        return unwrap()._getUnsignedMediumLE(idx(index));
     }
 
     @Override
     protected int _getInt(int index) {
-        return unwrap0()._getInt(idx(index));
+        return unwrap()._getInt(idx(index));
+    }
+
+    @Override
+    protected int _getIntLE(int index) {
+        return unwrap()._getIntLE(idx(index));
     }
 
     @Override
     protected long _getLong(int index) {
-        return unwrap0()._getLong(idx(index));
+        return unwrap()._getLong(idx(index));
+    }
+
+    @Override
+    protected long _getLongLE(int index) {
+        return unwrap()._getLongLE(idx(index));
     }
 
     @Override
     protected void _setByte(int index, int value) {
-        unwrap0()._setByte(idx(index), value);
+        unwrap()._setByte(idx(index), value);
     }
 
     @Override
     protected void _setShort(int index, int value) {
-        unwrap0()._setShort(idx(index), value);
+        unwrap()._setShort(idx(index), value);
+    }
+
+    @Override
+    protected void _setShortLE(int index, int value) {
+        unwrap()._setShortLE(idx(index), value);
     }
 
     @Override
     protected void _setMedium(int index, int value) {
-        unwrap0()._setMedium(idx(index), value);
+        unwrap()._setMedium(idx(index), value);
+    }
+
+    @Override
+    protected void _setMediumLE(int index, int value) {
+        unwrap()._setMediumLE(idx(index), value);
     }
 
     @Override
     protected void _setInt(int index, int value) {
-        unwrap0()._setInt(idx(index), value);
+        unwrap()._setInt(idx(index), value);
+    }
+
+    @Override
+    protected void _setIntLE(int index, int value) {
+        unwrap()._setIntLE(idx(index), value);
     }
 
     @Override
     protected void _setLong(int index, long value) {
-        unwrap0()._setLong(idx(index), value);
+        unwrap()._setLong(idx(index), value);
     }
 
-    private AbstractByteBuf unwrap0() {
-        return (AbstractByteBuf) unwrap();
+    @Override
+    protected void _setLongLE(int index, long value) {
+        unwrap()._setLongLE(idx(index), value);
     }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
index 33fadd75423a..7ab31681f15a 100644
--- a/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java
@@ -16,6 +16,7 @@
 package io.netty.buffer;
 
 import io.netty.util.ByteProcessor;
+import io.netty.util.CharsetUtil;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -25,14 +26,17 @@
 import java.nio.channels.FileChannel;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
-
+import java.nio.charset.Charset;
 
 /**
  * A derived buffer which exposes its parent's sub-region only.  It is
  * recommended to use {@link ByteBuf#slice()} and
  * {@link ByteBuf#slice(int, int)} instead of calling the constructor
  * explicitly.
+ *
+ * @deprecated Do not use.
  */
+@Deprecated
 public class SlicedByteBuf extends AbstractDerivedByteBuf {
 
     private final ByteBuf buffer;
@@ -60,6 +64,10 @@ public SlicedByteBuf(ByteBuf buffer, int index, int length) {
         writerIndex(length);
     }
 
+    final int adjustment() {
+        return adjustment;
+    }
+
     @Override
     public ByteBuf unwrap() {
         return buffer;
@@ -67,17 +75,18 @@ public ByteBuf unwrap() {
 
     @Override
     public ByteBufAllocator alloc() {
-        return buffer.alloc();
+        return unwrap().alloc();
     }
 
     @Override
+    @Deprecated
     public ByteOrder order() {
-        return buffer.order();
+        return unwrap().order();
     }
 
     @Override
     public boolean isDirect() {
-        return buffer.isDirect();
+        return unwrap().isDirect();
     }
 
     @Override
@@ -92,77 +101,131 @@ public ByteBuf capacity(int newCapacity) {
 
     @Override
     public boolean hasArray() {
-        return buffer.hasArray();
+        return unwrap().hasArray();
     }
 
     @Override
     public byte[] array() {
-        return buffer.array();
+        return unwrap().array();
     }
 
     @Override
     public int arrayOffset() {
-        return idx(buffer.arrayOffset());
+        return idx(unwrap().arrayOffset());
     }
 
     @Override
     public boolean hasMemoryAddress() {
-        return buffer.hasMemoryAddress();
+        return unwrap().hasMemoryAddress();
     }
 
     @Override
     public long memoryAddress() {
-        return buffer.memoryAddress() + adjustment;
+        return unwrap().memoryAddress() + adjustment;
+    }
+
+    @Override
+    public byte getByte(int index) {
+        checkIndex0(index, 1);
+        return unwrap().getByte(idx(index));
     }
 
     @Override
     protected byte _getByte(int index) {
-        return buffer.getByte(idx(index));
+        return unwrap().getByte(idx(index));
+    }
+
+    @Override
+    public short getShort(int index) {
+        checkIndex0(index, 2);
+        return unwrap().getShort(idx(index));
     }
 
     @Override
     protected short _getShort(int index) {
-        return buffer.getShort(idx(index));
+        return unwrap().getShort(idx(index));
+    }
+
+    @Override
+    public short getShortLE(int index) {
+        checkIndex0(index, 2);
+        return unwrap().getShortLE(idx(index));
     }
 
     @Override
     protected short _getShortLE(int index) {
-        return buffer.getShortLE(idx(index));
+        return unwrap().getShortLE(idx(index));
+    }
+
+    @Override
+    public int getUnsignedMedium(int index) {
+        checkIndex0(index, 3);
+        return unwrap().getUnsignedMedium(idx(index));
     }
 
     @Override
     protected int _getUnsignedMedium(int index) {
-        return buffer.getUnsignedMedium(idx(index));
+        return unwrap().getUnsignedMedium(idx(index));
+    }
+
+    @Override
+    public int getUnsignedMediumLE(int index) {
+        checkIndex0(index, 3);
+        return unwrap().getUnsignedMediumLE(idx(index));
     }
 
     @Override
     protected int _getUnsignedMediumLE(int index) {
-        return buffer.getUnsignedMediumLE(idx(index));
+        return unwrap().getUnsignedMediumLE(idx(index));
+    }
+
+    @Override
+    public int getInt(int index) {
+        checkIndex0(index, 4);
+        return unwrap().getInt(idx(index));
     }
 
     @Override
     protected int _getInt(int index) {
-        return buffer.getInt(idx(index));
+        return unwrap().getInt(idx(index));
+    }
+
+    @Override
+    public int getIntLE(int index) {
+        checkIndex0(index, 4);
+        return unwrap().getIntLE(idx(index));
     }
 
     @Override
     protected int _getIntLE(int index) {
-        return buffer.getIntLE(idx(index));
+        return unwrap().getIntLE(idx(index));
+    }
+
+    @Override
+    public long getLong(int index) {
+        checkIndex0(index, 8);
+        return unwrap().getLong(idx(index));
     }
 
     @Override
     protected long _getLong(int index) {
-        return buffer.getLong(idx(index));
+        return unwrap().getLong(idx(index));
+    }
+
+    @Override
+    public long getLongLE(int index) {
+        checkIndex0(index, 8);
+        return unwrap().getLongLE(idx(index));
     }
 
     @Override
     protected long _getLongLE(int index) {
-        return buffer.getLongLE(idx(index));
+        return unwrap().getLongLE(idx(index));
     }
 
     @Override
     public ByteBuf duplicate() {
-        ByteBuf duplicate = buffer.slice(adjustment, length);
+        final ByteBuf duplicate = unwrap().slice(adjustment, length);
         duplicate.setIndex(readerIndex(), writerIndex());
         return duplicate;
     }
@@ -170,165 +233,246 @@ public ByteBuf duplicate() {
     @Override
     public ByteBuf copy(int index, int length) {
         checkIndex0(index, length);
-        return buffer.copy(idx(index), length);
+        return unwrap().copy(idx(index), length);
     }
 
     @Override
     public ByteBuf slice(int index, int length) {
         checkIndex0(index, length);
-        return buffer.slice(idx(index), length);
+        return unwrap().slice(idx(index), length);
     }
 
     @Override
     public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
         checkIndex0(index, length);
-        buffer.getBytes(idx(index), dst, dstIndex, length);
+        unwrap().getBytes(idx(index), dst, dstIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
         checkIndex0(index, length);
-        buffer.getBytes(idx(index), dst, dstIndex, length);
+        unwrap().getBytes(idx(index), dst, dstIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf getBytes(int index, ByteBuffer dst) {
         checkIndex0(index, dst.remaining());
-        buffer.getBytes(idx(index), dst);
+        unwrap().getBytes(idx(index), dst);
+        return this;
+    }
+
+    @Override
+    public ByteBuf setByte(int index, int value) {
+        checkIndex0(index, 1);
+        unwrap().setByte(idx(index), value);
         return this;
     }
 
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        checkIndex0(index, length);
+        return buffer.getCharSequence(idx(index), length, charset);
+    }
+
     @Override
     protected void _setByte(int index, int value) {
-        buffer.setByte(idx(index), value);
+        unwrap().setByte(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setShort(int index, int value) {
+        checkIndex0(index, 2);
+        unwrap().setShort(idx(index), value);
+        return this;
     }
 
     @Override
     protected void _setShort(int index, int value) {
-        buffer.setShort(idx(index), value);
+        unwrap().setShort(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setShortLE(int index, int value) {
+        checkIndex0(index, 2);
+        unwrap().setShortLE(idx(index), value);
+        return this;
     }
 
     @Override
     protected void _setShortLE(int index, int value) {
-        buffer.setShortLE(idx(index), value);
+        unwrap().setShortLE(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setMedium(int index, int value) {
+        checkIndex0(index, 3);
+        unwrap().setMedium(idx(index), value);
+        return this;
     }
 
     @Override
     protected void _setMedium(int index, int value) {
-        buffer.setMedium(idx(index), value);
+        unwrap().setMedium(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setMediumLE(int index, int value) {
+        checkIndex0(index, 3);
+        unwrap().setMediumLE(idx(index), value);
+        return this;
     }
 
     @Override
     protected void _setMediumLE(int index, int value) {
-        buffer.setMediumLE(idx(index), value);
+        unwrap().setMediumLE(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setInt(int index, int value) {
+        checkIndex0(index, 4);
+        unwrap().setInt(idx(index), value);
+        return this;
     }
 
     @Override
     protected void _setInt(int index, int value) {
-        buffer.setInt(idx(index), value);
+        unwrap().setInt(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setIntLE(int index, int value) {
+        checkIndex0(index, 4);
+        unwrap().setIntLE(idx(index), value);
+        return this;
     }
 
     @Override
     protected void _setIntLE(int index, int value) {
-        buffer.setIntLE(idx(index), value);
+        unwrap().setIntLE(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setLong(int index, long value) {
+        checkIndex0(index, 8);
+        unwrap().setLong(idx(index), value);
+        return this;
     }
 
     @Override
     protected void _setLong(int index, long value) {
-        buffer.setLong(idx(index), value);
+        unwrap().setLong(idx(index), value);
+    }
+
+    @Override
+    public ByteBuf setLongLE(int index, long value) {
+        checkIndex0(index, 8);
+        unwrap().setLongLE(idx(index), value);
+        return this;
     }
 
     @Override
     protected void _setLongLE(int index, long value) {
-        buffer.setLongLE(idx(index), value);
+        unwrap().setLongLE(idx(index), value);
     }
 
     @Override
     public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
         checkIndex0(index, length);
-        buffer.setBytes(idx(index), src, srcIndex, length);
+        unwrap().setBytes(idx(index), src, srcIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
         checkIndex0(index, length);
-        buffer.setBytes(idx(index), src, srcIndex, length);
+        unwrap().setBytes(idx(index), src, srcIndex, length);
         return this;
     }
 
     @Override
     public ByteBuf setBytes(int index, ByteBuffer src) {
         checkIndex0(index, src.remaining());
-        buffer.setBytes(idx(index), src);
+        unwrap().setBytes(idx(index), src);
         return this;
     }
 
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        if (charset.equals(CharsetUtil.UTF_8)) {
+            checkIndex0(index, ByteBufUtil.utf8MaxBytes(sequence));
+            return ByteBufUtil.writeUtf8(this, idx(index), sequence, sequence.length());
+        }
+        if (charset.equals(CharsetUtil.US_ASCII)) {
+            int len = sequence.length();
+            checkIndex0(index, len);
+            return ByteBufUtil.writeAscii(this, idx(index), sequence, len);
+        }
+        byte[] bytes = sequence.toString().getBytes(charset);
+        checkIndex0(index, bytes.length);
+        buffer.setBytes(idx(index), bytes);
+        return bytes.length;
+    }
+
     @Override
     public ByteBuf getBytes(int index, OutputStream out, int length) throws IOException {
         checkIndex0(index, length);
-        buffer.getBytes(idx(index), out, length);
+        unwrap().getBytes(idx(index), out, length);
         return this;
     }
 
     @Override
     public int getBytes(int index, GatheringByteChannel out, int length) throws IOException {
         checkIndex0(index, length);
-        return buffer.getBytes(idx(index), out, length);
+        return unwrap().getBytes(idx(index), out, length);
     }
 
     @Override
     public int getBytes(int index, FileChannel out, long position, int length) throws IOException {
         checkIndex0(index, length);
-        return buffer.getBytes(idx(index), out, position, length);
+        return unwrap().getBytes(idx(index), out, position, length);
     }
 
     @Override
     public int setBytes(int index, InputStream in, int length) throws IOException {
         checkIndex0(index, length);
-        return buffer.setBytes(idx(index), in, length);
+        return unwrap().setBytes(idx(index), in, length);
     }
 
     @Override
     public int setBytes(int index, ScatteringByteChannel in, int length) throws IOException {
         checkIndex0(index, length);
-        return buffer.setBytes(idx(index), in, length);
+        return unwrap().setBytes(idx(index), in, length);
     }
 
     @Override
     public int setBytes(int index, FileChannel in, long position, int length) throws IOException {
         checkIndex0(index, length);
-        return buffer.setBytes(idx(index), in, position, length);
+        return unwrap().setBytes(idx(index), in, position, length);
     }
 
     @Override
     public int nioBufferCount() {
-        return buffer.nioBufferCount();
+        return unwrap().nioBufferCount();
     }
 
     @Override
     public ByteBuffer nioBuffer(int index, int length) {
         checkIndex0(index, length);
-        return buffer.nioBuffer(idx(index), length);
+        return unwrap().nioBuffer(idx(index), length);
     }
 
     @Override
     public ByteBuffer[] nioBuffers(int index, int length) {
         checkIndex0(index, length);
-        return buffer.nioBuffers(idx(index), length);
-    }
-
-    @Override
-    public ByteBuffer internalNioBuffer(int index, int length) {
-        return nioBuffer(index, length);
+        return unwrap().nioBuffers(idx(index), length);
     }
 
     @Override
     public int forEachByte(int index, int length, ByteProcessor processor) {
         checkIndex0(index, length);
-        int ret = buffer.forEachByte(idx(index), length, processor);
+        int ret = unwrap().forEachByte(idx(index), length, processor);
         if (ret >= adjustment) {
             return ret - adjustment;
         } else {
@@ -339,7 +483,7 @@ public int forEachByte(int index, int length, ByteProcessor processor) {
     @Override
     public int forEachByteDesc(int index, int length, ByteProcessor processor) {
         checkIndex0(index, length);
-        int ret = buffer.forEachByteDesc(idx(index), length, processor);
+        int ret = unwrap().forEachByteDesc(idx(index), length, processor);
         if (ret >= adjustment) {
             return ret - adjustment;
         } else {
diff --git a/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
index 0133a229fd77..31b8bfb78402 100644
--- a/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java
@@ -33,6 +33,7 @@
  * @deprecated use the Little Endian accessors, e.g. {@code getShortLE}, {@code getIntLE}
  * instead.
  */
+@Deprecated
 public class SwappedByteBuf extends ByteBuf {
 
     private final ByteBuf buf;
@@ -92,6 +93,16 @@ public int maxCapacity() {
         return buf.maxCapacity();
     }
 
+    @Override
+    public boolean isReadOnly() {
+        return buf.isReadOnly();
+    }
+
+    @Override
+    public ByteBuf asReadOnly() {
+        return Unpooled.unmodifiableBuffer(this);
+    }
+
     @Override
     public boolean isDirect() {
         return buf.isDirect();
@@ -365,6 +376,11 @@ public int getBytes(int index, FileChannel out, long position, int length) throw
         return buf.getBytes(index, out, position, length);
     }
 
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        return buf.getCharSequence(index, length, charset);
+    }
+
     @Override
     public ByteBuf setBoolean(int index, boolean value) {
         buf.setBoolean(index, value);
@@ -500,6 +516,11 @@ public ByteBuf setZero(int index, int length) {
         return this;
     }
 
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        return buf.setCharSequence(index, sequence, charset);
+    }
+
     @Override
     public boolean readBoolean() {
         return buf.readBoolean();
@@ -610,6 +631,11 @@ public ByteBuf readSlice(int length) {
         return buf.readSlice(length).order(order);
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        return buf.readRetainedSlice(length).order(order);
+    }
+
     @Override
     public ByteBuf readBytes(ByteBuf dst) {
         buf.readBytes(dst);
@@ -662,6 +688,11 @@ public int readBytes(FileChannel out, long position, int length) throws IOExcept
         return buf.readBytes(out, position, length);
     }
 
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        return buf.readCharSequence(length, charset);
+    }
+
     @Override
     public ByteBuf skipBytes(int length) {
         buf.skipBytes(length);
@@ -803,6 +834,11 @@ public ByteBuf writeZero(int length) {
         return this;
     }
 
+    @Override
+    public int writeCharSequence(CharSequence sequence, Charset charset) {
+        return buf.writeCharSequence(sequence, charset);
+    }
+
     @Override
     public int indexOf(int fromIndex, int toIndex, byte value) {
         return buf.indexOf(fromIndex, toIndex, value);
@@ -858,16 +894,31 @@ public ByteBuf slice() {
         return buf.slice().order(order);
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        return buf.slice().order(order);
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         return buf.slice(index, length).order(order);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        return buf.slice(index, length).order(order);
+    }
+
     @Override
     public ByteBuf duplicate() {
         return buf.duplicate().order(order);
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        return buf.retainedDuplicate().order(order);
+    }
+
     @Override
     public int nioBufferCount() {
         return buf.nioBufferCount();
diff --git a/buffer/src/main/java/io/netty/buffer/Unpooled.java b/buffer/src/main/java/io/netty/buffer/Unpooled.java
index c2b45752cabf..9b6c434c944b 100644
--- a/buffer/src/main/java/io/netty/buffer/Unpooled.java
+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java
@@ -674,7 +674,10 @@ private static ByteBuf copiedBuffer(CharBuffer buffer, Charset charset) {
      * on the specified {@code buffer}.  The new buffer has the same
      * {@code readerIndex} and {@code writerIndex} with the specified
      * {@code buffer}.
+     *
+     * @deprecated Use {@link ByteBuf#asReadOnly()}.
      */
+    @Deprecated
     public static ByteBuf unmodifiableBuffer(ByteBuf buffer) {
         ByteOrder endianness = buffer.order();
         if (endianness == BIG_ENDIAN) {
diff --git a/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
index f28949bbb7ec..29ac97055681 100644
--- a/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java
@@ -334,6 +334,12 @@ protected short _getShort(int index) {
         return HeapByteBufUtil.getShort(array, index);
     }
 
+    @Override
+    public short getShortLE(int index) {
+        ensureAccessible();
+        return _getShortLE(index);
+    }
+
     @Override
     protected short _getShortLE(int index) {
         return HeapByteBufUtil.getShortLE(array, index);
@@ -350,6 +356,12 @@ protected int _getUnsignedMedium(int index) {
         return HeapByteBufUtil.getUnsignedMedium(array, index);
     }
 
+    @Override
+    public int getUnsignedMediumLE(int index) {
+        ensureAccessible();
+        return _getUnsignedMediumLE(index);
+    }
+
     @Override
     protected int _getUnsignedMediumLE(int index) {
         return HeapByteBufUtil.getUnsignedMediumLE(array, index);
@@ -366,6 +378,12 @@ protected int _getInt(int index) {
         return HeapByteBufUtil.getInt(array, index);
     }
 
+    @Override
+    public int getIntLE(int index) {
+        ensureAccessible();
+        return _getIntLE(index);
+    }
+
     @Override
     protected int _getIntLE(int index) {
         return HeapByteBufUtil.getIntLE(array, index);
@@ -382,6 +400,12 @@ protected long _getLong(int index) {
         return HeapByteBufUtil.getLong(array, index);
     }
 
+    @Override
+    public long getLongLE(int index) {
+        ensureAccessible();
+        return _getLongLE(index);
+    }
+
     @Override
     protected long _getLongLE(int index) {
         return HeapByteBufUtil.getLongLE(array, index);
@@ -411,6 +435,13 @@ protected void _setShort(int index, int value) {
         HeapByteBufUtil.setShort(array, index, value);
     }
 
+    @Override
+    public ByteBuf setShortLE(int index, int value) {
+        ensureAccessible();
+        _setShortLE(index, value);
+        return this;
+    }
+
     @Override
     protected void _setShortLE(int index, int value) {
         HeapByteBufUtil.setShortLE(array, index, value);
@@ -428,6 +459,13 @@ protected void _setMedium(int index, int value) {
         HeapByteBufUtil.setMedium(array, index, value);
     }
 
+    @Override
+    public ByteBuf setMediumLE(int index, int   value) {
+        ensureAccessible();
+        _setMediumLE(index, value);
+        return this;
+    }
+
     @Override
     protected void _setMediumLE(int index, int value) {
         HeapByteBufUtil.setMediumLE(array, index, value);
@@ -445,6 +483,13 @@ protected void _setInt(int index, int value) {
         HeapByteBufUtil.setInt(array, index, value);
     }
 
+    @Override
+    public ByteBuf setIntLE(int index, int   value) {
+        ensureAccessible();
+        _setIntLE(index, value);
+        return this;
+    }
+
     @Override
     protected void _setIntLE(int index, int value) {
         HeapByteBufUtil.setIntLE(array, index, value);
@@ -462,6 +507,13 @@ protected void _setLong(int index, long value) {
         HeapByteBufUtil.setLong(array, index, value);
     }
 
+    @Override
+    public ByteBuf setLongLE(int index, long  value) {
+        ensureAccessible();
+        _setLongLE(index, value);
+        return this;
+    }
+
     @Override
     protected void _setLongLE(int index, long value) {
         HeapByteBufUtil.setLongLE(array, index, value);
diff --git a/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeHeapByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeHeapByteBuf.java
index 9a40f61df63c..1f687d0596c9 100644
--- a/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeHeapByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeHeapByteBuf.java
@@ -15,7 +15,6 @@
  */
 package io.netty.buffer;
 
-
 import io.netty.util.internal.PlatformDependent;
 
 final class UnpooledUnsafeHeapByteBuf extends UnpooledHeapByteBuf {
@@ -52,6 +51,17 @@ protected short _getShort(int index) {
         return UnsafeByteBufUtil.getShort(array, index);
     }
 
+    @Override
+    public short getShortLE(int index) {
+        checkIndex(index, 2);
+        return _getShortLE(index);
+    }
+
+    @Override
+    protected short _getShortLE(int index) {
+        return UnsafeByteBufUtil.getShortLE(array, index);
+    }
+
     @Override
     public int getUnsignedMedium(int index) {
         checkIndex(index, 3);
@@ -63,6 +73,17 @@ protected int _getUnsignedMedium(int index) {
         return UnsafeByteBufUtil.getUnsignedMedium(array, index);
     }
 
+    @Override
+    public int getUnsignedMediumLE(int index) {
+        checkIndex(index, 3);
+        return _getUnsignedMediumLE(index);
+    }
+
+    @Override
+    protected int _getUnsignedMediumLE(int index) {
+        return UnsafeByteBufUtil.getUnsignedMediumLE(array, index);
+    }
+
     @Override
     public int getInt(int index) {
         checkIndex(index, 4);
@@ -74,6 +95,17 @@ protected int _getInt(int index) {
         return UnsafeByteBufUtil.getInt(array, index);
     }
 
+    @Override
+    public int getIntLE(int index) {
+        checkIndex(index, 4);
+        return _getIntLE(index);
+    }
+
+    @Override
+    protected int _getIntLE(int index) {
+        return UnsafeByteBufUtil.getIntLE(array, index);
+    }
+
     @Override
     public long getLong(int index) {
         checkIndex(index, 8);
@@ -85,6 +117,17 @@ protected long _getLong(int index) {
         return UnsafeByteBufUtil.getLong(array, index);
     }
 
+    @Override
+    public long getLongLE(int index) {
+        checkIndex(index, 8);
+        return _getLongLE(index);
+    }
+
+    @Override
+    protected long _getLongLE(int index) {
+        return UnsafeByteBufUtil.getLongLE(array, index);
+    }
+
     @Override
     public ByteBuf setByte(int index, int value) {
         checkIndex(index);
@@ -109,6 +152,18 @@ protected void _setShort(int index, int value) {
         UnsafeByteBufUtil.setShort(array, index, value);
     }
 
+    @Override
+    public ByteBuf setShortLE(int index, int value) {
+        checkIndex(index, 2);
+        _setShortLE(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setShortLE(int index, int value) {
+        UnsafeByteBufUtil.setShortLE(array, index, value);
+    }
+
     @Override
     public ByteBuf setMedium(int index, int   value) {
         checkIndex(index, 3);
@@ -121,6 +176,18 @@ protected void _setMedium(int index, int value) {
         UnsafeByteBufUtil.setMedium(array, index, value);
     }
 
+    @Override
+    public ByteBuf setMediumLE(int index, int   value) {
+        checkIndex(index, 3);
+        _setMediumLE(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setMediumLE(int index, int value) {
+        UnsafeByteBufUtil.setMediumLE(array, index, value);
+    }
+
     @Override
     public ByteBuf setInt(int index, int   value) {
         checkIndex(index, 4);
@@ -133,6 +200,18 @@ protected void _setInt(int index, int value) {
         UnsafeByteBufUtil.setInt(array, index, value);
     }
 
+    @Override
+    public ByteBuf setIntLE(int index, int   value) {
+        checkIndex(index, 4);
+        _setIntLE(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setIntLE(int index, int value) {
+        UnsafeByteBufUtil.setIntLE(array, index, value);
+    }
+
     @Override
     public ByteBuf setLong(int index, long  value) {
         checkIndex(index, 8);
@@ -146,6 +225,19 @@ protected void _setLong(int index, long value) {
     }
 
     @Override
+    public ByteBuf setLongLE(int index, long  value) {
+        checkIndex(index, 8);
+        _setLongLE(index, value);
+        return this;
+    }
+
+    @Override
+    protected void _setLongLE(int index, long value) {
+        UnsafeByteBufUtil.setLongLE(array, index, value);
+    }
+
+    @Override
+    @Deprecated
     protected SwappedByteBuf newSwappedByteBuf() {
         if (PlatformDependent.isUnaligned()) {
             // Only use if unaligned access is supported otherwise there is no gain.
diff --git a/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
index 2b26f29137cf..4fb10616107b 100644
--- a/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java
@@ -45,26 +45,51 @@ public ByteBuf order(ByteOrder endianness) {
         return swappedBuf;
     }
 
+    @Override
+    public ByteBuf asReadOnly() {
+        return new UnreleasableByteBuf(buf.asReadOnly());
+    }
+
     @Override
     public ByteBuf readSlice(int length) {
         return new UnreleasableByteBuf(buf.readSlice(length));
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        return new UnreleasableByteBuf(buf.readRetainedSlice(length));
+    }
+
     @Override
     public ByteBuf slice() {
         return new UnreleasableByteBuf(buf.slice());
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        return new UnreleasableByteBuf(buf.retainedSlice());
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         return new UnreleasableByteBuf(buf.slice(index, length));
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        return new UnreleasableByteBuf(buf.retainedSlice(index, length));
+    }
+
     @Override
     public ByteBuf duplicate() {
         return new UnreleasableByteBuf(buf.duplicate());
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        return new UnreleasableByteBuf(buf.retainedDuplicate());
+    }
+
     @Override
     public ByteBuf retain(int increment) {
         return this;
diff --git a/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java b/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java
index 9ddcfd8bde59..45aa60ce889b 100644
--- a/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java
@@ -93,6 +93,16 @@ public final ByteBuf unwrap() {
         return buf;
     }
 
+    @Override
+    public ByteBuf asReadOnly() {
+        return buf.asReadOnly();
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return buf.isReadOnly();
+    }
+
     @Override
     public final boolean isDirect() {
         return buf.isDirect();
@@ -356,6 +366,11 @@ public int getBytes(int index, FileChannel out, long position, int length) throw
         return buf.getBytes(index, out, position, length);
     }
 
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        return buf.getCharSequence(index, length, charset);
+    }
+
     @Override
     public ByteBuf setBoolean(int index, boolean value) {
         buf.setBoolean(index, value);
@@ -491,6 +506,11 @@ public ByteBuf setZero(int index, int length) {
         return this;
     }
 
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        return buf.setCharSequence(index, sequence, charset);
+    }
+
     @Override
     public boolean readBoolean() {
         return buf.readBoolean();
@@ -601,6 +621,11 @@ public ByteBuf readSlice(int length) {
         return buf.readSlice(length);
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        return buf.readRetainedSlice(length);
+    }
+
     @Override
     public ByteBuf readBytes(ByteBuf dst) {
         buf.readBytes(dst);
@@ -653,6 +678,11 @@ public int readBytes(FileChannel out, long position, int length) throws IOExcept
         return buf.readBytes(out, position, length);
     }
 
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        return buf.readCharSequence(length, charset);
+    }
+
     @Override
     public ByteBuf skipBytes(int length) {
         buf.skipBytes(length);
@@ -794,6 +824,11 @@ public ByteBuf writeZero(int length) {
         return this;
     }
 
+    @Override
+    public int writeCharSequence(CharSequence sequence, Charset charset) {
+        return buf.writeCharSequence(sequence, charset);
+    }
+
     @Override
     public int indexOf(int fromIndex, int toIndex, byte value) {
         return buf.indexOf(fromIndex, toIndex, value);
@@ -849,16 +884,31 @@ public ByteBuf slice() {
         return buf.slice();
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        return buf.retainedSlice();
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         return buf.slice(index, length);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        return buf.retainedSlice(index, length);
+    }
+
     @Override
     public ByteBuf duplicate() {
         return buf.duplicate();
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        return buf.retainedDuplicate();
+    }
+
     @Override
     public int nioBufferCount() {
         return buf.nioBufferCount();
diff --git a/buffer/src/main/java/io/netty/buffer/WrappedCompositeByteBuf.java b/buffer/src/main/java/io/netty/buffer/WrappedCompositeByteBuf.java
index 029d9c1372ae..8f5161620f98 100644
--- a/buffer/src/main/java/io/netty/buffer/WrappedCompositeByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/WrappedCompositeByteBuf.java
@@ -22,6 +22,7 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.channels.FileChannel;
 import java.nio.channels.GatheringByteChannel;
 import java.nio.channels.ScatteringByteChannel;
 import java.nio.charset.Charset;
@@ -332,11 +333,21 @@ public ByteBuf slice() {
         return wrapped.slice();
     }
 
+    @Override
+    public ByteBuf retainedSlice() {
+        return wrapped.retainedSlice();
+    }
+
     @Override
     public ByteBuf slice(int index, int length) {
         return wrapped.slice(index, length);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        return wrapped.retainedSlice(index, length);
+    }
+
     @Override
     public ByteBuffer nioBuffer() {
         return wrapped.nioBuffer();
@@ -417,11 +428,21 @@ public ByteBuf duplicate() {
         return wrapped.duplicate();
     }
 
+    @Override
+    public ByteBuf retainedDuplicate() {
+        return wrapped.retainedDuplicate();
+    }
+
     @Override
     public ByteBuf readSlice(int length) {
         return wrapped.readSlice(length);
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        return wrapped.readRetainedSlice(length);
+    }
+
     @Override
     public int readBytes(GatheringByteChannel out, int length) throws IOException {
         return wrapped.readBytes(out, length);
@@ -498,6 +519,30 @@ public CompositeByteBuf addComponents(int cIndex, Iterable<ByteBuf> buffers) {
         return this;
     }
 
+    @Override
+    public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {
+        wrapped.addComponent(increaseWriterIndex, buffer);
+        return this;
+    }
+
+    @Override
+    public CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) {
+        wrapped.addComponents(increaseWriterIndex, buffers);
+        return this;
+    }
+
+    @Override
+    public CompositeByteBuf addComponents(boolean increaseWriterIndex, Iterable<ByteBuf> buffers) {
+        wrapped.addComponents(increaseWriterIndex, buffers);
+        return this;
+    }
+
+    @Override
+    public CompositeByteBuf addComponent(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {
+        wrapped.addComponent(increaseWriterIndex, cIndex, buffer);
+        return this;
+    }
+
     @Override
     public CompositeByteBuf removeComponent(int cIndex) {
         wrapped.removeComponent(cIndex);
@@ -1009,6 +1054,61 @@ public CompositeByteBuf readBytes(OutputStream out, int length) throws IOExcepti
         return this;
     }
 
+    @Override
+    public int getBytes(int index, FileChannel out, long position, int length) throws IOException {
+        return wrapped.getBytes(index, out, position, length);
+    }
+
+    @Override
+    public int setBytes(int index, FileChannel in, long position, int length) throws IOException {
+        return wrapped.setBytes(index, in, position, length);
+    }
+
+    @Override
+    public boolean isReadOnly() {
+        return wrapped.isReadOnly();
+    }
+
+    @Override
+    public ByteBuf asReadOnly() {
+        return wrapped.asReadOnly();
+    }
+
+    @Override
+    protected SwappedByteBuf newSwappedByteBuf() {
+        return wrapped.newSwappedByteBuf();
+    }
+
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        return wrapped.getCharSequence(index, length, charset);
+    }
+
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        return wrapped.readCharSequence(length, charset);
+    }
+
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        return wrapped.setCharSequence(index, sequence, charset);
+    }
+
+    @Override
+    public int readBytes(FileChannel out, long position, int length) throws IOException {
+        return wrapped.readBytes(out, position, length);
+    }
+
+    @Override
+    public int writeBytes(FileChannel in, long position, int length) throws IOException {
+        return wrapped.writeBytes(in, position, length);
+    }
+
+    @Override
+    public int writeCharSequence(CharSequence sequence, Charset charset) {
+        return wrapped.writeCharSequence(sequence, charset);
+    }
+
     @Override
     public CompositeByteBuf skipBytes(int length) {
         wrapped.skipBytes(length);
diff --git a/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
index be6aa2b9684b..78912eb3d00a 100644
--- a/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java
@@ -846,11 +846,11 @@ public void testAddEmptyBuffersRelease() {
     public void testAddEmptyBufferInMiddle() {
         CompositeByteBuf cbuf = compositeBuffer();
         ByteBuf buf1 = buffer().writeByte((byte) 1);
-        cbuf.addComponent(buf1).writerIndex(cbuf.writerIndex() + buf1.readableBytes());
+        cbuf.addComponent(true, buf1);
         ByteBuf buf2 = EMPTY_BUFFER;
-        cbuf.addComponent(buf2).writerIndex(cbuf.writerIndex() + buf2.readableBytes());
+        cbuf.addComponent(true, buf2);
         ByteBuf buf3 = buffer().writeByte((byte) 2);
-        cbuf.addComponent(buf3).writerIndex(cbuf.writerIndex() + buf3.readableBytes());
+        cbuf.addComponent(true, buf3);
 
         assertEquals(2, cbuf.readableBytes());
         assertEquals((byte) 1, cbuf.readByte());
diff --git a/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java
index 46d07f8f2a19..a1a6fadb6ab0 100644
--- a/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java
@@ -53,7 +53,7 @@ private void testDiscardMarks(int capacity) {
 
         ByteBuf buf2 = newBuffer(capacity);
 
-        assertSame(unwrapIfNeeded(buf), unwrapIfNeeded(buf2));
+        assertEquals(unwrapIfNeeded(buf), unwrapIfNeeded(buf2));
 
         buf2.writeShort(1);
 
diff --git a/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareByteBufTest.java b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareByteBufTest.java
new file mode 100644
index 000000000000..9e1f73a2c1a4
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareByteBufTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.buffer;
+
+public class AdvancedLeakAwareByteBufTest extends SimpleLeakAwareByteBufTest {
+
+    @Override
+    protected Class<? extends ByteBuf> leakClass() {
+        return AdvancedLeakAwareByteBuf.class;
+    }
+
+    @Override
+    protected ByteBuf wrap(ByteBuf buffer) {
+        return new AdvancedLeakAwareByteBuf(buffer, NoopResourceLeak.INSTANCE);
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBufTest.java
new file mode 100644
index 000000000000..5f89ea5905eb
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBufTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.buffer;
+
+public class AdvancedLeakAwareCompositeByteBufTest extends SimpleLeakAwareCompositeByteBufTest {
+
+    @Override
+    protected WrappedCompositeByteBuf wrap(CompositeByteBuf buffer) {
+        return new AdvancedLeakAwareCompositeByteBuf(buffer, NoopResourceLeak.INSTANCE);
+    }
+
+    @Override
+    protected Class<? extends ByteBuf> leakClass() {
+        return AdvancedLeakAwareByteBuf.class;
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/DefaultByteBufHolderTest.java b/buffer/src/test/java/io/netty/buffer/DefaultByteBufHolderTest.java
index 0b462c4f5418..4c60d0e7b6dd 100644
--- a/buffer/src/test/java/io/netty/buffer/DefaultByteBufHolderTest.java
+++ b/buffer/src/test/java/io/netty/buffer/DefaultByteBufHolderTest.java
@@ -29,4 +29,17 @@ public void testToString() {
         assertTrue(holder.release());
         assertNotNull(holder.toString());
     }
+
+    @Test
+    public void testEqualsAndHashCode() {
+        ByteBufHolder holder = new DefaultByteBufHolder(Unpooled.EMPTY_BUFFER);
+        ByteBufHolder copy = holder.copy();
+        try {
+            assertEquals(holder, copy);
+            assertEquals(holder.hashCode(), copy.hashCode());
+        } finally {
+            holder.release();
+            copy.release();
+        }
+    }
 }
diff --git a/buffer/src/test/java/io/netty/buffer/DuplicateByteBufTest.java b/buffer/src/test/java/io/netty/buffer/DuplicatedByteBufTest.java
similarity index 97%
rename from buffer/src/test/java/io/netty/buffer/DuplicateByteBufTest.java
rename to buffer/src/test/java/io/netty/buffer/DuplicatedByteBufTest.java
index 5e2d9122b603..0e3783471063 100644
--- a/buffer/src/test/java/io/netty/buffer/DuplicateByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/DuplicatedByteBufTest.java
@@ -22,7 +22,7 @@
 /**
  * Tests duplicated channel buffers
  */
-public class DuplicateByteBufTest extends AbstractByteBufTest {
+public class DuplicatedByteBufTest extends AbstractByteBufTest {
 
     @Override
     protected ByteBuf newBuffer(int length) {
diff --git a/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java
index 66cab63b8fd5..2dafc91a14e5 100644
--- a/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java
@@ -314,4 +314,10 @@ public void testExtractNioBuffers() {
         assertEquals(1, byteBuffers[2].limit());
         composite.release();
     }
+
+    @Test
+    public void testEmptyArray() {
+        ByteBuf buf = newBuffer(new ByteBuf[0]);
+        buf.release();
+    }
 }
diff --git a/buffer/src/test/java/io/netty/buffer/NoopResourceLeak.java b/buffer/src/test/java/io/netty/buffer/NoopResourceLeak.java
new file mode 100644
index 000000000000..417bf86b31b8
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/NoopResourceLeak.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.buffer;
+
+import io.netty.util.ResourceLeak;
+
+final class NoopResourceLeak implements ResourceLeak {
+
+    static final NoopResourceLeak INSTANCE = new NoopResourceLeak();
+
+    private NoopResourceLeak() { }
+
+    @Override
+    public void record() { }
+
+    @Override
+    public void record(Object hint) { }
+
+    @Override
+    public boolean close() {
+        return false;
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
index 9bdd2431c04f..b23b1352b9fc 100644
--- a/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
+++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java
@@ -36,6 +36,42 @@
 
 public class PooledByteBufAllocatorTest {
 
+    @Test
+    public void testArenaMetricsNoCache() {
+        testArenaMetrics0(new PooledByteBufAllocator(true, 2, 2, 8192, 11, 0, 0, 0), 100, 0, 100, 100);
+    }
+
+    @Test
+    public void testArenaMetricsCache() {
+        testArenaMetrics0(new PooledByteBufAllocator(true, 2, 2, 8192, 11, 1000, 1000, 1000), 100, 1, 1, 0);
+    }
+
+    private static void testArenaMetrics0(
+            PooledByteBufAllocator allocator, int num, int expectedActive, int expectedAlloc, int expectedDealloc) {
+        for (int i = 0; i < num; i++) {
+            assertTrue(allocator.directBuffer().release());
+            assertTrue(allocator.heapBuffer().release());
+        }
+
+        assertArenaMetrics(allocator.directArenas(), expectedActive, expectedAlloc, expectedDealloc);
+        assertArenaMetrics(allocator.heapArenas(), expectedActive, expectedAlloc, expectedDealloc);
+    }
+
+    private static void assertArenaMetrics(
+            List<PoolArenaMetric> arenaMetrics, int expectedActive, int expectedAlloc, int expectedDealloc) {
+        int active = 0;
+        int alloc = 0;
+        int dealloc = 0;
+        for (PoolArenaMetric arena : arenaMetrics) {
+            active += arena.numActiveAllocations();
+            alloc += arena.numAllocations();
+            dealloc += arena.numDeallocations();
+        }
+        assertEquals(expectedActive, active);
+        assertEquals(expectedAlloc, alloc);
+        assertEquals(expectedDealloc, dealloc);
+    }
+
     @Test
     public void testPoolChunkListMetric() {
         for (PoolArenaMetric arenaMetric: PooledByteBufAllocator.DEFAULT.heapArenas()) {
@@ -125,8 +161,8 @@ public void run() {
         assertTrue(threadCachesCreated.get());
     }
 
-    @Test
-    public void testNumThreadCachesWithNoDirectArenas() {
+    @Test(timeout = 3000)
+    public void testNumThreadCachesWithNoDirectArenas() throws InterruptedException {
         int numHeapArenas = 1;
         final PooledByteBufAllocator allocator =
             new PooledByteBufAllocator(numHeapArenas, 0, 8192, 1);
@@ -144,7 +180,7 @@ public void testNumThreadCachesWithNoDirectArenas() {
         assertEquals(0, allocator.numThreadLocalCaches());
     }
 
-    @Test
+    @Test(timeout = 3000)
     public void testThreadCacheToArenaMappings() throws InterruptedException {
         int numArenas = 2;
         final PooledByteBufAllocator allocator =
@@ -188,17 +224,20 @@ private static void destroyThreadCache(CountDownLatch tcache) {
         LockSupport.parkNanos(MILLISECONDS.toNanos(100));
     }
 
-    private static CountDownLatch createNewThreadCache(final PooledByteBufAllocator allocator) {
+    private static CountDownLatch createNewThreadCache(final PooledByteBufAllocator allocator)
+            throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
-
+        final CountDownLatch cacheLatch = new CountDownLatch(1);
         Thread t = new FastThreadLocalThread(new Runnable() {
 
             @Override
             public void run() {
                 ByteBuf buf = allocator.newHeapBuffer(1024, 1024);
-                for (int i = 0; i < buf.capacity(); i++) {
-                    buf.writeByte(0);
-                }
+
+                // Countdown the latch after we allocated a buffer. At this point the cache must exists.
+                cacheLatch.countDown();
+
+                buf.writeZero(buf.capacity());
 
                 try {
                     latch.await();
@@ -213,8 +252,8 @@ public void run() {
         });
         t.start();
 
-        // Wait a bit for the thread & thread cache to be created.
-        LockSupport.parkNanos(MILLISECONDS.toNanos(100));
+        // Wait until we allocated a buffer and so be sure the thread was started and the cache exists.
+        cacheLatch.await();
 
         return latch;
     }
diff --git a/buffer/src/test/java/io/netty/buffer/RetainedDuplicatedByteBufTest.java b/buffer/src/test/java/io/netty/buffer/RetainedDuplicatedByteBufTest.java
new file mode 100644
index 000000000000..29cec0f2e8e4
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/RetainedDuplicatedByteBufTest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.buffer;
+
+import static org.junit.Assert.assertEquals;
+
+public class RetainedDuplicatedByteBufTest extends DuplicatedByteBufTest {
+    @Override
+    protected ByteBuf newBuffer(int length) {
+        ByteBuf wrapped = Unpooled.buffer(length);
+        ByteBuf buffer = wrapped.retainedDuplicate();
+        wrapped.release();
+
+        assertEquals(wrapped.writerIndex(), buffer.writerIndex());
+        assertEquals(wrapped.readerIndex(), buffer.readerIndex());
+        return buffer;
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/RetainedSlicedByteBufTest.java b/buffer/src/test/java/io/netty/buffer/RetainedSlicedByteBufTest.java
new file mode 100644
index 000000000000..bbd63baa1889
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/RetainedSlicedByteBufTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.buffer;
+
+import io.netty.util.internal.ThreadLocalRandom;
+
+import static org.junit.Assert.assertEquals;
+
+public class RetainedSlicedByteBufTest extends SlicedByteBufTest {
+    @Override
+    protected ByteBuf newBuffer(int length) {
+        ByteBuf wrapped = Unpooled.wrappedBuffer(new byte[length * 2]);
+        ByteBuf buffer = wrapped.retainedSlice(ThreadLocalRandom.current().nextInt(length - 1) + 1, length);
+        wrapped.release();
+
+        assertEquals(0, buffer.readerIndex());
+        assertEquals(length, buffer.writerIndex());
+        return buffer;
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/SimpleLeakAwareByteBufTest.java b/buffer/src/test/java/io/netty/buffer/SimpleLeakAwareByteBufTest.java
new file mode 100644
index 000000000000..d598be29c446
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/SimpleLeakAwareByteBufTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.buffer;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class SimpleLeakAwareByteBufTest extends BigEndianHeapByteBufTest {
+    private final Class<? extends ByteBuf> clazz = leakClass();
+
+    @Override
+    protected final ByteBuf newBuffer(int capacity) {
+        return wrap(super.newBuffer(capacity));
+    }
+
+    protected ByteBuf wrap(ByteBuf buffer) {
+        return new SimpleLeakAwareByteBuf(buffer, NoopResourceLeak.INSTANCE);
+    }
+
+    protected Class<? extends ByteBuf> leakClass() {
+        return SimpleLeakAwareByteBuf.class;
+    }
+
+    @Test
+    public void testWrapSlice() {
+        assertWrapped(newBuffer(8).slice());
+    }
+
+    @Test
+    public void testWrapSlice2() {
+        assertWrapped(newBuffer(8).slice(0, 1));
+    }
+
+    @Test
+    public void testWrapReadSlice() {
+        assertWrapped(newBuffer(8).readSlice(1));
+    }
+
+    @Test
+    public void testWrapRetainedSlice() {
+        assertWrapped(newBuffer(8).retainedSlice());
+    }
+
+    @Test
+    public void testWrapRetainedSlice2() {
+        assertWrapped(newBuffer(8).retainedSlice(0, 1));
+    }
+
+    @Test
+    public void testWrapReadRetainedSlice() {
+        assertWrapped(newBuffer(8).readRetainedSlice(1));
+    }
+
+    @Test
+    public void testWrapDuplicate() {
+        assertWrapped(newBuffer(8).duplicate());
+    }
+
+    @Test
+    public void testWrapRetainedDuplicate() {
+        assertWrapped(newBuffer(8).retainedDuplicate());
+    }
+
+    @Test
+    public void testWrapReadOnly() {
+        assertWrapped(newBuffer(8).asReadOnly());
+    }
+
+    protected final void assertWrapped(ByteBuf buf) {
+        try {
+            Assert.assertSame(clazz, buf.getClass());
+        } finally {
+            buf.release();
+        }
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/SimpleLeakAwareCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/SimpleLeakAwareCompositeByteBufTest.java
new file mode 100644
index 000000000000..1029d26cb060
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/SimpleLeakAwareCompositeByteBufTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.buffer;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class SimpleLeakAwareCompositeByteBufTest extends WrappedCompositeByteBufTest {
+
+    private final Class<? extends ByteBuf> clazz = leakClass();
+
+    @Override
+    protected WrappedCompositeByteBuf wrap(CompositeByteBuf buffer) {
+        return new SimpleLeakAwareCompositeByteBuf(buffer, NoopResourceLeak.INSTANCE);
+    }
+
+    protected Class<? extends ByteBuf> leakClass() {
+        return SimpleLeakAwareByteBuf.class;
+    }
+
+   @Test
+    public void testWrapSlice() {
+        assertWrapped(newBuffer(8).slice());
+    }
+
+    @Test
+    public void testWrapSlice2() {
+        assertWrapped(newBuffer(8).slice(0, 1));
+    }
+
+    @Test
+    public void testWrapReadSlice() {
+        assertWrapped(newBuffer(8).readSlice(1));
+    }
+
+    @Test
+    public void testWrapRetainedSlice() {
+        assertWrapped(newBuffer(8).retainedSlice());
+    }
+
+    @Test
+    public void testWrapRetainedSlice2() {
+        assertWrapped(newBuffer(8).retainedSlice(0, 1));
+    }
+
+    @Test
+    public void testWrapReadRetainedSlice() {
+        assertWrapped(newBuffer(8).readRetainedSlice(1));
+    }
+
+    @Test
+    public void testWrapDuplicate() {
+        assertWrapped(newBuffer(8).duplicate());
+    }
+
+    @Test
+    public void testWrapRetainedDuplicate() {
+        assertWrapped(newBuffer(8).retainedDuplicate());
+    }
+
+    @Test
+    public void testWrapReadOnly() {
+        assertWrapped(newBuffer(8).asReadOnly());
+    }
+
+    protected final void assertWrapped(ByteBuf buf) {
+        try {
+            Assert.assertSame(clazz, buf.getClass());
+        } finally {
+            buf.release();
+        }
+    }
+}
diff --git a/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java
index 0e06307df380..225ad90c03e7 100644
--- a/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java
+++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java
@@ -15,6 +15,7 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.internal.ThreadLocalRandom;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -27,12 +28,11 @@
  */
 public class SlicedByteBufTest extends AbstractByteBufTest {
 
-    private final Random random = new Random();
-
     @Override
     protected ByteBuf newBuffer(int length) {
         ByteBuf buffer = Unpooled.wrappedBuffer(
-                new byte[length * 2], random.nextInt(length - 1) + 1, length);
+                new byte[length * 2], ThreadLocalRandom.current().nextInt(length - 1) + 1, length);
+        assertEquals(0, buffer.readerIndex());
         assertEquals(length, buffer.writerIndex());
         return buffer;
     }
diff --git a/buffer/src/test/java/io/netty/buffer/WrappedCompositeByteBufTest.java b/buffer/src/test/java/io/netty/buffer/WrappedCompositeByteBufTest.java
new file mode 100644
index 000000000000..5d5630f0431d
--- /dev/null
+++ b/buffer/src/test/java/io/netty/buffer/WrappedCompositeByteBufTest.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.buffer;
+
+public class WrappedCompositeByteBufTest extends BigEndianCompositeByteBufTest {
+
+    @Override
+    protected final ByteBuf newBuffer(int length) {
+        return wrap((CompositeByteBuf) super.newBuffer(length));
+    }
+
+    protected WrappedCompositeByteBuf wrap(CompositeByteBuf buffer) {
+        return new WrappedCompositeByteBuf(buffer);
+    }
+}
diff --git a/codec-dns/pom.xml b/codec-dns/pom.xml
index 5cb39a4855d6..d063f006c1cc 100644
--- a/codec-dns/pom.xml
+++ b/codec-dns/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-dns</artifactId>
@@ -38,7 +38,6 @@
     <dependency>
       <groupId>org.apache.directory.server</groupId>
       <artifactId>apacheds-protocol-dns</artifactId>
-      <version>1.5.7</version>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java
index 31232cff47ff..41b18e3fbebb 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java
@@ -21,6 +21,7 @@
 import io.netty.util.ResourceLeak;
 import io.netty.util.ResourceLeakDetector;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -30,6 +31,7 @@
 /**
  * A skeletal implementation of {@link DnsMessage}.
  */
+@UnstableApi
 public abstract class AbstractDnsMessage extends AbstractReferenceCounted implements DnsMessage {
 
     private static final ResourceLeakDetector<DnsMessage> leakDetector =
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java
index bf3cd685bd6f..28b92c27f928 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.IDN;
 
@@ -24,6 +25,7 @@
 /**
  * A skeletal implementation of {@link DnsRecord}.
  */
+@UnstableApi
 public abstract class AbstractDnsRecord implements DnsRecord {
 
     private final String name;
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java
index daeda8b1781c..d61474a4ffd0 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.channel.AddressedEnvelope;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
@@ -23,6 +24,7 @@
 /**
  * A {@link DnsQuery} implementation for UDP/IP.
  */
+@UnstableApi
 public class DatagramDnsQuery extends DefaultDnsQuery
         implements AddressedEnvelope<DatagramDnsQuery, InetSocketAddress> {
 
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java
index c932075572fb..339d9655c83e 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java
@@ -21,6 +21,7 @@
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -30,6 +31,7 @@
 /**
  * Decodes a {@link DatagramPacket} into a {@link DatagramDnsQuery}.
  */
+@UnstableApi
 @ChannelHandler.Sharable
 public class DatagramDnsQueryDecoder extends MessageToMessageDecoder<DatagramPacket> {
 
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java
index 8344801a4561..dbb562fd2b5a 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java
@@ -21,6 +21,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -31,6 +32,7 @@
  * Encodes a {@link DatagramDnsQuery} (or an {@link AddressedEnvelope} of {@link DnsQuery}} into a
  * {@link DatagramPacket}.
  */
+@UnstableApi
 @ChannelHandler.Sharable
 public class DatagramDnsQueryEncoder extends MessageToMessageEncoder<AddressedEnvelope<DnsQuery, InetSocketAddress>> {
 
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponse.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponse.java
index 20dddd802694..bee775cc64af 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponse.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponse.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.channel.AddressedEnvelope;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
@@ -23,6 +24,7 @@
 /**
  * A {@link DnsResponse} implementation for UDP/IP.
  */
+@UnstableApi
 public class DatagramDnsResponse extends DefaultDnsResponse
         implements AddressedEnvelope<DatagramDnsResponse, InetSocketAddress> {
 
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java
index c9e879a47f9b..972d0fc6df26 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java
@@ -21,6 +21,7 @@
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -30,6 +31,7 @@
 /**
  * Decodes a {@link DatagramPacket} into a {@link DatagramDnsResponse}.
  */
+@UnstableApi
 @ChannelHandler.Sharable
 public class DatagramDnsResponseDecoder extends MessageToMessageDecoder<DatagramPacket> {
 
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseEncoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseEncoder.java
index ac7d909156bf..904c78392ca9 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseEncoder.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseEncoder.java
@@ -21,6 +21,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -31,6 +32,7 @@
  * Encodes a {@link DatagramDnsResponse} (or an {@link AddressedEnvelope} of {@link DnsResponse}} into a
  * {@link DatagramPacket}.
  */
+@UnstableApi
 @ChannelHandler.Sharable
 public class DatagramDnsResponseEncoder
     extends MessageToMessageEncoder<AddressedEnvelope<DnsResponse, InetSocketAddress>> {
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsPtrRecord.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsPtrRecord.java
index 517c5f957006..eeca18ec80ff 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsPtrRecord.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsPtrRecord.java
@@ -18,7 +18,9 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
+@UnstableApi
 public class DefaultDnsPtrRecord extends AbstractDnsRecord implements DnsPtrRecord {
 
     private final String hostname;
@@ -27,7 +29,6 @@ public class DefaultDnsPtrRecord extends AbstractDnsRecord implements DnsPtrReco
      * Creates a new PTR record.
      *
      * @param name the domain name
-     * @param type the type of the record
      * @param dnsClass the class of the record, usually one of the following:
      *                 <ul>
      *                     <li>{@link #CLASS_IN}</li>
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuery.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuery.java
index 422d34bce94e..b7b3732c6e6a 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuery.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuery.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * The default {@link DnsQuery} implementation.
  */
+@UnstableApi
 public class DefaultDnsQuery extends AbstractDnsMessage implements DnsQuery {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuestion.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuestion.java
index 09ceb1e62cad..af5bbf69cf5b 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuestion.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsQuestion.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link DnsQuestion} implementation.
  */
+@UnstableApi
 public class DefaultDnsQuestion extends AbstractDnsRecord implements DnsQuestion {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRawRecord.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRawRecord.java
index cba07c55d266..f70eeda7c1f8 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRawRecord.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRawRecord.java
@@ -17,12 +17,14 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@code DnsRawRecord} implementation.
  */
+@UnstableApi
 public class DefaultDnsRawRecord extends AbstractDnsRecord implements DnsRawRecord {
 
     private final ByteBuf content;
@@ -67,12 +69,22 @@ public ByteBuf content() {
 
     @Override
     public DnsRawRecord copy() {
-        return new DefaultDnsRawRecord(name(), type(), dnsClass(), timeToLive(), content().copy());
+        return replace(content().copy());
     }
 
     @Override
     public DnsRawRecord duplicate() {
-        return new DefaultDnsRawRecord(name(), type(), dnsClass(), timeToLive(), content().duplicate());
+        return replace(content().duplicate());
+    }
+
+    @Override
+    public DnsRawRecord retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public DnsRawRecord replace(ByteBuf content) {
+        return new DefaultDnsRawRecord(name(), type(), dnsClass(), timeToLive(), content);
     }
 
     @Override
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
index 3dc24a410849..d630413c8431 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java
@@ -18,12 +18,14 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.CorruptedFrameException;
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link DnsRecordDecoder} implementation.
  *
  * @see DefaultDnsRecordEncoder
  */
+@UnstableApi
 public class DefaultDnsRecordDecoder implements DnsRecordDecoder {
 
     static final String ROOT = ".";
@@ -93,7 +95,7 @@ protected DnsRecord decodeRecord(
             return new DefaultDnsPtrRecord(name, dnsClass, timeToLive, decodeName(in));
         }
         return new DefaultDnsRawRecord(
-                name, type, dnsClass, timeToLive, in.duplicate().setIndex(offset, offset + length).retain());
+                name, type, dnsClass, timeToLive, in.retainedDuplicate().setIndex(offset, offset + length));
     }
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
index 3222566e0622..679e87e83e37 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBufUtil;
 import io.netty.handler.codec.UnsupportedMessageTypeException;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.ROOT;
 
@@ -27,6 +28,7 @@
  *
  * @see DefaultDnsRecordDecoder
  */
+@UnstableApi
 public class DefaultDnsRecordEncoder implements DnsRecordEncoder {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsResponse.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsResponse.java
index c0a6bc22ae4e..987febeba974 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsResponse.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsResponse.java
@@ -15,11 +15,14 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@link DnsResponse} implementation.
  */
+@UnstableApi
 public class DefaultDnsResponse extends AbstractDnsMessage implements DnsResponse {
 
     private boolean authoritativeAnswer;
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java
index a4b9902b058c..f6d1abbd4006 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessage.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.util.ReferenceCounted;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The superclass which contains core information concerning a {@link DnsQuery} and a {@link DnsResponse}.
  */
+@UnstableApi
 public interface DnsMessage extends ReferenceCounted {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java
index 4140b2e3ff9d..6b615053259a 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsOpCode.java
@@ -15,11 +15,14 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The DNS {@code OpCode} as defined in <a href="https://tools.ietf.org/html/rfc2929">RFC2929</a>.
  */
+@UnstableApi
 public class DnsOpCode implements Comparable<DnsOpCode> {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsPtrRecord.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsPtrRecord.java
index 53962e11426f..b99518af68b8 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsPtrRecord.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsPtrRecord.java
@@ -15,6 +15,9 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
+@UnstableApi
 public interface DnsPtrRecord extends DnsRecord {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java
index a30e51de0b33..ca21fd77a8ba 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuery.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * A DNS query message.
  */
+@UnstableApi
 public interface DnsQuery extends DnsMessage {
     @Override
     DnsQuery setId(int id);
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java
index 082ca3a11b8a..fa614cd1037d 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * A DNS question.
  */
+@UnstableApi
 public interface DnsQuestion extends DnsRecord {
     /**
      * An unused property. This method will always return {@code 0}.
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRawRecord.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRawRecord.java
index 524f8da33540..8176c9110921 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRawRecord.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRawRecord.java
@@ -15,11 +15,14 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * A generic {@link DnsRecord} that contains an undecoded {@code RDATA}.
  */
+@UnstableApi
 public interface DnsRawRecord extends DnsRecord, ByteBufHolder {
     @Override
     DnsRawRecord copy();
@@ -27,6 +30,12 @@ public interface DnsRawRecord extends DnsRecord, ByteBufHolder {
     @Override
     DnsRawRecord duplicate();
 
+    @Override
+    DnsRawRecord retainedDuplicate();
+
+    @Override
+    DnsRawRecord replace(ByteBuf content);
+
     @Override
     DnsRawRecord retain();
 
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecord.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecord.java
index eb1c060498f5..7ccadd939889 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecord.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecord.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * A DNS resource record.
  */
+@UnstableApi
 public interface DnsRecord {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java
index a2b6315acccb..0870b466868b 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordDecoder.java
@@ -16,12 +16,14 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Decodes a DNS record into its object representation.
  *
  * @see DatagramDnsResponseDecoder
  */
+@UnstableApi
 public interface DnsRecordDecoder {
 
     DnsRecordDecoder DEFAULT = new DefaultDnsRecordDecoder();
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordEncoder.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordEncoder.java
index 56b7fa1a0585..503a4009e709 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordEncoder.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordEncoder.java
@@ -16,12 +16,14 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Encodes a {@link DnsRecord} into binary representation.
  *
  * @see DatagramDnsQueryEncoder
  */
+@UnstableApi
 public interface DnsRecordEncoder {
 
     DnsRecordEncoder DEFAULT = new DefaultDnsRecordEncoder();
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordType.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordType.java
index 77f3d3c5a653..1c5f79b8d787 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordType.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsRecordType.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.dns;
 
 import io.netty.util.collection.IntObjectHashMap;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -23,6 +24,7 @@
 /**
  * Represents a DNS record type.
  */
+@UnstableApi
 public class DnsRecordType implements Comparable<DnsRecordType> {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java
index ef1370c59759..345f66d68f35 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponse.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * A DNS response message.
  */
+@UnstableApi
 public interface DnsResponse extends DnsMessage {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java
index dcd4c945aa5c..abc9b0d4eab3 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseCode.java
@@ -15,11 +15,14 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The DNS {@code RCODE}, as defined in <a href="https://tools.ietf.org/html/rfc2929">RFC2929</a>.
  */
+@UnstableApi
 public class DnsResponseCode implements Comparable<DnsResponseCode> {
 
     /**
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsSection.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsSection.java
index 1d0c842d1b58..dc597c2ef353 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsSection.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsSection.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Represents a section of a {@link DnsMessage}.
  */
+@UnstableApi
 public enum DnsSection {
     /**
      * The section that contains {@link DnsQuestion}s.
diff --git a/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java b/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
index e45c7dfcac80..0be6aa683aa5 100644
--- a/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/package-info.java
@@ -17,4 +17,7 @@
 /**
  * DNS codec.
  */
+@UnstableApi
 package io.netty.handler.codec.dns;
+
+import io.netty.util.internal.UnstableApi;
diff --git a/codec-haproxy/pom.xml b/codec-haproxy/pom.xml
index abfd42049108..14c7d1d2c504 100644
--- a/codec-haproxy/pom.xml
+++ b/codec-haproxy/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-haproxy</artifactId>
diff --git a/codec-http/pom.xml b/codec-http/pom.xml
index 72e8c54a27b5..f46e7ffb101b 100644
--- a/codec-http/pom.xml
+++ b/codec-http/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-http</artifactId>
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java
index 7259d218eb07..b8b7dc967fac 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java
@@ -27,6 +27,7 @@ final class ComposedLastHttpContent implements LastHttpContent {
     ComposedLastHttpContent(HttpHeaders trailingHeaders) {
         this.trailingHeaders = trailingHeaders;
     }
+
     @Override
     public HttpHeaders trailingHeaders() {
         return trailingHeaders;
@@ -39,6 +40,23 @@ public LastHttpContent copy() {
         return content;
     }
 
+    @Override
+    public LastHttpContent duplicate() {
+        return copy();
+    }
+
+    @Override
+    public LastHttpContent retainedDuplicate() {
+        return copy();
+    }
+
+    @Override
+    public LastHttpContent replace(ByteBuf content) {
+        final LastHttpContent dup = new DefaultLastHttpContent(content);
+        dup.trailingHeaders().setAll(trailingHeaders());
+        return dup;
+    }
+
     @Override
     public LastHttpContent retain(int increment) {
         return this;
@@ -59,11 +77,6 @@ public LastHttpContent touch(Object hint) {
         return this;
     }
 
-    @Override
-    public LastHttpContent duplicate() {
-        return copy();
-    }
-
     @Override
     public ByteBuf content() {
         return Unpooled.EMPTY_BUFFER;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
index 5d8e183383b0..ba55d9657e99 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java
@@ -125,44 +125,24 @@ public FullHttpRequest setUri(String uri) {
         return this;
     }
 
-    /**
-     * Copy this object
-     *
-     * @param copyContent
-     * <ul>
-     * <li>{@code true} if this object's {@link #content()} should be used to copy.</li>
-     * <li>{@code false} if {@code newContent} should be used instead.</li>
-     * </ul>
-     * @param newContent
-     * <ul>
-     * <li>if {@code copyContent} is false then this will be used in the copy's content.</li>
-     * <li>if {@code null} then a default buffer of 0 size will be selected</li>
-     * </ul>
-     * @return A copy of this object
-     */
-    private FullHttpRequest copy(boolean copyContent, ByteBuf newContent) {
-        return new DefaultFullHttpRequest(
-                protocolVersion(), method(), uri(),
-                copyContent ? content().copy() :
-                        newContent == null ? Unpooled.buffer(0) : newContent,
-                headers(),
-                trailingHeaders());
+    @Override
+    public FullHttpRequest copy() {
+        return replace(content().copy());
     }
 
     @Override
-    public FullHttpRequest copy(ByteBuf newContent) {
-        return copy(false, newContent);
+    public FullHttpRequest duplicate() {
+        return replace(content().duplicate());
     }
 
     @Override
-    public FullHttpRequest copy() {
-        return copy(true, null);
+    public FullHttpRequest retainedDuplicate() {
+        return replace(content().retainedDuplicate());
     }
 
     @Override
-    public FullHttpRequest duplicate() {
-        return new DefaultFullHttpRequest(
-                protocolVersion(), method(), uri(), content().duplicate(), headers(), trailingHeaders());
+    public FullHttpRequest replace(ByteBuf content) {
+        return new DefaultFullHttpRequest(protocolVersion(), method(), uri(), content, headers(), trailingHeaders());
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
index 8e48c764ece7..134865cabb58 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java
@@ -132,44 +132,24 @@ public FullHttpResponse setStatus(HttpResponseStatus status) {
         return this;
     }
 
-    /**
-     * Copy this object
-     *
-     * @param copyContent
-     * <ul>
-     * <li>{@code true} if this object's {@link #content()} should be used to copy.</li>
-     * <li>{@code false} if {@code newContent} should be used instead.</li>
-     * </ul>
-     * @param newContent
-     * <ul>
-     * <li>if {@code copyContent} is false then this will be used in the copy's content.</li>
-     * <li>if {@code null} then a default buffer of 0 size will be selected</li>
-     * </ul>
-     * @return A copy of this object
-     */
-    private FullHttpResponse copy(boolean copyContent, ByteBuf newContent) {
-        return new DefaultFullHttpResponse(
-                protocolVersion(), status(),
-                copyContent ? content().copy() :
-                        newContent == null ? Unpooled.buffer(0) : newContent,
-                headers(),
-                trailingHeaders());
+    @Override
+    public FullHttpResponse copy() {
+        return replace(content().copy());
     }
 
     @Override
-    public FullHttpResponse copy(ByteBuf newContent) {
-        return copy(false, newContent);
+    public FullHttpResponse duplicate() {
+        return replace(content().duplicate());
     }
 
     @Override
-    public FullHttpResponse copy() {
-        return copy(true, null);
+    public FullHttpResponse retainedDuplicate() {
+        return replace(content().retainedDuplicate());
     }
 
     @Override
-    public FullHttpResponse duplicate() {
-        return new DefaultFullHttpResponse(protocolVersion(), status(),
-                content().duplicate(), headers(), trailingHeaders());
+    public FullHttpResponse replace(ByteBuf content) {
+        return new DefaultFullHttpResponse(protocolVersion(), status(), content, headers(), trailingHeaders());
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
index 18f6a6b79445..48fad8eb1abe 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java
@@ -42,12 +42,22 @@ public ByteBuf content() {
 
     @Override
     public HttpContent copy() {
-        return new DefaultHttpContent(content.copy());
+        return replace(content.copy());
     }
 
     @Override
     public HttpContent duplicate() {
-        return new DefaultHttpContent(content.duplicate());
+        return replace(content.duplicate());
+    }
+
+    @Override
+    public HttpContent retainedDuplicate() {
+        return replace(content.retainedDuplicate());
+    }
+
+    @Override
+    public HttpContent replace(ByteBuf content) {
+        return new DefaultHttpContent(content);
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
index e49790c3f215..8e9518b3ef12 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java
@@ -53,6 +53,9 @@ public boolean process(byte value) throws Exception {
     static final NameValidator<CharSequence> HttpNameValidator = new NameValidator<CharSequence>() {
         @Override
         public void validateName(CharSequence name) {
+            if (name == null || name.length() == 0) {
+                throw new IllegalArgumentException("empty headers are not allowed [" + name + "]");
+            }
             if (name instanceof AsciiString) {
                 try {
                     ((AsciiString) name).forEachByte(HEADER_NAME_VALIDATOR);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java
index cc8ef0c7d69f..67c619a521ac 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java
@@ -45,16 +45,24 @@ public DefaultLastHttpContent(ByteBuf content, boolean validateHeaders) {
 
     @Override
     public LastHttpContent copy() {
-        DefaultLastHttpContent copy = new DefaultLastHttpContent(content().copy(), validateHeaders);
-        copy.trailingHeaders().set(trailingHeaders());
-        return copy;
+        return replace(content().copy());
     }
 
     @Override
     public LastHttpContent duplicate() {
-        DefaultLastHttpContent copy = new DefaultLastHttpContent(content().duplicate(), validateHeaders);
-        copy.trailingHeaders().set(trailingHeaders());
-        return copy;
+        return replace(content().duplicate());
+    }
+
+    @Override
+    public LastHttpContent retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public LastHttpContent replace(ByteBuf content) {
+        final DefaultLastHttpContent dup = new DefaultLastHttpContent(content, validateHeaders);
+        dup.trailingHeaders().set(trailingHeaders());
+        return dup;
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
index 4f63eed04e7d..40fc28f8a5de 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java
@@ -22,19 +22,18 @@
  * message. So it represent a <i>complete</i> http message.
  */
 public interface FullHttpMessage extends HttpMessage, LastHttpContent {
-    /**
-     * Create a copy of this {@link FullHttpMessage} with alternative content.
-     *
-     * @param newContent The buffer to use instead of this {@link FullHttpMessage}'s content in the copy operation.
-     * <p>
-     * NOTE: retain will NOT be called on this buffer. {@code null} results in an empty default choice buffer.
-     * @return The result of the copy operation
-     */
-    FullHttpMessage copy(ByteBuf newContent);
-
     @Override
     FullHttpMessage copy();
 
+    @Override
+    FullHttpMessage duplicate();
+
+    @Override
+    FullHttpMessage retainedDuplicate();
+
+    @Override
+    FullHttpMessage replace(ByteBuf content);
+
     @Override
     FullHttpMessage retain(int increment);
 
@@ -46,7 +45,4 @@ public interface FullHttpMessage extends HttpMessage, LastHttpContent {
 
     @Override
     FullHttpMessage touch(Object hint);
-
-    @Override
-    FullHttpMessage duplicate();
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
index cd8c01da572d..3cbae69a849f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java
@@ -23,10 +23,16 @@
  */
 public interface FullHttpRequest extends HttpRequest, FullHttpMessage {
     @Override
-    FullHttpRequest copy(ByteBuf newContent);
+    FullHttpRequest copy();
 
     @Override
-    FullHttpRequest copy();
+    FullHttpRequest duplicate();
+
+    @Override
+    FullHttpRequest retainedDuplicate();
+
+    @Override
+    FullHttpRequest replace(ByteBuf content);
 
     @Override
     FullHttpRequest retain(int increment);
@@ -40,9 +46,6 @@ public interface FullHttpRequest extends HttpRequest, FullHttpMessage {
     @Override
     FullHttpRequest touch(Object hint);
 
-    @Override
-    FullHttpRequest duplicate();
-
     @Override
     FullHttpRequest setProtocolVersion(HttpVersion version);
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java
index 5a5cc4010cb2..0b9474938d8e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java
@@ -23,10 +23,16 @@
  */
 public interface FullHttpResponse extends HttpResponse, FullHttpMessage {
     @Override
-    FullHttpResponse copy(ByteBuf newContent);
+    FullHttpResponse copy();
 
     @Override
-    FullHttpResponse copy();
+    FullHttpResponse duplicate();
+
+    @Override
+    FullHttpResponse retainedDuplicate();
+
+    @Override
+    FullHttpResponse replace(ByteBuf content);
 
     @Override
     FullHttpResponse retain(int increment);
@@ -40,9 +46,6 @@ public interface FullHttpResponse extends HttpResponse, FullHttpMessage {
     @Override
     FullHttpResponse touch(Object hint);
 
-    @Override
-    FullHttpResponse duplicate();
-
     @Override
     FullHttpResponse setProtocolVersion(HttpVersion version);
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
index de702742a7c5..0dae011e2486 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContent.java
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
 import io.netty.channel.ChannelPipeline;
 
@@ -33,6 +34,12 @@ public interface HttpContent extends HttpObject, ByteBufHolder {
     @Override
     HttpContent duplicate();
 
+    @Override
+    HttpContent retainedDuplicate();
+
+    @Override
+    HttpContent replace(ByteBuf content);
+
     @Override
     HttpContent retain();
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
index 635ab81fb1e9..5cfad30982e3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java
@@ -16,7 +16,6 @@
 package io.netty.handler.codec.http;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufHolder;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
@@ -121,11 +120,11 @@ protected boolean isContentLengthInvalid(HttpMessage start, int maxContentLength
     protected Object newContinueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {
         if (HttpUtil.is100ContinueExpected(start)) {
             if (getContentLength(start, -1L) <= maxContentLength) {
-                return CONTINUE.duplicate().retain();
+                return CONTINUE.retainedDuplicate();
             }
 
             pipeline.fireUserEventTriggered(HttpExpectationFailedEvent.INSTANCE);
-            return EXPECTATION_FAILED.duplicate().retain();
+            return EXPECTATION_FAILED.retainedDuplicate();
         }
         return null;
     }
@@ -176,7 +175,7 @@ protected void finishAggregation(FullHttpMessage aggregated) throws Exception {
         // See rfc2616 14.13 Content-Length
         if (!HttpUtil.isContentLengthSet(aggregated)) {
             aggregated.headers().set(
-                    HttpHeaderNames.CONTENT_LENGTH,
+                    CONTENT_LENGTH,
                     String.valueOf(aggregated.content().readableBytes()));
         }
     }
@@ -185,7 +184,7 @@ protected void finishAggregation(FullHttpMessage aggregated) throws Exception {
     protected void handleOversizedMessage(final ChannelHandlerContext ctx, HttpMessage oversized) throws Exception {
         if (oversized instanceof HttpRequest) {
             // send back a 413 and close the connection
-            ChannelFuture future = ctx.writeAndFlush(TOO_LARGE.duplicate().retain()).addListener(
+            ChannelFuture future = ctx.writeAndFlush(TOO_LARGE.retainedDuplicate()).addListener(
                     new ChannelFutureListener() {
                 @Override
                 public void operationComplete(ChannelFuture future) throws Exception {
@@ -217,7 +216,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
         }
     }
 
-    private abstract static class AggregatedFullHttpMessage implements ByteBufHolder, FullHttpMessage {
+    private abstract static class AggregatedFullHttpMessage implements FullHttpMessage {
         protected final HttpMessage message;
         private final ByteBuf content;
         private HttpHeaders trailingHeaders;
@@ -327,6 +326,9 @@ public boolean release(int decrement) {
 
         @Override
         public abstract FullHttpMessage duplicate();
+
+        @Override
+        public abstract FullHttpMessage retainedDuplicate();
     }
 
     private static final class AggregatedFullHttpRequest extends AggregatedFullHttpMessage implements FullHttpRequest {
@@ -335,48 +337,27 @@ private static final class AggregatedFullHttpRequest extends AggregatedFullHttpM
             super(request, content, trailingHeaders);
         }
 
-        /**
-         * Copy this object
-         *
-         * @param copyContent
-         * <ul>
-         * <li>{@code true} if this object's {@link #content()} should be used to copy.</li>
-         * <li>{@code false} if {@code newContent} should be used instead.</li>
-         * </ul>
-         * @param newContent
-         * <ul>
-         * <li>if {@code copyContent} is false then this will be used in the copy's content.</li>
-         * <li>if {@code null} then a default buffer of 0 size will be selected</li>
-         * </ul>
-         * @return A copy of this object
-         */
-        private FullHttpRequest copy(boolean copyContent, ByteBuf newContent) {
-            DefaultFullHttpRequest copy = new DefaultFullHttpRequest(
-                    protocolVersion(), method(), uri(),
-                    copyContent ? content().copy() :
-                            newContent == null ? Unpooled.buffer(0) : newContent);
-            copy.headers().set(headers());
-            copy.trailingHeaders().set(trailingHeaders());
-            return copy;
+        @Override
+        public FullHttpRequest copy() {
+            return replace(content().copy());
         }
 
         @Override
-        public FullHttpRequest copy(ByteBuf newContent) {
-            return copy(false, newContent);
+        public FullHttpRequest duplicate() {
+            return replace(content().duplicate());
         }
 
         @Override
-        public FullHttpRequest copy() {
-            return copy(true, null);
+        public FullHttpRequest retainedDuplicate() {
+            return replace(content().retainedDuplicate());
         }
 
         @Override
-        public FullHttpRequest duplicate() {
-            DefaultFullHttpRequest duplicate = new DefaultFullHttpRequest(
-                    getProtocolVersion(), getMethod(), getUri(), content().duplicate());
-            duplicate.headers().set(headers());
-            duplicate.trailingHeaders().set(trailingHeaders());
-            return duplicate;
+        public FullHttpRequest replace(ByteBuf content) {
+            DefaultFullHttpRequest dup = new DefaultFullHttpRequest(protocolVersion(), method(), uri(), content);
+            dup.headers().set(headers());
+            dup.trailingHeaders().set(trailingHeaders());
+            return dup;
         }
 
         @Override
@@ -454,48 +435,27 @@ private static final class AggregatedFullHttpResponse extends AggregatedFullHttp
             super(message, content, trailingHeaders);
         }
 
-        /**
-         * Copy this object
-         *
-         * @param copyContent
-         * <ul>
-         * <li>{@code true} if this object's {@link #content()} should be used to copy.</li>
-         * <li>{@code false} if {@code newContent} should be used instead.</li>
-         * </ul>
-         * @param newContent
-         * <ul>
-         * <li>if {@code copyContent} is false then this will be used in the copy's content.</li>
-         * <li>if {@code null} then a default buffer of 0 size will be selected</li>
-         * </ul>
-         * @return A copy of this object
-         */
-        private FullHttpResponse copy(boolean copyContent, ByteBuf newContent) {
-            DefaultFullHttpResponse copy = new DefaultFullHttpResponse(
-                    protocolVersion(), status(),
-                    copyContent ? content().copy() :
-                            newContent == null ? Unpooled.buffer(0) : newContent);
-            copy.headers().set(headers());
-            copy.trailingHeaders().set(trailingHeaders());
-            return copy;
+        @Override
+        public FullHttpResponse copy() {
+            return replace(content().copy());
         }
 
         @Override
-        public FullHttpResponse copy(ByteBuf newContent) {
-            return copy(false, newContent);
+        public FullHttpResponse duplicate() {
+            return replace(content().duplicate());
         }
 
         @Override
-        public FullHttpResponse copy() {
-            return copy(true, null);
+        public FullHttpResponse retainedDuplicate() {
+            return replace(content().retainedDuplicate());
         }
 
         @Override
-        public FullHttpResponse duplicate() {
-            DefaultFullHttpResponse duplicate = new DefaultFullHttpResponse(getProtocolVersion(), getStatus(),
-                    content().duplicate());
-            duplicate.headers().set(headers());
-            duplicate.trailingHeaders().set(trailingHeaders());
-            return duplicate;
+        public FullHttpResponse replace(ByteBuf content) {
+            DefaultFullHttpResponse dup = new DefaultFullHttpResponse(getProtocolVersion(), getStatus(), content);
+            dup.headers().set(headers());
+            dup.trailingHeaders().set(trailingHeaders());
+            return dup;
         }
 
         @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
index 432c4279781f..5445ca5f9fae 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java
@@ -279,7 +279,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
             // Keep reading data as a chunk until the end of connection is reached.
             int toRead = Math.min(buffer.readableBytes(), maxChunkSize);
             if (toRead > 0) {
-                ByteBuf content = buffer.readSlice(toRead).retain();
+                ByteBuf content = buffer.readRetainedSlice(toRead);
                 out.add(new DefaultHttpContent(content));
             }
             return;
@@ -301,7 +301,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
             if (toRead > chunkSize) {
                 toRead = (int) chunkSize;
             }
-            ByteBuf content = buffer.readSlice(toRead).retain();
+            ByteBuf content = buffer.readRetainedSlice(toRead);
             chunkSize -= toRead;
 
             if (chunkSize == 0) {
@@ -341,7 +341,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
             if (toRead == 0) {
                 return;
             }
-            HttpContent chunk = new DefaultHttpContent(buffer.readSlice(toRead).retain());
+            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));
             chunkSize -= toRead;
 
             out.add(chunk);
@@ -400,6 +400,11 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> ou
     protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
         super.decodeLast(ctx, in, out);
 
+        if (resetRequested) {
+            // If a reset was requested by decodeLast() we need to do it now otherwise we may produce a
+            // LastHttpContent while there was already one.
+            resetNow();
+        }
         // Handle the last unfinished message.
         if (message != null) {
             boolean chunked = HttpUtil.isTransferEncodingChunked(message);
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java b/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
index b222c570297a..be62a47f2eab 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java
@@ -44,6 +44,16 @@ public LastHttpContent duplicate() {
             return this;
         }
 
+        @Override
+        public LastHttpContent replace(ByteBuf content) {
+            return new DefaultLastHttpContent(content);
+        }
+
+        @Override
+        public LastHttpContent retainedDuplicate() {
+            return this;
+        }
+
         @Override
         public HttpHeaders trailingHeaders() {
             return EmptyHttpHeaders.INSTANCE;
@@ -111,6 +121,15 @@ public String toString() {
     @Override
     LastHttpContent copy();
 
+    @Override
+    LastHttpContent duplicate();
+
+    @Override
+    LastHttpContent retainedDuplicate();
+
+    @Override
+    LastHttpContent replace(ByteBuf content);
+
     @Override
     LastHttpContent retain(int increment);
 
@@ -122,7 +141,4 @@ public String toString() {
 
     @Override
     LastHttpContent touch(Object hint);
-
-    @Override
-    LastHttpContent duplicate();
 }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java
index 52457b32317b..93d76ae82dc8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java
@@ -99,7 +99,7 @@ public static CorsConfigBuilder forOrigins(final String... origins) {
     /**
      * Web browsers may set the 'Origin' request header to 'null' if a resource is loaded
      * from the local file system. Calling this method will enable a successful CORS response
-     * with a wildcard for the the CORS response header 'Access-Control-Allow-Origin'.
+     * with a {@code "null"} value for the the CORS response header 'Access-Control-Allow-Origin'.
      *
      * @return {@link CorsConfigBuilder} to support method chaining.
      */
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
index 048ecabe4565..d4a43fcaa2ff 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java
@@ -42,6 +42,7 @@ public class CorsHandler extends ChannelDuplexHandler {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(CorsHandler.class);
     private static final String ANY_ORIGIN = "*";
+    private static final String NULL_ORIGIN = "null";
     private final CorsConfig config;
 
     private HttpRequest request;
@@ -95,8 +96,8 @@ private void setPreflightHeaders(final HttpResponse response) {
     private boolean setOrigin(final HttpResponse response) {
         final String origin = request.headers().get(HttpHeaderNames.ORIGIN);
         if (origin != null) {
-            if ("null".equals(origin) && config.isNullOriginAllowed()) {
-                setAnyOrigin(response);
+            if (NULL_ORIGIN.equals(origin) && config.isNullOriginAllowed()) {
+                setNullOrigin(response);
                 return true;
             }
             if (config.isAnyOriginSupported()) {
@@ -148,6 +149,10 @@ private static void setAnyOrigin(final HttpResponse response) {
         setOrigin(response, ANY_ORIGIN);
     }
 
+    private static void setNullOrigin(final HttpResponse response) {
+        setOrigin(response, NULL_ORIGIN);
+    }
+
     private static void setOrigin(final HttpResponse response, final String origin) {
         response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, origin);
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
index e0870e11f628..31aa9ce64b5f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java
@@ -28,7 +28,10 @@
 import java.nio.channels.FileChannel;
 import java.nio.charset.Charset;
 
-import static io.netty.buffer.Unpooled.*;
+import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
+import static io.netty.buffer.Unpooled.buffer;
+import static io.netty.buffer.Unpooled.compositeBuffer;
+import static io.netty.buffer.Unpooled.wrappedBuffer;
 
 /**
  * Abstract Memory HttpData implementation
@@ -102,12 +105,10 @@ public void addContent(ByteBuf buffer, boolean last)
                 byteBuf = buffer;
             } else if (byteBuf instanceof CompositeByteBuf) {
                 CompositeByteBuf cbb = (CompositeByteBuf) byteBuf;
-                cbb.addComponent(buffer);
-                cbb.writerIndex(cbb.writerIndex() + buffer.readableBytes());
+                cbb.addComponent(true, buffer);
             } else {
                 CompositeByteBuf cbb = compositeBuffer(Integer.MAX_VALUE);
-                cbb.addComponents(byteBuf, buffer);
-                cbb.writerIndex(byteBuf.readableBytes() + buffer.readableBytes());
+                cbb.addComponents(true, byteBuf, buffer);
                 byteBuf = cbb;
             }
         }
@@ -209,7 +210,7 @@ public ByteBuf getChunk(int length) throws IOException {
         if (sizeLeft < length) {
             sliceLength = sizeLeft;
         }
-        ByteBuf chunk = byteBuf.slice(chunkPosition, sliceLength).retain();
+        ByteBuf chunk = byteBuf.retainedSlice(chunkPosition, sliceLength);
         chunkPosition += sliceLength;
         return chunk;
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
index a2060e732732..223cc6872f5e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.http.multipart;
 
+import io.netty.buffer.ByteBuf;
+
 import java.io.IOException;
 
 /**
@@ -37,6 +39,12 @@ public interface Attribute extends HttpData {
     @Override
     Attribute duplicate();
 
+    @Override
+    Attribute retainedDuplicate();
+
+    @Override
+    Attribute replace(ByteBuf content);
+
     @Override
     Attribute retain();
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java
index 6747a3ce259d..74391885b28e 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java
@@ -22,7 +22,7 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 
-import static io.netty.buffer.Unpooled.*;
+import static io.netty.buffer.Unpooled.wrappedBuffer;
 
 /**
  * Disk implementation of Attributes
@@ -162,27 +162,43 @@ protected String getPrefix() {
 
     @Override
     public Attribute copy() {
-        DiskAttribute attr = new DiskAttribute(getName());
-        attr.setCharset(getCharset());
+        final ByteBuf content = content();
+        return replace(content != null ? content.copy() : null);
+    }
+
+    @Override
+    public Attribute duplicate() {
+        final ByteBuf content = content();
+        return replace(content != null ? content.duplicate() : null);
+    }
+
+    @Override
+    public Attribute retainedDuplicate() {
         ByteBuf content = content();
         if (content != null) {
+            content = content.retainedDuplicate();
+            boolean success = false;
             try {
-                attr.setContent(content.copy());
-            } catch (IOException e) {
-                throw new ChannelException(e);
+                Attribute duplicate = replace(content);
+                success = true;
+                return duplicate;
+            } finally {
+                if (!success) {
+                    content.release();
+                }
             }
+        } else {
+            return replace(null);
         }
-        return attr;
     }
 
     @Override
-    public Attribute duplicate() {
+    public Attribute replace(ByteBuf content) {
         DiskAttribute attr = new DiskAttribute(getName());
         attr.setCharset(getCharset());
-        ByteBuf content = content();
         if (content != null) {
             try {
-                attr.setContent(content.duplicate());
+                attr.setContent(content);
             } catch (IOException e) {
                 throw new ChannelException(e);
             }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
index 0fc46b0d0d24..5a5d7873f746 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java
@@ -173,27 +173,43 @@ protected String getPrefix() {
 
     @Override
     public FileUpload copy() {
-        DiskFileUpload upload = new DiskFileUpload(getName(),
-                getFilename(), getContentType(), getContentTransferEncoding(), getCharset(), size);
-        ByteBuf buf = content();
-        if (buf != null) {
+        final ByteBuf content = content();
+        return replace(content != null ? content.copy() : null);
+    }
+
+    @Override
+    public FileUpload duplicate() {
+        final ByteBuf content = content();
+        return replace(content != null ? content.duplicate() : null);
+    }
+
+    @Override
+    public FileUpload retainedDuplicate() {
+        ByteBuf content = content();
+        if (content != null) {
+            content = content.retainedDuplicate();
+            boolean success = false;
             try {
-                upload.setContent(buf.copy());
-            } catch (IOException e) {
-                throw new ChannelException(e);
+                FileUpload duplicate = replace(content);
+                success = true;
+                return duplicate;
+            } finally {
+                if (!success) {
+                    content.release();
+                }
             }
+        } else {
+            return replace(null);
         }
-        return upload;
     }
 
     @Override
-    public FileUpload duplicate() {
-        DiskFileUpload upload = new DiskFileUpload(getName(),
-                getFilename(), getContentType(), getContentTransferEncoding(), getCharset(), size);
-        ByteBuf buf = content();
-        if (buf != null) {
+    public FileUpload replace(ByteBuf content) {
+        DiskFileUpload upload = new DiskFileUpload(
+                getName(), getFilename(), getContentType(), getContentTransferEncoding(), getCharset(), size);
+        if (content != null) {
             try {
-                upload.setContent(buf.duplicate());
+                upload.setContent(content);
             } catch (IOException e) {
                 throw new ChannelException(e);
             }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
index f519cf5c9013..113ab54963a8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUpload.java
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.http.multipart;
 
+import io.netty.buffer.ByteBuf;
+
 /**
  * FileUpload interface that could be in memory, on temporary file or any other implementations.
  *
@@ -62,6 +64,12 @@ public interface FileUpload extends HttpData {
     @Override
     FileUpload duplicate();
 
+    @Override
+    FileUpload retainedDuplicate();
+
+    @Override
+    FileUpload replace(ByteBuf content);
+
     @Override
     FileUpload retain();
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
index dab7d867afde..bf4215de0cda 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpData.java
@@ -219,6 +219,12 @@ public interface HttpData extends InterfaceHttpData, ByteBufHolder {
     @Override
     HttpData duplicate();
 
+    @Override
+    HttpData retainedDuplicate();
+
+    @Override
+    HttpData replace(ByteBuf content);
+
     @Override
     HttpData retain();
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
index e8ab8e505299..04e2729ced94 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java
@@ -26,11 +26,11 @@
 import io.netty.handler.codec.http.HttpConstants;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.stream.ChunkedInput;
@@ -48,7 +48,7 @@
 import java.util.Map;
 import java.util.regex.Pattern;
 
-import static io.netty.buffer.Unpooled.*;
+import static io.netty.buffer.Unpooled.wrappedBuffer;
 
 /**
  * This encoder will help to encode Request for a FORM as POST.
@@ -836,7 +836,6 @@ private ByteBuf fillByteBuf() {
         int length = currentBuffer.readableBytes();
         if (length > HttpPostBodyUtil.chunkSize) {
             ByteBuf slice = currentBuffer.slice(currentBuffer.readerIndex(), HttpPostBodyUtil.chunkSize);
-            currentBuffer.retain();
             currentBuffer.skipBytes(HttpPostBodyUtil.chunkSize);
             return slice;
         } else {
@@ -1239,45 +1238,24 @@ public FullHttpRequest setUri(String uri) {
             return this;
         }
 
-        /**
-         * Copy this object
-         *
-         * @param copyContent
-         * <ul>
-         * <li>{@code true} if this object's {@link #content()} should be used to copy.</li>
-         * <li>{@code false} if {@code newContent} should be used instead.</li>
-         * </ul>
-         * @param newContent
-         * <ul>
-         * <li>if {@code copyContent} is false then this will be used in the copy's content.</li>
-         * <li>if {@code null} then a default buffer of 0 size will be selected</li>
-         * </ul>
-         * @return A copy of this object
-         */
-        private FullHttpRequest copy(boolean copyContent, ByteBuf newContent) {
-            DefaultFullHttpRequest copy = new DefaultFullHttpRequest(
-                    protocolVersion(), method(), uri(),
-                    copyContent ? content().copy() :
-                            newContent == null ? buffer(0) : newContent);
-            copy.headers().set(headers());
-            copy.trailingHeaders().set(trailingHeaders());
-            return copy;
+        @Override
+        public FullHttpRequest copy() {
+            return replace(content().copy());
         }
 
         @Override
-        public FullHttpRequest copy(ByteBuf newContent) {
-            return copy(false, newContent);
+        public FullHttpRequest duplicate() {
+            return replace(content().duplicate());
         }
 
         @Override
-        public FullHttpRequest copy() {
-            return copy(true, null);
+        public FullHttpRequest retainedDuplicate() {
+            return replace(content().retainedDuplicate());
         }
 
         @Override
-        public FullHttpRequest duplicate() {
-            DefaultFullHttpRequest duplicate = new DefaultFullHttpRequest(
-                    getProtocolVersion(), getMethod(), getUri(), content().duplicate());
+        public FullHttpRequest replace(ByteBuf content) {
+            DefaultFullHttpRequest duplicate = new DefaultFullHttpRequest(protocolVersion(), method(), uri(), content);
             duplicate.headers().set(headers());
             duplicate.trailingHeaders().set(trailingHeaders());
             return duplicate;
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java
index 52133c428f72..085609a3b4ce 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java
@@ -633,6 +633,10 @@ private void parseBodyAttributes() {
             // error while decoding
             undecodedChunk.readerIndex(firstpos);
             throw new ErrorDataDecoderException(e);
+        } catch (IllegalArgumentException e) {
+            // error while decoding
+            undecodedChunk.readerIndex(firstpos);
+            throw new ErrorDataDecoderException(e);
         }
     }
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java
index 432b064bf4b5..63c8c34b2a4f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryAttribute.java
@@ -122,27 +122,43 @@ public String toString() {
 
     @Override
     public Attribute copy() {
-        MemoryAttribute attr = new MemoryAttribute(getName());
-        attr.setCharset(getCharset());
+        final ByteBuf content = content();
+        return replace(content != null ? content.copy() : null);
+    }
+
+    @Override
+    public Attribute duplicate() {
+        final ByteBuf content = content();
+        return replace(content != null ? content.duplicate() : null);
+    }
+
+    @Override
+    public Attribute retainedDuplicate() {
         ByteBuf content = content();
         if (content != null) {
+            content = content.retainedDuplicate();
+            boolean success = false;
             try {
-                attr.setContent(content.copy());
-            } catch (IOException e) {
-                throw new ChannelException(e);
+                Attribute duplicate = replace(content);
+                success = true;
+                return duplicate;
+            } finally {
+                if (!success) {
+                    content.release();
+                }
             }
+        } else {
+            return replace(null);
         }
-        return attr;
     }
 
     @Override
-    public Attribute duplicate() {
+    public Attribute replace(ByteBuf content) {
         MemoryAttribute attr = new MemoryAttribute(getName());
         attr.setCharset(getCharset());
-        ByteBuf content = content();
         if (content != null) {
             try {
-                attr.setContent(content.duplicate());
+                attr.setContent(content);
             } catch (IOException e) {
                 throw new ChannelException(e);
             }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
index f1a08fb094b9..f30b548c04a1 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java
@@ -132,28 +132,43 @@ public String toString() {
 
     @Override
     public FileUpload copy() {
-        MemoryFileUpload upload = new MemoryFileUpload(getName(), getFilename(), getContentType(),
-                getContentTransferEncoding(), getCharset(), size);
-        ByteBuf buf = content();
-        if (buf != null) {
+        final ByteBuf content = content();
+        return replace(content != null ? content.copy() : content);
+    }
+
+    @Override
+    public FileUpload duplicate() {
+        final ByteBuf content = content();
+        return replace(content != null ? content.duplicate() : content);
+    }
+
+    @Override
+    public FileUpload retainedDuplicate() {
+        ByteBuf content = content();
+        if (content != null) {
+            content = content.retainedDuplicate();
+            boolean success = false;
             try {
-                upload.setContent(buf.copy());
-                return upload;
-            } catch (IOException e) {
-                throw new ChannelException(e);
+                FileUpload duplicate = replace(content);
+                success = true;
+                return duplicate;
+            } finally {
+                if (!success) {
+                    content.release();
+                }
             }
+        } else {
+            return replace(null);
         }
-        return upload;
     }
 
     @Override
-    public FileUpload duplicate() {
-        MemoryFileUpload upload = new MemoryFileUpload(getName(), getFilename(), getContentType(),
-                getContentTransferEncoding(), getCharset(), size);
-        ByteBuf buf = content();
-        if (buf != null) {
+    public FileUpload replace(ByteBuf content) {
+        MemoryFileUpload upload = new MemoryFileUpload(
+                getName(), getFilename(), getContentType(), getContentTransferEncoding(), getCharset(), size);
+        if (content != null) {
             try {
-                upload.setContent(buf.duplicate());
+                upload.setContent(content);
                 return upload;
             } catch (IOException e) {
                 throw new ChannelException(e);
@@ -161,6 +176,7 @@ public FileUpload duplicate() {
         }
         return upload;
     }
+
     @Override
     public FileUpload retain() {
         super.retain();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java
index 03fba66523fb..90b7a4af6272 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedAttribute.java
@@ -271,6 +271,16 @@ public Attribute duplicate() {
         return attribute.duplicate();
     }
 
+    @Override
+    public Attribute retainedDuplicate() {
+        return attribute.retainedDuplicate();
+    }
+
+    @Override
+    public Attribute replace(ByteBuf content) {
+        return attribute.replace(content);
+    }
+
     @Override
     public ByteBuf content() {
         return attribute.content();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java
index 52caebb1c7cc..b80b892359d2 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java
@@ -293,6 +293,16 @@ public FileUpload duplicate() {
         return fileUpload.duplicate();
     }
 
+    @Override
+    public FileUpload retainedDuplicate() {
+        return fileUpload.retainedDuplicate();
+    }
+
+    @Override
+    public FileUpload replace(ByteBuf content) {
+        return fileUpload.replace(content);
+    }
+
     @Override
     public ByteBuf content() {
         return fileUpload.content();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java
index f3ce587d6bda..5fbcd903863f 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java
@@ -56,12 +56,22 @@ public BinaryWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData)
 
     @Override
     public BinaryWebSocketFrame copy() {
-        return new BinaryWebSocketFrame(isFinalFragment(), rsv(), content().copy());
+        return (BinaryWebSocketFrame) super.copy();
     }
 
     @Override
     public BinaryWebSocketFrame duplicate() {
-        return new BinaryWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());
+        return (BinaryWebSocketFrame) super.duplicate();
+    }
+
+    @Override
+    public BinaryWebSocketFrame retainedDuplicate() {
+        return (BinaryWebSocketFrame) super.retainedDuplicate();
+    }
+
+    @Override
+    public BinaryWebSocketFrame replace(ByteBuf content) {
+        return new BinaryWebSocketFrame(isFinalFragment(), rsv(), content);
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
index 9f6768b76520..0ef6826255b8 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java
@@ -140,12 +140,22 @@ public String reasonText() {
 
     @Override
     public CloseWebSocketFrame copy() {
-        return new CloseWebSocketFrame(isFinalFragment(), rsv(), content().copy());
+        return (CloseWebSocketFrame) super.copy();
     }
 
     @Override
     public CloseWebSocketFrame duplicate() {
-        return new CloseWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());
+        return (CloseWebSocketFrame) super.duplicate();
+    }
+
+    @Override
+    public CloseWebSocketFrame retainedDuplicate() {
+        return (CloseWebSocketFrame) super.retainedDuplicate();
+    }
+
+    @Override
+    public CloseWebSocketFrame replace(ByteBuf content) {
+        return new CloseWebSocketFrame(isFinalFragment(), rsv(), content);
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java
index 8560f410f17d..bd25ea0ea695 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java
@@ -93,12 +93,22 @@ private static ByteBuf fromText(String text) {
 
     @Override
     public ContinuationWebSocketFrame copy() {
-        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().copy());
+        return (ContinuationWebSocketFrame) super.copy();
     }
 
     @Override
     public ContinuationWebSocketFrame duplicate() {
-        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());
+        return (ContinuationWebSocketFrame) super.duplicate();
+    }
+
+    @Override
+    public ContinuationWebSocketFrame retainedDuplicate() {
+        return (ContinuationWebSocketFrame) super.retainedDuplicate();
+    }
+
+    @Override
+    public ContinuationWebSocketFrame replace(ByteBuf content) {
+        return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content);
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java
index 49a10ac644e7..08e7025088dc 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PingWebSocketFrame.java
@@ -56,12 +56,22 @@ public PingWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData) {
 
     @Override
     public PingWebSocketFrame copy() {
-        return new PingWebSocketFrame(isFinalFragment(), rsv(), content().copy());
+        return (PingWebSocketFrame) super.copy();
     }
 
     @Override
     public PingWebSocketFrame duplicate() {
-        return new PingWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());
+        return (PingWebSocketFrame) super.duplicate();
+    }
+
+    @Override
+    public PingWebSocketFrame retainedDuplicate() {
+        return (PingWebSocketFrame) super.retainedDuplicate();
+    }
+
+    @Override
+    public PingWebSocketFrame replace(ByteBuf content) {
+        return new PingWebSocketFrame(isFinalFragment(), rsv(), content);
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java
index b96c815d9898..29c0b0f7ddb4 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/PongWebSocketFrame.java
@@ -56,12 +56,22 @@ public PongWebSocketFrame(boolean finalFragment, int rsv, ByteBuf binaryData) {
 
     @Override
     public PongWebSocketFrame copy() {
-        return new PongWebSocketFrame(isFinalFragment(), rsv(), content().copy());
+        return (PongWebSocketFrame) super.copy();
     }
 
     @Override
     public PongWebSocketFrame duplicate() {
-        return new PongWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());
+        return (PongWebSocketFrame) super.duplicate();
+    }
+
+    @Override
+    public PongWebSocketFrame retainedDuplicate() {
+        return (PongWebSocketFrame) super.retainedDuplicate();
+    }
+
+    @Override
+    public PongWebSocketFrame replace(ByteBuf content) {
+        return new PongWebSocketFrame(isFinalFragment(), rsv(), content);
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java
index a6199a7e079a..9b124710bbd9 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java
@@ -96,12 +96,22 @@ public String text() {
 
     @Override
     public TextWebSocketFrame copy() {
-        return new TextWebSocketFrame(isFinalFragment(), rsv(), content().copy());
+        return (TextWebSocketFrame) super.copy();
     }
 
     @Override
     public TextWebSocketFrame duplicate() {
-        return new TextWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());
+        return (TextWebSocketFrame) super.duplicate();
+    }
+
+    @Override
+    public TextWebSocketFrame retainedDuplicate() {
+        return (TextWebSocketFrame) super.retainedDuplicate();
+    }
+
+    @Override
+    public TextWebSocketFrame replace(ByteBuf content) {
+        return new TextWebSocketFrame(isFinalFragment(), rsv(), content);
     }
 
     @Override
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
index 37606ab535f1..677f04736048 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrame.java
@@ -61,10 +61,22 @@ public int rsv() {
     }
 
     @Override
-    public abstract WebSocketFrame copy();
+    public WebSocketFrame copy() {
+        return (WebSocketFrame) super.copy();
+    }
+
+    @Override
+    public WebSocketFrame duplicate() {
+        return (WebSocketFrame) super.duplicate();
+    }
+
+    @Override
+    public WebSocketFrame retainedDuplicate() {
+        return (WebSocketFrame) super.retainedDuplicate();
+    }
 
     @Override
-    public abstract WebSocketFrame duplicate();
+    public abstract WebSocketFrame replace(ByteBuf content);
 
     @Override
     public String toString() {
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java
index 1f262b5fb5b2..89053fd82d29 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java
@@ -80,9 +80,7 @@ protected void decode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object
                 partUncompressedContent.release();
                 continue;
             }
-            compositeUncompressedContent.addComponent(partUncompressedContent);
-            compositeUncompressedContent.writerIndex(compositeUncompressedContent.writerIndex() +
-                    partUncompressedContent.readableBytes());
+            compositeUncompressedContent.addComponent(true, partUncompressedContent);
         }
         // Correctly handle empty frames
         // See https://github.com/netty/netty/issues/4348
diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateEncoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateEncoder.java
index 5111e232807b..1aff7b78c7a9 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateEncoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateEncoder.java
@@ -87,9 +87,7 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg,
                 partCompressedContent.release();
                 continue;
             }
-            fullCompressedContent.addComponent(partCompressedContent);
-            fullCompressedContent.writerIndex(fullCompressedContent.writerIndex() +
-                    partCompressedContent.readableBytes());
+            fullCompressedContent.addComponent(true, partCompressedContent);
         }
         if (fullCompressedContent.numComponents() <= 0) {
             fullCompressedContent.release();
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
index 85ca0dfc11ca..a1e9d73d1f01 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java
@@ -80,14 +80,22 @@ public ByteBuf content() {
 
     @Override
     public SpdyDataFrame copy() {
-        SpdyDataFrame frame = new DefaultSpdyDataFrame(streamId(), content().copy());
-        frame.setLast(isLast());
-        return frame;
+        return replace(content().copy());
     }
 
     @Override
     public SpdyDataFrame duplicate() {
-        SpdyDataFrame frame = new DefaultSpdyDataFrame(streamId(), content().duplicate());
+        return replace(content().duplicate());
+    }
+
+    @Override
+    public SpdyDataFrame retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public SpdyDataFrame replace(ByteBuf content) {
+        SpdyDataFrame frame = new DefaultSpdyDataFrame(streamId(), content);
         frame.setLast(isLast());
         return frame;
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
index 94483cbb4701..5097048601b3 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java
@@ -36,18 +36,13 @@ public Set<Integer> ids() {
 
     @Override
     public boolean isSet(int id) {
-        Integer key = Integer.valueOf(id);
-        return settingsMap.containsKey(key);
+        return settingsMap.containsKey(id);
     }
 
     @Override
     public int getValue(int id) {
-        Integer key = Integer.valueOf(id);
-        if (settingsMap.containsKey(key)) {
-            return settingsMap.get(key).getValue();
-        } else {
-            return -1;
-        }
+        final Setting setting = settingsMap.get(id);
+        return setting != null ? setting.getValue() : -1;
     }
 
     @Override
@@ -60,9 +55,9 @@ public SpdySettingsFrame setValue(int id, int value, boolean persistValue, boole
         if (id < 0 || id > SpdyCodecUtil.SPDY_SETTINGS_MAX_ID) {
             throw new IllegalArgumentException("Setting ID is not valid: " + id);
         }
-        Integer key = Integer.valueOf(id);
-        if (settingsMap.containsKey(key)) {
-            Setting setting = settingsMap.get(key);
+        final Integer key = Integer.valueOf(id);
+        final Setting setting = settingsMap.get(key);
+        if (setting != null) {
             setting.setValue(value);
             setting.setPersist(persistValue);
             setting.setPersisted(persisted);
@@ -74,47 +69,36 @@ public SpdySettingsFrame setValue(int id, int value, boolean persistValue, boole
 
     @Override
     public SpdySettingsFrame removeValue(int id) {
-        Integer key = Integer.valueOf(id);
-        if (settingsMap.containsKey(key)) {
-            settingsMap.remove(key);
-        }
+        settingsMap.remove(id);
         return this;
     }
 
     @Override
     public boolean isPersistValue(int id) {
-        Integer key = Integer.valueOf(id);
-        if (settingsMap.containsKey(key)) {
-            return settingsMap.get(key).isPersist();
-        } else {
-            return false;
-        }
+        final Setting setting = settingsMap.get(id);
+        return setting != null && setting.isPersist();
     }
 
     @Override
     public SpdySettingsFrame setPersistValue(int id, boolean persistValue) {
-        Integer key = Integer.valueOf(id);
-        if (settingsMap.containsKey(key)) {
-            settingsMap.get(key).setPersist(persistValue);
+        final Setting setting = settingsMap.get(id);
+        if (setting != null) {
+            setting.setPersist(persistValue);
         }
         return this;
     }
 
     @Override
     public boolean isPersisted(int id) {
-        Integer key = Integer.valueOf(id);
-        if (settingsMap.containsKey(key)) {
-            return settingsMap.get(key).isPersisted();
-        } else {
-            return false;
-        }
+        final Setting setting = settingsMap.get(id);
+        return setting != null && setting.isPersisted();
     }
 
     @Override
     public SpdySettingsFrame setPersisted(int id, boolean persisted) {
-        Integer key = Integer.valueOf(id);
-        if (settingsMap.containsKey(key)) {
-            settingsMap.get(key).setPersisted(persisted);
+        final Setting setting = settingsMap.get(id);
+        if (setting != null) {
+            setting.setPersisted(persisted);
         }
         return this;
     }
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
index e37d655a0dc8..b112c5ea6697 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java
@@ -45,6 +45,12 @@ public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame {
     @Override
     SpdyDataFrame duplicate();
 
+    @Override
+    SpdyDataFrame retainedDuplicate();
+
+    @Override
+    SpdyDataFrame replace(ByteBuf content);
+
     @Override
     SpdyDataFrame retain();
 
diff --git a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
index e5c0848e6c1a..b4f0e116e1d9 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java
@@ -24,7 +24,8 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;
+import static io.netty.handler.codec.spdy.SpdyCodecUtil.SPDY_SESSION_STREAM_ID;
+import static io.netty.handler.codec.spdy.SpdyCodecUtil.isServerId;
 
 /**
  * Manages streams within a SPDY session.
@@ -190,8 +191,8 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
             // Send data frames upstream in initialReceiveWindowSize chunks
             if (newWindowSize < 0) {
                 while (spdyDataFrame.content().readableBytes() > initialReceiveWindowSize) {
-                    SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamId,
-                            spdyDataFrame.content().readSlice(initialReceiveWindowSize).retain());
+                    SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(
+                            streamId, spdyDataFrame.content().readRetainedSlice(initialReceiveWindowSize));
                     ctx.writeAndFlush(partialDataFrame);
                 }
             }
@@ -497,8 +498,8 @@ private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg, Channe
                 spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * sendWindowSize);
 
                 // Create a partial data frame whose length is the current window size
-                SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(streamId,
-                        spdyDataFrame.content().readSlice(sendWindowSize).retain());
+                SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(
+                        streamId, spdyDataFrame.content().readRetainedSlice(sendWindowSize));
 
                 // Enqueue the remaining data (will be the first frame queued)
                 spdySession.putPendingWrite(streamId, new SpdySession.PendingWrite(spdyDataFrame, promise));
@@ -778,8 +779,8 @@ private void updateSendWindowSize(final ChannelHandlerContext ctx, int streamId,
                 spdySession.updateSendWindowSize(SPDY_SESSION_STREAM_ID, -1 * sendWindowSize);
 
                 // Create a partial data frame whose length is the current window size
-                SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(writeStreamId,
-                        spdyDataFrame.content().readSlice(sendWindowSize).retain());
+                SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame(
+                        writeStreamId, spdyDataFrame.content().readRetainedSlice(sendWindowSize));
 
                 // The transfer window size is pre-decremented when sending a data frame downstream.
                 // Close the session on write failures that leave the transfer window in a corrupt state.
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java
index 7b7230a36f52..1ac20de2ad1a 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java
@@ -17,6 +17,7 @@
 
 import io.netty.handler.codec.http.HttpHeadersTestUtils.HeaderValue;
 import io.netty.util.AsciiString;
+import io.netty.util.internal.StringUtil;
 import org.junit.Test;
 
 import java.util.Arrays;
@@ -36,6 +37,16 @@
 public class DefaultHttpHeadersTest {
     private static final CharSequence HEADER_NAME = "testHeader";
 
+    @Test(expected = IllegalArgumentException.class)
+    public void nullHeaderNameNotAllowed() {
+        new DefaultHttpHeaders().add(null, "foo");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void emtpyHeaderNameNotAllowed() {
+        new DefaultHttpHeaders().add(StringUtil.EMPTY_STRING, "foo");
+    }
+
     @Test
     public void keysShouldBeCaseInsensitive() {
         DefaultHttpHeaders headers = new DefaultHttpHeaders();
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
index 82d84370095a..0376258e98d1 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.http;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.TooLongFrameException;
@@ -576,7 +577,16 @@ public void testWebSocketResponseWithDataFollowing() {
 
         assertThat(ch.finish(), is(true));
 
-        assertEquals(ch.readInbound(), Unpooled.wrappedBuffer(otherData));
+        ByteBuf expected = Unpooled.wrappedBuffer(otherData);
+        ByteBuf buffer = ch.readInbound();
+        try {
+            assertEquals(expected, buffer);
+        } finally {
+            expected.release();
+            if (buffer != null) {
+                buffer.release();
+            }
+        }
     }
 
     @Test
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
index 6d3eec888d4b..df075e7fdb12 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java
@@ -70,6 +70,15 @@ public void simpleRequestWithAnyOrigin() {
         assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is("*"));
     }
 
+    @Test
+    public void simpleRequestWithNullOrigin() {
+        final HttpResponse response = simpleRequest(forOrigin("http://test.com").allowNullOrigin()
+                .allowCredentials()
+                .build(), "null");
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is("null"));
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_CREDENTIALS), is(equalTo("true")));
+    }
+
     @Test
     public void simpleRequestWithOrigin() {
         final String origin = "http://localhost:8888";
@@ -190,8 +199,8 @@ public void preflightRequestWithNullOrigin() {
                 .allowCredentials()
                 .build();
         final HttpResponse response = preflightRequest(config, origin, "content-type, xheader1");
-        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is(equalTo("*")));
-        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_CREDENTIALS), is(nullValue()));
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_ORIGIN), is(equalTo("null")));
+        assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_CREDENTIALS), is(equalTo("true")));
     }
 
     @Test
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java
index f63da4ce7476..df4a425de5c7 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java
@@ -74,22 +74,32 @@ private TestHttpData(String name, Charset charset, long size) {
 
         @Override
         public InterfaceHttpData.HttpDataType getHttpDataType() {
-            throw new UnsupportedOperationException("Should never be called.");
+            throw reject();
         }
 
         @Override
         public HttpData copy() {
-            throw new UnsupportedOperationException("Should never be called.");
+            throw reject();
         }
 
         @Override
         public HttpData duplicate() {
-            throw new UnsupportedOperationException("Should never be called.");
+            throw reject();
+        }
+
+        @Override
+        public HttpData retainedDuplicate() {
+            throw reject();
+        }
+
+        @Override
+        public HttpData replace(ByteBuf content) {
+            return null;
         }
 
         @Override
         public int compareTo(InterfaceHttpData o) {
-            throw new UnsupportedOperationException("Should never be called.");
+            throw reject();
         }
 
         @Override
@@ -101,5 +111,9 @@ public int hashCode() {
         public boolean equals(Object obj) {
             return super.equals(obj);
         }
+
+        private static UnsupportedOperationException reject() {
+            throw new UnsupportedOperationException("Should never be called.");
+        }
     }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
index 687745584eb9..28ef7a09982f 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java
@@ -23,6 +23,7 @@
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.DefaultLastHttpContent;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
@@ -474,4 +475,21 @@ public void testMultipartRequestWithFieldInvalidCharset() throws Exception {
             req.release();
         }
     }
+
+    @Test
+    public void testFormEncodeIncorrect() throws Exception {
+        LastHttpContent content = new DefaultLastHttpContent(
+                Unpooled.copiedBuffer("project=netty&&project=netty", CharsetUtil.US_ASCII));
+        DefaultHttpRequest req = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/");
+        HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(req);
+        try {
+            decoder.offer(content);
+            fail();
+        } catch (HttpPostRequestDecoder.ErrorDataDecoderException e) {
+            assertTrue(e.getCause() instanceof IllegalArgumentException);
+        } finally {
+            decoder.destroy();
+            content.release();
+        }
+    }
 }
diff --git a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java
index 427888e8a27b..b4e5e129d86c 100644
--- a/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java
+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java
@@ -103,15 +103,13 @@ protected WebSocketFrameEncoder newWebSocketEncoder() {
         byte[] bytes = "HTTP/1.1 101 Switching Protocols\r\nContent-Length: 0\r\n\r\n".getBytes(CharsetUtil.US_ASCII);
 
         CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();
-        compositeByteBuf.addComponent(Unpooled.wrappedBuffer(bytes));
-        compositeByteBuf.writerIndex(compositeByteBuf.writerIndex() + bytes.length);
+        compositeByteBuf.addComponent(true, Unpooled.wrappedBuffer(bytes));
         for (;;) {
             ByteBuf frameBytes = websocketChannel.readOutbound();
             if (frameBytes == null) {
                 break;
             }
-            compositeByteBuf.addComponent(frameBytes);
-            compositeByteBuf.writerIndex(compositeByteBuf.writerIndex() + frameBytes.readableBytes());
+            compositeByteBuf.addComponent(true, frameBytes);
         }
 
         EmbeddedChannel ch = new EmbeddedChannel(new HttpObjectAggregator(Integer.MAX_VALUE),
diff --git a/codec-http2/pom.xml b/codec-http2/pom.xml
index 32bb8cd937f5..77f4623e42bf 100644
--- a/codec-http2/pom.xml
+++ b/codec-http2/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-http2</artifactId>
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
index 5f3040d12b30..8159e9704321 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java
@@ -17,6 +17,7 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.http2.Http2HeadersEncoder.SensitivityDetector;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -66,6 +67,7 @@
  * @param <T> The type of handler created by this builder.
  * @param <B> The concrete type of this builder.
  */
+@UnstableApi
 public abstract class AbstractHttp2ConnectionHandlerBuilder<T extends Http2ConnectionHandler,
                                                             B extends AbstractHttp2ConnectionHandlerBuilder<T, B>> {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java
index 237a2e35fa59..e02009f74188 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Abstract implementation of {@link Http2StreamFrame}.
  */
+@UnstableApi
 public abstract class AbstractHttp2StreamFrame implements Http2StreamFrame {
     private Object stream;
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractInboundHttp2ToHttpAdapterBuilder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractInboundHttp2ToHttpAdapterBuilder.java
index cba76020a546..9549740d8d1a 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractInboundHttp2ToHttpAdapterBuilder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractInboundHttp2ToHttpAdapterBuilder.java
@@ -15,12 +15,14 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.TooLongFrameException;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * A skeletal builder implementation of {@link InboundHttp2ToHttpAdapter} and its subtypes.
  */
+@UnstableApi
 public abstract class AbstractInboundHttp2ToHttpAdapterBuilder<
         T extends InboundHttp2ToHttpAdapter, B extends AbstractInboundHttp2ToHttpAdapterBuilder<T, B>> {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java
index 5316f2125a6c..d81390c3aeb3 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.util.concurrent.PromiseCombiner;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_ENCODING;
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
@@ -37,6 +38,7 @@
  * A decorating HTTP2 encoder that will compress data frames according to the {@code content-encoding} header for each
  * stream. The compression provided by this class will be applied to the data for the entire stream.
  */
+@UnstableApi
 public class CompressorHttp2ConnectionEncoder extends DecoratingHttp2ConnectionEncoder {
     public static final int DEFAULT_COMPRESSION_LEVEL = 6;
     public static final int DEFAULT_WINDOW_BITS = 15;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java
index 787369ecbfd6..8d4fb1750293 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java
@@ -18,12 +18,14 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
 /**
  * Decorator around another {@link Http2ConnectionDecoder} instance.
  */
+@UnstableApi
 public class DecoratingHttp2ConnectionDecoder implements Http2ConnectionDecoder {
     private final Http2ConnectionDecoder delegate;
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionEncoder.java
index 5c4e95a56376..9d591ab9e686 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionEncoder.java
@@ -14,11 +14,14 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * A decorator around another {@link Http2ConnectionEncoder} instance.
  */
+@UnstableApi
 public class DecoratingHttp2ConnectionEncoder extends DecoratingHttp2FrameWriter implements Http2ConnectionEncoder {
     private final Http2ConnectionEncoder delegate;
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java
index 2d2f6505b190..3a95c92a80dd 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java
@@ -20,10 +20,12 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Decorator around another {@link Http2FrameWriter} instance.
  */
+@UnstableApi
 public class DecoratingHttp2FrameWriter implements Http2FrameWriter {
     private final Http2FrameWriter delegate;
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
index 0bb6379532a7..ef8b1d72fea4 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java
@@ -28,6 +28,7 @@
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -63,6 +64,7 @@
 /**
  * Simple implementation of {@link Http2Connection}.
  */
+@UnstableApi
 public class DefaultHttp2Connection implements Http2Connection {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2Connection.class);
     // Fields accessed by inner classes
@@ -131,18 +133,24 @@ public Future<Void> close(final Promise<Void> promise) {
             promise.trySuccess(null);
             return promise;
         }
+
         Iterator<PrimitiveEntry<Http2Stream>> itr = streamMap.entries().iterator();
         // We must take care while iterating the streamMap as to not modify while iterating in case there are other code
         // paths iterating over the active streams.
         if (activeStreams.allowModifications()) {
-            while (itr.hasNext()) {
-                DefaultStream stream = (DefaultStream) itr.next().value();
-                if (stream.id() != CONNECTION_STREAM_ID) {
-                    // If modifications of the activeStream map is allowed, then a stream close operation will also
-                    // modify the streamMap. Pass the iterator in so that remove will be called to prevent concurrent
-                    // modification exceptions.
-                    stream.close(itr);
+            activeStreams.incrementPendingIterations();
+            try {
+                while (itr.hasNext()) {
+                    DefaultStream stream = (DefaultStream) itr.next().value();
+                    if (stream.id() != CONNECTION_STREAM_ID) {
+                        // If modifications of the activeStream map is allowed, then a stream close operation will also
+                        // modify the streamMap. Pass the iterator in so that remove will be called to prevent
+                        // concurrent modification exceptions.
+                        stream.close(itr);
+                    }
                 }
+            } finally {
+                activeStreams.decrementPendingIterations();
             }
         } else {
             while (itr.hasNext()) {
@@ -218,8 +226,8 @@ public void goAwayReceived(final int lastKnownStream, long errorCode, ByteBuf de
         for (int i = 0; i < listeners.size(); ++i) {
             try {
                 listeners.get(i).onGoAwayReceived(lastKnownStream, errorCode, debugData);
-            } catch (RuntimeException e) {
-                logger.error("Caught RuntimeException from listener onGoAwayReceived.", e);
+            } catch (Throwable cause) {
+                logger.error("Caught Throwable from listener onGoAwayReceived.", cause);
             }
         }
 
@@ -249,8 +257,8 @@ public void goAwaySent(final int lastKnownStream, long errorCode, ByteBuf debugD
         for (int i = 0; i < listeners.size(); ++i) {
             try {
                 listeners.get(i).onGoAwaySent(lastKnownStream, errorCode, debugData);
-            } catch (RuntimeException e) {
-                logger.error("Caught RuntimeException from listener onGoAwaySent.", e);
+            } catch (Throwable cause) {
+                logger.error("Caught Throwable from listener onGoAwaySent.", cause);
             }
         }
 
@@ -277,16 +285,12 @@ private boolean isStreamMapEmpty() {
     }
 
     /**
-     * Closed streams may stay in the priority tree if they have dependents that are in prioritizable states.
-     * When a stream is requested to be removed we can only actually remove that stream when there are no more
-     * prioritizable children.
-     * (see [1] {@link Http2Stream#prioritizableForTree()} and [2] {@link DefaultStream#removeChild(DefaultStream)}).
-     * When a priority tree edge changes we also have to re-evaluate viable nodes
-     * (see [3] {@link DefaultStream#takeChild(DefaultStream, boolean, List)}).
-     * @param stream The stream to remove.
+     * Remove a stream from the {@link #streamMap}.
+     * @param stream the stream to remove.
+     * @param itr an iterator that may be pointing to the stream during iteration and {@link Iterator#remove()} will be
+     * used if non-{@code null}.
      */
     void removeStream(DefaultStream stream, Iterator<?> itr) {
-        // [1] Check if this stream can be removed because it has no prioritizable descendants.
         if (stream.parent().removeChild(stream)) {
             if (itr == null) {
                 streamMap.remove(stream.id());
@@ -297,8 +301,8 @@ void removeStream(DefaultStream stream, Iterator<?> itr) {
             for (int i = 0; i < listeners.size(); i++) {
                 try {
                     listeners.get(i).onStreamRemoved(stream);
-                } catch (RuntimeException e) {
-                    logger.error("Caught RuntimeException from listener onStreamRemoved.", e);
+                } catch (Throwable cause) {
+                    logger.error("Caught Throwable from listener onStreamRemoved.", cause);
                 }
             }
 
@@ -327,8 +331,8 @@ void notifyHalfClosed(Http2Stream stream) {
         for (int i = 0; i < listeners.size(); i++) {
             try {
                 listeners.get(i).onStreamHalfClosed(stream);
-            } catch (RuntimeException e) {
-                logger.error("Caught RuntimeException from listener onStreamHalfClosed.", e);
+            } catch (Throwable cause) {
+                logger.error("Caught Throwable from listener onStreamHalfClosed.", cause);
             }
         }
     }
@@ -337,8 +341,8 @@ void notifyClosed(Http2Stream stream) {
         for (int i = 0; i < listeners.size(); i++) {
             try {
                 listeners.get(i).onStreamClosed(stream);
-            } catch (RuntimeException e) {
-                logger.error("Caught RuntimeException from listener onStreamClosed.", e);
+            } catch (Throwable cause) {
+                logger.error("Caught Throwable from listener onStreamClosed.", cause);
             }
         }
     }
@@ -369,7 +373,6 @@ private class DefaultStream implements Http2Stream {
         private short weight = DEFAULT_PRIORITY_WEIGHT;
         private DefaultStream parent;
         private IntObjectMap<DefaultStream> children = IntCollections.emptyMap();
-        private int prioritizableForTree = 1;
         private boolean resetSent;
 
         DefaultStream(int id, State state) {
@@ -428,11 +431,6 @@ public final DefaultStream parent() {
             return parent;
         }
 
-        @Override
-        public final int prioritizableForTree() {
-            return prioritizableForTree;
-        }
-
         @Override
         public final boolean isDescendantOf(Http2Stream stream) {
             Http2Stream next = parent();
@@ -519,7 +517,6 @@ Http2Stream close(Iterator<?> itr) {
             }
 
             state = CLOSED;
-            decrementPrioritizableForTree(1);
 
             activeStreams.deactivate(this, itr);
             return this;
@@ -562,59 +559,6 @@ public Http2Stream closeRemoteSide() {
             return this;
         }
 
-        /**
-         * Recursively increment the {@link #prioritizableForTree} for this object up the parent links until
-         * either we go past the root or {@code oldParent} is encountered.
-         * @param amt The amount to increment by. This must be positive.
-         * @param oldParent The previous parent for this stream.
-         */
-        private void incrementPrioritizableForTree(int amt, Http2Stream oldParent) {
-            if (amt != 0) {
-                incrementPrioritizableForTree0(amt, oldParent);
-            }
-        }
-
-        /**
-         * Direct calls to this method are discouraged.
-         * Instead use {@link #incrementPrioritizableForTree(int, Http2Stream)}.
-         */
-        private void incrementPrioritizableForTree0(int amt, Http2Stream oldParent) {
-            assert amt > 0 && Integer.MAX_VALUE - amt >= prioritizableForTree;
-            prioritizableForTree += amt;
-            if (parent != null && parent != oldParent) {
-                parent.incrementPrioritizableForTree0(amt, oldParent);
-            }
-        }
-
-        /**
-         * Recursively increment the {@link #prioritizableForTree} for this object up the parent links until
-         * either we go past the root.
-         * @param amt The amount to decrement by. This must be positive.
-         */
-        private void decrementPrioritizableForTree(int amt) {
-            if (amt != 0) {
-                decrementPrioritizableForTree0(amt);
-            }
-        }
-
-        /**
-         * Direct calls to this method are discouraged. Instead use {@link #decrementPrioritizableForTree(int)}.
-         */
-        private void decrementPrioritizableForTree0(int amt) {
-            assert amt > 0 && prioritizableForTree >= amt;
-            prioritizableForTree -= amt;
-            if (parent != null) {
-                parent.decrementPrioritizableForTree0(amt);
-            }
-        }
-
-        /**
-         * Determine if this node by itself is considered to be valid in the priority tree.
-         */
-        private boolean isPrioritizable() {
-            return state != CLOSED;
-        }
-
         private void initChildrenIfEmpty() {
             if (children == IntCollections.<DefaultStream>emptyMap()) {
                 initChildren();
@@ -640,8 +584,8 @@ final void weight(short weight) {
                 for (int i = 0; i < listeners.size(); i++) {
                     try {
                         listeners.get(i).onWeightChanged(this, oldWeight);
-                    } catch (RuntimeException e) {
-                        logger.error("Caught RuntimeException from listener onWeightChanged.", e);
+                    } catch (Throwable cause) {
+                        logger.error("Caught Throwable from listener onWeightChanged.", cause);
                     }
                 }
             }
@@ -658,11 +602,7 @@ private IntObjectMap<DefaultStream> retain(DefaultStream streamToRetain) {
             // This map should be re-initialized in anticipation for the 1 exclusive child which will be added.
             // It will either be added directly in this method, or after this method is called...but it will be added.
             initChildren();
-            if (streamToRetain == null) {
-                prioritizableForTree = isPrioritizable() ? 1 : 0;
-            } else {
-                // prioritizableForTree does not change because it is assumed all children node will still be
-                // descendants through an exclusive priority tree operation.
+            if (streamToRetain != null) {
                 children.put(streamToRetain.id(), streamToRetain);
             }
             return prevChildren;
@@ -679,21 +619,11 @@ final void takeChild(DefaultStream child, boolean exclusive, List<ParentChangedE
                 events.add(new ParentChangedEvent(child, oldParent));
                 notifyParentChanging(child, this);
                 child.parent = this;
-                // We need the removal operation to happen first so the prioritizableForTree for the old parent to root
-                // path is updated with the correct child.prioritizableForTree() value. Note that the removal operation
-                // may not be successful and may return null. This is because when an exclusive dependency is processed
-                // the children are removed in a previous recursive call but the child's parent link is updated here.
-                if (oldParent != null && oldParent.children.remove(child.id()) != null &&
-                        !child.isDescendantOf(oldParent)) {
-                    oldParent.decrementPrioritizableForTree(child.prioritizableForTree());
-                    if (oldParent.prioritizableForTree() == 0) {
-                        // There are a few risks with immediately removing nodes from the priority tree:
-                        // 1. We are removing nodes while we are potentially shifting the tree. There are no
-                        // concrete cases known but is risky because it could invalidate the data structure.
-                        // 2. We are notifying listeners of the removal while the tree is in flux. Currently the
-                        // codec listeners make no assumptions about priority tree structure when being notified.
-                        removeStream(oldParent, null);
-                    }
+                // Note that the removal operation may not be successful and may return null. This is because when an
+                // exclusive dependency is processed the children are removed in a previous recursive call but the
+                // child's parent link is updated here.
+                if (oldParent != null) {
+                    oldParent.children.remove(child.id());
                 }
 
                 // Lazily initialize the children to save object allocations.
@@ -701,7 +631,6 @@ final void takeChild(DefaultStream child, boolean exclusive, List<ParentChangedE
 
                 final Http2Stream oldChild = children.put(child.id(), child);
                 assert oldChild == null : "A stream with the same stream ID was already in the child map.";
-                incrementPrioritizableForTree(child.prioritizableForTree(), oldParent);
             }
 
             if (exclusive && !children.isEmpty()) {
@@ -717,26 +646,17 @@ final void takeChild(DefaultStream child, boolean exclusive, List<ParentChangedE
          * Removes the child priority and moves any of its dependencies to being direct dependencies on this node.
          */
         final boolean removeChild(DefaultStream child) {
-            if (child.prioritizableForTree() == 0 && children.remove(child.id()) != null) {
+            if (children.remove(child.id()) != null) {
                 List<ParentChangedEvent> events = new ArrayList<ParentChangedEvent>(1 + child.numChildren());
                 events.add(new ParentChangedEvent(child, child.parent()));
                 notifyParentChanging(child, null);
                 child.parent = null;
-                decrementPrioritizableForTree(child.prioritizableForTree());
 
                 // Move up any grand children to be directly dependent on this node.
                 for (DefaultStream grandchild : child.children.values()) {
                     takeChild(grandchild, false, events);
                 }
 
-                if (prioritizableForTree() == 0) {
-                    // There are a few risks with immediately removing nodes from the priority tree:
-                    // 1. We are removing nodes while we are potentially shifting the tree. There are no
-                    // concrete cases known but is risky because it could invalidate the data structure.
-                    // 2. We are notifying listeners of the removal while the tree is in flux. Currently the
-                    // codec listeners make no assumptions about priority tree structure when being notified.
-                    removeStream(this, null);
-                }
                 notifyParentChanged(events);
                 return true;
             }
@@ -807,8 +727,8 @@ private static final class ParentChangedEvent {
         public void notifyListener(Listener l) {
             try {
                 l.onPriorityTreeParentChanged(stream, oldParent);
-            } catch (RuntimeException e) {
-                logger.error("Caught RuntimeException from listener onPriorityTreeParentChanged.", e);
+            } catch (Throwable cause) {
+                logger.error("Caught Throwable from listener onPriorityTreeParentChanged.", cause);
             }
         }
     }
@@ -830,8 +750,8 @@ private void notifyParentChanging(Http2Stream stream, Http2Stream newParent) {
         for (int i = 0; i < listeners.size(); i++) {
             try {
                 listeners.get(i).onPriorityTreeParentChanging(stream, newParent);
-            } catch (RuntimeException e) {
-                logger.error("Caught RuntimeException from listener onPriorityTreeParentChanging.", e);
+            } catch (Throwable cause) {
+                logger.error("Caught Throwable from listener onPriorityTreeParentChanging.", cause);
             }
         }
     }
@@ -1028,8 +948,8 @@ private void addStream(DefaultStream stream) {
             for (int i = 0; i < listeners.size(); i++) {
                 try {
                     listeners.get(i).onStreamAdded(stream);
-                } catch (RuntimeException e) {
-                    logger.error("Caught RuntimeException from listener onStreamAdded.", e);
+                } catch (Throwable cause) {
+                    logger.error("Caught Throwable from listener onStreamAdded.", cause);
                 }
             }
 
@@ -1175,7 +1095,7 @@ public void process() {
         }
 
         public void deactivate(final DefaultStream stream, final Iterator<?> itr) {
-            if (allowModifications()) {
+            if (allowModifications() || itr != null) {
                 removeFromActiveStreams(stream, itr);
             } else {
                 pendingEvents.add(new Event() {
@@ -1196,7 +1116,7 @@ public void process() {
         }
 
         public Http2Stream forEachActiveStream(Http2StreamVisitor visitor) throws Http2Exception {
-            ++pendingIterations;
+            incrementPendingIterations();
             try {
                 for (Http2Stream stream : streams) {
                     if (!visitor.visit(stream)) {
@@ -1205,20 +1125,7 @@ public Http2Stream forEachActiveStream(Http2StreamVisitor visitor) throws Http2E
                 }
                 return null;
             } finally {
-                --pendingIterations;
-                if (allowModifications()) {
-                    for (;;) {
-                        Event event = pendingEvents.poll();
-                        if (event == null) {
-                            break;
-                        }
-                        try {
-                            event.process();
-                        } catch (RuntimeException e) {
-                            logger.error("Caught RuntimeException while processing pending ActiveStreams$Event.", e);
-                        }
-                    }
-                }
+                decrementPendingIterations();
             }
         }
 
@@ -1230,8 +1137,8 @@ void addToActiveStreams(DefaultStream stream) {
                 for (int i = 0; i < listeners.size(); i++) {
                     try {
                         listeners.get(i).onStreamActive(stream);
-                    } catch (RuntimeException e) {
-                        logger.error("Caught RuntimeException from listener onStreamActive.", e);
+                    } catch (Throwable cause) {
+                        logger.error("Caught Throwable from listener onStreamActive.", cause);
                     }
                 }
             }
@@ -1249,6 +1156,27 @@ void removeFromActiveStreams(DefaultStream stream, Iterator<?> itr) {
         boolean allowModifications() {
             return pendingIterations == 0;
         }
+
+        void incrementPendingIterations() {
+            ++pendingIterations;
+        }
+
+        void decrementPendingIterations() {
+            --pendingIterations;
+            if (allowModifications()) {
+                for (;;) {
+                    Event event = pendingEvents.poll();
+                    if (event == null) {
+                        break;
+                    }
+                    try {
+                        event.process();
+                    } catch (Throwable cause) {
+                        logger.error("Caught Throwable while processing pending ActiveStreams$Event.", cause);
+                    }
+                }
+            }
+        }
     }
 
     /**
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
index 298fccd12530..bd9d2373b0e9 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java
@@ -17,6 +17,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http2.Http2Exception.ClosedStreamCreationException;
+import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -41,6 +42,7 @@
  * This interface enforces inbound flow control functionality through
  * {@link Http2LocalFlowController}
  */
+@UnstableApi
 public class DefaultHttp2ConnectionDecoder implements Http2ConnectionDecoder {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2ConnectionDecoder.class);
     private Http2FrameListener internalFrameListener = new PrefaceFrameListener();
@@ -342,10 +344,8 @@ public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDe
             try {
                 if (stream == null) {
                     if (connection.streamMayHaveExisted(streamId)) {
-                        if (logger.isInfoEnabled()) {
-                            logger.info("%s ignoring PRIORITY frame for stream id %d. Stream doesn't exist but may " +
-                                        " have existed", ctx.channel(), streamId);
-                        }
+                        logger.info("{} ignoring PRIORITY frame for stream {}. Stream doesn't exist but may " +
+                                     " have existed", ctx.channel(), streamId);
                         return;
                     }
 
@@ -353,11 +353,9 @@ public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDe
                     // first frame to be received for a stream that we must create the stream.
                     stream = connection.remote().createIdleStream(streamId);
                 } else if (streamCreatedAfterGoAwaySent(streamId)) {
-                    if (logger.isInfoEnabled()) {
-                        logger.info("%s ignoring PRIORITY frame for stream id %d. Stream created after GOAWAY sent. " +
-                                    "Last known stream by peer " + connection.remote().lastStreamKnownByPeer(),
-                                    ctx.channel(), streamId);
-                    }
+                    logger.info("{} ignoring PRIORITY frame for stream {}. Stream created after GOAWAY sent. " +
+                                    "Last known stream by peer {}",
+                            ctx.channel(), streamId, connection.remote().lastStreamKnownByPeer());
                     return;
                 }
 
@@ -462,7 +460,7 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) th
         public void onPingRead(ChannelHandlerContext ctx, ByteBuf data) throws Http2Exception {
             // Send an ack back to the remote client.
             // Need to retain the buffer here since it will be released after the write completes.
-            encoder.writePing(ctx, true, data.slice().retain(), ctx.newPromise());
+            encoder.writePing(ctx, true, data.retainedSlice(), ctx.newPromise());
 
             listener.onPingRead(ctx, data);
         }
@@ -482,7 +480,7 @@ public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promi
             }
 
             if (parentStream == null) {
-                throw connectionError(PROTOCOL_ERROR, "Stream does not exist %d", streamId);
+                throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);
             }
 
             switch (parentStream.state()) {
@@ -555,19 +553,18 @@ private boolean shouldIgnoreHeadersOrDataFrame(ChannelHandlerContext ctx, int st
                 String frameName) throws Http2Exception {
             if (stream == null) {
                 if (streamCreatedAfterGoAwaySent(streamId)) {
-                    if (logger.isInfoEnabled()) {
-                        logger.info("%s ignoring %s frame for stream id %d. Stream sent after GOAWAY sent",
-                                ctx.channel(), frameName, streamId);
-                    }
+                    logger.info("{} ignoring {} frame for stream {}. Stream sent after GOAWAY sent",
+                            ctx.channel(), frameName, streamId);
                     return true;
                 }
                 // Its possible that this frame would result in stream ID out of order creation (PROTOCOL ERROR) and its
                 // also possible that this frame is received on a CLOSED stream (STREAM_CLOSED after a RST_STREAM is
                 // sent). We don't have enough information to know for sure, so we choose the lesser of the two errors.
-                throw streamError(streamId, STREAM_CLOSED, "Received HEADERS frame for an unknown stream %d", streamId);
+                throw streamError(streamId, STREAM_CLOSED, "Received %s frame for an unknown stream %d",
+                                  frameName, streamId);
             } else if (stream.isResetSent() || streamCreatedAfterGoAwaySent(streamId)) {
                 if (logger.isInfoEnabled()) {
-                    logger.info("%s ignoring %s frame for stream id %d. %s", ctx.channel(), frameName,
+                    logger.info("{} ignoring {} frame for stream {} {}", ctx.channel(), frameName,
                             stream.isResetSent() ? "RST_STREAM sent." :
                                 ("Stream created after GOAWAY sent. Last known stream by peer " +
                                  connection.remote().lastStreamKnownByPeer()));
@@ -597,7 +594,7 @@ private boolean streamCreatedAfterGoAwaySent(int streamId) {
 
         private void verifyStreamMayHaveExisted(int streamId) throws Http2Exception {
             if (!connection.streamMayHaveExisted(streamId)) {
-                throw connectionError(PROTOCOL_ERROR, "Stream does not exist %d", streamId);
+                throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);
             }
         }
     }
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
index 2bc22a422cee..363ee557cc08 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java
@@ -21,6 +21,7 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.CoalescingBufferQueue;
 import io.netty.handler.codec.http2.Http2Exception.ClosedStreamCreationException;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayDeque;
 
@@ -33,6 +34,7 @@
 /**
  * Default implementation of {@link Http2ConnectionEncoder}.
  */
+@UnstableApi
 public class DefaultHttp2ConnectionEncoder implements Http2ConnectionEncoder {
     private final Http2FrameWriter frameWriter;
     private final Http2Connection connection;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java
index 70de2e7e3c2c..84c99e86fd09 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java
@@ -15,15 +15,17 @@
  */
 package io.netty.handler.codec.http2;
 
-import static io.netty.util.internal.ObjectUtil.checkNotNull;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.util.IllegalReferenceCountException;
+import io.netty.util.internal.UnstableApi;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@link Http2DataFrame} implementation.
  */
+@UnstableApi
 public final class DefaultHttp2DataFrame extends AbstractHttp2StreamFrame implements Http2DataFrame {
     private final ByteBuf content;
     private final boolean endStream;
@@ -99,12 +101,22 @@ public ByteBuf content() {
 
     @Override
     public DefaultHttp2DataFrame copy() {
-        return new DefaultHttp2DataFrame(content().copy(), endStream, padding);
+        return replace(content().copy());
     }
 
     @Override
     public DefaultHttp2DataFrame duplicate() {
-        return new DefaultHttp2DataFrame(content().duplicate(), endStream, padding);
+        return replace(content().duplicate());
+    }
+
+    @Override
+    public DefaultHttp2DataFrame retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public DefaultHttp2DataFrame replace(ByteBuf content) {
+        return new DefaultHttp2DataFrame(content, endStream, padding);
     }
 
     @Override
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
index 0cea4b5c6117..55e7f6d060ff 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java
@@ -18,6 +18,8 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http2.Http2FrameReader.Configuration;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_FRAME_SIZE;
 import static io.netty.handler.codec.http2.Http2CodecUtil.FRAME_HEADER_LENGTH;
@@ -49,16 +51,19 @@
 /**
  * A {@link Http2FrameReader} that supports all frame types defined by the HTTP/2 specification.
  */
+@UnstableApi
 public class DefaultHttp2FrameReader implements Http2FrameReader, Http2FrameSizePolicy, Configuration {
-    private enum State {
-        FRAME_HEADER,
-        FRAME_PAYLOAD,
-        ERROR
-    }
-
     private final Http2HeadersDecoder headersDecoder;
 
-    private State state = State.FRAME_HEADER;
+    /**
+     * {@code true} = reading headers, {@code false} = reading payload.
+     */
+    private boolean readingHeaders = true;
+    /**
+     * Once set to {@code true} the value will never change. This is set to {@code true} if an unrecoverable error which
+     * renders the connection unusable.
+     */
+    private boolean readError;
     private byte frameType;
     private int streamId;
     private Http2Flags flags;
@@ -128,44 +133,40 @@ public void close() {
     @Override
     public void readFrame(ChannelHandlerContext ctx, ByteBuf input, Http2FrameListener listener)
             throws Http2Exception {
+        if (readError) {
+            input.skipBytes(input.readableBytes());
+            return;
+        }
         try {
-            while (input.isReadable()) {
-                switch (state) {
-                    case FRAME_HEADER:
-                        processHeaderState(input);
-                        if (state == State.FRAME_HEADER) {
-                            // Wait until the entire header has arrived.
-                            return;
-                        }
-
-                        // The header is complete, fall into the next case to process the payload.
-                        // This is to ensure the proper handling of zero-length payloads. In this
-                        // case, we don't want to loop around because there may be no more data
-                        // available, causing us to exit the loop. Instead, we just want to perform
-                        // the first pass at payload processing now.
-                    case FRAME_PAYLOAD:
-                        processPayloadState(ctx, input, listener);
-                        if (state == State.FRAME_PAYLOAD) {
-                            // Wait until the entire payload has arrived.
-                            return;
-                        }
-                        break;
-                    case ERROR:
-                        input.skipBytes(input.readableBytes());
+            do {
+                if (readingHeaders) {
+                    processHeaderState(input);
+                    if (readingHeaders) {
+                        // Wait until the entire header has arrived.
                         return;
-                    default:
-                        throw new IllegalStateException("Should never get here");
+                    }
                 }
-            }
+
+                // The header is complete, fall into the next case to process the payload.
+                // This is to ensure the proper handling of zero-length payloads. In this
+                // case, we don't want to loop around because there may be no more data
+                // available, causing us to exit the loop. Instead, we just want to perform
+                // the first pass at payload processing now.
+                processPayloadState(ctx, input, listener);
+                if (!readingHeaders) {
+                    // Wait until the entire payload has arrived.
+                    return;
+                }
+            } while (input.isReadable());
         } catch (Http2Exception e) {
-            state = State.ERROR;
+            readError = !Http2Exception.isStreamError(e);
             throw e;
         } catch (RuntimeException e) {
-            state = State.ERROR;
-            throw e;
-        } catch (Error e) {
-            state = State.ERROR;
+            readError = true;
             throw e;
+        } catch (Throwable cause) {
+            readError = true;
+            PlatformDependent.throwException(cause);
         }
     }
 
@@ -184,6 +185,9 @@ private void processHeaderState(ByteBuf in) throws Http2Exception {
         flags = new Http2Flags(in.readUnsignedByte());
         streamId = readUnsignedInt(in);
 
+        // We have consumed the data, next time we read we will be expecting to read the frame payload.
+        readingHeaders = false;
+
         switch (frameType) {
             case DATA:
                 verifyDataFrame();
@@ -219,9 +223,6 @@ private void processHeaderState(ByteBuf in) throws Http2Exception {
                 // Unknown frame type, could be an extension.
                 break;
         }
-
-        // Start reading the payload for the frame.
-        state = State.FRAME_PAYLOAD;
     }
 
     private void processPayloadState(ChannelHandlerContext ctx, ByteBuf in, Http2FrameListener listener)
@@ -234,6 +235,9 @@ private void processPayloadState(ChannelHandlerContext ctx, ByteBuf in, Http2Fra
         // Get a view of the buffer for the size of the payload.
         ByteBuf payload = in.readSlice(payloadLength);
 
+        // We have consumed the data, next time we read we will be expecting to read a frame header.
+        readingHeaders = true;
+
         // Read the payload and fire the frame event to the listener.
         switch (frameType) {
             case DATA:
@@ -270,9 +274,6 @@ private void processPayloadState(ChannelHandlerContext ctx, ByteBuf in, Http2Fra
                 readUnknownFrame(ctx, payload, listener);
                 break;
         }
-
-        // Go back to reading the next frame header.
-        state = State.FRAME_HEADER;
     }
 
     private void verifyDataFrame() throws Http2Exception {
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
index 98ea24fd764d..67c90c7f5875 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java
@@ -15,8 +15,15 @@
 
 package io.netty.handler.codec.http2;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;
+import io.netty.handler.codec.http2.Http2FrameWriter.Configuration;
+import io.netty.util.internal.UnstableApi;
+
 import static io.netty.buffer.Unpooled.directBuffer;
-import static io.netty.buffer.Unpooled.unmodifiableBuffer;
 import static io.netty.buffer.Unpooled.unreleasableBuffer;
 import static io.netty.handler.codec.http2.Http2CodecUtil.CONTINUATION_FRAME_HEADER_LENGTH;
 import static io.netty.handler.codec.http2.Http2CodecUtil.DATA_FRAME_HEADER_LENGTH;
@@ -56,16 +63,10 @@
 import static java.lang.Math.max;
 import static java.lang.Math.min;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;
-import io.netty.handler.codec.http2.Http2FrameWriter.Configuration;
-
 /**
  * A {@link Http2FrameWriter} that supports all frame types defined by the HTTP/2 specification.
  */
+@UnstableApi
 public class DefaultHttp2FrameWriter implements Http2FrameWriter, Http2FrameSizePolicy, Configuration {
     private static final String STREAM_ID = "Stream ID";
     private static final String STREAM_DEPENDENCY = "Stream Dependency";
@@ -74,8 +75,8 @@ public class DefaultHttp2FrameWriter implements Http2FrameWriter, Http2FrameSize
      * When padding is needed it can be taken as a slice of this buffer. Users should call {@link ByteBuf#retain()}
      * before using their slice.
      */
-    private static final ByteBuf ZERO_BUFFER = unmodifiableBuffer(
-            unreleasableBuffer(directBuffer(MAX_UNSIGNED_BYTE).writeZero(MAX_UNSIGNED_BYTE)));
+    private static final ByteBuf ZERO_BUFFER =
+            unreleasableBuffer(directBuffer(MAX_UNSIGNED_BYTE).writeZero(MAX_UNSIGNED_BYTE)).asReadOnly();
 
     private final Http2HeadersEncoder headersEncoder;
     private int maxFrameSize;
@@ -303,8 +304,7 @@ public ChannelFuture writePushPromise(ChannelHandlerContext ctx, int streamId,
             // INT_FIELD_LENGTH is for the length of the promisedStreamId
             int nonFragmentLength = INT_FIELD_LENGTH + padding + flags.getPaddingPresenceFieldLength();
             int maxFragmentLength = maxFrameSize - nonFragmentLength;
-            ByteBuf fragment =
-                    headerBlock.readSlice(min(headerBlock.readableBytes(), maxFragmentLength));
+            ByteBuf fragment = headerBlock.readRetainedSlice(min(headerBlock.readableBytes(), maxFragmentLength));
 
             flags.endOfHeaders(!headerBlock.isReadable());
 
@@ -318,7 +318,7 @@ public ChannelFuture writePushPromise(ChannelHandlerContext ctx, int streamId,
             ctx.write(buf, promiseAggregator.newPromise());
 
             // Write the first fragment.
-            ctx.write(fragment.retain(), promiseAggregator.newPromise());
+            ctx.write(fragment, promiseAggregator.newPromise());
 
             if (padding > 0) { // Write out the padding, if any.
                 ctx.write(ZERO_BUFFER.slice(0, padding), promiseAggregator.newPromise());
@@ -428,8 +428,7 @@ private ChannelFuture writeHeadersInternal(ChannelHandlerContext ctx,
             // Read the first fragment (possibly everything).
             int nonFragmentBytes = padding + flags.getNumPriorityBytes() + flags.getPaddingPresenceFieldLength();
             int maxFragmentLength = maxFrameSize - nonFragmentBytes;
-            ByteBuf fragment =
-                    headerBlock.readSlice(min(headerBlock.readableBytes(), maxFragmentLength));
+            ByteBuf fragment = headerBlock.readRetainedSlice(min(headerBlock.readableBytes(), maxFragmentLength));
 
             // Set the end of headers flag for the first frame.
             flags.endOfHeaders(!headerBlock.isReadable());
@@ -449,7 +448,7 @@ private ChannelFuture writeHeadersInternal(ChannelHandlerContext ctx,
             ctx.write(buf, promiseAggregator.newPromise());
 
             // Write the first fragment.
-            ctx.write(fragment.retain(), promiseAggregator.newPromise());
+            ctx.write(fragment, promiseAggregator.newPromise());
 
             if (padding > 0) { // Write out the padding, if any.
                 ctx.write(ZERO_BUFFER.slice(0, padding), promiseAggregator.newPromise());
@@ -492,7 +491,7 @@ private ChannelFuture writeContinuationFrames(ChannelHandlerContext ctx, int str
 
             do {
                 fragmentReadableBytes = min(headerBlock.readableBytes(), maxFragmentLength);
-                ByteBuf fragment = headerBlock.readSlice(fragmentReadableBytes).retain();
+                ByteBuf fragment = headerBlock.readRetainedSlice(fragmentReadableBytes);
 
                 payloadLength = fragmentReadableBytes + nonFragmentLength;
                 if (headerBlock.isReadable()) {
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java
index a289b47e95c6..823fb47db837 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java
@@ -18,11 +18,12 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.DefaultByteBufHolder;
 import io.netty.buffer.Unpooled;
-import io.netty.util.IllegalReferenceCountException;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link Http2GoAwayFrame} implementation.
  */
+@UnstableApi
 public final class DefaultHttp2GoAwayFrame extends DefaultByteBufHolder implements Http2GoAwayFrame {
     private final long errorCode;
     private int extraStreamIds;
@@ -39,7 +40,7 @@ public DefaultHttp2GoAwayFrame(Http2Error error) {
     /**
      * Equivalent to {@code new DefaultHttp2GoAwayFrame(content, Unpooled.EMPTY_BUFFER)}.
      *
-     * @param error reason for the go away
+     * @param errorCode reason for the go away
      */
     public DefaultHttp2GoAwayFrame(long errorCode) {
         this(errorCode, Unpooled.EMPTY_BUFFER);
@@ -58,7 +59,7 @@ public DefaultHttp2GoAwayFrame(Http2Error error, ByteBuf content) {
     /**
      * Construct a new GOAWAY message.
      *
-     * @param error reason for the go away
+     * @param errorCode reason for the go away
      * @param content non-{@code null} debug data
      */
     public DefaultHttp2GoAwayFrame(long errorCode, ByteBuf content) {
@@ -77,7 +78,7 @@ public int extraStreamIds() {
     }
 
     @Override
-    public DefaultHttp2GoAwayFrame setExtraStreamIds(int extraStreamIds) {
+    public Http2GoAwayFrame setExtraStreamIds(int extraStreamIds) {
         if (extraStreamIds < 0) {
             throw new IllegalArgumentException("extraStreamIds must be non-negative");
         }
@@ -86,41 +87,45 @@ public DefaultHttp2GoAwayFrame setExtraStreamIds(int extraStreamIds) {
     }
 
     @Override
-    public DefaultHttp2GoAwayFrame copy() {
-        return new DefaultHttp2GoAwayFrame(errorCode, content().copy()).setExtraStreamIds(extraStreamIds);
+    public Http2GoAwayFrame copy() {
+        return (Http2GoAwayFrame) super.copy();
     }
 
     @Override
-    public DefaultHttp2GoAwayFrame duplicate() {
-        return new DefaultHttp2GoAwayFrame(errorCode, content().duplicate()).setExtraStreamIds(extraStreamIds);
+    public Http2GoAwayFrame duplicate() {
+        return (Http2GoAwayFrame) super.duplicate();
     }
 
     @Override
-    public DefaultHttp2GoAwayFrame retain() {
-        super.retain();
-        return this;
+    public Http2GoAwayFrame retainedDuplicate() {
+        return (Http2GoAwayFrame) super.retainedDuplicate();
     }
 
     @Override
-    public DefaultHttp2GoAwayFrame retain(int increment) {
-        super.retain(increment);
+    public Http2GoAwayFrame replace(ByteBuf content) {
+        return new DefaultHttp2GoAwayFrame(errorCode, content).setExtraStreamIds(extraStreamIds);
+    }
+
+    @Override
+    public Http2GoAwayFrame retain() {
+        super.retain();
         return this;
     }
 
     @Override
-    public String toString() {
-        return "DefaultHttp2GoAwayFrame(errorCode=" + errorCode + ", content=" + content()
-            + ", extraStreamIds=" + extraStreamIds + ")";
+    public Http2GoAwayFrame retain(int increment) {
+        super.retain(increment);
+        return this;
     }
 
     @Override
-    public DefaultHttp2GoAwayFrame touch() {
+    public Http2GoAwayFrame touch() {
         super.touch();
         return this;
     }
 
     @Override
-    public DefaultHttp2GoAwayFrame touch(Object hint) {
+    public Http2GoAwayFrame touch(Object hint) {
         super.touch(hint);
         return this;
     }
@@ -143,4 +148,10 @@ public int hashCode() {
         hash = hash * 31 + extraStreamIds;
         return hash;
     }
+
+    @Override
+    public String toString() {
+        return "DefaultHttp2GoAwayFrame(errorCode=" + errorCode + ", content=" + content()
+               + ", extraStreamIds=" + extraStreamIds + ")";
+    }
 }
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java
index 63bb56178721..3b94371ed454 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java
@@ -23,7 +23,9 @@
 import io.netty.util.AsciiString;
 import io.netty.util.ByteProcessor;
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
 
+@UnstableApi
 public class DefaultHttp2Headers
         extends DefaultHeaders<CharSequence, CharSequence, Http2Headers> implements Http2Headers {
     private static final ByteProcessor HTTP2_NAME_VALIDATOR_PROCESSOR = new ByteProcessor() {
@@ -35,6 +37,10 @@ public boolean process(byte value) throws Exception {
     private static final NameValidator<CharSequence> HTTP2_NAME_VALIDATOR = new NameValidator<CharSequence>() {
         @Override
         public void validateName(CharSequence name) {
+            if (name == null || name.length() == 0) {
+                PlatformDependent.throwException(connectionError(PROTOCOL_ERROR,
+                        "empty headers are not allowed [%s]", name));
+            }
             if (name instanceof AsciiString) {
                 final int index;
                 try {
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
index be71dff82350..5ce75f7f4459 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java
@@ -17,9 +17,10 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufInputStream;
-import io.netty.handler.codec.http2.hpack.Decoder;
-import io.netty.handler.codec.http2.hpack.HeaderListener;
+import io.netty.handler.codec.http2.internal.hpack.Decoder;
+import io.netty.handler.codec.http2.internal.hpack.HeaderListener;
 import io.netty.util.AsciiString;
+import io.netty.util.internal.UnstableApi;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -32,6 +33,7 @@
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 
+@UnstableApi
 public class DefaultHttp2HeadersDecoder implements Http2HeadersDecoder, Http2HeadersDecoder.Configuration {
     private static final float HEADERS_COUNT_WEIGHT_NEW = 1 / 5f;
     private static final float HEADERS_COUNT_WEIGHT_HISTORICAL = 1 - HEADERS_COUNT_WEIGHT_NEW;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
index 854498c3a2b7..f4d9e2d4ab57 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
@@ -17,8 +17,9 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
-import io.netty.handler.codec.http2.hpack.Encoder;
+import io.netty.handler.codec.http2.internal.hpack.Encoder;
 import io.netty.util.AsciiString;
+import io.netty.util.internal.UnstableApi;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -32,6 +33,7 @@
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
+@UnstableApi
 public class DefaultHttp2HeadersEncoder implements Http2HeadersEncoder, Http2HeadersEncoder.Configuration {
     private final Encoder encoder;
     private final ByteArrayOutputStream tableSizeChangeOutput = new ByteArrayOutputStream();
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersFrame.java
index ac9ecd672c7f..d12b4365e343 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersFrame.java
@@ -15,11 +15,14 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@link Http2HeadersFrame} implementation.
  */
+@UnstableApi
 public final class DefaultHttp2HeadersFrame extends AbstractHttp2StreamFrame implements Http2HeadersFrame {
     private final Http2Headers headers;
     private final boolean endStream;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
index 60c4633f68fe..74dc3ae31c44 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java
@@ -31,6 +31,7 @@
 import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;
 import io.netty.handler.codec.http2.Http2Exception.StreamException;
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Basic implementation of {@link Http2LocalFlowController}.
@@ -38,6 +39,7 @@
  * This class is <strong>NOT</strong> thread safe. The assumption is all methods must be invoked from a single thread.
  * Typically this thread is the event loop thread for the {@link ChannelHandlerContext} managed by this class.
  */
+@UnstableApi
 public class DefaultHttp2LocalFlowController implements Http2LocalFlowController {
     /**
      * The default ratio of window size to initial window size below which a {@code WINDOW_UPDATE}
@@ -282,7 +284,6 @@ private FlowState connectionState() {
     }
 
     private FlowState state(Http2Stream stream) {
-        checkNotNull(stream, "stream");
         return stream.getProperty(stateKey);
     }
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
index dd33ce80a41e..fb761276885e 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java
@@ -14,30 +14,32 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.StreamByteDistributor.Writer;
+import io.netty.util.BooleanSupplier;
+import io.netty.util.internal.UnstableApi;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.util.ArrayDeque;
+import java.util.Deque;
+
 import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_WINDOW_SIZE;
 import static io.netty.handler.codec.http2.Http2Error.FLOW_CONTROL_ERROR;
 import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.streamError;
 import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;
-import static io.netty.handler.codec.http2.Http2Stream.State.IDLE;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import static java.lang.Math.max;
 import static java.lang.Math.min;
 
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.http2.StreamByteDistributor.Writer;
-import io.netty.util.internal.logging.InternalLogger;
-import io.netty.util.internal.logging.InternalLoggerFactory;
-
-import java.util.ArrayDeque;
-import java.util.Deque;
-
 /**
  * Basic implementation of {@link Http2RemoteFlowController}.
  * <p>
  * This class is <strong>NOT</strong> thread safe. The assumption is all methods must be invoked from a single thread.
  * Typically this thread is the event loop thread for the {@link ChannelHandlerContext} managed by this class.
  */
+@UnstableApi
 public class DefaultHttp2RemoteFlowController implements Http2RemoteFlowController {
     private static final InternalLogger logger =
             InternalLoggerFactory.getInstance(DefaultHttp2RemoteFlowController.class);
@@ -45,7 +47,7 @@ public class DefaultHttp2RemoteFlowController implements Http2RemoteFlowControll
     private final Http2Connection connection;
     private final Http2Connection.PropertyKey stateKey;
     private final StreamByteDistributor streamByteDistributor;
-    private final AbstractState connectionState;
+    private final FlowState connectionState;
     private int initialWindowSize = DEFAULT_WINDOW_SIZE;
     private WritabilityMonitor monitor;
     private ChannelHandlerContext ctx;
@@ -71,12 +73,12 @@ public DefaultHttp2RemoteFlowController(Http2Connection connection,
 
         // Add a flow state for the connection.
         stateKey = connection.newKey();
-        connectionState = new DefaultState(connection.connectionStream(), initialWindowSize,
-                initialWindowSize > 0 && isChannelWritable());
+        connectionState = new FlowState(connection.connectionStream());
         connection.connectionStream().setProperty(stateKey, connectionState);
 
         // Monitor may depend upon connectionState, and so initialize after connectionState
         listener(listener);
+        monitor.windowSize(connectionState, initialWindowSize);
 
         // Register for notification of new streams.
         connection.addListener(new Http2ConnectionAdapter() {
@@ -84,40 +86,21 @@ public DefaultHttp2RemoteFlowController(Http2Connection connection,
             public void onStreamAdded(Http2Stream stream) {
                 // If the stream state is not open then the stream is not yet eligible for flow controlled frames and
                 // only requires the ReducedFlowState. Otherwise the full amount of memory is required.
-                stream.setProperty(stateKey, stream.state() == IDLE ?
-                        new ReducedState(stream) :
-                        new DefaultState(stream, 0,
-                                isWritable(DefaultHttp2RemoteFlowController.this.connection.connectionStream())));
+                stream.setProperty(stateKey, new FlowState(stream));
             }
 
             @Override
             public void onStreamActive(Http2Stream stream) {
-                // If the object was previously created, but later activated then we have to ensure
-                // the full state is allocated and the proper initialWindowSize is used.
-                AbstractState state = state(stream);
-                if (state.getClass() == DefaultState.class) {
-                    state.window(initialWindowSize);
-                } else {
-                    stream.setProperty(stateKey, new DefaultState(state, initialWindowSize));
-                }
+                // If the object was previously created, but later activated then we have to ensure the proper
+                // initialWindowSize is used.
+                monitor.windowSize(state(stream), initialWindowSize);
             }
 
             @Override
             public void onStreamClosed(Http2Stream stream) {
                 // Any pending frames can never be written, cancel and
                 // write errors for any pending frames.
-                AbstractState state = state(stream);
-                state.cancel();
-
-                // If the stream is now eligible for removal, but will persist in the priority tree then we can
-                // decrease the amount of memory required for this stream because no flow controlled frames can
-                // be exchanged on this stream
-                if (stream.prioritizableForTree() != 0) {
-                    state = new ReducedState(state);
-                    stream.setProperty(stateKey, state);
-                }
-                // Tell the monitor after cancel has been called and after the new state is used.
-                monitor.stateCancelled(state);
+                state(stream).cancel();
             }
 
             @Override
@@ -134,9 +117,7 @@ public void onStreamHalfClosed(Http2Stream stream) {
                      *
                      * This is to cancel any such illegal writes.
                      */
-                    AbstractState state = state(stream);
-                    state.cancel();
-                    monitor.stateCancelled(state);
+                    state(stream).cancel();
                 }
             }
         });
@@ -208,11 +189,6 @@ public void listener(Listener listener) {
         monitor = listener == null ? new WritabilityMonitor() : new ListenerWritabilityMonitor(listener);
     }
 
-    @Override
-    public int initialWindowSize(Http2Stream stream) {
-        return state(stream).initialWindowSize();
-    }
-
     @Override
     public void incrementWindowSize(Http2Stream stream, int delta) throws Http2Exception {
         assert ctx == null || ctx.executor().inEventLoop();
@@ -236,8 +212,8 @@ public boolean hasFlowControlled(Http2Stream stream) {
         return state(stream).hasFrame();
     }
 
-    private AbstractState state(Http2Stream stream) {
-        return (AbstractState) checkNotNull(stream, "stream").getProperty(stateKey);
+    private FlowState state(Http2Stream stream) {
+        return (FlowState) stream.getProperty(stateKey);
     }
 
     /**
@@ -282,43 +258,83 @@ public void writePendingBytes() throws Http2Exception {
     /**
      * The remote flow control state for a single stream.
      */
-    private final class DefaultState extends AbstractState {
+    private final class FlowState implements StreamByteDistributor.StreamState {
+        private final Http2Stream stream;
         private final Deque<FlowControlled> pendingWriteQueue;
         private int window;
         private int pendingBytes;
-        // Set to true while a frame is being written, false otherwise.
+        private boolean markedWritable;
+
+        /**
+         * Set to true while a frame is being written, false otherwise.
+         */
         private boolean writing;
-        // Set to true if cancel() was called.
+        /**
+         * Set to true if cancel() was called.
+         */
         private boolean cancelled;
+        private BooleanSupplier isWritableSupplier = new BooleanSupplier() {
+            @Override
+            public boolean get() throws Exception {
+                return windowSize() - pendingBytes() > 0;
+            }
+        };
 
-        DefaultState(Http2Stream stream, int initialWindowSize, boolean markedWritable) {
-            super(stream, markedWritable);
-            window(initialWindowSize);
+        FlowState(Http2Stream stream) {
+            this.stream = stream;
             pendingWriteQueue = new ArrayDeque<FlowControlled>(2);
         }
 
-        DefaultState(AbstractState existingState, int initialWindowSize) {
-            super(existingState);
-            window(initialWindowSize);
-            pendingWriteQueue = new ArrayDeque<FlowControlled>(2);
+        /**
+         * Determine if the stream associated with this object is writable.
+         * @return {@code true} if the stream associated with this object is writable.
+         */
+        boolean isWritable() {
+            try {
+                return isWritableSupplier.get();
+            } catch (Throwable cause) {
+                throw new Error("isWritableSupplier should never throw!", cause);
+            }
         }
 
+        /**
+         * The stream this state is associated with.
+         */
         @Override
-        public int windowSize() {
-            return window;
+        public Http2Stream stream() {
+            return stream;
         }
 
-        @Override
-        int initialWindowSize() {
-            return initialWindowSize;
+        /**
+         * Returns the parameter from the last call to {@link #markedWritability(boolean)}.
+         */
+        boolean markedWritability() {
+            return markedWritable;
+        }
+
+        /**
+         * Save the state of writability.
+         */
+        void markedWritability(boolean isWritable) {
+            this.markedWritable = isWritable;
         }
 
         @Override
-        void window(int initialWindowSize) {
+        public int windowSize() {
+            return window;
+        }
+
+        /**
+         * Reset the window size for this stream.
+         */
+        void windowSize(int initialWindowSize) {
             window = initialWindowSize;
         }
 
-        @Override
+        /**
+         * Write the allocated bytes for this stream.
+         * @return the number of bytes written for a stream or {@code -1} if no write occurred.
+         */
         int writeAllocatedBytes(int allocated) {
             final int initialAllocated = allocated;
             int writtenBytes;
@@ -382,7 +398,9 @@ int writeAllocatedBytes(int allocated) {
             return writtenBytes;
         }
 
-        @Override
+        /**
+         * Increments the flow control window for this stream by the given delta and returns the new value.
+         */
         int incrementStreamWindow(int delta) throws Http2Exception {
             if (delta > 0 && Integer.MAX_VALUE - delta < window) {
                 throw streamError(stream.id(), FLOW_CONTROL_ERROR,
@@ -406,7 +424,9 @@ public int pendingBytes() {
             return pendingBytes;
         }
 
-        @Override
+        /**
+         * Adds the {@code frame} to the pending queue and increments the pending byte count.
+         */
         void enqueueFrame(FlowControlled frame) {
             FlowControlled last = pendingWriteQueue.peekLast();
             if (last == null) {
@@ -441,7 +461,9 @@ private FlowControlled peek() {
             return pendingWriteQueue.peek();
         }
 
-        @Override
+        /**
+         * Any operations that may be pending are cleared and the status of these operations is failed.
+         */
         void cancel() {
             cancel(null);
         }
@@ -456,6 +478,7 @@ private void cancel(Throwable cause) {
             if (writing) {
                 return;
             }
+
             for (;;) {
                 FlowControlled frame = pendingWriteQueue.poll();
                 if (frame == null) {
@@ -466,6 +489,9 @@ private void cancel(Throwable cause) {
             }
 
             streamByteDistributor.updateStreamableBytes(this);
+
+            isWritableSupplier = BooleanSupplier.FALSE_SUPPLIER;
+            monitor.stateCancelled(this);
         }
 
         /**
@@ -512,135 +538,6 @@ private void writeError(FlowControlled frame, Http2Exception cause) {
         }
     }
 
-    /**
-     * The remote flow control state for a single stream that is not in a state where flow controlled frames cannot
-     * be exchanged.
-     */
-    private final class ReducedState extends AbstractState {
-        ReducedState(Http2Stream stream) {
-            super(stream, false);
-        }
-
-        ReducedState(AbstractState existingState) {
-            super(existingState);
-        }
-
-        @Override
-        public int windowSize() {
-            return 0;
-        }
-
-        @Override
-        int initialWindowSize() {
-            return 0;
-        }
-
-        @Override
-        public int pendingBytes() {
-            return 0;
-        }
-
-        @Override
-        int writeAllocatedBytes(int allocated) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        void cancel() {
-        }
-
-        @Override
-        void window(int initialWindowSize) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        int incrementStreamWindow(int delta) throws Http2Exception {
-            // This operation needs to be supported during the initial settings exchange when
-            // the peer has not yet acknowledged this peer being activated.
-            return 0;
-        }
-
-        @Override
-        void enqueueFrame(FlowControlled frame) {
-            throw new UnsupportedOperationException();
-        }
-
-        @Override
-        public boolean hasFrame() {
-            return false;
-        }
-    }
-
-    /**
-     * An abstraction which provides specific extensions used by remote flow control.
-     */
-    private abstract class AbstractState implements StreamByteDistributor.StreamState {
-        protected final Http2Stream stream;
-        private boolean markedWritable;
-
-        AbstractState(Http2Stream stream, boolean markedWritable) {
-            this.stream = stream;
-            this.markedWritable = markedWritable;
-        }
-
-        AbstractState(AbstractState existingState) {
-            stream = existingState.stream();
-            markedWritable = existingState.markWritability();
-        }
-
-        /**
-         * The stream this state is associated with.
-         */
-        @Override
-        public final Http2Stream stream() {
-            return stream;
-        }
-
-        /**
-         * Returns the parameter from the last call to {@link #markWritability(boolean)}.
-         */
-        final boolean markWritability() {
-            return markedWritable;
-        }
-
-        /**
-         * Save the state of writability.
-         */
-        final void markWritability(boolean isWritable) {
-            this.markedWritable = isWritable;
-        }
-
-        abstract int initialWindowSize();
-
-        /**
-         * Write the allocated bytes for this stream.
-         *
-         * @return the number of bytes written for a stream or {@code -1} if no write occurred.
-         */
-        abstract int writeAllocatedBytes(int allocated);
-
-        /**
-         * Any operations that may be pending are cleared and the status of these operations is failed.
-         */
-        abstract void cancel();
-
-        /**
-         * Reset the window size for this stream.
-         */
-        abstract void window(int initialWindowSize);
-
-        /**
-         * Increments the flow control window for this stream by the given delta and returns the new value.
-         */
-        abstract int incrementStreamWindow(int delta) throws Http2Exception;
-
-        /**
-         * Adds the {@code frame} to the pending queue and increments the pending byte count.
-         */
-        abstract void enqueueFrame(FlowControlled frame);
-    }
-
     /**
      * Abstract class which provides common functionality for writability monitor implementations.
      */
@@ -657,13 +554,22 @@ public void write(Http2Stream stream, int numBytes) {
          * Called when the writability of the underlying channel changes.
          * @throws Http2Exception If a write occurs and an exception happens in the write operation.
          */
-        public void channelWritabilityChange() throws Http2Exception { }
+        void channelWritabilityChange() throws Http2Exception { }
 
         /**
-         * Called when the state is cancelled outside of a write operation.
+         * Called when the state is cancelled.
          * @param state the state that was cancelled.
          */
-        public void stateCancelled(AbstractState state) { }
+        void stateCancelled(FlowState state) { }
+
+        /**
+         * Set the initial window size for {@code state}.
+         * @param state the state to change the initial window size for.
+         * @param initialWindowSize the size of the window in bytes.
+         */
+        void windowSize(FlowState state, int initialWindowSize) {
+            state.windowSize(initialWindowSize);
+        }
 
         /**
          * Increment the window size for a particular stream.
@@ -671,7 +577,7 @@ public void stateCancelled(AbstractState state) { }
          * @param delta The amount to increment by.
          * @throws Http2Exception If this operation overflows the window for {@code state}.
          */
-        public void incrementWindowSize(AbstractState state, int delta) throws Http2Exception {
+        void incrementWindowSize(FlowState state, int delta) throws Http2Exception {
             state.incrementStreamWindow(delta);
         }
 
@@ -681,7 +587,7 @@ public void incrementWindowSize(AbstractState state, int delta) throws Http2Exce
          * @param frame the frame to enqueue.
          * @throws Http2Exception If a writability error occurs.
          */
-        public void enqueueFrame(AbstractState state, FlowControlled frame) throws Http2Exception {
+        void enqueueFrame(FlowState state, FlowControlled frame) throws Http2Exception {
             state.enqueueFrame(frame);
         }
 
@@ -690,7 +596,7 @@ public void enqueueFrame(AbstractState state, FlowControlled frame) throws Http2
          * method should be called.
          * @param delta The amount to increment by.
          */
-        public final void incrementPendingBytes(int delta) {
+        final void incrementPendingBytes(int delta) {
             totalPendingBytes += delta;
 
             // Notification of writibilty change should be delayed until the end of the top level event.
@@ -700,13 +606,13 @@ public final void incrementPendingBytes(int delta) {
         /**
          * Determine if the stream associated with {@code state} is writable.
          * @param state The state which is associated with the stream to test writability for.
-         * @return {@code true} if {@link AbstractState#stream()} is writable. {@code false} otherwise.
+         * @return {@code true} if {@link FlowState#stream()} is writable. {@code false} otherwise.
          */
-        public final boolean isWritable(AbstractState state) {
-            return isWritableConnection() && state.windowSize() - state.pendingBytes() > 0;
+        final boolean isWritable(FlowState state) {
+            return isWritableConnection() && state.isWritable();
         }
 
-        protected final void writePendingBytes() throws Http2Exception {
+        final void writePendingBytes() throws Http2Exception {
             int bytesToWrite = writableBytes();
 
             // Make sure we always write at least once, regardless if we have bytesToWrite or not.
@@ -720,7 +626,7 @@ protected final void writePendingBytes() throws Http2Exception {
             }
         }
 
-        protected void initialWindowSize(int newWindowSize) throws Http2Exception {
+        void initialWindowSize(int newWindowSize) throws Http2Exception {
             if (newWindowSize < 0) {
                 throw new IllegalArgumentException("Invalid initial window size: " + newWindowSize);
             }
@@ -735,13 +641,13 @@ public boolean visit(Http2Stream stream) throws Http2Exception {
                 }
             });
 
-            if (delta > 0) {
+            if (delta > 0 && isChannelWritable()) {
                 // The window size increased, send any pending frames for all streams.
                 writePendingBytes();
             }
         }
 
-        protected final boolean isWritableConnection() {
+        final boolean isWritableConnection() {
             return connectionState.windowSize() - totalPendingBytes > 0 && isChannelWritable();
         }
     }
@@ -759,8 +665,8 @@ private final class ListenerWritabilityMonitor extends WritabilityMonitor {
         private final Http2StreamVisitor checkStreamWritabilityVisitor = new Http2StreamVisitor() {
             @Override
             public boolean visit(Http2Stream stream) throws Http2Exception {
-                AbstractState state = state(stream);
-                if (isWritable(state) != state.markWritability()) {
+                FlowState state = state(stream);
+                if (isWritable(state) != state.markedWritability()) {
                     notifyWritabilityChanged(state);
                 }
                 return true;
@@ -772,19 +678,23 @@ public boolean visit(Http2Stream stream) throws Http2Exception {
         }
 
         @Override
-        public void incrementWindowSize(AbstractState state, int delta) throws Http2Exception {
-            super.incrementWindowSize(state, delta);
-            if (isWritable(state) != state.markWritability()) {
-                if (state == connectionState) {
-                    checkAllWritabilityChanged();
-                } else {
-                    notifyWritabilityChanged(state);
-                }
+        void windowSize(FlowState state, int initialWindowSize) {
+            super.windowSize(state, initialWindowSize);
+            try {
+                checkStateWritability(state);
+            } catch (Http2Exception e) {
+                throw new RuntimeException("Caught unexpected exception from window", e);
             }
         }
 
         @Override
-        protected void initialWindowSize(int newWindowSize) throws Http2Exception {
+        void incrementWindowSize(FlowState state, int delta) throws Http2Exception {
+            super.incrementWindowSize(state, delta);
+            checkStateWritability(state);
+        }
+
+        @Override
+        void initialWindowSize(int newWindowSize) throws Http2Exception {
             super.initialWindowSize(newWindowSize);
             if (isWritableConnection()) {
                 // If the write operation does not occur we still need to check all streams because they
@@ -794,48 +704,58 @@ protected void initialWindowSize(int newWindowSize) throws Http2Exception {
         }
 
         @Override
-        public void enqueueFrame(AbstractState state, FlowControlled frame) throws Http2Exception {
+        void enqueueFrame(FlowState state, FlowControlled frame) throws Http2Exception {
             super.enqueueFrame(state, frame);
             checkConnectionThenStreamWritabilityChanged(state);
         }
 
         @Override
-        public void stateCancelled(AbstractState state) {
+        void stateCancelled(FlowState state) {
             try {
                 checkConnectionThenStreamWritabilityChanged(state);
             } catch (Http2Exception e) {
-                logger.error("Caught unexpected exception from checkAllWritabilityChanged", e);
+                throw new RuntimeException("Caught unexpected exception from checkAllWritabilityChanged", e);
             }
         }
 
         @Override
-        public void channelWritabilityChange() throws Http2Exception {
-            if (connectionState.markWritability() != isChannelWritable()) {
+        void channelWritabilityChange() throws Http2Exception {
+            if (connectionState.markedWritability() != isChannelWritable()) {
                 checkAllWritabilityChanged();
             }
         }
 
-        private void notifyWritabilityChanged(AbstractState state) {
-            state.markWritability(!state.markWritability());
+        private void checkStateWritability(FlowState state) throws Http2Exception {
+            if (isWritable(state) != state.markedWritability()) {
+                if (state == connectionState) {
+                    checkAllWritabilityChanged();
+                } else {
+                    notifyWritabilityChanged(state);
+                }
+            }
+        }
+
+        private void notifyWritabilityChanged(FlowState state) {
+            state.markedWritability(!state.markedWritability());
             try {
                 listener.writabilityChanged(state.stream);
-            } catch (RuntimeException e) {
-                logger.error("Caught unexpected exception from listener.writabilityChanged", e);
+            } catch (Throwable cause) {
+                logger.error("Caught Throwable from listener.writabilityChanged", cause);
             }
         }
 
-        private void checkConnectionThenStreamWritabilityChanged(AbstractState state) throws Http2Exception {
+        private void checkConnectionThenStreamWritabilityChanged(FlowState state) throws Http2Exception {
             // It is possible that the connection window and/or the individual stream writability could change.
-            if (isWritableConnection() != connectionState.markWritability()) {
+            if (isWritableConnection() != connectionState.markedWritability()) {
                 checkAllWritabilityChanged();
-            } else if (isWritable(state) != state.markWritability()) {
+            } else if (isWritable(state) != state.markedWritability()) {
                 notifyWritabilityChanged(state);
             }
         }
 
         private void checkAllWritabilityChanged() throws Http2Exception {
             // Make sure we mark that we have notified as a result of this change.
-            connectionState.markWritability(isWritableConnection());
+            connectionState.markedWritability(isWritableConnection());
             connection.forEachActiveStream(checkStreamWritabilityVisitor);
         }
     }
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ResetFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ResetFrame.java
index 2c7e2b05908e..551b3e2360e7 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ResetFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ResetFrame.java
@@ -15,11 +15,14 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 /**
  * The default {@link Http2ResetFrame} implementation.
  */
+@UnstableApi
 public final class DefaultHttp2ResetFrame extends AbstractHttp2StreamFrame implements Http2ResetFrame {
     private final long errorCode;
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java
index aa9a6114a558..aaab7443f4d0 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java
@@ -21,6 +21,7 @@
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.compression.ZlibCodecFactory;
 import io.netty.handler.codec.compression.ZlibWrapper;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_ENCODING;
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
@@ -37,6 +38,7 @@
  * A HTTP2 frame listener that will decompress data frames according to the {@code content-encoding} header for each
  * stream. The decompression provided by this class will be applied to the data for the entire stream.
  */
+@UnstableApi
 public class DelegatingDecompressorFrameListener extends Http2FrameListenerDecorator {
 
     private final Http2Connection connection;
@@ -319,11 +321,6 @@ public int windowSize(Http2Stream stream) {
             return flowController.windowSize(stream);
         }
 
-        @Override
-        public int initialWindowSize(Http2Stream stream) {
-            return flowController.initialWindowSize(stream);
-        }
-
         @Override
         public void incrementWindowSize(Http2Stream stream, int delta) throws Http2Exception {
             flowController.incrementWindowSize(stream, delta);
@@ -365,6 +362,11 @@ public boolean consumeBytes(Http2Stream stream, int numBytes) throws Http2Except
         public int unconsumedBytes(Http2Stream stream) {
             return flowController.unconsumedBytes(stream);
         }
+
+        @Override
+        public int initialWindowSize(Http2Stream stream) {
+            return flowController.initialWindowSize(stream);
+        }
     }
 
     /**
@@ -416,7 +418,7 @@ void incrementCompressedBytes(int delta) {
 
         /**
          * Increment the number of bytes after the decompression process. Under normal circumstances this
-         * delta should not exceed {@link Http2Decompressor#processedBytes()}.
+         * delta should not exceed {@link Http2Decompressor#processed)}.
          */
         void incrementDecompressedByes(int delta) {
             if (decompressed + delta < 0) {
@@ -426,10 +428,10 @@ void incrementDecompressedByes(int delta) {
         }
 
         /**
-         * Decrements {@link Http2Decompressor#processedBytes()} by {@code processedBytes} and determines the ratio
-         * between {@code processedBytes} and {@link Http2Decompressor#decompressedBytes()}.
-         * This ratio is used to decrement {@link Http2Decompressor#decompressedBytes()} and
-         * {@link Http2Decompressor#compressedBytes()}.
+         * Decrements {@link Http2Decompressor#processed} by {@code processedBytes} and determines the ratio
+         * between {@code processedBytes} and {@link Http2Decompressor#decompressed}.
+         * This ratio is used to decrement {@link Http2Decompressor#decompressed} and
+         * {@link Http2Decompressor#compressed}.
          * @param processedBytes The number of post-decompressed bytes that have been processed.
          * @return The number of pre-decompressed bytes that have been consumed.
          */
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/EmptyHttp2Headers.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/EmptyHttp2Headers.java
index 30da6648ad16..81fd1ea3e4d3 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/EmptyHttp2Headers.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/EmptyHttp2Headers.java
@@ -16,7 +16,9 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.EmptyHeaders;
+import io.netty.util.internal.UnstableApi;
 
+@UnstableApi
 public final class EmptyHttp2Headers
         extends EmptyHeaders<CharSequence, CharSequence, Http2Headers> implements Http2Headers {
     public static final EmptyHttp2Headers INSTANCE = new EmptyHttp2Headers();
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java
index 7ac962fa9f06..3794e3eaf4c6 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java
@@ -31,6 +31,7 @@
 import io.netty.handler.codec.http.HttpClientUpgradeHandler;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.util.collection.CharObjectMap;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.Collection;
 import java.util.Collections;
@@ -39,6 +40,7 @@
 /**
  * Client-side cleartext upgrade codec from HTTP to HTTP/2.
  */
+@UnstableApi
 public class Http2ClientUpgradeCodec implements HttpClientUpgradeHandler.UpgradeCodec {
 
     private static final List<CharSequence> UPGRADE_HEADERS = Collections.singletonList(HTTP_UPGRADE_SETTINGS_HEADER);
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
index 1b489dc2d4d5..b1f608482c08 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java
@@ -25,9 +25,9 @@
 import io.netty.handler.ssl.ApplicationProtocolNames;
 import io.netty.util.AsciiString;
 import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.buffer.Unpooled.directBuffer;
-import static io.netty.buffer.Unpooled.unmodifiableBuffer;
 import static io.netty.buffer.Unpooled.unreleasableBuffer;
 import static io.netty.util.CharsetUtil.UTF_8;
 import static java.lang.Math.max;
@@ -36,6 +36,7 @@
 /**
  * Constants and utility method used for encoding/decoding HTTP2 frames.
  */
+@UnstableApi
 public final class Http2CodecUtil {
     public static final int CONNECTION_STREAM_ID = 0;
     public static final int HTTP_UPGRADE_STREAM_ID = 1;
@@ -54,10 +55,12 @@ public final class Http2CodecUtil {
     public static final short MAX_WEIGHT = 256;
     public static final short MIN_WEIGHT = 1;
 
-    private static final ByteBuf CONNECTION_PREFACE = unmodifiableBuffer(
-            unreleasableBuffer(directBuffer(24).writeBytes("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(UTF_8))));
-    private static final ByteBuf EMPTY_PING = unmodifiableBuffer(
-            unreleasableBuffer(directBuffer(PING_FRAME_PAYLOAD_LENGTH).writeZero(PING_FRAME_PAYLOAD_LENGTH)));
+    private static final ByteBuf CONNECTION_PREFACE =
+            unreleasableBuffer(directBuffer(24).writeBytes("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(UTF_8)))
+                    .asReadOnly();
+    private static final ByteBuf EMPTY_PING =
+            unreleasableBuffer(directBuffer(PING_FRAME_PAYLOAD_LENGTH).writeZero(PING_FRAME_PAYLOAD_LENGTH))
+                    .asReadOnly();
 
     private static final int MAX_PADDING_LENGTH_LENGTH = 1;
     public static final int DATA_FRAME_HEADER_LENGTH = FRAME_HEADER_LENGTH + MAX_PADDING_LENGTH_LENGTH;
@@ -116,7 +119,7 @@ public static boolean isMaxFrameSizeValid(int maxFrameSize) {
      */
     public static ByteBuf connectionPrefaceBuf() {
         // Return a duplicate so that modifications to the reader index will not affect the original buffer.
-        return CONNECTION_PREFACE.duplicate().retain();
+        return CONNECTION_PREFACE.retainedDuplicate();
     }
 
     /**
@@ -124,7 +127,7 @@ public static ByteBuf connectionPrefaceBuf() {
      */
     public static ByteBuf emptyPingBuf() {
         // Return a duplicate so that modifications to the reader index will not affect the original buffer.
-        return EMPTY_PING.duplicate().retain();
+        return EMPTY_PING.retainedDuplicate();
     }
 
     /**
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java
index 419e216982c2..1079ad37e83a 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java
@@ -18,10 +18,12 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.Promise;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Manager for the state of an HTTP/2 connection with the remote end-point.
  */
+@UnstableApi
 public interface Http2Connection {
     /**
      * Listener for life-cycle events for streams in this connection.
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionAdapter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionAdapter.java
index ae39ccbee078..e5aa574b56a8 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionAdapter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionAdapter.java
@@ -15,10 +15,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Provides empty implementations of all {@link Http2Connection.Listener} methods.
  */
+@UnstableApi
 public class Http2ConnectionAdapter implements Http2Connection.Listener {
 
     @Override
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionDecoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionDecoder.java
index 673aa8a770d7..e95c4a47463a 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionDecoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionDecoder.java
@@ -16,6 +16,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 import java.io.Closeable;
 import java.util.List;
@@ -26,6 +27,7 @@
  * application-specific processing. Note that frames of an unknown type (i.e. HTTP/2 extensions)
  * will skip all protocol checks and be given directly to the listener for processing.
  */
+@UnstableApi
 public interface Http2ConnectionDecoder extends Closeable {
 
     /**
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionEncoder.java
index edb1a1d1752c..4b76011a577c 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionEncoder.java
@@ -18,11 +18,13 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.util.internal.UnstableApi;
 
 
 /**
  * Handler for outbound HTTP/2 traffic.
  */
+@UnstableApi
 public interface Http2ConnectionEncoder extends Http2FrameWriter {
 
     /**
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
index e2beec359865..3ba341eb4567 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java
@@ -26,6 +26,7 @@
 import io.netty.handler.codec.http2.Http2Exception.StreamException;
 import io.netty.util.concurrent.ScheduledFuture;
 import io.netty.util.internal.OneTimeTask;
+import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -58,6 +59,7 @@
  * This interface enforces inbound flow control functionality through
  * {@link Http2LocalFlowController}
  */
+@UnstableApi
 public class Http2ConnectionHandler extends ByteToMessageDecoder implements Http2LifecycleManager,
                                                                             ChannelOutboundHandler {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandlerBuilder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandlerBuilder.java
index e5590c16f943..9db97335a32b 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandlerBuilder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandlerBuilder.java
@@ -17,10 +17,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.http2.Http2HeadersEncoder.SensitivityDetector;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Builder which builds {@link Http2ConnectionHandler} objects.
  */
+@UnstableApi
 public final class Http2ConnectionHandlerBuilder
         extends AbstractHttp2ConnectionHandlerBuilder<Http2ConnectionHandler, Http2ConnectionHandlerBuilder> {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataFrame.java
index 9e6cd855c4b6..f9bfd7c85f36 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataFrame.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * HTTP/2 DATA frame.
  */
+@UnstableApi
 public interface Http2DataFrame extends Http2StreamFrame, ByteBufHolder {
     @Override
     Http2DataFrame setStream(Object stream);
@@ -47,6 +49,12 @@ public interface Http2DataFrame extends Http2StreamFrame, ByteBufHolder {
     @Override
     Http2DataFrame duplicate();
 
+    @Override
+    Http2DataFrame retainedDuplicate();
+
+    @Override
+    Http2DataFrame replace(ByteBuf content);
+
     @Override
     Http2DataFrame retain();
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataWriter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataWriter.java
index ac2b4564a87d..911e336220df 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataWriter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2DataWriter.java
@@ -18,10 +18,12 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Interface that defines an object capable of producing HTTP/2 data frames.
  */
+@UnstableApi
 public interface Http2DataWriter {
     /**
      * Writes a {@code DATA} frame to the remote endpoint. This will result in one or more
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Error.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Error.java
index 3b0eeb759ef3..d43e5a376d53 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Error.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Error.java
@@ -15,9 +15,12 @@
 
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * All error codes identified by the HTTP/2 spec.
  */
+@UnstableApi
 public enum Http2Error {
     NO_ERROR(0x0),
     PROTOCOL_ERROR(0x1),
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2EventAdapter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2EventAdapter.java
index 9cbd6d0dba67..3f5665a40ebf 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2EventAdapter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2EventAdapter.java
@@ -16,11 +16,13 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * This class brings {@link Http2Connection.Listener} and {@link Http2FrameListener} together to provide
  * NOOP implementation so inheriting classes can selectively choose which methods to override.
  */
+@UnstableApi
 public class Http2EventAdapter implements Http2Connection.Listener, Http2FrameListener {
     @Override
     public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java
index 4bf4d7693641..2b4a0a606000 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java
@@ -15,6 +15,8 @@
 
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -25,6 +27,7 @@
 /**
  * Exception thrown when an HTTP/2 error was encountered.
  */
+@UnstableApi
 public class Http2Exception extends Exception {
     private static final long serialVersionUID = -6941186345430164209L;
     private final Http2Error error;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Flags.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Flags.java
index c3dd8a44ff86..88ae60764d81 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Flags.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Flags.java
@@ -15,9 +15,12 @@
 
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Provides utility methods for accessing specific flags as defined by the HTTP/2 spec.
  */
+@UnstableApi
 public final class Http2Flags {
     public static final short END_STREAM = 0x1;
     public static final short END_HEADERS = 0x4;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FlowController.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FlowController.java
index 1fc17892337a..25a0f68e078c 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FlowController.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FlowController.java
@@ -15,10 +15,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Base interface for all HTTP/2 flow controllers.
  */
+@UnstableApi
 public interface Http2FlowController {
     /**
      * Set the {@link ChannelHandlerContext} for which to apply flow control on.
@@ -54,13 +56,6 @@ public interface Http2FlowController {
      */
     int windowSize(Http2Stream stream);
 
-    /**
-     * Get the initial flow control window size for the given stream. This quantity is measured in number of bytes. Note
-     * the unavailable window portion can be calculated by {@link #initialWindowSize()} - {@link
-     * #windowSize(Http2Stream)}.
-     */
-    int initialWindowSize(Http2Stream stream);
-
     /**
      * Increments the size of the stream's flow control window by the given delta.
      * <p>
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Frame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Frame.java
index d27fe5c0e2a9..f93839236f8b 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Frame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Frame.java
@@ -15,5 +15,8 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /** An HTTP/2 frame. */
+@UnstableApi
 public interface Http2Frame { }
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameAdapter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameAdapter.java
index 62204b179e4a..f9346ecf080b 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameAdapter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameAdapter.java
@@ -16,10 +16,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Convenience class that provides no-op implementations for all methods of {@link Http2FrameListener}.
  */
+@UnstableApi
 public class Http2FrameAdapter implements Http2FrameListener {
 
     @Override
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListener.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListener.java
index b96f13d3260a..39d51f387767 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListener.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListener.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * An listener of HTTP/2 frames.
  */
+@UnstableApi
 public interface Http2FrameListener {
     /**
      * Handles an inbound {@code DATA} frame.
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListenerDecorator.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListenerDecorator.java
index 9b4106302784..203ee3fbaf24 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListenerDecorator.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameListenerDecorator.java
@@ -17,10 +17,12 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Provides a decorator around a {@link Http2FrameListener} and delegates all method calls
  */
+@UnstableApi
 public class Http2FrameListenerDecorator implements Http2FrameListener {
     protected final Http2FrameListener listener;
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java
index d09d5cfc2cbb..c8c1cd865dbf 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java
@@ -22,6 +22,7 @@
 import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.logging.LogLevel;
+import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogLevel;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -29,6 +30,7 @@
 /**
  * Logs HTTP2 frames for debugging purposes.
  */
+@UnstableApi
 public class Http2FrameLogger extends ChannelHandlerAdapter {
 
     public enum Direction {
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameReader.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameReader.java
index b1bd4ca4ad8e..f7d181af39bd 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameReader.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameReader.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 import java.io.Closeable;
 
@@ -24,6 +25,7 @@
  * Reads HTTP/2 frames from an input {@link ByteBuf} and notifies the specified
  * {@link Http2FrameListener} when frames are complete.
  */
+@UnstableApi
 public interface Http2FrameReader extends Closeable {
     /**
      * Configuration specific to {@link Http2FrameReader}
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameSizePolicy.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameSizePolicy.java
index ddfee362eb38..7c8841bcabc2 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameSizePolicy.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameSizePolicy.java
@@ -14,6 +14,9 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
+@UnstableApi
 public interface Http2FrameSizePolicy {
     /**
      * Sets the maximum allowed frame size. Attempts to write frames longer than this maximum will fail.
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameTypes.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameTypes.java
index 7b95e5e0547a..a9512a7c31d7 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameTypes.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameTypes.java
@@ -15,9 +15,12 @@
 
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Registry of all standard frame types defined by the HTTP/2 specification.
  */
+@UnstableApi
 public final class Http2FrameTypes {
     public static final byte DATA = 0x0;
     public static final byte HEADERS = 0x1;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameWriter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameWriter.java
index 43c8dec9f969..48fd7d58df31 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameWriter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameWriter.java
@@ -19,6 +19,7 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.util.internal.UnstableApi;
 
 import java.io.Closeable;
 
@@ -27,6 +28,7 @@
  * this interface write to the context, but DO NOT FLUSH. To perform a flush, you must separately
  * call {@link ChannelHandlerContext#flush()}.
  */
+@UnstableApi
 public interface Http2FrameWriter extends Http2DataWriter, Closeable {
     /**
      * Configuration specific to {@link Http2FrameWriter}
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2GoAwayFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2GoAwayFrame.java
index 01a7001f6def..f959dc93691a 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2GoAwayFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2GoAwayFrame.java
@@ -17,11 +17,13 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * HTTP/2 GOAWAY frame. Last-Stream-Id is not exposed directly, but instead via the relative {@link
  * #extraStreamIds()}.
  */
+@UnstableApi
 public interface Http2GoAwayFrame extends Http2Frame, ByteBufHolder {
     /**
      * The reason for beginning closure of the connection. Represented as an HTTP/2 error code.
@@ -56,6 +58,12 @@ public interface Http2GoAwayFrame extends Http2Frame, ByteBufHolder {
     @Override
     Http2GoAwayFrame duplicate();
 
+    @Override
+    Http2GoAwayFrame retainedDuplicate();
+
+    @Override
+    Http2GoAwayFrame replace(ByteBuf content);
+
     @Override
     Http2GoAwayFrame retain();
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeaderTable.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeaderTable.java
index a28bb5b6749d..b9636471db1c 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeaderTable.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeaderTable.java
@@ -14,9 +14,12 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Extracts a common interface for encoding and processing HPACK header constraints
  */
+@UnstableApi
 public interface Http2HeaderTable {
     /**
      * Sets the maximum size of the HPACK header table used for decoding HTTP/2 headers.
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java
index 3c84716d15c8..b4b21926f4ba 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java
@@ -17,6 +17,7 @@
 
 import io.netty.handler.codec.Headers;
 import io.netty.util.AsciiString;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.Iterator;
 import java.util.Map.Entry;
@@ -24,6 +25,7 @@
 /**
  * A collection of headers sent or received via HTTP/2.
  */
+@UnstableApi
 public interface Http2Headers extends Headers<CharSequence, CharSequence, Http2Headers> {
 
     /**
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersDecoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersDecoder.java
index 098e46a1d6fe..485e1478ce08 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersDecoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersDecoder.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Decodes HPACK-encoded headers blocks into {@link Http2Headers}.
  */
+@UnstableApi
 public interface Http2HeadersDecoder {
     /**
      * Configuration related elements for the {@link Http2HeadersDecoder} interface
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java
index ad60d301abdc..8e6dd9cc0096 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Encodes {@link Http2Headers} into HPACK-encoded headers blocks.
  */
+@UnstableApi
 public interface Http2HeadersEncoder {
     /**
      * Configuration related elements for the {@link Http2HeadersEncoder} interface
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersFrame.java
index 392780ada44b..e352b3a141d5 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersFrame.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * HTTP/2 HEADERS frame.
  */
+@UnstableApi
 public interface Http2HeadersFrame extends Http2StreamFrame {
     @Override
     Http2HeadersFrame setStream(Object stream);
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2InboundFrameLogger.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2InboundFrameLogger.java
index 65c684ce3c89..395eeadd5c71 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2InboundFrameLogger.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2InboundFrameLogger.java
@@ -19,11 +19,13 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Decorator around a {@link Http2FrameReader} that logs all inbound frames before calling
  * back the listener.
  */
+@UnstableApi
 public class Http2InboundFrameLogger implements Http2FrameReader {
     private final Http2FrameReader reader;
     private final Http2FrameLogger logger;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java
index c815efa905aa..44cbf2aed7a7 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java
@@ -18,11 +18,13 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Manager for the life cycle of the HTTP/2 connection. Handles graceful shutdown of the channel,
  * closing only after all of the streams have closed.
  */
+@UnstableApi
 public interface Http2LifecycleManager {
 
     /**
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java
index 25e6b4d9b3a7..a3b2bc6ceef5 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java
@@ -15,10 +15,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link Http2FlowController} for controlling the inbound flow of {@code DATA} frames from the remote endpoint.
  */
+@UnstableApi
 public interface Http2LocalFlowController extends Http2FlowController {
     /**
      * Sets the writer to be use for sending {@code WINDOW_UPDATE} frames. This must be called before any flow
@@ -74,4 +76,11 @@ void receiveFlowControlledFrame(Http2Stream stream, ByteBuf data, int padding,
      * @return the number of unconsumed bytes for the stream.
      */
     int unconsumedBytes(Http2Stream stream);
+
+    /**
+     * Get the initial flow control window size for the given stream. This quantity is measured in number of bytes. Note
+     * the unavailable window portion can be calculated by {@link #initialWindowSize()} - {@link
+     * #windowSize(Http2Stream)}.
+     */
+    int initialWindowSize(Http2Stream stream);
 }
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
index 5ab86439c1c4..21e57f495431 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java
@@ -24,8 +24,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerInvoker;
-import io.netty.channel.ChannelHandlerInvokerUtil;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
@@ -34,6 +32,7 @@
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.internal.OneTimeTask;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -71,6 +70,7 @@
  * <p>{@link ChannelConfig#setMaxMessagesPerRead(int)} and {@link
  * ChannelConfig#setAutoRead(boolean)} are supported.
  */
+@UnstableApi
 public final class Http2MultiplexCodec extends ChannelDuplexHandler {
     private static final Http2FrameLogger HTTP2_FRAME_LOGGER = new Http2FrameLogger(INFO, Http2MultiplexCodec.class);
 
@@ -81,6 +81,7 @@ public final class Http2MultiplexCodec extends ChannelDuplexHandler {
     private final List<StreamInfo> streamsToFireChildReadComplete = new ArrayList<StreamInfo>();
     private ChannelHandlerContext ctx;
     private ChannelHandlerContext http2HandlerCtx;
+    private volatile Runnable flushTask;
 
     /**
      * Construct a new handler whose child channels run in the same event loop as this handler.
@@ -174,15 +175,74 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
         }
     }
 
+    // Override this to signal it will never throw an exception.
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        ctx.fireExceptionCaught(cause);
+    }
+
+    // Override this to signal it will never throw an exception.
+    @Override
+    public void flush(ChannelHandlerContext ctx) {
+        ctx.flush();
+    }
+
+    void flushFromStreamChannel() {
+        EventExecutor executor = ctx.executor();
+        if (executor.inEventLoop()) {
+            flush(ctx);
+        } else {
+            Runnable task = flushTask;
+            if (task == null) {
+                task = flushTask = new Runnable() {
+                    @Override
+                    public void run() {
+                        flush(ctx);
+                    }
+                };
+            }
+            executor.execute(task);
+        }
+    }
+
+    void writeFromStreamChannel(final Object msg, final boolean flush) {
+        final ChannelPromise promise = ctx.newPromise();
+        EventExecutor executor = ctx.executor();
+        if (executor.inEventLoop()) {
+            writeFromStreamChannel0(msg, flush, promise);
+        } else {
+            try {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        writeFromStreamChannel0(msg, flush, promise);
+                    }
+                });
+            } catch (Throwable cause) {
+                promise.setFailure(cause);
+            }
+        }
+    }
+
+    private void writeFromStreamChannel0(Object msg, boolean flush, ChannelPromise promise) {
+        try {
+            write(ctx, msg, promise);
+        } catch (Throwable cause) {
+            promise.tryFailure(cause);
+        }
+        if (flush) {
+            flush(ctx);
+        }
+    }
+
     /**
      * Processes all {@link Http2Frame}s. {@link Http2StreamFrame}s may only originate in child
      * streams.
      */
     @Override
-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
-            throws Exception {
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
         if (!(msg instanceof Http2Frame)) {
-            super.write(ctx, msg, promise);
+            ctx.write(msg, promise);
             return;
         }
         try {
@@ -278,7 +338,7 @@ public void onStreamActive(Http2Stream stream) {
 
         @Override
         public void onStreamClosed(Http2Stream stream) {
-            final StreamInfo streamInfo = (StreamInfo) stream.getProperty(streamInfoKey);
+            final StreamInfo streamInfo = stream.getProperty(streamInfoKey);
             if (streamInfo != null) {
                 final EventLoop eventLoop = streamInfo.childChannel.eventLoop();
                 if (eventLoop.inEventLoop()) {
@@ -311,20 +371,30 @@ public boolean visit(Http2Stream stream) {
                             StreamInfo streamInfo = (StreamInfo) stream.getProperty(streamInfoKey);
                             // TODO: Can we force a user interaction pattern that doesn't require us to duplicate()?
                             // https://github.com/netty/netty/issues/4943
-                            streamInfo.childChannel.pipeline().fireUserEventTriggered(goAway.duplicate().retain());
+                            streamInfo.childChannel.pipeline().fireUserEventTriggered(goAway.retainedDuplicate());
                         }
                         return true;
                     }
                 });
-            } catch (Throwable t) {
-                ctx.invoker().invokeExceptionCaught(ctx, t);
+            } catch (final Throwable t) {
+                EventExecutor executor = ctx.executor();
+                if (executor.inEventLoop()) {
+                    exceptionCaught(ctx, t);
+                } else {
+                    executor.execute(new OneTimeTask() {
+                        @Override
+                        public void run() {
+                            exceptionCaught(ctx, t);
+                        }
+                    });
+                }
             }
-            ctx.fireUserEventTriggered(goAway.duplicate().retain());
+            ctx.fireUserEventTriggered(goAway.retainedDuplicate());
         }
     }
 
     class InternalHttp2ConnectionHandler extends Http2ConnectionHandler {
-        public InternalHttp2ConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,
+        InternalHttp2ConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,
                 Http2Settings initialSettings) {
             super(decoder, encoder, initialSettings);
         }
@@ -337,7 +407,7 @@ protected void onStreamError(ChannelHandlerContext ctx, Throwable cause,
                 if (stream == null) {
                     return;
                 }
-                StreamInfo streamInfo = (StreamInfo) stream.getProperty(streamInfoKey);
+                StreamInfo streamInfo = stream.getProperty(streamInfoKey);
                 if (streamInfo == null) {
                     return;
                 }
@@ -353,7 +423,7 @@ class FrameListener extends Http2FrameAdapter {
         public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode)
                 throws Http2Exception {
             Http2Stream stream = http2Handler.connection().stream(streamId);
-            StreamInfo streamInfo = (StreamInfo) stream.getProperty(streamInfoKey);
+            StreamInfo streamInfo = stream.getProperty(streamInfoKey);
             // Use a user event in order to circumvent read queue.
             streamInfo.childChannel.pipeline().fireUserEventTriggered(new DefaultHttp2ResetFrame(errorCode));
         }
@@ -369,7 +439,7 @@ public void onHeadersRead(ChannelHandlerContext ctx, int streamId,
         public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers,
                 int padding, boolean endOfStream) throws Http2Exception {
             Http2Stream stream = http2Handler.connection().stream(streamId);
-            StreamInfo streamInfo = (StreamInfo) stream.getProperty(streamInfoKey);
+            StreamInfo streamInfo = stream.getProperty(streamInfoKey);
             fireChildReadAndRegister(streamInfo, new DefaultHttp2HeadersFrame(headers, endOfStream, padding));
         }
 
@@ -377,7 +447,7 @@ public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers
         public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,
                 boolean endOfStream) throws Http2Exception {
             Http2Stream stream = http2Handler.connection().stream(streamId);
-            StreamInfo streamInfo = (StreamInfo) stream.getProperty(streamInfoKey);
+            StreamInfo streamInfo = stream.getProperty(streamInfoKey);
             fireChildReadAndRegister(streamInfo, new DefaultHttp2DataFrame(data.retain(), endOfStream, padding));
             // We return the bytes in bytesConsumed() once the stream channel consumed the bytes.
             return 0;
@@ -387,7 +457,7 @@ public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int
     static final class StreamInfo {
         final Http2StreamChannel childChannel;
         /**
-         * {@code true} if stream is in {@link Http2MultiplexCodec#steamsToFireChildReadComplete}.
+         * {@code true} if stream is in {@link Http2MultiplexCodec#streamsToFireChildReadComplete}.
          */
         boolean inStreamsToFireChildReadComplete;
 
@@ -411,9 +481,7 @@ final class Http2StreamChannel extends AbstractHttp2StreamChannel {
         protected void doClose() throws Exception {
             if (!onStreamClosedFired) {
                 Http2StreamFrame resetFrame = new DefaultHttp2ResetFrame(Http2Error.CANCEL).setStream(this);
-                ChannelHandlerInvoker invoker = ctx.invoker();
-                invoker.invokeWrite(ctx, resetFrame, ctx.newPromise());
-                invoker.invokeFlush(ctx);
+                writeFromStreamChannel(resetFrame, true);
             }
             super.doClose();
         }
@@ -430,12 +498,13 @@ protected void doWrite(Object msg) {
                 throw new IllegalArgumentException("Stream must be null on the frame");
             }
             frame.setStream(this);
-            ctx.invoker().invokeWrite(ctx, frame, ctx.newPromise());
+
+            writeFromStreamChannel(msg, false);
         }
 
         @Override
         protected void doWriteComplete() {
-            ctx.invoker().invokeFlush(ctx);
+            flushFromStreamChannel();
         }
 
         @Override
@@ -462,7 +531,7 @@ private void bytesConsumed0(int bytes) {
             try {
                 http2Handler.connection().local().flowController().consumeBytes(stream, bytes);
             } catch (Throwable t) {
-                ChannelHandlerInvokerUtil.invokeExceptionCaughtNow(ctx, t);
+                exceptionCaught(ctx, t);
             }
         }
     }
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2NoMoreStreamIdsException.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2NoMoreStreamIdsException.java
index d10e87c780df..b003d5dbc459 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2NoMoreStreamIdsException.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2NoMoreStreamIdsException.java
@@ -14,11 +14,14 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 
 /**
  * This exception is thrown when there are no more stream IDs available for the current connection
  */
+@UnstableApi
 public class Http2NoMoreStreamIdsException extends Http2Exception {
     private static final long serialVersionUID = -7756236161274851110L;
     private static final String ERROR_MESSAGE = "No more streams can be created on this connection";
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java
index c2430f66ab71..5803113292df 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java
@@ -21,11 +21,13 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Decorator around a {@link Http2FrameWriter} that logs all outbound frames before calling the
  * writer.
  */
+@UnstableApi
 public class Http2OutboundFrameLogger implements Http2FrameWriter {
     private final Http2FrameWriter writer;
     private final Http2FrameLogger logger;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PromisedRequestVerifier.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PromisedRequestVerifier.java
index 927781f910ac..43b8f078c2cf 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PromisedRequestVerifier.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2PromisedRequestVerifier.java
@@ -15,11 +15,13 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Provides an extensibility point for users to define the validity of push requests.
  * @see <a href="https://tools.ietf.org/html/draft-ietf-httpbis-http2-17#section-8.2">[RFC http2], Section 8.2</a>.
  */
+@UnstableApi
 public interface Http2PromisedRequestVerifier {
     /**
      * Determine if a {@link Http2Headers} are authoritative for a particular {@link ChannelHandlerContext}.
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2RemoteFlowController.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2RemoteFlowController.java
index b586c1671055..1ba48bebe52a 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2RemoteFlowController.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2RemoteFlowController.java
@@ -15,11 +15,13 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link Http2FlowController} for controlling the flow of outbound {@code DATA} frames to the remote
  * endpoint.
  */
+@UnstableApi
 public interface Http2RemoteFlowController extends Http2FlowController {
     /**
      * Get the {@link ChannelHandlerContext} for which to apply flow control on.
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ResetFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ResetFrame.java
index 3a818f34568c..52d435336e10 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ResetFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ResetFrame.java
@@ -15,7 +15,10 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /** HTTP/2 RST_STREAM frame. */
+@UnstableApi
 public interface Http2ResetFrame extends Http2StreamFrame {
     @Override
     Http2ResetFrame setStream(Object stream);
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java
index 1c20bfded4cd..2ddd16f63ce8 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -23,6 +25,7 @@
 /**
  * Provides utilities related to security requirements specific to HTTP/2.
  */
+@UnstableApi
 public final class Http2SecurityUtil {
     /**
      * The following list is derived from <a
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerDowngrader.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerDowngrader.java
new file mode 100644
index 000000000000..2f0aecc3b826
--- /dev/null
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerDowngrader.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.http2;
+
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageCodec;
+import io.netty.handler.codec.http.DefaultHttpContent;
+import io.netty.handler.codec.http.DefaultLastHttpContent;
+import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.internal.UnstableApi;
+
+import java.util.List;
+
+/**
+ * This is a server-side adapter so that an http2 codec can be downgraded to
+ * appear as if it's speaking http/1.1.
+ *
+ * In particular, this handler converts from {@link Http2StreamFrame} to {@link
+ * HttpObject}, and back.  For simplicity, it converts to chunked encoding
+ * unless the entire stream is a single header.
+ */
+@UnstableApi
+public class Http2ServerDowngrader extends MessageToMessageCodec<Http2StreamFrame, HttpObject> {
+
+    private final boolean validateHeaders;
+
+    public Http2ServerDowngrader(boolean validateHeaders) {
+        this.validateHeaders = validateHeaders;
+    }
+
+    public Http2ServerDowngrader() {
+        this(true);
+    }
+
+    @Override
+    public boolean acceptInboundMessage(Object msg) throws Exception {
+        return (msg instanceof Http2HeadersFrame) || (msg instanceof Http2DataFrame);
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, Http2StreamFrame frame, List<Object> out) throws Exception {
+        if (frame instanceof Http2HeadersFrame) {
+            int id = 0; // not really the id
+            Http2HeadersFrame headersFrame = (Http2HeadersFrame) frame;
+            Http2Headers headers = headersFrame.headers();
+
+            if (headersFrame.isEndStream()) {
+                if (headers.method() == null) {
+                    LastHttpContent last = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);
+                    HttpConversionUtil.addHttp2ToHttpHeaders(id, headers, last.trailingHeaders(),
+                                                             HttpVersion.HTTP_1_1, true, true);
+                    out.add(last);
+                } else {
+                    FullHttpRequest full = HttpConversionUtil.toFullHttpRequest(id, headers, ctx.alloc(),
+                            validateHeaders);
+                    out.add(full);
+                }
+            } else {
+                out.add(HttpConversionUtil.toHttpRequest(id, headersFrame.headers(), validateHeaders));
+            }
+
+        } else if (frame instanceof Http2DataFrame) {
+            Http2DataFrame dataFrame = (Http2DataFrame) frame;
+            if (dataFrame.isEndStream()) {
+                out.add(new DefaultLastHttpContent(dataFrame.content(), validateHeaders));
+            } else {
+                out.add(new DefaultHttpContent(dataFrame.content()));
+            }
+        }
+        ReferenceCountUtil.retain(frame);
+    }
+
+    private void encodeLastContent(LastHttpContent last, List<Object> out) {
+        boolean needFiller = !(last instanceof FullHttpResponse) && last.trailingHeaders().isEmpty();
+        if (last.content().isReadable() || needFiller) {
+            out.add(new DefaultHttp2DataFrame(last.content(), last.trailingHeaders().isEmpty()));
+        }
+        if (!last.trailingHeaders().isEmpty()) {
+            Http2Headers headers = HttpConversionUtil.toHttp2Headers(last.trailingHeaders(), validateHeaders);
+            out.add(new DefaultHttp2HeadersFrame(headers, true));
+        }
+    }
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, HttpObject obj, List<Object> out) throws Exception {
+        if (obj instanceof HttpResponse) {
+            Http2Headers headers = HttpConversionUtil.toHttp2Headers((HttpResponse) obj, validateHeaders);
+            boolean noMoreFrames = false;
+            if (obj instanceof FullHttpResponse) {
+                FullHttpResponse full = (FullHttpResponse) obj;
+                noMoreFrames = !full.content().isReadable() && full.trailingHeaders().isEmpty();
+            }
+
+            out.add(new DefaultHttp2HeadersFrame(headers, noMoreFrames));
+        }
+
+        if (obj instanceof LastHttpContent) {
+            LastHttpContent last = (LastHttpContent) obj;
+            encodeLastContent(last, out);
+        } else if (obj instanceof HttpContent) {
+            HttpContent cont = (HttpContent) obj;
+            out.add(new DefaultHttp2DataFrame(cont.content(), false));
+        }
+        ReferenceCountUtil.retain(obj);
+    }
+}
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java
index 66f4faee6b7f..3e0e0d6c6d63 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpServerUpgradeHandler;
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -42,6 +43,7 @@
 /**
  * Server-side codec for performing a cleartext upgrade from HTTP/1.x to HTTP/2.
  */
+@UnstableApi
 public class Http2ServerUpgradeCodec implements HttpServerUpgradeHandler.UpgradeCodec {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(Http2ServerUpgradeCodec.class);
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Settings.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Settings.java
index da719e4bca81..396959420575 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Settings.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Settings.java
@@ -34,12 +34,14 @@
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 import io.netty.util.collection.CharObjectHashMap;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Settings for one endpoint in an HTTP/2 connection. Each of the values are optional as defined in
  * the spec for the SETTINGS frame. Permits storage of arbitrary key/value pairs but provides helper
  * methods for standard settings.
  */
+@UnstableApi
 public final class Http2Settings extends CharObjectHashMap<Long> {
     /**
      * Default capacity based on the number of standard settings from the HTTP/2 spec, adjusted so that adding all of
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java
index 0ac0c36b389a..77e8d2bf68f1 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java
@@ -15,9 +15,12 @@
 
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * A single stream within an HTTP2 connection. Streams are compared to each other by priority.
  */
+@UnstableApi
 public interface Http2Stream {
 
     /**
@@ -163,13 +166,6 @@ public boolean remoteSideOpen() {
      */
     Http2Stream parent();
 
-    /**
-     * Get the number of streams in the priority tree rooted at this node that are OK to exist in the priority
-     * tree on their own right. Some streams may be in the priority tree because their dependents require them to
-     * remain.
-     */
-    int prioritizableForTree();
-
     /**
      * Indicates whether or not this stream is a descendant in the priority tree from the given stream.
      */
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrame.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrame.java
index df34d7e3f7b4..380d4bbbc31a 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrame.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrame.java
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * A frame whose meaning <em>may</em> apply to a particular stream, instead of the entire
  * connection. It is still possibly for this frame type to apply to the entire connection. In such
@@ -24,6 +26,7 @@
  * <p>The meaning of {@code stream} is context-dependent and may change as a frame is processed in
  * the pipeline.
  */
+@UnstableApi
 public interface Http2StreamFrame extends Http2Frame {
     /**
      * Set the stream identifier for this message.
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamVisitor.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamVisitor.java
index ec2a1e5e1e00..a09a20cd03d8 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamVisitor.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamVisitor.java
@@ -14,9 +14,12 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * A visitor that allows iteration over a collection of streams.
  */
+@UnstableApi
 public interface Http2StreamVisitor {
     /**
      * @return <ul>
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java
index 80bac5eec750..056aafc92ee9 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java
@@ -17,6 +17,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.FullHttpMessage;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -31,6 +32,7 @@
 import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.util.AsciiString;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.URI;
 import java.util.Iterator;
@@ -52,6 +54,7 @@
 /**
  * Provides utility methods and constants for the HTTP/2 to HTTP conversion
  */
+@UnstableApi
 public final class HttpConversionUtil {
     /**
      * The set of headers that should not be directly copied when converting headers from HTTP to HTTP/2.
@@ -228,7 +231,7 @@ public static FullHttpResponse toHttpResponse(int streamId, Http2Headers http2He
      * @return A new request object which represents headers/data
      * @throws Http2Exception see {@link #addHttp2ToHttpHeaders(int, Http2Headers, FullHttpMessage, boolean)}
      */
-    public static FullHttpRequest toHttpRequest(int streamId, Http2Headers http2Headers, ByteBufAllocator alloc,
+    public static FullHttpRequest toFullHttpRequest(int streamId, Http2Headers http2Headers, ByteBufAllocator alloc,
                                                 boolean validateHttpHeaders)
                     throws Http2Exception {
         // HTTP/2 does not define a way to carry the version identifier that is included in the HTTP/1.1 request line.
@@ -250,6 +253,37 @@ public static FullHttpRequest toHttpRequest(int streamId, Http2Headers http2Head
         return msg;
     }
 
+    /**
+     * Create a new object to contain the request data.
+     *
+     * @param streamId The stream associated with the request
+     * @param http2Headers The initial set of HTTP/2 headers to create the request with
+     * @param validateHttpHeaders <ul>
+     *        <li>{@code true} to validate HTTP headers in the http-codec</li>
+     *        <li>{@code false} not to validate HTTP headers in the http-codec</li>
+     *        </ul>
+     * @return A new request object which represents headers for a chunked request
+     * @throws Http2Exception see {@link #addHttp2ToHttpHeaders(int, Http2Headers, FullHttpMessage, boolean)}
+     */
+    public static HttpRequest toHttpRequest(int streamId, Http2Headers http2Headers, boolean validateHttpHeaders)
+                    throws Http2Exception {
+        // HTTP/2 does not define a way to carry the version identifier that is included in the HTTP/1.1 request line.
+        final CharSequence method = checkNotNull(http2Headers.method(),
+                "method header cannot be null in conversion to HTTP/1.x");
+        final CharSequence path = checkNotNull(http2Headers.path(),
+                "path header cannot be null in conversion to HTTP/1.x");
+        HttpRequest msg = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.valueOf(method.toString()),
+                path.toString(), validateHttpHeaders);
+        try {
+            addHttp2ToHttpHeaders(streamId, http2Headers, msg.headers(), msg.protocolVersion(), false, true);
+        } catch (Http2Exception e) {
+            throw e;
+        } catch (Throwable t) {
+            throw streamError(streamId, PROTOCOL_ERROR, t, "HTTP/2 to HTTP/1.x headers conversion error");
+        }
+        return msg;
+    }
+
     /**
      * Translate and add HTTP/2 headers to HTTP/1.x headers.
      *
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
index 52ca74dfcdd4..3a8afaec48a2 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java
@@ -25,12 +25,14 @@
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;
 import io.netty.util.ReferenceCountUtil;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Translates HTTP/1.x object writes into HTTP/2 frames.
  * <p>
  * See {@link InboundHttp2ToHttpAdapter} to get translation from HTTP/2 frames to HTTP/1.x objects.
  */
+@UnstableApi
 public class HttpToHttp2ConnectionHandler extends Http2ConnectionHandler {
 
     private final boolean validateHeaders;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerBuilder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerBuilder.java
index 569455a48ea1..635e780d9874 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerBuilder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerBuilder.java
@@ -17,10 +17,12 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.http2.Http2HeadersEncoder.SensitivityDetector;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Builder which builds {@link HttpToHttp2ConnectionHandler} objects.
  */
+@UnstableApi
 public final class HttpToHttp2ConnectionHandlerBuilder extends
         AbstractHttp2ConnectionHandlerBuilder<HttpToHttp2ConnectionHandler, HttpToHttp2ConnectionHandlerBuilder> {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
index 68c912aa7c1e..a71bd7a08083 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java
@@ -16,6 +16,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http.FullHttpMessage;
 import io.netty.handler.codec.http.FullHttpRequest;
@@ -23,6 +24,7 @@
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpStatusClass;
 import io.netty.handler.codec.http.HttpUtil;
+import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
@@ -35,6 +37,7 @@
  * <p>
  * See {@link HttpToHttp2ConnectionHandler} to get translation from HTTP/1.x objects to HTTP/2 frames for writes.
  */
+@UnstableApi
 public class InboundHttp2ToHttpAdapter extends Http2EventAdapter {
     private static final ImmediateSendDetector DEFAULT_SEND_DETECTOR = new ImmediateSendDetector() {
         @Override
@@ -51,7 +54,7 @@ public boolean mustSendImmediately(FullHttpMessage msg) {
         @Override
         public FullHttpMessage copyIfNeeded(FullHttpMessage msg) {
             if (msg instanceof FullHttpRequest) {
-                FullHttpRequest copy = ((FullHttpRequest) msg).copy(null);
+                FullHttpRequest copy = ((FullHttpRequest) msg).replace(Unpooled.buffer(0));
                 copy.headers().remove(HttpHeaderNames.EXPECT);
                 return copy;
             }
@@ -150,7 +153,7 @@ protected void fireChannelRead(ChannelHandlerContext ctx, FullHttpMessage msg, b
     protected FullHttpMessage newMessage(Http2Stream stream, Http2Headers headers, boolean validateHttpHeaders,
                                          ByteBufAllocator alloc)
             throws Http2Exception {
-        return connection.isServer() ? HttpConversionUtil.toHttpRequest(stream.id(), headers, alloc,
+        return connection.isServer() ? HttpConversionUtil.toFullHttpRequest(stream.id(), headers, alloc,
                 validateHttpHeaders) : HttpConversionUtil.toHttpResponse(stream.id(), headers, alloc,
                                                                          validateHttpHeaders);
     }
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterBuilder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterBuilder.java
index 0cdd84bb14ee..1d9cdae058f0 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterBuilder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterBuilder.java
@@ -14,9 +14,12 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Builds an {@link InboundHttp2ToHttpAdapter}.
  */
+@UnstableApi
 public final class InboundHttp2ToHttpAdapterBuilder
         extends AbstractInboundHttp2ToHttpAdapterBuilder<InboundHttp2ToHttpAdapter, InboundHttp2ToHttpAdapterBuilder> {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapter.java
index a88d72c9895e..ecec713df68d 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapter.java
@@ -19,6 +19,7 @@
 import io.netty.handler.codec.http.FullHttpMessage;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.util.AsciiString;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.Iterator;
 import java.util.Map.Entry;
@@ -32,6 +33,7 @@
  * generate multiple messages per stream because the chances of an HTTP/2 event happening outside
  * the header/data message flow is more likely.
  */
+@UnstableApi
 public final class InboundHttp2ToHttpPriorityAdapter extends InboundHttp2ToHttpAdapter {
     private static final AsciiString OUT_OF_MESSAGE_SEQUENCE_METHOD = new AsciiString(
             HttpConversionUtil.OUT_OF_MESSAGE_SEQUENCE_METHOD.toString());
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapterBuilder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapterBuilder.java
index 48575eae709c..fa3869f0db1f 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapterBuilder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpPriorityAdapterBuilder.java
@@ -14,9 +14,12 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Builds an {@link InboundHttp2ToHttpPriorityAdapter}.
  */
+@UnstableApi
 public final class InboundHttp2ToHttpPriorityAdapterBuilder
         extends AbstractInboundHttp2ToHttpAdapterBuilder<InboundHttp2ToHttpPriorityAdapter,
                                                          InboundHttp2ToHttpPriorityAdapterBuilder> {
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java
index 4cf2f004b5f7..26ace2d233a8 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java
@@ -20,10 +20,12 @@
 import io.netty.handler.codec.http.FullHttpMessage;
 import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpScheme;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Translates HTTP/1.x object reads into HTTP/2 frames.
  */
+@UnstableApi
 public class InboundHttpToHttp2Adapter extends ChannelInboundHandlerAdapter {
     private final Http2Connection connection;
     private final Http2FrameListener listener;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java
index cb36801585f0..f06864f503f5 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java
@@ -21,6 +21,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
 import io.netty.util.ReferenceCountUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayDeque;
 import java.util.Iterator;
@@ -50,6 +51,7 @@
  * drop-in decorator of {@link DefaultHttp2ConnectionEncoder}.
  * </p>
  */
+@UnstableApi
 public class StreamBufferingEncoder extends DecoratingHttp2ConnectionEncoder {
 
     /**
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java
index d882cf5d71df..c0c225426a4a 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java
@@ -15,10 +15,13 @@
 
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * An object (used by remote flow control) that is responsible for distributing the bytes to be
  * written across the streams in the connection.
  */
+@UnstableApi
 public interface StreamByteDistributor {
 
     /**
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java
index 42b864ce193e..091cd47645d3 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java
@@ -14,6 +14,8 @@
  */
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
+
 import java.util.ArrayDeque;
 import java.util.Deque;
 
@@ -30,6 +32,7 @@
  * fewer streams may be written to in each call to {@link #distribute(int, Writer)}, doing this
  * should improve the goodput on each written stream.
  */
+@UnstableApi
 public final class UniformStreamByteDistributor implements StreamByteDistributor {
     static final int DEFAULT_MIN_ALLOCATION_CHUNK = 1024;
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java
index c8b4c4b540f0..d0edc4e6bef3 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java
@@ -17,6 +17,7 @@
 import io.netty.util.internal.MathUtil;
 import io.netty.util.internal.PriorityQueue;
 import io.netty.util.internal.PriorityQueueNode;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.Queue;
 
@@ -41,6 +42,7 @@
  * Each write operation will use the {@link #allocationQuantum(int)} to know how many more bytes should be allocated
  * relative to the next stream which wants to write. This is to balance fairness while also considering goodput.
  */
+@UnstableApi
 public final class WeightedFairQueueByteDistributor implements StreamByteDistributor {
     private final Http2Connection.PropertyKey stateKey;
     private final State connectionState;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Decoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java
similarity index 95%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Decoder.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java
index 9b801f274511..08c10a1f66ed 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Decoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java
@@ -29,25 +29,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
-import io.netty.handler.codec.http2.hpack.HpackUtil.IndexType;
+import io.netty.handler.codec.http2.internal.hpack.HpackUtil.IndexType;
+import io.netty.util.internal.EmptyArrays;
 
 import java.io.IOException;
 import java.io.InputStream;
 
+import static io.netty.util.internal.EmptyArrays.EMPTY_BYTES;
+
 public final class Decoder {
 
     private static final IOException DECOMPRESSION_EXCEPTION =
-            new IOException("decompression failure");
+            new IOException("HPACK - decompression failure");
     private static final IOException ILLEGAL_INDEX_VALUE =
-            new IOException("illegal index value");
+            new IOException("HPACK - illegal index value");
     private static final IOException INVALID_MAX_DYNAMIC_TABLE_SIZE =
-            new IOException("invalid max dynamic table size");
+            new IOException("HPACK - invalid max dynamic table size");
     private static final IOException MAX_DYNAMIC_TABLE_SIZE_CHANGE_REQUIRED =
-            new IOException("max dynamic table size change required");
+            new IOException("HPACK - max dynamic table size change required");
 
-    private static final byte[] EMPTY = {};
+    static {
+        DECOMPRESSION_EXCEPTION.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+        ILLEGAL_INDEX_VALUE.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+        INVALID_MAX_DYNAMIC_TABLE_SIZE.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+        MAX_DYNAMIC_TABLE_SIZE_CHANGE_REQUIRED.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+    }
 
     private final DynamicTable dynamicTable;
 
@@ -214,17 +222,12 @@ public void decode(InputStream in, HeaderListener headerListener) throws IOExcep
                     } else {
                         nameLength = index;
 
-                        // Disallow empty names -- they cannot be represented in HTTP/1.x
-                        if (nameLength == 0) {
-                            throw DECOMPRESSION_EXCEPTION;
-                        }
-
                         // Check name length against max header size
                         if (exceedsMaxHeaderSize(nameLength)) {
 
                             if (indexType == IndexType.NONE) {
                                 // Name is unused so skip bytes
-                                name = EMPTY;
+                                name = EMPTY_BYTES;
                                 skipLength = nameLength;
                                 state = State.SKIP_LITERAL_HEADER_NAME;
                                 break;
@@ -233,7 +236,7 @@ public void decode(InputStream in, HeaderListener headerListener) throws IOExcep
                             // Check name length against max dynamic table size
                             if (nameLength + HeaderField.HEADER_ENTRY_OVERHEAD > dynamicTable.capacity()) {
                                 dynamicTable.clear();
-                                name = EMPTY;
+                                name = EMPTY_BYTES;
                                 skipLength = nameLength;
                                 state = State.SKIP_LITERAL_HEADER_NAME;
                                 break;
@@ -260,7 +263,7 @@ public void decode(InputStream in, HeaderListener headerListener) throws IOExcep
                     if (exceedsMaxHeaderSize(nameLength)) {
                         if (indexType == IndexType.NONE) {
                             // Name is unused so skip bytes
-                            name = EMPTY;
+                            name = EMPTY_BYTES;
                             skipLength = nameLength;
                             state = State.SKIP_LITERAL_HEADER_NAME;
                             break;
@@ -269,7 +272,7 @@ public void decode(InputStream in, HeaderListener headerListener) throws IOExcep
                         // Check name length against max dynamic table size
                         if (nameLength + HeaderField.HEADER_ENTRY_OVERHEAD > dynamicTable.capacity()) {
                             dynamicTable.clear();
-                            name = EMPTY;
+                            name = EMPTY_BYTES;
                             skipLength = nameLength;
                             state = State.SKIP_LITERAL_HEADER_NAME;
                             break;
@@ -327,7 +330,7 @@ public void decode(InputStream in, HeaderListener headerListener) throws IOExcep
                         }
 
                         if (valueLength == 0) {
-                            insertHeader(headerListener, name, EMPTY, indexType);
+                            insertHeader(headerListener, name, EMPTY_BYTES, indexType);
                             state = State.READ_HEADER_REPRESENTATION;
                         } else {
                             state = State.READ_LITERAL_HEADER_VALUE;
@@ -502,9 +505,6 @@ private void insertHeader(HeaderListener headerListener, byte[] name, byte[] val
 
     private void addHeader(HeaderListener headerListener, byte[] name, byte[] value,
                            boolean sensitive) {
-        if (name.length == 0) {
-            throw new AssertionError("name is empty");
-        }
         long newSize = headerSize + name.length + value.length;
         if (newSize <= maxHeaderSize) {
             headerListener.addHeader(name, value, sensitive);
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/DynamicTable.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/DynamicTable.java
similarity index 97%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/DynamicTable.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/DynamicTable.java
index 2c4457992cd4..a623b5b29a53 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/DynamicTable.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/DynamicTable.java
@@ -29,9 +29,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
-import static io.netty.handler.codec.http2.hpack.HeaderField.HEADER_ENTRY_OVERHEAD;
+import static io.netty.handler.codec.http2.internal.hpack.HeaderField.HEADER_ENTRY_OVERHEAD;
 
 final class DynamicTable {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Encoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java
similarity index 95%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Encoder.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java
index 079f5b76eeba..022ac2392ba4 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Encoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java
@@ -29,14 +29,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
-
-import io.netty.handler.codec.http2.hpack.HpackUtil.IndexType;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.Arrays;
 
+import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.IndexType.INCREMENTAL;
+import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.IndexType.NEVER;
+import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.IndexType.NONE;
+
 public final class Encoder {
 
     private static final int BUCKET_SIZE = 17;
@@ -88,7 +90,7 @@ public void encodeHeader(OutputStream out, byte[] name, byte[] value, boolean se
         // If the header value is sensitive then it must never be indexed
         if (sensitive) {
             int nameIndex = getNameIndex(name);
-            encodeLiteral(out, name, value, IndexType.NEVER, nameIndex);
+            encodeLiteral(out, name, value, NEVER, nameIndex);
             return;
         }
 
@@ -97,7 +99,7 @@ public void encodeHeader(OutputStream out, byte[] name, byte[] value, boolean se
             int staticTableIndex = StaticTable.getIndex(name, value);
             if (staticTableIndex == -1) {
                 int nameIndex = StaticTable.getIndex(name);
-                encodeLiteral(out, name, value, IndexType.NONE, nameIndex);
+                encodeLiteral(out, name, value, NONE, nameIndex);
             } else {
                 encodeInteger(out, 0x80, 7, staticTableIndex);
             }
@@ -109,7 +111,7 @@ public void encodeHeader(OutputStream out, byte[] name, byte[] value, boolean se
         // If the headerSize is greater than the max table size then it must be encoded literally
         if (headerSize > capacity) {
             int nameIndex = getNameIndex(name);
-            encodeLiteral(out, name, value, IndexType.NONE, nameIndex);
+            encodeLiteral(out, name, value, NONE, nameIndex);
             return;
         }
 
@@ -128,7 +130,8 @@ public void encodeHeader(OutputStream out, byte[] name, byte[] value, boolean se
                 if (useIndexing) {
                     ensureCapacity(headerSize);
                 }
-                IndexType indexType = useIndexing ? IndexType.INCREMENTAL : IndexType.NONE;
+                HpackUtil.IndexType indexType =
+                        useIndexing ? INCREMENTAL : NONE;
                 encodeLiteral(out, name, value, indexType, nameIndex);
                 if (useIndexing) {
                     add(name, value);
@@ -201,7 +204,7 @@ private void encodeStringLiteral(OutputStream out, byte[] string) throws IOExcep
     /**
      * Encode literal header field according to Section 6.2.
      */
-    private void encodeLiteral(OutputStream out, byte[] name, byte[] value, IndexType indexType,
+    private void encodeLiteral(OutputStream out, byte[] name, byte[] value, HpackUtil.IndexType indexType,
                                int nameIndex)
             throws IOException {
         int mask;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HeaderField.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderField.java
similarity index 92%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HeaderField.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderField.java
index 4a028658e582..6905aef0f082 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HeaderField.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderField.java
@@ -29,10 +29,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
-import static io.netty.handler.codec.http2.hpack.HpackUtil.ISO_8859_1;
-import static io.netty.handler.codec.http2.hpack.HpackUtil.requireNonNull;
+import static io.netty.util.CharsetUtil.ISO_8859_1;
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
 class HeaderField implements Comparable<HeaderField> {
 
@@ -54,8 +54,8 @@ static int sizeOf(byte[] name, byte[] value) {
     }
 
     HeaderField(byte[] name, byte[] value) {
-        this.name = requireNonNull(name);
-        this.value = requireNonNull(value);
+        this.name = checkNotNull(name, "name");
+        this.value = checkNotNull(value, "value");
     }
 
     int size() {
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HeaderListener.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderListener.java
similarity index 96%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HeaderListener.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderListener.java
index 6fd488d41e9e..7bc516b49e66 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HeaderListener.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderListener.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 public interface HeaderListener {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HpackUtil.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HpackUtil.java
similarity index 96%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HpackUtil.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HpackUtil.java
index 53660f665705..fc3ec26b37c2 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HpackUtil.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HpackUtil.java
@@ -29,14 +29,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import java.nio.charset.Charset;
 
 final class HpackUtil {
-
-    static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
-
     /**
      * A string compare that doesn't leak timing information.
      */
@@ -51,16 +48,6 @@ static boolean equals(byte[] s1, byte[] s2) {
         return c == 0;
     }
 
-    /**
-     * Checks that the specified object reference is not {@code null}.
-     */
-    static <T> T requireNonNull(T obj) {
-        if (obj == null) {
-            throw new NullPointerException();
-        }
-        return obj;
-    }
-
     // Section 6.2. Literal Header Field Representation
     enum IndexType {
         INCREMENTAL, // Section 6.2.1. Literal Header Field with Incremental Indexing
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Huffman.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Huffman.java
similarity index 87%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Huffman.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Huffman.java
index 771fab8e3ec9..e3aa076289ce 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/Huffman.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Huffman.java
@@ -29,10 +29,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
-import static io.netty.handler.codec.http2.hpack.HpackUtil.HUFFMAN_CODES;
-import static io.netty.handler.codec.http2.hpack.HpackUtil.HUFFMAN_CODE_LENGTHS;
+import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.HUFFMAN_CODES;
+import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.HUFFMAN_CODE_LENGTHS;
 
 public final class Huffman {
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HuffmanDecoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HuffmanDecoder.java
similarity index 65%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HuffmanDecoder.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HuffmanDecoder.java
index c0b33e05d7eb..71557567ce3d 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HuffmanDecoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HuffmanDecoder.java
@@ -29,15 +29,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
+
+import io.netty.util.internal.EmptyArrays;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 
 final class HuffmanDecoder {
 
-    private static final IOException EOS_DECODED = new IOException("EOS Decoded");
-    private static final IOException INVALID_PADDING = new IOException("Invalid Padding");
+    private static final IOException EOS_DECODED = new IOException("HPACK - EOS Decoded");
+    private static final IOException INVALID_PADDING = new IOException("HPACK - Invalid Padding");
+
+    static {
+        EOS_DECODED.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+        INVALID_PADDING.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
+    }
 
     private final Node root;
 
@@ -65,44 +72,77 @@ final class HuffmanDecoder {
     public byte[] decode(byte[] buf) throws IOException {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
 
+        /*
+         * The idea here is to consume whole bytes at a time rather than individual bits. node
+         * represents the Huffman tree, with all bit patterns denormalized as 256 children. Each
+         * child represents the last 8 bits of the huffman code. The parents of each child each
+         * represent the successive 8 bit chunks that lead up to the last most part. 8 bit bytes
+         * from buf are used to traverse these tree until a terminal node is found.
+         *
+         * current is a bit buffer. The low order bits represent how much of the huffman code has
+         * not been used to traverse the tree. Thus, the high order bits are just garbage.
+         * currentBits represents how many of the low order bits of current are actually valid.
+         * currentBits will vary between 0 and 15.
+         *
+         * symbolBits is the number of bits of the the symbol being decoded, *including* all those
+         * of the parent nodes. symbolBits tells how far down the tree we are. For example, when
+         * decoding the invalid sequence {0xff, 0xff}, currentBits will be 0, but symbolBits will be
+         * 16. This is used to know if buf ended early (before consuming a whole symbol) or if
+         * there is too much padding.
+         */
         Node node = root;
         int current = 0;
-        int bits = 0;
+        int currentBits = 0;
+        int symbolBits = 0;
         for (int i = 0; i < buf.length; i++) {
             int b = buf[i] & 0xFF;
             current = (current << 8) | b;
-            bits += 8;
-            while (bits >= 8) {
-                int c = (current >>> (bits - 8)) & 0xFF;
+            currentBits += 8;
+            symbolBits += 8;
+            // While there are unconsumed bits in current, keep consuming symbols.
+            while (currentBits >= 8) {
+                int c = (current >>> (currentBits - 8)) & 0xFF;
                 node = node.children[c];
-                bits -= node.bits;
+                currentBits -= node.bits;
                 if (node.isTerminal()) {
                     if (node.symbol == HpackUtil.HUFFMAN_EOS) {
                         throw EOS_DECODED;
                     }
                     baos.write(node.symbol);
                     node = root;
+                    // Upon consuming a whole symbol, reset the symbol bits to the number of bits
+                    // left over in the byte.
+                    symbolBits = currentBits;
                 }
             }
         }
 
-        while (bits > 0) {
-            int c = (current << (8 - bits)) & 0xFF;
+        /*
+         * We have consumed all the bytes in buf, but haven't consumed all the symbols. We may be on
+         * a partial symbol, so consume until there is nothing left. This will loop at most 2 times.
+         */
+        while (currentBits > 0) {
+            int c = (current << (8 - currentBits)) & 0xFF;
             node = node.children[c];
-            if (node.isTerminal() && node.bits <= bits) {
-                bits -= node.bits;
+            if (node.isTerminal() && node.bits <= currentBits) {
+                if (node.symbol == HpackUtil.HUFFMAN_EOS) {
+                    throw EOS_DECODED;
+                }
+                currentBits -= node.bits;
                 baos.write(node.symbol);
                 node = root;
+                symbolBits = currentBits;
             } else {
                 break;
             }
         }
 
         // Section 5.2. String Literal Representation
+        // A padding strictly longer than 7 bits MUST be treated as a decoding error.
         // Padding not corresponding to the most significant bits of the code
         // for the EOS symbol (0xFF) MUST be treated as a decoding error.
-        int mask = (1 << bits) - 1;
-        if ((current & mask) != mask) {
+        int mask = (1 << symbolBits) - 1;
+        if (symbolBits > 7 || (current & mask) != mask) {
             throw INVALID_PADDING;
         }
 
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HuffmanEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HuffmanEncoder.java
similarity index 98%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HuffmanEncoder.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HuffmanEncoder.java
index 1e7e2654ba36..d540e8503179 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/HuffmanEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HuffmanEncoder.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import java.io.IOException;
 import java.io.OutputStream;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/StaticTable.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/StaticTable.java
similarity index 97%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/StaticTable.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/StaticTable.java
index ff8543b324b5..a61d08844fce 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/StaticTable.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/StaticTable.java
@@ -29,13 +29,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import static io.netty.util.CharsetUtil.ISO_8859_1;
+
 final class StaticTable {
 
     private static final String EMPTY = "";
@@ -125,7 +127,7 @@ static HeaderField getEntry(int index) {
      * -1 if the header field name is not in the static table.
      */
     static int getIndex(byte[] name) {
-        String nameString = new String(name, 0, name.length, HpackUtil.ISO_8859_1);
+        String nameString = new String(name, 0, name.length, ISO_8859_1);
         Integer index = STATIC_INDEX_BY_NAME.get(nameString);
         if (index == null) {
             return -1;
@@ -166,7 +168,7 @@ private static Map<String, Integer> createMap() {
         // save the smallest index for a given name in the map.
         for (int index = length; index > 0; index--) {
             HeaderField entry = getEntry(index);
-            String name = new String(entry.name, 0, entry.name.length, HpackUtil.ISO_8859_1);
+            String name = new String(entry.name, 0, entry.name.length, ISO_8859_1);
             ret.put(name, index);
         }
         return ret;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/package-info.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/package-info.java
similarity index 96%
rename from codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/package-info.java
rename to codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/package-info.java
index e56f49085762..f2e976bfbdf4 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/hpack/package-info.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/package-info.java
@@ -33,4 +33,4 @@
 /**
  * <a href="http://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/package-info.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/package-info.java
index d8a33f1fc6da..1826d13d82f9 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/package-info.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/package-info.java
@@ -16,5 +16,7 @@
 /**
  * Handlers for sending and receiving HTTP/2 frames.
  */
+@UnstableApi
 package io.netty.handler.codec.http2;
 
+import io.netty.util.internal.UnstableApi;
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java
index fc62bbfc429c..a1b8ee491a78 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java
@@ -161,6 +161,26 @@ public void removeAllStreamsWithNonActiveAndActiveStreams() throws InterruptedEx
         testRemoveAllStreams();
     }
 
+    @Test
+    public void removeIndividualStreamsWhileCloseDoesNotNPE() throws InterruptedException, Http2Exception {
+        final Http2Stream streamA = client.local().createStream(3, false);
+        final Http2Stream streamB = client.remote().createStream(2, false);
+        doAnswer(new Answer<Void>() {
+            @Override
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                streamA.close();
+                streamB.close();
+                return null;
+            }
+        }).when(clientListener2).onStreamClosed(any(Http2Stream.class));
+        try {
+            client.addListener(clientListener2);
+            testRemoveAllStreams();
+        } finally {
+            client.removeListener(clientListener2);
+        }
+    }
+
     @Test
     public void removeAllStreamsWhileIteratingActiveStreams() throws InterruptedException, Http2Exception {
         final Endpoint<Http2RemoteFlowController> remote = client.remote();
@@ -497,7 +517,6 @@ public void remoteStreamCanDependUponIdleStream() throws Http2Exception {
     public void prioritizeShouldUseDefaults() throws Exception {
         Http2Stream stream = client.local().createStream(1, false);
         assertEquals(1, client.connectionStream().numChildren());
-        assertEquals(2, client.connectionStream().prioritizableForTree());
         assertEquals(stream, child(client.connectionStream(), 1));
         assertEquals(DEFAULT_PRIORITY_WEIGHT, stream.weight());
         assertEquals(0, stream.parent().id());
@@ -509,7 +528,6 @@ public void reprioritizeWithNoChangeShouldDoNothing() throws Exception {
         Http2Stream stream = client.local().createStream(1, false);
         stream.setPriority(0, DEFAULT_PRIORITY_WEIGHT, false);
         assertEquals(1, client.connectionStream().numChildren());
-        assertEquals(2, client.connectionStream().prioritizableForTree());
         assertEquals(stream, child(client.connectionStream(), 1));
         assertEquals(DEFAULT_PRIORITY_WEIGHT, stream.weight());
         assertEquals(0, stream.parent().id());
@@ -532,33 +550,28 @@ public void insertExclusiveShouldAddNewLevel() throws Exception {
         // Level 0
         Http2Stream p = client.connectionStream();
         assertEquals(1, p.numChildren());
-        assertEquals(5, p.prioritizableForTree());
 
         // Level 1
         p = child(p, streamA.id());
         assertNotNull(p);
         assertEquals(0, p.parent().id());
         assertEquals(1, p.numChildren());
-        assertEquals(4, p.prioritizableForTree());
 
         // Level 2
         p = child(p, streamD.id());
         assertNotNull(p);
         assertEquals(streamA.id(), p.parent().id());
         assertEquals(2, p.numChildren());
-        assertEquals(3, p.prioritizableForTree());
 
         // Level 3
         p = child(p, streamB.id());
         assertNotNull(p);
         assertEquals(streamD.id(), p.parent().id());
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
         p = child(p.parent(), streamC.id());
         assertNotNull(p);
         assertEquals(streamD.id(), p.parent().id());
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
     }
 
     @Test
@@ -580,33 +593,28 @@ public void existingChildMadeExclusiveShouldNotCreateTreeCycle() throws Http2Exc
         // Level 0
         Http2Stream p = client.connectionStream();
         assertEquals(1, p.numChildren());
-        assertEquals(5, p.prioritizableForTree());
 
         // Level 1
         p = child(p, streamA.id());
         assertNotNull(p);
         assertEquals(0, p.parent().id());
         assertEquals(1, p.numChildren());
-        assertEquals(4, p.prioritizableForTree());
 
         // Level 2
         p = child(p, streamC.id());
         assertNotNull(p);
         assertEquals(streamA.id(), p.parent().id());
         assertEquals(2, p.numChildren());
-        assertEquals(3, p.prioritizableForTree());
 
         // Level 3
         p = child(p, streamB.id());
         assertNotNull(p);
         assertEquals(streamC.id(), p.parent().id());
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
         p = child(p.parent(), streamD.id());
         assertNotNull(p);
         assertEquals(streamC.id(), p.parent().id());
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
     }
 
     @Test
@@ -632,45 +640,38 @@ public void newExclusiveChildShouldUpdateOldParentCorrectly() throws Http2Except
         // Level 0
         Http2Stream p = client.connectionStream();
         assertEquals(2, p.numChildren());
-        assertEquals(7, p.prioritizableForTree());
 
         // Level 1
         p = child(p, streamE.id());
         assertNotNull(p);
         assertEquals(0, p.parent().id());
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
         p = child(p.parent(), streamA.id());
         assertNotNull(p);
         assertEquals(0, p.parent().id());
         assertEquals(1, p.numChildren());
-        assertEquals(5, p.prioritizableForTree());
 
         // Level 2
         p = child(p, streamF.id());
         assertNotNull(p);
         assertEquals(streamA.id(), p.parent().id());
         assertEquals(2, p.numChildren());
-        assertEquals(4, p.prioritizableForTree());
 
         // Level 3
         p = child(p, streamB.id());
         assertNotNull(p);
         assertEquals(streamF.id(), p.parent().id());
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
         p = child(p.parent(), streamC.id());
         assertNotNull(p);
         assertEquals(streamF.id(), p.parent().id());
         assertEquals(1, p.numChildren());
-        assertEquals(2, p.prioritizableForTree());
 
         // Level 4
         p = child(p, streamD.id());
         assertNotNull(p);
         assertEquals(streamC.id(), p.parent().id());
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
     }
 
     @Test
@@ -696,11 +697,6 @@ public void weightChangeWithNoTreeChangeShouldNotifyListeners() throws Http2Exce
                 any(Http2Stream.class));
         verify(clientListener, never()).onPriorityTreeParentChanged(any(Http2Stream.class),
                 any(Http2Stream.class));
-        assertEquals(5, client.connectionStream().prioritizableForTree());
-        assertEquals(4, streamA.prioritizableForTree());
-        assertEquals(1, streamB.prioritizableForTree());
-        assertEquals(1, streamC.prioritizableForTree());
-        assertEquals(3, streamD.prioritizableForTree());
     }
 
     @Test
@@ -720,11 +716,6 @@ public void sameNodeDependentShouldNotStackOverflowNorChangePrioritizableForTree
         assertEquals(4, client.numActiveStreams());
 
         Http2Stream connectionStream = client.connectionStream();
-        assertEquals(5, connectionStream.prioritizableForTree());
-        assertEquals(4, streamA.prioritizableForTree());
-        assertEquals(1, streamB.prioritizableForTree());
-        assertEquals(1, streamC.prioritizableForTree());
-        assertEquals(3, streamD.prioritizableForTree());
 
         // The goal is to call setPriority with the same parent and vary the parameters
         // we were at one point adding a circular depends to the tree and then throwing
@@ -732,11 +723,6 @@ public void sameNodeDependentShouldNotStackOverflowNorChangePrioritizableForTree
         for (int j = 0; j < weights.length; ++j) {
             for (int i = 0; i < exclusive.length; ++i) {
                 streamD.setPriority(streamA.id(), weights[j], exclusive[i]);
-                assertEquals(5, connectionStream.prioritizableForTree());
-                assertEquals(4, streamA.prioritizableForTree());
-                assertEquals(1, streamB.prioritizableForTree());
-                assertEquals(1, streamC.prioritizableForTree());
-                assertEquals(3, streamD.prioritizableForTree());
             }
         }
     }
@@ -755,45 +741,20 @@ public void multipleCircularDependencyShouldUpdatePrioritizable() throws Http2Ex
         assertEquals(4, client.numActiveStreams());
 
         Http2Stream connectionStream = client.connectionStream();
-        assertEquals(5, connectionStream.prioritizableForTree());
-        assertEquals(4, streamA.prioritizableForTree());
-        assertEquals(1, streamB.prioritizableForTree());
-        assertEquals(1, streamC.prioritizableForTree());
-        assertEquals(3, streamD.prioritizableForTree());
 
         // Bring B to the root
         streamA.setPriority(streamB.id(), DEFAULT_PRIORITY_WEIGHT, true);
-        assertEquals(5, connectionStream.prioritizableForTree());
-        assertEquals(3, streamA.prioritizableForTree());
-        assertEquals(4, streamB.prioritizableForTree());
-        assertEquals(1, streamC.prioritizableForTree());
-        assertEquals(2, streamD.prioritizableForTree());
 
         // Move all streams to be children of B
         streamC.setPriority(streamB.id(), DEFAULT_PRIORITY_WEIGHT, false);
         streamD.setPriority(streamB.id(), DEFAULT_PRIORITY_WEIGHT, false);
-        assertEquals(5, connectionStream.prioritizableForTree());
-        assertEquals(1, streamA.prioritizableForTree());
-        assertEquals(4, streamB.prioritizableForTree());
-        assertEquals(1, streamC.prioritizableForTree());
-        assertEquals(1, streamD.prioritizableForTree());
 
         // Move A back to the root
         streamB.setPriority(streamA.id(), DEFAULT_PRIORITY_WEIGHT, true);
-        assertEquals(5, connectionStream.prioritizableForTree());
-        assertEquals(4, streamA.prioritizableForTree());
-        assertEquals(3, streamB.prioritizableForTree());
-        assertEquals(1, streamC.prioritizableForTree());
-        assertEquals(1, streamD.prioritizableForTree());
 
         // Move all streams to be children of A
         streamC.setPriority(streamA.id(), DEFAULT_PRIORITY_WEIGHT, false);
         streamD.setPriority(streamA.id(), DEFAULT_PRIORITY_WEIGHT, false);
-        assertEquals(5, connectionStream.prioritizableForTree());
-        assertEquals(4, streamA.prioritizableForTree());
-        assertEquals(1, streamB.prioritizableForTree());
-        assertEquals(1, streamC.prioritizableForTree());
-        assertEquals(1, streamD.prioritizableForTree());
     }
 
     @Test
@@ -812,33 +773,22 @@ public void removeWithPrioritizableDependentsShouldNotRestructureTree() throws E
 
         // Level 0
         Http2Stream p = client.connectionStream();
-        assertEquals(4, p.prioritizableForTree());
         assertEquals(1, p.numChildren());
 
         // Level 1
         p = child(p, streamA.id());
         assertNotNull(p);
-        assertEquals(3, p.prioritizableForTree());
-        assertEquals(0, p.parent().id());
-        assertEquals(1, p.numChildren());
-
-        // Level 2
-        p = child(p, streamB.id());
-        assertNotNull(p);
-        assertEquals(2, p.prioritizableForTree());
-        assertEquals(streamA.id(), p.parent().id());
+        assertEquals(client.connectionStream().id(), p.parent().id());
         assertEquals(2, p.numChildren());
 
-        // Level 3
+        // Level 2
         p = child(p, streamC.id());
         assertNotNull(p);
-        assertEquals(1, p.prioritizableForTree());
-        assertEquals(streamB.id(), p.parent().id());
+        assertEquals(streamA.id(), p.parent().id());
         assertEquals(0, p.numChildren());
         p = child(p.parent(), streamD.id());
         assertNotNull(p);
-        assertEquals(1, p.prioritizableForTree());
-        assertEquals(streamB.id(), p.parent().id());
+        assertEquals(streamA.id(), p.parent().id());
         assertEquals(0, p.numChildren());
     }
 
@@ -857,7 +807,7 @@ public void closeWithNoPrioritizableDependentsShouldRestructureTree() throws Exc
         streamE.setPriority(streamC.id(), DEFAULT_PRIORITY_WEIGHT, false);
         streamF.setPriority(streamD.id(), DEFAULT_PRIORITY_WEIGHT, false);
 
-        // Close internal nodes, leave 1 leaf node open, and ensure part of the tree (D & F) is cleaned up
+        // Close internal nodes, leave 1 leaf node open, the only remaining stream is the one that is not closed (E).
         streamA.close();
         streamB.close();
         streamC.close();
@@ -867,38 +817,15 @@ public void closeWithNoPrioritizableDependentsShouldRestructureTree() throws Exc
         // Level 0
         Http2Stream p = client.connectionStream();
         assertEquals(1, p.numChildren());
-        assertEquals(2, p.prioritizableForTree());
 
         // Level 1
-        p = child(p, streamA.id());
-        assertNotNull(p);
-        assertEquals(0, p.parent().id());
-        assertEquals(1, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
-
-        // Level 2
-        p = child(p, streamB.id());
-        assertNotNull(p);
-        assertEquals(streamA.id(), p.parent().id());
-        assertEquals(1, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
-
-        // Level 3
-        p = child(p, streamC.id());
-        assertNotNull(p);
-        assertEquals(streamB.id(), p.parent().id());
-        assertEquals(1, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
-
-        // Level 4
         p = child(p, streamE.id());
         assertNotNull(p);
-        assertEquals(streamC.id(), p.parent().id());
+        assertEquals(client.connectionStream().id(), p.parent().id());
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
     }
 
-    @Test
+    @Test(expected = Http2Exception.class)
     public void priorityChangeWithNoPrioritizableDependentsShouldRestructureTree() throws Exception {
         Http2Stream streamA = client.local().createStream(1, false);
         Http2Stream streamB = client.local().createStream(3, false);
@@ -919,46 +846,8 @@ public void priorityChangeWithNoPrioritizableDependentsShouldRestructureTree() t
         streamC.close();
         streamD.close();
 
-        // Move F to depend on C, this should close D
+        // Attempt to move F to depend on C, however this should throw an exception because C is closed.
         streamF.setPriority(streamC.id(), DEFAULT_PRIORITY_WEIGHT, false);
-
-        // Level 0
-        Http2Stream p = client.connectionStream();
-        assertEquals(1, p.numChildren());
-        assertEquals(3, p.prioritizableForTree());
-
-        // Level 1
-        p = child(p, streamA.id());
-        assertNotNull(p);
-        assertEquals(0, p.parent().id());
-        assertEquals(1, p.numChildren());
-        assertEquals(2, p.prioritizableForTree());
-
-        // Level 2
-        p = child(p, streamB.id());
-        assertNotNull(p);
-        assertEquals(streamA.id(), p.parent().id());
-        assertEquals(1, p.numChildren());
-        assertEquals(2, p.prioritizableForTree());
-
-        // Level 3
-        p = child(p, streamC.id());
-        assertNotNull(p);
-        assertEquals(streamB.id(), p.parent().id());
-        assertEquals(2, p.numChildren());
-        assertEquals(2, p.prioritizableForTree());
-
-        // Level 4
-        p = child(p, streamE.id());
-        assertNotNull(p);
-        assertEquals(streamC.id(), p.parent().id());
-        assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
-        p = child(p.parent(), streamF.id());
-        assertNotNull(p);
-        assertEquals(streamC.id(), p.parent().id());
-        assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
     }
 
     @Test
@@ -1016,19 +905,16 @@ public void circularDependencyShouldRestructureTree() throws Exception {
         // Level 0
         Http2Stream p = client.connectionStream();
         assertEquals(1, p.numChildren());
-        assertEquals(7, p.prioritizableForTree());
 
         // Level 1
         p = child(p, streamD.id());
         assertNotNull(p);
         assertEquals(2, p.numChildren());
-        assertEquals(6, p.prioritizableForTree());
 
         // Level 2
         p = child(p, streamF.id());
         assertNotNull(p);
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
         p = child(p.parent(), streamA.id());
         assertNotNull(p);
         assertEquals(2, p.numChildren());
@@ -1037,17 +923,14 @@ public void circularDependencyShouldRestructureTree() throws Exception {
         p = child(p, streamB.id());
         assertNotNull(p);
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
         p = child(p.parent(), streamC.id());
         assertNotNull(p);
         assertEquals(1, p.numChildren());
-        assertEquals(2, p.prioritizableForTree());
 
         // Level 4;
         p = child(p, streamE.id());
         assertNotNull(p);
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
     }
 
     @Test
@@ -1107,39 +990,32 @@ public void circularDependencyWithExclusiveShouldRestructureTree() throws Except
         // Level 0
         Http2Stream p = client.connectionStream();
         assertEquals(1, p.numChildren());
-        assertEquals(7, p.prioritizableForTree());
 
         // Level 1
         p = child(p, streamD.id());
         assertNotNull(p);
         assertEquals(1, p.numChildren());
-        assertEquals(6, p.prioritizableForTree());
 
         // Level 2
         p = child(p, streamA.id());
         assertNotNull(p);
         assertEquals(3, p.numChildren());
-        assertEquals(5, p.prioritizableForTree());
 
         // Level 3
         p = child(p, streamB.id());
         assertNotNull(p);
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
         p = child(p.parent(), streamF.id());
         assertNotNull(p);
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
         p = child(p.parent(), streamC.id());
         assertNotNull(p);
         assertEquals(1, p.numChildren());
-        assertEquals(2, p.prioritizableForTree());
 
         // Level 4;
         p = child(p, streamE.id());
         assertNotNull(p);
         assertEquals(0, p.numChildren());
-        assertEquals(1, p.prioritizableForTree());
     }
 
     /**
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoderTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoderTest.java
index dbcf25d469e4..15df03e63654 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoderTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoderTest.java
@@ -17,7 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.handler.codec.http2.hpack.Encoder;
+import io.netty.handler.codec.http2.internal.hpack.Encoder;
 import io.netty.util.AsciiString;
 import org.junit.Before;
 import org.junit.Test;
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java
index 326cde1fe5a3..4f8b52fa5028 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java
@@ -17,6 +17,7 @@
 package io.netty.handler.codec.http2;
 
 import io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName;
+import io.netty.util.internal.StringUtil;
 import org.junit.Test;
 
 import java.util.Map.Entry;
@@ -30,6 +31,16 @@
 
 public class DefaultHttp2HeadersTest {
 
+    @Test(expected = Http2Exception.class)
+    public void nullHeaderNameNotAllowed() {
+        new DefaultHttp2Headers().add(null, "foo");
+    }
+
+    @Test(expected = Http2Exception.class)
+    public void emtpyHeaderNameNotAllowed() {
+        new DefaultHttp2Headers().add(StringUtil.EMPTY_STRING, "foo");
+    }
+
     @Test
     public void testPseudoHeadersMustComeFirstWhenIterating() {
         Http2Headers headers = newHeaders();
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowControllerTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowControllerTest.java
index d7f26f58765d..a2b809bacb4c 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowControllerTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowControllerTest.java
@@ -45,7 +45,9 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.handler.codec.http2.Http2FrameWriter.Configuration;
 import io.netty.util.concurrent.EventExecutor;
+
 import junit.framework.AssertionFailedError;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mock;
@@ -186,13 +188,15 @@ public void emptyPayloadShouldBeWrittenImmediately() throws Http2Exception {
     @Test
     public void unflushedPayloadsShouldBeDroppedOnCancel() throws Http2Exception {
         FakeFlowControlled data = new FakeFlowControlled(5);
+        Http2Stream streamA = stream(STREAM_A);
         sendData(STREAM_A, data);
-        connection.stream(STREAM_A).close();
+        streamA.close();
         controller.writePendingBytes();
         data.assertNotWritten();
         controller.writePendingBytes();
         data.assertNotWritten();
-        verify(listener, times(1)).writabilityChanged(stream(STREAM_A));
+        verify(listener, times(1)).writabilityChanged(streamA);
+        assertFalse(controller.isWritable(streamA));
     }
 
     @Test
@@ -716,7 +720,14 @@ public Void answer(InvocationOnMock invocationOnMock) {
         verify(flowControlled, never()).writeComplete();
 
         assertEquals(90, windowBefore - window(STREAM_A));
-        assertWritabilityChanged(0, true);
+        verify(listener, times(1)).writabilityChanged(stream(STREAM_A));
+        verify(listener, never()).writabilityChanged(stream(STREAM_B));
+        verify(listener, never()).writabilityChanged(stream(STREAM_C));
+        verify(listener, never()).writabilityChanged(stream(STREAM_D));
+        assertFalse(controller.isWritable(stream(STREAM_A)));
+        assertTrue(controller.isWritable(stream(STREAM_B)));
+        assertTrue(controller.isWritable(stream(STREAM_C)));
+        assertTrue(controller.isWritable(stream(STREAM_D)));
     }
 
     @Test
@@ -755,6 +766,7 @@ public Void answer(InvocationOnMock invocationOnMock) {
     public void flowControlledWriteCompleteThrowsAnException() throws Exception {
         final Http2RemoteFlowController.FlowControlled flowControlled =
                 mock(Http2RemoteFlowController.FlowControlled.class);
+        Http2Stream streamA = stream(STREAM_A);
         final AtomicInteger size = new AtomicInteger(150);
         doAnswer(new Answer<Integer>() {
             @Override
@@ -780,19 +792,22 @@ public Void answer(InvocationOnMock invocationOnMock) {
 
         int windowBefore = window(STREAM_A);
 
-        try {
-            controller.addFlowControlled(stream, flowControlled);
-            controller.writePendingBytes();
-        } catch (Exception e) {
-            fail();
-        }
+        controller.addFlowControlled(stream, flowControlled);
+        controller.writePendingBytes();
 
         verify(flowControlled, times(3)).write(any(ChannelHandlerContext.class), anyInt());
         verify(flowControlled, never()).error(any(ChannelHandlerContext.class), any(Throwable.class));
         verify(flowControlled).writeComplete();
 
         assertEquals(150, windowBefore - window(STREAM_A));
-        assertWritabilityChanged(0, true);
+        verify(listener, times(1)).writabilityChanged(streamA);
+        verify(listener, never()).writabilityChanged(stream(STREAM_B));
+        verify(listener, never()).writabilityChanged(stream(STREAM_C));
+        verify(listener, never()).writabilityChanged(stream(STREAM_D));
+        assertFalse(controller.isWritable(streamA));
+        assertTrue(controller.isWritable(stream(STREAM_B)));
+        assertTrue(controller.isWritable(stream(STREAM_C)));
+        assertTrue(controller.isWritable(stream(STREAM_D)));
     }
 
     @Test
@@ -817,11 +832,11 @@ public Void answer(InvocationOnMock invocationOnMock) {
         verify(flowControlled).write(any(ChannelHandlerContext.class), anyInt());
         verify(flowControlled).error(any(ChannelHandlerContext.class), any(Throwable.class));
         verify(flowControlled, never()).writeComplete();
-        verify(listener, times(1)).writabilityChanged(stream(STREAM_A));
+        verify(listener, times(1)).writabilityChanged(stream);
         verify(listener, never()).writabilityChanged(stream(STREAM_B));
         verify(listener, never()).writabilityChanged(stream(STREAM_C));
         verify(listener, never()).writabilityChanged(stream(STREAM_D));
-        assertFalse(controller.isWritable(stream(STREAM_A)));
+        assertFalse(controller.isWritable(stream));
         assertTrue(controller.isWritable(stream(STREAM_B)));
         assertTrue(controller.isWritable(stream(STREAM_C)));
         assertTrue(controller.isWritable(stream(STREAM_D)));
@@ -889,6 +904,9 @@ public void initialWindowSizeWithNoContextShouldNotThrow() throws Exception {
         // Re-initialize the controller so we can ensure the context hasn't been set yet.
         initConnectionAndController();
 
+        // This should not throw.
+        controller.initialWindowSize(1024 * 100);
+
         FakeFlowControlled dataA = new FakeFlowControlled(1);
         final Http2Stream stream = stream(STREAM_A);
 
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
index 65b8670c77fb..742d529f9d6e 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java
@@ -24,6 +24,7 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.DefaultChannelPromise;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.GenericFutureListener;
 import io.netty.util.concurrent.Promise;
@@ -178,6 +179,14 @@ public Http2Stream answer(InvocationOnMock in) throws Throwable {
         when(ctx.newPromise()).thenReturn(promise);
         when(ctx.write(any())).thenReturn(future);
         when(ctx.executor()).thenReturn(executor);
+        doAnswer(new Answer() {
+            @Override
+            public Object answer(InvocationOnMock in) throws Throwable {
+                Object msg = in.getArgumentAt(0, Object.class);
+                ReferenceCountUtil.release(msg);
+                return null;
+            }
+        }).when(ctx).fireChannelRead(any());
     }
 
     private Http2ConnectionHandler newHandler() throws Exception {
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java
index 39207f0c670a..cfef3935b5ef 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java
@@ -47,6 +47,8 @@
 import java.io.ByteArrayOutputStream;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 import static io.netty.handler.codec.http2.Http2TestUtil.randomString;
@@ -62,6 +64,7 @@
 import static org.mockito.Matchers.anyBoolean;
 import static org.mockito.Matchers.anyInt;
 import static org.mockito.Matchers.anyLong;
+import static org.mockito.Matchers.anyShort;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doThrow;
@@ -81,6 +84,7 @@ public class Http2ConnectionRoundtripTest {
     private Http2FrameListener serverListener;
 
     private Http2ConnectionHandler http2Client;
+    private Http2ConnectionHandler http2Server;
     private ServerBootstrap sb;
     private Bootstrap cb;
     private Channel serverChannel;
@@ -117,6 +121,59 @@ public void teardown() throws Exception {
         clientGroup.sync();
     }
 
+    @Test
+    public void inflightFrameAfterStreamResetShouldNotMakeConnectionUnsuable() throws Exception {
+        bootstrapEnv(1, 1, 2, 1);
+        final CountDownLatch latch = new CountDownLatch(1);
+        doAnswer(new Answer<Void>() {
+            @Override
+            public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+                ChannelHandlerContext ctx = invocationOnMock.getArgumentAt(0, ChannelHandlerContext.class);
+                http2Server.encoder().writeHeaders(ctx,
+                        invocationOnMock.getArgumentAt(1, Integer.class),
+                        invocationOnMock.getArgumentAt(2, Http2Headers.class),
+                        0,
+                        false,
+                        ctx.newPromise());
+                http2Server.flush(ctx);
+                return null;
+            }
+        }).when(serverListener).onHeadersRead(any(ChannelHandlerContext.class), anyInt(), any(Http2Headers.class),
+                anyInt(), anyShort(), anyBoolean(), anyInt(), anyBoolean());
+
+        doAnswer(new Answer<Void>() {
+            @Override
+            public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
+                latch.countDown();
+                return null;
+            }
+        }).when(clientListener).onHeadersRead(any(ChannelHandlerContext.class), eq(5), any(Http2Headers.class),
+                anyInt(), anyShort(), anyBoolean(), anyInt(), anyBoolean());
+
+        // Create a single stream by sending a HEADERS frame to the server.
+        final short weight = 16;
+        final Http2Headers headers = dummyHeaders();
+        runInChannel(clientChannel, new Http2Runnable() {
+            @Override
+            public void run() throws Http2Exception {
+                http2Client.encoder().writeHeaders(ctx(), 3, headers, 0, weight, false, 0, false, newPromise());
+                http2Client.flush(ctx());
+                http2Client.encoder().writeRstStream(ctx(), 3, Http2Error.INTERNAL_ERROR.code(), newPromise());
+                http2Client.flush(ctx());
+            }
+        });
+
+        runInChannel(clientChannel, new Http2Runnable() {
+            @Override
+            public void run() throws Http2Exception {
+                http2Client.encoder().writeHeaders(ctx(), 5, headers, 0, weight, false, 0, false, newPromise());
+                http2Client.flush(ctx());
+            }
+        });
+
+        assertTrue(latch.await(5, TimeUnit.SECONDS));
+    }
+
     @Test
     public void headersWithEndStreamShouldNotSendError() throws Exception {
         bootstrapEnv(1, 1, 2, 1);
@@ -337,7 +394,7 @@ public Integer answer(InvocationOnMock in) throws Throwable {
                 public void run() throws Http2Exception {
                     http2Client.encoder().writeHeaders(ctx(), 3, headers, 0, (short) 16, false, 0,
                             false, newPromise());
-                    http2Client.encoder().writeData(ctx(), 3, data.duplicate().retain(), 0, false, newPromise());
+                    http2Client.encoder().writeData(ctx(), 3, data.retainedDuplicate(), 0, false, newPromise());
 
                     // Write trailers.
                     http2Client.encoder().writeHeaders(ctx(), 3, headers, 0, (short) 16, false, 0,
@@ -422,10 +479,10 @@ public void run() throws Http2Exception {
                         // Send a bunch of data on each stream.
                         http2Client.encoder().writeHeaders(ctx(), streamId, headers, 0, (short) 16,
                                 false, 0, false, newPromise());
-                        http2Client.encoder().writePing(ctx(), false, pingData.slice().retain(),
+                        http2Client.encoder().writePing(ctx(), false, pingData.retainedSlice(),
                                 newPromise());
-                        http2Client.encoder().writeData(ctx(), streamId, data.slice().retain(), 0,
-                                false, newPromise());
+                        http2Client.encoder().writeData(ctx(), streamId, data.retainedSlice(), 0,
+                                                        false, newPromise());
                         // Write trailers.
                         http2Client.encoder().writeHeaders(ctx(), streamId, headers, 0, (short) 16,
                                 false, 0, true, newPromise());
@@ -473,6 +530,8 @@ private void bootstrapEnv(int dataCountDown, int settingsAckCount,
         sb = new ServerBootstrap();
         cb = new Bootstrap();
 
+        final AtomicReference<Http2ConnectionHandler> serverHandlerRef = new AtomicReference<Http2ConnectionHandler>();
+        final CountDownLatch serverInitLatch = new CountDownLatch(1);
         sb.group(new DefaultEventLoopGroup());
         sb.channel(LocalServerChannel.class);
         sb.childHandler(new ChannelInitializer<Channel>() {
@@ -482,11 +541,13 @@ protected void initChannel(Channel ch) throws Exception {
                 serverFrameCountDown =
                         new FrameCountDown(serverListener, serverSettingsAckLatch,
                                 requestLatch, dataLatch, trailersLatch, goAwayLatch);
-                p.addLast(new Http2ConnectionHandlerBuilder()
+                serverHandlerRef.set(new Http2ConnectionHandlerBuilder()
                         .server(true)
                         .frameListener(serverFrameCountDown)
                         .validateHeaders(false)
                         .build());
+                p.addLast(serverHandlerRef.get());
+                serverInitLatch.countDown();
             }
         });
 
@@ -500,6 +561,7 @@ protected void initChannel(Channel ch) throws Exception {
                         .server(false)
                         .frameListener(clientListener)
                         .validateHeaders(false)
+                        .gracefulShutdownTimeoutMillis(0)
                         .build());
             }
         });
@@ -510,6 +572,8 @@ protected void initChannel(Channel ch) throws Exception {
         assertTrue(ccf.awaitUninterruptibly().isSuccess());
         clientChannel = ccf.channel();
         http2Client = clientChannel.pipeline().get(Http2ConnectionHandler.class);
+        assertTrue(serverInitLatch.await(2, TimeUnit.SECONDS));
+        http2Server = serverHandlerRef.get();
     }
 
     private ChannelHandlerContext ctx() {
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java
index 29cdc162bf51..99f285d9194a 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java
@@ -15,31 +15,10 @@
 
 package io.netty.handler.codec.http2;
 
-import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
-import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_HEADER_SIZE;
-import static io.netty.handler.codec.http2.Http2TestUtil.randomString;
-import static io.netty.util.CharsetUtil.UTF_8;
-import static java.lang.Math.min;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyBoolean;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyShort;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.EmptyByteBuf;
-import io.netty.buffer.ReadOnlyByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelHandlerContext;
@@ -59,6 +38,26 @@
 import java.util.LinkedList;
 import java.util.List;
 
+import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
+import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_HEADER_SIZE;
+import static io.netty.handler.codec.http2.Http2TestUtil.randomString;
+import static io.netty.util.CharsetUtil.UTF_8;
+import static java.lang.Math.min;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyBoolean;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyShort;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Matchers.isA;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 /**
  * Tests encoding/decoding each HTTP2 frame type.
  */
@@ -127,7 +126,7 @@ public void teardown() {
             // Now verify that all of the reference counts are zero.
             for (ByteBuf buf : needReleasing) {
                 int expectedFinalRefCount = 0;
-                if (buf instanceof ReadOnlyByteBuf || buf instanceof EmptyByteBuf) {
+                if (buf.isReadOnly() || buf instanceof EmptyByteBuf) {
                     // Special case for when we're writing slices of the padding buffer.
                     expectedFinalRefCount = 1;
                 }
@@ -447,8 +446,7 @@ private ByteBuf captureWrites() {
         CompositeByteBuf composite = releaseLater(Unpooled.compositeBuffer());
         for (ByteBuf buf : captor.getAllValues()) {
             buf = releaseLater(buf.retain());
-            composite.addComponent(buf);
-            composite.writerIndex(composite.writerIndex() + buf.readableBytes());
+            composite.addComponent(true, buf);
         }
         return composite;
     }
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java
index feabb702f214..f796d64eb7ab 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java
@@ -38,6 +38,7 @@
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.PlatformDependent;
 
+import java.net.InetSocketAddress;
 import java.util.ArrayDeque;
 import java.util.Queue;
 
@@ -68,7 +69,7 @@ public class Http2MultiplexCodecTest {
 
     @Before
     public void setUp() throws Exception {
-        channel.connect(null);
+        channel.connect(new InetSocketAddress(0));
         channel.pipeline().addLast(serverCodec);
         http2HandlerCtx = channel.pipeline().context(serverCodec.connectionHandler());
 
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ServerDowngraderTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ServerDowngraderTest.java
new file mode 100644
index 000000000000..3d3cf0127ab6
--- /dev/null
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ServerDowngraderTest.java
@@ -0,0 +1,363 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.http2;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.DefaultHttpContent;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.DefaultLastHttpContent;
+import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.util.CharsetUtil;
+
+import org.junit.Test;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.nullValue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertFalse;
+
+public class Http2ServerDowngraderTest {
+
+    @Test
+    public void testUpgradeEmptyFullResponse() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        assertTrue(ch.writeOutbound(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK)));
+
+        Http2HeadersFrame headersFrame = ch.readOutbound();
+        assertThat(headersFrame.headers().status().toString(), is("200"));
+        assertTrue(headersFrame.isEndStream());
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeNonEmptyFullResponse() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        ByteBuf hello = Unpooled.copiedBuffer("hello world", CharsetUtil.UTF_8);
+        assertTrue(ch.writeOutbound(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, hello)));
+
+        Http2HeadersFrame headersFrame = ch.readOutbound();
+        assertThat(headersFrame.headers().status().toString(), is("200"));
+        assertFalse(headersFrame.isEndStream());
+
+        Http2DataFrame dataFrame = ch.readOutbound();
+        try {
+            assertThat(dataFrame.content().toString(CharsetUtil.UTF_8), is("hello world"));
+            assertTrue(dataFrame.isEndStream());
+        } finally {
+            dataFrame.release();
+        }
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeEmptyFullResponseWithTrailers() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+        HttpHeaders trailers = response.trailingHeaders();
+        trailers.set("key", "value");
+        assertTrue(ch.writeOutbound(response));
+
+        Http2HeadersFrame headersFrame = ch.readOutbound();
+        assertThat(headersFrame.headers().status().toString(), is("200"));
+        assertFalse(headersFrame.isEndStream());
+
+        Http2HeadersFrame trailersFrame = ch.readOutbound();
+        assertThat(trailersFrame.headers().get("key").toString(), is("value"));
+        assertTrue(trailersFrame.isEndStream());
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeNonEmptyFullResponseWithTrailers() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        ByteBuf hello = Unpooled.copiedBuffer("hello world", CharsetUtil.UTF_8);
+        FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, hello);
+        HttpHeaders trailers = response.trailingHeaders();
+        trailers.set("key", "value");
+        assertTrue(ch.writeOutbound(response));
+
+        Http2HeadersFrame headersFrame = ch.readOutbound();
+        assertThat(headersFrame.headers().status().toString(), is("200"));
+        assertFalse(headersFrame.isEndStream());
+
+        Http2DataFrame dataFrame = ch.readOutbound();
+        try {
+            assertThat(dataFrame.content().toString(CharsetUtil.UTF_8), is("hello world"));
+            assertFalse(dataFrame.isEndStream());
+        } finally {
+            dataFrame.release();
+        }
+
+        Http2HeadersFrame trailersFrame = ch.readOutbound();
+        assertThat(trailersFrame.headers().get("key").toString(), is("value"));
+        assertTrue(trailersFrame.isEndStream());
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeHeaders() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
+        assertTrue(ch.writeOutbound(response));
+
+        Http2HeadersFrame headersFrame = ch.readOutbound();
+        assertThat(headersFrame.headers().status().toString(), is("200"));
+        assertFalse(headersFrame.isEndStream());
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeChunk() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        ByteBuf hello = Unpooled.copiedBuffer("hello world", CharsetUtil.UTF_8);
+        HttpContent content = new DefaultHttpContent(hello);
+        assertTrue(ch.writeOutbound(content));
+
+        Http2DataFrame dataFrame = ch.readOutbound();
+        try {
+            assertThat(dataFrame.content().toString(CharsetUtil.UTF_8), is("hello world"));
+            assertFalse(dataFrame.isEndStream());
+        } finally {
+            dataFrame.release();
+        }
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeEmptyEnd() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        LastHttpContent end = LastHttpContent.EMPTY_LAST_CONTENT;
+        assertTrue(ch.writeOutbound(end));
+
+        Http2DataFrame emptyFrame = ch.readOutbound();
+        try {
+            assertThat(emptyFrame.content().readableBytes(), is(0));
+            assertTrue(emptyFrame.isEndStream());
+        } finally {
+            emptyFrame.release();
+        }
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeDataEnd() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        ByteBuf hello = Unpooled.copiedBuffer("hello world", CharsetUtil.UTF_8);
+        LastHttpContent end = new DefaultLastHttpContent(hello, true);
+        assertTrue(ch.writeOutbound(end));
+
+        Http2DataFrame dataFrame = ch.readOutbound();
+        try {
+            assertThat(dataFrame.content().toString(CharsetUtil.UTF_8), is("hello world"));
+            assertTrue(dataFrame.isEndStream());
+        } finally {
+            dataFrame.release();
+        }
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeTrailers() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        LastHttpContent trailers = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, true);
+        HttpHeaders headers = trailers.trailingHeaders();
+        headers.set("key", "value");
+        assertTrue(ch.writeOutbound(trailers));
+
+        Http2HeadersFrame headerFrame = ch.readOutbound();
+        assertThat(headerFrame.headers().get("key").toString(), is("value"));
+        assertTrue(headerFrame.isEndStream());
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testUpgradeDataEndWithTrailers() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        ByteBuf hello = Unpooled.copiedBuffer("hello world", CharsetUtil.UTF_8);
+        LastHttpContent trailers = new DefaultLastHttpContent(hello, true);
+        HttpHeaders headers = trailers.trailingHeaders();
+        headers.set("key", "value");
+        assertTrue(ch.writeOutbound(trailers));
+
+        Http2DataFrame dataFrame = ch.readOutbound();
+        try {
+            assertThat(dataFrame.content().toString(CharsetUtil.UTF_8), is("hello world"));
+            assertFalse(dataFrame.isEndStream());
+        } finally {
+            dataFrame.release();
+        }
+
+        Http2HeadersFrame headerFrame = ch.readOutbound();
+        assertThat(headerFrame.headers().get("key").toString(), is("value"));
+        assertTrue(headerFrame.isEndStream());
+
+        assertThat(ch.readOutbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testDowngradeHeaders() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        Http2Headers headers = new DefaultHttp2Headers();
+        headers.path("/");
+        headers.method("GET");
+
+        assertTrue(ch.writeInbound(new DefaultHttp2HeadersFrame(headers)));
+
+        HttpRequest request = ch.readInbound();
+        assertThat(request.uri(), is("/"));
+        assertThat(request.method(), is(HttpMethod.GET));
+        assertThat(request.protocolVersion(), is(HttpVersion.HTTP_1_1));
+        assertFalse(request instanceof FullHttpRequest);
+
+        assertThat(ch.readInbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testDowngradeFullHeaders() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        Http2Headers headers = new DefaultHttp2Headers();
+        headers.path("/");
+        headers.method("GET");
+
+        assertTrue(ch.writeInbound(new DefaultHttp2HeadersFrame(headers, true)));
+
+        FullHttpRequest request = ch.readInbound();
+        try {
+            assertThat(request.uri(), is("/"));
+            assertThat(request.method(), is(HttpMethod.GET));
+            assertThat(request.protocolVersion(), is(HttpVersion.HTTP_1_1));
+            assertThat(request.content().readableBytes(), is(0));
+            assertTrue(request.trailingHeaders().isEmpty());
+        } finally {
+            request.release();
+        }
+
+        assertThat(ch.readInbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testDowngradeTrailers() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        Http2Headers headers = new DefaultHttp2Headers();
+        headers.set("key", "value");
+        assertTrue(ch.writeInbound(new DefaultHttp2HeadersFrame(headers, true)));
+
+        LastHttpContent trailers = ch.readInbound();
+        try {
+            assertThat(trailers.content().readableBytes(), is(0));
+            assertThat(trailers.trailingHeaders().get("key").toString(), is("value"));
+            assertFalse(trailers instanceof FullHttpRequest);
+        } finally {
+            trailers.release();
+        }
+
+        assertThat(ch.readInbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testDowngradeData() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        ByteBuf hello = Unpooled.copiedBuffer("hello world", CharsetUtil.UTF_8);
+        assertTrue(ch.writeInbound(new DefaultHttp2DataFrame(hello)));
+
+        HttpContent content = ch.readInbound();
+        try {
+            assertThat(content.content().toString(CharsetUtil.UTF_8), is("hello world"));
+            assertFalse(content instanceof LastHttpContent);
+        } finally {
+            content.release();
+        }
+
+        assertThat(ch.readInbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testDowngradeEndData() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        ByteBuf hello = Unpooled.copiedBuffer("hello world", CharsetUtil.UTF_8);
+        assertTrue(ch.writeInbound(new DefaultHttp2DataFrame(hello, true)));
+
+        LastHttpContent content = ch.readInbound();
+        try {
+            assertThat(content.content().toString(CharsetUtil.UTF_8), is("hello world"));
+            assertTrue(content.trailingHeaders().isEmpty());
+        } finally {
+            content.release();
+        }
+
+        assertThat(ch.readInbound(), is(nullValue()));
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testPassThroughOther() throws Exception {
+        EmbeddedChannel ch = new EmbeddedChannel(new Http2ServerDowngrader());
+        Http2ResetFrame reset = new DefaultHttp2ResetFrame(0);
+        Http2GoAwayFrame goaway = new DefaultHttp2GoAwayFrame(0);
+        assertTrue(ch.writeInbound(reset));
+        assertTrue(ch.writeInbound(goaway.retain()));
+
+        assertEquals(reset, ch.readInbound());
+
+        Http2GoAwayFrame frame = ch.readInbound();
+        try {
+            assertEquals(goaway, frame);
+            assertThat(ch.readInbound(), is(nullValue()));
+            assertFalse(ch.finish());
+        } finally {
+            goaway.release();
+            frame.release();
+        }
+    }
+}
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java
index e79742a82696..01baf4b2454c 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java
@@ -267,7 +267,7 @@ public void clientRequestOneDataFrame() throws Exception {
                 @Override
                 public void run() {
                     clientHandler.encoder().writeHeaders(ctxClient(), 3, http2Headers, 0, false, newPromiseClient());
-                    clientHandler.encoder().writeData(ctxClient(), 3, content.duplicate().retain(), 0, true,
+                    clientHandler.encoder().writeData(ctxClient(), 3, content.retainedDuplicate(), 0, true,
                                                       newPromiseClient());
                     clientChannel.flush();
                 }
@@ -300,10 +300,11 @@ public void clientRequestMultipleDataFrames() throws Exception {
                 @Override
                 public void run() {
                     clientHandler.encoder().writeHeaders(ctxClient(), 3, http2Headers, 0, false, newPromiseClient());
-                    clientHandler.encoder().writeData(ctxClient(), 3, content.slice(0, midPoint).retain(), 0, false,
-                            newPromiseClient());
-                    clientHandler.encoder().writeData(ctxClient(), 3,
-                            content.slice(midPoint, text.length() - midPoint).retain(), 0, true, newPromiseClient());
+                    clientHandler.encoder().writeData(
+                            ctxClient(), 3, content.retainedSlice(0, midPoint), 0, false, newPromiseClient());
+                    clientHandler.encoder().writeData(
+                            ctxClient(), 3, content.retainedSlice(midPoint, text.length() - midPoint),
+                            0, true, newPromiseClient());
                     clientChannel.flush();
                 }
             });
@@ -417,7 +418,7 @@ public void clientRequestTrailingHeaders() throws Exception {
                 @Override
                 public void run() {
                     clientHandler.encoder().writeHeaders(ctxClient(), 3, http2Headers, 0, false, newPromiseClient());
-                    clientHandler.encoder().writeData(ctxClient(), 3, content.duplicate().retain(), 0, false,
+                    clientHandler.encoder().writeData(ctxClient(), 3, content.retainedDuplicate(), 0, false,
                                                       newPromiseClient());
                     clientHandler.encoder().writeHeaders(ctxClient(), 3, http2Headers2, 0, true, newPromiseClient());
                     clientChannel.flush();
@@ -464,9 +465,9 @@ public void run() {
                     clientHandler.encoder().writeHeaders(ctxClient(), 5, http2Headers2, 0, false, newPromiseClient());
                     clientChannel.flush(); // Headers are queued in the flow controller and so flush them.
                     clientHandler.encoder().writePriority(ctxClient(), 5, 3, (short) 123, true, newPromiseClient());
-                    clientHandler.encoder().writeData(ctxClient(), 3, content.duplicate().retain(), 0, true,
+                    clientHandler.encoder().writeData(ctxClient(), 3, content.retainedDuplicate(), 0, true,
                                                       newPromiseClient());
-                    clientHandler.encoder().writeData(ctxClient(), 5, content2.duplicate().retain(), 0, true,
+                    clientHandler.encoder().writeData(ctxClient(), 5, content2.retainedDuplicate(), 0, true,
                                                       newPromiseClient());
                     clientChannel.flush();
                 }
@@ -518,9 +519,9 @@ public void clientRequestStreamDependencyOutsideHttpMessageFlow() throws Excepti
                 public void run() {
                     clientHandler.encoder().writeHeaders(ctxClient(), 3, http2Headers, 0, false, newPromiseClient());
                     clientHandler.encoder().writeHeaders(ctxClient(), 5, http2Headers2, 0, false, newPromiseClient());
-                    clientHandler.encoder().writeData(ctxClient(), 3, content.duplicate().retain(), 0, true,
+                    clientHandler.encoder().writeData(ctxClient(), 3, content.retainedDuplicate(), 0, true,
                                                       newPromiseClient());
-                    clientHandler.encoder().writeData(ctxClient(), 5, content2.duplicate().retain(), 0, true,
+                    clientHandler.encoder().writeData(ctxClient(), 5, content2.retainedDuplicate(), 0, true,
                                                       newPromiseClient());
                     clientChannel.flush(); // headers and data are queued in the flow controller, so flush them.
                     clientHandler.encoder().writePriority(ctxClient(), 5, 3, (short) 222, false, newPromiseClient());
@@ -592,9 +593,9 @@ public void run() {
                 public void run() {
                     serverHandler.encoder().writeHeaders(ctxServer(), 3, http2Headers, 0, false, newPromiseServer());
                     serverHandler.encoder().writePushPromise(ctxServer(), 3, 2, http2Headers2, 0, newPromiseServer());
-                    serverHandler.encoder().writeData(ctxServer(), 3, content.duplicate().retain(), 0, true,
+                    serverHandler.encoder().writeData(ctxServer(), 3, content.retainedDuplicate(), 0, true,
                                                       newPromiseServer());
-                    serverHandler.encoder().writeData(ctxServer(), 5, content2.duplicate().retain(), 0, true,
+                    serverHandler.encoder().writeData(ctxServer(), 5, content2.retainedDuplicate(), 0, true,
                                                       newPromiseServer());
                     serverConnectedChannel.flush();
                 }
@@ -627,7 +628,7 @@ public void serverResponseHeaderInformational() throws Exception {
         final FullHttpMessage response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE);
         final String text = "a big payload";
         final ByteBuf payload = Unpooled.copiedBuffer(text.getBytes());
-        final FullHttpMessage request2 = request.copy(payload);
+        final FullHttpMessage request2 = request.replace(payload);
         final FullHttpMessage response2 = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
 
         try {
@@ -660,7 +661,7 @@ public void run() {
             runInChannel(clientChannel, new Http2Runnable() {
                 @Override
                 public void run() {
-                    clientHandler.encoder().writeData(ctxClient(), 3, payload.duplicate().retain(), 0, true,
+                    clientHandler.encoder().writeData(ctxClient(), 3, payload.retainedDuplicate(), 0, true,
                                                       newPromiseClient());
                     clientChannel.flush();
                 }
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributorTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributorTest.java
index 9c4055e0c2ae..276f18a3e8a2 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributorTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributorTest.java
@@ -798,7 +798,7 @@ public void bytesDistributedWithAdditionShouldBeCorrect() throws Http2Exception
     }
 
     /**
-     * In this test, we close an internal stream in the priority tree but tree should not change.
+     * In this test, we close an internal stream in the priority tree.
      *
      * <pre>
      *         0
@@ -807,6 +807,13 @@ public void bytesDistributedWithAdditionShouldBeCorrect() throws Http2Exception
      *      / \
      *     C   D
      * </pre>
+     *
+     * After the close:
+     * <pre>
+     *          0
+     *        / | \
+     *       C  D  B
+     * </pre>
      */
     @Test
     public void bytesDistributedShouldBeCorrectWithInternalStreamClose() throws Http2Exception {
@@ -819,8 +826,7 @@ public void bytesDistributedShouldBeCorrectWithInternalStreamClose() throws Http
 
         assertTrue(write(500));
         verifyNeverWrite(STREAM_A);
-        assertEquals(200, captureWrites(STREAM_B));
-        assertEquals(300, captureWrites(STREAM_C) + captureWrites(STREAM_D));
+        assertEquals(500, captureWrites(STREAM_B) + captureWrites(STREAM_C) + captureWrites(STREAM_D));
 
         assertFalse(write(1300));
         verifyNeverWrite(STREAM_A);
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/DecoderTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/DecoderTest.java
similarity index 81%
rename from codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/DecoderTest.java
rename to codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/DecoderTest.java
index 4a3d60b535f7..e652881fc914 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/DecoderTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/DecoderTest.java
@@ -29,9 +29,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
-import static io.netty.handler.codec.http2.hpack.HpackUtil.ISO_8859_1;
+import io.netty.util.CharsetUtil;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+import static io.netty.util.internal.EmptyArrays.EMPTY_BYTES;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -41,12 +48,6 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
 public class DecoderTest {
 
     private static final int MAX_HEADER_SIZE = 8192;
@@ -60,12 +61,17 @@ private static String hex(String s) {
     }
 
     private static byte[] getBytes(String s) {
-        return s.getBytes(ISO_8859_1);
+        return s.getBytes(CharsetUtil.ISO_8859_1);
     }
 
     private void decode(String encoded) throws IOException {
         byte[] b = Hex.decodeHex(encoded.toCharArray());
-        decoder.decode(new ByteArrayInputStream(b), mockListener);
+        ByteArrayInputStream in = new ByteArrayInputStream(b);
+        try {
+            decoder.decode(in, mockListener);
+        } finally {
+            in.close();
+        }
     }
 
     @Before
@@ -74,15 +80,64 @@ public void setUp() {
         mockListener = mock(HeaderListener.class);
     }
 
+    @Test
+    public void testLiteralHuffmanEncodedWithEmptyNameAndValue() throws IOException {
+        byte[] input = {0, (byte) 0x80, 0};
+        ByteArrayInputStream in = new ByteArrayInputStream(input);
+        try {
+            decoder.decode(in, mockListener);
+            verify(mockListener, times(1)).addHeader(EMPTY_BYTES, EMPTY_BYTES, false);
+        } finally {
+            in.close();
+        }
+    }
+
+    @Test(expected = IOException.class)
+    public void testLiteralHuffmanEncodedWithPaddingGreaterThan7Throws() throws IOException {
+        byte[] input = {0, (byte) 0x81, -1};
+        ByteArrayInputStream in = new ByteArrayInputStream(input);
+        try {
+            decoder.decode(in, mockListener);
+        } finally {
+            in.close();
+        }
+    }
+
+    @Test(expected = IOException.class)
+    public void testLiteralHuffmanEncodedWithDecodingEOSThrows() throws IOException {
+        byte[] input = {0, (byte) 0x84, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF};
+        ByteArrayInputStream in = new ByteArrayInputStream(input);
+        try {
+            decoder.decode(in, mockListener);
+        } finally {
+            in.close();
+        }
+    }
+
+    @Test(expected = IOException.class)
+    public void testLiteralHuffmanEncodedWithPaddingNotCorrespondingToMSBThrows() throws IOException {
+        byte[] input = {0, (byte) 0x81, 0};
+        ByteArrayInputStream in = new ByteArrayInputStream(input);
+        try {
+            decoder.decode(in, mockListener);
+        } finally {
+            in.close();
+        }
+    }
+
     @Test
     public void testIncompleteIndex() throws IOException {
         // Verify incomplete indices are unread
         byte[] compressed = Hex.decodeHex("FFF0".toCharArray());
         ByteArrayInputStream in = new ByteArrayInputStream(compressed);
-        decoder.decode(in, mockListener);
-        assertEquals(1, in.available());
-        decoder.decode(in, mockListener);
-        assertEquals(1, in.available());
+        try {
+            decoder.decode(in, mockListener);
+            assertEquals(1, in.available());
+            decoder.decode(in, mockListener);
+            assertEquals(1, in.available());
+        } finally {
+            in.close();
+        }
     }
 
     @Test(expected = IOException.class)
@@ -151,9 +206,10 @@ public void testMissingDynamicTableSizeUpdate() throws Exception {
         decode("81");
     }
 
-    @Test(expected = IOException.class)
+    @Test
     public void testLiteralWithIncrementalIndexingWithEmptyName() throws Exception {
-        decode("000005" + hex("value"));
+        decode("400005" + hex("value"));
+        verify(mockListener, times(1)).addHeader(EMPTY_BYTES, getBytes("value"), false);
     }
 
     @Test
@@ -229,9 +285,10 @@ public void testLiteralWithIncrementalIndexingWithLargeValue() throws Exception
         verifyNoMoreInteractions(mockListener);
     }
 
-    @Test(expected = IOException.class)
+    @Test
     public void testLiteralWithoutIndexingWithEmptyName() throws Exception {
         decode("000005" + hex("value"));
+        verify(mockListener, times(1)).addHeader(EMPTY_BYTES, getBytes("value"), false);
     }
 
     @Test(expected = IOException.class)
@@ -273,9 +330,10 @@ public void testLiteralWithoutIndexingWithLargeValue() throws Exception {
         decode("BE");
     }
 
-    @Test(expected = IOException.class)
+    @Test
     public void testLiteralNeverIndexedWithEmptyName() throws Exception {
         decode("100005" + hex("value"));
+        verify(mockListener, times(1)).addHeader(EMPTY_BYTES, getBytes("value"), true);
     }
 
     @Test(expected = IOException.class)
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/Hex.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/Hex.java
similarity index 99%
rename from codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/Hex.java
rename to codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/Hex.java
index f97561e163b2..8144d07b7170 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/Hex.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/Hex.java
@@ -31,7 +31,7 @@
  * limitations under the License.
  */
 
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import java.io.IOException;
 
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/HpackTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/HpackTest.java
similarity index 92%
rename from codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/HpackTest.java
rename to codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/HpackTest.java
index 794260eea70f..10ad360ec93a 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/HpackTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/HpackTest.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -45,7 +45,8 @@
 @RunWith(Parameterized.class)
 public class HpackTest {
 
-    private static final String TEST_DIR = "/io/netty/handler/codec/http2/hpack/testdata/";
+    private static final String TEST_DIR = '/' + HpackTest.class.getPackage().getName().replaceAll("\\.", "/")
+            + "/testdata/";
 
     private final String fileName;
 
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/HuffmanTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/HuffmanTest.java
similarity index 66%
rename from codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/HuffmanTest.java
rename to codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/HuffmanTest.java
index 09a0575db585..85f59f524f64 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/HuffmanTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/HuffmanTest.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import org.junit.Assert;
 import org.junit.Test;
@@ -72,14 +72,56 @@ public void testDecodeIllegalPadding() throws IOException {
         Huffman.DECODER.decode(buf);
     }
 
-    @Test//(expected = IOException.class) TODO(jpinner) fix me
+    @Test(expected = IOException.class)
     public void testDecodeExtraPadding() throws IOException {
-        byte[] buf = new byte[2];
-        buf[0] = 0x0F; // '1', 'EOS'
-        buf[1] = (byte) 0xFF; // 'EOS'
+        byte[] buf = makeBuf(0x0f, 0xFF); // '1', 'EOS'
+        Huffman.DECODER.decode(buf);
+    }
+
+    @Test(expected = IOException.class)
+    public void testDecodeExtraPadding1byte() throws IOException {
+        byte[] buf = makeBuf(0xFF);
+        Huffman.DECODER.decode(buf);
+    }
+
+    @Test(expected = IOException.class)
+    public void testDecodeExtraPadding2byte() throws IOException {
+        byte[] buf = makeBuf(0x1F, 0xFF); // 'a'
+        Huffman.DECODER.decode(buf);
+    }
+
+    @Test(expected = IOException.class)
+    public void testDecodeExtraPadding3byte() throws IOException {
+        byte[] buf = makeBuf(0x1F, 0xFF, 0xFF); // 'a'
+        Huffman.DECODER.decode(buf);
+    }
+
+    @Test(expected = IOException.class)
+    public void testDecodeExtraPadding4byte() throws IOException {
+        byte[] buf = makeBuf(0x1F, 0xFF, 0xFF, 0xFF); // 'a'
+        Huffman.DECODER.decode(buf);
+    }
+
+    @Test(expected = IOException.class)
+    public void testDecodeExtraPadding29bit() throws IOException {
+        byte[] buf = makeBuf(0xFF, 0x9F, 0xFF, 0xFF, 0xFF);  // '|'
         Huffman.DECODER.decode(buf);
     }
 
+    @Test(expected = IOException.class)
+    public void testDecodePartialSymbol() throws IOException {
+        byte[] buf = makeBuf(0x52, 0xBC, 0x30, 0xFF, 0xFF, 0xFF, 0xFF); // " pFA\x00", 31 bits of padding, a.k.a. EOS
+        Huffman.DECODER.decode(buf);
+    }
+
+    private byte[] makeBuf(int ... bytes) {
+        byte[] buf = new byte[bytes.length];
+        for (int i = 0; i < buf.length; i++) {
+            buf[i] = (byte) bytes[i];
+        }
+        return buf;
+    }
+
     private void roundTrip(String s) throws IOException {
         roundTrip(Huffman.ENCODER, Huffman.DECODER, s);
     }
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/TestCase.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestCase.java
similarity index 99%
rename from codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/TestCase.java
rename to codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestCase.java
index 0177bb288aa6..9e5a2e6e8221 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/TestCase.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestCase.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import com.google.gson.FieldNamingPolicy;
 import com.google.gson.Gson;
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/TestHeaderListener.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestHeaderListener.java
similarity index 96%
rename from codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/TestHeaderListener.java
rename to codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestHeaderListener.java
index d8bf747f2ddd..6cd8db3fa80b 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/hpack/TestHeaderListener.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/internal/hpack/TestHeaderListener.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.handler.codec.http2.hpack;
+package io.netty.handler.codec.http2.internal.hpack;
 
 import java.util.List;
 
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testDuplicateHeaders.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testDuplicateHeaders.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testDuplicateHeaders.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testDuplicateHeaders.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testEmpty.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testEmpty.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testEmpty.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testEmpty.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testEviction.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testEviction.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testEviction.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testEviction.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testMaxHeaderTableSize.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testMaxHeaderTableSize.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testMaxHeaderTableSize.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testMaxHeaderTableSize.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC2_1.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC2_1.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC2_1.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC2_1.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC2_2.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC2_2.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC2_2.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC2_2.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC2_3.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC2_3.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC2_3.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC2_3.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC2_4.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC2_4.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC2_4.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC2_4.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC3.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC3.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC3.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC3.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC4.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC4.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC4.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC4.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC5.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC5.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC5.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC5.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC6.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC6.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testSpecExampleC6.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testSpecExampleC6.json
diff --git a/codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testStaticTableEntries.json b/codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testStaticTableEntries.json
similarity index 100%
rename from codec-http2/src/test/resources/io/netty/handler/codec/http2/hpack/testdata/testStaticTableEntries.json
rename to codec-http2/src/test/resources/io/netty/handler/codec/http2/internal/hpack/testdata/testStaticTableEntries.json
diff --git a/codec-memcache/pom.xml b/codec-memcache/pom.xml
index 1ce6c3515203..f33cda3a9ff9 100644
--- a/codec-memcache/pom.xml
+++ b/codec-memcache/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-memcache</artifactId>
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java
index edcf1ccbe003..2ac6c29fcd57 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java
@@ -17,10 +17,12 @@
 
 import io.netty.handler.codec.DecoderResult;
 import io.netty.util.AbstractReferenceCounted;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link MemcacheObject} implementation.
  */
+@UnstableApi
 public abstract class AbstractMemcacheObject extends AbstractReferenceCounted implements MemcacheObject {
 
     private DecoderResult decoderResult = DecoderResult.SUCCESS;
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java
index e8ae96a8e29a..6d330396a79e 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.MessageAggregator;
 import io.netty.handler.codec.memcache.binary.BinaryMemcacheRequestDecoder;
 import io.netty.handler.codec.memcache.binary.BinaryMemcacheResponseEncoder;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link ChannelHandler} that aggregates an {@link MemcacheMessage}
@@ -41,6 +42,7 @@
  * p.addLast("handler", new YourMemcacheRequestHandler());
  * </pre>
  */
+@UnstableApi
 public abstract class AbstractMemcacheObjectAggregator<H extends MemcacheMessage> extends
         MessageAggregator<MemcacheObject, H, MemcacheContent, FullMemcacheMessage> {
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java
index 3aff4bf96107..891c3c928fe6 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectDecoder.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.memcache;
 
 import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Abstract super class for both ascii and binary decoders.
@@ -23,5 +24,6 @@
  * Currently it just acts as a common denominator, but will certainly include methods once the ascii protocol
  * is implemented.
  */
+@UnstableApi
 public abstract class AbstractMemcacheObjectDecoder extends ByteToMessageDecoder {
 }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java
index b209fcd11094..8cbf4b3f40f0 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java
@@ -21,6 +21,7 @@
 import io.netty.channel.FileRegion;
 import io.netty.handler.codec.MessageToMessageEncoder;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -31,6 +32,7 @@
  * require different treatment of their messages. Since the content chunk writing is the same for both, the encoder
  * abstracts this right away.</p>
  */
+@UnstableApi
 public abstract class AbstractMemcacheObjectEncoder<M extends MemcacheMessage> extends MessageToMessageEncoder<Object> {
 
     private boolean expectingMoreContent;
@@ -45,7 +47,6 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
             @SuppressWarnings({ "unchecked", "CastConflictsWithInstanceof" })
             final M m = (M) msg;
             out.add(encodeMessage(ctx, m));
-            return;
         }
 
         if (msg instanceof MemcacheContent || msg instanceof ByteBuf || msg instanceof FileRegion) {
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java
index 67854278788e..5b5c8ba03f09 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultLastMemcacheContent.java
@@ -18,10 +18,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default implementation for the {@link LastMemcacheContent}.
  */
+@UnstableApi
 public class DefaultLastMemcacheContent extends DefaultMemcacheContent implements LastMemcacheContent {
 
     public DefaultLastMemcacheContent() {
@@ -58,11 +60,21 @@ public LastMemcacheContent touch(Object hint) {
 
     @Override
     public LastMemcacheContent copy() {
-        return new DefaultLastMemcacheContent(content().copy());
+        return replace(content().copy());
     }
 
     @Override
     public LastMemcacheContent duplicate() {
-        return new DefaultLastMemcacheContent(content().duplicate());
+        return replace(content().duplicate());
+    }
+
+    @Override
+    public LastMemcacheContent retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public LastMemcacheContent replace(ByteBuf content) {
+        return new DefaultLastMemcacheContent(content);
     }
 }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java
index 748dc21724dd..1ff7bcd6bbb6 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default {@link MemcacheContent} implementation.
  */
+@UnstableApi
 public class DefaultMemcacheContent extends AbstractMemcacheObject implements MemcacheContent {
 
     private final ByteBuf content;
@@ -42,12 +44,22 @@ public ByteBuf content() {
 
     @Override
     public MemcacheContent copy() {
-        return new DefaultMemcacheContent(content.copy());
+        return replace(content.copy());
     }
 
     @Override
     public MemcacheContent duplicate() {
-        return new DefaultMemcacheContent(content.duplicate());
+        return replace(content.duplicate());
+    }
+
+    @Override
+    public MemcacheContent retainedDuplicate() {
+        return replace(content.retainedDuplicate());
+    }
+
+    @Override
+    public MemcacheContent replace(ByteBuf content) {
+        return new DefaultMemcacheContent(content);
     }
 
     @Override
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java
index 3ae0616b9d1f..5183b25afdea 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/FullMemcacheMessage.java
@@ -15,15 +15,28 @@
  */
 package io.netty.handler.codec.memcache;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Combines {@link MemcacheMessage} and {@link LastMemcacheContent} into one
  * message. So it represent a <i>complete</i> memcache message.
  */
+@UnstableApi
 public interface FullMemcacheMessage extends MemcacheMessage, LastMemcacheContent {
 
     @Override
     FullMemcacheMessage copy();
 
+    @Override
+    FullMemcacheMessage duplicate();
+
+    @Override
+    FullMemcacheMessage retainedDuplicate();
+
+    @Override
+    FullMemcacheMessage replace(ByteBuf content);
+
     @Override
     FullMemcacheMessage retain(int increment);
 
@@ -35,7 +48,4 @@ public interface FullMemcacheMessage extends MemcacheMessage, LastMemcacheConten
 
     @Override
     FullMemcacheMessage touch(Object hint);
-
-    @Override
-    FullMemcacheMessage duplicate();
 }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java
index 0b20bdd2c626..299784f342a8 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java
@@ -18,6 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.DecoderResult;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The {@link MemcacheContent} which signals the end of the content batch.
@@ -26,6 +27,7 @@
  * empty {@link LastMemcacheContent} is issued to make the upstream parsing
  * easier.
  */
+@UnstableApi
 public interface LastMemcacheContent extends MemcacheContent {
 
     LastMemcacheContent EMPTY_LAST_CONTENT = new LastMemcacheContent() {
@@ -36,27 +38,37 @@ public LastMemcacheContent copy() {
         }
 
         @Override
-        public LastMemcacheContent retain(int increment) {
+        public LastMemcacheContent duplicate() {
             return this;
         }
 
         @Override
-        public LastMemcacheContent retain() {
+        public LastMemcacheContent retainedDuplicate() {
             return this;
         }
 
         @Override
-        public LastMemcacheContent touch() {
+        public LastMemcacheContent replace(ByteBuf content) {
+            return new DefaultLastMemcacheContent(content);
+        }
+
+        @Override
+        public LastMemcacheContent retain(int increment) {
             return this;
         }
 
         @Override
-        public LastMemcacheContent touch(Object hint) {
+        public LastMemcacheContent retain() {
             return this;
         }
 
         @Override
-        public LastMemcacheContent duplicate() {
+        public LastMemcacheContent touch() {
+            return this;
+        }
+
+        @Override
+        public LastMemcacheContent touch(Object hint) {
             return this;
         }
 
@@ -94,6 +106,15 @@ public boolean release(int decrement) {
     @Override
     LastMemcacheContent copy();
 
+    @Override
+    LastMemcacheContent duplicate();
+
+    @Override
+    LastMemcacheContent retainedDuplicate();
+
+    @Override
+    LastMemcacheContent replace(ByteBuf content);
+
     @Override
     LastMemcacheContent retain(int increment);
 
@@ -105,7 +126,4 @@ public boolean release(int decrement) {
 
     @Override
     LastMemcacheContent touch(Object hint);
-
-    @Override
-    LastMemcacheContent duplicate();
 }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java
index 86466e838901..08f88946ec3e 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java
@@ -15,8 +15,10 @@
  */
 package io.netty.handler.codec.memcache;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
 import io.netty.channel.ChannelPipeline;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * An Memcache content chunk.
@@ -26,6 +28,7 @@
  * in your handler, place a aggregator after an implementation of the {@link AbstractMemcacheObjectDecoder}
  * in the {@link ChannelPipeline}.
  */
+@UnstableApi
 public interface MemcacheContent extends MemcacheObject, ByteBufHolder {
 
     @Override
@@ -34,6 +37,12 @@ public interface MemcacheContent extends MemcacheObject, ByteBufHolder {
     @Override
     MemcacheContent duplicate();
 
+    @Override
+    MemcacheContent retainedDuplicate();
+
+    @Override
+    MemcacheContent replace(ByteBuf content);
+
     @Override
     MemcacheContent retain();
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java
index fdc096a30177..420472dc2ea6 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheMessage.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.memcache;
 
 import io.netty.util.ReferenceCounted;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Marker interface for both ascii and binary messages.
  */
+@UnstableApi
 public interface MemcacheMessage extends MemcacheObject, ReferenceCounted {
 
     /**
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java
index 5cb072de2e3a..15da8df8d837 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java
@@ -16,8 +16,10 @@
 package io.netty.handler.codec.memcache;
 
 import io.netty.handler.codec.DecoderResultProvider;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Defines a common interface for all {@link MemcacheObject} implementations.
  */
+@UnstableApi
 public interface MemcacheObject extends DecoderResultProvider { }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java
index c09daec13d65..2c9038282991 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java
@@ -24,6 +24,7 @@
 import io.netty.handler.codec.memcache.DefaultMemcacheContent;
 import io.netty.handler.codec.memcache.LastMemcacheContent;
 import io.netty.handler.codec.memcache.MemcacheContent;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 
@@ -32,6 +33,7 @@
  * <p/>
  * The difference in the protocols (header) is implemented by the subclasses.
  */
+@UnstableApi
 public abstract class AbstractBinaryMemcacheDecoder<M extends BinaryMemcacheMessage>
     extends AbstractMemcacheObjectDecoder {
 
@@ -87,7 +89,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         return;
                     }
 
-                    currentMessage.setExtras(in.readSlice(extrasLength).retain());
+                    currentMessage.setExtras(in.readRetainedSlice(extrasLength));
                 }
 
                 state = State.READ_KEY;
@@ -103,7 +105,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         return;
                     }
 
-                    currentMessage.setKey(in.readSlice(keyLength).retain());
+                    currentMessage.setKey(in.readRetainedSlice(keyLength));
                 }
                 out.add(currentMessage.retain());
                 state = State.READ_CONTENT;
@@ -131,7 +133,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         toRead = remainingLength;
                     }
 
-                    ByteBuf chunkBuffer = in.readSlice(toRead).retain();
+                    ByteBuf chunkBuffer = in.readRetainedSlice(toRead);
 
                     MemcacheContent chunk;
                     if ((alreadyReadChunkSize += toRead) >= valueLength) {
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
index ad06e8c2bfb2..8e950f7a604c 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java
@@ -20,10 +20,12 @@
 import io.netty.handler.codec.MessageToByteEncoder;
 import io.netty.handler.codec.memcache.AbstractMemcacheObjectEncoder;
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link MessageToByteEncoder} that encodes binary memcache messages into bytes.
  */
+@UnstableApi
 public abstract class AbstractBinaryMemcacheEncoder<M extends BinaryMemcacheMessage>
     extends AbstractMemcacheObjectEncoder<M> {
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java
index ab270c2b26ea..c40ddf48d103 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.memcache.AbstractMemcacheObject;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Default implementation of a {@link BinaryMemcacheMessage}.
  */
+@UnstableApi
 public abstract class AbstractBinaryMemcacheMessage
     extends AbstractMemcacheObject
     implements BinaryMemcacheMessage {
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java
index 920cd20d2d52..b3f9a68086dc 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java
@@ -20,6 +20,7 @@
 import io.netty.channel.CombinedChannelDuplexHandler;
 import io.netty.handler.codec.PrematureChannelClosureException;
 import io.netty.handler.codec.memcache.LastMemcacheContent;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.List;
 import java.util.concurrent.atomic.AtomicLong;
@@ -35,6 +36,7 @@
  * content, which defaults to 8192. This chunk size is the maximum, so if smaller chunks arrive they
  * will be passed up the pipeline and not queued up to the chunk size.
  */
+@UnstableApi
 public final class BinaryMemcacheClientCodec extends
         CombinedChannelDuplexHandler<BinaryMemcacheResponseDecoder, BinaryMemcacheRequestEncoder> {
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java
index dc95f5143f3d..227e16014718 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.memcache.MemcacheMessage;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * An interface that defines a binary Memcache message, providing common properties for
@@ -28,6 +29,7 @@
  * @see BinaryMemcacheRequest
  * @see BinaryMemcacheResponse
  */
+@UnstableApi
 public interface BinaryMemcacheMessage extends MemcacheMessage {
 
     /**
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java
index c1f59e1e5530..388be337544a 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.memcache.FullMemcacheMessage;
 import io.netty.handler.codec.memcache.MemcacheContent;
 import io.netty.handler.codec.memcache.MemcacheObject;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * An object aggregator for the memcache binary protocol.
@@ -27,6 +28,7 @@
  * It aggregates {@link BinaryMemcacheMessage}s and {@link MemcacheContent} into {@link FullBinaryMemcacheRequest}s
  * or {@link FullBinaryMemcacheResponse}s.
  */
+@UnstableApi
 public class BinaryMemcacheObjectAggregator extends AbstractMemcacheObjectAggregator<BinaryMemcacheMessage> {
 
     public BinaryMemcacheObjectAggregator(int maxContentLength) {
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java
index 755c740bdc78..f77b50ab5033 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java
@@ -15,12 +15,15 @@
  */
 package io.netty.handler.codec.memcache.binary;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Represents all Opcodes that can occur in a {@link BinaryMemcacheMessage}.
  * <p/>
  * This class can be extended if a custom application needs to implement a superset of the normally supported
  * operations by a vanilla memcached protocol.
  */
+@UnstableApi
 public final class BinaryMemcacheOpcodes {
 
     private BinaryMemcacheOpcodes() {
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java
index 87a9cf4d84db..9df0649f34b9 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequest.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.memcache.binary;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Represents a full {@link BinaryMemcacheRequest}, which contains the header and optional key and extras.
  */
+@UnstableApi
 public interface BinaryMemcacheRequest extends BinaryMemcacheMessage {
 
     /**
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
index e9f8ed65d5ef..900c8d467f9c 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestDecoder.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The decoder part which takes care of decoding the request-specific headers.
  */
+@UnstableApi
 public class BinaryMemcacheRequestDecoder
     extends AbstractBinaryMemcacheDecoder<BinaryMemcacheRequest> {
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java
index c4261ebe1133..1c68a6d9d89d 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheRequestEncoder.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.memcache.binary;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The encoder part which takes care of encoding the request headers.
  */
+@UnstableApi
 public class BinaryMemcacheRequestEncoder
     extends AbstractBinaryMemcacheEncoder<BinaryMemcacheRequest> {
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java
index 3adfbce5caab..6ba81eebc3b2 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponse.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.memcache.binary;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Represents a full {@link BinaryMemcacheResponse}, which contains the header and optional key and extras.
  */
+@UnstableApi
 public interface BinaryMemcacheResponse extends BinaryMemcacheMessage {
 
     /**
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
index 1bd891b6bda9..28d8da45fefb 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseDecoder.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The decoder which takes care of decoding the response headers.
  */
+@UnstableApi
 public class BinaryMemcacheResponseDecoder
     extends AbstractBinaryMemcacheDecoder<BinaryMemcacheResponse> {
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java
index c9f2c506a8b4..7326c84a0a80 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseEncoder.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.memcache.binary;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The encoder which takes care of encoding the response headers.
  */
+@UnstableApi
 public class BinaryMemcacheResponseEncoder
     extends AbstractBinaryMemcacheEncoder<BinaryMemcacheResponse> {
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java
index f2599cee8a7d..45df9d421efd 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheResponseStatus.java
@@ -15,9 +15,12 @@
  */
 package io.netty.handler.codec.memcache.binary;
 
+import io.netty.util.internal.UnstableApi;
+
 /**
  * Contains all possible status values a {@link BinaryMemcacheResponse} can return.
  */
+@UnstableApi
 public final class BinaryMemcacheResponseStatus {
 
     private BinaryMemcacheResponseStatus() {
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java
index ffe29284d8fb..5323b176d1b5 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.memcache.binary;
 
 import io.netty.channel.CombinedChannelDuplexHandler;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The full server codec that combines the correct encoder and decoder.
@@ -24,6 +25,7 @@
  * Internally, it combines the {@link BinaryMemcacheRequestDecoder} and the
  * {@link BinaryMemcacheResponseEncoder} to request decoding and response encoding.
  */
+@UnstableApi
 public class BinaryMemcacheServerCodec extends
         CombinedChannelDuplexHandler<BinaryMemcacheRequestDecoder, BinaryMemcacheResponseEncoder> {
 
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java
index e370befc9b14..68feb03a30ee 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.memcache.binary;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default implementation of the {@link BinaryMemcacheRequest}.
  */
+@UnstableApi
 public class DefaultBinaryMemcacheRequest extends AbstractBinaryMemcacheMessage implements BinaryMemcacheRequest {
 
     /**
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java
index 57bcb09b4e99..b632dcea8494 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.memcache.binary;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default implementation of the {@link BinaryMemcacheResponse}.
  */
+@UnstableApi
 public class DefaultBinaryMemcacheResponse extends AbstractBinaryMemcacheMessage implements BinaryMemcacheResponse {
 
     /**
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java
index 89f759b589ef..dbc5bacbab46 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default implementation of a {@link FullBinaryMemcacheRequest}.
  */
+@UnstableApi
 public class DefaultFullBinaryMemcacheRequest extends DefaultBinaryMemcacheRequest
     implements FullBinaryMemcacheRequest {
 
@@ -115,4 +117,22 @@ public FullBinaryMemcacheRequest duplicate() {
         }
         return new DefaultFullBinaryMemcacheRequest(key, extras, content().duplicate());
     }
+
+    @Override
+    public FullBinaryMemcacheRequest retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public FullBinaryMemcacheRequest replace(ByteBuf content) {
+        ByteBuf key = key();
+        if (key != null) {
+            key = key.retainedDuplicate();
+        }
+        ByteBuf extras = extras();
+        if (extras != null) {
+            extras = extras.retainedDuplicate();
+        }
+        return new DefaultFullBinaryMemcacheRequest(key, extras, content);
+    }
 }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java
index 0f9d865ba01d..734cba8ffe9b 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheResponse.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The default implementation of a {@link FullBinaryMemcacheResponse}.
  */
+@UnstableApi
 public class DefaultFullBinaryMemcacheResponse extends DefaultBinaryMemcacheResponse
     implements FullBinaryMemcacheResponse {
 
@@ -115,4 +117,22 @@ public FullBinaryMemcacheResponse duplicate() {
         }
         return new DefaultFullBinaryMemcacheResponse(key, extras, content().duplicate());
     }
+
+    @Override
+    public FullBinaryMemcacheResponse retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public FullBinaryMemcacheResponse replace(ByteBuf content) {
+        ByteBuf key = key();
+        if (key != null) {
+            key = key.retainedDuplicate();
+        }
+        ByteBuf extras = extras();
+        if (extras != null) {
+            extras = extras.retainedDuplicate();
+        }
+        return new DefaultFullBinaryMemcacheResponse(key, extras, content);
+    }
 }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java
index 3fb26689117f..e47d665cd025 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheRequest.java
@@ -15,16 +15,28 @@
  */
 package io.netty.handler.codec.memcache.binary;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.memcache.FullMemcacheMessage;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link BinaryMemcacheRequest} that also includes the content.
  */
+@UnstableApi
 public interface FullBinaryMemcacheRequest extends BinaryMemcacheRequest, FullMemcacheMessage {
 
     @Override
     FullBinaryMemcacheRequest copy();
 
+    @Override
+    FullBinaryMemcacheRequest duplicate();
+
+    @Override
+    FullBinaryMemcacheRequest retainedDuplicate();
+
+    @Override
+    FullBinaryMemcacheRequest replace(ByteBuf content);
+
     @Override
     FullBinaryMemcacheRequest retain(int increment);
 
@@ -36,7 +48,4 @@ public interface FullBinaryMemcacheRequest extends BinaryMemcacheRequest, FullMe
 
     @Override
     FullBinaryMemcacheRequest touch(Object hint);
-
-    @Override
-    FullBinaryMemcacheRequest duplicate();
 }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java
index a4ff2376d6a0..0d8d148fd0b7 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/FullBinaryMemcacheResponse.java
@@ -15,16 +15,28 @@
  */
 package io.netty.handler.codec.memcache.binary;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.handler.codec.memcache.FullMemcacheMessage;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * A {@link BinaryMemcacheResponse} that also includes the content.
  */
+@UnstableApi
 public interface FullBinaryMemcacheResponse extends BinaryMemcacheResponse, FullMemcacheMessage {
 
     @Override
     FullBinaryMemcacheResponse copy();
 
+    @Override
+    FullBinaryMemcacheResponse duplicate();
+
+    @Override
+    FullBinaryMemcacheResponse retainedDuplicate();
+
+    @Override
+    FullBinaryMemcacheResponse replace(ByteBuf content);
+
     @Override
     FullBinaryMemcacheResponse retain(int increment);
 
@@ -36,7 +48,4 @@ public interface FullBinaryMemcacheResponse extends BinaryMemcacheResponse, Full
 
     @Override
     FullBinaryMemcacheResponse touch(Object hint);
-
-    @Override
-    FullBinaryMemcacheResponse duplicate();
 }
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java
index 9b5491358e62..e61bc1bb31d3 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/package-info.java
@@ -17,4 +17,7 @@
 /**
  * Implementations and Interfaces for the Memcache Binary protocol.
  */
+@UnstableApi
 package io.netty.handler.codec.memcache.binary;
+
+import io.netty.util.internal.UnstableApi;
diff --git a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java
index d04be91ce958..3419bd2a3f4a 100644
--- a/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java
+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/package-info.java
@@ -17,4 +17,7 @@
 /**
  * Common superset of ascii and binary classes.
  */
+@UnstableApi
 package io.netty.handler.codec.memcache;
+
+import io.netty.util.internal.UnstableApi;
diff --git a/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java
new file mode 100644
index 000000000000..ad41f49ae15f
--- /dev/null
+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.CharsetUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class FullMemcacheMessageRequestTest {
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(
+                new BinaryMemcacheRequestEncoder(),
+                new BinaryMemcacheRequestDecoder(),
+                new BinaryMemcacheObjectAggregator(1024));
+    }
+
+    @After
+    public void teardown() throws Exception {
+        assertFalse(channel.finish());
+    }
+
+    @Test
+    public void testEncodeDecode() throws Exception {
+        ByteBuf key = Unpooled.wrappedBuffer("key".getBytes(CharsetUtil.UTF_8));
+        ByteBuf content = Unpooled.wrappedBuffer("content".getBytes(CharsetUtil.UTF_8));
+        ByteBuf extras = Unpooled.wrappedBuffer("extras".getBytes(CharsetUtil.UTF_8));
+        FullBinaryMemcacheRequest req = new DefaultFullBinaryMemcacheRequest(key, extras, content);
+        assertTrue(channel.writeOutbound(req));
+        // header + content
+        assertEquals(2, channel.outboundMessages().size());
+        assertTrue(channel.writeInbound(channel.readOutbound(), channel.readOutbound()));
+
+        FullBinaryMemcacheRequest read = channel.readInbound();
+        assertEquals("key", read.key().toString(CharsetUtil.UTF_8));
+        assertEquals("content", read.content().toString(CharsetUtil.UTF_8));
+        assertEquals("extras", read.extras().toString(CharsetUtil.UTF_8));
+        read.release();
+    }
+}
diff --git a/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java
new file mode 100644
index 000000000000..f8bf7e4a0054
--- /dev/null
+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageResponseTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.memcache.binary;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.CharsetUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class FullMemcacheMessageResponseTest {
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(
+                new BinaryMemcacheResponseEncoder(),
+                new BinaryMemcacheResponseDecoder(),
+                new BinaryMemcacheObjectAggregator(1024));
+    }
+
+    @After
+    public void teardown() throws Exception {
+        assertFalse(channel.finish());
+    }
+
+    @Test
+    public void testEncodeDecode() throws Exception {
+        ByteBuf key = Unpooled.wrappedBuffer("key".getBytes(CharsetUtil.UTF_8));
+        ByteBuf content = Unpooled.wrappedBuffer("content".getBytes(CharsetUtil.UTF_8));
+        ByteBuf extras = Unpooled.wrappedBuffer("extras".getBytes(CharsetUtil.UTF_8));
+        FullBinaryMemcacheResponse resp = new DefaultFullBinaryMemcacheResponse(key, extras, content);
+        assertTrue(channel.writeOutbound(resp));
+        // header + content
+        assertEquals(2, channel.outboundMessages().size());
+        assertTrue(channel.writeInbound(channel.readOutbound(), channel.readOutbound()));
+
+        FullBinaryMemcacheResponse read = channel.readInbound();
+        assertEquals("key", read.key().toString(CharsetUtil.UTF_8));
+        assertEquals("content", read.content().toString(CharsetUtil.UTF_8));
+        assertEquals("extras", read.extras().toString(CharsetUtil.UTF_8));
+        read.release();
+    }
+}
diff --git a/codec-mqtt/pom.xml b/codec-mqtt/pom.xml
index 6f896a99f800..6c2ca7afcb7f 100644
--- a/codec-mqtt/pom.xml
+++ b/codec-mqtt/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-mqtt</artifactId>
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
index 453f82dab3ea..ad5cc5756fe8 100644
--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
@@ -26,7 +26,11 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static io.netty.handler.codec.mqtt.MqttCodecUtil.*;
+import static io.netty.handler.codec.mqtt.MqttCodecUtil.isValidClientId;
+import static io.netty.handler.codec.mqtt.MqttCodecUtil.isValidMessageId;
+import static io.netty.handler.codec.mqtt.MqttCodecUtil.isValidPublishTopicName;
+import static io.netty.handler.codec.mqtt.MqttCodecUtil.resetUnusedFields;
+import static io.netty.handler.codec.mqtt.MqttCodecUtil.validateFixedHeader;
 
 /**
  * Decodes Mqtt messages from bytes, following
@@ -409,7 +413,7 @@ private static Result<MqttUnsubscribePayload> decodeUnsubscribePayload(
     }
 
     private static Result<ByteBuf> decodePublishPayload(ByteBuf buffer, int bytesRemainingInVariablePart) {
-        ByteBuf b = buffer.readSlice(bytesRemainingInVariablePart).retain();
+        ByteBuf b = buffer.readRetainedSlice(bytesRemainingInVariablePart);
         return new Result<ByteBuf>(b, bytesRemainingInVariablePart);
     }
 
diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishMessage.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishMessage.java
index 57f96665d76a..d86bda1725bd 100644
--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishMessage.java
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishMessage.java
@@ -53,12 +53,22 @@ public ByteBuf content() {
 
     @Override
     public MqttPublishMessage copy() {
-        return new MqttPublishMessage(fixedHeader(), variableHeader(), content().copy());
+        return replace(content().copy());
     }
 
     @Override
     public MqttPublishMessage duplicate() {
-        return new MqttPublishMessage(fixedHeader(), variableHeader(), content().duplicate());
+        return replace(content().duplicate());
+    }
+
+    @Override
+    public MqttPublishMessage retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public MqttPublishMessage replace(ByteBuf content) {
+        return new MqttPublishMessage(fixedHeader(), variableHeader(), content);
     }
 
     @Override
diff --git a/codec-redis/pom.xml b/codec-redis/pom.xml
new file mode 100644
index 000000000000..52ee32ce40e6
--- /dev/null
+++ b/codec-redis/pom.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2016 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>io.netty</groupId>
+    <artifactId>netty-parent</artifactId>
+    <version>4.1.0.Final</version>
+  </parent>
+
+  <artifactId>netty-codec-redis</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Netty/Codec/Redis</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+  </dependencies>
+
+</project>
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractStringRedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractStringRedisMessage.java
new file mode 100644
index 000000000000..880c4f325fa5
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractStringRedisMessage.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * Abstract class for Simple Strings or Errors.
+ */
+@UnstableApi
+public abstract class AbstractStringRedisMessage implements RedisMessage {
+
+    private final String content;
+
+    AbstractStringRedisMessage(String content) {
+        this.content = ObjectUtil.checkNotNull(content, "content");
+    }
+
+    /**
+     * Get string content of this {@link AbstractStringRedisMessage}.
+     *
+     * @return content of this message.
+     */
+    public final String content() {
+        return content;
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/ArrayHeaderRedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/ArrayHeaderRedisMessage.java
new file mode 100644
index 000000000000..7d469976483e
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/ArrayHeaderRedisMessage.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * Header of Redis Array Message.
+ */
+@UnstableApi
+public class ArrayHeaderRedisMessage implements RedisMessage {
+
+    private final long length;
+
+    /**
+     * Creates a {@link ArrayHeaderRedisMessage} for the given {@code length}.
+     */
+    public ArrayHeaderRedisMessage(long length) {
+        if (length < RedisConstants.NULL_VALUE) {
+            throw new RedisCodecException("length: " + length + " (expected: >= " + RedisConstants.NULL_VALUE + ")");
+        }
+        this.length = length;
+    }
+
+    /**
+     * Get length of this array object.
+     */
+    public final long length() {
+        return length;
+    }
+
+    /**
+     * Returns whether the content of this message is {@code null}.
+     *
+     * @return indicates whether the content of this message is {@code null}.
+     */
+    public boolean isNull() {
+        return length == RedisConstants.NULL_VALUE;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder(StringUtil.simpleClassName(this))
+                .append('[')
+                .append("length=")
+                .append(length)
+                .append(']').toString();
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/ArrayRedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/ArrayRedisMessage.java
new file mode 100644
index 000000000000..484871de8f8c
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/ArrayRedisMessage.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.AbstractReferenceCounted;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Arrays of <a href="http://redis.io/topics/protocol">RESP</a>.
+ */
+@UnstableApi
+public class ArrayRedisMessage extends AbstractReferenceCounted implements RedisMessage {
+
+    private final List<RedisMessage> children;
+
+    private ArrayRedisMessage() {
+        children = Collections.emptyList();
+    }
+
+    /**
+     * Creates a {@link ArrayRedisMessage} for the given {@code content}.
+     *
+     * @param children the children.
+     */
+    public ArrayRedisMessage(List<RedisMessage> children) {
+        // do not retain here. children are already retained when created.
+        this.children = ObjectUtil.checkNotNull(children, "children");
+    }
+
+    /**
+     * Get children of this Arrays. It can be null or empty.
+     *
+     * @return list of {@link RedisMessage}s.
+     */
+    public final List<RedisMessage> children() {
+        return children;
+    }
+
+    /**
+     * Returns whether the content of this message is {@code null}.
+     *
+     * @return indicates whether the content of this message is {@code null}.
+     */
+    public boolean isNull() {
+        return false;
+    }
+
+    @Override
+    protected void deallocate() {
+        for (RedisMessage msg : children) {
+            ReferenceCountUtil.release(msg);
+        }
+    }
+
+    @Override
+    public ArrayRedisMessage touch(Object hint) {
+        for (RedisMessage msg : children) {
+            ReferenceCountUtil.touch(msg);
+        }
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder(StringUtil.simpleClassName(this))
+                .append('[')
+                .append("children=")
+                .append(children.size())
+                .append(']').toString();
+    }
+
+    /**
+     * A predefined null array instance for {@link ArrayRedisMessage}.
+     */
+    public static final ArrayRedisMessage NULL_INSTANCE = new ArrayRedisMessage() {
+        @Override
+        public boolean isNull() {
+            return true;
+        }
+
+        @Override
+        public ArrayRedisMessage retain() {
+            return this;
+        }
+
+        @Override
+        public ArrayRedisMessage retain(int increment) {
+            return this;
+        }
+
+        @Override
+        public ArrayRedisMessage touch() {
+            return this;
+        }
+
+        @Override
+        public ArrayRedisMessage touch(Object hint) {
+            return this;
+        }
+
+        @Override
+        public boolean release() {
+            return false;
+        }
+
+        @Override
+        public boolean release(int decrement) {
+            return false;
+        }
+
+        @Override
+        public String toString() {
+            return "NullArrayRedisMessage";
+        }
+    };
+
+    /**
+     * A predefined empty array instance for {@link ArrayRedisMessage}.
+     */
+    public static final ArrayRedisMessage EMPTY_INSTANCE = new ArrayRedisMessage() {
+        @Override
+        public boolean isNull() {
+            return false;
+        }
+
+        @Override
+        public ArrayRedisMessage retain() {
+            return this;
+        }
+
+        @Override
+        public ArrayRedisMessage retain(int increment) {
+            return this;
+        }
+
+        @Override
+        public ArrayRedisMessage touch() {
+            return this;
+        }
+
+        @Override
+        public ArrayRedisMessage touch(Object hint) {
+            return this;
+        }
+
+        @Override
+        public boolean release() {
+            return false;
+        }
+
+        @Override
+        public boolean release(int decrement) {
+            return false;
+        }
+
+        @Override
+        public String toString() {
+            return "EmptyArrayRedisMessage";
+        }
+    };
+
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringHeaderRedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringHeaderRedisMessage.java
new file mode 100644
index 000000000000..25c0c58ce9a0
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringHeaderRedisMessage.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * The header of Bulk Strings in <a href="http://redis.io/topics/protocol">RESP</a>.
+ */
+@UnstableApi
+public class BulkStringHeaderRedisMessage implements RedisMessage {
+
+    private final int bulkStringLength;
+
+    /**
+     * Creates a {@link BulkStringHeaderRedisMessage}.
+     *
+     * @param bulkStringLength follow content length.
+     */
+    public BulkStringHeaderRedisMessage(int bulkStringLength) {
+        if (bulkStringLength <= 0) {
+            throw new RedisCodecException("bulkStringLength: " + bulkStringLength + " (expected: > 0)");
+        }
+        this.bulkStringLength = bulkStringLength;
+    }
+
+    /**
+     * Return {@code bulkStringLength} for this content.
+     */
+    public final int bulkStringLength() {
+        return bulkStringLength;
+    }
+
+    /**
+     * Returns whether the content of this message is {@code null}.
+     *
+     * @return indicates whether the content of this message is {@code null}.
+     */
+    public boolean isNull() {
+        return bulkStringLength == RedisConstants.NULL_VALUE;
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringRedisContent.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringRedisContent.java
new file mode 100644
index 000000000000..d22fd4b959e0
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringRedisContent.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufHolder;
+import io.netty.channel.ChannelPipeline;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * A chunk of bulk strings which is used for Redis chunked transfer-encoding.
+ * {@link RedisDecoder} generates {@link BulkStringRedisContent} after
+ * {@link BulkStringHeaderRedisMessage} when the content is large or the encoding of the content is chunked.
+ * If you prefer not to receive {@link BulkStringRedisContent} in your handler,
+ * place {@link RedisBulkStringAggregator} after {@link RedisDecoder} in the {@link ChannelPipeline}.
+ */
+@UnstableApi
+public interface BulkStringRedisContent extends RedisMessage, ByteBufHolder {
+
+    @Override
+    BulkStringRedisContent copy();
+
+    @Override
+    BulkStringRedisContent duplicate();
+
+    @Override
+    BulkStringRedisContent retainedDuplicate();
+
+    @Override
+    BulkStringRedisContent replace(ByteBuf content);
+
+    @Override
+    BulkStringRedisContent retain();
+
+    @Override
+    BulkStringRedisContent retain(int increment);
+
+    @Override
+    BulkStringRedisContent touch();
+
+    @Override
+    BulkStringRedisContent touch(Object hint);
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/DefaultBulkStringRedisContent.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/DefaultBulkStringRedisContent.java
new file mode 100644
index 000000000000..203a627f7f81
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/DefaultBulkStringRedisContent.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.DefaultByteBufHolder;
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * A default implementation of {@link BulkStringRedisContent}.
+ */
+@UnstableApi
+public class DefaultBulkStringRedisContent extends DefaultByteBufHolder implements BulkStringRedisContent {
+
+    /**
+     * Creates a {@link DefaultBulkStringRedisContent} for the given {@code content}.
+     *
+     * @param content the content, can be {@code null}.
+     */
+    public DefaultBulkStringRedisContent(ByteBuf content) {
+        super(content);
+    }
+
+    @Override
+    public BulkStringRedisContent copy() {
+        return (BulkStringRedisContent) super.copy();
+    }
+
+    @Override
+    public BulkStringRedisContent duplicate() {
+        return (BulkStringRedisContent) super.duplicate();
+    }
+
+    @Override
+    public BulkStringRedisContent retainedDuplicate() {
+        return (BulkStringRedisContent) super.retainedDuplicate();
+    }
+
+    @Override
+    public BulkStringRedisContent replace(ByteBuf content) {
+        return new DefaultBulkStringRedisContent(content);
+    }
+
+    @Override
+    public BulkStringRedisContent retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public BulkStringRedisContent retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public BulkStringRedisContent touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public BulkStringRedisContent touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder(StringUtil.simpleClassName(this))
+                .append('[')
+                .append("content=")
+                .append(content())
+                .append(']').toString();
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/DefaultLastBulkStringRedisContent.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/DefaultLastBulkStringRedisContent.java
new file mode 100644
index 000000000000..5a1e12455b15
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/DefaultLastBulkStringRedisContent.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * A default implementation for {@link LastBulkStringRedisContent}.
+ */
+@UnstableApi
+public final class DefaultLastBulkStringRedisContent extends DefaultBulkStringRedisContent
+        implements LastBulkStringRedisContent {
+
+    /**
+     * Creates a {@link DefaultLastBulkStringRedisContent} for the given {@code content}.
+     * @param content the content, can be {@code null}.
+     */
+    public DefaultLastBulkStringRedisContent(ByteBuf content) {
+        super(content);
+    }
+
+    @Override
+    public LastBulkStringRedisContent copy() {
+        return (LastBulkStringRedisContent) super.copy();
+    }
+
+    @Override
+    public LastBulkStringRedisContent duplicate() {
+        return (LastBulkStringRedisContent) super.duplicate();
+    }
+
+    @Override
+    public LastBulkStringRedisContent retainedDuplicate() {
+        return (LastBulkStringRedisContent) super.retainedDuplicate();
+    }
+
+    @Override
+    public LastBulkStringRedisContent replace(ByteBuf content) {
+        return new DefaultLastBulkStringRedisContent(content);
+    }
+
+    @Override
+    public LastBulkStringRedisContent retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public LastBulkStringRedisContent retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public LastBulkStringRedisContent touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public LastBulkStringRedisContent touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/ErrorRedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/ErrorRedisMessage.java
new file mode 100644
index 000000000000..5546fc68ea41
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/ErrorRedisMessage.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * Errors of <a href="http://redis.io/topics/protocol">RESP</a>.
+ */
+@UnstableApi
+public final class ErrorRedisMessage extends AbstractStringRedisMessage {
+
+    /**
+     * Creates a {@link ErrorRedisMessage} from {@code content}.
+     *
+     * @param content the message content, must not be {@code null}.
+     */
+    public ErrorRedisMessage(String content) {
+        super(content);
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder(StringUtil.simpleClassName(this))
+                .append('[')
+                .append("content=")
+                .append(content())
+                .append(']').toString();
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/FixedRedisMessagePool.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/FixedRedisMessagePool.java
new file mode 100644
index 000000000000..fc165fced188
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/FixedRedisMessagePool.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.util.CharsetUtil;
+import io.netty.util.collection.LongObjectHashMap;
+import io.netty.util.collection.LongObjectMap;
+import io.netty.util.internal.UnstableApi;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A default fixed redis message pool.
+ */
+@UnstableApi
+public final class FixedRedisMessagePool implements RedisMessagePool {
+
+    private static final String[] DEFAULT_SIMPLE_STRINGS = {
+            "OK",
+            "PONG",
+            "QUEUED",
+    };
+
+    private static final String[] DEFAULT_ERRORS = {
+            "ERR",
+            "ERR index out of range",
+            "ERR no such key",
+            "ERR source and destination objects are the same",
+            "ERR syntax error",
+            "BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.",
+            "BUSYKEY Target key name already exists.",
+            "EXECABORT Transaction discarded because of previous errors.",
+            "LOADING Redis is loading the dataset in memory",
+            "MASTERDOWN Link with MASTER is down and slave-serve-stale-data is set to 'no'.",
+            "MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. " +
+            "Commands that may modify the data set are disabled. Please check Redis logs for details " +
+            "about the error.",
+            "NOAUTH Authentication required.",
+            "NOREPLICAS Not enough good slaves to write.",
+            "NOSCRIPT No matching script. Please use EVAL.",
+            "OOM command not allowed when used memory > 'maxmemory'.",
+            "READONLY You can't write against a read only slave.",
+            "WRONGTYPE Operation against a key holding the wrong kind of value",
+    };
+
+    private static final long MIN_CACHED_INTEGER_NUMBER = RedisConstants.NULL_VALUE; // inclusive
+    private static final long MAX_CACHED_INTEGER_NUMBER = 128; // exclusive
+
+    // cached integer size cannot larger than `int` range because of Collection.
+    private static final int SIZE_CACHED_INTEGER_NUMBER = (int) (MAX_CACHED_INTEGER_NUMBER - MIN_CACHED_INTEGER_NUMBER);
+
+    /**
+     * A shared object for {@link FixedRedisMessagePool}.
+     */
+    public static final FixedRedisMessagePool INSTANCE = new FixedRedisMessagePool();
+
+    // internal caches.
+    private Map<ByteBuf, SimpleStringRedisMessage> byteBufToSimpleStrings;
+    private Map<String, SimpleStringRedisMessage> stringToSimpleStrings;
+    private Map<ByteBuf, ErrorRedisMessage> byteBufToErrors;
+    private Map<String, ErrorRedisMessage> stringToErrors;
+    private Map<ByteBuf, IntegerRedisMessage> byteBufToIntegers;
+    private LongObjectMap<IntegerRedisMessage> longToIntegers;
+    private LongObjectMap<byte[]> longToByteBufs;
+
+    /**
+     * Creates a {@link FixedRedisMessagePool} instance.
+     */
+    private FixedRedisMessagePool() {
+        byteBufToSimpleStrings = new HashMap<ByteBuf, SimpleStringRedisMessage>(DEFAULT_SIMPLE_STRINGS.length, 1.0f);
+        stringToSimpleStrings = new HashMap<String, SimpleStringRedisMessage>(DEFAULT_SIMPLE_STRINGS.length, 1.0f);
+        for (String message : DEFAULT_SIMPLE_STRINGS) {
+            ByteBuf key = Unpooled.unmodifiableBuffer(
+                    Unpooled.unreleasableBuffer(Unpooled.wrappedBuffer(message.getBytes(CharsetUtil.UTF_8))));
+            SimpleStringRedisMessage cached = new SimpleStringRedisMessage(message);
+            byteBufToSimpleStrings.put(key, cached);
+            stringToSimpleStrings.put(message, cached);
+        }
+
+        byteBufToErrors = new HashMap<ByteBuf, ErrorRedisMessage>(DEFAULT_ERRORS.length, 1.0f);
+        stringToErrors = new HashMap<String, ErrorRedisMessage>(DEFAULT_ERRORS.length, 1.0f);
+        for (String message : DEFAULT_ERRORS) {
+            ByteBuf key = Unpooled.unmodifiableBuffer(
+                    Unpooled.unreleasableBuffer(Unpooled.wrappedBuffer(message.getBytes(CharsetUtil.UTF_8))));
+            ErrorRedisMessage cached = new ErrorRedisMessage(message);
+            byteBufToErrors.put(key, cached);
+            stringToErrors.put(message, cached);
+        }
+
+        byteBufToIntegers = new HashMap<ByteBuf, IntegerRedisMessage>(SIZE_CACHED_INTEGER_NUMBER, 1.0f);
+        longToIntegers = new LongObjectHashMap<IntegerRedisMessage>(SIZE_CACHED_INTEGER_NUMBER, 1.0f);
+        longToByteBufs = new LongObjectHashMap<byte[]>(SIZE_CACHED_INTEGER_NUMBER, 1.0f);
+        for (long value = MIN_CACHED_INTEGER_NUMBER; value < MAX_CACHED_INTEGER_NUMBER; value++) {
+            byte[] keyBytes = RedisCodecUtil.longToAsciiBytes(value);
+            ByteBuf keyByteBuf = Unpooled.unmodifiableBuffer(Unpooled.unreleasableBuffer(
+                    Unpooled.wrappedBuffer(keyBytes)));
+            IntegerRedisMessage cached = new IntegerRedisMessage(value);
+            byteBufToIntegers.put(keyByteBuf, cached);
+            longToIntegers.put(value, cached);
+            longToByteBufs.put(value, keyBytes);
+        }
+    }
+
+    @Override
+    public SimpleStringRedisMessage getSimpleString(String content) {
+        return stringToSimpleStrings.get(content);
+    }
+
+    @Override
+    public SimpleStringRedisMessage getSimpleString(ByteBuf content) {
+        return byteBufToSimpleStrings.get(content);
+    }
+
+    @Override
+    public ErrorRedisMessage getError(String content) {
+        return stringToErrors.get(content);
+    }
+
+    @Override
+    public ErrorRedisMessage getError(ByteBuf content) {
+        return byteBufToErrors.get(content);
+    }
+
+    @Override
+    public IntegerRedisMessage getInteger(long value) {
+        return longToIntegers.get(value);
+    }
+
+    @Override
+    public IntegerRedisMessage getInteger(ByteBuf content) {
+        return byteBufToIntegers.get(content);
+    }
+
+    @Override
+    public byte[] getByteBufOfInteger(long value) {
+        return longToByteBufs.get(value);
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/FullBulkStringRedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/FullBulkStringRedisMessage.java
new file mode 100644
index 000000000000..e3123e25a244
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/FullBulkStringRedisMessage.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.DefaultByteBufHolder;
+import io.netty.buffer.Unpooled;
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * An aggregated bulk string of <a href="http://redis.io/topics/protocol">RESP</a>.
+ */
+@UnstableApi
+public class FullBulkStringRedisMessage extends DefaultByteBufHolder implements LastBulkStringRedisContent {
+
+    private FullBulkStringRedisMessage() {
+        this(Unpooled.EMPTY_BUFFER);
+    }
+
+    /**
+     * Creates a {@link FullBulkStringRedisMessage} for the given {@code content}.
+     *
+     * @param content the content, must not be {@code null}. If content is null or empty,
+     * use {@link FullBulkStringRedisMessage#NULL_INSTANCE} or {@link FullBulkStringRedisMessage#EMPTY_INSTANCE}
+     * instead of constructor.
+     */
+    public FullBulkStringRedisMessage(ByteBuf content) {
+        super(content);
+    }
+
+    /**
+     * Returns whether the content of this message is {@code null}.
+     *
+     * @return indicates whether the content of this message is {@code null}.
+     */
+    public boolean isNull() {
+        return false;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder(StringUtil.simpleClassName(this))
+                .append('[')
+                .append("content=")
+                .append(content())
+                .append(']').toString();
+    }
+
+    /**
+     * A predefined null instance of {@link FullBulkStringRedisMessage}.
+     */
+    public static final FullBulkStringRedisMessage NULL_INSTANCE = new FullBulkStringRedisMessage() {
+        @Override
+        public boolean isNull() {
+            return true;
+        }
+
+        @Override
+        public ByteBuf content() {
+            return Unpooled.EMPTY_BUFFER;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage copy() {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage duplicate() {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage retainedDuplicate() {
+            return this;
+        }
+
+        @Override
+        public int refCnt() {
+            return 1;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage retain() {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage retain(int increment) {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage touch() {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage touch(Object hint) {
+            return this;
+        }
+
+        @Override
+        public boolean release() {
+            return false;
+        }
+
+        @Override
+        public boolean release(int decrement) {
+            return false;
+        }
+    };
+
+    /**
+     * A predefined empty instance of {@link FullBulkStringRedisMessage}.
+     */
+    public static final FullBulkStringRedisMessage EMPTY_INSTANCE = new FullBulkStringRedisMessage() {
+        @Override
+        public ByteBuf content() {
+            return Unpooled.EMPTY_BUFFER;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage copy() {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage duplicate() {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage retainedDuplicate() {
+            return this;
+        }
+
+        @Override
+        public int refCnt() {
+            return 1;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage retain() {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage retain(int increment) {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage touch() {
+            return this;
+        }
+
+        @Override
+        public FullBulkStringRedisMessage touch(Object hint) {
+            return this;
+        }
+
+        @Override
+        public boolean release() {
+            return false;
+        }
+
+        @Override
+        public boolean release(int decrement) {
+            return false;
+        }
+    };
+
+    @Override
+    public FullBulkStringRedisMessage copy() {
+        return (FullBulkStringRedisMessage) super.copy();
+    }
+
+    @Override
+    public FullBulkStringRedisMessage duplicate() {
+        return (FullBulkStringRedisMessage) super.duplicate();
+    }
+
+    @Override
+    public FullBulkStringRedisMessage retainedDuplicate() {
+        return (FullBulkStringRedisMessage) super.retainedDuplicate();
+    }
+
+    @Override
+    public FullBulkStringRedisMessage replace(ByteBuf content) {
+        return new FullBulkStringRedisMessage(content);
+    }
+
+    @Override
+    public FullBulkStringRedisMessage retain() {
+        super.retain();
+        return this;
+    }
+
+    @Override
+    public FullBulkStringRedisMessage retain(int increment) {
+        super.retain(increment);
+        return this;
+    }
+
+    @Override
+    public FullBulkStringRedisMessage touch() {
+        super.touch();
+        return this;
+    }
+
+    @Override
+    public FullBulkStringRedisMessage touch(Object hint) {
+        super.touch(hint);
+        return this;
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/IntegerRedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/IntegerRedisMessage.java
new file mode 100644
index 000000000000..cc6813a3b16a
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/IntegerRedisMessage.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * Integers of <a href="http://redis.io/topics/protocol">RESP</a>.
+ */
+@UnstableApi
+public final class IntegerRedisMessage implements RedisMessage {
+
+    private final long value;
+
+    /**
+     * Creates a {@link IntegerRedisMessage} for the given {@code content}.
+     *
+     * @param value the message content.
+     */
+    public IntegerRedisMessage(long value) {
+        this.value = value;
+    }
+
+    /**
+     * Get long value of this {@link IntegerRedisMessage}.
+     *
+     * @return long value
+     */
+    public long value() {
+        return value;
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder(StringUtil.simpleClassName(this))
+                .append('[')
+                .append("value=")
+                .append(value)
+                .append(']').toString();
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/LastBulkStringRedisContent.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/LastBulkStringRedisContent.java
new file mode 100644
index 000000000000..b592fdf6bf3f
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/LastBulkStringRedisContent.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * A last chunk of Bulk Strings.
+ */
+@UnstableApi
+public interface LastBulkStringRedisContent extends BulkStringRedisContent {
+
+    /**
+     * The 'end of content' marker in chunked encoding.
+     */
+    LastBulkStringRedisContent EMPTY_LAST_CONTENT = new LastBulkStringRedisContent() {
+
+        @Override
+        public ByteBuf content() {
+            return Unpooled.EMPTY_BUFFER;
+        }
+
+        @Override
+        public LastBulkStringRedisContent copy() {
+            return this;
+        }
+
+        @Override
+        public LastBulkStringRedisContent duplicate() {
+            return this;
+        }
+
+        @Override
+        public LastBulkStringRedisContent retainedDuplicate() {
+            return this;
+        }
+
+        @Override
+        public LastBulkStringRedisContent replace(ByteBuf content) {
+            return new DefaultLastBulkStringRedisContent(content);
+        }
+
+        @Override
+        public LastBulkStringRedisContent retain(int increment) {
+            return this;
+        }
+
+        @Override
+        public LastBulkStringRedisContent retain() {
+            return this;
+        }
+
+        @Override
+        public int refCnt() {
+            return 1;
+        }
+
+        @Override
+        public LastBulkStringRedisContent touch() {
+            return this;
+        }
+
+        @Override
+        public LastBulkStringRedisContent touch(Object hint) {
+            return this;
+        }
+
+        @Override
+        public boolean release() {
+            return false;
+        }
+
+        @Override
+        public boolean release(int decrement) {
+            return false;
+        }
+    };
+
+    @Override
+    LastBulkStringRedisContent copy();
+
+    @Override
+    LastBulkStringRedisContent duplicate();
+
+    @Override
+    LastBulkStringRedisContent retainedDuplicate();
+
+    @Override
+    LastBulkStringRedisContent replace(ByteBuf content);
+
+    @Override
+    LastBulkStringRedisContent retain();
+
+    @Override
+    LastBulkStringRedisContent retain(int increment);
+
+    @Override
+    LastBulkStringRedisContent touch();
+
+    @Override
+    LastBulkStringRedisContent touch(Object hint);
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisArrayAggregator.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisArrayAggregator.java
new file mode 100644
index 000000000000..d189ab2ea90e
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisArrayAggregator.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.CodecException;
+import io.netty.handler.codec.MessageToMessageDecoder;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.internal.UnstableApi;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
+
+/**
+ * Aggregates {@link RedisMessage} parts into {@link ArrayRedisMessage}. This decoder
+ * should be used together with {@link RedisDecoder}.
+ */
+@UnstableApi
+public final class RedisArrayAggregator extends MessageToMessageDecoder<RedisMessage> {
+
+    private final Deque<AggregateState> depths = new ArrayDeque<AggregateState>(4);
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, RedisMessage msg, List<Object> out) throws Exception {
+        if (msg instanceof ArrayHeaderRedisMessage) {
+            msg = decodeRedisArrayHeader((ArrayHeaderRedisMessage) msg);
+            if (msg == null) {
+                return;
+            }
+        } else {
+            ReferenceCountUtil.retain(msg);
+        }
+
+        while (!depths.isEmpty()) {
+            AggregateState current = depths.peek();
+            current.children.add(msg);
+
+            // if current aggregation completed, go to parent aggregation.
+            if (current.children.size() == current.length) {
+                msg = new ArrayRedisMessage(current.children);
+                depths.pop();
+            } else {
+                // not aggregated yet. try next time.
+                return;
+            }
+        }
+
+        out.add(msg);
+    }
+
+    private RedisMessage decodeRedisArrayHeader(ArrayHeaderRedisMessage header) {
+        if (header.isNull()) {
+            return ArrayRedisMessage.NULL_INSTANCE;
+        } else if (header.length() == 0L) {
+            return ArrayRedisMessage.EMPTY_INSTANCE;
+        } else if (header.length() > 0L) {
+            // Currently, this codec doesn't support `long` length for arrays because Java's List.size() is int.
+            if (header.length() > Integer.MAX_VALUE) {
+                throw new CodecException("this codec doesn't support longer length than " + Integer.MAX_VALUE);
+            }
+
+            // start aggregating array
+            depths.push(new AggregateState((int) header.length()));
+            return null;
+        } else {
+            throw new CodecException("bad length: " + header.length());
+        }
+    }
+
+    private static final class AggregateState {
+        private final int length;
+        private final List<RedisMessage> children;
+        AggregateState(int length) {
+            this.length = length;
+            this.children = new ArrayList<RedisMessage>(length);
+        }
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisBulkStringAggregator.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisBulkStringAggregator.java
new file mode 100644
index 000000000000..1b763b601906
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisBulkStringAggregator.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelPipeline;
+import io.netty.handler.codec.MessageAggregator;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * A {@link ChannelHandler} that aggregates an {@link BulkStringHeaderRedisMessage}
+ * and its following {@link BulkStringRedisContent}s into a single {@link FullBulkStringRedisMessage}
+ * with no following {@link BulkStringRedisContent}s.  It is useful when you don't want to take
+ * care of {@link RedisMessage}s whose transfer encoding is 'chunked'.  Insert this
+ * handler after {@link RedisDecoder} in the {@link ChannelPipeline}:
+ * <pre>
+ * {@link ChannelPipeline} p = ...;
+ * ...
+ * p.addLast("encoder", new {@link RedisEncoder}());
+ * p.addLast("decoder", new {@link RedisDecoder}());
+ * p.addLast("aggregator", <b>new {@link RedisBulkStringAggregator}()</b>);
+ * ...
+ * p.addLast("handler", new HttpRequestHandler());
+ * </pre>
+ * Be aware that you need to have the {@link RedisEncoder} before the {@link RedisBulkStringAggregator}
+ * in the {@link ChannelPipeline}.
+ */
+@UnstableApi
+public final class RedisBulkStringAggregator extends MessageAggregator<RedisMessage, BulkStringHeaderRedisMessage,
+                                                                 BulkStringRedisContent, FullBulkStringRedisMessage> {
+
+    /**
+     * Creates a new instance.
+     */
+    public RedisBulkStringAggregator() {
+        super(RedisConstants.REDIS_MESSAGE_MAX_LENGTH);
+    }
+
+    @Override
+    protected boolean isStartMessage(RedisMessage msg) throws Exception {
+        return msg instanceof BulkStringHeaderRedisMessage && !isAggregated(msg);
+    }
+
+    @Override
+    protected boolean isContentMessage(RedisMessage msg) throws Exception {
+        return msg instanceof BulkStringRedisContent;
+    }
+
+    @Override
+    protected boolean isLastContentMessage(BulkStringRedisContent msg) throws Exception {
+        return msg instanceof LastBulkStringRedisContent;
+    }
+
+    @Override
+    protected boolean isAggregated(RedisMessage msg) throws Exception {
+        return msg instanceof FullBulkStringRedisMessage;
+    }
+
+    @Override
+    protected boolean isContentLengthInvalid(BulkStringHeaderRedisMessage start, int maxContentLength)
+            throws Exception {
+        return start.bulkStringLength() > maxContentLength;
+    }
+
+    @Override
+    protected Object newContinueResponse(BulkStringHeaderRedisMessage start, int maxContentLength,
+                                         ChannelPipeline pipeline) throws Exception {
+        return null;
+    }
+
+    @Override
+    protected boolean closeAfterContinueResponse(Object msg) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected boolean ignoreContentAfterContinueResponse(Object msg) throws Exception {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected FullBulkStringRedisMessage beginAggregation(BulkStringHeaderRedisMessage start, ByteBuf content)
+            throws Exception {
+        return new FullBulkStringRedisMessage(content);
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisCodecException.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisCodecException.java
new file mode 100644
index 000000000000..cb2c42196f3e
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisCodecException.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.handler.codec.CodecException;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * An {@link Exception} which is thrown by {@link RedisEncoder} or {@link RedisDecoder}.
+ */
+@UnstableApi
+public final class RedisCodecException extends CodecException {
+
+    private static final long serialVersionUID = 5570454251549268063L;
+
+    /**
+     * Creates a new instance.
+     */
+    public RedisCodecException(String message) {
+        super(message);
+    }
+
+    /**
+     * Creates a new instance.
+     */
+    public RedisCodecException(Throwable cause) {
+        super(cause);
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisCodecUtil.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisCodecUtil.java
new file mode 100644
index 000000000000..1675903c4252
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisCodecUtil.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.CharsetUtil;
+import io.netty.util.internal.PlatformDependent;
+
+/**
+ * Utilities for codec-redis.
+ */
+final class RedisCodecUtil {
+
+    private RedisCodecUtil() {
+    }
+
+    static byte[] longToAsciiBytes(long value) {
+        return Long.toString(value).getBytes(CharsetUtil.US_ASCII);
+    }
+
+    /**
+     * Returns a {@code short} value using endian order.
+     */
+    static short makeShort(char first, char second) {
+        return PlatformDependent.BIG_ENDIAN_NATIVE_ORDER ?
+                (short) ((second << 8) | first) : (short) ((first << 8) | second);
+    }
+
+    /**
+     * Returns a {@code byte[]} of {@code short} value. This is opposite of {@code makeShort()}.
+     */
+    static byte[] shortToBytes(short value) {
+        byte[] bytes = new byte[2];
+        if (PlatformDependent.BIG_ENDIAN_NATIVE_ORDER) {
+            bytes[1] = (byte) ((value >> 8) & 0xff);
+            bytes[0] = (byte) (value & 0xff);
+        } else {
+            bytes[0] = (byte) ((value >> 8) & 0xff);
+            bytes[1] = (byte) (value & 0xff);
+        }
+        return bytes;
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisConstants.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisConstants.java
new file mode 100644
index 000000000000..9fae6f123216
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisConstants.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+/**
+ * Constant values for Redis encoder/decoder.
+ */
+final class RedisConstants {
+
+    private RedisConstants() {
+    }
+
+    static final int TYPE_LENGTH = 1;
+
+    static final int EOL_LENGTH = 2;
+
+    static final int NULL_LENGTH = 2;
+
+    static final int NULL_VALUE = -1;
+
+    static final int REDIS_MESSAGE_MAX_LENGTH = 512 * 1024 * 1024; // 512MB
+
+    static final int POSITIVE_LONG_MAX_LENGTH = 19; // length of Long.MAX_VALUE
+
+    static final int LONG_MAX_LENGTH = POSITIVE_LONG_MAX_LENGTH + 1; // +1 is sign
+
+    static final short NULL_SHORT = RedisCodecUtil.makeShort('-', '1');
+
+    static final short EOL_SHORT = RedisCodecUtil.makeShort('\r', '\n');
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java
new file mode 100644
index 000000000000..001d0ef5d33d
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java
@@ -0,0 +1,309 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.util.ByteProcessor;
+import io.netty.util.CharsetUtil;
+import io.netty.util.internal.UnstableApi;
+
+import java.util.List;
+
+/**
+ * Decodes the Redis protocol into {@link RedisMessage} objects following
+ * <a href="http://redis.io/topics/protocol">RESP (REdis Serialization Protocol)</a>.
+ *
+ * {@link RedisMessage} parts can be aggregated to {@link RedisMessage} using
+ * {@link RedisArrayAggregator} or processed directly.
+ */
+@UnstableApi
+public final class RedisDecoder extends ByteToMessageDecoder {
+
+    private final ToPositiveLongProcessor toPositiveLongProcessor = new ToPositiveLongProcessor();
+
+    private final int maxInlineMessageLength;
+    private final RedisMessagePool messagePool;
+
+    // current decoding states
+    private State state = State.DECODE_TYPE;
+    private RedisMessageType type;
+    private int remainingBulkLength;
+
+    private enum State {
+        DECODE_TYPE,
+        DECODE_INLINE, // SIMPLE_STRING, ERROR, INTEGER
+        DECODE_LENGTH, // BULK_STRING, ARRAY_HEADER
+        DECODE_BULK_STRING_EOL,
+        DECODE_BULK_STRING_CONTENT,
+    }
+
+    /**
+     * Creates a new instance with default {@code maxInlineMessageLength} and {@code messageaPool}.
+     */
+    public RedisDecoder() {
+        // 1024 * 64 is max inline length of current Redis server implementation.
+        this(1024 * 64, FixedRedisMessagePool.INSTANCE);
+    }
+
+    /**
+     * Creates a new instance.
+     * @param maxInlineMessageLength the maximum length of inline message.
+     * @param messagePool the predefined message pool.
+     */
+    public RedisDecoder(int maxInlineMessageLength, RedisMessagePool messagePool) {
+        if (maxInlineMessageLength <= 0 || maxInlineMessageLength > RedisConstants.REDIS_MESSAGE_MAX_LENGTH) {
+            throw new RedisCodecException("maxInlineMessageLength: " + maxInlineMessageLength +
+                                          " (expected: <= " + RedisConstants.REDIS_MESSAGE_MAX_LENGTH + ")");
+        }
+        this.maxInlineMessageLength = maxInlineMessageLength;
+        this.messagePool = messagePool;
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        try {
+            for (;;) {
+                switch (state) {
+                case DECODE_TYPE:
+                    if (!decodeType(in)) {
+                        return;
+                    }
+                    break;
+                case DECODE_INLINE:
+                    if (!decodeInline(in, out)) {
+                        return;
+                    }
+                    break;
+                case DECODE_LENGTH:
+                    if (!decodeLength(in, out)) {
+                        return;
+                    }
+                    break;
+                case DECODE_BULK_STRING_EOL:
+                    if (!decodeBulkStringEndOfLine(in, out)) {
+                        return;
+                    }
+                    break;
+                case DECODE_BULK_STRING_CONTENT:
+                    if (!decodeBulkStringContent(in, out)) {
+                        return;
+                    }
+                    break;
+                default:
+                    throw new RedisCodecException("Unknown state: " + state);
+                }
+            }
+        } catch (RedisCodecException e) {
+            resetDecoder();
+            throw e;
+        } catch (Exception e) {
+            resetDecoder();
+            throw new RedisCodecException(e);
+        }
+    }
+
+    private void resetDecoder() {
+        state = State.DECODE_TYPE;
+        remainingBulkLength = 0;
+    }
+
+    private boolean decodeType(ByteBuf in) throws Exception {
+        if (!in.isReadable()) {
+            return false;
+        }
+        type = RedisMessageType.valueOf(in.readByte());
+        state = type.isInline() ? State.DECODE_INLINE : State.DECODE_LENGTH;
+        return true;
+    }
+
+    private boolean decodeInline(ByteBuf in, List<Object> out) throws Exception {
+        ByteBuf lineBytes = readLine(in);
+        if (lineBytes == null) {
+            if (in.readableBytes() > maxInlineMessageLength) {
+                throw new RedisCodecException("length: " + in.readableBytes() +
+                                              " (expected: <= " + maxInlineMessageLength + ")");
+            }
+            return false;
+        }
+        out.add(newInlineRedisMessage(type, lineBytes));
+        resetDecoder();
+        return true;
+    }
+
+    private boolean decodeLength(ByteBuf in, List<Object> out) throws Exception {
+        ByteBuf lineByteBuf = readLine(in);
+        if (lineByteBuf == null) {
+            return false;
+        }
+        final long length = parseRedisNumber(lineByteBuf);
+        if (length < RedisConstants.NULL_VALUE) {
+            throw new RedisCodecException("length: " + length + " (expected: >= " + RedisConstants.NULL_VALUE + ")");
+        }
+        switch (type) {
+        case ARRAY_HEADER:
+            out.add(new ArrayHeaderRedisMessage(length));
+            resetDecoder();
+            return true;
+        case BULK_STRING:
+            if (length > RedisConstants.REDIS_MESSAGE_MAX_LENGTH) {
+                throw new RedisCodecException("length: " + length + " (expected: <= " +
+                                              RedisConstants.REDIS_MESSAGE_MAX_LENGTH + ")");
+            }
+            remainingBulkLength = (int) length; // range(int) is already checked.
+            return decodeBulkString(in, out);
+        default:
+            throw new RedisCodecException("bad type: " + type);
+        }
+    }
+
+    private boolean decodeBulkString(ByteBuf in, List<Object> out) throws Exception {
+        switch (remainingBulkLength) {
+        case RedisConstants.NULL_VALUE: // $-1\r\n
+            out.add(FullBulkStringRedisMessage.NULL_INSTANCE);
+            resetDecoder();
+            return true;
+        case 0:
+            state = State.DECODE_BULK_STRING_EOL;
+            return decodeBulkStringEndOfLine(in, out);
+        default: // expectedBulkLength is always positive.
+            out.add(new BulkStringHeaderRedisMessage(remainingBulkLength));
+            state = State.DECODE_BULK_STRING_CONTENT;
+            return decodeBulkStringContent(in, out);
+        }
+    }
+
+    // $0\r\n <here> \r\n
+    private boolean decodeBulkStringEndOfLine(ByteBuf in, List<Object> out) throws Exception {
+        if (in.readableBytes() < RedisConstants.EOL_LENGTH) {
+            return false;
+        }
+        readEndOfLine(in);
+        out.add(FullBulkStringRedisMessage.EMPTY_INSTANCE);
+        resetDecoder();
+        return true;
+    }
+
+    // ${expectedBulkLength}\r\n <here> {data...}\r\n
+    private boolean decodeBulkStringContent(ByteBuf in, List<Object> out) throws Exception {
+        final int readableBytes = in.readableBytes();
+        if (readableBytes == 0) {
+            return false;
+        }
+
+        // if this is last frame.
+        if (readableBytes >= remainingBulkLength + RedisConstants.EOL_LENGTH) {
+            ByteBuf content = in.readSlice(remainingBulkLength);
+            readEndOfLine(in);
+            // Only call retain after readEndOfLine(...) as the method may throw an exception.
+            out.add(new DefaultLastBulkStringRedisContent(content.retain()));
+            resetDecoder();
+            return true;
+        }
+
+        // chunked write.
+        int toRead = Math.min(remainingBulkLength, readableBytes);
+        remainingBulkLength -= toRead;
+        out.add(new DefaultBulkStringRedisContent(in.readSlice(toRead).retain()));
+        return true;
+    }
+
+    private static void readEndOfLine(final ByteBuf in) {
+        final short delim = in.readShort();
+        if (RedisConstants.EOL_SHORT == delim) {
+            return;
+        }
+        final byte[] bytes = RedisCodecUtil.shortToBytes(delim);
+        throw new RedisCodecException("delimiter: [" + bytes[0] + "," + bytes[1] + "] (expected: \\r\\n)");
+    }
+
+    private RedisMessage newInlineRedisMessage(RedisMessageType messageType, ByteBuf content) {
+        switch (messageType) {
+        case SIMPLE_STRING: {
+            SimpleStringRedisMessage cached = messagePool.getSimpleString(content);
+            return cached != null ? cached : new SimpleStringRedisMessage(content.toString(CharsetUtil.UTF_8));
+        }
+        case ERROR: {
+            ErrorRedisMessage cached = messagePool.getError(content);
+            return cached != null ? cached : new ErrorRedisMessage(content.toString(CharsetUtil.UTF_8));
+        }
+        case INTEGER: {
+            IntegerRedisMessage cached = messagePool.getInteger(content);
+            return cached != null ? cached : new IntegerRedisMessage(parseRedisNumber(content));
+        }
+        default:
+            throw new RedisCodecException("bad type: " + messageType);
+        }
+    }
+
+    private static ByteBuf readLine(ByteBuf in) {
+        if (!in.isReadable(RedisConstants.EOL_LENGTH)) {
+            return null;
+        }
+        final int lfIndex = in.forEachByte(ByteProcessor.FIND_LF);
+        if (lfIndex < 0) {
+            return null;
+        }
+        ByteBuf data = in.readSlice(lfIndex - in.readerIndex() - 1); // `-1` is for CR
+        readEndOfLine(in); // validate CR LF
+        return data;
+    }
+
+    private long parseRedisNumber(ByteBuf byteBuf) {
+        final int readableBytes = byteBuf.readableBytes();
+        final boolean negative = readableBytes > 0 && byteBuf.getByte(byteBuf.readerIndex()) == '-';
+        final int extraOneByteForNegative = negative ? 1 : 0;
+        if (readableBytes <= extraOneByteForNegative) {
+            throw new RedisCodecException("no number to parse: " + byteBuf.toString(CharsetUtil.US_ASCII));
+        }
+        if (readableBytes > RedisConstants.POSITIVE_LONG_MAX_LENGTH + extraOneByteForNegative) {
+            throw new RedisCodecException("too many characters to be a valid RESP Integer: " +
+                                          byteBuf.toString(CharsetUtil.US_ASCII));
+        }
+        if (negative) {
+            return -parsePositiveNumber(byteBuf.skipBytes(extraOneByteForNegative));
+        }
+        return parsePositiveNumber(byteBuf);
+    }
+
+    private long parsePositiveNumber(ByteBuf byteBuf) {
+        toPositiveLongProcessor.reset();
+        byteBuf.forEachByte(toPositiveLongProcessor);
+        return toPositiveLongProcessor.content();
+    }
+
+    private static final class ToPositiveLongProcessor implements ByteProcessor {
+        private long result;
+
+        @Override
+        public boolean process(byte value) throws Exception {
+            if (value < '0' || value > '9') {
+                throw new RedisCodecException("bad byte in number: " + value);
+            }
+            result = result * 10 + (value - '0');
+            return true;
+        }
+
+        public long content() {
+            return result;
+        }
+
+        public void reset() {
+            result = 0;
+        }
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisEncoder.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisEncoder.java
new file mode 100644
index 000000000000..45fad5e5114a
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisEncoder.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.CodecException;
+import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.UnstableApi;
+
+import java.util.List;
+
+/**
+ * Encodes {@link RedisMessage} into bytes following
+ * <a href="http://redis.io/topics/protocol">RESP (REdis Serialization Protocol)</a>.
+ */
+@UnstableApi
+public class RedisEncoder extends MessageToMessageEncoder<RedisMessage> {
+
+    private final RedisMessagePool messagePool;
+
+    /**
+     * Creates a new instance with default {@code messagePool}.
+     */
+    public RedisEncoder() {
+        this(FixedRedisMessagePool.INSTANCE);
+    }
+
+    /**
+     * Creates a new instance.
+     * @param messagePool the predefined message pool.
+     */
+    public RedisEncoder(RedisMessagePool messagePool) {
+        this.messagePool = ObjectUtil.checkNotNull(messagePool, "messagePool");
+    }
+
+    @Override
+    protected void encode(ChannelHandlerContext ctx, RedisMessage msg, List<Object> out) throws Exception {
+        try {
+            writeRedisMessage(ctx.alloc(), msg, out);
+        } catch (CodecException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new CodecException(e);
+        }
+    }
+
+    private void writeRedisMessage(ByteBufAllocator allocator, RedisMessage msg, List<Object> out) {
+        if (msg instanceof SimpleStringRedisMessage) {
+            writeSimpleStringMessage(allocator, (SimpleStringRedisMessage) msg, out);
+        } else if (msg instanceof ErrorRedisMessage) {
+            writeErrorMessage(allocator, (ErrorRedisMessage) msg, out);
+        } else if (msg instanceof IntegerRedisMessage) {
+            writeIntegerMessage(allocator, (IntegerRedisMessage) msg, out);
+        } else if (msg instanceof FullBulkStringRedisMessage) {
+            writeFullBulkStringMessage(allocator, (FullBulkStringRedisMessage) msg, out);
+        } else if (msg instanceof BulkStringRedisContent) {
+            writeBulkStringContent(allocator, (BulkStringRedisContent) msg, out);
+        } else if (msg instanceof BulkStringHeaderRedisMessage) {
+            writeBulkStringHeader(allocator, (BulkStringHeaderRedisMessage) msg, out);
+        } else if (msg instanceof ArrayHeaderRedisMessage) {
+            writeArrayHeader(allocator, (ArrayHeaderRedisMessage) msg, out);
+        } else if (msg instanceof ArrayRedisMessage) {
+            writeArrayMessage(allocator, (ArrayRedisMessage) msg, out);
+        } else {
+            throw new CodecException("unknown message type: " + msg);
+        }
+    }
+
+    private static void writeSimpleStringMessage(ByteBufAllocator allocator, SimpleStringRedisMessage msg,
+                                                 List<Object> out) {
+        writeString(allocator, RedisMessageType.SIMPLE_STRING.value(), msg.content(), out);
+    }
+
+    private static void writeErrorMessage(ByteBufAllocator allocator, ErrorRedisMessage msg, List<Object> out) {
+        writeString(allocator, RedisMessageType.ERROR.value(), msg.content(), out);
+    }
+
+    private static void writeString(ByteBufAllocator allocator, byte type, String content, List<Object> out) {
+        ByteBuf buf = allocator.ioBuffer(RedisConstants.TYPE_LENGTH + ByteBufUtil.utf8MaxBytes(content) +
+                                         RedisConstants.EOL_LENGTH);
+        buf.writeByte(type);
+        ByteBufUtil.writeUtf8(buf, content);
+        buf.writeShort(RedisConstants.EOL_SHORT);
+        out.add(buf);
+    }
+
+    private void writeIntegerMessage(ByteBufAllocator allocator, IntegerRedisMessage msg, List<Object> out) {
+        ByteBuf buf = allocator.ioBuffer(RedisConstants.TYPE_LENGTH + RedisConstants.LONG_MAX_LENGTH +
+                                         RedisConstants.EOL_LENGTH);
+        buf.writeByte(RedisMessageType.INTEGER.value());
+        buf.writeBytes(numberToBytes(msg.value()));
+        buf.writeShort(RedisConstants.EOL_SHORT);
+        out.add(buf);
+    }
+
+    private void writeBulkStringHeader(ByteBufAllocator allocator, BulkStringHeaderRedisMessage msg, List<Object> out) {
+        final ByteBuf buf = allocator.ioBuffer(RedisConstants.TYPE_LENGTH +
+                                        (msg.isNull() ? RedisConstants.NULL_LENGTH :
+                                                        RedisConstants.LONG_MAX_LENGTH + RedisConstants.EOL_LENGTH));
+        buf.writeByte(RedisMessageType.BULK_STRING.value());
+        if (msg.isNull()) {
+            buf.writeShort(RedisConstants.NULL_SHORT);
+        } else {
+            buf.writeBytes(numberToBytes(msg.bulkStringLength()));
+            buf.writeShort(RedisConstants.EOL_SHORT);
+        }
+        out.add(buf);
+    }
+
+    private static void writeBulkStringContent(ByteBufAllocator allocator, BulkStringRedisContent msg,
+                                               List<Object> out) {
+        out.add(msg.content().retain());
+        if (msg instanceof LastBulkStringRedisContent) {
+            out.add(allocator.ioBuffer(RedisConstants.EOL_LENGTH).writeShort(RedisConstants.EOL_SHORT));
+        }
+    }
+
+    private void writeFullBulkStringMessage(ByteBufAllocator allocator, FullBulkStringRedisMessage msg,
+                                            List<Object> out) {
+        if (msg.isNull()) {
+            ByteBuf buf = allocator.ioBuffer(RedisConstants.TYPE_LENGTH + RedisConstants.NULL_LENGTH +
+                                             RedisConstants.EOL_LENGTH);
+            buf.writeByte(RedisMessageType.BULK_STRING.value());
+            buf.writeShort(RedisConstants.NULL_SHORT);
+            buf.writeShort(RedisConstants.EOL_SHORT);
+            out.add(buf);
+        } else {
+            ByteBuf headerBuf = allocator.ioBuffer(RedisConstants.TYPE_LENGTH + RedisConstants.LONG_MAX_LENGTH +
+                                                   RedisConstants.EOL_LENGTH);
+            headerBuf.writeByte(RedisMessageType.BULK_STRING.value());
+            headerBuf.writeBytes(numberToBytes(msg.content().readableBytes()));
+            headerBuf.writeShort(RedisConstants.EOL_SHORT);
+            out.add(headerBuf);
+            out.add(msg.content().retain());
+            out.add(allocator.ioBuffer(RedisConstants.EOL_LENGTH).writeShort(RedisConstants.EOL_SHORT));
+        }
+    }
+
+    /**
+     * Write array header only without body. Use this if you want to write arrays as streaming.
+     */
+    private void writeArrayHeader(ByteBufAllocator allocator, ArrayHeaderRedisMessage msg, List<Object> out) {
+        writeArrayHeader(allocator, msg.isNull(), msg.length(), out);
+    }
+
+    /**
+     * Write full constructed array message.
+     */
+    private void writeArrayMessage(ByteBufAllocator allocator, ArrayRedisMessage msg, List<Object> out) {
+        if (msg.isNull()) {
+            writeArrayHeader(allocator, msg.isNull(), RedisConstants.NULL_VALUE, out);
+        } else {
+            writeArrayHeader(allocator, msg.isNull(), msg.children().size(), out);
+            for (RedisMessage child : msg.children()) {
+                writeRedisMessage(allocator, child, out);
+            }
+        }
+    }
+
+    private void writeArrayHeader(ByteBufAllocator allocator, boolean isNull, long length, List<Object> out) {
+        if (isNull) {
+            final ByteBuf buf = allocator.ioBuffer(RedisConstants.TYPE_LENGTH + RedisConstants.NULL_LENGTH +
+                                                   RedisConstants.EOL_LENGTH);
+            buf.writeByte(RedisMessageType.ARRAY_HEADER.value());
+            buf.writeShort(RedisConstants.NULL_SHORT);
+            buf.writeShort(RedisConstants.EOL_SHORT);
+            out.add(buf);
+        } else {
+            final ByteBuf buf = allocator.ioBuffer(RedisConstants.TYPE_LENGTH + RedisConstants.LONG_MAX_LENGTH +
+                                                   RedisConstants.EOL_LENGTH);
+            buf.writeByte(RedisMessageType.ARRAY_HEADER.value());
+            buf.writeBytes(numberToBytes(length));
+            buf.writeShort(RedisConstants.EOL_SHORT);
+            out.add(buf);
+        }
+    }
+
+    private byte[] numberToBytes(long value) {
+        byte[] bytes = messagePool.getByteBufOfInteger(value);
+        return bytes != null ? bytes : RedisCodecUtil.longToAsciiBytes(value);
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessage.java
new file mode 100644
index 000000000000..afb277e1503c
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessage.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * RedisMessage is base interface for codec-redis.
+ */
+@UnstableApi
+public interface RedisMessage {
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessagePool.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessagePool.java
new file mode 100644
index 000000000000..7f7d8d2a9ff1
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessagePool.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * A strategy interface for caching {@link RedisMessage}s.
+ */
+@UnstableApi
+
+public interface RedisMessagePool {
+
+    /**
+     * Returns {@link SimpleStringRedisMessage} for given {@code content}. Returns {@code null} it does not exist.
+     */
+    SimpleStringRedisMessage getSimpleString(String content);
+
+    /**
+     * Returns {@link SimpleStringRedisMessage} for given {@code content}. Returns {@code null} it does not exist.
+     */
+    SimpleStringRedisMessage getSimpleString(ByteBuf content);
+
+    /**
+     * Returns {@link ErrorRedisMessage} for given {@code content}. Returns {@code null} it does not exist.
+     */
+    ErrorRedisMessage getError(String content);
+
+    /**
+     * Returns {@link ErrorRedisMessage} for given {@code content}. Returns {@code null} it does not exist.
+     */
+    ErrorRedisMessage getError(ByteBuf content);
+
+    /**
+     * Returns {@link IntegerRedisMessage} for given {@code value}. Returns {@code null} it does not exist.
+     */
+    IntegerRedisMessage getInteger(long value);
+
+    /**
+     * Returns {@link IntegerRedisMessage} for given {@code content}. Returns {@code null} it does not exist.
+     */
+    IntegerRedisMessage getInteger(ByteBuf content);
+
+    /**
+     * Returns {@code byte[]} for given {@code msg}. Returns {@code null} it does not exist.
+     */
+    byte[] getByteBufOfInteger(long value);
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessageType.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessageType.java
new file mode 100644
index 000000000000..b325f060f967
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisMessageType.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * Type of <a href="http://redis.io/topics/protocol">RESP (REdis Serialization Protocol)</a>.
+ */
+@UnstableApi
+public enum RedisMessageType {
+
+    SIMPLE_STRING((byte) '+', true),
+    ERROR((byte) '-', true),
+    INTEGER((byte) ':', true),
+    BULK_STRING((byte) '$', false),
+    ARRAY_HEADER((byte) '*', false),
+    ARRAY((byte) '*', false); // for aggregated
+
+    private final byte value;
+    private final boolean inline;
+
+    RedisMessageType(byte value, boolean inline) {
+        this.value = value;
+        this.inline = inline;
+    }
+
+    /**
+     * Returns prefix {@code byte} for this type.
+     */
+    public byte value() {
+        return value;
+    }
+
+    /**
+     * Returns {@code true} if this type is inline type, or returns {@code false}. If this is {@code true},
+     * this type doesn't have length field.
+     */
+    public boolean isInline() {
+        return inline;
+    }
+
+    /**
+     * Return {@link RedisMessageType} for this type prefix {@code byte}.
+     */
+    public static RedisMessageType valueOf(byte value) {
+        switch (value) {
+        case '+':
+            return SIMPLE_STRING;
+        case '-':
+            return ERROR;
+        case ':':
+            return INTEGER;
+        case '$':
+            return BULK_STRING;
+        case '*':
+            return ARRAY_HEADER;
+        default:
+            throw new RedisCodecException("Unknown RedisMessageType: " + value);
+        }
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/SimpleStringRedisMessage.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/SimpleStringRedisMessage.java
new file mode 100644
index 000000000000..1179b5deef8f
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/SimpleStringRedisMessage.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
+
+/**
+ * Simple Strings of <a href="http://redis.io/topics/protocol">RESP</a>.
+ */
+@UnstableApi
+public final class SimpleStringRedisMessage extends AbstractStringRedisMessage {
+
+    /**
+     * Creates a {@link SimpleStringRedisMessage} for the given {@code content}.
+     *
+     * @param content the message content, must not be {@code null}.
+     */
+    public SimpleStringRedisMessage(String content) {
+        super(content);
+    }
+
+    @Override
+    public String toString() {
+        return new StringBuilder(StringUtil.simpleClassName(this))
+                .append('[')
+                .append("content=")
+                .append(content())
+                .append(']').toString();
+    }
+}
diff --git a/codec-redis/src/main/java/io/netty/handler/codec/redis/package-info.java b/codec-redis/src/main/java/io/netty/handler/codec/redis/package-info.java
new file mode 100644
index 000000000000..73ddd33c68c0
--- /dev/null
+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/package-info.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+/**
+ * Encoder, decoder for Redis.
+ */
+@UnstableApi
+package io.netty.handler.codec.redis;
+
+import io.netty.util.internal.UnstableApi;
diff --git a/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisCodecTestUtil.java b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisCodecTestUtil.java
new file mode 100644
index 000000000000..72e3beca0517
--- /dev/null
+++ b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisCodecTestUtil.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.util.CharsetUtil;
+
+final class RedisCodecTestUtil {
+
+    private RedisCodecTestUtil() {
+    }
+
+    static byte[] bytesOf(long value) {
+        return bytesOf(Long.toString(value));
+    }
+
+    static byte[] bytesOf(String s) {
+        return s.getBytes(CharsetUtil.UTF_8);
+    }
+
+    static byte[] bytesOf(ByteBuf buf) {
+        byte[] data = new byte[buf.readableBytes()];
+        buf.readBytes(data);
+        return data;
+    }
+
+    static String stringOf(ByteBuf buf) {
+        return new String(bytesOf(buf));
+    }
+
+    static ByteBuf byteBufOf(String s) {
+        return byteBufOf(bytesOf(s));
+    }
+
+    static ByteBuf byteBufOf(byte[] data) {
+        return Unpooled.wrappedBuffer(data);
+    }
+}
diff --git a/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisDecoderTest.java b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisDecoderTest.java
new file mode 100644
index 000000000000..d7e7a4085829
--- /dev/null
+++ b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisDecoderTest.java
@@ -0,0 +1,266 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.util.IllegalReferenceCountException;
+import io.netty.util.ReferenceCountUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.List;
+
+import static io.netty.handler.codec.redis.RedisCodecTestUtil.*;
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+/**
+ * Verifies the correct functionality of the {@link RedisDecoder} and {@link RedisArrayAggregator}.
+ */
+public class RedisDecoderTest {
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(
+                new RedisDecoder(),
+                new RedisBulkStringAggregator(),
+                new RedisArrayAggregator());
+    }
+
+    @After
+    public void teardown() throws Exception {
+        assertFalse(channel.finish());
+    }
+
+    @Test
+    public void shouldDecodeSimpleString() {
+        assertFalse(channel.writeInbound(byteBufOf("+")));
+        assertFalse(channel.writeInbound(byteBufOf("O")));
+        assertFalse(channel.writeInbound(byteBufOf("K")));
+        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
+
+        SimpleStringRedisMessage msg = channel.readInbound();
+
+        assertThat(msg.content(), is("OK"));
+
+        ReferenceCountUtil.release(msg);
+    }
+
+    @Test
+    public void shouldDecodeTwoSimpleStrings() {
+        assertFalse(channel.writeInbound(byteBufOf("+")));
+        assertFalse(channel.writeInbound(byteBufOf("O")));
+        assertFalse(channel.writeInbound(byteBufOf("K")));
+        assertTrue(channel.writeInbound(byteBufOf("\r\n+SEC")));
+        assertTrue(channel.writeInbound(byteBufOf("OND\r\n")));
+
+        SimpleStringRedisMessage msg1 = channel.readInbound();
+        assertThat(msg1.content(), is("OK"));
+        ReferenceCountUtil.release(msg1);
+
+        SimpleStringRedisMessage msg2 = channel.readInbound();
+        assertThat(msg2.content(), is("SECOND"));
+        ReferenceCountUtil.release(msg2);
+    }
+
+    @Test
+    public void shouldDecodeError() {
+        String content = "ERROR sample message";
+        assertFalse(channel.writeInbound(byteBufOf("-")));
+        assertFalse(channel.writeInbound(byteBufOf(content)));
+        assertFalse(channel.writeInbound(byteBufOf("\r")));
+        assertTrue(channel.writeInbound(byteBufOf("\n")));
+
+        ErrorRedisMessage msg = channel.readInbound();
+
+        assertThat(msg.content(), is(content));
+
+        ReferenceCountUtil.release(msg);
+    }
+
+    @Test
+    public void shouldDecodeInteger() {
+        long value = 1234L;
+        byte[] content = bytesOf(value);
+        assertFalse(channel.writeInbound(byteBufOf(":")));
+        assertFalse(channel.writeInbound(byteBufOf(content)));
+        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
+
+        IntegerRedisMessage msg = channel.readInbound();
+
+        assertThat(msg.value(), is(value));
+
+        ReferenceCountUtil.release(msg);
+    }
+
+    @Test
+    public void shouldDecodeBulkString() {
+        String buf1 = "bulk\nst";
+        String buf2 = "ring\ntest\n1234";
+        byte[] content = bytesOf(buf1 + buf2);
+        assertFalse(channel.writeInbound(byteBufOf("$")));
+        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(content.length))));
+        assertFalse(channel.writeInbound(byteBufOf("\r\n")));
+        assertFalse(channel.writeInbound(byteBufOf(buf1)));
+        assertFalse(channel.writeInbound(byteBufOf(buf2)));
+        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
+
+        FullBulkStringRedisMessage msg = channel.readInbound();
+
+        assertThat(bytesOf(msg.content()), is(content));
+
+        ReferenceCountUtil.release(msg);
+    }
+
+    @Test
+    public void shouldDecodeEmptyBulkString() {
+        byte[] content = bytesOf("");
+        assertFalse(channel.writeInbound(byteBufOf("$")));
+        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(content.length))));
+        assertFalse(channel.writeInbound(byteBufOf("\r\n")));
+        assertFalse(channel.writeInbound(byteBufOf(content)));
+        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
+
+        FullBulkStringRedisMessage msg = channel.readInbound();
+
+        assertThat(bytesOf(msg.content()), is(content));
+
+        ReferenceCountUtil.release(msg);
+    }
+
+    @Test
+    public void shouldDecodeNullBulkString() {
+        assertFalse(channel.writeInbound(byteBufOf("$")));
+        assertFalse(channel.writeInbound(byteBufOf(Integer.toString(-1))));
+        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
+
+        assertTrue(channel.writeInbound(byteBufOf("$")));
+        assertTrue(channel.writeInbound(byteBufOf(Integer.toString(-1))));
+        assertTrue(channel.writeInbound(byteBufOf("\r\n")));
+
+        FullBulkStringRedisMessage msg1 = channel.readInbound();
+        assertThat(msg1.isNull(), is(true));
+        ReferenceCountUtil.release(msg1);
+
+        FullBulkStringRedisMessage msg2 = channel.readInbound();
+        assertThat(msg2.isNull(), is(true));
+        ReferenceCountUtil.release(msg2);
+
+        FullBulkStringRedisMessage msg3 = channel.readInbound();
+        assertThat(msg3, is(nullValue()));
+    }
+
+    @Test
+    public void shouldDecodeSimpleArray() throws Exception {
+        assertFalse(channel.writeInbound(byteBufOf("*3\r\n")));
+        assertFalse(channel.writeInbound(byteBufOf(":1234\r\n")));
+        assertFalse(channel.writeInbound(byteBufOf("+sim")));
+        assertFalse(channel.writeInbound(byteBufOf("ple\r\n-err")));
+        assertTrue(channel.writeInbound(byteBufOf("or\r\n")));
+
+        ArrayRedisMessage msg = channel.readInbound();
+        List<RedisMessage> children = msg.children();
+
+        assertThat(msg.children().size(), is(equalTo(3)));
+
+        assertThat(children.get(0), instanceOf(IntegerRedisMessage.class));
+        assertThat(((IntegerRedisMessage) children.get(0)).value(), is(1234L));
+        assertThat(children.get(1), instanceOf(SimpleStringRedisMessage.class));
+        assertThat(((SimpleStringRedisMessage) children.get(1)).content(), is("simple"));
+        assertThat(children.get(2), instanceOf(ErrorRedisMessage.class));
+        assertThat(((ErrorRedisMessage) children.get(2)).content(), is("error"));
+
+        ReferenceCountUtil.release(msg);
+    }
+
+    @Test
+    public void shouldDecodeNestedArray() throws Exception {
+        ByteBuf buf = Unpooled.buffer();
+        buf.writeBytes(byteBufOf("*2\r\n"));
+        buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
+        buf.writeBytes(byteBufOf("*2\r\n+Foo\r\n-Bar\r\n"));
+        assertTrue(channel.writeInbound(buf));
+
+        ArrayRedisMessage msg = channel.readInbound();
+        List<RedisMessage> children = msg.children();
+
+        assertThat(msg.children().size(), is(2));
+
+        ArrayRedisMessage intArray = (ArrayRedisMessage) children.get(0);
+        ArrayRedisMessage strArray = (ArrayRedisMessage) children.get(1);
+
+        assertThat(intArray.children().size(), is(3));
+        assertThat(((IntegerRedisMessage) intArray.children().get(0)).value(), is(1L));
+        assertThat(((IntegerRedisMessage) intArray.children().get(1)).value(), is(2L));
+        assertThat(((IntegerRedisMessage) intArray.children().get(2)).value(), is(3L));
+
+        assertThat(strArray.children().size(), is(2));
+        assertThat(((SimpleStringRedisMessage) strArray.children().get(0)).content(), is("Foo"));
+        assertThat(((ErrorRedisMessage) strArray.children().get(1)).content(), is("Bar"));
+
+        ReferenceCountUtil.release(msg);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void shouldErrorOnDoubleReleaseArrayReferenceCounted() throws Exception {
+        ByteBuf buf = Unpooled.buffer();
+        buf.writeBytes(byteBufOf("*2\r\n"));
+        buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
+        buf.writeBytes(byteBufOf("*2\r\n+Foo\r\n-Bar\r\n"));
+        assertTrue(channel.writeInbound(buf));
+
+        ArrayRedisMessage msg = channel.readInbound();
+
+        ReferenceCountUtil.release(msg);
+        ReferenceCountUtil.release(msg);
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void shouldErrorOnReleaseArrayChildReferenceCounted() throws Exception {
+        ByteBuf buf = Unpooled.buffer();
+        buf.writeBytes(byteBufOf("*2\r\n"));
+        buf.writeBytes(byteBufOf("*3\r\n:1\r\n:2\r\n:3\r\n"));
+        buf.writeBytes(byteBufOf("$3\r\nFoo\r\n"));
+        assertTrue(channel.writeInbound(buf));
+
+        ArrayRedisMessage msg = channel.readInbound();
+
+        List<RedisMessage> children = msg.children();
+        ReferenceCountUtil.release(msg);
+        ReferenceCountUtil.release(children.get(1));
+    }
+
+    @Test(expected = IllegalReferenceCountException.class)
+    public void shouldErrorOnReleasecontentOfArrayChildReferenceCounted() throws Exception {
+        ByteBuf buf = Unpooled.buffer();
+        buf.writeBytes(byteBufOf("*2\r\n"));
+        buf.writeBytes(byteBufOf("$3\r\nFoo\r\n$3\r\nBar\r\n"));
+        assertTrue(channel.writeInbound(buf));
+
+        ArrayRedisMessage msg = channel.readInbound();
+
+        List<RedisMessage> children = msg.children();
+        ByteBuf childBuf = ((FullBulkStringRedisMessage) children.get(0)).content();
+        ReferenceCountUtil.release(msg);
+        ReferenceCountUtil.release(childBuf);
+    }
+}
diff --git a/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisEncoderTest.java b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisEncoderTest.java
new file mode 100644
index 000000000000..32803f4ee14a
--- /dev/null
+++ b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisEncoderTest.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.handler.codec.redis;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.embedded.EmbeddedChannel;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assert.*;
+
+import static io.netty.handler.codec.redis.RedisCodecTestUtil.*;
+
+/**
+ * Verifies the correct functionality of the {@link RedisEncoder}.
+ */
+public class RedisEncoderTest {
+
+    private EmbeddedChannel channel;
+
+    @Before
+    public void setup() throws Exception {
+        channel = new EmbeddedChannel(new RedisEncoder());
+    }
+
+    @After
+    public void teardown() throws Exception {
+        assertFalse(channel.finish());
+    }
+
+    @Test
+    public void shouldEncodeSimpleString() {
+        RedisMessage msg = new SimpleStringRedisMessage("simple");
+
+        boolean result = channel.writeOutbound(msg);
+        assertThat(result, is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(bytesOf("+simple\r\n")));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeError() {
+        RedisMessage msg = new ErrorRedisMessage("error1");
+
+        boolean result = channel.writeOutbound(msg);
+        assertThat(result, is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(equalTo(bytesOf("-error1\r\n"))));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeInteger() {
+        RedisMessage msg = new IntegerRedisMessage(1234L);
+
+        boolean result = channel.writeOutbound(msg);
+        assertThat(result, is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(equalTo(bytesOf(":1234\r\n"))));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeBulkStringContent() {
+        RedisMessage header = new BulkStringHeaderRedisMessage(16);
+        RedisMessage body1 = new DefaultBulkStringRedisContent(byteBufOf("bulk\nstr").retain());
+        RedisMessage body2 = new DefaultLastBulkStringRedisContent(byteBufOf("ing\ntest").retain());
+
+        assertThat(channel.writeOutbound(header), is(true));
+        assertThat(channel.writeOutbound(body1), is(true));
+        assertThat(channel.writeOutbound(body2), is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(equalTo(bytesOf("$16\r\nbulk\nstring\ntest\r\n"))));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeFullBulkString() {
+        ByteBuf bulkString = byteBufOf("bulk\nstring\ntest").retain();
+        int length = bulkString.readableBytes();
+        RedisMessage msg = new FullBulkStringRedisMessage(bulkString);
+
+        boolean result = channel.writeOutbound(msg);
+        assertThat(result, is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(equalTo(bytesOf("$" + length + "\r\nbulk\nstring\ntest\r\n"))));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeSimpleArray() {
+        List<RedisMessage> children = new ArrayList<RedisMessage>();
+        children.add(new FullBulkStringRedisMessage(byteBufOf("foo").retain()));
+        children.add(new FullBulkStringRedisMessage(byteBufOf("bar").retain()));
+        RedisMessage msg = new ArrayRedisMessage(children);
+
+        boolean result = channel.writeOutbound(msg);
+        assertThat(result, is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(equalTo(bytesOf("*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n"))));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeNullArray() {
+        RedisMessage msg = ArrayRedisMessage.NULL_INSTANCE;
+
+        boolean result = channel.writeOutbound(msg);
+        assertThat(result, is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(equalTo(bytesOf("*-1\r\n"))));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeEmptyArray() {
+        RedisMessage msg = ArrayRedisMessage.EMPTY_INSTANCE;
+
+        boolean result = channel.writeOutbound(msg);
+        assertThat(result, is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(equalTo(bytesOf("*0\r\n"))));
+        written.release();
+    }
+
+    @Test
+    public void shouldEncodeNestedArray() {
+        List<RedisMessage> grandChildren = new ArrayList<RedisMessage>();
+        grandChildren.add(new FullBulkStringRedisMessage(byteBufOf("bar")));
+        grandChildren.add(new IntegerRedisMessage(-1234L));
+        List<RedisMessage> children = new ArrayList<RedisMessage>();
+        children.add(new SimpleStringRedisMessage("foo"));
+        children.add(new ArrayRedisMessage(grandChildren));
+        RedisMessage msg = new ArrayRedisMessage(children);
+
+        boolean result = channel.writeOutbound(msg);
+        assertThat(result, is(true));
+
+        ByteBuf written = readAll(channel);
+        assertThat(bytesOf(written), is(equalTo(bytesOf("*2\r\n+foo\r\n*2\r\n$3\r\nbar\r\n:-1234\r\n"))));
+        written.release();
+    }
+
+    private static ByteBuf readAll(EmbeddedChannel channel) {
+        ByteBuf buf = Unpooled.buffer();
+        ByteBuf read;
+        while ((read = channel.readOutbound()) != null) {
+            buf.writeBytes(read);
+        }
+        return buf;
+    }
+}
diff --git a/codec-smtp/pom.xml b/codec-smtp/pom.xml
index 4f13dea9e3eb..f485d707def7 100644
--- a/codec-smtp/pom.xml
+++ b/codec-smtp/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-smtp</artifactId>
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultLastSmtpContent.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultLastSmtpContent.java
index 76d36af841e5..1761dfd8b73d 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultLastSmtpContent.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultLastSmtpContent.java
@@ -16,10 +16,12 @@
 package io.netty.handler.codec.smtp;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Default implementation of {@link LastSmtpContent} that does no validation of the raw data passed in.
  */
+@UnstableApi
 public final class DefaultLastSmtpContent extends DefaultSmtpContent implements LastSmtpContent {
 
     /**
@@ -31,34 +33,44 @@ public DefaultLastSmtpContent(ByteBuf data) {
 
     @Override
     public LastSmtpContent copy() {
-        return new DefaultLastSmtpContent(content().copy());
+        return (LastSmtpContent) super.copy();
     }
 
     @Override
     public LastSmtpContent duplicate() {
-        return new DefaultLastSmtpContent(content().duplicate());
+        return (LastSmtpContent) super.duplicate();
     }
 
     @Override
-    public LastSmtpContent retain() {
+    public LastSmtpContent retainedDuplicate() {
+        return (LastSmtpContent) super.retainedDuplicate();
+    }
+
+    @Override
+    public LastSmtpContent replace(ByteBuf content) {
+        return new DefaultLastSmtpContent(content);
+    }
+
+    @Override
+    public DefaultLastSmtpContent retain() {
         super.retain();
         return this;
     }
 
     @Override
-    public LastSmtpContent retain(int increment) {
+    public DefaultLastSmtpContent retain(int increment) {
         super.retain(increment);
         return this;
     }
 
     @Override
-    public LastSmtpContent touch() {
+    public DefaultLastSmtpContent touch() {
         super.touch();
         return this;
     }
 
     @Override
-    public LastSmtpContent touch(Object hint) {
+    public DefaultLastSmtpContent touch(Object hint) {
         super.touch(hint);
         return this;
     }
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpContent.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpContent.java
index 01418ad81559..2aff95c4ff38 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpContent.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpContent.java
@@ -17,10 +17,12 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.DefaultByteBufHolder;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Default implementation of {@link SmtpContent} that does no validation of the raw data passed in.
  */
+@UnstableApi
 public class DefaultSmtpContent extends DefaultByteBufHolder implements SmtpContent {
 
     /**
@@ -32,12 +34,22 @@ public DefaultSmtpContent(ByteBuf data) {
 
     @Override
     public SmtpContent copy() {
-        return new DefaultSmtpContent(content().copy());
+        return (SmtpContent) super.copy();
     }
 
     @Override
     public SmtpContent duplicate() {
-        return new DefaultSmtpContent(content().duplicate());
+        return (SmtpContent) super.duplicate();
+    }
+
+    @Override
+    public SmtpContent retainedDuplicate() {
+        return (SmtpContent) super.retainedDuplicate();
+    }
+
+    @Override
+    public SmtpContent replace(ByteBuf content) {
+        return new DefaultSmtpContent(content);
     }
 
     @Override
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpRequest.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpRequest.java
index 0aacc93e8576..8f4d697d82a6 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpRequest.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpRequest.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec.smtp;
 
 import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.Collections;
 import java.util.List;
@@ -23,6 +24,7 @@
 /**
  * Default {@link SmtpRequest} implementation.
  */
+@UnstableApi
 public final class DefaultSmtpRequest implements SmtpRequest {
 
     private final SmtpCommand command;
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpResponse.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpResponse.java
index 04df671fd12e..35bc8648e503 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpResponse.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/DefaultSmtpResponse.java
@@ -15,12 +15,15 @@
  */
 package io.netty.handler.codec.smtp;
 
+import io.netty.util.internal.UnstableApi;
+
 import java.util.Collections;
 import java.util.List;
 
 /**
  * Default {@link SmtpResponse} implementation.
  */
+@UnstableApi
 public final class DefaultSmtpResponse implements SmtpResponse {
 
     private final int code;
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/LastSmtpContent.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/LastSmtpContent.java
index 6849ed5e6a6b..a26fe387e09f 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/LastSmtpContent.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/LastSmtpContent.java
@@ -17,6 +17,7 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * The last part of a sequence of {@link SmtpContent}s that are sent after a {@code DATA} request.
@@ -24,6 +25,7 @@
  * and the lines that start with a DOT must be escaped with an extra DOT as
  * specified by <a href="https://www.ietf.org/rfc/rfc2821.txt">RFC2821</a>.
  */
+@UnstableApi
 public interface LastSmtpContent extends SmtpContent {
 
     /**
@@ -40,6 +42,16 @@ public LastSmtpContent duplicate() {
             return this;
         }
 
+        @Override
+        public LastSmtpContent retainedDuplicate() {
+            return this;
+        }
+
+        @Override
+        public LastSmtpContent replace(ByteBuf content) {
+            return new DefaultLastSmtpContent(content);
+        }
+
         @Override
         public LastSmtpContent retain() {
             return this;
@@ -87,6 +99,12 @@ public boolean release(int decrement) {
     @Override
     LastSmtpContent duplicate();
 
+    @Override
+    LastSmtpContent retainedDuplicate();
+
+    @Override
+    LastSmtpContent replace(ByteBuf content);
+
     @Override
     LastSmtpContent retain();
 
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpCommand.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpCommand.java
index f1466cbc8bd4..a3d1597affc2 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpCommand.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpCommand.java
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBufUtil;
 import io.netty.util.AsciiString;
 import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -26,6 +27,7 @@
 /**
  * The command part of a {@link SmtpRequest}.
  */
+@UnstableApi
 public final class SmtpCommand {
     public static final SmtpCommand EHLO = new SmtpCommand(new AsciiString("EHLO"), false);
     public static final SmtpCommand HELO = new SmtpCommand(new AsciiString("HELO"), false);
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpContent.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpContent.java
index b30a9383958d..f1870e66d26f 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpContent.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpContent.java
@@ -15,7 +15,9 @@
  */
 package io.netty.handler.codec.smtp;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
+import io.netty.util.internal.UnstableApi;
 
 /**
  * Content that is sent after the {@code DATA} request.
@@ -23,6 +25,7 @@
  * and the lines that start with a DOT must be escaped with an extra DOT as
  * specified by <a href="https://www.ietf.org/rfc/rfc2821.txt">RFC2821</a>.
  */
+@UnstableApi
 public interface SmtpContent extends ByteBufHolder {
     @Override
     SmtpContent copy();
@@ -30,6 +33,12 @@ public interface SmtpContent extends ByteBufHolder {
     @Override
     SmtpContent duplicate();
 
+    @Override
+    SmtpContent retainedDuplicate();
+
+    @Override
+    SmtpContent replace(ByteBuf content);
+
     @Override
     SmtpContent retain();
 
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequest.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequest.java
index 73d4335678ec..c2528d4679f0 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequest.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequest.java
@@ -15,11 +15,14 @@
  */
 package io.netty.handler.codec.smtp;
 
+import io.netty.util.internal.UnstableApi;
+
 import java.util.List;
 
 /**
  * An SMTP request.
  */
+@UnstableApi
 public interface SmtpRequest {
 
     /**
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequestEncoder.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequestEncoder.java
index 12362550a3a2..1df357021c39 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequestEncoder.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequestEncoder.java
@@ -20,6 +20,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageEncoder;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.Iterator;
 import java.util.List;
@@ -28,6 +29,7 @@
 /**
  * Encoder for SMTP requests.
  */
+@UnstableApi
 public final class SmtpRequestEncoder extends MessageToMessageEncoder<Object> {
     private static final byte[] CRLF = {'\r', '\n'};
     private static final byte[] DOT_CRLF = {'.', '\r', '\n'};
@@ -74,7 +76,7 @@ protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) t
             final ByteBuf content = ((SmtpContent) msg).content();
             out.add(content.retain());
             if (msg instanceof LastSmtpContent) {
-                out.add(DOT_CRLF_BUFFER.duplicate().retain());
+                out.add(DOT_CRLF_BUFFER.retainedDuplicate());
                 contentExpected = false;
             }
         }
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequests.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequests.java
index 60b9cd1bb2e1..38398577ba99 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequests.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequests.java
@@ -17,6 +17,7 @@
 
 import io.netty.util.AsciiString;
 import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -24,6 +25,7 @@
 /**
  * Provides utility methods to create {@link SmtpRequest}s.
  */
+@UnstableApi
 public final class SmtpRequests {
 
     private static final SmtpRequest DATA = new DefaultSmtpRequest(SmtpCommand.DATA);
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponse.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponse.java
index e5159481e8b4..96a40b8a0a74 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponse.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponse.java
@@ -15,11 +15,14 @@
  */
 package io.netty.handler.codec.smtp;
 
+import io.netty.util.internal.UnstableApi;
+
 import java.util.List;
 
 /**
  * A SMTP response
  */
+@UnstableApi
 public interface SmtpResponse {
 
     /**
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponseDecoder.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponseDecoder.java
index c8a380795321..13587b36bcd6 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponseDecoder.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponseDecoder.java
@@ -20,6 +20,7 @@
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.LineBasedFrameDecoder;
 import io.netty.util.CharsetUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -28,6 +29,7 @@
 /**
  * Decoder for SMTP responses.
  */
+@UnstableApi
 public final class SmtpResponseDecoder extends LineBasedFrameDecoder {
 
     private List<CharSequence> details;
diff --git a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/package-info.java b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/package-info.java
index fc33e43cc5ef..fd1a48eaf469 100644
--- a/codec-smtp/src/main/java/io/netty/handler/codec/smtp/package-info.java
+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/package-info.java
@@ -17,4 +17,7 @@
 /**
  * <a href="https://www.ietf.org/rfc/rfc2821.txt">SMTP</a> codec.
  */
+@UnstableApi
 package io.netty.handler.codec.smtp;
+
+import io.netty.util.internal.UnstableApi;
diff --git a/codec-socks/pom.xml b/codec-socks/pom.xml
index c6cd69d81231..b567994c5712 100644
--- a/codec-socks/pom.xml
+++ b/codec-socks/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-socks</artifactId>
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoder.java
index 231a78c25139..f3c627d8b70e 100755
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoder.java
@@ -64,7 +64,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             case SUCCESS: {
                 int readableBytes = actualReadableBytes();
                 if (readableBytes > 0) {
-                    out.add(in.readSlice(readableBytes).retain());
+                    out.add(in.readRetainedSlice(readableBytes));
                 }
                 break;
             }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ServerDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ServerDecoder.java
index cdb0e0e7c77c..f31181e9348d 100755
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ServerDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ServerDecoder.java
@@ -85,7 +85,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             case SUCCESS: {
                 int readableBytes = actualReadableBytes();
                 if (readableBytes > 0) {
-                    out.add(in.readSlice(readableBytes).retain());
+                    out.add(in.readRetainedSlice(readableBytes));
                 }
                 break;
             }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoder.java
index 1b57288c37f4..5ec0683c90b5 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoder.java
@@ -78,7 +78,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             case SUCCESS: {
                 int readableBytes = actualReadableBytes();
                 if (readableBytes > 0) {
-                    out.add(in.readSlice(readableBytes).retain());
+                    out.add(in.readRetainedSlice(readableBytes));
                 }
                 break;
             }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoder.java
index b9f36553fe04..82a16162d9b4 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoder.java
@@ -77,7 +77,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             case SUCCESS: {
                 int readableBytes = actualReadableBytes();
                 if (readableBytes > 0) {
-                    out.add(in.readSlice(readableBytes).retain());
+                    out.add(in.readRetainedSlice(readableBytes));
                 }
                 break;
             }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialRequestDecoder.java
index 17c043fae52e..0ff9646a4622 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialRequestDecoder.java
@@ -71,7 +71,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             case SUCCESS: {
                 int readableBytes = actualReadableBytes();
                 if (readableBytes > 0) {
-                    out.add(in.readSlice(readableBytes).retain());
+                    out.add(in.readRetainedSlice(readableBytes));
                 }
                 break;
             }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialResponseDecoder.java
index 125ce2ebd2be..9e8d168131e9 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5InitialResponseDecoder.java
@@ -62,7 +62,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             case SUCCESS: {
                 int readableBytes = actualReadableBytes();
                 if (readableBytes > 0) {
-                    out.add(in.readSlice(readableBytes).retain());
+                    out.add(in.readRetainedSlice(readableBytes));
                 }
                 break;
             }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthRequestDecoder.java
index db0f684c96e6..576c23e078f1 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthRequestDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthRequestDecoder.java
@@ -69,7 +69,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             case SUCCESS: {
                 int readableBytes = actualReadableBytes();
                 if (readableBytes > 0) {
-                    out.add(in.readSlice(readableBytes).retain());
+                    out.add(in.readRetainedSlice(readableBytes));
                 }
                 break;
             }
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthResponseDecoder.java
index a6386e59e9de..9c09bf9743f6 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthResponseDecoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PasswordAuthResponseDecoder.java
@@ -59,7 +59,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
             case SUCCESS: {
                 int readableBytes = actualReadableBytes();
                 if (readableBytes > 0) {
-                    out.add(in.readSlice(readableBytes).retain());
+                    out.add(in.readRetainedSlice(readableBytes));
                 }
                 break;
             }
diff --git a/codec-stomp/pom.xml b/codec-stomp/pom.xml
index 37d4e5ab838d..9ace6f0e7b6d 100644
--- a/codec-stomp/pom.xml
+++ b/codec-stomp/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-stomp</artifactId>
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultLastStompContentSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultLastStompContentSubframe.java
index eaca9f9900dd..0b49f76903e1 100644
--- a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultLastStompContentSubframe.java
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultLastStompContentSubframe.java
@@ -26,6 +26,26 @@ public DefaultLastStompContentSubframe(ByteBuf content) {
         super(content);
     }
 
+    @Override
+    public LastStompContentSubframe copy() {
+        return (LastStompContentSubframe) super.copy();
+    }
+
+    @Override
+    public LastStompContentSubframe duplicate() {
+        return (LastStompContentSubframe) super.duplicate();
+    }
+
+    @Override
+    public LastStompContentSubframe retainedDuplicate() {
+        return (LastStompContentSubframe) super.retainedDuplicate();
+    }
+
+    @Override
+    public LastStompContentSubframe replace(ByteBuf content) {
+        return new DefaultLastStompContentSubframe(content);
+    }
+
     @Override
     public DefaultLastStompContentSubframe retain() {
         super.retain();
@@ -50,16 +70,6 @@ public LastStompContentSubframe touch(Object hint) {
         return this;
     }
 
-    @Override
-    public LastStompContentSubframe copy() {
-        return new DefaultLastStompContentSubframe(content().copy());
-    }
-
-    @Override
-    public LastStompContentSubframe duplicate() {
-        return new DefaultLastStompContentSubframe(content().duplicate());
-    }
-
     @Override
     public String toString() {
         return "DefaultLastStompContent{" +
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompContentSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompContentSubframe.java
index d38566c7b11a..a3bb3aad5abb 100644
--- a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompContentSubframe.java
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompContentSubframe.java
@@ -17,76 +17,63 @@
 
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.DefaultByteBufHolder;
 import io.netty.handler.codec.DecoderResult;
 
 /**
  * The default {@link StompContentSubframe} implementation.
  */
-public class DefaultStompContentSubframe implements StompContentSubframe {
+public class DefaultStompContentSubframe extends DefaultByteBufHolder implements StompContentSubframe {
     private DecoderResult decoderResult = DecoderResult.SUCCESS;
-    private final ByteBuf content;
 
     public DefaultStompContentSubframe(ByteBuf content) {
-        if (content == null) {
-            throw new NullPointerException("content");
-        }
-        this.content = content;
+        super(content);
     }
 
     @Override
-    public ByteBuf content() {
-        return content;
+    public StompContentSubframe copy() {
+        return (StompContentSubframe) super.copy();
     }
 
     @Override
-    public StompContentSubframe copy() {
-        return new DefaultStompContentSubframe(content().copy());
+    public StompContentSubframe duplicate() {
+        return (StompContentSubframe) super.duplicate();
     }
 
     @Override
-    public StompContentSubframe duplicate() {
-        return new DefaultStompContentSubframe(content().duplicate());
+    public StompContentSubframe retainedDuplicate() {
+        return (StompContentSubframe) super.retainedDuplicate();
     }
 
     @Override
-    public int refCnt() {
-        return content().refCnt();
+    public StompContentSubframe replace(ByteBuf content) {
+        return new DefaultStompContentSubframe(content);
     }
 
     @Override
     public StompContentSubframe retain() {
-        content().retain();
+        super.retain();
         return this;
     }
 
     @Override
     public StompContentSubframe retain(int increment) {
-        content().retain(increment);
+        super.retain(increment);
         return this;
     }
 
     @Override
     public StompContentSubframe touch() {
-        content.touch();
+        super.touch();
         return this;
     }
 
     @Override
     public StompContentSubframe touch(Object hint) {
-        content.touch(hint);
+        super.touch(hint);
         return this;
     }
 
-    @Override
-    public boolean release() {
-        return content().release();
-    }
-
-    @Override
-    public boolean release(int decrement) {
-        return content().release(decrement);
-    }
-
     @Override
     public DecoderResult decoderResult() {
         return decoderResult;
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java
index 5332ced4715e..d113ed6f2b7d 100644
--- a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java
@@ -45,12 +45,22 @@ public ByteBuf content() {
 
     @Override
     public StompFrame copy() {
-        return new DefaultStompFrame(command, content.copy());
+        return replace(content.copy());
     }
 
     @Override
     public StompFrame duplicate() {
-        return new DefaultStompFrame(command, content.duplicate());
+        return replace(content.duplicate());
+    }
+
+    @Override
+    public StompFrame retainedDuplicate() {
+        return replace(content.retainedDuplicate());
+    }
+
+    @Override
+    public StompFrame replace(ByteBuf content) {
+        return new DefaultStompFrame(command, content);
     }
 
     @Override
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/LastStompContentSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/LastStompContentSubframe.java
index 138d24edbcdc..1cc018f75a4f 100644
--- a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/LastStompContentSubframe.java
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/LastStompContentSubframe.java
@@ -44,6 +44,16 @@ public LastStompContentSubframe duplicate() {
             return this;
         }
 
+        @Override
+        public LastStompContentSubframe retainedDuplicate() {
+            return this;
+        }
+
+        @Override
+        public LastStompContentSubframe replace(ByteBuf content) {
+            return new DefaultLastStompContentSubframe(content);
+        }
+
         @Override
         public LastStompContentSubframe retain() {
             return this;
@@ -96,6 +106,12 @@ public void setDecoderResult(DecoderResult result) {
     @Override
     LastStompContentSubframe duplicate();
 
+    @Override
+    LastStompContentSubframe retainedDuplicate();
+
+    @Override
+    LastStompContentSubframe replace(ByteBuf content);
+
     @Override
     LastStompContentSubframe retain();
 
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompContentSubframe.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompContentSubframe.java
index 7b55edb89375..3b1da86b3966 100644
--- a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompContentSubframe.java
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompContentSubframe.java
@@ -15,6 +15,7 @@
  */
 package io.netty.handler.codec.stomp;
 
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
 import io.netty.channel.ChannelPipeline;
 
@@ -32,6 +33,12 @@ public interface StompContentSubframe extends ByteBufHolder, StompSubframe {
     @Override
     StompContentSubframe duplicate();
 
+    @Override
+    StompContentSubframe retainedDuplicate();
+
+    @Override
+    StompContentSubframe replace(ByteBuf content);
+
     @Override
     StompContentSubframe retain();
 
diff --git a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompFrame.java b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompFrame.java
index 254ac6073c3a..e7fd844d29c1 100644
--- a/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompFrame.java
+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompFrame.java
@@ -15,6 +15,8 @@
  */
 package io.netty.handler.codec.stomp;
 
+import io.netty.buffer.ByteBuf;
+
 /**
  * Combines {@link StompHeadersSubframe} and {@link LastStompContentSubframe} into one
  * frame. So it represent a <i>complete</i> STOMP frame.
@@ -26,6 +28,12 @@ public interface StompFrame extends StompHeadersSubframe, LastStompContentSubfra
     @Override
     StompFrame duplicate();
 
+    @Override
+    StompFrame retainedDuplicate();
+
+    @Override
+    StompFrame replace(ByteBuf content);
+
     @Override
     StompFrame retain();
 
diff --git a/codec-xml/pom.xml b/codec-xml/pom.xml
index abd5254c76d9..4dfbc490f136 100644
--- a/codec-xml/pom.xml
+++ b/codec-xml/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec-xml</artifactId>
diff --git a/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java
index a5add5de0da1..918001851f76 100644
--- a/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java
+++ b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java
@@ -15,7 +15,7 @@
  */
 package io.netty.handler.codec.xml;
 
-import com.fasterxml.aalto.AsyncInputFeeder;
+import com.fasterxml.aalto.AsyncByteArrayFeeder;
 import com.fasterxml.aalto.AsyncXMLInputFactory;
 import com.fasterxml.aalto.AsyncXMLStreamReader;
 import com.fasterxml.aalto.stax.InputFactoryImpl;
@@ -38,8 +38,8 @@ public class XmlDecoder extends ByteToMessageDecoder {
     private static final AsyncXMLInputFactory XML_INPUT_FACTORY = new InputFactoryImpl();
     private static final XmlDocumentEnd XML_DOCUMENT_END = XmlDocumentEnd.INSTANCE;
 
-    private final AsyncXMLStreamReader streamReader = XML_INPUT_FACTORY.createAsyncXMLStreamReader();
-    private final AsyncInputFeeder streamFeeder = streamReader.getInputFeeder();
+    private final AsyncXMLStreamReader streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();
+    private final AsyncByteArrayFeeder streamFeeder = (AsyncByteArrayFeeder) streamReader.getInputFeeder();
 
     @Override
     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
diff --git a/codec/pom.xml b/codec/pom.xml
index 288d62bcae12..25f4e3729bb7 100644
--- a/codec/pom.xml
+++ b/codec/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-codec</artifactId>
diff --git a/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
index ad42f602e783..8d9f7deb8d08 100644
--- a/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java
@@ -22,7 +22,6 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.socket.ChannelInputShutdownEvent;
-import io.netty.util.internal.RecyclableArrayList;
 import io.netty.util.internal.StringUtil;
 
 import java.util.List;
@@ -120,11 +119,10 @@ public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)
                 if (cumulation instanceof CompositeByteBuf) {
                     composite = (CompositeByteBuf) cumulation;
                 } else {
-                    int readable = cumulation.readableBytes();
                     composite = alloc.compositeBuffer(Integer.MAX_VALUE);
-                    composite.addComponent(cumulation).writerIndex(readable);
+                    composite.addComponent(true, cumulation);
                 }
-                composite.addComponent(in).writerIndex(composite.writerIndex() + in.readableBytes());
+                composite.addComponent(true, in);
                 buffer = composite;
             }
             return buffer;
@@ -233,7 +231,7 @@ protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception { }
     @Override
     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
         if (msg instanceof ByteBuf) {
-            RecyclableArrayList out = RecyclableArrayList.newInstance();
+            CodecOutputList out = CodecOutputList.newInstance();
             try {
                 ByteBuf data = (ByteBuf) msg;
                 first = cumulation == null;
@@ -273,8 +271,21 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
      * Get {@code numElements} out of the {@link List} and forward these through the pipeline.
      */
     static void fireChannelRead(ChannelHandlerContext ctx, List<Object> msgs, int numElements) {
+        if (msgs instanceof CodecOutputList) {
+            fireChannelRead(ctx, (CodecOutputList) msgs, numElements);
+        } else {
+            for (int i = 0; i < numElements; i++) {
+                ctx.fireChannelRead(msgs.get(i));
+            }
+        }
+    }
+
+    /**
+     * Get {@code numElements} out of the {@link CodecOutputList} and forward these through the pipeline.
+     */
+    static void fireChannelRead(ChannelHandlerContext ctx, CodecOutputList msgs, int numElements) {
         for (int i = 0; i < numElements; i ++) {
-            ctx.fireChannelRead(msgs.get(i));
+            ctx.fireChannelRead(msgs.getUnsafe(i));
         }
     }
 
@@ -321,14 +332,9 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
     }
 
     private void channelInputClosed(ChannelHandlerContext ctx, boolean callChannelInactive) throws Exception {
-        RecyclableArrayList out = RecyclableArrayList.newInstance();
+        CodecOutputList out = CodecOutputList.newInstance();
         try {
-            if (cumulation != null) {
-                callDecode(ctx, cumulation, out);
-                decodeLast(ctx, cumulation, out);
-            } else {
-                decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);
-            }
+            channelInputClosed(ctx, out);
         } catch (DecoderException e) {
             throw e;
         } catch (Exception e) {
@@ -349,12 +355,25 @@ private void channelInputClosed(ChannelHandlerContext ctx, boolean callChannelIn
                     ctx.fireChannelInactive();
                 }
             } finally {
-                // recycle in all cases
+                // Recycle in all cases
                 out.recycle();
             }
         }
     }
 
+    /**
+     * Called when the input of the channel was closed which may be because it changed to inactive or because of
+     * {@link ChannelInputShutdownEvent}.
+     */
+    void channelInputClosed(ChannelHandlerContext ctx, List<Object> out) throws Exception {
+        if (cumulation != null) {
+            callDecode(ctx, cumulation, out);
+            decodeLast(ctx, cumulation, out);
+        } else {
+            decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);
+        }
+    }
+
     /**
      * Called once data should be decoded from the given {@link ByteBuf}. This method will call
      * {@link #decode(ChannelHandlerContext, ByteBuf, List)} as long as decoding should take place.
diff --git a/codec/src/main/java/io/netty/handler/codec/CodecOutputList.java b/codec/src/main/java/io/netty/handler/codec/CodecOutputList.java
new file mode 100644
index 000000000000..23d6317e1594
--- /dev/null
+++ b/codec/src/main/java/io/netty/handler/codec/CodecOutputList.java
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec;
+
+import io.netty.util.Recycler;
+
+import java.util.AbstractList;
+import java.util.RandomAccess;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * Special {@link AbstractList} implementation which is used within our codec base classes.
+ */
+final class CodecOutputList extends AbstractList<Object> implements RandomAccess {
+
+    private static final Recycler<CodecOutputList> RECYCLER = new Recycler<CodecOutputList>() {
+        @Override
+        protected CodecOutputList newObject(Handle<CodecOutputList> handle) {
+            return new CodecOutputList(handle);
+        }
+    };
+
+    static CodecOutputList newInstance() {
+        return RECYCLER.get();
+    }
+
+    private final Recycler.Handle<CodecOutputList> handle;
+    private int size;
+    // Size of 16 should be good enough for 99 % of all users.
+    private Object[] array = new Object[16];
+    private boolean insertSinceRecycled;
+
+    private CodecOutputList(Recycler.Handle<CodecOutputList> handle) {
+        this.handle = handle;
+    }
+
+    @Override
+    public Object get(int index) {
+        checkIndex(index);
+        return array[index];
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    @Override
+    public boolean add(Object element) {
+        checkNotNull(element, "element");
+        try {
+            insert(size, element);
+        } catch (IndexOutOfBoundsException ignore) {
+            // This should happen very infrequently so we just catch the exception and try again.
+            expandArray();
+            insert(size, element);
+        }
+        ++ size;
+        return true;
+    }
+
+    @Override
+    public Object set(int index, Object element) {
+        checkNotNull(element, "element");
+        checkIndex(index);
+
+        Object old = array[index];
+        insert(index, element);
+        return old;
+    }
+
+    @Override
+    public void add(int index, Object element) {
+        checkNotNull(element, "element");
+        checkIndex(index);
+
+        if (size == array.length) {
+            expandArray();
+        }
+
+        if (index != size - 1) {
+            System.arraycopy(array, index, array, index + 1, size - index);
+        }
+
+        insert(index, element);
+        ++ size;
+    }
+
+    @Override
+    public Object remove(int index) {
+        checkIndex(index);
+        Object old = array[index];
+
+        int len = size - index - 1;
+        if (len > 0) {
+            System.arraycopy(array, index + 1, array, index, len);
+        }
+        array[-- size] = null;
+
+        return old;
+    }
+
+    @Override
+    public void clear() {
+        // We only set the size to 0 and not null out the array. Null out the array will explicit requested by
+        // calling recycle()
+        size = 0;
+    }
+
+    /**
+     * Returns {@code true} if any elements where added or set. This will be reset once {@link #recycle()} was called.
+     */
+    boolean insertSinceRecycled() {
+        return insertSinceRecycled;
+    }
+
+    /**
+     * Recycle the array which will clear it and null out all entries in the internal storage.
+     */
+    void recycle() {
+        for (int i = 0 ; i < size; i ++) {
+            array[i] = null;
+        }
+        clear();
+        insertSinceRecycled = false;
+        handle.recycle(this);
+    }
+
+    /**
+     * Returns the element on the given index. This operation will not do any range-checks and so is considered unsafe.
+     */
+    Object getUnsafe(int index) {
+        return array[index];
+    }
+
+    private void checkIndex(int index) {
+        if (index >= size) {
+            throw new IndexOutOfBoundsException();
+        }
+    }
+
+    private void insert(int index, Object element) {
+        array[index] = element;
+        insertSinceRecycled = true;
+    }
+
+    private void expandArray() {
+        // double capacity
+        int newCapacity = array.length << 1;
+
+        if (newCapacity < 0) {
+            throw new OutOfMemoryError();
+        }
+
+        Object[] newArray = new Object[newCapacity];
+        System.arraycopy(array, 0, newArray, 0, array.length);
+
+        array = newArray;
+    }
+}
diff --git a/codec/src/main/java/io/netty/handler/codec/DatagramPacketEncoder.java b/codec/src/main/java/io/netty/handler/codec/DatagramPacketEncoder.java
index bbdc89e1c0a5..7ada7d0e76a6 100644
--- a/codec/src/main/java/io/netty/handler/codec/DatagramPacketEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/DatagramPacketEncoder.java
@@ -22,8 +22,6 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.socket.DatagramPacket;
 import io.netty.handler.codec.protobuf.ProtobufEncoder;
-import io.netty.util.ReferenceCountUtil;
-import io.netty.util.internal.RecyclableArrayList;
 import io.netty.util.internal.StringUtil;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
@@ -62,6 +60,7 @@ public DatagramPacketEncoder(MessageToMessageEncoder<? super M> encoder) {
     @Override
     public boolean acceptOutboundMessage(Object msg) throws Exception {
         if (super.acceptOutboundMessage(msg)) {
+            @SuppressWarnings("rawtypes")
             AddressedEnvelope envelope = (AddressedEnvelope) msg;
             return encoder.acceptOutboundMessage(envelope.content())
                     && envelope.sender() instanceof InetSocketAddress
@@ -73,28 +72,20 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
     @Override
     protected void encode(
             ChannelHandlerContext ctx, AddressedEnvelope<M, InetSocketAddress> msg, List<Object> out) throws Exception {
-        RecyclableArrayList buffers = null;
-        try {
-            buffers = RecyclableArrayList.newInstance();
-            encoder.encode(ctx, msg.content(), buffers);
-            if (buffers.size() != 1) {
-                throw new EncoderException(
-                        StringUtil.simpleClassName(encoder) + " must produce only one message.");
-            }
-            Object content = buffers.get(0);
-            if (content instanceof ByteBuf) {
-                out.add(new DatagramPacket(((ByteBuf) content).retain(), msg.recipient(), msg.sender()));
-            } else {
-                throw new EncoderException(
-                        StringUtil.simpleClassName(encoder) + " must produce only ByteBuf.");
-            }
-        } finally {
-            if (buffers != null) {
-                for (Object o : buffers) {
-                    ReferenceCountUtil.release(o);
-                }
-                buffers.recycle();
-            }
+        assert out.isEmpty();
+
+        encoder.encode(ctx, msg.content(), out);
+        if (out.size() != 1) {
+            throw new EncoderException(
+                    StringUtil.simpleClassName(encoder) + " must produce only one message.");
+        }
+        Object content = out.get(0);
+        if (content instanceof ByteBuf) {
+            // Replace the ByteBuf with a DatagramPacket.
+            out.set(0, new DatagramPacket((ByteBuf) content, msg.recipient(), msg.sender()));
+        } else {
+            throw new EncoderException(
+                    StringUtil.simpleClassName(encoder) + " must produce only ByteBuf.");
         }
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
index 0cb276bca586..27e8c201576e 100644
--- a/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java
@@ -268,13 +268,13 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Except
             }
 
             if (stripDelimiter) {
-                frame = buffer.readSlice(minFrameLength);
+                frame = buffer.readRetainedSlice(minFrameLength);
                 buffer.skipBytes(minDelimLength);
             } else {
-                frame = buffer.readSlice(minFrameLength + minDelimLength);
+                frame = buffer.readRetainedSlice(minFrameLength + minDelimLength);
             }
 
-            return frame.retain();
+            return frame;
         } else {
             if (!discardingTooLongFrame) {
                 if (buffer.readableBytes() > maxFrameLength) {
diff --git a/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
index bef42a6ab80f..5b4bb7187c50 100644
--- a/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java
@@ -74,7 +74,7 @@ protected Object decode(
         if (in.readableBytes() < frameLength) {
             return null;
         } else {
-            return in.readSlice(frameLength).retain();
+            return in.readRetainedSlice(frameLength);
         }
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
index 608ff27f526c..e6268a927eec 100644
--- a/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java
@@ -491,7 +491,7 @@ private void failIfNecessary(boolean firstDetectionOfTooLongFrame) {
      * is overridden to avoid memory copy.
      */
     protected ByteBuf extractFrame(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {
-        return buffer.slice(index, length).retain();
+        return buffer.retainedSlice(index, length);
     }
 
     private void fail(long frameLength) {
diff --git a/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
index 9b231c766cd8..7ab4bff183b8 100644
--- a/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java
@@ -101,13 +101,13 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Except
                 }
 
                 if (stripDelimiter) {
-                    frame = buffer.readSlice(length);
+                    frame = buffer.readRetainedSlice(length);
                     buffer.skipBytes(delimLength);
                 } else {
-                    frame = buffer.readSlice(length + delimLength);
+                    frame = buffer.readRetainedSlice(length + delimLength);
                 }
 
-                return frame.retain();
+                return frame;
             } else {
                 final int length = buffer.readableBytes();
                 if (length > maxLength) {
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java
index 43d7ae9c7d34..9c30837be991 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java
@@ -320,8 +320,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     private static void appendPartialContent(CompositeByteBuf content, ByteBuf partialContent) {
         if (partialContent.isReadable()) {
             partialContent.retain();
-            content.addComponent(partialContent);
-            content.writerIndex(content.writerIndex() + partialContent.readableBytes());
+            content.addComponent(true, partialContent);
         }
     }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
index 23926ee58401..797e8b70f945 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java
@@ -21,7 +21,6 @@
 import io.netty.channel.ChannelPipeline;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.ReferenceCounted;
-import io.netty.util.internal.RecyclableArrayList;
 import io.netty.util.internal.TypeParameterMatcher;
 
 import java.util.List;
@@ -80,7 +79,7 @@ public boolean acceptInboundMessage(Object msg) throws Exception {
 
     @Override
     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        RecyclableArrayList out = RecyclableArrayList.newInstance();
+        CodecOutputList out = CodecOutputList.newInstance();
         try {
             if (acceptInboundMessage(msg)) {
                 @SuppressWarnings("unchecked")
@@ -100,7 +99,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         } finally {
             int size = out.size();
             for (int i = 0; i < size; i ++) {
-                ctx.fireChannelRead(out.get(i));
+                ctx.fireChannelRead(out.getUnsafe(i));
             }
             out.recycle();
         }
diff --git a/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
index 1a2cc034c221..f133cfdf2a04 100644
--- a/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java
@@ -22,7 +22,6 @@
 import io.netty.channel.ChannelPromise;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.ReferenceCounted;
-import io.netty.util.internal.RecyclableArrayList;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.TypeParameterMatcher;
 
@@ -79,10 +78,10 @@ public boolean acceptOutboundMessage(Object msg) throws Exception {
 
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
-        RecyclableArrayList out = null;
+        CodecOutputList out = null;
         try {
             if (acceptOutboundMessage(msg)) {
-                out = RecyclableArrayList.newInstance();
+                out = CodecOutputList.newInstance();
                 @SuppressWarnings("unchecked")
                 I cast = (I) msg;
                 try {
@@ -122,9 +121,9 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
                         } else {
                             p = ctx.newPromise();
                         }
-                        ctx.write(out.get(i), p);
+                        ctx.write(out.getUnsafe(i), p);
                     }
-                    ctx.write(out.get(sizeMinusOne), promise);
+                    ctx.write(out.getUnsafe(sizeMinusOne), promise);
                 }
                 out.recycle();
             }
diff --git a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
index 8b9fbed6df18..1fa42b242ca8 100644
--- a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java
@@ -16,6 +16,7 @@
 package io.netty.handler.codec;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPipeline;
@@ -322,37 +323,19 @@ protected S state(S newState) {
     }
 
     @Override
-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        RecyclableArrayList out = RecyclableArrayList.newInstance();
+    final void channelInputClosed(ChannelHandlerContext ctx, List<Object> out) throws Exception {
         try {
             replayable.terminate();
-            callDecode(ctx, internalBuffer(), out);
-            decodeLast(ctx, replayable, out);
+            if (cumulation != null) {
+                callDecode(ctx, internalBuffer(), out);
+                decodeLast(ctx, replayable, out);
+            } else {
+                replayable.setCumulation(Unpooled.EMPTY_BUFFER);
+                decodeLast(ctx, replayable, out);
+            }
         } catch (Signal replay) {
             // Ignore
             replay.expect(REPLAY);
-        } catch (DecoderException e) {
-            throw e;
-        } catch (Exception e) {
-            throw new DecoderException(e);
-        } finally {
-            try {
-                if (cumulation != null) {
-                    cumulation.release();
-                    cumulation = null;
-                }
-
-                int size = out.size();
-                if (size > 0) {
-                    fireChannelRead(ctx, out, size);
-                    // Something was read, call fireChannelReadComplete()
-                    ctx.fireChannelReadComplete();
-                }
-                ctx.fireChannelInactive();
-            } finally {
-                // recycle in all cases
-                out.recycle();
-            }
         }
     }
 
@@ -367,6 +350,15 @@ protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> ou
                 if (outSize > 0) {
                     fireChannelRead(ctx, out, outSize);
                     out.clear();
+
+                    // Check if this handler was removed before continuing with decoding.
+                    // If it was removed, it is not safe to continue to operate on the buffer.
+                    //
+                    // See:
+                    // - https://github.com/netty/netty/issues/4635
+                    if (ctx.isRemoved()) {
+                        break;
+                    }
                     outSize = 0;
                 }
 
diff --git a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderByteBuf.java b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderByteBuf.java
index 99f8b04eab95..5e71b7dac6c4 100644
--- a/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderByteBuf.java
+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderByteBuf.java
@@ -74,8 +74,7 @@ public int capacity() {
 
     @Override
     public ByteBuf capacity(int newCapacity) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -88,6 +87,17 @@ public ByteBufAllocator alloc() {
         return buffer.alloc();
     }
 
+    @Override
+    public boolean isReadOnly() {
+        return false;
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public ByteBuf asReadOnly() {
+        return Unpooled.unmodifiableBuffer(this);
+    }
+
     @Override
     public boolean isDirect() {
         return buffer.isDirect();
@@ -120,8 +130,7 @@ public long memoryAddress() {
 
     @Override
     public ByteBuf clear() {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -131,14 +140,12 @@ public boolean equals(Object obj) {
 
     @Override
     public int compareTo(ByteBuf buffer) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public ByteBuf copy() {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -149,26 +156,27 @@ public ByteBuf copy(int index, int length) {
 
     @Override
     public ByteBuf discardReadBytes() {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf ensureWritable(int writableBytes) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public int ensureWritable(int minWritableBytes, boolean force) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public ByteBuf duplicate() {
-        reject();
-        return this;
+        throw reject();
+    }
+
+    @Override
+    public ByteBuf retainedDuplicate() {
+        throw reject();
     }
 
     @Override
@@ -205,8 +213,7 @@ public ByteBuf getBytes(int index, byte[] dst) {
 
     @Override
     public ByteBuf getBytes(int index, ByteBuffer dst) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -218,32 +225,27 @@ public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
 
     @Override
     public ByteBuf getBytes(int index, ByteBuf dst, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf getBytes(int index, ByteBuf dst) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public int getBytes(int index, GatheringByteChannel out, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public int getBytes(int index, FileChannel out, long position, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public ByteBuf getBytes(int index, OutputStream out, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -348,10 +350,15 @@ public double getDouble(int index) {
         return buffer.getDouble(index);
     }
 
+    @Override
+    public CharSequence getCharSequence(int index, int length, Charset charset) {
+        checkIndex(index, length);
+        return buffer.getCharSequence(index, length, charset);
+    }
+
     @Override
     public int hashCode() {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
@@ -434,8 +441,7 @@ public int forEachByteDesc(ByteProcessor processor) {
         if (terminated) {
             return buffer.forEachByteDesc(processor);
         } else {
-            reject();
-            return 0;
+            throw reject();
         }
     }
 
@@ -456,8 +462,7 @@ public ByteBuf markReaderIndex() {
 
     @Override
     public ByteBuf markWriterIndex() {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -534,8 +539,7 @@ public ByteBuf readBytes(byte[] dst) {
 
     @Override
     public ByteBuf readBytes(ByteBuffer dst) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -547,8 +551,7 @@ public ByteBuf readBytes(ByteBuf dst, int dstIndex, int length) {
 
     @Override
     public ByteBuf readBytes(ByteBuf dst, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -560,14 +563,12 @@ public ByteBuf readBytes(ByteBuf dst) {
 
     @Override
     public int readBytes(GatheringByteChannel out, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public int readBytes(FileChannel out, long position, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
@@ -582,10 +583,15 @@ public ByteBuf readSlice(int length) {
         return buffer.readSlice(length);
     }
 
+    @Override
+    public ByteBuf readRetainedSlice(int length) {
+        checkReadableBytes(length);
+        return buffer.readRetainedSlice(length);
+    }
+
     @Override
     public ByteBuf readBytes(OutputStream out, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -701,6 +707,12 @@ public double readDouble() {
         return buffer.readDouble();
     }
 
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        checkReadableBytes(length);
+        return buffer.readCharSequence(length, charset);
+    }
+
     @Override
     public ByteBuf resetReaderIndex() {
         buffer.resetReaderIndex();
@@ -709,152 +721,127 @@ public ByteBuf resetReaderIndex() {
 
     @Override
     public ByteBuf resetWriterIndex() {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setBoolean(int index, boolean value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setByte(int index, int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setBytes(int index, byte[] src) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setBytes(int index, ByteBuffer src) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setBytes(int index, ByteBuf src, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setBytes(int index, ByteBuf src) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public int setBytes(int index, InputStream in, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public ByteBuf setZero(int index, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public int setBytes(int index, ScatteringByteChannel in, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public int setBytes(int index, FileChannel in, long position, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public ByteBuf setIndex(int readerIndex, int writerIndex) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setInt(int index, int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setIntLE(int index, int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setLong(int index, long value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setLongLE(int index, long value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setMedium(int index, int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setMediumLE(int index, int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setShort(int index, int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setShortLE(int index, int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setChar(int index, int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setFloat(int index, float value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf setDouble(int index, double value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -866,8 +853,12 @@ public ByteBuf skipBytes(int length) {
 
     @Override
     public ByteBuf slice() {
-        reject();
-        return this;
+        throw reject();
+    }
+
+    @Override
+    public ByteBuf retainedSlice() {
+        throw reject();
     }
 
     @Override
@@ -876,6 +867,12 @@ public ByteBuf slice(int index, int length) {
         return buffer.slice(index, length);
     }
 
+    @Override
+    public ByteBuf retainedSlice(int index, int length) {
+        checkIndex(index, length);
+        return buffer.slice(index, length);
+    }
+
     @Override
     public int nioBufferCount() {
         return buffer.nioBufferCount();
@@ -883,8 +880,7 @@ public int nioBufferCount() {
 
     @Override
     public ByteBuffer nioBuffer() {
-        reject();
-        return null;
+        throw reject();
     }
 
     @Override
@@ -895,8 +891,7 @@ public ByteBuffer nioBuffer(int index, int length) {
 
     @Override
     public ByteBuffer[] nioBuffers() {
-        reject();
-        return null;
+        throw reject();
     }
 
     @Override
@@ -919,8 +914,7 @@ public String toString(int index, int length, Charset charset) {
 
     @Override
     public String toString(Charset charsetName) {
-        reject();
-        return null;
+        throw reject();
     }
 
     @Override
@@ -956,110 +950,92 @@ public int maxWritableBytes() {
 
     @Override
     public ByteBuf writeBoolean(boolean value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeByte(int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeBytes(byte[] src, int srcIndex, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeBytes(byte[] src) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeBytes(ByteBuffer src) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeBytes(ByteBuf src, int srcIndex, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeBytes(ByteBuf src, int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeBytes(ByteBuf src) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public int writeBytes(InputStream in, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public int writeBytes(ScatteringByteChannel in, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public int writeBytes(FileChannel in, long position, int length) {
-        reject();
-        return 0;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeInt(int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeIntLE(int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeLong(long value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeLongLE(long value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeMedium(int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeMediumLE(int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeZero(int length) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -1069,38 +1045,42 @@ public int writerIndex() {
 
     @Override
     public ByteBuf writerIndex(int writerIndex) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeShort(int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeShortLE(int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeChar(int value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeFloat(float value) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf writeDouble(double value) {
-        reject();
-        return this;
+        throw reject();
+    }
+
+    @Override
+    public int setCharSequence(int index, CharSequence sequence, Charset charset) {
+        throw reject();
+    }
+
+    @Override
+    public int writeCharSequence(CharSequence sequence, Charset charset) {
+        throw reject();
     }
 
     private void checkIndex(int index, int length) {
@@ -1117,8 +1097,7 @@ private void checkReadableBytes(int readableBytes) {
 
     @Override
     public ByteBuf discardSomeReadBytes() {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -1128,14 +1107,12 @@ public int refCnt() {
 
     @Override
     public ByteBuf retain() {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
     public ByteBuf retain(int increment) {
-        reject();
-        return this;
+        throw reject();
     }
 
     @Override
@@ -1152,23 +1129,20 @@ public ByteBuf touch(Object hint) {
 
     @Override
     public boolean release() {
-        reject();
-        return false;
+        throw reject();
     }
 
     @Override
     public boolean release(int decrement) {
-        reject();
-        return false;
+        throw reject();
     }
 
     @Override
     public ByteBuf unwrap() {
-        reject();
-        return this;
+        throw reject();
     }
 
-    private static void reject() {
-        throw new UnsupportedOperationException("not a replayable operation");
+    private static UnsupportedOperationException reject() {
+        return new UnsupportedOperationException("not a replayable operation");
     }
 }
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java b/codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java
index 4443f71d4e63..2aef048030c2 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java
@@ -24,11 +24,11 @@
 
 import java.util.List;
 
-import static com.ning.compress.lzf.LZFChunk.BYTE_Z;
+import static com.ning.compress.lzf.LZFChunk.BLOCK_TYPE_COMPRESSED;
+import static com.ning.compress.lzf.LZFChunk.BLOCK_TYPE_NON_COMPRESSED;
 import static com.ning.compress.lzf.LZFChunk.BYTE_V;
+import static com.ning.compress.lzf.LZFChunk.BYTE_Z;
 import static com.ning.compress.lzf.LZFChunk.HEADER_LEN_NOT_COMPRESSED;
-import static com.ning.compress.lzf.LZFChunk.BLOCK_TYPE_NON_COMPRESSED;
-import static com.ning.compress.lzf.LZFChunk.BLOCK_TYPE_COMPRESSED;
 
 /**
  * Uncompresses a {@link ByteBuf} encoded with the LZF format.
@@ -189,7 +189,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                         recycler.releaseInputBuffer(inputArray);
                     }
                 } else if (chunkLength > 0) {
-                    out.add(in.readSlice(chunkLength).retain());
+                    out.add(in.readRetainedSlice(chunkLength));
                 }
 
                 currentState = State.INIT_BLOCK;
diff --git a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java
index 4ec65aa4b6d1..30af58d050b4 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java
@@ -22,7 +22,7 @@
 import java.util.Arrays;
 import java.util.List;
 
-import static io.netty.handler.codec.compression.Snappy.*;
+import static io.netty.handler.codec.compression.Snappy.validateChecksum;
 
 /**
  * Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.
@@ -153,7 +153,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                     } else {
                         in.skipBytes(4);
                     }
-                    out.add(in.readSlice(chunkLength - 4).retain());
+                    out.add(in.readRetainedSlice(chunkLength - 4));
                     break;
                 case COMPRESSED_DATA:
                     if (!started) {
diff --git a/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java
index b791e410370d..7af1d74646cc 100644
--- a/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java
@@ -177,7 +177,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
      */
     @SuppressWarnings("UnusedParameters")
     protected ByteBuf extractObject(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {
-        return buffer.slice(index, length).retain();
+        return buffer.retainedSlice(index, length);
     }
 
     private void decodeByte(byte c, ByteBuf in, int idx) {
@@ -190,9 +190,22 @@ private void decodeByte(byte c, ByteBuf in, int idx) {
             // also contain braces/brackets and that could lead to incorrect results.
             if (!insideString) {
                 insideString = true;
-            // If the double quote wasn't escaped then this is the end of a string.
-            } else if (in.getByte(idx - 1) != '\\') {
-                insideString = false;
+            } else {
+                int backslashCount = 0;
+                idx--;
+                while (idx >= 0) {
+                    if (in.getByte(idx) == '\\') {
+                        backslashCount++;
+                        idx--;
+                    } else {
+                        break;
+                    }
+                }
+                // The double quote isn't escaped only if there are even "\"s.
+                if (backslashCount % 2 == 0) {
+                    // Since the double quote isn't escaped then this is the end of a string.
+                    insideString = false;
+                }
             }
         }
     }
diff --git a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
index 35ed8d9aaea9..c02e76e80ebb 100644
--- a/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java
@@ -15,14 +15,15 @@
  */
 package io.netty.handler.codec.protobuf;
 
-import java.io.IOException;
-import java.util.List;
-
+import com.google.protobuf.CodedInputStream;
+import com.google.protobuf.nano.CodedInputByteBufferNano;
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.CorruptedFrameException;
 
+import java.util.List;
+
 /**
  * A decoder that splits the received {@link ByteBuf}s dynamically by the
  * value of the Google Protocol Buffers
@@ -36,7 +37,7 @@
  * +--------+---------------+      +---------------+
  * </pre>
  *
- * @see {@link CodedInputStream } or {@link CodedInputByteBufferNano}
+ * @see {@link CodedInputStream} or {@link CodedInputByteBufferNano}
  */
 public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder {
 
@@ -58,10 +59,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
 
         if (in.readableBytes() < length) {
             in.resetReaderIndex();
-            return;
         } else {
-            out.add(in.readSlice(length).retain());
-            return;
+            out.add(in.readRetainedSlice(length));
         }
     }
 
@@ -69,9 +68,8 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
      * Reads variable length 32bit int from buffer
      *
      * @return decoded int if buffers readerIndex has been forwarded else nonsense value
-     * @throws IOException
      */
-    private static int readRawVarint32(ByteBuf buffer) throws IOException {
+    private static int readRawVarint32(ByteBuf buffer) {
         if (!buffer.isReadable()) {
             return 0;
         }
diff --git a/codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java
index aa7e86f1ea81..ac519bab068c 100644
--- a/codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/LengthFieldBasedFrameDecoderTest.java
@@ -21,7 +21,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 
-import static io.netty.util.ReferenceCountUtil.*;
+import static io.netty.util.ReferenceCountUtil.releaseLater;
 
 public class LengthFieldBasedFrameDecoderTest {
 
@@ -64,12 +64,12 @@ public void testDiscardTooLongFrame2() {
         buf.writeByte('a');
         EmbeddedChannel channel = new EmbeddedChannel(new LengthFieldBasedFrameDecoder(16, 0, 4));
         try {
-            channel.writeInbound(buf.readSlice(14).retain());
+            channel.writeInbound(buf.readRetainedSlice(14));
             Assert.fail();
         } catch (TooLongFrameException e) {
             // expected
         }
-        Assert.assertTrue(channel.writeInbound(buf.readSlice(buf.readableBytes()).retain()));
+        Assert.assertTrue(channel.writeInbound(buf.readRetainedSlice(buf.readableBytes())));
 
         Assert.assertTrue(channel.finish());
 
diff --git a/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
index 7539c23e4481..a539597268dd 100644
--- a/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java
@@ -20,11 +20,13 @@
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.embedded.EmbeddedChannel;
+import io.netty.channel.socket.ChannelInputShutdownEvent;
 import org.junit.Test;
 
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.atomic.AtomicReference;
 
 import static io.netty.util.ReferenceCountUtil.*;
 import static org.junit.Assert.*;
@@ -43,7 +45,7 @@ public void testLineProtocol() {
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'C' }));
         assertNull(ch.readInbound());
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { '\n' }));
-        assertEquals(Unpooled.wrappedBuffer(new byte[] { 'A', 'B', 'C' }), ch.readInbound());
+        assertEquals(Unpooled.wrappedBuffer(new byte[] { 'A', 'B', 'C' }), releaseLater(ch.readInbound()));
 
         // Truncated input
         ch.writeInbound(Unpooled.wrappedBuffer(new byte[] { 'A' }));
@@ -225,4 +227,39 @@ public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
         assertEquals(3, (int) queue.take());
         assertTrue(queue.isEmpty());
     }
+
+    @Test
+    public void testChannelInputShutdownEvent() {
+        final AtomicReference<Error> error = new AtomicReference<Error>();
+
+        EmbeddedChannel channel = new EmbeddedChannel(new ReplayingDecoder<Integer>(0) {
+            private boolean decoded;
+
+            @Override
+            protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+                if (!(in instanceof ReplayingDecoderByteBuf)) {
+                    error.set(new AssertionError("in must be of type " + ReplayingDecoderByteBuf.class
+                            + " but was " + in.getClass()));
+                    return;
+                }
+                if (!decoded) {
+                    decoded = true;
+                    in.readByte();
+                    state(1);
+                } else {
+                    // This will throw an ReplayingError
+                    in.skipBytes(Integer.MAX_VALUE);
+                }
+            }
+        });
+
+        assertFalse(channel.writeInbound(Unpooled.wrappedBuffer(new byte[] {0, 1})));
+        channel.pipeline().fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
+        assertFalse(channel.finishAndReleaseAll());
+
+        Error err = error.get();
+        if (err != null) {
+            throw err;
+        }
+    }
 }
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/AbstractDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/AbstractDecoderTest.java
index 29634c627a8f..6267217d4035 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/AbstractDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/AbstractDecoderTest.java
@@ -28,7 +28,8 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 @RunWith(Theories.class)
 public abstract class AbstractDecoderTest extends AbstractCompressionTest {
@@ -106,8 +107,8 @@ protected void testDecompressionOfBatchedFlow(final ByteBuf expected, final Byte
         final int compressedLength = data.readableBytes();
         int written = 0, length = rand.nextInt(100);
         while (written + length < compressedLength) {
-            ByteBuf compressedBuf = data.slice(written, length);
-            channel.writeInbound(compressedBuf.retain());
+            ByteBuf compressedBuf = data.retainedSlice(written, length);
+            channel.writeInbound(compressedBuf);
             written += length;
             length = rand.nextInt(100);
         }
@@ -125,8 +126,7 @@ protected static ByteBuf readDecompressed(final EmbeddedChannel channel) {
         CompositeByteBuf decompressed = Unpooled.compositeBuffer();
         ByteBuf msg;
         while ((msg = channel.readInbound()) != null) {
-            decompressed.addComponent(msg);
-            decompressed.writerIndex(decompressed.writerIndex() + msg.readableBytes());
+            decompressed.addComponent(true, msg);
         }
         return decompressed;
     }
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/AbstractEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/AbstractEncoderTest.java
index 93a130384f5a..ba07dca1189f 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/AbstractEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/AbstractEncoderTest.java
@@ -26,7 +26,8 @@
 import org.junit.experimental.theories.Theory;
 import org.junit.runner.RunWith;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 @RunWith(Theories.class)
 public abstract class AbstractEncoderTest extends AbstractCompressionTest {
@@ -88,13 +89,13 @@ protected void testCompressionOfBatchedFlow(final ByteBuf data) throws Exception
         final int dataLength = data.readableBytes();
         int written = 0, length = rand.nextInt(100);
         while (written + length < dataLength) {
-            ByteBuf in = data.slice(written, length);
-            assertTrue(channel.writeOutbound(in.retain()));
+            ByteBuf in = data.retainedSlice(written, length);
+            assertTrue(channel.writeOutbound(in));
             written += length;
             length = rand.nextInt(100);
         }
-        ByteBuf in = data.slice(written, dataLength - written);
-        assertTrue(channel.writeOutbound(in.retain()));
+        ByteBuf in = data.retainedSlice(written, dataLength - written);
+        assertTrue(channel.writeOutbound(in));
         assertTrue(channel.finish());
 
         ByteBuf decompressed = readDecompressed(dataLength);
@@ -108,8 +109,7 @@ protected ByteBuf readDecompressed(final int dataLength) throws Exception {
         CompositeByteBuf compressed = Unpooled.compositeBuffer();
         ByteBuf msg;
         while ((msg = channel.readOutbound()) != null) {
-            compressed.addComponent(msg);
-            compressed.writerIndex(compressed.writerIndex() + msg.readableBytes());
+            compressed.addComponent(true, msg);
         }
         ByteBuf decompressed =  decompress(compressed, dataLength);
         compressed.release();
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/AbstractIntegrationTest.java b/codec/src/test/java/io/netty/handler/codec/compression/AbstractIntegrationTest.java
index b0b81394809f..9ce264c13104 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/AbstractIntegrationTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/AbstractIntegrationTest.java
@@ -150,8 +150,7 @@ protected void testIdentity(final byte[] data) {
         final CompositeByteBuf compressed = Unpooled.compositeBuffer();
         ByteBuf msg;
         while ((msg = encoder.readOutbound()) != null) {
-            compressed.addComponent(msg);
-            compressed.writerIndex(compressed.writerIndex() + msg.readableBytes());
+            compressed.addComponent(true, msg);
         }
         assertThat(compressed, is(notNullValue()));
 
@@ -159,8 +158,7 @@ protected void testIdentity(final byte[] data) {
         assertFalse(compressed.isReadable());
         final CompositeByteBuf decompressed = Unpooled.compositeBuffer();
         while ((msg = decoder.readInbound()) != null) {
-            decompressed.addComponent(msg);
-            decompressed.writerIndex(decompressed.writerIndex() + msg.readableBytes());
+            decompressed.addComponent(true, msg);
         }
         assertEquals(in.resetReaderIndex(), decompressed);
 
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/FastLzIntegrationTest.java b/codec/src/test/java/io/netty/handler/codec/compression/FastLzIntegrationTest.java
index 2bb074657ea2..8740ba5452f3 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/FastLzIntegrationTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/FastLzIntegrationTest.java
@@ -79,8 +79,7 @@ protected void testIdentity(final byte[] data) {
         ByteBuf msg;
         final CompositeByteBuf compressed = Unpooled.compositeBuffer();
         while ((msg = encoder.readOutbound()) != null) {
-            compressed.addComponent(msg);
-            compressed.writerIndex(compressed.writerIndex() + msg.readableBytes());
+            compressed.addComponent(true, msg);
         }
         assertThat(compressed, is(notNullValue()));
 
@@ -100,8 +99,7 @@ protected void testIdentity(final byte[] data) {
         assertFalse(compressed.isReadable());
         final CompositeByteBuf decompressed = Unpooled.compositeBuffer();
         while ((msg = decoder.readInbound()) != null) {
-            decompressed.addComponent(msg);
-            decompressed.writerIndex(decompressed.writerIndex() + msg.readableBytes());
+            decompressed.addComponent(true, msg);
         }
         assertEquals(original, decompressed);
 
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/LzmaFrameEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/LzmaFrameEncoderTest.java
index 8f4fb7b39ca2..d0fbd069b5c1 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/LzmaFrameEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/LzmaFrameEncoderTest.java
@@ -29,7 +29,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 public class LzmaFrameEncoderTest extends AbstractEncoderTest {
 
@@ -50,16 +51,16 @@ protected void testCompressionOfBatchedFlow(final ByteBuf data) throws Exception
         final int dataLength = data.readableBytes();
         int written = 0, length = rand.nextInt(50);
         while (written + length < dataLength) {
-            ByteBuf in = data.slice(written, length);
-            assertTrue(channel.writeOutbound(in.retain()));
+            ByteBuf in = data.retainedSlice(written, length);
+            assertTrue(channel.writeOutbound(in));
             written += length;
             originalLengths.add(length);
             length = rand.nextInt(50);
         }
         length = dataLength - written;
-        ByteBuf in = data.slice(written, dataLength - written);
+        ByteBuf in = data.retainedSlice(written, dataLength - written);
         originalLengths.add(length);
-        assertTrue(channel.writeOutbound(in.retain()));
+        assertTrue(channel.writeOutbound(in));
         assertTrue(channel.finish());
 
         CompositeByteBuf decompressed = Unpooled.compositeBuffer();
@@ -67,8 +68,7 @@ protected void testCompressionOfBatchedFlow(final ByteBuf data) throws Exception
         int i = 0;
         while ((msg = channel.readOutbound()) != null) {
             ByteBuf decompressedMsg = decompress(msg, originalLengths.get(i++));
-            decompressed.addComponent(decompressedMsg);
-            decompressed.writerIndex(decompressed.writerIndex() + decompressedMsg.readableBytes());
+            decompressed.addComponent(true, decompressedMsg);
             msg.release();
         }
         assertEquals(originalLengths.size(), i);
diff --git a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFrameEncoderTest.java b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFrameEncoderTest.java
index 5947a93b11e3..330a6f27181f 100644
--- a/codec/src/test/java/io/netty/handler/codec/compression/SnappyFrameEncoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFrameEncoderTest.java
@@ -94,8 +94,7 @@ public void testStreamStartIsOnlyWrittenOnce() throws Exception {
             if (m == null) {
                 break;
             }
-            actual.addComponent(m);
-            actual.writerIndex(actual.writerIndex() + m.readableBytes());
+            actual.addComponent(true, m);
         }
         assertEquals(releaseLater(expected), releaseLater(actual));
     }
diff --git a/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java
index 08ece60917bc..083b4eb1d43e 100644
--- a/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java
@@ -87,6 +87,51 @@ public void testSingleByteStream() {
         assertFalse(ch.finish());
     }
 
+    @Test
+    public void testBackslashInString1() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+        // {"foo" : "bar\""}
+        String json = "{\"foo\" : \"bar\\\"\"}";
+        System.out.println(json);
+        ch.writeInbound(Unpooled.copiedBuffer(json, CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(json, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testBackslashInString2() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+        // {"foo" : "bar\\"}
+        String json = "{\"foo\" : \"bar\\\\\"}";
+        System.out.println(json);
+        ch.writeInbound(Unpooled.copiedBuffer(json, CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(json, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
+    @Test
+    public void testBackslashInString3() {
+        EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
+        // {"foo" : "bar\\\""}
+        String json = "{\"foo\" : \"bar\\\\\\\"\"}";
+        System.out.println(json);
+        ch.writeInbound(Unpooled.copiedBuffer(json, CharsetUtil.UTF_8));
+
+        ByteBuf res = ch.readInbound();
+        assertEquals(json, res.toString(CharsetUtil.UTF_8));
+        res.release();
+
+        assertFalse(ch.finish());
+    }
+
     @Test
     public void testMultipleJsonObjectsInOneWrite() {
         EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());
diff --git a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
index 79c2bfb2174a..1cf2b92c995d 100644
--- a/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
+++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java
@@ -28,7 +28,10 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 public abstract class AbstractCompatibleMarshallingDecoderTest {
     @SuppressWarnings("RedundantStringConstructorCall")
@@ -81,9 +84,9 @@ public void testFragmentedUnmarshalling() throws IOException {
         byte[] testBytes = bout.toByteArray();
 
         ByteBuf buffer = input(testBytes);
-        ByteBuf slice = buffer.readSlice(2);
+        ByteBuf slice = buffer.readRetainedSlice(2);
 
-        ch.writeInbound(slice.retain());
+        ch.writeInbound(slice);
         ch.writeInbound(buffer);
         assertTrue(ch.finish());
 
diff --git a/common/pom.xml b/common/pom.xml
index ff57732cc55e..0d682ce53557 100644
--- a/common/pom.xml
+++ b/common/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-common</artifactId>
diff --git a/common/src/main/java/io/netty/util/BooleanSupplier.java b/common/src/main/java/io/netty/util/BooleanSupplier.java
new file mode 100644
index 000000000000..9f6a5ba62a4b
--- /dev/null
+++ b/common/src/main/java/io/netty/util/BooleanSupplier.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util;
+
+/**
+ * Represents a supplier of {@code boolean}-valued results.
+ */
+public interface BooleanSupplier {
+    /**
+     * Gets a boolean value.
+     * @return a boolean value.
+     * @throws Exception If an exception occurs.
+     */
+    boolean get() throws Exception;
+
+    /**
+     * A supplier which always returns {@code false} and never throws.
+     */
+    BooleanSupplier FALSE_SUPPLIER = new BooleanSupplier() {
+        @Override
+        public boolean get() {
+            return false;
+        }
+    };
+
+    /**
+     * A supplier which always returns {@code true} and never throws.
+     */
+    BooleanSupplier TRUE_SUPPLIER = new BooleanSupplier() {
+        @Override
+        public boolean get() {
+            return true;
+        }
+    };
+}
diff --git a/common/src/main/java/io/netty/util/DomainMappingBuilder.java b/common/src/main/java/io/netty/util/DomainMappingBuilder.java
index 0cdb9712b7dd..e0dcf7dafb0e 100644
--- a/common/src/main/java/io/netty/util/DomainMappingBuilder.java
+++ b/common/src/main/java/io/netty/util/DomainMappingBuilder.java
@@ -16,21 +16,16 @@
 
 package io.netty.util;
 
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Set;
-
-import static io.netty.util.internal.ObjectUtil.checkNotNull;
-
 /**
  * Builder for immutable {@link DomainNameMapping} instances.
  *
  * @param <V> concrete type of value objects
+ * @deprecated Use {@link DomainNameMappingBuilder} instead.
  */
+@Deprecated
 public final class DomainMappingBuilder<V> {
 
-    private final V defaultValue;
-    private final Map<String, V> map;
+    private final DomainNameMappingBuilder<V> builder;
 
     /**
      * Constructor with default initial capacity of the map holding the mappings
@@ -39,7 +34,7 @@ public final class DomainMappingBuilder<V> {
      *                     when nothing matches the input
      */
     public DomainMappingBuilder(V defaultValue) {
-        this(4, defaultValue);
+        builder = new DomainNameMappingBuilder<V>(defaultValue);
     }
 
     /**
@@ -50,8 +45,7 @@ public DomainMappingBuilder(V defaultValue) {
      *                        when nothing matches the input
      */
     public DomainMappingBuilder(int initialCapacity, V defaultValue) {
-        this.defaultValue = checkNotNull(defaultValue, "defaultValue");
-        this.map = new LinkedHashMap<String, V>(initialCapacity);
+        builder = new DomainNameMappingBuilder<V>(initialCapacity, defaultValue);
     }
 
     /**
@@ -67,7 +61,7 @@ public DomainMappingBuilder(int initialCapacity, V defaultValue) {
      *                 when the specified host name matches the specified input host name
      */
     public DomainMappingBuilder<V> add(String hostname, V output) {
-        map.put(checkNotNull(hostname, "hostname"), checkNotNull(output, "output"));
+        builder.add(hostname, output);
         return this;
     }
 
@@ -78,114 +72,6 @@ public DomainMappingBuilder<V> add(String hostname, V output) {
      * @return new {@link DomainNameMapping} instance
      */
     public DomainNameMapping<V> build() {
-        return new ImmutableDomainNameMapping<V>(this.defaultValue, this.map);
-    }
-
-    /**
-     * Immutable mapping from domain name pattern to its associated value object.
-     * Mapping is represented by two arrays: keys and values. Key domainNamePatterns[i] is associated with values[i].
-     *
-     * @param <V> concrete type of value objects
-     */
-    private static final class ImmutableDomainNameMapping<V> extends DomainNameMapping<V> {
-        private static final String REPR_HEADER = "ImmutableDomainNameMapping(default: ";
-        private static final String REPR_MAP_OPENING = ", map: {";
-        private static final String REPR_MAP_CLOSING = "})";
-        private static final int REPR_CONST_PART_LENGTH =
-            REPR_HEADER.length() + REPR_MAP_OPENING.length() + REPR_MAP_CLOSING.length();
-
-        private final String[] domainNamePatterns;
-        private final V[] values;
-
-        @SuppressWarnings("unchecked")
-        private ImmutableDomainNameMapping(V defaultValue, Map<String, V> map) {
-            super(null, defaultValue);
-
-            Set<Map.Entry<String, V>> mappings = map.entrySet();
-            int numberOfMappings = mappings.size();
-            domainNamePatterns = new String[numberOfMappings];
-            values = (V[]) new Object[numberOfMappings];
-
-            int index = 0;
-            for (Map.Entry<String, V> mapping : mappings) {
-                domainNamePatterns[index] = normalizeHostname(mapping.getKey());
-                values[index] = mapping.getValue();
-                ++index;
-            }
-        }
-
-        @Override
-        @Deprecated
-        public DomainNameMapping<V> add(String hostname, V output) {
-            throw new UnsupportedOperationException(
-                "Immutable DomainNameMapping does not support modification after initial creation");
-        }
-
-        @Override
-        public V map(String hostname) {
-            if (hostname != null) {
-                hostname = normalizeHostname(hostname);
-
-                int length = domainNamePatterns.length;
-                for (int index = 0; index < length; ++index) {
-                    if (matches(domainNamePatterns[index], hostname)) {
-                        return values[index];
-                    }
-                }
-            }
-
-            return defaultValue;
-        }
-
-        @Override
-        public String toString() {
-            String defaultValueStr = defaultValue.toString();
-
-            int numberOfMappings = domainNamePatterns.length;
-            if (numberOfMappings == 0) {
-                return REPR_HEADER + defaultValueStr + REPR_MAP_OPENING + REPR_MAP_CLOSING;
-            }
-
-            String pattern0 = domainNamePatterns[0];
-            String value0 = values[0].toString();
-            int oneMappingLength = pattern0.length() + value0.length() + 3; // 2 for separator ", " and 1 for '='
-            int estimatedBufferSize = estimateBufferSize(defaultValueStr.length(), numberOfMappings, oneMappingLength);
-
-            StringBuilder sb = new StringBuilder(estimatedBufferSize)
-                .append(REPR_HEADER).append(defaultValueStr).append(REPR_MAP_OPENING);
-
-            appendMapping(sb, pattern0, value0);
-            for (int index = 1; index < numberOfMappings; ++index) {
-                sb.append(", ");
-                appendMapping(sb, index);
-            }
-
-            return sb.append(REPR_MAP_CLOSING).toString();
-        }
-
-        /**
-         * Estimates the length of string representation of the given instance:
-         * est = lengthOfConstantComponents + defaultValueLength + (estimatedMappingLength * numOfMappings) * 1.10
-         *
-         * @param defaultValueLength     length of string representation of {@link #defaultValue}
-         * @param numberOfMappings       number of mappings the given instance holds,
-         *                               e.g. {@link #domainNamePatterns#length}
-         * @param estimatedMappingLength estimated size taken by one mapping
-         * @return estimated length of string returned by {@link #toString()}
-         */
-        private static int estimateBufferSize(int defaultValueLength,
-                                              int numberOfMappings,
-                                              int estimatedMappingLength) {
-            return REPR_CONST_PART_LENGTH + defaultValueLength
-                + (int) (estimatedMappingLength * numberOfMappings * 1.10);
-        }
-
-        private StringBuilder appendMapping(StringBuilder sb, int mappingIndex) {
-            return appendMapping(sb, domainNamePatterns[mappingIndex], values[mappingIndex].toString());
-        }
-
-        private static StringBuilder appendMapping(StringBuilder sb, String domainNamePattern, String value) {
-            return sb.append(domainNamePattern).append('=').append(value);
-        }
+        return builder.build();
     }
 }
diff --git a/common/src/main/java/io/netty/util/DomainNameMapping.java b/common/src/main/java/io/netty/util/DomainNameMapping.java
index ff9aeb9cb0ab..d1734aa712c9 100644
--- a/common/src/main/java/io/netty/util/DomainNameMapping.java
+++ b/common/src/main/java/io/netty/util/DomainNameMapping.java
@@ -19,6 +19,7 @@
 import io.netty.util.internal.StringUtil;
 
 import java.net.IDN;
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Locale;
 import java.util.Map;
@@ -37,13 +38,14 @@ public class DomainNameMapping<V> implements Mapping<String, V> {
 
     final V defaultValue;
     private final Map<String, V> map;
+    private final Map<String, V> unmodifiableMap;
 
     /**
      * Creates a default, order-sensitive mapping. If your hostnames are in conflict, the mapping
      * will choose the one you add first.
      *
      * @param defaultValue the default value for {@link #map(String)} to return when nothing matches the input
-     * @deprecated use {@link DomainMappingBuilder} to create and fill the mapping instead
+     * @deprecated use {@link DomainNameMappingBuilder} to create and fill the mapping instead
      */
     @Deprecated
     public DomainNameMapping(V defaultValue) {
@@ -56,7 +58,7 @@ public DomainNameMapping(V defaultValue) {
      *
      * @param initialCapacity initial capacity for the internal map
      * @param defaultValue    the default value for {@link #map(String)} to return when nothing matches the input
-     * @deprecated use {@link DomainMappingBuilder} to create and fill the mapping instead
+     * @deprecated use {@link DomainNameMappingBuilder} to create and fill the mapping instead
      */
     @Deprecated
     public DomainNameMapping(int initialCapacity, V defaultValue) {
@@ -66,6 +68,8 @@ public DomainNameMapping(int initialCapacity, V defaultValue) {
     DomainNameMapping(Map<String, V> map, V defaultValue) {
         this.defaultValue = checkNotNull(defaultValue, "defaultValue");
         this.map = map;
+        unmodifiableMap = map != null ? Collections.unmodifiableMap(map)
+                                      : null;
     }
 
     /**
@@ -78,7 +82,7 @@ public DomainNameMapping(int initialCapacity, V defaultValue) {
      * @param hostname the host name (optionally wildcard)
      * @param output   the output value that will be returned by {@link #map(String)} when the specified host name
      *                 matches the specified input host name
-     * @deprecated use {@link DomainMappingBuilder} to create and fill the mapping instead
+     * @deprecated use {@link DomainNameMappingBuilder} to create and fill the mapping instead
      */
     @Deprecated
     public DomainNameMapping<V> add(String hostname, V output) {
@@ -132,6 +136,13 @@ public V map(String hostname) {
         return defaultValue;
     }
 
+    /**
+     * Returns a read-only {@link Map} of the domain mapping patterns and their associated value objects.
+     */
+    public Map<String, V> asMap() {
+        return unmodifiableMap;
+    }
+
     @Override
     public String toString() {
         return StringUtil.simpleClassName(this) + "(default: " + defaultValue + ", map: " + map + ')';
diff --git a/common/src/main/java/io/netty/util/DomainNameMappingBuilder.java b/common/src/main/java/io/netty/util/DomainNameMappingBuilder.java
new file mode 100644
index 000000000000..4bf360c5fa45
--- /dev/null
+++ b/common/src/main/java/io/netty/util/DomainNameMappingBuilder.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Set;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+/**
+ * Builder for immutable {@link DomainNameMapping} instances.
+ *
+ * @param <V> concrete type of value objects
+ */
+public final class DomainNameMappingBuilder<V> {
+
+    private final V defaultValue;
+    private final Map<String, V> map;
+
+    /**
+     * Constructor with default initial capacity of the map holding the mappings
+     *
+     * @param defaultValue the default value for {@link DomainNameMapping#map(String)} to return
+     *                     when nothing matches the input
+     */
+    public DomainNameMappingBuilder(V defaultValue) {
+        this(4, defaultValue);
+    }
+
+    /**
+     * Constructor with initial capacity of the map holding the mappings
+     *
+     * @param initialCapacity initial capacity for the internal map
+     * @param defaultValue    the default value for {@link DomainNameMapping#map(String)} to return
+     *                        when nothing matches the input
+     */
+    public DomainNameMappingBuilder(int initialCapacity, V defaultValue) {
+        this.defaultValue = checkNotNull(defaultValue, "defaultValue");
+        map = new LinkedHashMap<String, V>(initialCapacity);
+    }
+
+    /**
+     * Adds a mapping that maps the specified (optionally wildcard) host name to the specified output value.
+     * Null values are forbidden for both hostnames and values.
+     * <p>
+     * <a href="http://en.wikipedia.org/wiki/Wildcard_DNS_record">DNS wildcard</a> is supported as hostname.
+     * For example, you can use {@code *.netty.io} to match {@code netty.io} and {@code downloads.netty.io}.
+     * </p>
+     *
+     * @param hostname the host name (optionally wildcard)
+     * @param output   the output value that will be returned by {@link DomainNameMapping#map(String)}
+     *                 when the specified host name matches the specified input host name
+     */
+    public DomainNameMappingBuilder<V> add(String hostname, V output) {
+        map.put(checkNotNull(hostname, "hostname"), checkNotNull(output, "output"));
+        return this;
+    }
+
+    /**
+     * Creates a new instance of immutable {@link DomainNameMapping}
+     * Attempts to add new mappings to the result object will cause {@link UnsupportedOperationException} to be thrown
+     *
+     * @return new {@link DomainNameMapping} instance
+     */
+    public DomainNameMapping<V> build() {
+        return new ImmutableDomainNameMapping<V>(defaultValue, map);
+    }
+
+    /**
+     * Immutable mapping from domain name pattern to its associated value object.
+     * Mapping is represented by two arrays: keys and values. Key domainNamePatterns[i] is associated with values[i].
+     *
+     * @param <V> concrete type of value objects
+     */
+    private static final class ImmutableDomainNameMapping<V> extends DomainNameMapping<V> {
+        private static final String REPR_HEADER = "ImmutableDomainNameMapping(default: ";
+        private static final String REPR_MAP_OPENING = ", map: {";
+        private static final String REPR_MAP_CLOSING = "})";
+        private static final int REPR_CONST_PART_LENGTH =
+            REPR_HEADER.length() + REPR_MAP_OPENING.length() + REPR_MAP_CLOSING.length();
+
+        private final String[] domainNamePatterns;
+        private final V[] values;
+        private final Map<String, V> map;
+
+        @SuppressWarnings("unchecked")
+        private ImmutableDomainNameMapping(V defaultValue, Map<String, V> map) {
+            super(null, defaultValue);
+
+            Set<Map.Entry<String, V>> mappings = map.entrySet();
+            int numberOfMappings = mappings.size();
+            domainNamePatterns = new String[numberOfMappings];
+            values = (V[]) new Object[numberOfMappings];
+
+            final Map<String, V> mapCopy = new LinkedHashMap<String, V>(map.size());
+            int index = 0;
+            for (Map.Entry<String, V> mapping : mappings) {
+                final String hostname = normalizeHostname(mapping.getKey());
+                final V value = mapping.getValue();
+                domainNamePatterns[index] = hostname;
+                values[index] = value;
+                mapCopy.put(hostname, value);
+                ++index;
+            }
+
+            this.map = Collections.unmodifiableMap(mapCopy);
+        }
+
+        @Override
+        @Deprecated
+        public DomainNameMapping<V> add(String hostname, V output) {
+            throw new UnsupportedOperationException(
+                "Immutable DomainNameMapping does not support modification after initial creation");
+        }
+
+        @Override
+        public V map(String hostname) {
+            if (hostname != null) {
+                hostname = normalizeHostname(hostname);
+
+                int length = domainNamePatterns.length;
+                for (int index = 0; index < length; ++index) {
+                    if (matches(domainNamePatterns[index], hostname)) {
+                        return values[index];
+                    }
+                }
+            }
+
+            return defaultValue;
+        }
+
+        @Override
+        public Map<String, V> asMap() {
+            return map;
+        }
+
+        @Override
+        public String toString() {
+            String defaultValueStr = defaultValue.toString();
+
+            int numberOfMappings = domainNamePatterns.length;
+            if (numberOfMappings == 0) {
+                return REPR_HEADER + defaultValueStr + REPR_MAP_OPENING + REPR_MAP_CLOSING;
+            }
+
+            String pattern0 = domainNamePatterns[0];
+            String value0 = values[0].toString();
+            int oneMappingLength = pattern0.length() + value0.length() + 3; // 2 for separator ", " and 1 for '='
+            int estimatedBufferSize = estimateBufferSize(defaultValueStr.length(), numberOfMappings, oneMappingLength);
+
+            StringBuilder sb = new StringBuilder(estimatedBufferSize)
+                .append(REPR_HEADER).append(defaultValueStr).append(REPR_MAP_OPENING);
+
+            appendMapping(sb, pattern0, value0);
+            for (int index = 1; index < numberOfMappings; ++index) {
+                sb.append(", ");
+                appendMapping(sb, index);
+            }
+
+            return sb.append(REPR_MAP_CLOSING).toString();
+        }
+
+        /**
+         * Estimates the length of string representation of the given instance:
+         * est = lengthOfConstantComponents + defaultValueLength + (estimatedMappingLength * numOfMappings) * 1.10
+         *
+         * @param defaultValueLength     length of string representation of {@link #defaultValue}
+         * @param numberOfMappings       number of mappings the given instance holds,
+         *                               e.g. {@link #domainNamePatterns#length}
+         * @param estimatedMappingLength estimated size taken by one mapping
+         * @return estimated length of string returned by {@link #toString()}
+         */
+        private static int estimateBufferSize(int defaultValueLength,
+                                              int numberOfMappings,
+                                              int estimatedMappingLength) {
+            return REPR_CONST_PART_LENGTH + defaultValueLength
+                + (int) (estimatedMappingLength * numberOfMappings * 1.10);
+        }
+
+        private StringBuilder appendMapping(StringBuilder sb, int mappingIndex) {
+            return appendMapping(sb, domainNamePatterns[mappingIndex], values[mappingIndex].toString());
+        }
+
+        private static StringBuilder appendMapping(StringBuilder sb, String domainNamePattern, String value) {
+            return sb.append(domainNamePattern).append('=').append(value);
+        }
+    }
+}
diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index c18c5b3316dc..8f06787dfa7a 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -102,6 +102,10 @@ public final T get() {
         return (T) handle.value;
     }
 
+    /**
+     * @deprecated use {@link Handle#recycle(Object)}.
+     */
+    @Deprecated
     public final boolean recycle(T o, Handle<T> handle) {
         if (handle == NOOP_HANDLE) {
             return false;
diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
index 0a7d654ef690..5ef1b7e94b01 100644
--- a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java
@@ -19,8 +19,6 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.Set;
 import java.util.concurrent.AbstractExecutorService;
 import java.util.concurrent.Callable;
 import java.util.concurrent.RunnableFuture;
@@ -35,7 +33,7 @@ public abstract class AbstractEventExecutor extends AbstractExecutorService impl
     static final long DEFAULT_SHUTDOWN_TIMEOUT = 15;
 
     private final EventExecutorGroup parent;
-    private final Collection<AbstractEventExecutor> selfCollection = Collections.singleton(this);
+    private final Collection<EventExecutor> selfCollection = Collections.<EventExecutor>singleton(this);
 
     protected AbstractEventExecutor() {
         this(null);
@@ -62,12 +60,7 @@ public boolean inEventLoop() {
 
     @Override
     public Iterator<EventExecutor> iterator() {
-        return new EventExecutorIterator();
-    }
-
-    @Override
-    public <E extends EventExecutor> Set<E> children() {
-        return (Set<E>) selfCollection;
+        return selfCollection.iterator();
     }
 
     @Override
@@ -157,27 +150,4 @@ public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDela
     public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
         throw new UnsupportedOperationException();
     }
-
-    private final class EventExecutorIterator implements Iterator<EventExecutor> {
-        private boolean nextCalled;
-
-        @Override
-        public boolean hasNext() {
-            return !nextCalled;
-        }
-
-        @Override
-        public EventExecutor next() {
-            if (!hasNext()) {
-                throw new NoSuchElementException();
-            }
-            nextCalled = true;
-            return AbstractEventExecutor.this;
-        }
-
-        @Override
-        public void remove() {
-            throw new UnsupportedOperationException("read-only");
-        }
-    }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
index bb3eb02aa190..75d607e39c68 100644
--- a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java
@@ -25,45 +25,72 @@
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.util.ArrayDeque;
+import java.util.Queue;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
-
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultPromise.class);
     private static final InternalLogger rejectedExecutionLogger =
             InternalLoggerFactory.getInstance(DefaultPromise.class.getName() + ".rejectedExecution");
-
     private static final int MAX_LISTENER_STACK_DEPTH = 8;
+    private static final AtomicReferenceFieldUpdater<DefaultPromise, Object> RESULT_UPDATER;
     private static final Signal SUCCESS = Signal.valueOf(DefaultPromise.class, "SUCCESS");
     private static final Signal UNCANCELLABLE = Signal.valueOf(DefaultPromise.class, "UNCANCELLABLE");
     private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder(new CancellationException());
+    private static final FastThreadLocal<Queue<DefaultPromise<?>>> STACK_OVERFLOW_DELAYED_PROMISES =
+            new FastThreadLocal<Queue<DefaultPromise<?>>>() {
+        @Override
+        protected Queue<DefaultPromise<?>> initialValue() throws Exception {
+            return new ArrayDeque<DefaultPromise<?>>(2);
+        }
+    };
+    /**
+     * This queue will hold pairs of {@code <Future, GenericFutureListener>} which are always inserted sequentially.
+     * <p>
+     * This is only used for static utility method {@link #notifyListener(EventExecutor, Future, GenericFutureListener)}
+     * and not instances of {@link DefaultPromise}.
+     */
+    private static final FastThreadLocal<Queue<Object>> STACK_OVERFLOW_DELAYED_FUTURES =
+            new FastThreadLocal<Queue<Object>>() {
+        @Override
+        protected Queue<Object> initialValue() throws Exception {
+            return new ArrayDeque<Object>(2);
+        }
+    };
 
     static {
+        AtomicReferenceFieldUpdater<DefaultPromise, Object> updater =
+                PlatformDependent.newAtomicReferenceFieldUpdater(DefaultPromise.class, "result");
+        RESULT_UPDATER = updater == null ? AtomicReferenceFieldUpdater.newUpdater(DefaultPromise.class,
+                                                                                  Object.class, "result") : updater;
         CANCELLATION_CAUSE_HOLDER.cause.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
     }
 
-    private final EventExecutor executor;
-
     private volatile Object result;
-
+    private final EventExecutor executor;
     /**
      * One or more listeners. Can be a {@link GenericFutureListener} or a {@link DefaultFutureListeners}.
      * If {@code null}, it means either 1) no listeners were added yet or 2) all listeners were notified.
+     *
+     * Threading - synchronized(this). We must support adding listeners when there is no EventExecutor.
      */
     private Object listeners;
-
     /**
-     * The list of the listeners that were added after the promise is done.  Initially {@code null} and lazily
-     * instantiated when the late listener is scheduled to be notified later.  Also used as a cached {@link Runnable}
-     * that performs the notification of the listeners it contains.
+     * Threading - synchronized(this). We are required to hold the monitor to use Java's underlying wait()/notifyAll().
      */
-    private LateListeners lateListeners;
-
     private short waiters;
 
+    /**
+     * Threading - synchronized(this). We must prevent concurrent notification and FIFO listener notification if the
+     * executor changes.
+     */
+    private boolean notifyingListeners;
+
     /**
      * Creates a new instance.
      *
@@ -73,10 +100,7 @@ public class DefaultPromise<V> extends AbstractFuture<V> implements Promise<V> {
      *        the {@link EventExecutor} which is used to notify the promise once it is complete
      */
     public DefaultPromise(EventExecutor executor) {
-        if (executor == null) {
-            throw new NullPointerException("executor");
-        }
-        this.executor = executor;
+        this.executor = checkNotNull(executor, "executor");
     }
 
     protected DefaultPromise() {
@@ -84,157 +108,128 @@ protected DefaultPromise() {
         executor = null;
     }
 
-    protected EventExecutor executor() {
-        return executor;
-    }
-
     @Override
-    public boolean isCancelled() {
-        return isCancelled0(result);
+    public Promise<V> setSuccess(V result) {
+        if (setSuccess0(result)) {
+            notifyListeners();
+            return this;
+        }
+        throw new IllegalStateException("complete already: " + this);
     }
 
-    private static boolean isCancelled0(Object result) {
-        return result instanceof CauseHolder && ((CauseHolder) result).cause instanceof CancellationException;
+    @Override
+    public boolean trySuccess(V result) {
+        if (setSuccess0(result)) {
+            notifyListeners();
+            return true;
+        }
+        return false;
     }
 
     @Override
-    public boolean isCancellable() {
-        return result == null;
+    public Promise<V> setFailure(Throwable cause) {
+        if (setFailure0(cause)) {
+            notifyListeners();
+            return this;
+        }
+        throw new IllegalStateException("complete already: " + this, cause);
     }
 
     @Override
-    public boolean isDone() {
-        return isDone0(result);
+    public boolean tryFailure(Throwable cause) {
+        if (setFailure0(cause)) {
+            notifyListeners();
+            return true;
+        }
+        return false;
     }
 
-    private static boolean isDone0(Object result) {
-        return result != null && result != UNCANCELLABLE;
+    @Override
+    public boolean setUncancellable() {
+        if (RESULT_UPDATER.compareAndSet(this, null, UNCANCELLABLE)) {
+            return true;
+        }
+        Object result = this.result;
+        return !isDone0(result) || !isCancelled0(result);
     }
 
     @Override
     public boolean isSuccess() {
         Object result = this.result;
-        if (result == null || result == UNCANCELLABLE) {
-            return false;
-        }
-        return !(result instanceof CauseHolder);
+        return result != null && result != UNCANCELLABLE && !(result instanceof CauseHolder);
+    }
+
+    @Override
+    public boolean isCancellable() {
+        return result == null;
     }
 
     @Override
     public Throwable cause() {
         Object result = this.result;
-        if (result instanceof CauseHolder) {
-            return ((CauseHolder) result).cause;
-        }
-        return null;
+        return (result instanceof CauseHolder) ? ((CauseHolder) result).cause : null;
     }
 
     @Override
     public Promise<V> addListener(GenericFutureListener<? extends Future<? super V>> listener) {
-        if (listener == null) {
-            throw new NullPointerException("listener");
-        }
+        checkNotNull(listener, "listener");
 
-        if (isDone()) {
-            notifyLateListener(listener);
-            return this;
+        synchronized (this) {
+            addListener0(listener);
         }
 
-        synchronized (this) {
-            if (!isDone()) {
-                if (listeners == null) {
-                    listeners = listener;
-                } else {
-                    if (listeners instanceof DefaultFutureListeners) {
-                        ((DefaultFutureListeners) listeners).add(listener);
-                    } else {
-                        final GenericFutureListener<? extends Future<V>> firstListener =
-                                (GenericFutureListener<? extends Future<V>>) listeners;
-                        listeners = new DefaultFutureListeners(firstListener, listener);
-                    }
-                }
-                return this;
-            }
+        if (isDone()) {
+            notifyListeners();
         }
 
-        notifyLateListener(listener);
         return this;
     }
 
     @Override
     public Promise<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
-        if (listeners == null) {
-            throw new NullPointerException("listeners");
-        }
+        checkNotNull(listeners, "listeners");
 
-        for (GenericFutureListener<? extends Future<? super V>> l: listeners) {
-            if (l == null) {
-                break;
+        synchronized (this) {
+            for (GenericFutureListener<? extends Future<? super V>> listener : listeners) {
+                if (listener == null) {
+                    break;
+                }
+                addListener0(listener);
             }
-            addListener(l);
-        }
-        return this;
-    }
-
-    @Override
-    public Promise<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener) {
-        if (listener == null) {
-            throw new NullPointerException("listener");
         }
 
         if (isDone()) {
-            return this;
-        }
-
-        synchronized (this) {
-            if (!isDone()) {
-                if (listeners instanceof DefaultFutureListeners) {
-                    ((DefaultFutureListeners) listeners).remove(listener);
-                } else if (listeners == listener) {
-                    listeners = null;
-                }
-            }
+            notifyListeners();
         }
 
         return this;
     }
 
     @Override
-    public Promise<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {
-        if (listeners == null) {
-            throw new NullPointerException("listeners");
-        }
+    public Promise<V> removeListener(final GenericFutureListener<? extends Future<? super V>> listener) {
+        checkNotNull(listener, "listener");
 
-        for (GenericFutureListener<? extends Future<? super V>> l: listeners) {
-            if (l == null) {
-                break;
-            }
-            removeListener(l);
+        synchronized (this) {
+            removeListener0(listener);
         }
-        return this;
-    }
 
-    @Override
-    public Promise<V> sync() throws InterruptedException {
-        await();
-        rethrowIfFailed();
         return this;
     }
 
     @Override
-    public Promise<V> syncUninterruptibly() {
-        awaitUninterruptibly();
-        rethrowIfFailed();
-        return this;
-    }
+    public Promise<V> removeListeners(final GenericFutureListener<? extends Future<? super V>>... listeners) {
+        checkNotNull(listeners, "listeners");
 
-    private void rethrowIfFailed() {
-        Throwable cause = cause();
-        if (cause == null) {
-            return;
+        synchronized (this) {
+            for (GenericFutureListener<? extends Future<? super V>> listener : listeners) {
+                if (listener == null) {
+                    break;
+                }
+                removeListener0(listener);
+            }
         }
 
-        PlatformDependent.throwException(cause);
+        return this;
     }
 
     @Override
@@ -247,9 +242,10 @@ public Promise<V> await() throws InterruptedException {
             throw new InterruptedException(toString());
         }
 
+        checkDeadLock();
+
         synchronized (this) {
             while (!isDone()) {
-                checkDeadLock();
                 incWaiters();
                 try {
                     wait();
@@ -261,27 +257,17 @@ public Promise<V> await() throws InterruptedException {
         return this;
     }
 
-    @Override
-    public boolean await(long timeout, TimeUnit unit)
-            throws InterruptedException {
-        return await0(unit.toNanos(timeout), true);
-    }
-
-    @Override
-    public boolean await(long timeoutMillis) throws InterruptedException {
-        return await0(MILLISECONDS.toNanos(timeoutMillis), true);
-    }
-
     @Override
     public Promise<V> awaitUninterruptibly() {
         if (isDone()) {
             return this;
         }
 
+        checkDeadLock();
+
         boolean interrupted = false;
         synchronized (this) {
             while (!isDone()) {
-                checkDeadLock();
                 incWaiters();
                 try {
                     wait();
@@ -301,6 +287,16 @@ public Promise<V> awaitUninterruptibly() {
         return this;
     }
 
+    @Override
+    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
+        return await0(unit.toNanos(timeout), true);
+    }
+
+    @Override
+    public boolean await(long timeoutMillis) throws InterruptedException {
+        return await0(MILLISECONDS.toNanos(timeoutMillis), true);
+    }
+
     @Override
     public boolean awaitUninterruptibly(long timeout, TimeUnit unit) {
         try {
@@ -321,89 +317,19 @@ public boolean awaitUninterruptibly(long timeoutMillis) {
         }
     }
 
-    private boolean await0(long timeoutNanos, boolean interruptable) throws InterruptedException {
-        if (isDone()) {
-            return true;
-        }
-
-        if (timeoutNanos <= 0) {
-            return isDone();
-        }
-
-        if (interruptable && Thread.interrupted()) {
-            throw new InterruptedException(toString());
-        }
-
-        long startTime = System.nanoTime();
-        long waitTime = timeoutNanos;
-        boolean interrupted = false;
-
-        try {
-            synchronized (this) {
-                if (isDone()) {
-                    return true;
-                }
-
-                if (waitTime <= 0) {
-                    return isDone();
-                }
-
-                checkDeadLock();
-                incWaiters();
-                try {
-                    for (;;) {
-                        try {
-                            wait(waitTime / 1000000, (int) (waitTime % 1000000));
-                        } catch (InterruptedException e) {
-                            if (interruptable) {
-                                throw e;
-                            } else {
-                                interrupted = true;
-                            }
-                        }
-
-                        if (isDone()) {
-                            return true;
-                        } else {
-                            waitTime = timeoutNanos - (System.nanoTime() - startTime);
-                            if (waitTime <= 0) {
-                                return isDone();
-                            }
-                        }
-                    }
-                } finally {
-                    decWaiters();
-                }
-            }
-        } finally {
-            if (interrupted) {
-                Thread.currentThread().interrupt();
-            }
-        }
-    }
-
-    /**
-     * Do deadlock checks
-     */
-    protected void checkDeadLock() {
-        EventExecutor e = executor();
-        if (e != null && e.inEventLoop()) {
-            throw new BlockingOperationException(toString());
-        }
-    }
-
     @Override
-    public Promise<V> setSuccess(V result) {
-        if (setSuccess0(result)) {
-            notifyListeners();
-            return this;
+    public V getNow() {
+        Object result = this.result;
+        if (result instanceof CauseHolder || result == SUCCESS) {
+            return null;
         }
-        throw new IllegalStateException("complete already: " + this);
+        return (V) result;
     }
 
     @Override
-    public boolean trySuccess(V result) {
-        if (setSuccess0(result)) {
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        if (RESULT_UPDATER.compareAndSet(this, null, CANCELLATION_CAUSE_HOLDER)) {
+            checkNotifyWaiters();
             notifyListeners();
             return true;
         }
@@ -411,328 +337,352 @@ public boolean trySuccess(V result) {
     }
 
     @Override
-    public Promise<V> setFailure(Throwable cause) {
-        if (setFailure0(cause)) {
-            notifyListeners();
-            return this;
-        }
-        throw new IllegalStateException("complete already: " + this, cause);
+    public boolean isCancelled() {
+        return isCancelled0(result);
     }
 
     @Override
-    public boolean tryFailure(Throwable cause) {
-        if (setFailure0(cause)) {
-            notifyListeners();
-            return true;
-        }
-        return false;
+    public boolean isDone() {
+        return isDone0(result);
     }
 
     @Override
-    public boolean cancel(boolean mayInterruptIfRunning) {
-        Object result = this.result;
-        if (isDone0(result) || result == UNCANCELLABLE) {
-            return false;
-        }
-
-        synchronized (this) {
-            // Allow only once.
-            result = this.result;
-            if (isDone0(result) || result == UNCANCELLABLE) {
-                return false;
-            }
-
-            this.result = CANCELLATION_CAUSE_HOLDER;
-            if (hasWaiters()) {
-                notifyAll();
-            }
-        }
-
-        notifyListeners();
-        return true;
+    public Promise<V> sync() throws InterruptedException {
+        await();
+        rethrowIfFailed();
+        return this;
     }
 
     @Override
-    public boolean setUncancellable() {
-        Object result = this.result;
-        if (isDone0(result)) {
-            return !isCancelled0(result);
-        }
-
-        synchronized (this) {
-            // Allow only once.
-            result = this.result;
-            if (isDone0(result)) {
-                return !isCancelled0(result);
-            }
+    public Promise<V> syncUninterruptibly() {
+        awaitUninterruptibly();
+        rethrowIfFailed();
+        return this;
+    }
 
-            this.result = UNCANCELLABLE;
-        }
-        return true;
+    @Override
+    public String toString() {
+        return toStringBuilder().toString();
     }
 
-    private boolean setFailure0(Throwable cause) {
-        if (cause == null) {
-            throw new NullPointerException("cause");
-        }
+    protected StringBuilder toStringBuilder() {
+        StringBuilder buf = new StringBuilder(64)
+                .append(StringUtil.simpleClassName(this))
+                .append('@')
+                .append(Integer.toHexString(hashCode()));
 
-        if (isDone()) {
-            return false;
+        Object result = this.result;
+        if (result == SUCCESS) {
+            buf.append("(success)");
+        } else if (result == UNCANCELLABLE) {
+            buf.append("(uncancellable)");
+        } else if (result instanceof CauseHolder) {
+            buf.append("(failure: ")
+                    .append(((CauseHolder) result).cause)
+                    .append(')');
+        } else if (result != null) {
+            buf.append("(success: ")
+                    .append(result)
+                    .append(')');
+        } else {
+            buf.append("(incomplete)");
         }
 
-        synchronized (this) {
-            // Allow only once.
-            if (isDone()) {
-                return false;
-            }
-
-            result = new CauseHolder(cause);
-            if (hasWaiters()) {
-                notifyAll();
-            }
-        }
-        return true;
+        return buf;
     }
 
-    private boolean setSuccess0(V result) {
-        if (isDone()) {
-            return false;
-        }
-
-        synchronized (this) {
-            // Allow only once.
-            if (isDone()) {
-                return false;
-            }
-            if (result == null) {
-                this.result = SUCCESS;
-            } else {
-                this.result = result;
-            }
-            if (hasWaiters()) {
-                notifyAll();
-            }
-        }
-        return true;
+    protected EventExecutor executor() {
+        return executor;
     }
 
-    @Override
-    @SuppressWarnings("unchecked")
-    public V getNow() {
-        Object result = this.result;
-        if (result instanceof CauseHolder || result == SUCCESS) {
-            return null;
+    protected void checkDeadLock() {
+        EventExecutor e = executor();
+        if (e != null && e.inEventLoop()) {
+            throw new BlockingOperationException(toString());
         }
-        return (V) result;
-    }
-
-    private boolean hasWaiters() {
-        return waiters > 0;
     }
 
-    private void incWaiters() {
-        if (waiters == Short.MAX_VALUE) {
-            throw new IllegalStateException("too many waiters: " + this);
+    /**
+     * Notify a listener that a future has completed.
+     * <p>
+     * This method has a fixed depth of {@link #MAX_LISTENER_STACK_DEPTH} that will limit recursion to prevent
+     * {@link StackOverflowError} and will stop notifying listeners added after this threshold is exceeded.
+     * @param eventExecutor the executor to use to notify the listener {@code listener}.
+     * @param future the future that is complete.
+     * @param listener the listener to notify.
+     */
+    protected static void notifyListener(
+            EventExecutor eventExecutor, final Future<?> future, final GenericFutureListener<?> listener) {
+        checkNotNull(future, "future");
+        checkNotNull(listener, "listener");
+        if (eventExecutor.inEventLoop()) {
+            notifyListenerWithStackOverFlowProtection(future, listener);
+        } else {
+            safeExecute(eventExecutor, new OneTimeTask() {
+                @Override
+                public void run() {
+                    notifyListenerWithStackOverFlowProtection(future, listener);
+                }
+            });
         }
-        waiters ++;
-    }
-
-    private void decWaiters() {
-        waiters --;
     }
 
     private void notifyListeners() {
-        // This method doesn't need synchronization because:
-        // 1) This method is always called after synchronized (this) block.
-        //    Hence any listener list modification happens-before this method.
-        // 2) This method is called only when 'done' is true.  Once 'done'
-        //    becomes true, the listener list is never modified - see add/removeListener()
-
-        Object listeners = this.listeners;
+        // Modifications to listeners should be done in a synchronized block before this, and should be visible here.
         if (listeners == null) {
             return;
         }
-
         EventExecutor executor = executor();
         if (executor.inEventLoop()) {
-            final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
-            final int stackDepth = threadLocals.futureListenerStackDepth();
-            if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                threadLocals.setFutureListenerStackDepth(stackDepth + 1);
-                try {
-                    if (listeners instanceof DefaultFutureListeners) {
-                        notifyListeners0(this, (DefaultFutureListeners) listeners);
-                    } else {
-                        final GenericFutureListener<? extends Future<V>> l =
-                                (GenericFutureListener<? extends Future<V>>) listeners;
-                        notifyListener0(this, l);
-                    }
-                } finally {
-                    this.listeners = null;
-                    threadLocals.setFutureListenerStackDepth(stackDepth);
-                }
-                return;
-            }
-        }
-
-        if (listeners instanceof DefaultFutureListeners) {
-            final DefaultFutureListeners dfl = (DefaultFutureListeners) listeners;
-            safeExecute(executor, new OneTimeTask() {
-                @Override
-                public void run() {
-                    notifyListeners0(DefaultPromise.this, dfl);
-                    DefaultPromise.this.listeners = null;
-                }
-            });
+            notifyListenersWithStackOverFlowProtection();
         } else {
-            final GenericFutureListener<? extends Future<V>> l =
-                    (GenericFutureListener<? extends Future<V>>) listeners;
             safeExecute(executor, new OneTimeTask() {
                 @Override
                 public void run() {
-                    notifyListener0(DefaultPromise.this, l);
-                    DefaultPromise.this.listeners = null;
+                    notifyListenersWithStackOverFlowProtection();
                 }
             });
         }
     }
 
-    private static void notifyListeners0(Future<?> future, DefaultFutureListeners listeners) {
-        final GenericFutureListener<?>[] a = listeners.listeners();
-        final int size = listeners.size();
-        for (int i = 0; i < size; i ++) {
-            notifyListener0(future, a[i]);
+    private void notifyListenersWithStackOverFlowProtection() {
+        final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
+        final int stackDepth = threadLocals.futureListenerStackDepth();
+        if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
+            threadLocals.setFutureListenerStackDepth(stackDepth + 1);
+            try {
+                notifyListenersNow();
+            } finally {
+                threadLocals.setFutureListenerStackDepth(stackDepth);
+                if (stackDepth == 0) {
+                    // We want to force all notifications to occur at the same depth on the stack as the initial method
+                    // invocation. If we leave the stackDepth at 0 then notifyListeners could occur from a
+                    // delayedPromise's stack which could lead to a stack overflow. So force the stack depth to 1 here,
+                    // and later set it back to 0 after all delayedPromises have been notified.
+                    threadLocals.setFutureListenerStackDepth(1);
+                    try {
+                        Queue<DefaultPromise<?>> delayedPromiseQueue = STACK_OVERFLOW_DELAYED_PROMISES.get();
+                        DefaultPromise<?> delayedPromise;
+                        while ((delayedPromise = delayedPromiseQueue.poll()) != null) {
+                            delayedPromise.notifyListenersWithStackOverFlowProtection();
+                        }
+                    } finally {
+                        threadLocals.setFutureListenerStackDepth(0);
+                    }
+                }
+            }
+        } else {
+            STACK_OVERFLOW_DELAYED_PROMISES.get().add(this);
         }
     }
 
     /**
-     * Notifies the specified listener which were added after this promise is already done.
-     * This method ensures that the specified listener is not notified until {@link #listeners} becomes {@code null}
-     * to avoid the case where the late listeners are notified even before the early listeners are notified.
+     * The logic in this method should be identical to {@link #notifyListenersWithStackOverFlowProtection()} but
+     * cannot share code because the listener(s) can not be queued for an instance of {@link DefaultPromise} since the
+     * listener(s) may be changed and is protected by a synchronized operation.
      */
-    private void notifyLateListener(final GenericFutureListener<?> l) {
-        final EventExecutor executor = executor();
-        if (executor.inEventLoop()) {
-            // Execute immediately if late listeners is empty. This allows subsequent late listeners
-            // that are added after completion to be notified immediately and preserver order.
-            if (listeners == null && (lateListeners == null || lateListeners.isEmpty())) {
-                final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
-                final int stackDepth = threadLocals.futureListenerStackDepth();
-                if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                    threadLocals.setFutureListenerStackDepth(stackDepth + 1);
+    private static void notifyListenerWithStackOverFlowProtection(Future<?> future, GenericFutureListener<?> listener) {
+        final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
+        final int stackDepth = threadLocals.futureListenerStackDepth();
+        if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
+            threadLocals.setFutureListenerStackDepth(stackDepth + 1);
+            try {
+                notifyListener0(future, listener);
+            } finally {
+                threadLocals.setFutureListenerStackDepth(stackDepth);
+                if (stackDepth == 0) {
+                    // We want to force all notifications to occur at the same depth on the stack as the initial method
+                    // invocation. If we leave the stackDepth at 0 then notifyListeners could occur from a
+                    // delayedPromise's stack which could lead to a stack overflow. So force the stack depth to 1 here,
+                    // and later set it back to 0 after all delayedPromises have been notified.
+                    threadLocals.setFutureListenerStackDepth(1);
                     try {
-                        notifyListener0(this, l);
+                        Queue<Object> delayedFutureQueue = STACK_OVERFLOW_DELAYED_FUTURES.get();
+                        Object delayedFuture;
+                        while ((delayedFuture = delayedFutureQueue.poll()) != null) {
+                            notifyListenerWithStackOverFlowProtection((Future<?>) delayedFuture,
+                                    (GenericFutureListener<?>) delayedFutureQueue.poll());
+                        }
                     } finally {
-                        threadLocals.setFutureListenerStackDepth(stackDepth);
+                        threadLocals.setFutureListenerStackDepth(0);
                     }
-                    return;
-                }
-            } else {
-                LateListeners lateListeners = this.lateListeners;
-                if (lateListeners == null) {
-                    this.lateListeners = lateListeners = new LateListeners();
                 }
-                lateListeners.add(l);
-                executor.execute(lateListeners);
-                return;
             }
+        } else {
+            Queue<Object> delayedFutureQueue = STACK_OVERFLOW_DELAYED_FUTURES.get();
+            delayedFutureQueue.add(future);
+            delayedFutureQueue.add(listener);
         }
-
-        // Add the late listener to lateListeners in the executor thread for thread safety.
-        // We could just make LateListeners extend ConcurrentLinkedQueue, but it's an overkill considering
-        // that most asynchronous applications won't execute this code path.
-        executor.execute(new LateListenerNotifier(l));
     }
 
-    protected static void notifyListener(
-            final EventExecutor eventExecutor, final Future<?> future, final GenericFutureListener<?> l) {
-
-        if (eventExecutor.inEventLoop()) {
-            final InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();
-            final int stackDepth = threadLocals.futureListenerStackDepth();
-            if (stackDepth < MAX_LISTENER_STACK_DEPTH) {
-                threadLocals.setFutureListenerStackDepth(stackDepth + 1);
-                try {
-                    notifyListener0(future, l);
-                } finally {
-                    threadLocals.setFutureListenerStackDepth(stackDepth);
-                }
+    private void notifyListenersNow() {
+        Object listeners;
+        synchronized (this) {
+            // Only proceed if there are listeners to notify and we are not already notifying listeners.
+            if (notifyingListeners || this.listeners == null) {
                 return;
             }
+            notifyingListeners = true;
+            listeners = this.listeners;
+            this.listeners = null;
         }
-
-        safeExecute(eventExecutor, new OneTimeTask() {
-            @Override
-            public void run() {
-                notifyListener0(future, l);
+        for (;;) {
+            if (listeners instanceof DefaultFutureListeners) {
+                notifyListeners0((DefaultFutureListeners) listeners);
+            } else {
+                notifyListener0(this, (GenericFutureListener<? extends Future<V>>) listeners);
+            }
+            synchronized (this) {
+                if (this.listeners == null) {
+                    // Nothing can throw from within this method, so setting notifyingListeners back to false does not
+                    // need to be in a finally block.
+                    notifyingListeners = false;
+                    return;
+                }
+                listeners = this.listeners;
+                this.listeners = null;
             }
-        });
+        }
     }
 
-    private static void safeExecute(EventExecutor executor, Runnable task) {
-        try {
-            executor.execute(task);
-        } catch (Throwable t) {
-            rejectedExecutionLogger.error("Failed to submit a listener notification task. Event loop shut down?", t);
+    private void notifyListeners0(DefaultFutureListeners listeners) {
+        GenericFutureListener<?>[] a = listeners.listeners();
+        int size = listeners.size();
+        for (int i = 0; i < size; i ++) {
+            notifyListener0(this, a[i]);
         }
     }
 
     @SuppressWarnings({ "unchecked", "rawtypes" })
-    static void notifyListener0(Future future, GenericFutureListener l) {
+    private static void notifyListener0(Future future, GenericFutureListener l) {
         try {
             l.operationComplete(future);
         } catch (Throwable t) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("An exception was thrown by " + l.getClass().getName() + ".operationComplete()", t);
-            }
+            logger.warn("An exception was thrown by {}.operationComplete()", l.getClass().getName(), t);
         }
     }
 
-    /**
-     * Returns a {@link GenericProgressiveFutureListener}, an array of {@link GenericProgressiveFutureListener}, or
-     * {@code null}.
-     */
-    private synchronized Object progressiveListeners() {
-        Object listeners = this.listeners;
+    private void addListener0(GenericFutureListener<? extends Future<? super V>> listener) {
         if (listeners == null) {
-            // No listeners added
-            return null;
+            listeners = listener;
+        } else if (listeners instanceof DefaultFutureListeners) {
+            ((DefaultFutureListeners) listeners).add(listener);
+        } else {
+            listeners = new DefaultFutureListeners((GenericFutureListener<? extends Future<V>>) listeners, listener);
         }
+    }
 
+    private void removeListener0(GenericFutureListener<? extends Future<? super V>> listener) {
         if (listeners instanceof DefaultFutureListeners) {
-            // Copy DefaultFutureListeners into an array of listeners.
-            DefaultFutureListeners dfl = (DefaultFutureListeners) listeners;
-            int progressiveSize = dfl.progressiveSize();
-            switch (progressiveSize) {
-                case 0:
-                    return null;
-                case 1:
-                    for (GenericFutureListener<?> l: dfl.listeners()) {
-                        if (l instanceof GenericProgressiveFutureListener) {
-                            return l;
+            ((DefaultFutureListeners) listeners).remove(listener);
+        } else if (listeners == listener) {
+            listeners = null;
+        }
+    }
+
+    private boolean setSuccess0(V result) {
+        return setValue0(result == null ? SUCCESS : result);
+    }
+
+    private boolean setFailure0(Throwable cause) {
+        return setValue0(new CauseHolder(checkNotNull(cause, "cause")));
+    }
+
+    private boolean setValue0(Object objResult) {
+        if (RESULT_UPDATER.compareAndSet(this, null, objResult) ||
+            RESULT_UPDATER.compareAndSet(this, UNCANCELLABLE, objResult)) {
+            checkNotifyWaiters();
+            return true;
+        }
+        return false;
+    }
+
+    private synchronized void checkNotifyWaiters() {
+        if (waiters > 0) {
+            notifyAll();
+        }
+    }
+
+    private void incWaiters() {
+        if (waiters == Short.MAX_VALUE) {
+            throw new IllegalStateException("too many waiters: " + this);
+        }
+        ++waiters;
+    }
+
+    private void decWaiters() {
+        --waiters;
+    }
+
+    private void rethrowIfFailed() {
+        Throwable cause = cause();
+        if (cause == null) {
+            return;
+        }
+
+        PlatformDependent.throwException(cause);
+    }
+
+    private boolean await0(long timeoutNanos, boolean interruptable) throws InterruptedException {
+        if (isDone()) {
+            return true;
+        }
+
+        if (timeoutNanos <= 0) {
+            return isDone();
+        }
+
+        if (interruptable && Thread.interrupted()) {
+            throw new InterruptedException(toString());
+        }
+
+        checkDeadLock();
+
+        long startTime = System.nanoTime();
+        long waitTime = timeoutNanos;
+        boolean interrupted = false;
+        try {
+            for (;;) {
+                synchronized (this) {
+                    incWaiters();
+                    try {
+                        wait(waitTime / 1000000, (int) (waitTime % 1000000));
+                    } catch (InterruptedException e) {
+                        if (interruptable) {
+                            throw e;
+                        } else {
+                            interrupted = true;
                         }
+                    } finally {
+                        decWaiters();
+                    }
+                }
+                if (isDone()) {
+                    return true;
+                } else {
+                    waitTime = timeoutNanos - (System.nanoTime() - startTime);
+                    if (waitTime <= 0) {
+                        return isDone();
                     }
-                    return null;
-            }
-
-            GenericFutureListener<?>[] array = dfl.listeners();
-            GenericProgressiveFutureListener<?>[] copy = new GenericProgressiveFutureListener[progressiveSize];
-            for (int i = 0, j = 0; j < progressiveSize; i ++) {
-                GenericFutureListener<?> l = array[i];
-                if (l instanceof GenericProgressiveFutureListener) {
-                    copy[j ++] = (GenericProgressiveFutureListener<?>) l;
                 }
             }
-
-            return copy;
-        } else if (listeners instanceof GenericProgressiveFutureListener) {
-            return listeners;
-        } else {
-            // Only one listener was added and it's not a progressive listener.
-            return null;
+        } finally {
+            if (interrupted) {
+                Thread.currentThread().interrupt();
+            }
         }
     }
 
+    /**
+     * Notify all progressive listeners.
+     * <p>
+     * No attempt is made to ensure notification order if multiple calls are made to this method before
+     * the original invocation completes.
+     * <p>
+     * This will do an iteration over all listeners to get all of type {@link GenericProgressiveFutureListener}s.
+     * @param progress the new progress.
+     * @param total the total progress.
+     */
     @SuppressWarnings("unchecked")
     void notifyProgressiveListeners(final long progress, final long total) {
         final Object listeners = progressiveListeners();
@@ -774,6 +724,51 @@ public void run() {
         }
     }
 
+    /**
+     * Returns a {@link GenericProgressiveFutureListener}, an array of {@link GenericProgressiveFutureListener}, or
+     * {@code null}.
+     */
+    private synchronized Object progressiveListeners() {
+        Object listeners = this.listeners;
+        if (listeners == null) {
+            // No listeners added
+            return null;
+        }
+
+        if (listeners instanceof DefaultFutureListeners) {
+            // Copy DefaultFutureListeners into an array of listeners.
+            DefaultFutureListeners dfl = (DefaultFutureListeners) listeners;
+            int progressiveSize = dfl.progressiveSize();
+            switch (progressiveSize) {
+                case 0:
+                    return null;
+                case 1:
+                    for (GenericFutureListener<?> l: dfl.listeners()) {
+                        if (l instanceof GenericProgressiveFutureListener) {
+                            return l;
+                        }
+                    }
+                    return null;
+            }
+
+            GenericFutureListener<?>[] array = dfl.listeners();
+            GenericProgressiveFutureListener<?>[] copy = new GenericProgressiveFutureListener[progressiveSize];
+            for (int i = 0, j = 0; j < progressiveSize; i ++) {
+                GenericFutureListener<?> l = array[i];
+                if (l instanceof GenericProgressiveFutureListener) {
+                    copy[j ++] = (GenericProgressiveFutureListener<?>) l;
+                }
+            }
+
+            return copy;
+        } else if (listeners instanceof GenericProgressiveFutureListener) {
+            return listeners;
+        } else {
+            // Only one listener was added and it's not a progressive listener.
+            return null;
+        }
+    }
+
     private static void notifyProgressiveListeners0(
             ProgressiveFuture<?> future, GenericProgressiveFutureListener<?>[] listeners, long progress, long total) {
         for (GenericProgressiveFutureListener<?> l: listeners) {
@@ -790,96 +785,30 @@ private static void notifyProgressiveListener0(
         try {
             l.operationProgressed(future, progress, total);
         } catch (Throwable t) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("An exception was thrown by " + l.getClass().getName() + ".operationProgressed()", t);
-            }
-        }
-    }
-
-    private static final class CauseHolder {
-        final Throwable cause;
-        CauseHolder(Throwable cause) {
-            this.cause = cause;
+            logger.warn("An exception was thrown by {}.operationProgressed()", l.getClass().getName(), t);
         }
     }
 
-    @Override
-    public String toString() {
-        return toStringBuilder().toString();
+    private static boolean isCancelled0(Object result) {
+        return result instanceof CauseHolder && ((CauseHolder) result).cause instanceof CancellationException;
     }
 
-    protected StringBuilder toStringBuilder() {
-        StringBuilder buf = new StringBuilder(64)
-            .append(StringUtil.simpleClassName(this))
-            .append('@')
-            .append(Integer.toHexString(hashCode()));
-
-        Object result = this.result;
-        if (result == SUCCESS) {
-            buf.append("(success)");
-        } else if (result == UNCANCELLABLE) {
-            buf.append("(uncancellable)");
-        } else if (result instanceof CauseHolder) {
-            buf.append("(failure: ")
-               .append(((CauseHolder) result).cause)
-               .append(')');
-        } else if (result != null) {
-            buf.append("(success: ")
-               .append(result)
-               .append(')');
-        } else {
-            buf.append("(incomplete)");
-        }
-
-        return buf;
+    private static boolean isDone0(Object result) {
+        return result != null && result != UNCANCELLABLE;
     }
 
-    private final class LateListeners extends ArrayDeque<GenericFutureListener<?>> implements Runnable {
-
-        private static final long serialVersionUID = -687137418080392244L;
-
-        LateListeners() {
-            super(2);
-        }
-
-        @Override
-        public void run() {
-            final EventExecutor executor = executor();
-            if (listeners == null || executor == ImmediateEventExecutor.INSTANCE) {
-                for (;;) {
-                    GenericFutureListener<?> l = poll();
-                    if (l == null) {
-                        break;
-                    }
-                    notifyListener0(DefaultPromise.this, l);
-                }
-            } else {
-                // Reschedule until the initial notification is done to avoid the race condition
-                // where the notification is made in an incorrect order.
-                safeExecute(executor, this);
-            }
+    private static final class CauseHolder {
+        final Throwable cause;
+        CauseHolder(Throwable cause) {
+            this.cause = cause;
         }
     }
 
-    private final class LateListenerNotifier implements Runnable {
-        private GenericFutureListener<?> l;
-
-        LateListenerNotifier(GenericFutureListener<?> l) {
-            this.l = l;
-        }
-
-        @Override
-        public void run() {
-            LateListeners lateListeners = DefaultPromise.this.lateListeners;
-            if (l != null) {
-                if (lateListeners == null) {
-                    DefaultPromise.this.lateListeners = lateListeners = new LateListeners();
-                }
-                lateListeners.add(l);
-                l = null;
-            }
-
-            lateListeners.run();
+    private static void safeExecute(EventExecutor executor, Runnable task) {
+        try {
+            executor.execute(task);
+        } catch (Throwable t) {
+            rejectedExecutionLogger.error("Failed to submit a listener notification task. Event loop shut down?", t);
         }
     }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutor.java b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java
index c54fbeb3f07e..027e79d15171 100644
--- a/common/src/main/java/io/netty/util/concurrent/EventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java
@@ -32,12 +32,6 @@ public interface EventExecutor extends EventExecutorGroup {
     @Override
     EventExecutor next();
 
-    /**
-     * Returns an unmodifiable singleton set which contains itself.
-     */
-    @Override
-    <E extends EventExecutor> Set<E> children();
-
     /**
      * Return the {@link EventExecutorGroup} which is the parent of this {@link EventExecutor},
      */
diff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
index 0ca5c82e6068..a4daa7861448 100644
--- a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
@@ -84,18 +84,9 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E
      */
     EventExecutor next();
 
-    /**
-     * @deprecated Use {@link #children()} instead.
-     */
     @Override
-    @Deprecated
     Iterator<EventExecutor> iterator();
 
-    /**
-     * Returns the unmodifiable set of {@link EventExecutor}s managed by this {@link EventExecutorGroup}.
-     */
-    <E extends EventExecutor> Set<E> children();
-
     @Override
     Future<?> submit(Runnable task);
 
diff --git a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
index 5782b6fe28d0..e0518f236cda 100644
--- a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
@@ -130,7 +130,7 @@ public EventExecutor next() {
 
     @Override
     public Iterator<EventExecutor> iterator() {
-        return children().iterator();
+        return readonlyChildren.iterator();
     }
 
     /**
@@ -141,12 +141,6 @@ public final int executorCount() {
         return children.length;
     }
 
-    @Override
-    @SuppressWarnings("unchecked")
-    public final <E extends EventExecutor> Set<E> children() {
-        return (Set<E>) readonlyChildren;
-    }
-
     /**
      * Create a new EventExecutor which will later then accessible via the {@link #next()}  method. This method will be
      * called for each thread that will serve this {@link MultithreadEventExecutorGroup}.
diff --git a/common/src/main/java/io/netty/util/internal/PendingWrite.java b/common/src/main/java/io/netty/util/internal/PendingWrite.java
index 8621aba5852e..5a86723b2712 100644
--- a/common/src/main/java/io/netty/util/internal/PendingWrite.java
+++ b/common/src/main/java/io/netty/util/internal/PendingWrite.java
@@ -54,7 +54,8 @@ private PendingWrite(Recycler.Handle<PendingWrite> handle) {
     public boolean recycle() {
         msg = null;
         promise = null;
-        return RECYCLER.recycle(this, handle);
+        handle.recycle(this);
+        return true;
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java b/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java
index b81b0a08d210..bf98f22a1a6e 100644
--- a/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java
+++ b/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java
@@ -152,6 +152,7 @@ public boolean insertSinceRecycled() {
     public boolean recycle() {
         clear();
         insertSinceRecycled = false;
-        return RECYCLER.recycle(this, handle);
+        handle.recycle(this);
+        return true;
     }
 }
diff --git a/common/src/main/java/io/netty/util/internal/UnstableApi.java b/common/src/main/java/io/netty/util/internal/UnstableApi.java
new file mode 100644
index 000000000000..042a702f83d5
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/UnstableApi.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.internal;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates a public API that can change at any time (even in minor/bugfix releases).
+ *
+ * Usage guidelines:
+ *
+ * <ol>
+ *     <li>Is not needed for things located in *.internal.* packages</li>
+ *     <li>Only public acessible classes/interfaces must be annotated</li>
+ *     <li>If this annotation is not present the API is considered stable and so no backward compatibility can be
+ *         broken in a non-major release!</li>
+ * </ol>
+ */
+@Retention(RetentionPolicy.SOURCE)
+@Target({
+        ElementType.ANNOTATION_TYPE,
+        ElementType.CONSTRUCTOR,
+        ElementType.FIELD,
+        ElementType.METHOD,
+        ElementType.PACKAGE,
+        ElementType.TYPE
+})
+@Documented
+public @interface UnstableApi {
+}
diff --git a/common/src/main/java/io/netty/util/internal/chmv8/ForkJoinPool.java b/common/src/main/java/io/netty/util/internal/chmv8/ForkJoinPool.java
index bfe4e9d269d8..24bded99e5bc 100644
--- a/common/src/main/java/io/netty/util/internal/chmv8/ForkJoinPool.java
+++ b/common/src/main/java/io/netty/util/internal/chmv8/ForkJoinPool.java
@@ -1078,8 +1078,13 @@ final boolean isApparentlyUnblocked() {
      * to avoid contention in one pool is likely to hold for others.
      * Lazily initialized on first submission (but null-checked
      * in other contexts to avoid unnecessary initialization).
+     *
+     * Note: this was changed to fix https://github.com/netty/netty/issues/4211
+     * Instead of using "ThreadLocal<Submitter>" like jsr166e, just use "ThreadLocal<int[]>" to
+     * avoid leaking the Submitter's class loader. Here "int[]" is just an array with exactly one
+     * int.
      */
-    static final ThreadLocal<Submitter> submitters;
+    static final ThreadLocal<int[]> submitters;
 
     /**
      * Creates a new ForkJoinWorkerThread. This factory is used unless
@@ -1478,10 +1483,10 @@ final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {
      * randomly modified upon collisions using xorshifts, which
      * requires a non-zero seed.
      */
-    static final class Submitter {
-        int seed;
-        Submitter(int s) { seed = s; }
-    }
+    //static final class Submitter {
+    //    int seed;
+    //    Submitter(int s) { seed = s; }
+    //}
 
     /**
      * Unless shutting down, adds the given task to a submission queue
@@ -1492,12 +1497,12 @@ static final class Submitter {
      * @param task the task. Caller must ensure non-null.
      */
     final void externalPush(ForkJoinTask<?> task) {
-        Submitter z = submitters.get();
+        int[] z = submitters.get();
         WorkQueue q; int r, m, s, n, am; ForkJoinTask<?>[] a;
         int ps = plock;
         WorkQueue[] ws = workQueues;
         if (z != null && ps > 0 && ws != null && (m = (ws.length - 1)) >= 0 &&
-                (q = ws[m & (r = z.seed) & SQMASK]) != null && r != 0 &&
+                (q = ws[m & (r = z[0]) & SQMASK]) != null && r != 0 &&
                 U.compareAndSwapInt(q, QLOCK, 0, 1)) { // lock
             if ((a = q.array) != null &&
                     (am = a.length - 1) > (n = (s = q.top) - q.base)) {
@@ -1533,18 +1538,18 @@ final void externalPush(ForkJoinTask<?> task) {
      */
     private void fullExternalPush(ForkJoinTask<?> task) {
         int r = 0; // random index seed
-        for (Submitter z = submitters.get();;) {
+        for (int[] z = submitters.get();;) {
             WorkQueue[] ws; WorkQueue q; int ps, m, k;
             if (z == null) {
                 if (U.compareAndSwapInt(this, INDEXSEED, r = indexSeed,
                         r += SEED_INCREMENT) && r != 0)
-                    submitters.set(z = new Submitter(r));
+                    submitters.set(z = new int[]{ r });
             }
             else if (r == 0) {                  // move to a different index
-                r = z.seed;
+                r = z[0];
                 r ^= r << 13;                   // same xorshift as WorkQueues
                 r ^= r >>> 17;
-                z.seed = r ^= (r << 5);
+                z[0] = r ^= (r << 5);
             }
             if ((ps = plock) < 0)
                 throw new RejectedExecutionException();
@@ -2313,12 +2318,12 @@ private boolean tryTerminate(boolean now, boolean enable) {
      * least one task.
      */
     static WorkQueue commonSubmitterQueue() {
-        Submitter z; ForkJoinPool p; WorkQueue[] ws; int m, r;
+        int[] z; ForkJoinPool p; WorkQueue[] ws; int m, r;
         return ((z = submitters.get()) != null &&
                 (p = common) != null &&
                 (ws = p.workQueues) != null &&
                 (m = ws.length - 1) >= 0) ?
-                ws[m & z.seed & SQMASK] : null;
+                ws[m & z[0] & SQMASK] : null;
     }
 
     /**
@@ -2326,11 +2331,11 @@ static WorkQueue commonSubmitterQueue() {
      */
     final boolean tryExternalUnpush(ForkJoinTask<?> task) {
         WorkQueue joiner; ForkJoinTask<?>[] a; int m, s;
-        Submitter z = submitters.get();
+        int[] z = submitters.get();
         WorkQueue[] ws = workQueues;
         boolean popped = false;
         if (z != null && ws != null && (m = ws.length - 1) >= 0 &&
-                (joiner = ws[z.seed & m & SQMASK]) != null &&
+                (joiner = ws[z[0] & m & SQMASK]) != null &&
                 joiner.base != (s = joiner.top) &&
                 (a = joiner.array) != null) {
             long j = (((a.length - 1) & (s - 1)) << ASHIFT) + ABASE;
@@ -2349,11 +2354,11 @@ final boolean tryExternalUnpush(ForkJoinTask<?> task) {
 
     final int externalHelpComplete(CountedCompleter<?> task) {
         WorkQueue joiner; int m, j;
-        Submitter z = submitters.get();
+        int[] z = submitters.get();
         WorkQueue[] ws = workQueues;
         int s = 0;
         if (z != null && ws != null && (m = ws.length - 1) >= 0 &&
-                (joiner = ws[(j = z.seed) & m & SQMASK]) != null && task != null) {
+                (joiner = ws[(j = z[0]) & m & SQMASK]) != null && task != null) {
             int scans = m + m + 1;
             long c = 0L;             // for stability check
             j |= 1;                  // poll odd queues
@@ -3279,7 +3284,7 @@ protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
             throw new Error(e);
         }
 
-        submitters = new ThreadLocal<Submitter>();
+        submitters = new ThreadLocal<int[]>();
         defaultForkJoinWorkerThreadFactory =
                 new DefaultForkJoinWorkerThreadFactory();
         modifyThreadPermission = new RuntimePermission("modifyThread");
diff --git a/common/src/main/templates/io/netty/util/collection/KObjectHashMap.template b/common/src/main/templates/io/netty/util/collection/KObjectHashMap.template
index 78f76b329777..6358364c1eb9 100644
--- a/common/src/main/templates/io/netty/util/collection/KObjectHashMap.template
+++ b/common/src/main/templates/io/netty/util/collection/KObjectHashMap.template
@@ -145,10 +145,6 @@ public class @K@ObjectHashMap<V> implements @K@ObjectMap<V> {
         }
     }
 
-    private int probeNext(int index) {
-        return index == values.length - 1 ? 0 : index + 1;
-    }
-
     @Override
     public void putAll(Map<? extends @O@, ? extends V> sourceMap) {
         if (sourceMap instanceof @K@ObjectHashMap) {
@@ -367,6 +363,7 @@ public class @K@ObjectHashMap<V> implements @K@ObjectMap<V> {
      * Returns the hashed index for the given key.
      */
     private int hashIndex(@k@ key) {
+        // The array lengths are always a power of two, so we can use a bitmask to stay inside the array bounds.
         return hashCode(key) & mask;
     }
 
@@ -377,6 +374,14 @@ public class @K@ObjectHashMap<V> implements @K@ObjectMap<V> {
        return @HASH_CODE@;
     }
 
+    /**
+     * Get the next sequential index after {@code index} and wraps if necessary.
+     */
+    private int probeNext(int index) {
+        // The array lengths are always a power of two, so we can use a bitmask to stay inside the array bounds.
+        return (index + 1) & mask;
+    }
+
     /**
      * Grows the map size after an insertion. If necessary, performs a rehash of the map.
      */
@@ -398,8 +403,9 @@ public class @K@ObjectHashMap<V> implements @K@ObjectMap<V> {
      * if necessary to not break conflict chains.
      *
      * @param index the index position of the element to remove.
+     * @return {@code true} if the next item was moved back. {@code false} otherwise.
      */
-    private void removeAt(int index) {
+    private boolean removeAt(final int index) {
         --size;
         // Clearing the key is not strictly necessary (for GC like in a regular collection),
         // but recommended for security. The memory location is still fresh in the cache anyway.
@@ -411,6 +417,7 @@ public class @K@ObjectHashMap<V> implements @K@ObjectMap<V> {
         // entries and move them back if possible, optimizing future lookups.
         // Knuth Section 6.4 Algorithm R, also used by the JDK's IdentityHashMap.
 
+        boolean movedBack = false;
         int nextFree = index;
         for (int i = probeNext(index); values[i] != null; i = probeNext(i)) {
             int bucket = hashIndex(keys[i]);
@@ -419,12 +426,14 @@ public class @K@ObjectHashMap<V> implements @K@ObjectMap<V> {
                 // Move the displaced entry "back" to the first available position.
                 keys[nextFree] = keys[i];
                 values[nextFree] = values[i];
+                movedBack = true;
                 // Put the first entry after the displaced entry
                 keys[i] = 0;
                 values[i] = null;
                 nextFree = i;
             }
         }
+        return movedBack;
     }
 
     /**
@@ -624,7 +633,12 @@ public class @K@ObjectHashMap<V> implements @K@ObjectMap<V> {
             if (prevIndex < 0) {
                 throw new IllegalStateException("next must be called before each remove.");
             }
-            removeAt(prevIndex);
+            if (removeAt(prevIndex)) {
+                // removeAt may move elements "back" in the array if they have been displaced because their spot in the
+                // array was occupied when they were inserted. If this occurs then the nextIndex is now invalid and
+                // should instead point to the prevIndex which now holds an element which was "moved back".
+                nextIndex = prevIndex;
+            }
             prevIndex = -1;
         }
 
diff --git a/common/src/test/java/io/netty/util/DomainNameMappingTest.java b/common/src/test/java/io/netty/util/DomainNameMappingTest.java
index bd369e930183..b8447964cd98 100644
--- a/common/src/test/java/io/netty/util/DomainNameMappingTest.java
+++ b/common/src/test/java/io/netty/util/DomainNameMappingTest.java
@@ -18,6 +18,8 @@
 
 import org.junit.Test;
 
+import java.util.Map;
+
 import static org.junit.Assert.assertEquals;
 
 @SuppressWarnings("deprecation")
@@ -105,22 +107,22 @@ public void testToStringInDeprecatedApi() {
 
     @Test(expected = NullPointerException.class)
     public void testNullDefaultValue() {
-        new DomainMappingBuilder<String>(null);
+        new DomainNameMappingBuilder<String>(null);
     }
 
     @Test(expected = NullPointerException.class)
     public void testNullDomainNamePatternsAreForbidden() {
-        new DomainMappingBuilder<String>("NotFound").add(null, "Some value");
+        new DomainNameMappingBuilder<String>("NotFound").add(null, "Some value");
     }
 
     @Test(expected = NullPointerException.class)
     public void testNullValuesAreForbidden() {
-        new DomainMappingBuilder<String>("NotFound").add("Some key", null);
+        new DomainNameMappingBuilder<String>("NotFound").add("Some key", null);
     }
 
     @Test
     public void testDefaultValue() {
-        DomainNameMapping<String> mapping = new DomainMappingBuilder<String>("NotFound")
+        DomainNameMapping<String> mapping = new DomainNameMappingBuilder<String>("NotFound")
             .add("*.netty.io", "Netty")
             .build();
 
@@ -129,7 +131,7 @@ public void testDefaultValue() {
 
     @Test
     public void testStrictEquality() {
-        DomainNameMapping<String> mapping = new DomainMappingBuilder<String>("NotFound")
+        DomainNameMapping<String> mapping = new DomainNameMappingBuilder<String>("NotFound")
             .add("netty.io", "Netty")
             .add("downloads.netty.io", "Netty-Downloads")
             .build();
@@ -142,7 +144,7 @@ public void testStrictEquality() {
 
     @Test
     public void testWildcardMatchesAnyPrefix() {
-        DomainNameMapping<String> mapping = new DomainMappingBuilder<String>("NotFound")
+        DomainNameMapping<String> mapping = new DomainNameMappingBuilder<String>("NotFound")
             .add("*.netty.io", "Netty")
             .build();
 
@@ -156,14 +158,14 @@ public void testWildcardMatchesAnyPrefix() {
     @Test
     public void testFirstMatchWins() {
         assertEquals("Netty",
-            new DomainMappingBuilder<String>("NotFound")
+            new DomainNameMappingBuilder<String>("NotFound")
                 .add("*.netty.io", "Netty")
                 .add("downloads.netty.io", "Netty-Downloads")
                 .build()
                 .map("downloads.netty.io"));
 
         assertEquals("Netty-Downloads",
-            new DomainMappingBuilder<String>("NotFound")
+            new DomainNameMappingBuilder<String>("NotFound")
                 .add("downloads.netty.io", "Netty-Downloads")
                 .add("*.netty.io", "Netty")
                 .build()
@@ -172,7 +174,7 @@ public void testFirstMatchWins() {
 
     @Test
     public void testToString() {
-        DomainNameMapping<String> mapping = new DomainMappingBuilder<String>("NotFound")
+        DomainNameMapping<String> mapping = new DomainNameMappingBuilder<String>("NotFound")
             .add("*.netty.io", "Netty")
             .add("downloads.netty.io", "Netty-Download")
             .build();
@@ -181,4 +183,31 @@ public void testToString() {
             "ImmutableDomainNameMapping(default: NotFound, map: {*.netty.io=Netty, downloads.netty.io=Netty-Download})",
             mapping.toString());
     }
+
+    @Test
+    public void testAsMap() {
+        DomainNameMapping<String> mapping = new DomainNameMapping<String>("NotFound")
+            .add("netty.io", "Netty")
+            .add("downloads.netty.io", "Netty-Downloads");
+
+        Map<String, String> entries = mapping.asMap();
+
+        assertEquals(2, entries.size());
+        assertEquals("Netty", entries.get("netty.io"));
+        assertEquals("Netty-Downloads", entries.get("downloads.netty.io"));
+    }
+
+    @Test
+    public void testAsMapWithImmutableDomainNameMapping() {
+        DomainNameMapping<String> mapping = new DomainNameMappingBuilder<String>("NotFound")
+            .add("netty.io", "Netty")
+            .add("downloads.netty.io", "Netty-Downloads")
+            .build();
+
+        Map<String, String> entries = mapping.asMap();
+
+        assertEquals(2, entries.size());
+        assertEquals("Netty", entries.get("netty.io"));
+        assertEquals("Netty-Downloads", entries.get("downloads.netty.io"));
+    }
 }
diff --git a/common/src/test/java/io/netty/util/RecyclerTest.java b/common/src/test/java/io/netty/util/RecyclerTest.java
index f226b15020c3..4a893ce3fa3c 100644
--- a/common/src/test/java/io/netty/util/RecyclerTest.java
+++ b/common/src/test/java/io/netty/util/RecyclerTest.java
@@ -69,7 +69,7 @@ public static RecyclableObject newInstance() {
         }
 
         public void recycle() {
-            RECYCLER.recycle(this, handle);
+            handle.recycle(this);
         }
     }
 
@@ -77,14 +77,14 @@ static final class DisabledRecyclableObject {
 
         private static final Recycler<DisabledRecyclableObject> RECYCLER = new Recycler<DisabledRecyclableObject>(-1) {
             @Override
-            protected DisabledRecyclableObject newObject(Handle handle) {
+            protected DisabledRecyclableObject newObject(Handle<DisabledRecyclableObject> handle) {
                 return new DisabledRecyclableObject(handle);
             }
         };
 
-        private final Recycler.Handle handle;
+        private final Recycler.Handle<DisabledRecyclableObject> handle;
 
-        private DisabledRecyclableObject(Recycler.Handle handle) {
+        private DisabledRecyclableObject(Recycler.Handle<DisabledRecyclableObject> handle) {
             this.handle = handle;
         }
 
@@ -93,7 +93,7 @@ public static DisabledRecyclableObject newInstance() {
         }
 
         public void recycle() {
-            RECYCLER.recycle(this, handle);
+            handle.recycle(this);
         }
     }
 
@@ -125,7 +125,7 @@ protected HandledObject newObject(
         }
 
         for (int i = 0; i < objects.length; i++) {
-            recycler.recycle(objects[i], objects[i].handle);
+            objects[i].recycle();
             objects[i] = null;
         }
 
@@ -136,7 +136,7 @@ protected HandledObject newObject(
     public void testRecycleAtDifferentThread() throws Exception {
         final Recycler<HandledObject> recycler = new Recycler<HandledObject>(256) {
             @Override
-            protected HandledObject newObject(Recycler.Handle handle) {
+            protected HandledObject newObject(Recycler.Handle<HandledObject> handle) {
                 return new HandledObject(handle);
             }
         };
@@ -145,7 +145,7 @@ protected HandledObject newObject(Recycler.Handle handle) {
         final Thread thread = new Thread() {
             @Override
             public void run() {
-                recycler.recycle(o, o.handle);
+                o.recycle();
             }
         };
         thread.start();
@@ -174,14 +174,14 @@ protected HandledObject newObject(Recycler.Handle handle) {
         }
 
         for (int i = 0; i < maxCapacity; i ++) {
-            recycler.recycle(array[i], array[i].handle);
+            array[i].recycle();
         }
 
         final Thread thread = new Thread() {
             @Override
             public void run() {
                 for (int i = maxCapacity; i < array.length; i ++) {
-                    recycler.recycle(array[i], array[i].handle);
+                    array[i].recycle();
                 }
             }
         };
@@ -205,5 +205,9 @@ static final class HandledObject {
         HandledObject(Recycler.Handle<HandledObject> handle) {
             this.handle = handle;
         }
+
+        void recycle() {
+            handle.recycle(this);
+        }
     }
 }
diff --git a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
index ab5d4f03fd00..29ca951db826 100644
--- a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
+++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java
@@ -16,26 +16,45 @@
 
 package io.netty.util.concurrent;
 
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
 @SuppressWarnings("unchecked")
 public class DefaultPromiseTest {
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultPromiseTest.class);
+    private static int stackOverflowDepth;
+
+    @BeforeClass
+    public static void beforeClass() {
+        try {
+            findStackOverflowDepth();
+            throw new IllegalStateException("Expected StackOverflowError but didn't get it?!");
+        } catch (StackOverflowError e) {
+            logger.debug("StackOverflowError depth: {}", stackOverflowDepth);
+        }
+    }
+
+    private static void findStackOverflowDepth() {
+        ++stackOverflowDepth;
+        findStackOverflowDepth();
+    }
 
     @Test(expected = CancellationException.class)
     public void testCancellationExceptionIsThrownWhenBlockingGet() throws InterruptedException, ExecutionException {
@@ -54,52 +73,43 @@ public void testCancellationExceptionIsThrownWhenBlockingGetWithTimeout() throws
 
     @Test
     public void testNoStackOverflowErrorWithImmediateEventExecutorA() throws Exception {
-        final Promise<Void>[] p = new DefaultPromise[128];
-        for (int i = 0; i < p.length; i ++) {
-            final int finalI = i;
-            p[i] = new DefaultPromise<Void>(ImmediateEventExecutor.INSTANCE);
-            p[i].addListener(new FutureListener<Void>() {
-                @Override
-                public void operationComplete(Future<Void> future) throws Exception {
-                    if (finalI + 1 < p.length) {
-                        p[finalI + 1].setSuccess(null);
-                    }
-                }
-            });
-        }
-
-        p[0].setSuccess(null);
+        testStackOverFlowErrorChainedFuturesA(Math.min(stackOverflowDepth << 1, Integer.MAX_VALUE),
+                                              ImmediateEventExecutor.INSTANCE);
+    }
 
-        for (Promise<Void> a: p) {
-            assertThat(a.isSuccess(), is(true));
+    @Test
+    public void testNoStackOverflowErrorWithDefaultEventExecutorA() throws Exception {
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        try {
+            EventExecutor executor = new DefaultEventExecutor(executorService);
+            try {
+                testStackOverFlowErrorChainedFuturesA(Math.min(stackOverflowDepth << 1, Integer.MAX_VALUE), executor);
+            } finally {
+                executor.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);
+            }
+        } finally {
+            executorService.shutdown();
         }
     }
 
     @Test
     public void testNoStackOverflowErrorWithImmediateEventExecutorB() throws Exception {
-        final Promise<Void>[] p = new DefaultPromise[128];
-        for (int i = 0; i < p.length; i ++) {
-            final int finalI = i;
-            p[i] = new DefaultPromise<Void>(ImmediateEventExecutor.INSTANCE);
-            p[i].addListener(new FutureListener<Void>() {
-                @Override
-                public void operationComplete(Future<Void> future) throws Exception {
-                    DefaultPromise.notifyListener(ImmediateEventExecutor.INSTANCE, future, new FutureListener<Void>() {
-                        @Override
-                        public void operationComplete(Future<Void> future) throws Exception {
-                            if (finalI + 1 < p.length) {
-                                p[finalI + 1].setSuccess(null);
-                            }
-                        }
-                    });
-                }
-            });
-        }
-
-        p[0].setSuccess(null);
+        testStackOverFlowErrorChainedFuturesB(Math.min(stackOverflowDepth << 1, Integer.MAX_VALUE),
+                                              ImmediateEventExecutor.INSTANCE);
+    }
 
-        for (Promise<Void> a: p) {
-            assertThat(a.isSuccess(), is(true));
+    @Test
+    public void testNoStackOverflowErrorWithDefaultEventExecutorB() throws Exception {
+        ExecutorService executorService = Executors.newSingleThreadExecutor();
+        try {
+            EventExecutor executor = new DefaultEventExecutor(executorService);
+            try {
+                testStackOverFlowErrorChainedFuturesB(Math.min(stackOverflowDepth << 1, Integer.MAX_VALUE), executor);
+            } finally {
+                executor.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);
+            }
+        } finally {
+            executorService.shutdown();
         }
     }
 
@@ -187,13 +197,70 @@ public void testLateListenerIsOrderedCorrectlyFailure() throws InterruptedExcept
         testLateListenerIsOrderedCorrectly(fakeException());
     }
 
+    private void testStackOverFlowErrorChainedFuturesA(int promiseChainLength, EventExecutor executor)
+            throws InterruptedException {
+        final Promise<Void>[] p = new DefaultPromise[promiseChainLength];
+        final CountDownLatch latch = new CountDownLatch(promiseChainLength);
+        for (int i = 0; i < p.length; i ++) {
+            final int finalI = i;
+            p[i] = new DefaultPromise<Void>(executor);
+            p[i].addListener(new FutureListener<Void>() {
+                @Override
+                public void operationComplete(Future<Void> future) throws Exception {
+                    if (finalI + 1 < p.length) {
+                        p[finalI + 1].setSuccess(null);
+                    }
+                    latch.countDown();
+                }
+            });
+        }
+
+        p[0].setSuccess(null);
+
+        latch.await(2, TimeUnit.SECONDS);
+        for (int i = 0; i < p.length; ++i) {
+            assertTrue("index " + i, p[i].isSuccess());
+        }
+    }
+
+    private void testStackOverFlowErrorChainedFuturesB(int promiseChainLength, EventExecutor executor)
+            throws InterruptedException {
+        final Promise<Void>[] p = new DefaultPromise[promiseChainLength];
+        final CountDownLatch latch = new CountDownLatch(promiseChainLength);
+        for (int i = 0; i < p.length; i ++) {
+            final int finalI = i;
+            p[i] = new DefaultPromise<Void>(executor);
+            p[i].addListener(new FutureListener<Void>() {
+                @Override
+                public void operationComplete(Future<Void> future) throws Exception {
+                    future.addListener(new FutureListener<Void>() {
+                        @Override
+                        public void operationComplete(Future<Void> future) throws Exception {
+                            if (finalI + 1 < p.length) {
+                                p[finalI + 1].setSuccess(null);
+                            }
+                            latch.countDown();
+                        }
+                    });
+                }
+            });
+        }
+
+        p[0].setSuccess(null);
+
+        latch.await(2, TimeUnit.SECONDS);
+        for (int i = 0; i < p.length; ++i) {
+            assertTrue("index " + i, p[i].isSuccess());
+        }
+    }
+
     /**
      * This test is mean to simulate the following sequence of events, which all take place on the I/O thread:
      * <ol>
      * <li>A write is done</li>
      * <li>The write operation completes, and the promise state is changed to done</li>
-     * <li>A listener is added to the return from the write. The {@link FutureListener#operationComplete()} updates
-     * state which must be invoked before the response to the previous write is read.</li>
+     * <li>A listener is added to the return from the write. The {@link FutureListener#operationComplete(Future)}
+     * updates state which must be invoked before the response to the previous write is read.</li>
      * <li>The write operation</li>
      * </ol>
      */
diff --git a/common/src/test/resources/logback-test.xml b/common/src/test/resources/logback-test.xml
new file mode 100644
index 000000000000..ea5238ed68b3
--- /dev/null
+++ b/common/src/test/resources/logback-test.xml
@@ -0,0 +1,11 @@
+<configuration debug="false">
+  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+    <encoder>
+      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
+    </encoder>
+  </appender>
+
+  <root level="${logLevel:-info}">
+    <appender-ref ref="STDOUT" />
+  </root>
+</configuration>
diff --git a/common/src/test/templates/io/netty/util/collection/KObjectHashMapTest.template b/common/src/test/templates/io/netty/util/collection/KObjectHashMapTest.template
index ed87c489f505..2be12a9ea81a 100644
--- a/common/src/test/templates/io/netty/util/collection/KObjectHashMapTest.template
+++ b/common/src/test/templates/io/netty/util/collection/KObjectHashMapTest.template
@@ -14,6 +14,7 @@
  */
 package io.netty.util.collection;
 
+import io.netty.util.collection.@K@ObjectMap.PrimitiveEntry;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -77,6 +78,24 @@ public class @K@ObjectHashMapTest {
         map = new @K@ObjectHashMap<Value>();
     }
 
+    @Test
+    public void iteartorRemoveShouldNotNPE() {
+        map = new @K@ObjectHashMap<Value>(4, 1);
+        map.put((@O@)(@k@) 0, new Value("A"));
+        map.put((@O@)(@k@) 1, new Value("B"));
+        map.put((@O@)(@k@) 4, new Value("C"));
+        map.remove((@O@)(@k@) 1);
+        Iterator<PrimitiveEntry<Value>> itr = map.entries().iterator();
+        while (itr.hasNext()) {
+            PrimitiveEntry<Value> entry = itr.next();
+            assertNotNull(entry.key());
+            assertNotNull(entry.value());
+            itr.remove();
+        }
+        assertTrue(map.isEmpty());
+        assertEquals(0, map.size());
+    }
+
     @Test
     public void putNewMappingShouldSucceed() {
         Value v = new Value("v");
diff --git a/example/pom.xml b/example/pom.xml
index 9bbb48b69440..5ab7b2c79a82 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-example</artifactId>
@@ -65,6 +65,11 @@
       <artifactId>netty-codec-memcache</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-codec-redis</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>netty-codec-socks</artifactId>
diff --git a/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
index 0baf355fae8a..c20f1daff401 100644
--- a/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
+++ b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java
@@ -62,7 +62,7 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
     private void generateTraffic() {
         // Flush the outbound buffer to the socket.
         // Once flushed, generate the same amount of traffic again.
-        ctx.writeAndFlush(content.duplicate().retain()).addListener(trafficGenerator);
+        ctx.writeAndFlush(content.retainedDuplicate()).addListener(trafficGenerator);
     }
 
     private final ChannelFutureListener trafficGenerator = new ChannelFutureListener() {
diff --git a/example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java b/example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
index 01c422bac4a8..d7731bbad9e1 100644
--- a/example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
+++ b/example/src/main/java/io/netty/example/http/cors/HttpCorsServerInitializer.java
@@ -80,7 +80,7 @@ public HttpCorsServerInitializer(SslContext sslCtx) {
 
     @Override
     public void initChannel(SocketChannel ch) {
-        CorsConfig corsConfig = CorsConfigBuilder.forAnyOrigin().build();
+        CorsConfig corsConfig = CorsConfigBuilder.forAnyOrigin().allowNullOrigin().allowCredentials().build();
         ChannelPipeline pipeline = ch.pipeline();
         if (sslCtx != null) {
             pipeline.addLast(sslCtx.newHandler(ch.alloc()));
diff --git a/example/src/main/java/io/netty/example/http2/tiles/FallbackRequestHandler.java b/example/src/main/java/io/netty/example/http2/tiles/FallbackRequestHandler.java
index b50962a9b3a5..e9836dcfcb23 100644
--- a/example/src/main/java/io/netty/example/http2/tiles/FallbackRequestHandler.java
+++ b/example/src/main/java/io/netty/example/http2/tiles/FallbackRequestHandler.java
@@ -17,7 +17,6 @@
 package io.netty.example.http2.tiles;
 
 import static io.netty.buffer.Unpooled.copiedBuffer;
-import static io.netty.buffer.Unpooled.unmodifiableBuffer;
 import static io.netty.buffer.Unpooled.unreleasableBuffer;
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
 import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
@@ -40,10 +39,10 @@
  */
 public final class FallbackRequestHandler extends SimpleChannelInboundHandler<HttpRequest> {
 
-    private static final ByteBuf response = unmodifiableBuffer(unreleasableBuffer(copiedBuffer("<!DOCTYPE html>"
+    private static final ByteBuf response = unreleasableBuffer(copiedBuffer("<!DOCTYPE html>"
             + "<html><body><h2>To view the example you need a browser that supports HTTP/2 ("
             + Http2CodecUtil.TLS_UPGRADE_PROTOCOL_NAME
-            + ")</h2></body></html>", UTF_8)));
+            + ")</h2></body></html>", UTF_8)).asReadOnly();
 
     @Override
     protected void channelRead0(ChannelHandlerContext ctx, HttpRequest req) throws Exception {
diff --git a/example/src/main/java/io/netty/example/http2/tiles/ImageCache.java b/example/src/main/java/io/netty/example/http2/tiles/ImageCache.java
index dbf3e0b2da11..ad50d9f2e691 100644
--- a/example/src/main/java/io/netty/example/http2/tiles/ImageCache.java
+++ b/example/src/main/java/io/netty/example/http2/tiles/ImageCache.java
@@ -16,7 +16,6 @@
 
 package io.netty.example.http2.tiles;
 
-import static io.netty.buffer.Unpooled.unmodifiableBuffer;
 import static io.netty.buffer.Unpooled.unreleasableBuffer;
 import static io.netty.example.http2.Http2ExampleUtil.toByteBuf;
 import io.netty.buffer.ByteBuf;
@@ -51,8 +50,8 @@ private void init() {
             for (int x = 0; x < 20; x++) {
                 try {
                     String name = name(x, y);
-                    ByteBuf fileBytes = unreleasableBuffer(unmodifiableBuffer(toByteBuf(getClass()
-                            .getResourceAsStream(name))));
+                    ByteBuf fileBytes = unreleasableBuffer(toByteBuf(getClass()
+                            .getResourceAsStream(name)).asReadOnly());
                     imageBank.put(name, fileBytes);
                 } catch (IOException e) {
                     e.printStackTrace();
diff --git a/example/src/main/java/io/netty/example/redis/RedisClient.java b/example/src/main/java/io/netty/example/redis/RedisClient.java
new file mode 100644
index 000000000000..11067ee4d8ad
--- /dev/null
+++ b/example/src/main/java/io/netty/example/redis/RedisClient.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package io.netty.example.redis;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.redis.RedisArrayAggregator;
+import io.netty.handler.codec.redis.RedisBulkStringAggregator;
+import io.netty.handler.codec.redis.RedisDecoder;
+import io.netty.handler.codec.redis.RedisEncoder;
+import io.netty.util.concurrent.GenericFutureListener;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+
+/**
+ * Simple Redis client that demonstrates Redis commands against a Redis server.
+ */
+public class RedisClient {
+    private static final String HOST = System.getProperty("host", "127.0.0.1");
+    private static final int PORT = Integer.parseInt(System.getProperty("port", "6379"));
+
+    public static void main(String[] args) throws Exception {
+        EventLoopGroup group = new NioEventLoopGroup();
+        try {
+            Bootstrap b = new Bootstrap();
+            b.group(group)
+             .channel(NioSocketChannel.class)
+             .handler(new ChannelInitializer<SocketChannel>() {
+                 @Override
+                 protected void initChannel(SocketChannel ch) throws Exception {
+                     ChannelPipeline p = ch.pipeline();
+                     p.addLast(new RedisDecoder());
+                     p.addLast(new RedisBulkStringAggregator());
+                     p.addLast(new RedisArrayAggregator());
+                     p.addLast(new RedisEncoder());
+                     p.addLast(new RedisClientHandler());
+                 }
+             });
+
+            // Start the connection attempt.
+            Channel ch = b.connect(HOST, PORT).sync().channel();
+
+            // Read commands from the stdin.
+            System.out.println("Enter Redis commands (quit to end)");
+            ChannelFuture lastWriteFuture = null;
+            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
+            for (;;) {
+                final String input = in.readLine();
+                final String line = input != null ? input.trim() : null;
+                if (line == null || "quit".equalsIgnoreCase(line)) { // EOF or "quit"
+                    ch.close().sync();
+                    break;
+                } else if (line.isEmpty()) { // skip `enter` or `enter` with spaces.
+                    continue;
+                }
+                // Sends the received line to the server.
+                lastWriteFuture = ch.writeAndFlush(line);
+                lastWriteFuture.addListener(new GenericFutureListener<ChannelFuture>() {
+                    @Override
+                    public void operationComplete(ChannelFuture future) throws Exception {
+                        if (!future.isSuccess()) {
+                            System.err.print("write failed: ");
+                            future.cause().printStackTrace(System.err);
+                        }
+                    }
+                });
+            }
+
+            // Wait until all messages are flushed before closing the channel.
+            if (lastWriteFuture != null) {
+                lastWriteFuture.sync();
+            }
+        } finally {
+            group.shutdownGracefully();
+        }
+    }
+}
diff --git a/example/src/main/java/io/netty/example/redis/RedisClientHandler.java b/example/src/main/java/io/netty/example/redis/RedisClientHandler.java
new file mode 100644
index 000000000000..89fb99c44d2f
--- /dev/null
+++ b/example/src/main/java/io/netty/example/redis/RedisClientHandler.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.example.redis;
+
+import io.netty.buffer.ByteBufUtil;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.codec.CodecException;
+import io.netty.handler.codec.redis.ArrayRedisMessage;
+import io.netty.handler.codec.redis.ErrorRedisMessage;
+import io.netty.handler.codec.redis.FullBulkStringRedisMessage;
+import io.netty.handler.codec.redis.IntegerRedisMessage;
+import io.netty.handler.codec.redis.RedisMessage;
+import io.netty.handler.codec.redis.SimpleStringRedisMessage;
+import io.netty.util.CharsetUtil;
+import io.netty.util.ReferenceCountUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * An example Redis client handler. This handler read input from STDIN and write output to STDOUT.
+ */
+public class RedisClientHandler extends ChannelDuplexHandler {
+
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+        String[] commands = ((String) msg).split("\\s+");
+        List<RedisMessage> children = new ArrayList<RedisMessage>(commands.length);
+        for (String cmdString : commands) {
+            children.add(new FullBulkStringRedisMessage(ByteBufUtil.writeUtf8(ctx.alloc(), cmdString)));
+        }
+        RedisMessage request = new ArrayRedisMessage(children);
+        ctx.write(request, promise);
+    }
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) {
+        RedisMessage redisMessage = (RedisMessage) msg;
+        printAggregatedRedisResponse(redisMessage);
+        ReferenceCountUtil.release(redisMessage);
+    }
+
+    @Override
+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
+        System.err.print("exceptionCaught: ");
+        cause.printStackTrace(System.err);
+        ctx.close();
+    }
+
+    private static void printAggregatedRedisResponse(RedisMessage msg) {
+        if (msg instanceof SimpleStringRedisMessage) {
+            System.out.println(((SimpleStringRedisMessage) msg).content());
+        } else if (msg instanceof ErrorRedisMessage) {
+            System.out.println(((ErrorRedisMessage) msg).content());
+        } else if (msg instanceof IntegerRedisMessage) {
+            System.out.println(((IntegerRedisMessage) msg).value());
+        } else if (msg instanceof FullBulkStringRedisMessage) {
+            System.out.println(getString((FullBulkStringRedisMessage) msg));
+        } else if (msg instanceof ArrayRedisMessage) {
+            for (RedisMessage child : ((ArrayRedisMessage) msg).children()) {
+                printAggregatedRedisResponse(child);
+            }
+        } else {
+            throw new CodecException("unknown message type: " + msg);
+        }
+    }
+
+    private static String getString(FullBulkStringRedisMessage msg) {
+        if (msg.isNull()) {
+            return "(null)";
+        }
+        return msg.content().toString(CharsetUtil.UTF_8);
+    }
+}
diff --git a/handler-proxy/pom.xml b/handler-proxy/pom.xml
index 056852fbe196..c33d3004da7a 100644
--- a/handler-proxy/pom.xml
+++ b/handler-proxy/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-handler-proxy</artifactId>
diff --git a/handler/pom.xml b/handler/pom.xml
index 776e0687f5de..7ed67b9b10a3 100644
--- a/handler/pom.xml
+++ b/handler/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-handler</artifactId>
diff --git a/handler/src/main/java/io/netty/handler/flow/FlowControlHandler.java b/handler/src/main/java/io/netty/handler/flow/FlowControlHandler.java
new file mode 100644
index 000000000000..c3130db0845d
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/flow/FlowControlHandler.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version
+ * 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package io.netty.handler.flow;
+
+import java.util.ArrayDeque;
+import java.util.Queue;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelConfig;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelPipeline;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.handler.codec.MessageToByteEncoder;
+import io.netty.util.Recycler;
+import io.netty.util.Recycler.Handle;
+import io.netty.util.ReferenceCountUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+/**
+ * The {@link FlowControlHandler} ensures that only one message per {@code read()} is sent downstream.
+ *
+ * Classes such as {@link ByteToMessageDecoder} or {@link MessageToByteEncoder} are free to emit as
+ * many events as they like for any given input. A channel's auto reading configuration doesn't usually
+ * apply in these scenarios. This is causing problems in downstream {@link ChannelHandler}s that would
+ * like to hold subsequent events while they're processing one event. It's a common problem with the
+ * {@code HttpObjectDecoder} that will very often fire a {@code HttpRequest} that is immediately followed
+ * by a {@code LastHttpContent} event.
+ *
+ * <pre>
+ * {@link ChannelPipeline} pipeline = ...;
+ *
+ * pipeline.addLast(new HttpServerCodec());
+ * pipeline.addLast(new {@link FlowControlHandler}());
+ *
+ * pipeline.addLast(new MyExampleHandler());
+ *
+ * class MyExampleHandler extends {@link ChannelInboundHandlerAdapter} {
+ *   @Override
+ *   public void channelRead({@link ChannelHandlerContext} ctx, Object msg) {
+ *     if (msg instanceof HttpRequest) {
+ *       ctx.channel().config().setAutoRead(false);
+ *
+ *       // The FlowControlHandler will hold any subsequent events that
+ *       // were emitted by HttpObjectDecoder until auto reading is turned
+ *       // back on or Channel#read() is being called.
+ *     }
+ *   }
+ * }
+ * </pre>
+ *
+ * @see ChannelConfig#setAutoRead(boolean)
+ */
+public class FlowControlHandler extends ChannelDuplexHandler {
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(FlowControlHandler.class);
+
+    private final boolean releaseMessages;
+
+    private RecyclableArrayDeque queue;
+
+    private ChannelConfig config;
+
+    private boolean shouldConsume;
+
+    public FlowControlHandler() {
+        this(true);
+    }
+
+    public FlowControlHandler(boolean releaseMessages) {
+        this.releaseMessages = releaseMessages;
+    }
+
+    /**
+     * Determine if the underlying {@link Queue} is empty. This method exists for
+     * testing, debugging and inspection purposes and it is not Thread safe!
+     */
+    boolean isQueueEmpty() {
+        return queue.isEmpty();
+    }
+
+    /**
+     * Releases all messages and destroys the {@link Queue}.
+     */
+    private void destroy() {
+        if (queue != null) {
+
+            if (!queue.isEmpty()) {
+                logger.trace("Non-empty queue: {}", queue);
+
+                if (releaseMessages) {
+                    Object msg;
+                    while ((msg = queue.poll()) != null) {
+                        ReferenceCountUtil.safeRelease(msg);
+                    }
+                }
+            }
+
+            queue.recycle();
+            queue = null;
+        }
+    }
+
+    @Override
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+        config = ctx.channel().config();
+    }
+
+    @Override
+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+        destroy();
+        ctx.fireChannelInactive();
+    }
+
+    @Override
+    public void read(ChannelHandlerContext ctx) throws Exception {
+        if (dequeue(ctx, 1) == 0) {
+            // It seems no messages were consumed. We need to read() some
+            // messages from upstream and once one arrives it need to be
+            // relayed to downstream to keep the flow going.
+            shouldConsume = true;
+            ctx.read();
+        }
+    }
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+        if (queue == null) {
+            queue = RecyclableArrayDeque.newInstance();
+        }
+
+        queue.offer(msg);
+
+        // We just received one message. Do we need to relay it regardless
+        // of the auto reading configuration? The answer is yes if this
+        // method was called as a result of a prior read() call.
+        int minConsume = shouldConsume ? 1 : 0;
+        shouldConsume = false;
+
+        dequeue(ctx, minConsume);
+    }
+
+    @Override
+    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+        // Don't relay completion events from upstream as they
+        // make no sense in this context. See dequeue() where
+        // a new set of completion events is being produced.
+    }
+
+    /**
+     * Dequeues one or many (or none) messages depending on the channel's auto
+     * reading state and returns the number of messages that were consumed from
+     * the internal queue.
+     *
+     * The {@code minConsume} argument is used to force {@code dequeue()} into
+     * consuming that number of messages regardless of the channel's auto
+     * reading configuration.
+     *
+     * @see #read(ChannelHandlerContext)
+     * @see #channelRead(ChannelHandlerContext, Object)
+     */
+    private int dequeue(ChannelHandlerContext ctx, int minConsume) {
+        if (queue != null) {
+
+            int consumed = 0;
+
+            Object msg;
+            while ((consumed < minConsume) || config.isAutoRead()) {
+                msg = queue.poll();
+                if (msg == null) {
+                    break;
+                }
+
+                ++consumed;
+                ctx.fireChannelRead(msg);
+            }
+
+            // We're firing a completion event every time one (or more)
+            // messages were consumed and the queue ended up being drained
+            // to an empty state.
+            if (queue.isEmpty() && consumed > 0) {
+                ctx.fireChannelReadComplete();
+            }
+
+            return consumed;
+        }
+
+        return 0;
+    }
+
+    /**
+     * A recyclable {@link ArrayDeque}.
+     */
+    private static final class RecyclableArrayDeque extends ArrayDeque<Object> {
+
+        private static final long serialVersionUID = 0L;
+
+        /**
+         * A value of {@code 2} should be a good choice for most scenarios.
+         */
+        private static final int DEFAULT_NUM_ELEMENTS = 2;
+
+        private static final Recycler<RecyclableArrayDeque> RECYCLER = new Recycler<RecyclableArrayDeque>() {
+            @Override
+            protected RecyclableArrayDeque newObject(Handle<RecyclableArrayDeque> handle) {
+                return new RecyclableArrayDeque(DEFAULT_NUM_ELEMENTS, handle);
+            }
+        };
+
+        public static RecyclableArrayDeque newInstance() {
+            return RECYCLER.get();
+        }
+
+        private final Handle<RecyclableArrayDeque> handle;
+
+        private RecyclableArrayDeque(int numElements, Handle<RecyclableArrayDeque> handle) {
+            super(numElements);
+            this.handle = handle;
+        }
+
+        public void recycle() {
+            clear();
+            handle.recycle(this);
+        }
+    }
+}
diff --git a/handler/src/main/java/io/netty/handler/flow/package-info.java b/handler/src/main/java/io/netty/handler/flow/package-info.java
new file mode 100644
index 000000000000..2e5c763d3828
--- /dev/null
+++ b/handler/src/main/java/io/netty/handler/flow/package-info.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Package to control the flow of messages.
+ */
+package io.netty.handler.flow;
diff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
index 125db87e764a..92ea5b860371 100644
--- a/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java
@@ -61,29 +61,30 @@ public final class OpenSsl {
         // If in the classpath, try to load the native library and initialize netty-tcnative.
         if (cause == null) {
             try {
-                String os = normalizeOs(SystemPropertyUtil.get("os.name", ""));
-                String arch = normalizeArch(SystemPropertyUtil.get("os.arch", ""));
-
-                Set<String> libNames = new LinkedHashSet<String>(3);
-                // First, try loading the platform-specific library. Platform-specific
-                // libraries will be available if using a tcnative uber jar.
-                libNames.add("netty-tcnative-" + os + '-' + arch);
-                if (LINUX.equalsIgnoreCase(os)) {
-                    // Fedora SSL lib so naming (libssl.so.10 vs libssl.so.1.0.0)..
-                    libNames.add("netty-tcnative-" + os + '-' + arch + "-fedora");
-                }
-                // finally the default library.
-                libNames.add("netty-tcnative");
+                // The JNI library was not already loaded. Load it now.
+                loadTcNative();
+            } catch (Throwable t) {
+                cause = t;
+                logger.debug(
+                    "Failed to load netty-tcnative; " +
+                        OpenSslEngine.class.getSimpleName() + " will be unavailable, unless the " +
+                        "application has already loaded the symbols by some other means. " +
+                        "See http://netty.io/wiki/forked-tomcat-native.html for more information.", t);
+            }
 
-                NativeLibraryLoader.loadFirstAvailable(SSL.class.getClassLoader(),
-                        libNames.toArray(new String[libNames.size()]));
+            try {
+                initializeTcNative();
 
-                Library.initialize("provided");
-                SSL.initialize(null);
+                // The library was initialized successfully. If loading the library failed above,
+                // reset the cause now since it appears that the library was loaded by some other
+                // means.
+                cause = null;
             } catch (Throwable t) {
-                cause = t;
+                if (cause == null) {
+                    cause = t;
+                }
                 logger.debug(
-                        "Failed to load netty-tcnative; " +
+                    "Failed to initialize netty-tcnative; " +
                         OpenSslEngine.class.getSimpleName() + " will be unavailable. " +
                         "See http://netty.io/wiki/forked-tomcat-native.html for more information.", t);
             }
@@ -219,6 +220,30 @@ static long memoryAddress(ByteBuf buf) {
 
     private OpenSsl() { }
 
+    private static void loadTcNative() throws Exception {
+        String os = normalizeOs(SystemPropertyUtil.get("os.name", ""));
+        String arch = normalizeArch(SystemPropertyUtil.get("os.arch", ""));
+
+        Set<String> libNames = new LinkedHashSet<String>(3);
+        // First, try loading the platform-specific library. Platform-specific
+        // libraries will be available if using a tcnative uber jar.
+        libNames.add("netty-tcnative-" + os + '-' + arch);
+        if (LINUX.equalsIgnoreCase(os)) {
+            // Fedora SSL lib so naming (libssl.so.10 vs libssl.so.1.0.0)..
+            libNames.add("netty-tcnative-" + os + '-' + arch + "-fedora");
+        }
+        // finally the default library.
+        libNames.add("netty-tcnative");
+
+        NativeLibraryLoader.loadFirstAvailable(SSL.class.getClassLoader(),
+            libNames.toArray(new String[libNames.size()]));
+    }
+
+    private static void initializeTcNative() throws Exception {
+        Library.initialize("provided");
+        SSL.initialize(null);
+    }
+
     private static String normalizeOs(String value) {
         value = normalize(value);
         if (value.startsWith("aix")) {
diff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java
index a38e28192dcf..362d6f644076 100644
--- a/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java
+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java
@@ -517,18 +517,24 @@ static long toBIO(PrivateKey key) throws Exception {
                 try {
                     buffer.writeBytes(encodedBuf);
                 } finally {
-                    encodedBuf.release();
+                    zerooutAndRelease(encodedBuf);
                 }
             } finally {
-                wrappedBuf.release();
+                zerooutAndRelease(wrappedBuf);
             }
             buffer.writeBytes(END_PRIVATE_KEY);
             return newBIO(buffer);
         } finally {
-            buffer.release();
+            // Zero out the buffer and so the private key it held.
+            zerooutAndRelease(buffer);
         }
     }
 
+    private static void zerooutAndRelease(ByteBuf buffer) {
+        buffer.setZero(0, buffer.capacity());
+        buffer.release();
+    }
+
     /**
      * Return the pointer to a <a href="https://www.openssl.org/docs/crypto/BIO_get_mem_ptr.html">in-memory BIO</a>
      * or {@code 0} if the {@code certChain} is {@code null}. The BIO contains the content of the {@code certChain}.
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java b/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
index c4563a99dde8..79e434655a98 100644
--- a/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
+++ b/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java
@@ -39,11 +39,19 @@
 /**
  * An {@link TrustManagerFactory} that trusts an X.509 certificate whose SHA1 checksum matches.
  * <p>
- * <strong>NOTE:</strong>
- * Never use this {@link TrustManagerFactory} in production unless you are sure exactly what you are doing with it.
- * </p><p>
+ * <strong>NOTE:</strong> It is recommended to verify certificates and their chain to prevent
+ * <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-middle attacks</a>.
+ * This {@link TrustManagerFactory} will <strong>only</strong> verify that the fingerprint of certificates match one
+ * of the given fingerprints. This procedure is called
+ * <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Certificate_pinning">certificate pinning</a> and
+ * is an effective protection. For maximum security one should verify that the whole certificate chain is as expected.
+ * It is worth mentioning that certain firewalls, proxies or other appliances found in corporate environments,
+ * actually perform Man-in-the-middle attacks and thus present a different certificate fingerprint.
+ * </p>
+ * <p>
  * The SHA1 checksum of an X.509 certificate is calculated from its DER encoded format.  You can get the fingerprint of
  * an X.509 certificate using the {@code openssl} command.  For example:
+ *
  * <pre>
  * $ openssl x509 -fingerprint -sha1 -in my_certificate.crt
  * SHA1 Fingerprint=4E:85:10:55:BC:7B:12:08:D1:EA:0A:12:C9:72:EE:F3:AA:B2:C7:CB
diff --git a/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java b/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java
index eddd1719e36e..7ec9e63d7ea7 100644
--- a/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java
+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java
@@ -16,11 +16,12 @@
 package io.netty.handler.timeout;
 
 import io.netty.channel.Channel;
+import io.netty.util.internal.ObjectUtil;
 
 /**
  * A user event triggered by {@link IdleStateHandler} when a {@link Channel} is idle.
  */
-public final class IdleStateEvent {
+public class IdleStateEvent {
     public static final IdleStateEvent FIRST_READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, true);
     public static final IdleStateEvent READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, false);
     public static final IdleStateEvent FIRST_WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, true);
@@ -31,8 +32,14 @@ public final class IdleStateEvent {
     private final IdleState state;
     private final boolean first;
 
-    private IdleStateEvent(IdleState state, boolean first) {
-        this.state = state;
+    /**
+     * Constructor for sub-classes.
+     *
+     * @param state the {@link IdleStateEvent} which triggered the event.
+     * @param first {@code true} if its the first idle event for the {@link IdleStateEvent}.
+     */
+    protected IdleStateEvent(IdleState state, boolean first) {
+        this.state = ObjectUtil.checkNotNull(state, "state");
         this.first = first;
     }
 
diff --git a/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
index 0c78d1fd9f33..c58cd873e402 100644
--- a/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java
@@ -343,6 +343,22 @@ protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws
         ctx.fireUserEventTriggered(evt);
     }
 
+    /**
+     * Returns a {@link IdleStateEvent}.
+     */
+    protected IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {
+        switch (state) {
+            case ALL_IDLE:
+                return first ? IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT : IdleStateEvent.ALL_IDLE_STATE_EVENT;
+            case READER_IDLE:
+                return first ? IdleStateEvent.FIRST_READER_IDLE_STATE_EVENT : IdleStateEvent.READER_IDLE_STATE_EVENT;
+            case WRITER_IDLE:
+                return first ? IdleStateEvent.FIRST_WRITER_IDLE_STATE_EVENT : IdleStateEvent.WRITER_IDLE_STATE_EVENT;
+            default:
+                throw new Error();
+        }
+    }
+
     private final class ReaderIdleTimeoutTask implements Runnable {
 
         private final ChannelHandlerContext ctx;
@@ -367,13 +383,11 @@ public void run() {
                 readerIdleTimeout =
                     ctx.executor().schedule(this, readerIdleTimeNanos, TimeUnit.NANOSECONDS);
                 try {
-                    IdleStateEvent event;
+                    IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, firstReaderIdleEvent);
                     if (firstReaderIdleEvent) {
                         firstReaderIdleEvent = false;
-                        event = IdleStateEvent.FIRST_READER_IDLE_STATE_EVENT;
-                    } else {
-                        event = IdleStateEvent.READER_IDLE_STATE_EVENT;
                     }
+
                     channelIdle(ctx, event);
                 } catch (Throwable t) {
                     ctx.fireExceptionCaught(t);
@@ -406,13 +420,11 @@ public void run() {
                 writerIdleTimeout = ctx.executor().schedule(
                         this, writerIdleTimeNanos, TimeUnit.NANOSECONDS);
                 try {
-                    IdleStateEvent event;
+                    IdleStateEvent event = newIdleStateEvent(IdleState.WRITER_IDLE, firstWriterIdleEvent);
                     if (firstWriterIdleEvent) {
                         firstWriterIdleEvent = false;
-                        event = IdleStateEvent.FIRST_WRITER_IDLE_STATE_EVENT;
-                    } else {
-                        event = IdleStateEvent.WRITER_IDLE_STATE_EVENT;
                     }
+
                     channelIdle(ctx, event);
                 } catch (Throwable t) {
                     ctx.fireExceptionCaught(t);
@@ -448,13 +460,11 @@ public void run() {
                 allIdleTimeout = ctx.executor().schedule(
                         this, allIdleTimeNanos, TimeUnit.NANOSECONDS);
                 try {
-                    IdleStateEvent event;
+                    IdleStateEvent event = newIdleStateEvent(IdleState.ALL_IDLE, firstAllIdleEvent);
                     if (firstAllIdleEvent) {
                         firstAllIdleEvent = false;
-                        event = IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;
-                    } else {
-                        event = IdleStateEvent.ALL_IDLE_STATE_EVENT;
                     }
+
                     channelIdle(ctx, event);
                 } catch (Throwable t) {
                     ctx.fireExceptionCaught(t);
diff --git a/handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java b/handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java
new file mode 100644
index 000000000000..f6cea33c3fa2
--- /dev/null
+++ b/handler/src/test/java/io/netty/handler/flow/FlowControlHandlerTest.java
@@ -0,0 +1,383 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version
+ * 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package io.netty.handler.flow;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelConfig;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.nio.NioServerSocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.util.ReferenceCountUtil;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.net.SocketAddress;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Exchanger;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class FlowControlHandlerTest {
+    private static EventLoopGroup GROUP;
+
+    @BeforeClass
+    public static void init() {
+        GROUP = new NioEventLoopGroup();
+    }
+
+    @AfterClass
+    public static void destroy() {
+        GROUP.shutdownGracefully();
+    }
+
+    /**
+     * The {@link OneByteToThreeStringsDecoder} decodes this {@code byte[]} into three messages.
+     */
+    private static ByteBuf newOneMessage() {
+        return Unpooled.wrappedBuffer(new byte[]{ 1 });
+    }
+
+    private static Channel newServer(final boolean autoRead, final ChannelHandler... handlers) {
+        assertTrue(handlers.length >= 1);
+
+        ServerBootstrap serverBootstrap = new ServerBootstrap();
+        serverBootstrap.group(GROUP)
+            .channel(NioServerSocketChannel.class)
+            .childOption(ChannelOption.AUTO_READ, autoRead)
+            .childHandler(new ChannelInitializer<Channel>() {
+                @Override
+                protected void initChannel(Channel ch) throws Exception {
+                    ChannelPipeline pipeline = ch.pipeline();
+                    pipeline.addLast(new OneByteToThreeStringsDecoder());
+                    pipeline.addLast(handlers);
+                }
+            });
+
+        return serverBootstrap.bind(0)
+                .syncUninterruptibly()
+                .channel();
+    }
+
+    private static Channel newClient(SocketAddress server) {
+        Bootstrap bootstrap = new Bootstrap();
+
+        bootstrap.group(GROUP)
+            .channel(NioSocketChannel.class)
+            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 1000)
+            .handler(new ChannelInboundHandlerAdapter() {
+                @Override
+                public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                    fail("In this test the client is never receiving a message from the server.");
+                }
+            });
+
+        return bootstrap.connect(server)
+                .syncUninterruptibly()
+                .channel();
+    }
+
+    /**
+     * This test demonstrates the default behavior if auto reading
+     * is turned on from the get-go and you're trying to turn it off
+     * once you've received your first message.
+     *
+     * NOTE: This test waits for the client to disconnect which is
+     * interpreted as the signal that all {@code byte}s have been
+     * transferred to the server.
+     */
+    @Test
+    public void testAutoReadingOn() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(3);
+
+        ChannelInboundHandlerAdapter handler = new ChannelInboundHandlerAdapter() {
+            @Override
+            public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                ReferenceCountUtil.release(msg);
+                // We're turning off auto reading in the hope that no
+                // new messages are being sent but that is not true.
+                ctx.channel().config().setAutoRead(false);
+
+                latch.countDown();
+            }
+        };
+
+        Channel server = newServer(true, handler);
+        Channel client = newClient(server.localAddress());
+
+        try {
+            client.writeAndFlush(newOneMessage())
+                .syncUninterruptibly();
+
+            // We received three messages even through auto reading
+            // was turned off after we received the first message.
+            assertTrue(latch.await(1L, TimeUnit.SECONDS));
+        } finally {
+            client.close();
+            server.close();
+        }
+    }
+
+    /**
+     * This test demonstrates the default behavior if auto reading
+     * is turned off from the get-go and you're calling read() in
+     * the hope that only one message will be returned.
+     *
+     * NOTE: This test waits for the client to disconnect which is
+     * interpreted as the signal that all {@code byte}s have been
+     * transferred to the server.
+     */
+    @Test
+    public void testAutoReadingOff() throws Exception {
+        final Exchanger<Channel> peerRef = new Exchanger<Channel>();
+        final CountDownLatch latch = new CountDownLatch(3);
+
+        ChannelInboundHandlerAdapter handler = new ChannelInboundHandlerAdapter() {
+            @Override
+            public void channelActive(ChannelHandlerContext ctx) throws Exception {
+                peerRef.exchange(ctx.channel(), 1L, TimeUnit.SECONDS);
+                ctx.fireChannelActive();
+            }
+
+            @Override
+            public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                ReferenceCountUtil.release(msg);
+                latch.countDown();
+            }
+        };
+
+        Channel server = newServer(false, handler);
+        Channel client = newClient(server.localAddress());
+
+        try {
+            // The client connection on the server side
+            Channel peer = peerRef.exchange(null, 1L, TimeUnit.SECONDS);
+
+            // Write the message
+            client.writeAndFlush(newOneMessage())
+                .syncUninterruptibly();
+
+            // Read the message
+            peer.read();
+
+            // We received all three messages but hoped that only one
+            // message was read because auto reading was off and we
+            // invoked the read() method only once.
+            assertTrue(latch.await(1L, TimeUnit.SECONDS));
+        } finally {
+            client.close();
+            server.close();
+        }
+    }
+
+    /**
+     * The {@link FlowControlHandler} will simply pass-through all messages
+     * if auto reading is on and remains on.
+     */
+    @Test
+    public void testFlowAutoReadOn() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(3);
+
+        ChannelInboundHandlerAdapter handler = new ChannelDuplexHandler() {
+            @Override
+            public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                latch.countDown();
+            }
+        };
+
+        FlowControlHandler flow = new FlowControlHandler();
+        Channel server = newServer(true, flow, handler);
+        Channel client = newClient(server.localAddress());
+        try {
+            // Write the message
+            client.writeAndFlush(newOneMessage())
+                .syncUninterruptibly();
+
+            // We should receive 3 messages
+            assertTrue(latch.await(1L, TimeUnit.SECONDS));
+            assertTrue(flow.isQueueEmpty());
+        } finally {
+            client.close();
+            server.close();
+        }
+    }
+
+    /**
+     * The {@link FlowControlHandler} will pass down messages one by one
+     * if {@link ChannelConfig#setAutoRead(boolean)} is being toggled.
+     */
+    @Test
+    public void testFlowToggleAutoRead() throws Exception {
+        final Exchanger<Channel> peerRef = new Exchanger<Channel>();
+        final AtomicReference<CountDownLatch> latchRef
+            = new AtomicReference<CountDownLatch>(new CountDownLatch(1));
+
+        final AtomicInteger counter = new AtomicInteger();
+
+        ChannelInboundHandlerAdapter handler = new ChannelInboundHandlerAdapter() {
+            @Override
+            public void channelActive(ChannelHandlerContext ctx) throws Exception {
+                peerRef.exchange(ctx.channel(), 1L, TimeUnit.SECONDS);
+                ctx.fireChannelActive();
+            }
+
+            @Override
+            public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                ReferenceCountUtil.release(msg);
+
+                // Disable auto reading after each message
+                counter.incrementAndGet();
+                ctx.channel().config().setAutoRead(false);
+
+                CountDownLatch latch = latchRef.get();
+                latch.countDown();
+            }
+        };
+
+        FlowControlHandler flow = new FlowControlHandler();
+        Channel server = newServer(true, flow, handler);
+        Channel client = newClient(server.localAddress());
+        try {
+            // The client connection on the server side
+            Channel peer = peerRef.exchange(null, 1L, TimeUnit.SECONDS);
+
+            client.writeAndFlush(newOneMessage())
+                .syncUninterruptibly();
+
+            // channelRead(1)
+            assertTrue(latchRef.get().await(1L, TimeUnit.SECONDS));
+            assertFalse(peer.config().isAutoRead());
+            assertEquals(1, counter.get());
+
+            // channelRead(2)
+            latchRef.set(new CountDownLatch(1));
+            peer.config().setAutoRead(true);
+            assertTrue(latchRef.get().await(1L, TimeUnit.SECONDS));
+            assertFalse(peer.config().isAutoRead());
+            assertEquals(2, counter.get());
+
+            // channelRead(3)
+            latchRef.set(new CountDownLatch(1));
+            peer.config().setAutoRead(true);
+            assertTrue(latchRef.get().await(1L, TimeUnit.SECONDS));
+            assertFalse(peer.config().isAutoRead());
+            assertEquals(3, counter.get());
+            assertTrue(flow.isQueueEmpty());
+        } finally {
+            client.close();
+            server.close();
+        }
+    }
+
+    /**
+     * The {@link FlowControlHandler} will pass down messages one by one
+     * if auto reading is off and the user is calling {@code read()} on
+     * their own.
+     */
+    @Test
+    public void testFlowAutoReadOff() throws Exception {
+        final Exchanger<Channel> peerRef = new Exchanger<Channel>();
+        final AtomicReference<CountDownLatch> latchRef
+            = new AtomicReference<CountDownLatch>(new CountDownLatch(1));
+        final AtomicInteger counter = new AtomicInteger();
+
+        ChannelInboundHandlerAdapter handler = new ChannelDuplexHandler() {
+            @Override
+            public void channelActive(ChannelHandlerContext ctx) throws Exception {
+                peerRef.exchange(ctx.channel(), 1L, TimeUnit.SECONDS);
+                ctx.fireChannelActive();
+            }
+
+            @Override
+            public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                counter.incrementAndGet();
+
+                CountDownLatch latch = latchRef.get();
+                latch.countDown();
+            }
+        };
+
+        FlowControlHandler flow = new FlowControlHandler();
+        Channel server = newServer(false, flow, handler);
+        Channel client = newClient(server.localAddress());
+        try {
+            // The client connection on the server side
+            Channel peer = peerRef.exchange(null, 1L, TimeUnit.SECONDS);
+
+            // Write the message
+            client.writeAndFlush(newOneMessage())
+                .syncUninterruptibly();
+
+            // channelRead(1)
+            peer.read();
+            assertTrue(latchRef.get().await(1L, TimeUnit.SECONDS));
+            assertEquals(1, counter.get());
+
+            // channelRead(2)
+            latchRef.set(new CountDownLatch(1));
+            peer.read();
+            assertTrue(latchRef.get().await(1L, TimeUnit.SECONDS));
+            assertEquals(2, counter.get());
+
+            // channelRead(3)
+            latchRef.set(new CountDownLatch(1));
+            peer.read();
+            assertTrue(latchRef.get().await(1L, TimeUnit.SECONDS));
+            assertEquals(3, counter.get());
+            assertTrue(flow.isQueueEmpty());
+        } finally {
+            client.close();
+            server.close();
+        }
+    }
+
+    /**
+     * This is a fictional message decoder. It decodes each {@code byte}
+     * into three strings.
+     */
+    private static final class OneByteToThreeStringsDecoder extends ByteToMessageDecoder {
+        @Override
+        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+            for (int i = 0; i < in.readableBytes(); i++) {
+                out.add("1");
+                out.add("2");
+                out.add("3");
+            }
+            in.readerIndex(in.readableBytes());
+        }
+    }
+}
diff --git a/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
index fd5a2a6c3608..8170376f383f 100644
--- a/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
+++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
@@ -22,7 +22,6 @@
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.EventLoopGroup;
@@ -31,19 +30,17 @@
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.DecoderException;
-import io.netty.util.DomainMappingBuilder;
 import io.netty.util.DomainNameMapping;
+import io.netty.util.DomainNameMappingBuilder;
 import io.netty.util.ReferenceCountUtil;
 import org.junit.Test;
 
+import javax.xml.bind.DatatypeConverter;
 import java.io.File;
 import java.net.InetSocketAddress;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-import javax.net.ssl.HandshakeCompletedEvent;
-import javax.xml.bind.DatatypeConverter;
-
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.junit.Assert.assertThat;
@@ -81,15 +78,14 @@ public void testServerNameParsing() throws Exception {
         SslContext leanContext = makeSslContext();
         SslContext leanContext2 = makeSslContext();
 
-        DomainNameMapping<SslContext> mapping = new DomainNameMapping<SslContext>(nettyContext);
-        mapping.add("*.netty.io", nettyContext);
-
-        // input with custom cases
-        mapping.add("*.LEANCLOUD.CN", leanContext);
-
-        // a hostname conflict with previous one, since we are using order-sensitive config, the engine won't
-        // be used with the handler.
-        mapping.add("chat4.leancloud.cn", leanContext2);
+        DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)
+                .add("*.netty.io", nettyContext)
+                // input with custom cases
+                .add("*.LEANCLOUD.CN", leanContext)
+                // a hostname conflict with previous one, since we are using order-sensitive config, the engine won't
+                // be used with the handler.
+                .add("chat4.leancloud.cn", leanContext2)
+                .build();
 
         SniHandler handler = new SniHandler(mapping);
         EmbeddedChannel ch = new EmbeddedChannel(handler);
@@ -133,15 +129,14 @@ public void testFallbackToDefaultContext() throws Exception {
         SslContext leanContext = makeSslContext();
         SslContext leanContext2 = makeSslContext();
 
-        DomainNameMapping<SslContext> mapping = new DomainNameMapping<SslContext>(nettyContext);
-        mapping.add("*.netty.io", nettyContext);
-
-        // input with custom cases
-        mapping.add("*.LEANCLOUD.CN", leanContext);
-
-        // a hostname conflict with previous one, since we are using order-sensitive config, the engine won't
-        // be used with the handler.
-        mapping.add("chat4.leancloud.cn", leanContext2);
+        DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)
+                .add("*.netty.io", nettyContext)
+                // input with custom cases
+                .add("*.LEANCLOUD.CN", leanContext)
+                // a hostname conflict with previous one, since we are using order-sensitive config, the engine won't
+                // be used with the handler.
+                .add("chat4.leancloud.cn", leanContext2)
+                .build();
 
         SniHandler handler = new SniHandler(mapping);
         EmbeddedChannel ch = new EmbeddedChannel(handler);
@@ -164,25 +159,15 @@ public void testFallbackToDefaultContext() throws Exception {
     @Test
     public void testSniWithApnHandler() throws Exception {
         SslContext nettyContext = makeSslContext();
-        SslContext leanContext = makeSslContext();
+        SslContext sniContext = makeSslContext();
         final SslContext clientContext = makeSslClientContext();
-        SslContext wrappedLeanContext = null;
         final CountDownLatch serverApnDoneLatch = new CountDownLatch(1);
         final CountDownLatch clientApnDoneLatch = new CountDownLatch(1);
 
-        final DomainNameMapping<SslContext> mapping = new DomainMappingBuilder(nettyContext)
+        final DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)
                                                          .add("*.netty.io", nettyContext)
-                                                         .add("*.LEANCLOUD.CN", leanContext).build();
-        // hex dump of a client hello packet, which contains hostname "CHAT4LEANCLOUDCN"
-        final String tlsHandshakeMessageHex1 = "16030100";
-        // part 2
-        final String tlsHandshakeMessageHex = "bd010000b90303a74225676d1814ba57faff3b366" +
-                "3656ed05ee9dbb2a4dbb1bb1c32d2ea5fc39e0000000100008c0000001700150000164348" +
-                "415434E380824C45414E434C4F5544E38082434E000b000403000102000a00340032000e0" +
-                "00d0019000b000c00180009000a0016001700080006000700140015000400050012001300" +
-                "0100020003000f0010001100230000000d0020001e0601060206030501050205030401040" +
-                "20403030103020303020102020203000f00010133740000";
-
+                                                         .add("sni.fake.site", sniContext).build();
+        final SniHandler handler = new SniHandler(mapping);
         EventLoopGroup group = new NioEventLoopGroup(2);
         Channel serverChannel = null;
         Channel clientChannel = null;
@@ -195,7 +180,7 @@ public void testSniWithApnHandler() throws Exception {
                 protected void initChannel(Channel ch) throws Exception {
                     ChannelPipeline p = ch.pipeline();
                     // Server side SNI.
-                    p.addLast(new SniHandler(mapping));
+                    p.addLast(handler);
                     // Catch the notification event that APN has completed successfully.
                     p.addLast(new ApplicationProtocolNegotiationHandler("foo") {
                         @Override
@@ -212,11 +197,8 @@ protected void configurePipeline(ChannelHandlerContext ctx, String protocol) thr
             cb.handler(new ChannelInitializer<Channel>() {
                 @Override
                 protected void initChannel(Channel ch) throws Exception {
-                    // Simulate client side SNI (which is currently not supported).
-                    ch.write(Unpooled.wrappedBuffer(DatatypeConverter.parseHexBinary(tlsHandshakeMessageHex1)));
-                    ch.writeAndFlush(Unpooled.wrappedBuffer(DatatypeConverter.parseHexBinary(tlsHandshakeMessageHex)));
-                    // Add a SslHandler so we can do the client side of the handshake.
-                    ch.pipeline().addLast(clientContext.newHandler(ch.alloc()));
+                    ch.pipeline().addLast(new SslHandler(clientContext.newEngine(
+                            ch.alloc(), "sni.fake.site", -1)));
                     // Catch the notification event that APN has completed successfully.
                     ch.pipeline().addLast(new ApplicationProtocolNegotiationHandler("foo") {
                         @Override
@@ -235,6 +217,8 @@ protected void configurePipeline(ChannelHandlerContext ctx, String protocol) thr
 
             assertTrue(serverApnDoneLatch.await(5, TimeUnit.SECONDS));
             assertTrue(clientApnDoneLatch.await(5, TimeUnit.SECONDS));
+            assertThat(handler.hostname(), is("sni.fake.site"));
+            assertThat(handler.sslContext(), is(sniContext));
         } finally {
             if (serverChannel != null) {
                 serverChannel.close().sync();
diff --git a/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
index 859303135ac8..b5591d5bcdb9 100644
--- a/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
+++ b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java
@@ -131,7 +131,7 @@ public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
                     return null;
                 }
                 done = true;
-                return buffer.duplicate().retain();
+                return buffer.retainedDuplicate();
             }
 
             @Override
diff --git a/microbench/pom.xml b/microbench/pom.xml
index 4b0adcac93e5..dc61d1c1fc7a 100644
--- a/microbench/pom.xml
+++ b/microbench/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-microbench</artifactId>
@@ -92,12 +92,12 @@
     <dependency>
       <groupId>org.openjdk.jmh</groupId>
       <artifactId>jmh-core</artifactId>
-      <version>1.11.1</version>
+      <version>1.12</version>
     </dependency>
     <dependency>
       <groupId>org.openjdk.jmh</groupId>
       <artifactId>jmh-generator-annprocess</artifactId>
-      <version>1.11.1</version>
+      <version>1.12</version>
       <scope>provided</scope>
     </dependency>
     <dependency>
diff --git a/microbench/src/main/java/io/netty/handler/codec/CodecOutputListBenchmark.java b/microbench/src/main/java/io/netty/handler/codec/CodecOutputListBenchmark.java
new file mode 100644
index 000000000000..8db4a99ffc25
--- /dev/null
+++ b/microbench/src/main/java/io/netty/handler/codec/CodecOutputListBenchmark.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec;
+
+import io.netty.microbench.util.AbstractMicrobenchmark;
+import io.netty.util.internal.RecyclableArrayList;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.Level;
+import org.openjdk.jmh.annotations.Param;
+import org.openjdk.jmh.annotations.Scope;
+import org.openjdk.jmh.annotations.Setup;
+import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.annotations.TearDown;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@State(Scope.Benchmark)
+public class CodecOutputListBenchmark extends AbstractMicrobenchmark {
+
+    private static final Object ELEMENT = new Object();
+    private CodecOutputList codecOutputList;
+    private RecyclableArrayList recycleableArrayList;
+    private List<Object> arrayList;
+
+    @Param({ "1", "4" })
+    public int elements;
+
+    @Setup(Level.Invocation)
+    public void setup() {
+        codecOutputList = CodecOutputList.newInstance();
+        recycleableArrayList = RecyclableArrayList.newInstance(16);
+        arrayList = new ArrayList<Object>(16);
+    }
+
+    @TearDown
+    public void destroy() {
+        codecOutputList.recycle();
+        recycleableArrayList.recycle();
+    }
+
+    @Benchmark
+    public void codecOutList() {
+        benchmarkAddAndClear(codecOutputList, elements);
+    }
+
+    @Benchmark
+    public void recyclableArrayList() {
+        benchmarkAddAndClear(recycleableArrayList, elements);
+    }
+
+    @Benchmark
+    public void arrayList() {
+        benchmarkAddAndClear(arrayList, elements);
+    }
+
+    private static void benchmarkAddAndClear(List<Object> list, int elements) {
+        for (int i = 0; i < elements; i++) {
+            list.add(ELEMENT);
+        }
+        list.clear();
+    }
+}
diff --git a/microbench/src/main/java/io/netty/handler/codec/package-info.java b/microbench/src/main/java/io/netty/handler/codec/package-info.java
new file mode 100644
index 000000000000..f10445a32118
--- /dev/null
+++ b/microbench/src/main/java/io/netty/handler/codec/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/**
+ * Benchmarks for {@link io.netty.handler.codec}.
+ */
+package io.netty.handler.codec;
diff --git a/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelWriteReleaseHandlerContext.java b/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelWriteReleaseHandlerContext.java
index 9a74f98d97d1..b1d60365986d 100644
--- a/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelWriteReleaseHandlerContext.java
+++ b/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelWriteReleaseHandlerContext.java
@@ -20,7 +20,6 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerInvoker;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelProgressivePromise;
 import io.netty.channel.ChannelPromise;
@@ -50,7 +49,7 @@ public EmbeddedChannelWriteReleaseHandlerContext(ByteBufAllocator alloc, Channel
         this.alloc = checkNotNull(alloc, "alloc");
         this.channel = checkNotNull(channel, "channel");
         this.handler = checkNotNull(handler, "handler");
-        this.eventLoop = checkNotNull(channel.eventLoop(), "eventLoop");
+        eventLoop = checkNotNull(channel.eventLoop(), "eventLoop");
     }
 
     protected abstract void handleException(Throwable t);
@@ -75,11 +74,6 @@ public EventExecutor executor() {
         return eventLoop;
     }
 
-    @Override
-    public ChannelHandlerInvoker invoker() {
-        return eventLoop.asInvoker();
-    }
-
     @Override
     public String name() {
         return HANDLER_NAME;
diff --git a/microbench/src/main/java/io/netty/microbench/http2/NoopHttp2RemoteFlowController.java b/microbench/src/main/java/io/netty/microbench/http2/NoopHttp2RemoteFlowController.java
index 85ba52c8fff2..ce250d4cace0 100644
--- a/microbench/src/main/java/io/netty/microbench/http2/NoopHttp2RemoteFlowController.java
+++ b/microbench/src/main/java/io/netty/microbench/http2/NoopHttp2RemoteFlowController.java
@@ -46,11 +46,6 @@ public boolean isWritable(Http2Stream stream) {
         return true;
     }
 
-    @Override
-    public int initialWindowSize(Http2Stream stream) {
-        return MAX_INITIAL_WINDOW_SIZE;
-    }
-
     @Override
     public void incrementWindowSize(Http2Stream stream, int delta) throws Http2Exception {
     }
diff --git a/microbench/src/main/java/io/netty/microbench/http2/hpack/DecoderBenchmark.java b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/DecoderBenchmark.java
similarity index 93%
rename from microbench/src/main/java/io/netty/microbench/http2/hpack/DecoderBenchmark.java
rename to microbench/src/main/java/io/netty/microbench/http2/internal/hpack/DecoderBenchmark.java
index 0ef4291d8edb..745d803735d4 100644
--- a/microbench/src/main/java/io/netty/microbench/http2/hpack/DecoderBenchmark.java
+++ b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/DecoderBenchmark.java
@@ -29,11 +29,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.microbench.http2.hpack;
+package io.netty.microbench.http2.internal.hpack;
 
-import io.netty.handler.codec.http2.hpack.Decoder;
-import io.netty.handler.codec.http2.hpack.Encoder;
-import io.netty.handler.codec.http2.hpack.HeaderListener;
+import io.netty.handler.codec.http2.internal.hpack.Decoder;
+import io.netty.handler.codec.http2.internal.hpack.Encoder;
+import io.netty.handler.codec.http2.internal.hpack.HeaderListener;
 import io.netty.microbench.util.AbstractMicrobenchmark;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
diff --git a/microbench/src/main/java/io/netty/microbench/http2/hpack/EncoderBenchmark.java b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/EncoderBenchmark.java
similarity index 96%
rename from microbench/src/main/java/io/netty/microbench/http2/hpack/EncoderBenchmark.java
rename to microbench/src/main/java/io/netty/microbench/http2/internal/hpack/EncoderBenchmark.java
index 1f532fe14b1c..804dcfa6b4e2 100644
--- a/microbench/src/main/java/io/netty/microbench/http2/hpack/EncoderBenchmark.java
+++ b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/EncoderBenchmark.java
@@ -29,9 +29,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.microbench.http2.hpack;
+package io.netty.microbench.http2.internal.hpack;
 
-import io.netty.handler.codec.http2.hpack.Encoder;
+import io.netty.handler.codec.http2.internal.hpack.Encoder;
 import io.netty.microbench.util.AbstractMicrobenchmark;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
diff --git a/microbench/src/main/java/io/netty/microbench/http2/hpack/Header.java b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/Header.java
similarity index 98%
rename from microbench/src/main/java/io/netty/microbench/http2/hpack/Header.java
rename to microbench/src/main/java/io/netty/microbench/http2/internal/hpack/Header.java
index 3150a41ed8ca..07905dbd8448 100644
--- a/microbench/src/main/java/io/netty/microbench/http2/hpack/Header.java
+++ b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/Header.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.microbench.http2.hpack;
+package io.netty.microbench.http2.internal.hpack;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/microbench/src/main/java/io/netty/microbench/http2/hpack/HeadersSize.java b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/HeadersSize.java
similarity index 97%
rename from microbench/src/main/java/io/netty/microbench/http2/hpack/HeadersSize.java
rename to microbench/src/main/java/io/netty/microbench/http2/internal/hpack/HeadersSize.java
index 0750b2030423..01b7956f9038 100644
--- a/microbench/src/main/java/io/netty/microbench/http2/hpack/HeadersSize.java
+++ b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/HeadersSize.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.microbench.http2.hpack;
+package io.netty.microbench.http2.internal.hpack;
 
 import java.io.ByteArrayOutputStream;
 import java.util.List;
diff --git a/microbench/src/main/java/io/netty/microbench/http2/hpack/Util.java b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/Util.java
similarity index 98%
rename from microbench/src/main/java/io/netty/microbench/http2/hpack/Util.java
rename to microbench/src/main/java/io/netty/microbench/http2/internal/hpack/Util.java
index 018f21035791..0e298bb0bbb3 100644
--- a/microbench/src/main/java/io/netty/microbench/http2/hpack/Util.java
+++ b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/Util.java
@@ -29,7 +29,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.netty.microbench.http2.hpack;
+package io.netty.microbench.http2.internal.hpack;
 
 import java.util.HashMap;
 import java.util.List;
diff --git a/microbench/src/main/java/io/netty/microbench/http2/hpack/package-info.java b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/package-info.java
similarity index 96%
rename from microbench/src/main/java/io/netty/microbench/http2/hpack/package-info.java
rename to microbench/src/main/java/io/netty/microbench/http2/internal/hpack/package-info.java
index 1f7579b3d699..2ef6bda25b91 100644
--- a/microbench/src/main/java/io/netty/microbench/http2/hpack/package-info.java
+++ b/microbench/src/main/java/io/netty/microbench/http2/internal/hpack/package-info.java
@@ -33,4 +33,4 @@
 /**
  * Benchmarks for {@link io.netty.handler.codec.http2.hpack}.
  */
-package io.netty.microbench.http2.hpack;
+package io.netty.microbench.http2.internal.hpack;
diff --git a/microbench/src/main/java/io/netty/microbenchmark/common/MathOperationsBenchmark.java b/microbench/src/main/java/io/netty/microbenchmark/common/MathOperationsBenchmark.java
new file mode 100644
index 000000000000..72cb4a4cda80
--- /dev/null
+++ b/microbench/src/main/java/io/netty/microbenchmark/common/MathOperationsBenchmark.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package io.netty.microbenchmark.common;
+
+import io.netty.microbench.util.AbstractMicrobenchmark;
+import org.openjdk.jmh.annotations.Benchmark;
+
+public class MathOperationsBenchmark extends AbstractMicrobenchmark {
+    private int index;
+    private final int length = 1 << 20;
+    private final int mask = length - 1;
+
+    @Benchmark
+    public int nextIndexNoConditionals() {
+        return (index + 1) & mask;
+    }
+
+    @Benchmark
+    public int nextIndexConditionals() {
+        return index == length - 1 ? 0 : index + 1;
+    }
+}
diff --git a/pom.xml b/pom.xml
index 387f9df32896..149ed11db0b9 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>io.netty</groupId>
   <artifactId>netty-parent</artifactId>
   <packaging>pom</packaging>
-  <version>4.1.0.CR7</version>
+  <version>4.1.0.Final</version>
 
   <name>Netty</name>
   <url>http://netty.io/</url>
@@ -53,7 +53,7 @@
     <url>https://github.com/netty/netty</url>
     <connection>scm:git:git://github.com/netty/netty.git</connection>
     <developerConnection>scm:git:ssh://git@github.com/netty/netty.git</developerConnection>
-    <tag>netty-4.1.0.CR7</tag>
+    <tag>netty-4.1.0.Final</tag>
   </scm>
 
   <developers>
@@ -202,9 +202,9 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
     <netty.build.version>22</netty.build.version>
-    <jboss.marshalling.version>1.3.18.GA</jboss.marshalling.version>
-    <jetty.alpnAgent.version>1.0.1.Final</jetty.alpnAgent.version>
-    <jetty.alpnAgent.path>${settings.localRepository}/kr/motd/javaagent/jetty-alpn-agent/${jetty.alpnAgent.version}/jetty-alpn-agent-${jetty.alpnAgent.version}.jar</jetty.alpnAgent.path>
+    <jboss.marshalling.version>1.4.8.Final</jboss.marshalling.version>
+    <jetty.alpnAgent.version>2.0.1</jetty.alpnAgent.version>
+    <jetty.alpnAgent.path>${settings.localRepository}/org/mortbay/jetty/alpn/jetty-alpn-agent/${jetty.alpnAgent.version}/jetty-alpn-agent-${jetty.alpnAgent.version}.jar</jetty.alpnAgent.path>
     <argLine.common>
       -server
       -dsa -da -ea:io.netty...
@@ -224,9 +224,11 @@
     <!-- Fedora-"like" systems. This is currently only used for the netty-tcnative dependency -->
     <os.detection.classifierWithLikes>fedora</os.detection.classifierWithLikes>
     <tcnative.artifactId>netty-tcnative</tcnative.artifactId>
-    <tcnative.version>1.1.33.Fork15</tcnative.version>
+    <tcnative.version>1.1.33.Fork17</tcnative.version>
     <tcnative.classifier>${os.detected.classifier}</tcnative.classifier>
     <epoll.classifier>${os.detected.name}-${os.detected.arch}</epoll.classifier>
+    <logging.config>${project.basedir}/../common/src/test/resources/logback-test.xml</logging.config>
+    <logging.logLevel>debug</logging.logLevel>
   </properties>
 
   <modules>
@@ -239,6 +241,7 @@
     <module>codec-http2</module>
     <module>codec-memcache</module>
     <module>codec-mqtt</module>
+    <module>codec-redis</module>
     <module>codec-smtp</module>
     <module>codec-socks</module>
     <module>codec-stomp</module>
@@ -265,7 +268,7 @@
       <dependency>
         <groupId>org.javassist</groupId>
         <artifactId>javassist</artifactId>
-        <version>3.19.0-GA</version>
+        <version>3.20.0-GA</version>
         <scope>compile</scope>
         <optional>true</optional>
       </dependency>
@@ -297,12 +300,12 @@
       <dependency>
         <groupId>com.google.protobuf</groupId>
         <artifactId>protobuf-java</artifactId>
-        <version>2.5.0</version>
+        <version>2.6.1</version>
       </dependency>
       <dependency>
         <groupId>com.google.protobuf.nano</groupId>
         <artifactId>protobuf-javanano</artifactId>
-        <version>3.0.0-alpha-4</version>
+        <version>3.0.0-alpha-5</version>
       </dependency>
 
       <!-- Our own Tomcat Native fork - completely optional, used for acclerating SSL with OpenSSL. -->
@@ -323,7 +326,7 @@
       <dependency>
         <groupId>org.bouncycastle</groupId>
         <artifactId>bcpkix-jdk15on</artifactId>
-        <version>1.50</version>
+        <version>1.54</version>
         <scope>compile</scope>
         <optional>true</optional>
       </dependency>
@@ -331,7 +334,7 @@
       <dependency>
         <groupId>com.fasterxml</groupId>
         <artifactId>aalto-xml</artifactId>
-        <version>0.9.9</version>
+        <version>1.0.0</version>
       </dependency>
 
       <dependency>
@@ -376,17 +379,17 @@
       <dependency>
         <groupId>org.slf4j</groupId>
         <artifactId>slf4j-api</artifactId>
-        <version>1.7.5</version>
+        <version>1.7.21</version>
       </dependency>
       <dependency>
         <groupId>commons-logging</groupId>
         <artifactId>commons-logging</artifactId>
-        <version>1.1.3</version>
+        <version>1.2</version>
       </dependency>
       <dependency>
         <groupId>org.apache.logging.log4j</groupId>
         <artifactId>log4j-api</artifactId>
-        <version>2.3</version>
+        <version>2.5</version>
       </dependency>
       <dependency>
         <groupId>log4j</groupId>
@@ -454,7 +457,7 @@
       <dependency>
         <groupId>org.jmock</groupId>
         <artifactId>jmock-junit4</artifactId>
-        <version>2.6.0</version>
+        <version>2.8.2</version>
         <scope>test</scope>
         <exclusions>
           <exclusion>
@@ -466,13 +469,13 @@
       <dependency>
         <groupId>org.mockito</groupId>
         <artifactId>mockito-core</artifactId>
-        <version>1.10.8</version>
+        <version>1.10.19</version>
         <scope>test</scope>
       </dependency>
       <dependency>
         <groupId>ch.qos.logback</groupId>
         <artifactId>logback-classic</artifactId>
-        <version>1.0.13</version>
+        <version>1.1.7</version>
         <scope>test</scope>
       </dependency>
 
@@ -510,7 +513,7 @@
       <dependency>
         <groupId>com.google.code.gson</groupId>
         <artifactId>gson</artifactId>
-        <version>2.3.1</version>
+        <version>2.6.2</version>
         <scope>test</scope>
       </dependency>
 
@@ -533,7 +536,7 @@
       <dependency>
         <groupId>org.apache.logging.log4j</groupId>
         <artifactId>log4j-core</artifactId>
-        <version>2.3</version>
+        <version>2.5</version>
         <scope>test</scope>
       </dependency>
     </dependencies>
@@ -618,6 +621,13 @@
                 <requireMavenVersion>
                   <version>[3.1.1,)</version>
                 </requireMavenVersion>
+                <requireProperty>
+                  <regexMessage>
+                    x86_64 JDK must be used.
+                  </regexMessage>
+                  <property>os.detected.arch</property>
+                  <regex>^x86_64$</regex>
+                </requireProperty>
               </rules>
             </configuration>
           </execution>
@@ -780,7 +790,7 @@
               <goal>get</goal>
             </goals>
             <configuration>
-              <groupId>kr.motd.javaagent</groupId>
+              <groupId>org.mortbay.jetty.alpn</groupId>
               <artifactId>jetty-alpn-agent</artifactId>
               <version>${jetty.alpnAgent.version}</version>
             </configuration>
@@ -799,6 +809,10 @@
             <exclude>**/TestUtil*</exclude>
           </excludes>
           <runOrder>random</runOrder>
+          <systemPropertyVariables>
+            <logback.configurationFile>${logging.config}</logback.configurationFile>
+            <logLevel>${logging.logLevel}</logLevel>
+          </systemPropertyVariables>
           <argLine>${argLine.common} ${argLine.alpnAgent} ${argLine.leak} ${argLine.coverage} ${argLine.noUnsafe}</argLine>
           <properties>
             <property>
diff --git a/resolver-dns/pom.xml b/resolver-dns/pom.xml
index cc98d16c1492..9a435fc47b43 100644
--- a/resolver-dns/pom.xml
+++ b/resolver-dns/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-resolver-dns</artifactId>
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java
index 899cf0cfae08..06589b976826 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java
@@ -18,6 +18,7 @@
 import io.netty.channel.EventLoop;
 import io.netty.util.internal.OneTimeTask;
 import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetAddress;
 import java.util.ArrayList;
@@ -33,6 +34,7 @@
 /**
  * Default implementation of {@link DnsCache}, backed by a {@link ConcurrentMap}.
  */
+@UnstableApi
 public class DefaultDnsCache implements DnsCache {
 
     private final ConcurrentMap<String, List<DnsCacheEntry>> resolveCache = PlatformDependent.newConcurrentHashMap();
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java
index ffc747a64817..1f666076c746 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java
@@ -22,22 +22,34 @@
 import io.netty.channel.socket.DatagramChannel;
 import io.netty.resolver.AddressResolver;
 import io.netty.resolver.AddressResolverGroup;
+import io.netty.resolver.InetSocketAddressResolver;
+import io.netty.resolver.NameResolver;
 import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Promise;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.UnstableApi;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.util.List;
+import java.util.concurrent.ConcurrentMap;
 
 import static io.netty.resolver.dns.DnsNameResolver.ANY_LOCAL_ADDR;
+import static io.netty.util.internal.PlatformDependent.newConcurrentHashMap;
 
 /**
  * A {@link AddressResolverGroup} of {@link DnsNameResolver}s.
  */
+@UnstableApi
 public class DnsAddressResolverGroup extends AddressResolverGroup<InetSocketAddress> {
 
     private final ChannelFactory<? extends DatagramChannel> channelFactory;
     private final InetSocketAddress localAddress;
     private final DnsServerAddresses nameServerAddresses;
 
+    private final ConcurrentMap<String, Promise<InetAddress>> resolvesInProgress = newConcurrentHashMap();
+    private final ConcurrentMap<String, Promise<List<InetAddress>>> resolveAllsInProgress = newConcurrentHashMap();
+
     public DnsAddressResolverGroup(
             Class<? extends DatagramChannel> channelType, DnsServerAddresses nameServerAddresses) {
         this(channelType, ANY_LOCAL_ADDR, nameServerAddresses);
@@ -81,11 +93,16 @@ protected AddressResolver<InetSocketAddress> newResolver(
             EventLoop eventLoop, ChannelFactory<? extends DatagramChannel> channelFactory,
             InetSocketAddress localAddress, DnsServerAddresses nameServerAddresses) throws Exception {
 
-        return new DnsNameResolverBuilder(eventLoop)
-                .channelFactory(channelFactory)
-                .localAddress(localAddress)
-                .nameServerAddresses(nameServerAddresses)
-                .build()
-                .asAddressResolver();
+        final NameResolver<InetAddress> resolver = new InflightNameResolver<InetAddress>(
+                eventLoop,
+                new DnsNameResolverBuilder(eventLoop)
+                        .channelFactory(channelFactory)
+                        .localAddress(localAddress)
+                        .nameServerAddresses(nameServerAddresses)
+                        .build(),
+                resolvesInProgress,
+                resolveAllsInProgress);
+
+        return new InetSocketAddressResolver(eventLoop, resolver);
     }
 }
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
index 79ea3876d5f0..e7a694344083 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java
@@ -16,6 +16,7 @@
 package io.netty.resolver.dns;
 
 import io.netty.channel.EventLoop;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetAddress;
 import java.util.List;
@@ -23,6 +24,7 @@
 /**
  * A cache for DNS resolution entries.
  */
+@UnstableApi
 public interface DnsCache {
 
     /**
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java
index 789ef7ab8424..c03b5ae17b70 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java
@@ -20,6 +20,7 @@
 
 import io.netty.channel.EventLoop;
 import io.netty.util.concurrent.ScheduledFuture;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetAddress;
 import java.util.concurrent.TimeUnit;
@@ -27,6 +28,7 @@
 /**
  * Entry in {@link DnsCache}.
  */
+@UnstableApi
 public final class DnsCacheEntry {
 
     private final String hostname;
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
index 52853ba5afa0..576a47229e6f 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java
@@ -40,6 +40,7 @@
 import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.Promise;
+import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -56,6 +57,7 @@
 /**
  * A DNS-based {@link InetNameResolver}.
  */
+@UnstableApi
 public class DnsNameResolver extends InetNameResolver {
 
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(DnsNameResolver.class);
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
index a5861f9dfaff..eb3338651c58 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java
@@ -24,6 +24,7 @@
 import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.resolver.HostsFileEntriesResolver;
 import io.netty.util.internal.InternalThreadLocalMap;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 import java.util.List;
@@ -33,6 +34,7 @@
 /**
  * A {@link DnsNameResolver} builder.
  */
+@UnstableApi
 public final class DnsNameResolverBuilder {
 
     private final EventLoop eventLoop;
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
index 05eb8757bd1d..07eb32e63c84 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverException.java
@@ -18,12 +18,14 @@
 import io.netty.handler.codec.dns.DnsQuestion;
 import io.netty.util.internal.EmptyArrays;
 import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetSocketAddress;
 
 /**
  * A {@link RuntimeException} raised when {@link DnsNameResolver} failed to perform a successful query.
  */
+@UnstableApi
 public final class DnsNameResolverException extends RuntimeException {
 
     private static final long serialVersionUID = -8826717909627131850L;
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java
index 2e806ef787fc..3f04d695304d 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStream.java
@@ -16,11 +16,14 @@
 
 package io.netty.resolver.dns;
 
+import io.netty.util.internal.UnstableApi;
+
 import java.net.InetSocketAddress;
 
 /**
  * An infinite stream of DNS server addresses.
  */
+@UnstableApi
 public interface DnsServerAddressStream {
     /**
      * Retrieves the next DNS server address from the stream.
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java
index fcd842c90a1a..627243354845 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java
@@ -17,6 +17,7 @@
 package io.netty.resolver.dns;
 
 import io.netty.util.internal.InternalThreadLocalMap;
+import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -31,6 +32,7 @@
 /**
  * Provides an infinite sequence of DNS server addresses to {@link DnsNameResolver}.
  */
+@UnstableApi
 @SuppressWarnings("IteratorNextCanNotThrowNoSuchElementException")
 public abstract class DnsServerAddresses {
 
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java b/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java
new file mode 100644
index 000000000000..cb93f9a2127f
--- /dev/null
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/InflightNameResolver.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.resolver.dns;
+
+import io.netty.resolver.NameResolver;
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.FutureListener;
+import io.netty.util.concurrent.Promise;
+import io.netty.util.internal.StringUtil;
+
+import java.util.List;
+import java.util.concurrent.ConcurrentMap;
+
+import static io.netty.util.internal.ObjectUtil.checkNotNull;
+
+// FIXME(trustin): Find a better name and move it to the 'resolver' module.
+final class InflightNameResolver<T> implements NameResolver<T> {
+
+    private final EventExecutor executor;
+    private final NameResolver<T> delegate;
+    private final ConcurrentMap<String, Promise<T>> resolvesInProgress;
+    private final ConcurrentMap<String, Promise<List<T>>> resolveAllsInProgress;
+
+    InflightNameResolver(EventExecutor executor, NameResolver<T> delegate,
+                         ConcurrentMap<String, Promise<T>> resolvesInProgress,
+                         ConcurrentMap<String, Promise<List<T>>> resolveAllsInProgress) {
+
+        this.executor = checkNotNull(executor, "executor");
+        this.delegate = checkNotNull(delegate, "delegate");
+        this.resolvesInProgress = checkNotNull(resolvesInProgress, "resolvesInProgress");
+        this.resolveAllsInProgress = checkNotNull(resolveAllsInProgress, "resolveAllsInProgress");
+    }
+
+    @Override
+    public Future<T> resolve(String inetHost) {
+        return resolve(inetHost, executor.<T>newPromise());
+    }
+
+    @Override
+    public Future<List<T>> resolveAll(String inetHost) {
+        return resolveAll(inetHost, executor.<List<T>>newPromise());
+    }
+
+    @Override
+    public void close() {
+        delegate.close();
+    }
+
+    @Override
+    public Promise<T> resolve(String inetHost, Promise<T> promise) {
+        return resolve(resolvesInProgress, inetHost, promise, false);
+    }
+
+    @Override
+    public Promise<List<T>> resolveAll(String inetHost, Promise<List<T>> promise) {
+        return resolve(resolveAllsInProgress, inetHost, promise, true);
+    }
+
+    private <U> Promise<U> resolve(
+            final ConcurrentMap<String, Promise<U>> resolveMap,
+            final String inetHost, final Promise<U> promise, boolean resolveAll) {
+
+        final Promise<U> earlyPromise = resolveMap.putIfAbsent(inetHost, promise);
+        if (earlyPromise != null) {
+            // Name resolution for the specified inetHost is in progress already.
+            if (earlyPromise.isDone()) {
+                transferResult(earlyPromise, promise);
+            } else {
+                earlyPromise.addListener(new FutureListener<U>() {
+                    @Override
+                    public void operationComplete(Future<U> f) throws Exception {
+                        transferResult(f, promise);
+                    }
+                });
+            }
+        } else {
+            try {
+                if (resolveAll) {
+                    @SuppressWarnings("unchecked")
+                    final Promise<List<T>> castPromise = (Promise<List<T>>) promise; // U is List<T>
+                    delegate.resolveAll(inetHost, castPromise);
+                } else {
+                    @SuppressWarnings("unchecked")
+                    final Promise<T> castPromise = (Promise<T>) promise; // U is T
+                    delegate.resolve(inetHost, castPromise);
+                }
+            } finally {
+                if (promise.isDone()) {
+                    resolveMap.remove(inetHost);
+                } else {
+                    promise.addListener(new FutureListener<U>() {
+                        @Override
+                        public void operationComplete(Future<U> f) throws Exception {
+                            resolveMap.remove(inetHost);
+                        }
+                    });
+                }
+            }
+        }
+
+        return promise;
+    }
+
+    private static <T> void transferResult(Future<T> src, Promise<T> dst) {
+        if (src.isSuccess()) {
+            dst.trySuccess(src.getNow());
+        } else {
+            dst.tryFailure(src.cause());
+        }
+    }
+
+    @Override
+    public String toString() {
+        return StringUtil.simpleClassName(this) + '(' + delegate + ')';
+    }
+}
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java b/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java
index 0fbcf486977b..7b084dfe1c12 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/NoopDnsCache.java
@@ -16,6 +16,7 @@
 package io.netty.resolver.dns;
 
 import io.netty.channel.EventLoop;
+import io.netty.util.internal.UnstableApi;
 
 import java.net.InetAddress;
 import java.util.Collections;
@@ -24,6 +25,7 @@
 /**
  * A noop DNS cache that actually never caches anything.
  */
+@UnstableApi
 public final class NoopDnsCache implements DnsCache {
 
     public static final NoopDnsCache INSTANCE = new NoopDnsCache();
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java b/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java
index 63825ba87883..3edc17840e04 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/package-info.java
@@ -18,4 +18,7 @@
  * An alternative to Java's built-in domain name lookup mechanism that resolves a domain name asynchronously,
  * which supports the queries of an arbitrary DNS record type as well.
  */
+@UnstableApi
 package io.netty.resolver.dns;
+
+import io.netty.util.internal.UnstableApi;
diff --git a/resolver/pom.xml b/resolver/pom.xml
index 3c990d697367..a5ba370388e8 100644
--- a/resolver/pom.xml
+++ b/resolver/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-resolver</artifactId>
diff --git a/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java
index 3d19042e5cc9..dbf5fb9ca8e9 100644
--- a/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java
+++ b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java
@@ -16,6 +16,7 @@
 package io.netty.resolver;
 
 import java.net.InetAddress;
+import java.util.Locale;
 import java.util.Map;
 
 /**
@@ -27,6 +28,6 @@ public final class DefaultHostsFileEntriesResolver implements HostsFileEntriesRe
 
     @Override
     public InetAddress address(String inetHost) {
-        return entries.get(inetHost);
+        return entries.get(inetHost.toLowerCase(Locale.ENGLISH));
     }
 }
diff --git a/resolver/src/main/java/io/netty/resolver/HostsFileParser.java b/resolver/src/main/java/io/netty/resolver/HostsFileParser.java
index 0e8b9163c712..a17a0f7068a1 100644
--- a/resolver/src/main/java/io/netty/resolver/HostsFileParser.java
+++ b/resolver/src/main/java/io/netty/resolver/HostsFileParser.java
@@ -29,6 +29,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Locale;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.regex.Pattern;
@@ -151,10 +152,11 @@ public static Map<String, InetAddress> parse(Reader reader) throws IOException {
                 // loop over hostname and aliases
                 for (int i = 1; i < lineParts.size(); i ++) {
                     String hostname = lineParts.get(i);
-                    if (!entries.containsKey(hostname)) {
+                    String hostnameLower = hostname.toLowerCase(Locale.ENGLISH);
+                    if (!entries.containsKey(hostnameLower)) {
                         // trying to map a host to multiple IPs is wrong
                         // only the first entry is honored
-                        entries.put(hostname, InetAddress.getByAddress(hostname, ipBytes));
+                        entries.put(hostnameLower, InetAddress.getByAddress(hostname, ipBytes));
                     }
                 }
             }
diff --git a/resolver/src/test/java/io/netty/resolver/DefaultHostsFileEntriesResolverTest.java b/resolver/src/test/java/io/netty/resolver/DefaultHostsFileEntriesResolverTest.java
new file mode 100644
index 000000000000..7fac11b2d5a0
--- /dev/null
+++ b/resolver/src/test/java/io/netty/resolver/DefaultHostsFileEntriesResolverTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/**
+ * show issue https://github.com/netty/netty/issues/5182
+ * HostsFileParser tries to resolve hostnames as case-sensitive
+ */
+package io.netty.resolver;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertNotNull;
+
+public class DefaultHostsFileEntriesResolverTest {
+
+    @Test
+    public void testLocalhost() {
+        DefaultHostsFileEntriesResolver resolver = new DefaultHostsFileEntriesResolver();
+        assertNotNull("localhost doesn't resolve", resolver.address("localhost"));
+        assertNotNull("LOCALHOST doesn't resolve", resolver.address("LOCALHOST"));
+    }
+}
diff --git a/resolver/src/test/java/io/netty/resolver/HostsFileParserTest.java b/resolver/src/test/java/io/netty/resolver/HostsFileParserTest.java
index d32613389573..bc059107b90e 100644
--- a/resolver/src/test/java/io/netty/resolver/HostsFileParserTest.java
+++ b/resolver/src/test/java/io/netty/resolver/HostsFileParserTest.java
@@ -38,16 +38,20 @@ public void testParse() throws IOException {
                 .append("192.168.0.2  host3  #comment").append("\n") // comment after hostname
                 .append("192.168.0.3  host4  host5 host6").append("\n") // multiple aliases
                 .append("192.168.0.4  host4").append("\n") // host mapped to a second address, must be ignored
+                .append("192.168.0.5  HOST7").append("\n") // uppercase host, should match lowercase host
+                .append("192.168.0.6  host7").append("\n") // should be ignored since we have the uppercase host already
                 .toString();
 
         Map<String, InetAddress> entries = HostsFileParser.parse(new BufferedReader(new StringReader(hostsString)));
 
-        assertEquals("Expected 6 entries", 6, entries.size());
+        assertEquals("Expected 7 entries", 7, entries.size());
         assertEquals("127.0.0.1", entries.get("host1").getHostAddress());
         assertEquals("192.168.0.1", entries.get("host2").getHostAddress());
         assertEquals("192.168.0.2", entries.get("host3").getHostAddress());
         assertEquals("192.168.0.3", entries.get("host4").getHostAddress());
         assertEquals("192.168.0.3", entries.get("host5").getHostAddress());
         assertEquals("192.168.0.3", entries.get("host6").getHostAddress());
+        assertNotNull("uppercase host doesn't resolve", entries.get("host7"));
+        assertEquals("192.168.0.5", entries.get("host7").getHostAddress());
     }
 }
diff --git a/run-example.sh b/run-example.sh
index f81439441cc4..3d7667df32fc 100755
--- a/run-example.sh
+++ b/run-example.sh
@@ -28,6 +28,7 @@ EXAMPLE_MAP=(
   'objectecho-server:io.netty.example.objectecho.ObjectEchoServer'
   'quote-client:org.jboss.netty.example.qotm.QuoteOfTheMomentClient'
   'quote-server:org.jboss.netty.example.qotm.QuoteOfTheMomentServer'
+  'redis-client:io.netty.example.redis.RedisClient'
   'securechat-client:io.netty.example.securechat.SecureChatClient'
   'securechat-server:io.netty.example.securechat.SecureChatServer'
   'telnet-client:io.netty.example.telnet.TelnetClient'
diff --git a/tarball/pom.xml b/tarball/pom.xml
index 8b2ba608857c..e2dfb570fa06 100644
--- a/tarball/pom.xml
+++ b/tarball/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-tarball</artifactId>
diff --git a/testsuite-osgi/pom.xml b/testsuite-osgi/pom.xml
index ce43adeb2e01..145e0b550703 100644
--- a/testsuite-osgi/pom.xml
+++ b/testsuite-osgi/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-testsuite-osgi</artifactId>
diff --git a/testsuite/pom.xml b/testsuite/pom.xml
index 60e37dfb7daa..294d33ebb4fc 100644
--- a/testsuite/pom.xml
+++ b/testsuite/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-testsuite</artifactId>
diff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
index 62887699405e..29edbb933e60 100644
--- a/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java
@@ -63,15 +63,13 @@ public void testSimpleSendCompositeDirectByteBuf() throws Throwable {
 
     public void testSimpleSendCompositeDirectByteBuf(Bootstrap sb, Bootstrap cb) throws Throwable {
         CompositeByteBuf buf = Unpooled.compositeBuffer();
-        buf.addComponent(Unpooled.directBuffer().writeBytes(BYTES, 0, 2));
-        buf.addComponent(Unpooled.directBuffer().writeBytes(BYTES, 2, 2));
-        buf.writerIndex(4);
+        buf.addComponent(true, Unpooled.directBuffer().writeBytes(BYTES, 0, 2));
+        buf.addComponent(true, Unpooled.directBuffer().writeBytes(BYTES, 2, 2));
         testSimpleSend0(sb, cb, buf, true, BYTES, 1);
 
         CompositeByteBuf buf2 = Unpooled.compositeBuffer();
-        buf2.addComponent(Unpooled.directBuffer().writeBytes(BYTES, 0, 2));
-        buf2.addComponent(Unpooled.directBuffer().writeBytes(BYTES, 2, 2));
-        buf2.writerIndex(4);
+        buf2.addComponent(true, Unpooled.directBuffer().writeBytes(BYTES, 0, 2));
+        buf2.addComponent(true, Unpooled.directBuffer().writeBytes(BYTES, 2, 2));
         testSimpleSend0(sb, cb, buf2, true, BYTES, 4);
     }
 
@@ -82,15 +80,13 @@ public void testSimpleSendCompositeHeapByteBuf() throws Throwable {
 
     public void testSimpleSendCompositeHeapByteBuf(Bootstrap sb, Bootstrap cb) throws Throwable {
         CompositeByteBuf buf = Unpooled.compositeBuffer();
-        buf.addComponent(Unpooled.buffer().writeBytes(BYTES, 0, 2));
-        buf.addComponent(Unpooled.buffer().writeBytes(BYTES, 2, 2));
-        buf.writerIndex(4);
+        buf.addComponent(true, Unpooled.buffer().writeBytes(BYTES, 0, 2));
+        buf.addComponent(true, Unpooled.buffer().writeBytes(BYTES, 2, 2));
         testSimpleSend0(sb, cb, buf, true, BYTES, 1);
 
         CompositeByteBuf buf2 = Unpooled.compositeBuffer();
-        buf2.addComponent(Unpooled.buffer().writeBytes(BYTES, 0, 2));
-        buf2.addComponent(Unpooled.buffer().writeBytes(BYTES, 2, 2));
-        buf2.writerIndex(4);
+        buf2.addComponent(true, Unpooled.buffer().writeBytes(BYTES, 0, 2));
+        buf2.addComponent(true, Unpooled.buffer().writeBytes(BYTES, 2, 2));
         testSimpleSend0(sb, cb, buf2, true, BYTES, 4);
     }
 
@@ -101,15 +97,13 @@ public void testSimpleSendCompositeMixedByteBuf() throws Throwable {
 
     public void testSimpleSendCompositeMixedByteBuf(Bootstrap sb, Bootstrap cb) throws Throwable {
         CompositeByteBuf buf = Unpooled.compositeBuffer();
-        buf.addComponent(Unpooled.directBuffer().writeBytes(BYTES, 0, 2));
-        buf.addComponent(Unpooled.buffer().writeBytes(BYTES, 2, 2));
-        buf.writerIndex(4);
+        buf.addComponent(true, Unpooled.directBuffer().writeBytes(BYTES, 0, 2));
+        buf.addComponent(true, Unpooled.buffer().writeBytes(BYTES, 2, 2));
         testSimpleSend0(sb, cb, buf, true, BYTES, 1);
 
         CompositeByteBuf buf2 = Unpooled.compositeBuffer();
-        buf2.addComponent(Unpooled.directBuffer().writeBytes(BYTES, 0, 2));
-        buf2.addComponent(Unpooled.buffer().writeBytes(BYTES, 2, 2));
-        buf2.writerIndex(4);
+        buf2.addComponent(true, Unpooled.directBuffer().writeBytes(BYTES, 0, 2));
+        buf2.addComponent(true, Unpooled.buffer().writeBytes(BYTES, 2, 2));
         testSimpleSend0(sb, cb, buf2, true, BYTES, 4);
     }
 
diff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
index bec2bf46e4aa..3a7c3e487aec 100644
--- a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java
@@ -127,7 +127,7 @@ private void testGatheringWrite0(
                 buf.writerIndex(split);
                 ByteBuf buf2 = Unpooled.buffer(size).writeBytes(buf, split, oldIndex - split);
                 CompositeByteBuf comp = Unpooled.compositeBuffer();
-                comp.addComponent(buf).addComponent(buf2).writerIndex(length);
+                comp.addComponent(true, buf).addComponent(true, buf2);
                 cc.write(comp);
             } else {
                 cc.write(buf);
diff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
index 110bd1c5bc90..ad9b5c436657 100644
--- a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java
@@ -287,7 +287,7 @@ public void initChannel(Channel sch) throws Exception {
             int length = Math.min(random.nextInt(1024 * 64), data.length - clientSendCounterVal);
             ByteBuf buf = Unpooled.wrappedBuffer(data, clientSendCounterVal, length);
             if (useCompositeByteBuf) {
-                buf = Unpooled.compositeBuffer().addComponent(buf).writerIndex(buf.writerIndex());
+                buf = Unpooled.compositeBuffer().addComponent(true, buf);
             }
 
             ChannelFuture future = clientChannel.writeAndFlush(buf);
@@ -520,7 +520,7 @@ public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception
 
             ByteBuf buf = Unpooled.wrappedBuffer(actual);
             if (useCompositeByteBuf) {
-                buf = Unpooled.compositeBuffer().addComponent(buf).writerIndex(buf.writerIndex());
+                buf = Unpooled.compositeBuffer().addComponent(true, buf);
             }
             ctx.write(buf);
 
diff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java
index 6eed0bc15ea3..ad124f639697 100644
--- a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java
+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java
@@ -52,7 +52,8 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 @RunWith(Parameterized.class)
 public class SocketSslGreetingTest extends AbstractSocketTest {
@@ -200,7 +201,7 @@ protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Except
         public void channelActive(ChannelHandlerContext ctx)
                 throws Exception {
             channel = ctx.channel();
-            channel.writeAndFlush(greeting.duplicate().retain());
+            channel.writeAndFlush(greeting.retainedDuplicate());
         }
 
         @Override
diff --git a/transport-native-epoll/pom.xml b/transport-native-epoll/pom.xml
index c3e72fe24349..daac67bbae85 100644
--- a/transport-native-epoll/pom.xml
+++ b/transport-native-epoll/pom.xml
@@ -19,7 +19,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
   <artifactId>netty-transport-native-epoll</artifactId>
 
@@ -113,7 +113,6 @@
 
       <plugin>
         <artifactId>maven-antrun-plugin</artifactId>
-        <version>1.7</version>
         <executions>
           <execution>
             <!-- Phase must be before regex-glibc-sendmmsg and regex-linux-sendmmsg -->
@@ -140,7 +139,6 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>build-helper-maven-plugin</artifactId>
-        <version>1.7</version>
         <executions>
           <execution>
             <!-- Phase must be before regex-combined-sendmmsg -->
diff --git a/transport-native-epoll/src/main/c/netty_epoll_native.c b/transport-native-epoll/src/main/c/netty_epoll_native.c
index 403dcc9e7e82..b977de686b4c 100644
--- a/transport-native-epoll/src/main/c/netty_epoll_native.c
+++ b/transport-native-epoll/src/main/c/netty_epoll_native.c
@@ -232,24 +232,24 @@ static jint netty_epoll_native_epollCtlDel0(JNIEnv* env, jclass clazz, jint efd,
 
 static jint netty_epoll_native_sendmmsg0(JNIEnv* env, jclass clazz, jint fd, jobjectArray packets, jint offset, jint len) {
     struct mmsghdr msg[len];
+    struct sockaddr_storage addr[len];
     int i;
 
     memset(msg, 0, sizeof(msg));
 
     for (i = 0; i < len; i++) {
-        struct sockaddr_storage addr;
 
         jobject packet = (*env)->GetObjectArrayElement(env, packets, i + offset);
         jbyteArray address = (jbyteArray) (*env)->GetObjectField(env, packet, packetAddrFieldId);
         jint scopeId = (*env)->GetIntField(env, packet, packetScopeIdFieldId);
         jint port = (*env)->GetIntField(env, packet, packetPortFieldId);
 
-        if (netty_unix_socket_initSockaddr(env, address, scopeId, port, &addr) == -1) {
+        if (netty_unix_socket_initSockaddr(env, address, scopeId, port, &addr[i]) == -1) {
             return -1;
         }
 
-        msg[i].msg_hdr.msg_name = &addr;
-        msg[i].msg_hdr.msg_namelen = sizeof(addr);
+        msg[i].msg_hdr.msg_name = &addr[i];
+        msg[i].msg_hdr.msg_namelen = sizeof(addr[i]);
 
         msg[i].msg_hdr.msg_iov = (struct iovec*) (intptr_t) (*env)->GetLongField(env, packet, packetMemoryAddressFieldId);
         msg[i].msg_hdr.msg_iovlen = (*env)->GetIntField(env, packet, packetCountFieldId);;
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
index bc22b37370e6..8cdbba542efc 100644
--- a/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java
@@ -530,7 +530,7 @@ protected Object filterOutboundMessage(Object msg) {
                 "unsupported message type: " + StringUtil.simpleClassName(msg) + EXPECTED_TYPES);
     }
 
-    protected void shutdownOutput0(final ChannelPromise promise) {
+    private void shutdownOutput0(final ChannelPromise promise) {
         try {
             fd().shutdown(false, true);
             promise.setSuccess();
@@ -539,14 +539,37 @@ protected void shutdownOutput0(final ChannelPromise promise) {
         }
     }
 
+    private void shutdownInput0(final ChannelPromise promise) {
+        try {
+            fd().shutdown(true, false);
+            promise.setSuccess();
+        } catch (Throwable cause) {
+            promise.setFailure(cause);
+        }
+    }
+
+    private void shutdown0(final ChannelPromise promise) {
+        try {
+            fd().shutdown(true, true);
+            promise.setSuccess();
+        } catch (Throwable cause) {
+            promise.setFailure(cause);
+        }
+    }
+
+    @Override
+    public boolean isOutputShutdown() {
+        return fd().isOutputShutdown();
+    }
+
     @Override
     public boolean isInputShutdown() {
         return fd().isInputShutdown();
     }
 
     @Override
-    public boolean isOutputShutdown() {
-        return fd().isOutputShutdown();
+    public boolean isShutdown() {
+        return fd().isShutdown();
     }
 
     @Override
@@ -580,6 +603,68 @@ public void run() {
         return promise;
     }
 
+    @Override
+    public ChannelFuture shutdownInput() {
+        return shutdownInput(newPromise());
+    }
+
+    @Override
+    public ChannelFuture shutdownInput(final ChannelPromise promise) {
+        Executor closeExecutor = ((EpollStreamUnsafe) unsafe()).prepareToClose();
+        if (closeExecutor != null) {
+            closeExecutor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    shutdownInput0(promise);
+                }
+            });
+        } else {
+            EventLoop loop = eventLoop();
+            if (loop.inEventLoop()) {
+                shutdownInput0(promise);
+            } else {
+                loop.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        shutdownInput0(promise);
+                    }
+                });
+            }
+        }
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture shutdown() {
+        return shutdown(newPromise());
+    }
+
+    @Override
+    public ChannelFuture shutdown(final ChannelPromise promise) {
+        Executor closeExecutor = ((EpollStreamUnsafe) unsafe()).prepareToClose();
+        if (closeExecutor != null) {
+            closeExecutor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    shutdown0(promise);
+                }
+            });
+        } else {
+            EventLoop loop = eventLoop();
+            if (loop.inEventLoop()) {
+                shutdown0(promise);
+            } else {
+                loop.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        shutdown0(promise);
+                    }
+                });
+            }
+        }
+        return promise;
+    }
+
     @Override
     protected void doClose() throws Exception {
         try {
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
index 15289a0a08b1..1e0ac80cf88b 100644
--- a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
@@ -201,6 +201,14 @@ private int epollWait(boolean oldWakenUp) throws IOException {
                 break;
             }
 
+            // If a task was submitted when wakenUp value was 1, the task didn't get a chance to produce wakeup event.
+            // So we need to check task queue again before calling epoll_wait. If we don't, the task might be pended
+            // until epoll_wait was timed out. It might be pended until idle timeout if IdleStateHandler existed
+            // in pipeline.
+            if (hasTasks() && WAKEN_UP_UPDATER.compareAndSet(this, 0, 1)) {
+                return Native.epollWait(epollFd.intValue(), events, 0);
+            }
+
             int selectedKeys = Native.epollWait(epollFd.intValue(), events, (int) timeoutMillis);
             selectCnt ++;
 
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java
index c151806c66b7..6f9351210d36 100644
--- a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java
@@ -15,8 +15,8 @@
  */
 package io.netty.channel.epoll;
 
-import io.netty.channel.EventLoop;
 import io.netty.channel.DefaultSelectStrategyFactory;
+import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.MultithreadEventLoopGroup;
 import io.netty.channel.SelectStrategyFactory;
@@ -50,7 +50,7 @@ public EpollEventLoopGroup(int nThreads) {
      */
     @SuppressWarnings("deprecation")
     public EpollEventLoopGroup(int nThreads, SelectStrategyFactory selectStrategyFactory) {
-        this(nThreads, null, selectStrategyFactory);
+        this(nThreads, (ThreadFactory) null, selectStrategyFactory);
     }
 
     /**
@@ -61,6 +61,10 @@ public EpollEventLoopGroup(int nThreads, ThreadFactory threadFactory) {
         this(nThreads, threadFactory, 0);
     }
 
+    public EpollEventLoopGroup(int nThreads, Executor executor) {
+        this(nThreads, executor, DefaultSelectStrategyFactory.INSTANCE);
+    }
+
     /**
      * Create a new instance using the specified number of threads and the given {@link ThreadFactory}.
      */
@@ -93,12 +97,16 @@ public EpollEventLoopGroup(int nThreads, ThreadFactory threadFactory, int maxEve
         super(nThreads, threadFactory, maxEventsAtOnce, selectStrategyFactory);
     }
 
+    public EpollEventLoopGroup(int nThreads, Executor executor, SelectStrategyFactory selectStrategyFactory) {
+        super(nThreads, executor, 0, selectStrategyFactory);
+    }
+
     /**
      * Sets the percentage of the desired amount of time spent for I/O in the child event loops.  The default value is
      * {@code 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.
      */
     public void setIoRatio(int ioRatio) {
-        for (EventExecutor e: children()) {
+        for (EventExecutor e: this) {
             ((EpollEventLoop) e).setIoRatio(ioRatio);
         }
     }
diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
index e4ba4ce2a702..d9244314fb26 100644
--- a/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java
@@ -53,14 +53,16 @@
  */
 public final class Native {
     static {
-        String name = SystemPropertyUtil.get("os.name").toLowerCase(Locale.UK).trim();
-        if (!name.startsWith("linux")) {
-            throw new IllegalStateException("Only supported on Linux");
+        try {
+            // First, try calling a side-effect free JNI method to see if the library was already
+            // loaded by the application.
+            offsetofEpollData();
+        } catch (UnsatisfiedLinkError ignore) {
+            // The library was not previously loaded, load it now.
+            loadNativeLibrary();
         }
-        NativeLibraryLoader.load(SystemPropertyUtil.get("io.netty.packagePrefix", "").replace('.', '-') +
-                                 "netty-transport-native-epoll",
-                                 PlatformDependent.getClassLoader(Native.class));
     }
+
     // EventLoop operations and constants
     public static final int EPOLLIN = epollin();
     public static final int EPOLLOUT = epollout();
@@ -250,4 +252,13 @@ public static void setTcpMd5Sig(int fd, InetAddress address, byte[] key) throws
     private Native() {
         // utility
     }
+
+    private static void loadNativeLibrary() {
+        String name = SystemPropertyUtil.get("os.name").toLowerCase(Locale.UK).trim();
+        if (!name.startsWith("linux")) {
+            throw new IllegalStateException("Only supported on Linux");
+        }
+        NativeLibraryLoader.load(SystemPropertyUtil.get("io.netty.packagePrefix", "").replace('.', '-') +
+            "netty-transport-native-epoll", PlatformDependent.getClassLoader(Native.class));
+    }
 }
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketShutdownOutputByPeerTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketShutdownOutputByPeerTest.java
new file mode 100644
index 000000000000..5a7bdc1b93f1
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketShutdownOutputByPeerTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketShutdownOutputByPeerTest;
+
+import java.util.List;
+
+public class EpollSocketShutdownOutputByPeerTest extends SocketShutdownOutputByPeerTest {
+    @Override
+    protected List<TestsuitePermutation.BootstrapFactory<ServerBootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.serverSocket();
+    }
+}
diff --git a/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketShutdownOutputBySelfTest.java b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketShutdownOutputBySelfTest.java
new file mode 100644
index 000000000000..3ad80e472bdf
--- /dev/null
+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketShutdownOutputBySelfTest.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.epoll;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.testsuite.transport.TestsuitePermutation;
+import io.netty.testsuite.transport.socket.SocketShutdownOutputBySelfTest;
+
+import java.util.List;
+
+public class EpollSocketShutdownOutputBySelfTest extends SocketShutdownOutputBySelfTest {
+    @Override
+    protected List<TestsuitePermutation.BootstrapFactory<Bootstrap>> newFactories() {
+        return EpollSocketTestPermutation.INSTANCE.clientSocket();
+    }
+}
diff --git a/transport-rxtx/pom.xml b/transport-rxtx/pom.xml
index 575473f0298b..b1fb27146fda 100644
--- a/transport-rxtx/pom.xml
+++ b/transport-rxtx/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-transport-rxtx</artifactId>
diff --git a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java
index 07628a944aef..7ff98e06ef9a 100644
--- a/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java
+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java
@@ -18,6 +18,7 @@
 import gnu.io.CommPort;
 import gnu.io.CommPortIdentifier;
 import gnu.io.SerialPort;
+import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.oio.OioByteStreamChannel;
 import io.netty.util.internal.OneTimeTask;
@@ -25,7 +26,14 @@
 import java.net.SocketAddress;
 import java.util.concurrent.TimeUnit;
 
-import static io.netty.channel.rxtx.RxtxChannelOption.*;
+import static io.netty.channel.rxtx.RxtxChannelOption.BAUD_RATE;
+import static io.netty.channel.rxtx.RxtxChannelOption.DATA_BITS;
+import static io.netty.channel.rxtx.RxtxChannelOption.DTR;
+import static io.netty.channel.rxtx.RxtxChannelOption.PARITY_BIT;
+import static io.netty.channel.rxtx.RxtxChannelOption.READ_TIMEOUT;
+import static io.netty.channel.rxtx.RxtxChannelOption.RTS;
+import static io.netty.channel.rxtx.RxtxChannelOption.STOP_BITS;
+import static io.netty.channel.rxtx.RxtxChannelOption.WAIT_TIME;
 
 /**
  * A channel to a serial device using the RXTX library.
@@ -129,6 +137,16 @@ protected void doClose() throws Exception {
         }
     }
 
+    @Override
+    protected boolean isInputShutdown() {
+        return !open;
+    }
+
+    @Override
+    protected ChannelFuture shutdownInput() {
+        return newFailedFuture(new UnsupportedOperationException("shutdownInput"));
+    }
+
     private final class RxtxUnsafe extends AbstractUnsafe {
         @Override
         public void connect(
diff --git a/transport-sctp/pom.xml b/transport-sctp/pom.xml
index cb5fd1d3e307..492a6b45121c 100644
--- a/transport-sctp/pom.xml
+++ b/transport-sctp/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-transport-sctp</artifactId>
diff --git a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
index 436e47e38738..8d48e67131b1 100644
--- a/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java
@@ -150,19 +150,25 @@ public int hashCode() {
 
     @Override
     public SctpMessage copy() {
-        if (msgInfo == null) {
-            return new SctpMessage(protocolIdentifier, streamIdentifier, unordered, content().copy());
-        } else {
-            return new SctpMessage(msgInfo, content().copy());
-        }
+        return (SctpMessage) super.copy();
     }
 
     @Override
     public SctpMessage duplicate() {
+        return (SctpMessage) super.duplicate();
+    }
+
+    @Override
+    public SctpMessage retainedDuplicate() {
+        return (SctpMessage) super.retainedDuplicate();
+    }
+
+    @Override
+    public SctpMessage replace(ByteBuf content) {
         if (msgInfo == null) {
-            return new SctpMessage(protocolIdentifier, streamIdentifier, unordered, content().duplicate());
+            return new SctpMessage(protocolIdentifier, streamIdentifier, unordered, content);
         } else {
-            return new SctpMessage(msgInfo, content().duplicate());
+            return new SctpMessage(msgInfo, content);
         }
     }
 
diff --git a/transport-udt/pom.xml b/transport-udt/pom.xml
index 88f7efe6bef9..3aa586244b31 100644
--- a/transport-udt/pom.xml
+++ b/transport-udt/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-transport-udt</artifactId>
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java b/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
index d8662444beff..fc02a8d0b43b 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java
@@ -33,12 +33,22 @@ public UdtMessage(final ByteBuf data) {
 
     @Override
     public UdtMessage copy() {
-        return new UdtMessage(content().copy());
+        return (UdtMessage) super.copy();
     }
 
     @Override
     public UdtMessage duplicate() {
-        return new UdtMessage(content().duplicate());
+        return (UdtMessage) super.duplicate();
+    }
+
+    @Override
+    public UdtMessage retainedDuplicate() {
+        return (UdtMessage) super.retainedDuplicate();
+    }
+
+    @Override
+    public UdtMessage replace(ByteBuf content) {
+        return new UdtMessage(content);
     }
 
     @Override
diff --git a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
index 20adae249baf..62dbb9ffd7e0 100644
--- a/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java
@@ -17,10 +17,10 @@
 
 import com.barchart.udt.TypeUDT;
 import com.barchart.udt.nio.SocketChannelUDT;
-
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
+import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.FileRegion;
 import io.netty.channel.RecvByteBufAllocator;
@@ -34,7 +34,7 @@
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 
-import static java.nio.channels.SelectionKey.*;
+import static java.nio.channels.SelectionKey.OP_CONNECT;
 
 /**
  * Byte Channel Connector for UDT Streams.
@@ -149,6 +149,11 @@ protected int doWriteBytes(final ByteBuf byteBuf) throws Exception {
         return byteBuf.readBytes(javaChannel(), expectedWrittenBytes);
     }
 
+    @Override
+    protected ChannelFuture shutdownInput() {
+        return newFailedFuture(new UnsupportedOperationException("shutdownInput"));
+    }
+
     @Override
     protected long doWriteFileRegion(FileRegion region) throws Exception {
         throw new UnsupportedOperationException();
diff --git a/transport/pom.xml b/transport/pom.xml
index 6d365b72d33d..68cf9911c5ab 100644
--- a/transport/pom.xml
+++ b/transport/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>io.netty</groupId>
     <artifactId>netty-parent</artifactId>
-    <version>4.1.0.CR7</version>
+    <version>4.1.0.Final</version>
   </parent>
 
   <artifactId>netty-transport</artifactId>
diff --git a/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
index a10c0d0fc947..43b38fd4b440 100644
--- a/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java
@@ -35,6 +35,7 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -303,9 +304,10 @@ public void operationComplete(ChannelFuture future) throws Exception {
                     } else {
                         // Registration was successful, so set the correct executor to use.
                         // See https://github.com/netty/netty/issues/2586
-                        promise.executor = channel.eventLoop();
+                        promise.registered();
+
+                        doBind0(regFuture, channel, localAddress, promise);
                     }
-                    doBind0(regFuture, channel, localAddress, promise);
                 }
             });
             return promise;
@@ -313,7 +315,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     }
 
     final ChannelFuture initAndRegister() {
-        final Channel channel = channelFactory().newChannel();
+        final Channel channel = channelFactory.newChannel();
         try {
             init(channel);
         } catch (Throwable t) {
@@ -375,6 +377,41 @@ public B handler(ChannelHandler handler) {
         return (B) this;
     }
 
+    /**
+     * Returns the configured {@link EventLoopGroup} or {@code null} if non is configured yet.
+     *
+     * @deprecated Use {@link #config()} instead.
+     */
+    @Deprecated
+    public final EventLoopGroup group() {
+        return group;
+    }
+
+    /**
+     * Returns the {@link AbstractBootstrapConfig} object that can be used to obtain the current config
+     * of the bootstrap.
+     */
+    public abstract AbstractBootstrapConfig<B, C> config();
+
+    static <K, V> Map<K, V> copiedMap(Map<K, V> map) {
+        final Map<K, V> copied;
+        synchronized (map) {
+            if (map.isEmpty()) {
+                return Collections.emptyMap();
+            }
+            copied = new LinkedHashMap<K, V>(map);
+        }
+        return Collections.unmodifiableMap(copied);
+    }
+
+    final Map<ChannelOption<?>, Object> options0() {
+        return options;
+    }
+
+    final Map<AttributeKey<?>, Object> attrs0() {
+        return attrs;
+    }
+
     final SocketAddress localAddress() {
         return localAddress;
     }
@@ -388,86 +425,43 @@ final ChannelHandler handler() {
         return handler;
     }
 
-    /**
-     * Return the configured {@link EventLoopGroup} or {@code null} if non is configured yet.
-     */
-    public EventLoopGroup group() {
-        return group;
-    }
-
     final Map<ChannelOption<?>, Object> options() {
-        return options;
+        return copiedMap(options);
     }
 
     final Map<AttributeKey<?>, Object> attrs() {
-        return attrs;
+        return copiedMap(attrs);
     }
 
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder()
             .append(StringUtil.simpleClassName(this))
-            .append('(');
-        if (group != null) {
-            buf.append("group: ")
-               .append(StringUtil.simpleClassName(group))
-               .append(", ");
-        }
-        if (channelFactory != null) {
-            buf.append("channelFactory: ")
-               .append(channelFactory)
-               .append(", ");
-        }
-        if (localAddress != null) {
-            buf.append("localAddress: ")
-               .append(localAddress)
-               .append(", ");
-        }
-        synchronized (options) {
-            if (!options.isEmpty()) {
-                buf.append("options: ")
-                   .append(options)
-                   .append(", ");
-            }
-        }
-        synchronized (attrs) {
-            if (!attrs.isEmpty()) {
-                buf.append("attrs: ")
-                   .append(attrs)
-                   .append(", ");
-            }
-        }
-        if (handler != null) {
-            buf.append("handler: ")
-               .append(handler)
-               .append(", ");
-        }
-        if (buf.charAt(buf.length() - 1) == '(') {
-            buf.append(')');
-        } else {
-            buf.setCharAt(buf.length() - 2, ')');
-            buf.setLength(buf.length() - 1);
-        }
+            .append('(').append(config()).append(')');
         return buf.toString();
     }
 
-    private static final class PendingRegistrationPromise extends DefaultChannelPromise {
+    static final class PendingRegistrationPromise extends DefaultChannelPromise {
+
         // Is set to the correct EventExecutor once the registration was successful. Otherwise it will
         // stay null and so the GlobalEventExecutor.INSTANCE will be used for notifications.
-        private volatile EventExecutor executor;
+        private volatile boolean registered;
 
-        private PendingRegistrationPromise(Channel channel) {
+        PendingRegistrationPromise(Channel channel) {
             super(channel);
         }
 
+        void registered() {
+            registered = true;
+        }
+
         @Override
         protected EventExecutor executor() {
-            EventExecutor executor = this.executor;
-            if (executor != null) {
+            if (registered) {
                 // If the registration was a success executor is set.
                 //
                 // See https://github.com/netty/netty/issues/2586
-                return executor;
+                return super.executor();
             }
             // The registration failed so we can only use the GlobalEventExecutor as last resort to notify.
             return GlobalEventExecutor.INSTANCE;
diff --git a/transport/src/main/java/io/netty/bootstrap/AbstractBootstrapConfig.java b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrapConfig.java
new file mode 100644
index 000000000000..976ec94640b8
--- /dev/null
+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrapConfig.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.bootstrap;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.util.AttributeKey;
+import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.StringUtil;
+
+import java.net.SocketAddress;
+import java.util.Map;
+
+/**
+ * Exposes the configuration of an {@link AbstractBootstrap}.
+ */
+public abstract class AbstractBootstrapConfig<B extends AbstractBootstrap<B, C>, C extends Channel> {
+
+    protected final B bootstrap;
+
+    protected AbstractBootstrapConfig(B bootstrap) {
+        this.bootstrap = ObjectUtil.checkNotNull(bootstrap, "bootstrap");
+    }
+
+    /**
+     * Returns the configured local address or {@code null} if non is configured yet.
+     */
+    public final SocketAddress localAddress() {
+        return bootstrap.localAddress();
+    }
+
+    /**
+     * Returns the configured {@link ChannelFactory} or {@code null} if non is configured yet.
+     */
+    @SuppressWarnings("deprecation")
+    public final ChannelFactory<? extends C> channelFactory() {
+        return bootstrap.channelFactory();
+    }
+
+    /**
+     * Returns the configured {@link ChannelHandler} or {@code null} if non is configured yet.
+     */
+    public final ChannelHandler handler() {
+        return bootstrap.handler();
+    }
+
+    /**
+     * Returns a copy of the configured options.
+     */
+    public final Map<ChannelOption<?>, Object> options() {
+        return bootstrap.options();
+    }
+
+    /**
+     * Returns a copy of the configured attributes.
+     */
+    public final Map<AttributeKey<?>, Object> attrs() {
+        return bootstrap.attrs();
+    }
+
+    /**
+     * Returns the configured {@link EventLoopGroup} or {@code null} if non is configured yet.
+     */
+    @SuppressWarnings("deprecation")
+    public final EventLoopGroup group() {
+        return bootstrap.group();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder()
+                .append(StringUtil.simpleClassName(this))
+                .append('(');
+        EventLoopGroup group = group();
+        if (group != null) {
+            buf.append("group: ")
+                    .append(StringUtil.simpleClassName(group))
+                    .append(", ");
+        }
+        @SuppressWarnings("deprecation")
+        ChannelFactory<? extends C> factory = channelFactory();
+        if (factory != null) {
+            buf.append("channelFactory: ")
+                    .append(factory)
+                    .append(", ");
+        }
+        SocketAddress localAddress = localAddress();
+        if (localAddress != null) {
+            buf.append("localAddress: ")
+                    .append(localAddress)
+                    .append(", ");
+        }
+
+        Map<ChannelOption<?>, Object> options = options();
+        if (!options.isEmpty()) {
+            buf.append("options: ")
+                    .append(options)
+                    .append(", ");
+        }
+        Map<AttributeKey<?>, Object> attrs = attrs();
+        if (!attrs.isEmpty()) {
+            buf.append("attrs: ")
+                    .append(attrs)
+                    .append(", ");
+        }
+        ChannelHandler handler = handler();
+        if (handler != null) {
+            buf.append("handler: ")
+                    .append(handler)
+                    .append(", ");
+        }
+        if (buf.charAt(buf.length() - 1) == '(') {
+            buf.append(')');
+        } else {
+            buf.setCharAt(buf.length() - 2, ')');
+            buf.setLength(buf.length() - 1);
+        }
+        return buf.toString();
+    }
+}
diff --git a/transport/src/main/java/io/netty/bootstrap/Bootstrap.java b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java
index 0805b91d3832..00abf9e2fb28 100644
--- a/transport/src/main/java/io/netty/bootstrap/Bootstrap.java
+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java
@@ -53,6 +53,8 @@ public class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> {
 
     private static final AddressResolverGroup<?> DEFAULT_RESOLVER = DefaultAddressResolverGroup.INSTANCE;
 
+    private final BootstrapConfig config = new BootstrapConfig(this);
+
     @SuppressWarnings("unchecked")
     private volatile AddressResolverGroup<SocketAddress> resolver =
             (AddressResolverGroup<SocketAddress>) DEFAULT_RESOLVER;
@@ -113,7 +115,7 @@ public ChannelFuture connect() {
             throw new IllegalStateException("remoteAddress not set");
         }
 
-        return doResolveAndConnect(remoteAddress, localAddress());
+        return doResolveAndConnect(remoteAddress, config.localAddress());
     }
 
     /**
@@ -139,7 +141,7 @@ public ChannelFuture connect(SocketAddress remoteAddress) {
         }
 
         validate();
-        return doResolveAndConnect(remoteAddress, localAddress());
+        return doResolveAndConnect(remoteAddress, config.localAddress());
     }
 
     /**
@@ -156,72 +158,85 @@ public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAdd
     /**
      * @see {@link #connect()}
      */
-    private ChannelFuture doResolveAndConnect(SocketAddress remoteAddress, final SocketAddress localAddress) {
+    private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
         final ChannelFuture regFuture = initAndRegister();
-        if (regFuture.cause() != null) {
-            return regFuture;
+        final Channel channel = regFuture.channel();
+
+        if (regFuture.isDone()) {
+            if (!regFuture.isSuccess()) {
+                return regFuture;
+            }
+            return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());
+        } else {
+            // Registration future is almost always fulfilled already, but just in case it's not.
+            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
+            regFuture.addListener(new ChannelFutureListener() {
+                @Override
+                public void operationComplete(ChannelFuture future) throws Exception {
+                    // Direclty obtain the cause and do a null check so we only need one volatile read in case of a
+                    // failure.
+                    Throwable cause = future.cause();
+                    if (cause != null) {
+                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
+                        // IllegalStateException once we try to access the EventLoop of the Channel.
+                        promise.setFailure(cause);
+                    } else {
+                        // Registration was successful, so set the correct executor to use.
+                        // See https://github.com/netty/netty/issues/2586
+                        promise.registered();
+                        doResolveAndConnect0(channel, remoteAddress, localAddress, promise);
+                    }
+                }
+            });
+            return promise;
         }
+    }
 
-        final Channel channel = regFuture.channel();
+    private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,
+                                               final SocketAddress localAddress, final ChannelPromise promise) {
         final EventLoop eventLoop = channel.eventLoop();
         final AddressResolver<SocketAddress> resolver = this.resolver.getResolver(eventLoop);
 
         if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) {
             // Resolver has no idea about what to do with the specified remote address or it's resolved already.
-            return doConnect(remoteAddress, localAddress, regFuture, channel.newPromise());
+            doConnect(remoteAddress, localAddress, promise);
+            return promise;
         }
 
         final Future<SocketAddress> resolveFuture = resolver.resolve(remoteAddress);
-        final Throwable resolveFailureCause = resolveFuture.cause();
-
-        if (resolveFailureCause != null) {
-            // Failed to resolve immediately
-            channel.close();
-            return channel.newFailedFuture(resolveFailureCause);
-        }
 
         if (resolveFuture.isDone()) {
-            // Succeeded to resolve immediately; cached? (or did a blocking lookup)
-            return doConnect(resolveFuture.getNow(), localAddress, regFuture, channel.newPromise());
+            final Throwable resolveFailureCause = resolveFuture.cause();
+
+            if (resolveFailureCause != null) {
+                // Failed to resolve immediately
+                channel.close();
+                promise.setFailure(resolveFailureCause);
+            } else {
+                // Succeeded to resolve immediately; cached? (or did a blocking lookup)
+                doConnect(resolveFuture.getNow(), localAddress, promise);
+            }
+            return promise;
         }
 
         // Wait until the name resolution is finished.
-        final ChannelPromise connectPromise = channel.newPromise();
         resolveFuture.addListener(new FutureListener<SocketAddress>() {
             @Override
             public void operationComplete(Future<SocketAddress> future) throws Exception {
                 if (future.cause() != null) {
                     channel.close();
-                    connectPromise.setFailure(future.cause());
+                    promise.setFailure(future.cause());
                 } else {
-                    doConnect(future.getNow(), localAddress, regFuture, connectPromise);
+                    doConnect(future.getNow(), localAddress, promise);
                 }
             }
         });
 
-        return connectPromise;
+        return promise;
     }
 
-    private static ChannelFuture doConnect(
-            final SocketAddress remoteAddress, final SocketAddress localAddress,
-            final ChannelFuture regFuture, final ChannelPromise connectPromise) {
-        if (regFuture.isDone()) {
-            doConnect0(remoteAddress, localAddress, regFuture, connectPromise);
-        } else {
-            regFuture.addListener(new ChannelFutureListener() {
-                @Override
-                public void operationComplete(ChannelFuture future) throws Exception {
-                    doConnect0(remoteAddress, localAddress, regFuture, connectPromise);
-                }
-            });
-        }
-
-        return connectPromise;
-    }
-
-    private static void doConnect0(
-            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelFuture regFuture,
-            final ChannelPromise connectPromise) {
+    private static void doConnect(
+            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) {
 
         // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up
         // the pipeline in its channelRegistered() implementation.
@@ -229,16 +244,12 @@ private static void doConnect0(
         channel.eventLoop().execute(new OneTimeTask() {
             @Override
             public void run() {
-                if (regFuture.isSuccess()) {
-                    if (localAddress == null) {
-                        channel.connect(remoteAddress, connectPromise);
-                    } else {
-                        channel.connect(remoteAddress, localAddress, connectPromise);
-                    }
-                    connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
+                if (localAddress == null) {
+                    channel.connect(remoteAddress, connectPromise);
                 } else {
-                    connectPromise.setFailure(regFuture.cause());
+                    channel.connect(remoteAddress, localAddress, connectPromise);
                 }
+                connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
             }
         });
     }
@@ -247,9 +258,9 @@ public void run() {
     @SuppressWarnings("unchecked")
     void init(Channel channel) throws Exception {
         ChannelPipeline p = channel.pipeline();
-        p.addLast(handler());
+        p.addLast(config.handler());
 
-        final Map<ChannelOption<?>, Object> options = options();
+        final Map<ChannelOption<?>, Object> options = options0();
         synchronized (options) {
             for (Entry<ChannelOption<?>, Object> e: options.entrySet()) {
                 try {
@@ -262,7 +273,7 @@ void init(Channel channel) throws Exception {
             }
         }
 
-        final Map<AttributeKey<?>, Object> attrs = attrs();
+        final Map<AttributeKey<?>, Object> attrs = attrs0();
         synchronized (attrs) {
             for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {
                 channel.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());
@@ -273,7 +284,7 @@ void init(Channel channel) throws Exception {
     @Override
     public Bootstrap validate() {
         super.validate();
-        if (handler() == null) {
+        if (config.handler() == null) {
             throw new IllegalStateException("handler not set");
         }
         return this;
@@ -297,17 +308,15 @@ public Bootstrap clone(EventLoopGroup group) {
     }
 
     @Override
-    public String toString() {
-        if (remoteAddress == null) {
-            return super.toString();
-        }
+    public final BootstrapConfig config() {
+        return config;
+    }
 
-        StringBuilder buf = new StringBuilder(super.toString());
-        buf.setLength(buf.length() - 1);
+    final SocketAddress remoteAddress() {
+        return remoteAddress;
+    }
 
-        return buf.append(", remoteAddress: ")
-                  .append(remoteAddress)
-                  .append(')')
-                  .toString();
+    final AddressResolverGroup<?> resolver() {
+        return resolver;
     }
 }
diff --git a/transport/src/main/java/io/netty/bootstrap/BootstrapConfig.java b/transport/src/main/java/io/netty/bootstrap/BootstrapConfig.java
new file mode 100644
index 000000000000..24d9fa45e18f
--- /dev/null
+++ b/transport/src/main/java/io/netty/bootstrap/BootstrapConfig.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.bootstrap;
+
+import io.netty.channel.Channel;
+import io.netty.resolver.AddressResolverGroup;
+
+import java.net.SocketAddress;
+
+/**
+ * Exposes the configuration of a {@link Bootstrap}.
+ */
+public final class BootstrapConfig extends AbstractBootstrapConfig<Bootstrap, Channel> {
+
+    BootstrapConfig(Bootstrap bootstrap) {
+        super(bootstrap);
+    }
+
+    /**
+     * Returns the configured remote address or {@code null} if non is configured yet.
+     */
+    public SocketAddress remoteAddress() {
+        return bootstrap.remoteAddress();
+    }
+
+    /**
+     * Returns the configured {@link AddressResolverGroup} or the default if non is configured yet.
+     */
+    public AddressResolverGroup<?> resolver() {
+        return bootstrap.resolver();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder(super.toString());
+        buf.setLength(buf.length() - 1);
+        buf.append(", resolver: ").append(resolver());
+        SocketAddress remoteAddress = remoteAddress();
+        if (remoteAddress != null) {
+            buf.append(", remoteAddress: ")
+                    .append(remoteAddress);
+        }
+        return buf.append(')').toString();
+    }
+}
diff --git a/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
index 38929b1b71d3..822a1cd133d6 100644
--- a/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
+++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java
@@ -29,7 +29,6 @@
 import io.netty.channel.ServerChannel;
 import io.netty.util.AttributeKey;
 import io.netty.util.internal.OneTimeTask;
-import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
@@ -48,6 +47,7 @@ public class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, ServerCh
 
     private final Map<ChannelOption<?>, Object> childOptions = new LinkedHashMap<ChannelOption<?>, Object>();
     private final Map<AttributeKey<?>, Object> childAttrs = new LinkedHashMap<AttributeKey<?>, Object>();
+    private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);
     private volatile EventLoopGroup childGroup;
     private volatile ChannelHandler childHandler;
 
@@ -138,22 +138,14 @@ public ServerBootstrap childHandler(ChannelHandler childHandler) {
         return this;
     }
 
-    /**
-     * Return the configured {@link EventLoopGroup} which will be used for the child channels or {@code null}
-     * if non is configured yet.
-     */
-    public EventLoopGroup childGroup() {
-        return childGroup;
-    }
-
     @Override
     void init(Channel channel) throws Exception {
-        final Map<ChannelOption<?>, Object> options = options();
+        final Map<ChannelOption<?>, Object> options = options0();
         synchronized (options) {
             channel.config().setOptions(options);
         }
 
-        final Map<AttributeKey<?>, Object> attrs = attrs();
+        final Map<AttributeKey<?>, Object> attrs = attrs0();
         synchronized (attrs) {
             for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {
                 @SuppressWarnings("unchecked")
@@ -179,7 +171,7 @@ void init(Channel channel) throws Exception {
             @Override
             public void initChannel(Channel ch) throws Exception {
                 ChannelPipeline pipeline = ch.pipeline();
-                ChannelHandler handler = handler();
+                ChannelHandler handler = config.handler();
                 if (handler != null) {
                     pipeline.addLast(handler);
                 }
@@ -294,42 +286,31 @@ public ServerBootstrap clone() {
         return new ServerBootstrap(this);
     }
 
-    @Override
-    public String toString() {
-        StringBuilder buf = new StringBuilder(super.toString());
-        buf.setLength(buf.length() - 1);
-        buf.append(", ");
-        if (childGroup != null) {
-            buf.append("childGroup: ");
-            buf.append(StringUtil.simpleClassName(childGroup));
-            buf.append(", ");
-        }
-        synchronized (childOptions) {
-            if (!childOptions.isEmpty()) {
-                buf.append("childOptions: ");
-                buf.append(childOptions);
-                buf.append(", ");
-            }
-        }
-        synchronized (childAttrs) {
-            if (!childAttrs.isEmpty()) {
-                buf.append("childAttrs: ");
-                buf.append(childAttrs);
-                buf.append(", ");
-            }
-        }
-        if (childHandler != null) {
-            buf.append("childHandler: ");
-            buf.append(childHandler);
-            buf.append(", ");
-        }
-        if (buf.charAt(buf.length() - 1) == '(') {
-            buf.append(')');
-        } else {
-            buf.setCharAt(buf.length() - 2, ')');
-            buf.setLength(buf.length() - 1);
-        }
+    /**
+     * Return the configured {@link EventLoopGroup} which will be used for the child channels or {@code null}
+     * if non is configured yet.
+     *
+     * @deprecated Use {@link #config()} instead.
+     */
+    @Deprecated
+    public EventLoopGroup childGroup() {
+        return childGroup;
+    }
+
+    final ChannelHandler childHandler() {
+        return childHandler;
+    }
+
+    final Map<ChannelOption<?>, Object> childOptions() {
+        return copiedMap(childOptions);
+    }
+
+    final Map<AttributeKey<?>, Object> childAttrs() {
+        return copiedMap(childAttrs);
+    }
 
-        return buf.toString();
+    @Override
+    public final ServerBootstrapConfig config() {
+        return config;
     }
 }
diff --git a/transport/src/main/java/io/netty/bootstrap/ServerBootstrapConfig.java b/transport/src/main/java/io/netty/bootstrap/ServerBootstrapConfig.java
new file mode 100644
index 000000000000..1401d59eb335
--- /dev/null
+++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrapConfig.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.bootstrap;
+
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.EventLoopGroup;
+import io.netty.channel.ServerChannel;
+import io.netty.util.AttributeKey;
+import io.netty.util.internal.StringUtil;
+
+import java.util.Map;
+
+/**
+ * Exposes the configuration of a {@link ServerBootstrapConfig}.
+ */
+public final class ServerBootstrapConfig extends AbstractBootstrapConfig<ServerBootstrap, ServerChannel> {
+
+    ServerBootstrapConfig(ServerBootstrap bootstrap) {
+        super(bootstrap);
+    }
+
+    /**
+     * Returns the configured {@link EventLoopGroup} which will be used for the child channels or {@code null}
+     * if non is configured yet.
+     */
+    @SuppressWarnings("deprecation")
+    public EventLoopGroup childGroup() {
+        return bootstrap.childGroup();
+    }
+
+    /**
+     * Returns the configured {@link ChannelHandler} be used for the child channels or {@code null}
+     * if non is configured yet.
+     */
+    public ChannelHandler childHandler() {
+        return bootstrap.childHandler();
+    }
+
+    /**
+     * Returns a copy of the configured options which will be used for the child channels.
+     */
+    public Map<ChannelOption<?>, Object> childOptions() {
+        return bootstrap.childOptions();
+    }
+
+    /**
+     * Returns a copy of the configured attributes which will be used for the child channels.
+     */
+    public Map<AttributeKey<?>, Object> childAttrs() {
+        return bootstrap.childAttrs();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder(super.toString());
+        buf.setLength(buf.length() - 1);
+        buf.append(", ");
+        EventLoopGroup childGroup = childGroup();
+        if (childGroup != null) {
+            buf.append("childGroup: ");
+            buf.append(StringUtil.simpleClassName(childGroup));
+            buf.append(", ");
+        }
+        Map<ChannelOption<?>, Object> childOptions = childOptions();
+        if (!childOptions.isEmpty()) {
+            buf.append("childOptions: ");
+            buf.append(childOptions);
+            buf.append(", ");
+        }
+        Map<AttributeKey<?>, Object> childAttrs = childAttrs();
+        if (!childAttrs.isEmpty()) {
+            buf.append("childAttrs: ");
+            buf.append(childAttrs);
+            buf.append(", ");
+        }
+        ChannelHandler childHandler = childHandler();
+        if (childHandler != null) {
+            buf.append("childHandler: ");
+            buf.append(childHandler);
+            buf.append(", ");
+        }
+        if (buf.charAt(buf.length() - 1) == '(') {
+            buf.append(')');
+        } else {
+            buf.setCharAt(buf.length() - 2, ')');
+            buf.setLength(buf.length() - 1);
+        }
+
+        return buf.toString();
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/AbstractChannel.java b/transport/src/main/java/io/netty/channel/AbstractChannel.java
index 3c3cb8986c0c..a0d261205a9c 100644
--- a/transport/src/main/java/io/netty/channel/AbstractChannel.java
+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java
@@ -50,14 +50,10 @@ public abstract class AbstractChannel extends DefaultAttributeMap implements Cha
         NOT_YET_CONNECTED_EXCEPTION.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);
     }
 
-    private MessageSizeEstimator.Handle estimatorHandle;
-
     private final Channel parent;
     private final ChannelId id;
     private final Unsafe unsafe;
     private final DefaultChannelPipeline pipeline;
-    private final ChannelFuture succeededFuture = new SucceededChannelFuture(this, null);
-    private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);
     private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);
     private final CloseFuture closeFuture = new CloseFuture(this);
 
@@ -80,7 +76,7 @@ protected AbstractChannel(Channel parent) {
         this.parent = parent;
         id = newId();
         unsafe = newUnsafe();
-        pipeline = new DefaultChannelPipeline(this);
+        pipeline = newChannelPipeline();
     }
 
     /**
@@ -93,7 +89,7 @@ protected AbstractChannel(Channel parent, ChannelId id) {
         this.parent = parent;
         this.id = id;
         unsafe = newUnsafe();
-        pipeline = new DefaultChannelPipeline(this);
+        pipeline = newChannelPipeline();
     }
 
     @Override
@@ -109,6 +105,13 @@ protected ChannelId newId() {
         return DefaultChannelId.newInstance();
     }
 
+    /**
+     * Returns a new {@link DefaultChannelPipeline} instance.
+     */
+    protected DefaultChannelPipeline newChannelPipeline() {
+        return new DefaultChannelPipeline(this);
+    }
+
     @Override
     public boolean isWritable() {
         ChannelOutboundBuffer buf = unsafe.outboundBuffer();
@@ -293,22 +296,22 @@ public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
 
     @Override
     public ChannelPromise newPromise() {
-        return new DefaultChannelPromise(this);
+        return pipeline.newPromise();
     }
 
     @Override
     public ChannelProgressivePromise newProgressivePromise() {
-        return new DefaultChannelProgressivePromise(this);
+        return pipeline.newProgressivePromise();
     }
 
     @Override
     public ChannelFuture newSucceededFuture() {
-        return succeededFuture;
+        return pipeline.newSucceededFuture();
     }
 
     @Override
     public ChannelFuture newFailedFuture(Throwable cause) {
-        return new FailedChannelFuture(this, null, cause);
+        return pipeline.newFailedFuture(cause);
     }
 
     @Override
@@ -400,14 +403,7 @@ public String toString() {
 
     @Override
     public final ChannelPromise voidPromise() {
-        return voidPromise;
-    }
-
-    final MessageSizeEstimator.Handle estimatorHandle() {
-        if (estimatorHandle == null) {
-            estimatorHandle = config().getMessageSizeEstimator().newHandle();
-        }
-        return estimatorHandle;
+        return pipeline.voidPromise();
     }
 
     /**
@@ -433,11 +429,6 @@ public RecvByteBufAllocator.Handle recvBufAllocHandle() {
             return recvHandle;
         }
 
-        @Override
-        public final ChannelHandlerInvoker invoker() {
-            return eventLoop().asInvoker();
-        }
-
         @Override
         public final ChannelOutboundBuffer outboundBuffer() {
             return outboundBuffer;
@@ -503,12 +494,6 @@ private void register0(ChannelPromise promise) {
                 neverRegistered = false;
                 registered = true;
 
-                if (firstRegistration) {
-                    // We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers,
-                    // that were added before the registration was done.
-                    pipeline.callHandlerAddedForAllHandlers();
-                }
-
                 safeSetSuccess(promise);
                 pipeline.fireChannelRegistered();
                 // Only fire a channelActive if the channel has never been registered. This prevents firing
@@ -800,7 +785,7 @@ public final void write(Object msg, ChannelPromise promise) {
             int size;
             try {
                 msg = filterOutboundMessage(msg);
-                size = estimatorHandle().size(msg);
+                size = pipeline.estimatorHandle().size(msg);
                 if (size < 0) {
                     size = 0;
                 }
diff --git a/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
index 6bb2df1969b1..3c8cfafaf805 100644
--- a/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java
@@ -16,39 +16,65 @@
 package io.netty.channel;
 
 import io.netty.buffer.ByteBufAllocator;
+import io.netty.util.DefaultAttributeMap;
+import io.netty.util.ResourceLeakHint;
 import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
-import io.netty.util.ResourceLeakHint;
+import io.netty.util.Recycler;
+import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.OneTimeTask;
+import io.netty.util.internal.RecyclableMpscLinkedQueueNode;
 import io.netty.util.internal.StringUtil;
+import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.net.SocketAddress;
 
-abstract class AbstractChannelHandlerContext implements ChannelHandlerContext, ResourceLeakHint {
+abstract class AbstractChannelHandlerContext extends DefaultAttributeMap
+        implements ChannelHandlerContext, ResourceLeakHint {
 
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractChannelHandlerContext.class);
     volatile AbstractChannelHandlerContext next;
     volatile AbstractChannelHandlerContext prev;
 
+    /**
+     * {@link ChannelHandler#handlerAdded(ChannelHandlerContext)} was called.
+     */
+    private static final int ADDED = 1;
+    /**
+     * {@link ChannelHandler#handlerRemoved(ChannelHandlerContext)} was called.
+     */
+    private static final int REMOVED = 2;
+    /**
+     * Neither {@link ChannelHandler#handlerAdded(ChannelHandlerContext)}
+     * nor {@link ChannelHandler#handlerRemoved(ChannelHandlerContext)} was called.
+     */
+    private static final int INIT = 0;
+
     private final boolean inbound;
     private final boolean outbound;
     private final DefaultChannelPipeline pipeline;
     private final String name;
-    private boolean handlerRemoved;
 
-    final ChannelHandlerInvoker invoker;
+    // Will be set to null if no child executor should be used, otherwise it will be set to the
+    // child executor.
+    final EventExecutor executor;
     private ChannelFuture succeededFuture;
+    private int handlerState = INIT;
 
     // Lazily instantiated tasks used to trigger events to a handler with different executor.
     // These needs to be volatile as otherwise an other Thread may see an half initialized instance.
     // See the JMM for more details
-    volatile Runnable invokeChannelReadCompleteTask;
-    volatile Runnable invokeReadTask;
-    volatile Runnable invokeChannelWritableStateChangedTask;
-    volatile Runnable invokeFlushTask;
+    private volatile Runnable invokeChannelReadCompleteTask;
+    private volatile Runnable invokeReadTask;
+    private volatile Runnable invokeChannelWritableStateChangedTask;
+    private volatile Runnable invokeFlushTask;
 
-    AbstractChannelHandlerContext(
-            DefaultChannelPipeline pipeline, ChannelHandlerInvoker invoker,
-            String name, boolean inbound, boolean outbound) {
+    AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,
+                                  boolean inbound, boolean outbound) {
 
         if (name == null) {
             throw new NullPointerException("name");
@@ -56,8 +82,7 @@ abstract class AbstractChannelHandlerContext implements ChannelHandlerContext, R
 
         this.pipeline = pipeline;
         this.name = name;
-        this.invoker = invoker;
-
+        this.executor = executor;
         this.inbound = inbound;
         this.outbound = outbound;
     }
@@ -79,7 +104,11 @@ public ByteBufAllocator alloc() {
 
     @Override
     public EventExecutor executor() {
-        return invoker().executor();
+        if (executor == null) {
+            return channel().eventLoop();
+        } else {
+            return executor;
+        }
     }
 
     @Override
@@ -88,78 +117,316 @@ public String name() {
     }
 
     @Override
-    public <T> Attribute<T> attr(AttributeKey<T> key) {
-        return channel().attr(key);
+    public ChannelHandlerContext fireChannelRegistered() {
+        invokeChannelRegistered(findContextInbound());
+        return this;
     }
 
-    @Override
-    public <T> boolean hasAttr(AttributeKey<T> key) {
-        return channel().hasAttr(key);
+    static void invokeChannelRegistered(final AbstractChannelHandlerContext next) {
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeChannelRegistered();
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeChannelRegistered();
+                }
+            });
+        }
     }
 
-    @Override
-    public ChannelHandlerContext fireChannelRegistered() {
-        AbstractChannelHandlerContext next = findContextInbound();
-        next.invokeChannelRegistered();
-        return this;
+    private void invokeChannelRegistered() {
+        if (isAdded()) {
+            try {
+                ((ChannelInboundHandler) handler()).channelRegistered(this);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            fireChannelRegistered();
+        }
     }
 
     @Override
     public ChannelHandlerContext fireChannelUnregistered() {
-        AbstractChannelHandlerContext next = findContextInbound();
-        next.invokeChannelUnregistered();
+        invokeChannelUnregistered(findContextInbound());
         return this;
     }
 
+    static void invokeChannelUnregistered(final AbstractChannelHandlerContext next) {
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeChannelUnregistered();
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeChannelUnregistered();
+                }
+            });
+        }
+    }
+
+    private void invokeChannelUnregistered() {
+        if (isAdded()) {
+            try {
+                ((ChannelInboundHandler) handler()).channelUnregistered(this);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            fireChannelUnregistered();
+        }
+    }
+
     @Override
     public ChannelHandlerContext fireChannelActive() {
-        AbstractChannelHandlerContext next = findContextInbound();
-        next.invokeChannelActive();
+        final AbstractChannelHandlerContext next = findContextInbound();
+        invokeChannelActive(next);
         return this;
     }
 
+    static void invokeChannelActive(final AbstractChannelHandlerContext next) {
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeChannelActive();
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeChannelActive();
+                }
+            });
+        }
+    }
+
+    private void invokeChannelActive() {
+        if (isAdded()) {
+            try {
+                ((ChannelInboundHandler) handler()).channelActive(this);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            fireChannelActive();
+        }
+    }
+
     @Override
     public ChannelHandlerContext fireChannelInactive() {
-        AbstractChannelHandlerContext next = findContextInbound();
-        next.invokeChannelInactive();
+        invokeChannelInactive(findContextInbound());
         return this;
     }
 
+    static void invokeChannelInactive(final AbstractChannelHandlerContext next) {
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeChannelInactive();
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeChannelInactive();
+                }
+            });
+        }
+    }
+
+    private void invokeChannelInactive() {
+        if (isAdded()) {
+            try {
+                ((ChannelInboundHandler) handler()).channelInactive(this);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            fireChannelInactive();
+        }
+    }
+
     @Override
-    public ChannelHandlerContext fireExceptionCaught(Throwable cause) {
-        AbstractChannelHandlerContext next = this.next;
-        next.invokeExceptionCaught(cause);
+    public ChannelHandlerContext fireExceptionCaught(final Throwable cause) {
+        invokeExceptionCaught(next, cause);
         return this;
     }
 
+    static void invokeExceptionCaught(final AbstractChannelHandlerContext next, final Throwable cause) {
+        ObjectUtil.checkNotNull(cause, "cause");
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeExceptionCaught(cause);
+        } else {
+            try {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        next.invokeExceptionCaught(cause);
+                    }
+                });
+            } catch (Throwable t) {
+                if (logger.isWarnEnabled()) {
+                    logger.warn("Failed to submit an exceptionCaught() event.", t);
+                    logger.warn("The exceptionCaught() event that was failed to submit was:", cause);
+                }
+            }
+        }
+    }
+
+    private void invokeExceptionCaught(final Throwable cause) {
+        if (isAdded()) {
+            try {
+                handler().exceptionCaught(this, cause);
+            } catch (Throwable t) {
+                if (logger.isWarnEnabled()) {
+                    logger.warn(
+                            "An exception was thrown by a user handler's " +
+                                    "exceptionCaught() method while handling the following exception:", cause);
+                }
+            }
+        } else {
+            fireExceptionCaught(cause);
+        }
+    }
+
     @Override
-    public ChannelHandlerContext fireUserEventTriggered(Object event) {
-        AbstractChannelHandlerContext next = findContextInbound();
-        next.invokeUserEventTriggered(event);
+    public ChannelHandlerContext fireUserEventTriggered(final Object event) {
+        invokeUserEventTriggered(findContextInbound(), event);
         return this;
     }
 
+    static void invokeUserEventTriggered(final AbstractChannelHandlerContext next, final Object event) {
+        ObjectUtil.checkNotNull(event, "event");
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeUserEventTriggered(event);
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeUserEventTriggered(event);
+                }
+            });
+        }
+    }
+
+    private void invokeUserEventTriggered(Object event) {
+        if (isAdded()) {
+            try {
+                ((ChannelInboundHandler) handler()).userEventTriggered(this, event);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            fireUserEventTriggered(event);
+        }
+    }
+
     @Override
-    public ChannelHandlerContext fireChannelRead(Object msg) {
-        AbstractChannelHandlerContext next = findContextInbound();
-        next.invokeChannelRead(pipeline.touch(msg, next));
+    public ChannelHandlerContext fireChannelRead(final Object msg) {
+        invokeChannelRead(findContextInbound(), msg);
         return this;
     }
 
+    static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
+        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeChannelRead(m);
+        } else {
+            executor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeChannelRead(m);
+                }
+            });
+        }
+    }
+
+    private void invokeChannelRead(Object msg) {
+        if (isAdded()) {
+            try {
+                ((ChannelInboundHandler) handler()).channelRead(this, msg);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            fireChannelRead(msg);
+        }
+    }
+
     @Override
     public ChannelHandlerContext fireChannelReadComplete() {
-        AbstractChannelHandlerContext next = findContextInbound();
-        next.invokeChannelReadComplete();
+        invokeChannelReadComplete(findContextInbound());
         return this;
     }
 
+    static void invokeChannelReadComplete(final AbstractChannelHandlerContext next) {
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeChannelReadComplete();
+        } else {
+            Runnable task = next.invokeChannelReadCompleteTask;
+            if (task == null) {
+                next.invokeChannelReadCompleteTask = task = new Runnable() {
+                    @Override
+                    public void run() {
+                        next.invokeChannelReadComplete();
+                    }
+                };
+            }
+            executor.execute(task);
+        }
+    }
+
+    private void invokeChannelReadComplete() {
+        if (isAdded()) {
+            try {
+                ((ChannelInboundHandler) handler()).channelReadComplete(this);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            fireChannelReadComplete();
+        }
+    }
+
     @Override
     public ChannelHandlerContext fireChannelWritabilityChanged() {
-        AbstractChannelHandlerContext next = findContextInbound();
-        next.invokeChannelWritabilityChanged();
+        invokeChannelWritabilityChanged(findContextInbound());
         return this;
     }
 
+    static void invokeChannelWritabilityChanged(final AbstractChannelHandlerContext next) {
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeChannelWritabilityChanged();
+        } else {
+            Runnable task = next.invokeChannelWritableStateChangedTask;
+            if (task == null) {
+                next.invokeChannelWritableStateChangedTask = task = new Runnable() {
+                    @Override
+                    public void run() {
+                        next.invokeChannelWritabilityChanged();
+                    }
+                };
+            }
+            executor.execute(task);
+        }
+    }
+
+    private void invokeChannelWritabilityChanged() {
+        if (isAdded()) {
+            try {
+                ((ChannelInboundHandler) handler()).channelWritabilityChanged(this);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            fireChannelWritabilityChanged();
+        }
+    }
+
     @Override
     public ChannelFuture bind(SocketAddress localAddress) {
         return bind(localAddress, newPromise());
@@ -192,86 +459,406 @@ public ChannelFuture deregister() {
 
     @Override
     public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) {
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeBind(localAddress, promise);
+        if (localAddress == null) {
+            throw new NullPointerException("localAddress");
+        }
+        if (!validatePromise(promise, false)) {
+            // cancelled
+            return promise;
+        }
+
+        final AbstractChannelHandlerContext next = findContextOutbound();
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeBind(localAddress, promise);
+        } else {
+            safeExecute(executor, new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeBind(localAddress, promise);
+                }
+            }, promise, null);
+        }
         return promise;
     }
 
+    private void invokeBind(SocketAddress localAddress, ChannelPromise promise) {
+        if (isAdded()) {
+            try {
+                ((ChannelOutboundHandler) handler()).bind(this, localAddress, promise);
+            } catch (Throwable t) {
+                notifyOutboundHandlerException(t, promise);
+            }
+        } else {
+            bind(localAddress, promise);
+        }
+    }
+
     @Override
     public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
         return connect(remoteAddress, null, promise);
     }
 
     @Override
-    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeConnect(remoteAddress, localAddress, promise);
+    public ChannelFuture connect(
+            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
+
+        if (remoteAddress == null) {
+            throw new NullPointerException("remoteAddress");
+        }
+        if (!validatePromise(promise, false)) {
+            // cancelled
+            return promise;
+        }
+
+        final AbstractChannelHandlerContext next = findContextOutbound();
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeConnect(remoteAddress, localAddress, promise);
+        } else {
+            safeExecute(executor, new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeConnect(remoteAddress, localAddress, promise);
+                }
+            }, promise, null);
+        }
         return promise;
     }
 
+    private void invokeConnect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
+        if (isAdded()) {
+            try {
+                ((ChannelOutboundHandler) handler()).connect(this, remoteAddress, localAddress, promise);
+            } catch (Throwable t) {
+                notifyOutboundHandlerException(t, promise);
+            }
+        } else {
+            connect(remoteAddress, localAddress, promise);
+        }
+    }
+
     @Override
-    public ChannelFuture disconnect(ChannelPromise promise) {
-        if (!channel().metadata().hasDisconnect()) {
-            return close(promise);
+    public ChannelFuture disconnect(final ChannelPromise promise) {
+        if (!validatePromise(promise, false)) {
+            // cancelled
+            return promise;
         }
 
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeDisconnect(promise);
+        final AbstractChannelHandlerContext next = findContextOutbound();
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            // Translate disconnect to close if the channel has no notion of disconnect-reconnect.
+            // So far, UDP/IP is the only transport that has such behavior.
+            if (!channel().metadata().hasDisconnect()) {
+                next.invokeClose(promise);
+            } else {
+                next.invokeDisconnect(promise);
+            }
+        } else {
+            safeExecute(executor, new OneTimeTask() {
+                @Override
+                public void run() {
+                    if (!channel().metadata().hasDisconnect()) {
+                        next.invokeClose(promise);
+                    } else {
+                        next.invokeDisconnect(promise);
+                    }
+                }
+            }, promise, null);
+        }
         return promise;
     }
 
+    private void invokeDisconnect(ChannelPromise promise) {
+        if (isAdded()) {
+            try {
+                ((ChannelOutboundHandler) handler()).disconnect(this, promise);
+            } catch (Throwable t) {
+                notifyOutboundHandlerException(t, promise);
+            }
+        } else {
+            disconnect(promise);
+        }
+    }
+
     @Override
-    public ChannelFuture close(ChannelPromise promise) {
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeClose(promise);
+    public ChannelFuture close(final ChannelPromise promise) {
+        if (!validatePromise(promise, false)) {
+            // cancelled
+            return promise;
+        }
+
+        final AbstractChannelHandlerContext next = findContextOutbound();
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeClose(promise);
+        } else {
+            safeExecute(executor, new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeClose(promise);
+                }
+            }, promise, null);
+        }
+
         return promise;
     }
 
+    private void invokeClose(ChannelPromise promise) {
+        if (isAdded()) {
+            try {
+                ((ChannelOutboundHandler) handler()).close(this, promise);
+            } catch (Throwable t) {
+                notifyOutboundHandlerException(t, promise);
+            }
+        } else {
+            close(promise);
+        }
+    }
+
     @Override
-    public ChannelFuture deregister(ChannelPromise promise) {
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeDeregister(promise);
+    public ChannelFuture deregister(final ChannelPromise promise) {
+        if (!validatePromise(promise, false)) {
+            // cancelled
+            return promise;
+        }
+
+        final AbstractChannelHandlerContext next = findContextOutbound();
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeDeregister(promise);
+        } else {
+            safeExecute(executor, new OneTimeTask() {
+                @Override
+                public void run() {
+                    next.invokeDeregister(promise);
+                }
+            }, promise, null);
+        }
+
         return promise;
     }
 
+    private void invokeDeregister(ChannelPromise promise) {
+        if (isAdded()) {
+            try {
+                ((ChannelOutboundHandler) handler()).deregister(this, promise);
+            } catch (Throwable t) {
+                notifyOutboundHandlerException(t, promise);
+            }
+        } else {
+            deregister(promise);
+        }
+    }
+
     @Override
     public ChannelHandlerContext read() {
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeRead();
+        final AbstractChannelHandlerContext next = findContextOutbound();
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeRead();
+        } else {
+            Runnable task = next.invokeReadTask;
+            if (task == null) {
+                next.invokeReadTask = task = new Runnable() {
+                    @Override
+                    public void run() {
+                        next.invokeRead();
+                    }
+                };
+            }
+            executor.execute(task);
+        }
+
         return this;
     }
 
+    private void invokeRead() {
+        if (isAdded()) {
+            try {
+                ((ChannelOutboundHandler) handler()).read(this);
+            } catch (Throwable t) {
+                notifyHandlerException(t);
+            }
+        } else {
+            read();
+        }
+    }
+
     @Override
     public ChannelFuture write(Object msg) {
         return write(msg, newPromise());
     }
 
     @Override
-    public ChannelFuture write(Object msg, ChannelPromise promise) {
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeWrite(pipeline.touch(msg, next), promise);
+    public ChannelFuture write(final Object msg, final ChannelPromise promise) {
+        if (msg == null) {
+            throw new NullPointerException("msg");
+        }
+
+        try {
+            if (!validatePromise(promise, true)) {
+                ReferenceCountUtil.release(msg);
+                // cancelled
+                return promise;
+            }
+        } catch (RuntimeException e) {
+            ReferenceCountUtil.release(msg);
+            throw e;
+        }
+        write(msg, false, promise);
+
         return promise;
     }
 
+    private void invokeWrite(Object msg, ChannelPromise promise) {
+        if (isAdded()) {
+            invokeWrite0(msg, promise);
+        } else {
+            write(msg, promise);
+        }
+    }
+
+    private void invokeWrite0(Object msg, ChannelPromise promise) {
+        try {
+            ((ChannelOutboundHandler) handler()).write(this, msg, promise);
+        } catch (Throwable t) {
+            notifyOutboundHandlerException(t, promise);
+        }
+    }
+
     @Override
     public ChannelHandlerContext flush() {
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeFlush();
+        final AbstractChannelHandlerContext next = findContextOutbound();
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            next.invokeFlush();
+        } else {
+            Runnable task = next.invokeFlushTask;
+            if (task == null) {
+                next.invokeFlushTask = task = new Runnable() {
+                    @Override
+                    public void run() {
+                        next.invokeFlush();
+                    }
+                };
+            }
+            safeExecute(executor, task, channel().voidPromise(), null);
+        }
+
         return this;
     }
 
+    private void invokeFlush() {
+        if (isAdded()) {
+            invokeFlush0();
+        } else {
+            flush();
+        }
+    }
+
+    private void invokeFlush0() {
+        try {
+            ((ChannelOutboundHandler) handler()).flush(this);
+        } catch (Throwable t) {
+            notifyHandlerException(t);
+        }
+    }
+
     @Override
     public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
-        AbstractChannelHandlerContext next = findContextOutbound();
-        next.invokeWriteAndFlush(pipeline.touch(msg, next), promise);
+        if (msg == null) {
+            throw new NullPointerException("msg");
+        }
+
+        if (!validatePromise(promise, true)) {
+            ReferenceCountUtil.release(msg);
+            // cancelled
+            return promise;
+        }
+
+        write(msg, true, promise);
+
         return promise;
     }
 
+    private void invokeWriteAndFlush(Object msg, ChannelPromise promise) {
+        if (isAdded()) {
+            invokeWrite0(msg, promise);
+            invokeFlush0();
+        } else {
+            writeAndFlush(msg, promise);
+        }
+    }
+
+    private void write(Object msg, boolean flush, ChannelPromise promise) {
+        AbstractChannelHandlerContext next = findContextOutbound();
+        final Object m = pipeline.touch(msg, next);
+        EventExecutor executor = next.executor();
+        if (executor.inEventLoop()) {
+            if (flush) {
+                next.invokeWriteAndFlush(m, promise);
+            } else {
+                next.invokeWrite(m, promise);
+            }
+        } else {
+            AbstractWriteTask task;
+            if (flush) {
+                task = WriteAndFlushTask.newInstance(next, m, promise);
+            }  else {
+                task = WriteTask.newInstance(next, m, promise);
+            }
+            safeExecute(executor, task, promise, m);
+        }
+    }
+
     @Override
     public ChannelFuture writeAndFlush(Object msg) {
         return writeAndFlush(msg, newPromise());
     }
 
+    private static void notifyOutboundHandlerException(Throwable cause, ChannelPromise promise) {
+        if (!promise.tryFailure(cause) && !(promise instanceof VoidChannelPromise)) {
+            if (logger.isWarnEnabled()) {
+                logger.warn("Failed to fail the promise because it's done already: {}", promise, cause);
+            }
+        }
+    }
+
+    private void notifyHandlerException(Throwable cause) {
+        if (inExceptionCaught(cause)) {
+            if (logger.isWarnEnabled()) {
+                logger.warn(
+                        "An exception was thrown by a user handler " +
+                                "while handling an exceptionCaught event", cause);
+            }
+            return;
+        }
+
+        invokeExceptionCaught(cause);
+    }
+
+    private static boolean inExceptionCaught(Throwable cause) {
+        do {
+            StackTraceElement[] trace = cause.getStackTrace();
+            if (trace != null) {
+                for (StackTraceElement t : trace) {
+                    if (t == null) {
+                        break;
+                    }
+                    if ("exceptionCaught".equals(t.getMethodName())) {
+                        return true;
+                    }
+                }
+            }
+
+            cause = cause.getCause();
+        } while (cause != null);
+
+        return false;
+    }
+
     @Override
     public ChannelPromise newPromise() {
         return new DefaultChannelPromise(channel(), executor());
@@ -296,6 +883,43 @@ public ChannelFuture newFailedFuture(Throwable cause) {
         return new FailedChannelFuture(channel(), executor(), cause);
     }
 
+    private boolean validatePromise(ChannelPromise promise, boolean allowVoidPromise) {
+        if (promise == null) {
+            throw new NullPointerException("promise");
+        }
+
+        if (promise.isDone()) {
+            // Check if the promise was cancelled and if so signal that the processing of the operation
+            // should not be performed.
+            //
+            // See https://github.com/netty/netty/issues/2349
+            if (promise.isCancelled()) {
+                return false;
+            }
+            throw new IllegalArgumentException("promise already done: " + promise);
+        }
+
+        if (promise.channel() != channel()) {
+            throw new IllegalArgumentException(String.format(
+                    "promise.channel does not match: %s (expected: %s)", promise.channel(), channel()));
+        }
+
+        if (promise.getClass() == DefaultChannelPromise.class) {
+            return true;
+        }
+
+        if (!allowVoidPromise && promise instanceof VoidChannelPromise) {
+            throw new IllegalArgumentException(
+                    StringUtil.simpleClassName(VoidChannelPromise.class) + " not allowed for this operation");
+        }
+
+        if (promise instanceof AbstractChannel.CloseFuture) {
+            throw new IllegalArgumentException(
+                    StringUtil.simpleClassName(AbstractChannel.CloseFuture.class) + " not allowed in a pipeline");
+        }
+        return true;
+    }
+
     private AbstractChannelHandlerContext findContextInbound() {
         AbstractChannelHandlerContext ctx = this;
         do {
@@ -317,102 +941,176 @@ public ChannelPromise voidPromise() {
         return channel().voidPromise();
     }
 
-    void setRemoved() {
-        handlerRemoved = true;
+    final void setRemoved() {
+        handlerState = REMOVED;
     }
 
-    @Override
-    public boolean isRemoved() {
-        return handlerRemoved;
+    final void setAdded() {
+        handlerState = ADDED;
     }
 
-    final void invokeChannelRegistered() {
-        invoker().invokeChannelRegistered(this);
+    /**
+     * Makes best possible effort to detect if {@link ChannelHandler#handlerAdded(ChannelHandlerContext)} was called
+     * yet. If not return {@code false} and if called or could not detect return {@code true}.
+     *
+     * If this method returns {@code true} we will not invoke the {@link ChannelHandler} but just forward the event.
+     * This is needed as {@link DefaultChannelPipeline} may already put the {@link ChannelHandler} in the linked-list
+     * but not called {@link }
+     */
+    private boolean isAdded() {
+        return handlerState == ADDED;
     }
 
-    final void invokeChannelUnregistered() {
-        invoker().invokeChannelUnregistered(this);
+    @Override
+    public boolean isRemoved() {
+        return handlerState == REMOVED;
     }
 
-    final void invokeChannelActive() {
-        invoker().invokeChannelActive(this);
+    @Override
+    public <T> Attribute<T> attr(AttributeKey<T> key) {
+        return channel().attr(key);
     }
 
-    final void invokeChannelInactive() {
-        invoker().invokeChannelInactive(this);
+    @Override
+    public <T> boolean hasAttr(AttributeKey<T> key) {
+        return channel().hasAttr(key);
     }
 
-    final void invokeExceptionCaught(final Throwable cause) {
-        invoker().invokeExceptionCaught(this, cause);
+    private static void safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg) {
+        try {
+            executor.execute(runnable);
+        } catch (Throwable cause) {
+            try {
+                promise.setFailure(cause);
+            } finally {
+                if (msg != null) {
+                    ReferenceCountUtil.release(msg);
+                }
+            }
+        }
     }
 
-    final void invokeUserEventTriggered(final Object event) {
-        invoker().invokeUserEventTriggered(this, event);
+    @Override
+    public String toHintString() {
+        return '\'' + name + "' will handle the message from this point.";
     }
 
-    final void invokeChannelRead(final Object msg) {
-        invoker().invokeChannelRead(this, msg);
+    @Override
+    public String toString() {
+        return StringUtil.simpleClassName(ChannelHandlerContext.class) + '(' + name + ", " + channel() + ')';
     }
 
-    final void invokeChannelReadComplete() {
-        invoker().invokeChannelReadComplete(this);
-    }
+    abstract static class AbstractWriteTask extends RecyclableMpscLinkedQueueNode<Runnable> implements Runnable {
 
-    final void invokeChannelWritabilityChanged() {
-        invoker().invokeChannelWritabilityChanged(this);
-    }
+        private static final boolean ESTIMATE_TASK_SIZE_ON_SUBMIT =
+                SystemPropertyUtil.getBoolean("io.netty.transport.estimateSizeOnSubmit", true);
 
-    final void invokeBind(final SocketAddress localAddress, final ChannelPromise promise) {
-        invoker().invokeBind(this, localAddress, promise);
-    }
+        // Assuming a 64-bit JVM, 16 bytes object header, 3 reference fields and one int field, plus alignment
+        private static final int WRITE_TASK_OVERHEAD =
+                SystemPropertyUtil.getInt("io.netty.transport.writeTaskSizeOverhead", 48);
 
-    final void invokeConnect(final SocketAddress remoteAddress,
-                              final SocketAddress localAddress, final ChannelPromise promise) {
-        invoker().invokeConnect(this, remoteAddress, localAddress, promise);
-    }
+        private AbstractChannelHandlerContext ctx;
+        private Object msg;
+        private ChannelPromise promise;
+        private int size;
 
-    final void invokeDisconnect(final ChannelPromise promise) {
-        invoker().invokeDisconnect(this, promise);
-    }
+        private AbstractWriteTask(Recycler.Handle<? extends AbstractWriteTask> handle) {
+            super(handle);
+        }
 
-    final void invokeClose(final ChannelPromise promise) {
-        invoker().invokeClose(this, promise);
-    }
+        protected static void init(AbstractWriteTask task, AbstractChannelHandlerContext ctx,
+                                   Object msg, ChannelPromise promise) {
+            task.ctx = ctx;
+            task.msg = msg;
+            task.promise = promise;
+
+            if (ESTIMATE_TASK_SIZE_ON_SUBMIT) {
+                ChannelOutboundBuffer buffer = ctx.channel().unsafe().outboundBuffer();
+
+                // Check for null as it may be set to null if the channel is closed already
+                if (buffer != null) {
+                    task.size = ctx.pipeline.estimatorHandle().size(msg) + WRITE_TASK_OVERHEAD;
+                    buffer.incrementPendingOutboundBytes(task.size);
+                } else {
+                    task.size = 0;
+                }
+            } else {
+                task.size = 0;
+            }
+        }
 
-    final void invokeDeregister(final ChannelPromise promise) {
-        invoker().invokeDeregister(this, promise);
-    }
+        @Override
+        public final void run() {
+            try {
+                ChannelOutboundBuffer buffer = ctx.channel().unsafe().outboundBuffer();
+                // Check for null as it may be set to null if the channel is closed already
+                if (ESTIMATE_TASK_SIZE_ON_SUBMIT && buffer != null) {
+                    buffer.decrementPendingOutboundBytes(size);
+                }
+                write(ctx, msg, promise);
+            } finally {
+                // Set to null so the GC can collect them directly
+                ctx = null;
+                msg = null;
+                promise = null;
+            }
+        }
 
-    final void invokeRead() {
-        invoker().invokeRead(this);
-    }
+        @Override
+        public Runnable value() {
+            return this;
+        }
 
-    final void invokeWrite(final Object msg, final ChannelPromise promise) {
-        invoker().invokeWrite(this, msg, promise);
+        protected void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+            ctx.invokeWrite(msg, promise);
+        }
     }
 
-    final void invokeFlush() {
-        invoker().invokeFlush(this);
-    }
+    static final class WriteTask extends AbstractWriteTask implements SingleThreadEventLoop.NonWakeupRunnable {
 
-    final void invokeWriteAndFlush(final Object msg, final ChannelPromise promise) {
-        final ChannelHandlerInvoker invoker = invoker();
-        invoker.invokeWrite(this, msg, promise);
-        invoker.invokeFlush(this);
-    }
+        private static final Recycler<WriteTask> RECYCLER = new Recycler<WriteTask>() {
+            @Override
+            protected WriteTask newObject(Handle<WriteTask> handle) {
+                return new WriteTask(handle);
+            }
+        };
 
-    @Override
-    public ChannelHandlerInvoker invoker() {
-        return invoker == null ? channel().unsafe().invoker() : invoker;
-    }
+        private static WriteTask newInstance(
+                AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+            WriteTask task = RECYCLER.get();
+            init(task, ctx, msg, promise);
+            return task;
+        }
 
-    @Override
-    public String toHintString() {
-        return '\'' + name + "' will handle the message from this point.";
+        private WriteTask(Recycler.Handle<WriteTask> handle) {
+            super(handle);
+        }
     }
 
-    @Override
-    public String toString() {
-        return StringUtil.simpleClassName(ChannelHandlerContext.class) + '(' + name + ", " + channel() + ')';
+    static final class WriteAndFlushTask extends AbstractWriteTask {
+
+        private static final Recycler<WriteAndFlushTask> RECYCLER = new Recycler<WriteAndFlushTask>() {
+            @Override
+            protected WriteAndFlushTask newObject(Handle<WriteAndFlushTask> handle) {
+                return new WriteAndFlushTask(handle);
+            }
+        };
+
+        private static WriteAndFlushTask newInstance(
+                AbstractChannelHandlerContext ctx, Object msg,  ChannelPromise promise) {
+            WriteAndFlushTask task = RECYCLER.get();
+            init(task, ctx, msg, promise);
+            return task;
+        }
+
+        private WriteAndFlushTask(Recycler.Handle<WriteAndFlushTask> handle) {
+            super(handle);
+        }
+
+        @Override
+        public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
+            super.write(ctx, msg, promise);
+            ctx.invokeFlush();
+        }
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/Channel.java b/transport/src/main/java/io/netty/channel/Channel.java
index 5f4f0405e7c3..5d7e2bfb7b2b 100644
--- a/transport/src/main/java/io/netty/channel/Channel.java
+++ b/transport/src/main/java/io/netty/channel/Channel.java
@@ -77,7 +77,7 @@
  * resources once you are done with the {@link Channel}. This ensures all resources are
  * released in a proper way, i.e. filehandles.
  */
-public interface Channel extends AttributeMap, Comparable<Channel> {
+public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparable<Channel> {
 
     /**
      * Returns the globally unique identifier of this {@link Channel}.
@@ -190,252 +190,12 @@ public interface Channel extends AttributeMap, Comparable<Channel> {
      */
     ByteBufAllocator alloc();
 
-    /**
-     * Return a new {@link ChannelPromise}.
-     */
-    ChannelPromise newPromise();
-
-    /**
-     * Return an new {@link ChannelProgressivePromise}.
-     */
-    ChannelProgressivePromise newProgressivePromise();
-
-    /**
-     * Create a new {@link ChannelFuture} which is marked as succeeded already. So {@link ChannelFuture#isSuccess()}
-     * will return {@code true}. All {@link FutureListener} added to it will be notified directly. Also
-     * every call of blocking methods will just return without blocking.
-     */
-    ChannelFuture newSucceededFuture();
-
-    /**
-     * Create a new {@link ChannelFuture} which is marked as failed already. So {@link ChannelFuture#isSuccess()}
-     * will return {@code false}. All {@link FutureListener} added to it will be notified directly. Also
-     * every call of blocking methods will just return without blocking.
-     */
-    ChannelFuture newFailedFuture(Throwable cause);
-
-    /**
-     * Return a special ChannelPromise which can be reused for different operations.
-     * <p>
-     * It's only supported to use
-     * it for {@link Channel#write(Object, ChannelPromise)}.
-     * </p>
-     * <p>
-     * Be aware that the returned {@link ChannelPromise} will not support most operations and should only be used
-     * if you want to save an object allocation for every write operation. You will not be able to detect if the
-     * operation  was complete, only if it failed as the implementation will call
-     * {@link ChannelPipeline#fireExceptionCaught(Throwable)} in this case.
-     * </p>
-     * <strong>Be aware this is an expert feature and should be used with care!</strong>
-     */
-    ChannelPromise voidPromise();
-
-    /**
-     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture bind(SocketAddress localAddress);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     * <p>
-     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with
-     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}
-     * will be used.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);
-
-    /**
-     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture disconnect();
-
-    /**
-     * Request to close this {@link Channel} and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of
-     * an error.
-     *
-     * After it is closed it is not possible to reuse it again.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture close();
-
-    /**
-     * Request to deregister this {@link Channel} from the previous assigned {@link EventExecutor} and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     *
-     */
-    ChannelFuture deregister();
-
-    /**
-     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelFuture} will be notified.
-     *
-     * <p>
-     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with
-     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}
-     * will be used.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     *
-     * The given {@link ChannelPromise} will be notified and also returned.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
-
-    /**
-     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture disconnect(ChannelPromise promise);
-
-    /**
-     * Request to close this {@link Channel} and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of
-     * an error.
-     *
-     * After it is closed it is not possible to reuse it again.
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture close(ChannelPromise promise);
-
-    /**
-     * Request to deregister this {@link Channel} from the previous assigned {@link EventExecutor} and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture deregister(ChannelPromise promise);
-
-    /**
-     * Request to Read data from the {@link Channel} into the first inbound buffer, triggers an
-     * {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)} event if data was
-     * read, and triggers a
-     * {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext) channelReadComplete} event so the
-     * handler can decide to continue reading.  If there's a pending read operation already, this method does nothing.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#read(ChannelHandlerContext)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     Channel read();
 
-    /**
-     * Request to write a message via this {@link Channel} through the {@link ChannelPipeline}.
-     * This method will not request to actual flush, so be sure to call {@link #flush()}
-     * once you want to request to flush all pending data to the actual transport.
-     */
-    ChannelFuture write(Object msg);
-
-    /**
-     * Request to write a message via this {@link Channel} through the {@link ChannelPipeline}.
-     * This method will not request to actual flush, so be sure to call {@link #flush()}
-     * once you want to request to flush all pending data to the actual transport.
-     */
-    ChannelFuture write(Object msg, ChannelPromise promise);
-
-    /**
-     * Request to flush all pending messages.
-     */
+    @Override
     Channel flush();
 
-    /**
-     * Shortcut for call {@link #write(Object, ChannelPromise)} and {@link #flush()}.
-     */
-    ChannelFuture writeAndFlush(Object msg, ChannelPromise promise);
-
-    /**
-     * Shortcut for call {@link #write(Object)} and {@link #flush()}.
-     */
-    ChannelFuture writeAndFlush(Object msg);
-
     /**
      * <em>Unsafe</em> operations that should <em>never</em> be called from user-code. These methods
      * are only provided to implement the actual transport, and must be invoked from an I/O thread except for the
@@ -458,11 +218,6 @@ interface Unsafe {
          */
         RecvByteBufAllocator.Handle recvBufAllocHandle();
 
-        /**
-         * Returns the {@link ChannelHandlerInvoker} which is used by default unless specified by a user.
-         */
-        ChannelHandlerInvoker invoker();
-
         /**
          * Return the {@link SocketAddress} to which is bound local or
          * {@code null} if none.
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
index 0fdb8476ad77..859b48956091 100644
--- a/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java
@@ -17,13 +17,11 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
+import io.netty.util.Attribute;
 import io.netty.util.AttributeKey;
 import io.netty.util.AttributeMap;
 import io.netty.util.concurrent.EventExecutor;
-import io.netty.util.concurrent.FutureListener;
 
-import java.net.ConnectException;
-import java.net.SocketAddress;
 import java.nio.channels.Channels;
 
 /**
@@ -124,7 +122,7 @@
  * what fundamental differences they have, how they flow in a  pipeline,  and how to handle
  * the operation in your application.
  */
-public interface ChannelHandlerContext extends AttributeMap {
+public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker {
 
     /**
      * Return the {@link Channel} which is bound to the {@link ChannelHandlerContext}.
@@ -136,14 +134,6 @@ public interface ChannelHandlerContext extends AttributeMap {
      */
     EventExecutor executor();
 
-    /**
-     * Returns the {@link ChannelHandlerInvoker} which is used to trigger an event for the associated
-     * {@link ChannelHandler}. Note that the methods in {@link ChannelHandlerInvoker} are not intended to be called
-     * by a user. Use this method only to obtain the reference to the {@link ChannelHandlerInvoker}
-     * (and not calling its methods) unless you know what you are doing.
-     */
-    ChannelHandlerInvoker invoker();
-
     /**
      * The unique name of the {@link ChannelHandlerContext}.The name was used when then {@link ChannelHandler}
      * was added to the {@link ChannelPipeline}. This name can also be used to access the registered
@@ -163,287 +153,39 @@ public interface ChannelHandlerContext extends AttributeMap {
      */
     boolean isRemoved();
 
-    /**
-     * A {@link Channel} was registered to its {@link EventLoop}.
-     *
-     * This will result in having the {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)} method
-     * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelHandlerContext fireChannelRegistered();
 
-    /**
-     * A {@link Channel} was unregistered from its {@link EventLoop}.
-     *
-     * This will result in having the {@link ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)} method
-     * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelHandlerContext fireChannelUnregistered();
 
-    /**
-     * A {@link Channel} is active now, which means it is connected.
-     *
-     * This will result in having the {@link ChannelInboundHandler#channelActive(ChannelHandlerContext)} method
-     * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelHandlerContext fireChannelActive();
 
-    /**
-     * A {@link Channel} is inactive now, which means it is closed.
-     *
-     * This will result in having the {@link ChannelInboundHandler#channelInactive(ChannelHandlerContext)} method
-     * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelHandlerContext fireChannelInactive();
 
-    /**
-     * A {@link Channel} received an {@link Throwable} in one of its inbound operations.
-     *
-     * This will result in having the {@link ChannelInboundHandler#exceptionCaught(ChannelHandlerContext, Throwable)}
-     * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelHandlerContext fireExceptionCaught(Throwable cause);
 
-    /**
-     * A {@link Channel} received an user defined event.
-     *
-     * This will result in having the {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}
-     * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelHandlerContext fireUserEventTriggered(Object event);
 
-    /**
-     * A {@link Channel} received a message.
-     *
-     * This will result in having the {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)}
-     * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelHandlerContext fireChannelRead(Object msg);
 
-    /**
-     * Triggers an {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}
-     * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
-     */
+    @Override
     ChannelHandlerContext fireChannelReadComplete();
 
-    /**
-     * Triggers an {@link ChannelInboundHandler#channelWritabilityChanged(ChannelHandlerContext)}
-     * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
-     */
+    @Override
     ChannelHandlerContext fireChannelWritabilityChanged();
 
-    /**
-     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture bind(SocketAddress localAddress);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     * <p>
-     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with
-     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}
-     * will be used.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);
-
-    /**
-     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture disconnect();
-
-    /**
-     * Request to close the {@link Channel} and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of
-     * an error.
-     *
-     * After it is closed it is not possible to reuse it again.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture close();
-
-    /**
-     * Request to deregister from the previous assigned {@link EventExecutor} and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     *
-     */
-    ChannelFuture deregister();
-
-    /**
-     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelFuture} will be notified.
-     *
-     * <p>
-     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with
-     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}
-     * will be used.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     *
-     * The given {@link ChannelPromise} will be notified and also returned.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
-
-    /**
-     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture disconnect(ChannelPromise promise);
-
-    /**
-     * Request to close the {@link Channel} and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of
-     * an error.
-     *
-     * After it is closed it is not possible to reuse it again.
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture close(ChannelPromise promise);
-
-    /**
-     * Request to deregister from the previous assigned {@link EventExecutor} and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture deregister(ChannelPromise promise);
-
-    /**
-     * Request to Read data from the {@link Channel} into the first inbound buffer, triggers an
-     * {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)} event if data was
-     * read, and triggers a
-     * {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext) channelReadComplete} event so the
-     * handler can decide to continue reading.  If there's a pending read operation already, this method does nothing.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#read(ChannelHandlerContext)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelHandlerContext read();
 
-    /**
-     * Request to write a message via this {@link ChannelHandlerContext} through the {@link ChannelPipeline}.
-     * This method will not request to actual flush, so be sure to call {@link #flush()}
-     * once you want to request to flush all pending data to the actual transport.
-     */
-    ChannelFuture write(Object msg);
-
-    /**
-     * Request to write a message via this {@link ChannelHandlerContext} through the {@link ChannelPipeline}.
-     * This method will not request to actual flush, so be sure to call {@link #flush()}
-     * once you want to request to flush all pending data to the actual transport.
-     */
-    ChannelFuture write(Object msg, ChannelPromise promise);
-
-    /**
-     * Request to flush all pending messages via this ChannelOutboundInvoker.
-     */
+    @Override
     ChannelHandlerContext flush();
 
-    /**
-     * Shortcut for call {@link #write(Object, ChannelPromise)} and {@link #flush()}.
-     */
-    ChannelFuture writeAndFlush(Object msg, ChannelPromise promise);
-
-    /**
-     * Shortcut for call {@link #write(Object)} and {@link #flush()}.
-     */
-    ChannelFuture writeAndFlush(Object msg);
-
     /**
      * Return the assigned {@link ChannelPipeline}
      */
@@ -455,43 +197,16 @@ public interface ChannelHandlerContext extends AttributeMap {
     ByteBufAllocator alloc();
 
     /**
-     * Return a new {@link ChannelPromise}.
+     * @deprecated Use {@link Channel#attr(AttributeKey)}
      */
-    ChannelPromise newPromise();
+    @Deprecated
+    @Override
+    <T> Attribute<T> attr(AttributeKey<T> key);
 
     /**
-     * Return an new {@link ChannelProgressivePromise}
+     * @deprecated Use {@link Channel#hasAttr(AttributeKey)}
      */
-    ChannelProgressivePromise newProgressivePromise();
-
-    /**
-     * Create a new {@link ChannelFuture} which is marked as succeeded already. So {@link ChannelFuture#isSuccess()}
-     * will return {@code true}. All {@link FutureListener} added to it will be notified directly. Also
-     * every call of blocking methods will just return without blocking.
-     */
-    ChannelFuture newSucceededFuture();
-
-    /**
-     * Create a new {@link ChannelFuture} which is marked as failed already. So {@link ChannelFuture#isSuccess()}
-     * will return {@code false}. All {@link FutureListener} added to it will be notified directly. Also
-     * every call of blocking methods will just return without blocking.
-     */
-    ChannelFuture newFailedFuture(Throwable cause);
-
-    /**
-     * Return a special ChannelPromise which can be reused for different operations.
-     * <p>
-     * It's only supported to use
-     * it for {@link ChannelHandlerContext#write(Object, ChannelPromise)}.
-     * </p>
-     * <p>
-     * Be aware that the returned {@link ChannelPromise} will not support most operations and should only be used
-     * if you want to save an object allocation for every write operation. You will not be able to detect if the
-     * operation  was complete, only if it failed as the implementation will call
-     * {@link ChannelPipeline#fireExceptionCaught(Throwable)} in this case.
-     * </p>
-     * <strong>Be aware this is an expert feature and should be used with care!</strong>
-     */
-    ChannelPromise voidPromise();
-
+    @Deprecated
+    @Override
+    <T> boolean hasAttr(AttributeKey<T> key);
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java
deleted file mode 100644
index 8acdf6d2a284..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.channel;
-
-import io.netty.util.concurrent.EventExecutor;
-
-import java.net.SocketAddress;
-
-/**
- * Invokes the event handler methods of {@link ChannelInboundHandler} and {@link ChannelOutboundHandler}.
- * A user can specify a {@link ChannelHandlerInvoker} to implement a custom thread model unsupported by the default
- * implementation. Note that the methods in this interface are not intended to be called by a user.
- */
-public interface ChannelHandlerInvoker {
-
-    /**
-     * Returns the {@link EventExecutor} which is used to execute an arbitrary task.
-     */
-    EventExecutor executor();
-
-    /**
-     * Invokes {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)}. This method is not for a user
-     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeChannelRegistered(ChannelHandlerContext ctx);
-
-    /**
-     * Invokes {@link ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)}. This method is not for a user
-     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeChannelUnregistered(ChannelHandlerContext ctx);
-
-    /**
-     * Invokes {@link ChannelInboundHandler#channelActive(ChannelHandlerContext)}. This method is not for a user
-     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeChannelActive(ChannelHandlerContext ctx);
-
-    /**
-     * Invokes {@link ChannelInboundHandler#channelInactive(ChannelHandlerContext)}. This method is not for a user
-     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeChannelInactive(ChannelHandlerContext ctx);
-
-    /**
-     * Invokes {@link ChannelHandler#exceptionCaught(ChannelHandlerContext, Throwable)}. This method is not for a user
-     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeExceptionCaught(ChannelHandlerContext ctx, Throwable cause);
-
-    /**
-     * Invokes {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}. This method is not for
-     * a user but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeUserEventTriggered(ChannelHandlerContext ctx, Object event);
-
-    /**
-     * Invokes {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)}. This method is not for a user
-     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeChannelRead(ChannelHandlerContext ctx, Object msg);
-
-    /**
-     * Invokes {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}. This method is not for a user
-     * but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeChannelReadComplete(ChannelHandlerContext ctx);
-
-    /**
-     * Invokes {@link ChannelInboundHandler#channelWritabilityChanged(ChannelHandlerContext)}. This method is not for
-     * a user but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
-     * {@link ChannelHandlerContext} instead.
-     */
-    void invokeChannelWritabilityChanged(ChannelHandlerContext ctx);
-
-    /**
-     * Invokes {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)}.
-     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
-     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
-     */
-    void invokeBind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise);
-
-    /**
-     * Invokes
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}.
-     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
-     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
-     */
-    void invokeConnect(
-            ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
-
-    /**
-     * Invokes {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}.
-     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
-     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
-     */
-    void invokeDisconnect(ChannelHandlerContext ctx, ChannelPromise promise);
-
-    /**
-     * Invokes {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}.
-     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
-     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
-     */
-    void invokeClose(ChannelHandlerContext ctx, ChannelPromise promise);
-
-    /**
-     * Invokes {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}.
-     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
-     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
-     */
-    void invokeDeregister(ChannelHandlerContext ctx, ChannelPromise promise);
-
-    /**
-     * Invokes {@link ChannelOutboundHandler#read(ChannelHandlerContext)}.
-     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
-     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
-     */
-    void invokeRead(ChannelHandlerContext ctx);
-
-    /**
-     * Invokes {@link ChannelOutboundHandler#write(ChannelHandlerContext, Object, ChannelPromise)}.
-     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
-     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
-     */
-    void invokeWrite(ChannelHandlerContext ctx, Object msg, ChannelPromise promise);
-
-    /**
-     * Invokes {@link ChannelOutboundHandler#flush(ChannelHandlerContext)}.
-     * This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
-     * To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
-     */
-    void invokeFlush(ChannelHandlerContext ctx);
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java
deleted file mode 100644
index 86e3e269b4cb..000000000000
--- a/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.channel;
-
-import io.netty.util.internal.StringUtil;
-
-import java.net.SocketAddress;
-
-import static io.netty.channel.DefaultChannelPipeline.*;
-
-/**
- * A set of helper methods for easier implementation of custom {@link ChannelHandlerInvoker} implementation.
- */
-public final class ChannelHandlerInvokerUtil {
-
-    public static void invokeChannelRegisteredNow(ChannelHandlerContext ctx) {
-        try {
-            ((ChannelInboundHandler) ctx.handler()).channelRegistered(ctx);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeChannelUnregisteredNow(ChannelHandlerContext ctx) {
-        try {
-            ((ChannelInboundHandler) ctx.handler()).channelUnregistered(ctx);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeChannelActiveNow(final ChannelHandlerContext ctx) {
-        try {
-            ((ChannelInboundHandler) ctx.handler()).channelActive(ctx);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeChannelInactiveNow(final ChannelHandlerContext ctx) {
-        try {
-            ((ChannelInboundHandler) ctx.handler()).channelInactive(ctx);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeExceptionCaughtNow(final ChannelHandlerContext ctx, final Throwable cause) {
-        try {
-            ctx.handler().exceptionCaught(ctx, cause);
-        } catch (Throwable t) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("An exception was thrown by a user handler's exceptionCaught() method:", t);
-                logger.warn(".. and the cause of the exceptionCaught() was:", cause);
-            }
-        }
-    }
-
-    public static void invokeUserEventTriggeredNow(final ChannelHandlerContext ctx, final Object event) {
-        try {
-            ((ChannelInboundHandler) ctx.handler()).userEventTriggered(ctx, event);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeChannelReadNow(final ChannelHandlerContext ctx, final Object msg) {
-        try {
-            ((ChannelInboundHandler) ctx.handler()).channelRead(ctx, msg);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeChannelReadCompleteNow(final ChannelHandlerContext ctx) {
-        try {
-            ((ChannelInboundHandler) ctx.handler()).channelReadComplete(ctx);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeChannelWritabilityChangedNow(final ChannelHandlerContext ctx) {
-        try {
-            ((ChannelInboundHandler) ctx.handler()).channelWritabilityChanged(ctx);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeBindNow(
-            final ChannelHandlerContext ctx, final SocketAddress localAddress, final ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) ctx.handler()).bind(ctx, localAddress, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-    public static void invokeConnectNow(
-            final ChannelHandlerContext ctx,
-            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) ctx.handler()).connect(ctx, remoteAddress, localAddress, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    public static void invokeDisconnectNow(final ChannelHandlerContext ctx, final ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) ctx.handler()).disconnect(ctx, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    public static void invokeCloseNow(final ChannelHandlerContext ctx, final ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) ctx.handler()).close(ctx, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    public static void invokeDeregisterNow(final ChannelHandlerContext ctx, final ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) ctx.handler()).deregister(ctx, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    public static void invokeReadNow(final ChannelHandlerContext ctx) {
-        try {
-            ((ChannelOutboundHandler) ctx.handler()).read(ctx);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static void invokeWriteNow(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
-        try {
-            ((ChannelOutboundHandler) ctx.handler()).write(ctx, msg, promise);
-        } catch (Throwable t) {
-            notifyOutboundHandlerException(t, promise);
-        }
-    }
-
-    public static void invokeFlushNow(final ChannelHandlerContext ctx) {
-        try {
-            ((ChannelOutboundHandler) ctx.handler()).flush(ctx);
-        } catch (Throwable t) {
-            notifyHandlerException(ctx, t);
-        }
-    }
-
-    public static boolean validatePromise(
-            ChannelHandlerContext ctx, ChannelPromise promise, boolean allowVoidPromise) {
-        if (ctx == null) {
-            throw new NullPointerException("ctx");
-        }
-
-        if (promise == null) {
-            throw new NullPointerException("promise");
-        }
-
-        if (promise.isDone()) {
-            if (promise.isCancelled()) {
-                return false;
-            }
-            throw new IllegalArgumentException("promise already done: " + promise);
-        }
-
-        if (promise.channel() != ctx.channel()) {
-            throw new IllegalArgumentException(String.format(
-                    "promise.channel does not match: %s (expected: %s)", promise.channel(), ctx.channel()));
-        }
-
-        if (promise.getClass() == DefaultChannelPromise.class) {
-            return true;
-        }
-
-        if (!allowVoidPromise && promise instanceof VoidChannelPromise) {
-            throw new IllegalArgumentException(
-                    StringUtil.simpleClassName(VoidChannelPromise.class) + " not allowed for this operation");
-        }
-
-        if (promise instanceof AbstractChannel.CloseFuture) {
-            throw new IllegalArgumentException(
-                    StringUtil.simpleClassName(AbstractChannel.CloseFuture.class) + " not allowed in a pipeline");
-        }
-        return true;
-    }
-
-    private static void notifyHandlerException(ChannelHandlerContext ctx, Throwable cause) {
-        if (inExceptionCaught(cause)) {
-            if (logger.isWarnEnabled()) {
-                logger.warn(
-                        "An exception was thrown by a user handler " +
-                                "while handling an exceptionCaught event", cause);
-            }
-            return;
-        }
-
-        invokeExceptionCaughtNow(ctx, cause);
-    }
-
-    private static void notifyOutboundHandlerException(Throwable cause, ChannelPromise promise) {
-        if (!promise.tryFailure(cause) && !(promise instanceof VoidChannelPromise)) {
-            if (logger.isWarnEnabled()) {
-                logger.warn("Failed to fail the promise because it's done already: {}", promise, cause);
-            }
-        }
-    }
-
-    private static boolean inExceptionCaught(Throwable cause) {
-        do {
-            StackTraceElement[] trace = cause.getStackTrace();
-            if (trace != null) {
-                for (StackTraceElement t : trace) {
-                    if (t == null) {
-                        break;
-                    }
-                    if ("exceptionCaught".equals(t.getMethodName())) {
-                        return true;
-                    }
-                }
-            }
-
-            cause = cause.getCause();
-        } while (cause != null);
-
-        return false;
-    }
-
-    private ChannelHandlerInvokerUtil() { }
-}
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
index b70880ee287b..ae3a50409174 100644
--- a/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
+++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java
@@ -70,6 +70,6 @@ public interface ChannelInboundHandler extends ChannelHandler {
      * Gets called if a {@link Throwable} was thrown.
      */
     @Override
-    @SuppressWarnings("deprecated")
+    @SuppressWarnings("deprecation")
     void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java
new file mode 100644
index 000000000000..5a04ae9baa84
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+public interface ChannelInboundInvoker {
+
+    /**
+     * A {@link Channel} was registered to its {@link EventLoop}.
+     *
+     * This will result in having the  {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)} method
+     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelInboundInvoker fireChannelRegistered();
+
+    /**
+     * A {@link Channel} was unregistered from its {@link EventLoop}.
+     *
+     * This will result in having the  {@link ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)} method
+     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelInboundInvoker fireChannelUnregistered();
+
+    /**
+     * A {@link Channel} is active now, which means it is connected.
+     *
+     * This will result in having the  {@link ChannelInboundHandler#channelActive(ChannelHandlerContext)} method
+     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelInboundInvoker fireChannelActive();
+
+    /**
+     * A {@link Channel} is inactive now, which means it is closed.
+     *
+     * This will result in having the  {@link ChannelInboundHandler#channelInactive(ChannelHandlerContext)} method
+     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelInboundInvoker fireChannelInactive();
+
+    /**
+     * A {@link Channel} received an {@link Throwable} in one of its inbound operations.
+     *
+     * This will result in having the  {@link ChannelInboundHandler#exceptionCaught(ChannelHandlerContext, Throwable)}
+     * method  called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelInboundInvoker fireExceptionCaught(Throwable cause);
+
+    /**
+     * A {@link Channel} received an user defined event.
+     *
+     * This will result in having the  {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}
+     * method  called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelInboundInvoker fireUserEventTriggered(Object event);
+
+    /**
+     * A {@link Channel} received a message.
+     *
+     * This will result in having the {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)}
+     * method  called of the next {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelInboundInvoker fireChannelRead(Object msg);
+
+    /**
+     * Triggers an {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}
+     * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
+     */
+    ChannelInboundInvoker fireChannelReadComplete();
+
+    /**
+     * Triggers an {@link ChannelInboundHandler#channelWritabilityChanged(ChannelHandlerContext)}
+     * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
+     */
+    ChannelInboundInvoker fireChannelWritabilityChanged();
+}
diff --git a/transport/src/main/java/io/netty/channel/ChannelOption.java b/transport/src/main/java/io/netty/channel/ChannelOption.java
index bceba03ef3f8..9fefad51356e 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOption.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java
@@ -79,6 +79,7 @@ public static <T> ChannelOption<T> newInstance(String name) {
     /**
      * @deprecated Use {@link MaxMessagesRecvByteBufAllocator}
      */
+    @Deprecated
     public static final ChannelOption<Integer> MAX_MESSAGES_PER_READ = valueOf("MAX_MESSAGES_PER_READ");
     public static final ChannelOption<Integer> WRITE_SPIN_COUNT = valueOf("WRITE_SPIN_COUNT");
     /**
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
index 5b9a3f591117..0e6bfa5934b4 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
@@ -798,7 +798,7 @@ protected Entry newObject(Handle handle) {
             }
         };
 
-        private final Handle handle;
+        private final Handle<Entry> handle;
         Entry next;
         Object msg;
         ByteBuffer[] bufs;
@@ -810,7 +810,7 @@ protected Entry newObject(Handle handle) {
         int count = -1;
         boolean cancelled;
 
-        private Entry(Handle handle) {
+        private Entry(Handle<Entry> handle) {
             this.handle = handle;
         }
 
@@ -853,7 +853,7 @@ void recycle() {
             pendingSize = 0;
             count = -1;
             cancelled = false;
-            RECYCLER.recycle(this, handle);
+            handle.recycle(this);
         }
 
         Entry recycleAndGetNext() {
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
new file mode 100644
index 000000000000..19b737a1f02f
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel;
+
+import io.netty.util.concurrent.EventExecutor;
+import io.netty.util.concurrent.FutureListener;
+
+import java.net.ConnectException;
+import java.net.SocketAddress;
+
+public interface ChannelOutboundInvoker {
+
+    /**
+     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
+     * completes, either because the operation was successful or because of an error.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
+     * called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture bind(SocketAddress localAddress);
+
+    /**
+     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
+     * completes, either because the operation was successful or because of an error.
+     * <p>
+     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with
+     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}
+     * will be used.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture connect(SocketAddress remoteAddress);
+
+    /**
+     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the
+     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
+     * an error.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);
+
+    /**
+     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
+     * either because the operation was successful or because of an error.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture disconnect();
+
+    /**
+     * Request to close the {@link Channel} and notify the {@link ChannelFuture} once the operation completes,
+     * either because the operation was successful or because of
+     * an error.
+     *
+     * After it is closed it is not possible to reuse it again.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture close();
+
+    /**
+     * Request to deregister from the previous assigned {@link EventExecutor} and notify the
+     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
+     * an error.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     *
+     */
+    ChannelFuture deregister();
+
+    /**
+     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
+     * completes, either because the operation was successful or because of an error.
+     *
+     * The given {@link ChannelPromise} will be notified.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
+     * called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise);
+
+    /**
+     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
+     * completes, either because the operation was successful or because of an error.
+     *
+     * The given {@link ChannelFuture} will be notified.
+     *
+     * <p>
+     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with
+     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}
+     * will be used.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise);
+
+    /**
+     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the
+     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
+     * an error.
+     *
+     * The given {@link ChannelPromise} will be notified and also returned.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
+
+    /**
+     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
+     * either because the operation was successful or because of an error.
+     *
+     * The given {@link ChannelPromise} will be notified.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture disconnect(ChannelPromise promise);
+
+    /**
+     * Request to close the {@link Channel} and notify the {@link ChannelFuture} once the operation completes,
+     * either because the operation was successful or because of
+     * an error.
+     *
+     * After it is closed it is not possible to reuse it again.
+     * The given {@link ChannelPromise} will be notified.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture close(ChannelPromise promise);
+
+    /**
+     * Request to deregister from the previous assigned {@link EventExecutor} and notify the
+     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
+     * an error.
+     *
+     * The given {@link ChannelPromise} will be notified.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelFuture deregister(ChannelPromise promise);
+
+    /**
+     * Request to Read data from the {@link Channel} into the first inbound buffer, triggers an
+     * {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)} event if data was
+     * read, and triggers a
+     * {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext) channelReadComplete} event so the
+     * handler can decide to continue reading.  If there's a pending read operation already, this method does nothing.
+     * <p>
+     * This will result in having the
+     * {@link ChannelOutboundHandler#read(ChannelHandlerContext)}
+     * method called of the next {@link ChannelOutboundHandler} contained in the {@link ChannelPipeline} of the
+     * {@link Channel}.
+     */
+    ChannelOutboundInvoker read();
+
+    /**
+     * Request to write a message via this {@link ChannelHandlerContext} through the {@link ChannelPipeline}.
+     * This method will not request to actual flush, so be sure to call {@link #flush()}
+     * once you want to request to flush all pending data to the actual transport.
+     */
+    ChannelFuture write(Object msg);
+
+    /**
+     * Request to write a message via this {@link ChannelHandlerContext} through the {@link ChannelPipeline}.
+     * This method will not request to actual flush, so be sure to call {@link #flush()}
+     * once you want to request to flush all pending data to the actual transport.
+     */
+    ChannelFuture write(Object msg, ChannelPromise promise);
+
+    /**
+     * Request to flush all pending messages via this ChannelOutboundInvoker.
+     */
+    ChannelOutboundInvoker flush();
+
+    /**
+     * Shortcut for call {@link #write(Object, ChannelPromise)} and {@link #flush()}.
+     */
+    ChannelFuture writeAndFlush(Object msg, ChannelPromise promise);
+
+    /**
+     * Shortcut for call {@link #write(Object)} and {@link #flush()}.
+     */
+    ChannelFuture writeAndFlush(Object msg);
+
+    /**
+     * Return a new {@link ChannelPromise}.
+     */
+    ChannelPromise newPromise();
+
+    /**
+     * Return an new {@link ChannelProgressivePromise}
+     */
+    ChannelProgressivePromise newProgressivePromise();
+
+    /**
+     * Create a new {@link ChannelFuture} which is marked as succeeded already. So {@link ChannelFuture#isSuccess()}
+     * will return {@code true}. All {@link FutureListener} added to it will be notified directly. Also
+     * every call of blocking methods will just return without blocking.
+     */
+    ChannelFuture newSucceededFuture();
+
+    /**
+     * Create a new {@link ChannelFuture} which is marked as failed already. So {@link ChannelFuture#isSuccess()}
+     * will return {@code false}. All {@link FutureListener} added to it will be notified directly. Also
+     * every call of blocking methods will just return without blocking.
+     */
+    ChannelFuture newFailedFuture(Throwable cause);
+
+    /**
+     * Return a special ChannelPromise which can be reused for different operations.
+     * <p>
+     * It's only supported to use
+     * it for {@link ChannelOutboundInvoker#write(Object, ChannelPromise)}.
+     * </p>
+     * <p>
+     * Be aware that the returned {@link ChannelPromise} will not support most operations and should only be used
+     * if you want to save an object allocation for every write operation. You will not be able to detect if the
+     * operation  was complete, only if it failed as the implementation will call
+     * {@link ChannelPipeline#fireExceptionCaught(Throwable)} in this case.
+     * </p>
+     * <strong>Be aware this is an expert feature and should be used with care!</strong>
+     */
+    ChannelPromise voidPromise();
+}
diff --git a/transport/src/main/java/io/netty/channel/ChannelPipeline.java b/transport/src/main/java/io/netty/channel/ChannelPipeline.java
index 58a5b4ffab74..2752216b55f1 100644
--- a/transport/src/main/java/io/netty/channel/ChannelPipeline.java
+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java
@@ -17,10 +17,8 @@
 
 import io.netty.buffer.ByteBuf;
 import io.netty.util.concurrent.DefaultEventExecutorGroup;
-import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.EventExecutorGroup;
 
-import java.net.ConnectException;
 import java.net.SocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.SocketChannel;
@@ -215,12 +213,13 @@
  * For example, you can insert an encryption handler when sensitive information is about to be exchanged, and remove it
  * after the exchange.
  */
-public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>> {
+public interface ChannelPipeline
+        extends ChannelInboundInvoker, ChannelOutboundInvoker, Iterable<Entry<String, ChannelHandler>> {
 
     /**
      * Inserts a {@link ChannelHandler} at the first position of this pipeline.
      *
-     * @param name     the name of the handler to insert first. {@code null} to let the name auto-generated.
+     * @param name     the name of the handler to insert first
      * @param handler  the handler to insert first
      *
      * @throws IllegalArgumentException
@@ -235,7 +234,7 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      *
      * @param group    the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler}
      *                 methods
-     * @param name     the name of the handler to insert first. {@code null} to let the name auto-generated.
+     * @param name     the name of the handler to insert first
      * @param handler  the handler to insert first
      *
      * @throws IllegalArgumentException
@@ -245,24 +244,10 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      */
     ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler);
 
-    /**
-     * Inserts a {@link ChannelHandler} at the first position of this pipeline.
-     *
-     * @param invoker  the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
-     * @param name     the name of the handler to insert first. {@code null} to let the name auto-generated.
-     * @param handler  the handler to insert first
-     *
-     * @throws IllegalArgumentException
-     *         if there's an entry with the same name already in the pipeline
-     * @throws NullPointerException
-     *         if the specified handler is {@code null}
-     */
-    ChannelPipeline addFirst(ChannelHandlerInvoker invoker, String name, ChannelHandler handler);
-
     /**
      * Appends a {@link ChannelHandler} at the last position of this pipeline.
      *
-     * @param name     the name of the handler to append. {@code null} to let the name auto-generated.
+     * @param name     the name of the handler to append
      * @param handler  the handler to append
      *
      * @throws IllegalArgumentException
@@ -277,7 +262,7 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      *
      * @param group    the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler}
      *                 methods
-     * @param name     the name of the handler to append. {@code null} to let the name auto-generated.
+     * @param name     the name of the handler to append
      * @param handler  the handler to append
      *
      * @throws IllegalArgumentException
@@ -287,26 +272,12 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      */
     ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler);
 
-    /**
-     * Appends a {@link ChannelHandler} at the last position of this pipeline.
-     *
-     * @param invoker  the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
-     * @param name     the name of the handler to append. {@code null} to let the name auto-generated.
-     * @param handler  the handler to append
-     *
-     * @throws IllegalArgumentException
-     *         if there's an entry with the same name already in the pipeline
-     * @throws NullPointerException
-     *         if the specified handler is {@code null}
-     */
-    ChannelPipeline addLast(ChannelHandlerInvoker invoker, String name, ChannelHandler handler);
-
     /**
      * Inserts a {@link ChannelHandler} before an existing handler of this
      * pipeline.
      *
      * @param baseName  the name of the existing handler
-     * @param name      the name of the handler to insert before. {@code null} to let the name auto-generated.
+     * @param name      the name of the handler to insert before
      * @param handler   the handler to insert before
      *
      * @throws NoSuchElementException
@@ -325,7 +296,7 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      * @param group     the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler}
      *                  methods
      * @param baseName  the name of the existing handler
-     * @param name      the name of the handler to insert before. {@code null} to let the name auto-generated.
+     * @param name      the name of the handler to insert before
      * @param handler   the handler to insert before
      *
      * @throws NoSuchElementException
@@ -337,30 +308,12 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      */
     ChannelPipeline addBefore(EventExecutorGroup group, String baseName, String name, ChannelHandler handler);
 
-    /**
-     * Inserts a {@link ChannelHandler} before an existing handler of this
-     * pipeline.
-     *
-     * @param invoker   the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
-     * @param baseName  the name of the existing handler
-     * @param name      the name of the handler to insert before. {@code null} to let the name auto-generated.
-     * @param handler   the handler to insert before
-     *
-     * @throws NoSuchElementException
-     *         if there's no such entry with the specified {@code baseName}
-     * @throws IllegalArgumentException
-     *         if there's an entry with the same name already in the pipeline
-     * @throws NullPointerException
-     *         if the specified baseName or handler is {@code null}
-     */
-    ChannelPipeline addBefore(ChannelHandlerInvoker invoker, String baseName, String name, ChannelHandler handler);
-
     /**
      * Inserts a {@link ChannelHandler} after an existing handler of this
      * pipeline.
      *
      * @param baseName  the name of the existing handler
-     * @param name      the name of the handler to insert after. {@code null} to let the name auto-generated.
+     * @param name      the name of the handler to insert after
      * @param handler   the handler to insert after
      *
      * @throws NoSuchElementException
@@ -379,7 +332,7 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      * @param group     the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler}
      *                  methods
      * @param baseName  the name of the existing handler
-     * @param name      the name of the handler to insert after. {@code null} to let the name auto-generated.
+     * @param name      the name of the handler to insert after
      * @param handler   the handler to insert after
      *
      * @throws NoSuchElementException
@@ -391,24 +344,6 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      */
     ChannelPipeline addAfter(EventExecutorGroup group, String baseName, String name, ChannelHandler handler);
 
-    /**
-     * Inserts a {@link ChannelHandler} after an existing handler of this
-     * pipeline.
-     *
-     * @param invoker   the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
-     * @param baseName  the name of the existing handler
-     * @param name      the name of the handler to insert after. {@code null} to let the name auto-generated.
-     * @param handler   the handler to insert after
-     *
-     * @throws NoSuchElementException
-     *         if there's no such entry with the specified {@code baseName}
-     * @throws IllegalArgumentException
-     *         if there's an entry with the same name already in the pipeline
-     * @throws NullPointerException
-     *         if the specified baseName or handler is {@code null}
-     */
-    ChannelPipeline addAfter(ChannelHandlerInvoker invoker, String baseName, String name, ChannelHandler handler);
-
     /**
      * Inserts {@link ChannelHandler}s at the first position of this pipeline.
      *
@@ -427,15 +362,6 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      */
     ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler... handlers);
 
-    /**
-     * Inserts {@link ChannelHandler}s at the first position of this pipeline.
-     *
-     * @param invoker   the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
-     * @param handlers  the handlers to insert first
-     *
-     */
-    ChannelPipeline addFirst(ChannelHandlerInvoker invoker, ChannelHandler... handlers);
-
     /**
      * Inserts {@link ChannelHandler}s at the last position of this pipeline.
      *
@@ -454,15 +380,6 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      */
     ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers);
 
-    /**
-     * Inserts {@link ChannelHandler}s at the last position of this pipeline.
-     *
-     * @param invoker   the {@link ChannelHandlerInvoker} which invokes the {@code handler}s event handler methods
-     * @param handlers  the handlers to insert last
-     *
-     */
-    ChannelPipeline addLast(ChannelHandlerInvoker invoker, ChannelHandler... handlers);
-
     /**
      * Removes the specified {@link ChannelHandler} from this pipeline.
      *
@@ -528,8 +445,7 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      * Replaces the specified {@link ChannelHandler} with a new handler in this pipeline.
      *
      * @param  oldHandler    the {@link ChannelHandler} to be replaced
-     * @param  newName       the name under which the replacement should be added.
-     *                       {@code null} to use the same name with the handler being replaced.
+     * @param  newName       the name under which the replacement should be added
      * @param  newHandler    the {@link ChannelHandler} which is used as replacement
      *
      * @return itself
@@ -540,7 +456,8 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      *         if a handler with the specified new name already exists in this
      *         pipeline, except for the handler to be replaced
      * @throws NullPointerException
-     *         if the specified old handler or new handler is {@code null}
+     *         if the specified old handler or new handler is
+     *         {@code null}
      */
     ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);
 
@@ -548,8 +465,7 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      * Replaces the {@link ChannelHandler} of the specified name with a new handler in this pipeline.
      *
      * @param  oldName       the name of the {@link ChannelHandler} to be replaced
-     * @param  newName       the name under which the replacement should be added.
-     *                       {@code null} to use the same name with the handler being replaced.
+     * @param  newName       the name under which the replacement should be added
      * @param  newHandler    the {@link ChannelHandler} which is used as replacement
      *
      * @return the removed handler
@@ -560,7 +476,8 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      *         if a handler with the specified new name already exists in this
      *         pipeline, except for the handler to be replaced
      * @throws NullPointerException
-     *         if the specified old handler or new handler is {@code null}
+     *         if the specified old handler or new handler is
+     *         {@code null}
      */
     ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler);
 
@@ -568,8 +485,7 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      * Replaces the {@link ChannelHandler} of the specified type with a new handler in this pipeline.
      *
      * @param  oldHandlerType   the type of the handler to be removed
-     * @param  newName          the name under which the replacement should be added.
-     *                          {@code null} to use the same name with the handler being replaced.
+     * @param  newName          the name under which the replacement should be added
      * @param  newHandler       the {@link ChannelHandler} which is used as replacement
      *
      * @return the removed handler
@@ -581,7 +497,8 @@ public interface ChannelPipeline extends Iterable<Entry<String, ChannelHandler>>
      *         if a handler with the specified new name already exists in this
      *         pipeline, except for the handler to be replaced
      * @throws NullPointerException
-     *         if the specified old handler or new handler is {@code null}
+     *         if the specified old handler or new handler is
+     *         {@code null}
      */
     <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
                                          ChannelHandler newHandler);
@@ -677,284 +594,33 @@ <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName,
      */
     Map<String, ChannelHandler> toMap();
 
-    /**
-     * A {@link Channel} was registered to its {@link EventLoop}.
-     *
-     * This will result in having the  {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelPipeline fireChannelRegistered();
 
-    /**
-     * A {@link Channel} was unregistered from its {@link EventLoop}.
-     *
-     * This will result in having the  {@link ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+     @Override
     ChannelPipeline fireChannelUnregistered();
 
-    /**
-     * A {@link Channel} is active now, which means it is connected.
-     *
-     * This will result in having the  {@link ChannelInboundHandler#channelActive(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelPipeline fireChannelActive();
 
-    /**
-     * A {@link Channel} is inactive now, which means it is closed.
-     *
-     * This will result in having the  {@link ChannelInboundHandler#channelInactive(ChannelHandlerContext)} method
-     * called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelPipeline fireChannelInactive();
 
-    /**
-     * A {@link Channel} received an {@link Throwable} in one of its inbound operations.
-     *
-     * This will result in having the  {@link ChannelInboundHandler#exceptionCaught(ChannelHandlerContext, Throwable)}
-     * method  called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelPipeline fireExceptionCaught(Throwable cause);
 
-    /**
-     * A {@link Channel} received an user defined event.
-     *
-     * This will result in having the  {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)}
-     * method  called of the next  {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelPipeline fireUserEventTriggered(Object event);
 
-    /**
-     * A {@link Channel} received a message.
-     *
-     * This will result in having the {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)}
-     * method  called of the next {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
+    @Override
     ChannelPipeline fireChannelRead(Object msg);
 
-    /**
-     * Triggers an {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}
-     * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
-     */
+    @Override
     ChannelPipeline fireChannelReadComplete();
 
-    /**
-     * Triggers an {@link ChannelInboundHandler#channelWritabilityChanged(ChannelHandlerContext)}
-     * event to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}.
-     */
+    @Override
     ChannelPipeline fireChannelWritabilityChanged();
 
-    /**
-     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture bind(SocketAddress localAddress);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     * <p>
-     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with
-     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}
-     * will be used.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress);
-
-    /**
-     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture disconnect();
-
-    /**
-     * Request to close the {@link Channel} and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of
-     * an error.
-     *
-     * After it is closed it is not possible to reuse it again.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture close();
-
-    /**
-     * Request to deregister the {@link Channel} from the previous assigned {@link EventExecutor} and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     *
-     */
-    ChannelFuture deregister();
-
-    /**
-     * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method
-     * called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation
-     * completes, either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelFuture} will be notified.
-     *
-     * <p>
-     * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with
-     * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}
-     * will be used.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise);
-
-    /**
-     * Request to connect to the given {@link SocketAddress} while bind to the localAddress and notify the
-     * {@link ChannelFuture} once the operation completes, either because the operation was successful or because of
-     * an error.
-     *
-     * The given {@link ChannelPromise} will be notified and also returned.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise);
-
-    /**
-     * Request to disconnect from the remote peer and notify the {@link ChannelFuture} once the operation completes,
-     * either because the operation was successful or because of an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#disconnect(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture disconnect(ChannelPromise promise);
-
-    /**
-     * Request to close the {@link Channel} bound to this {@link ChannelPipeline} and notify the {@link ChannelFuture}
-     * once the operation completes, either because the operation was successful or because of
-     * an error.
-     *
-     * After it is closed it is not possible to reuse it again.
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#close(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture close(ChannelPromise promise);
-
-    /**
-     * Request to deregister the {@link Channel} bound this {@link ChannelPipeline} from the previous assigned
-     * {@link EventExecutor} and notify the {@link ChannelFuture} once the operation completes, either because the
-     * operation was successful or because of an error.
-     *
-     * The given {@link ChannelPromise} will be notified.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#deregister(ChannelHandlerContext, ChannelPromise)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelFuture deregister(ChannelPromise promise);
-
-    /**
-     * Request to Read data from the {@link Channel} into the first inbound buffer, triggers an
-     * {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)} event if data was
-     * read, and triggers a
-     * {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext) channelReadComplete} event so the
-     * handler can decide to continue reading.  If there's a pending read operation already, this method does nothing.
-     * <p>
-     * This will result in having the
-     * {@link ChannelOutboundHandler#read(ChannelHandlerContext)}
-     * method called of the next {@link ChannelOutboundHandler} contained in the  {@link ChannelPipeline} of the
-     * {@link Channel}.
-     */
-    ChannelPipeline read();
-
-    /**
-     * Request to write a message via this {@link ChannelPipeline}.
-     * This method will not request to actual flush, so be sure to call {@link #flush()}
-     * once you want to request to flush all pending data to the actual transport.
-     */
-    ChannelFuture write(Object msg);
-
-    /**
-     * Request to write a message via this {@link ChannelPipeline}.
-     * This method will not request to actual flush, so be sure to call {@link #flush()}
-     * once you want to request to flush all pending data to the actual transport.
-     */
-    ChannelFuture write(Object msg, ChannelPromise promise);
-
-    /**
-     * Request to flush all pending messages.
-     */
+    @Override
     ChannelPipeline flush();
-
-    /**
-     * Shortcut for call {@link #write(Object, ChannelPromise)} and {@link #flush()}.
-     */
-    ChannelFuture writeAndFlush(Object msg, ChannelPromise promise);
-
-    /**
-     * Shortcut for call {@link #write(Object)} and {@link #flush()}.
-     */
-    ChannelFuture writeAndFlush(Object msg);
 }
diff --git a/transport/src/main/java/io/netty/channel/CoalescingBufferQueue.java b/transport/src/main/java/io/netty/channel/CoalescingBufferQueue.java
index 39a88ab576fd..439d6a40531c 100644
--- a/transport/src/main/java/io/netty/channel/CoalescingBufferQueue.java
+++ b/transport/src/main/java/io/netty/channel/CoalescingBufferQueue.java
@@ -129,7 +129,7 @@ public ByteBuf remove(int bytes, ChannelPromise aggregatePromise) {
                 bufAndListenerPairs.addFirst(entryBuffer);
                 if (bytes > 0) {
                     // Take a slice of what we can consume and retain it.
-                    toReturn = compose(toReturn, entryBuffer.readSlice(bytes).retain());
+                    toReturn = compose(toReturn, entryBuffer.readRetainedSlice(bytes));
                     bytes = 0;
                 }
                 break;
@@ -152,16 +152,15 @@ private ByteBuf compose(ByteBuf current, ByteBuf next) {
         }
         if (current instanceof CompositeByteBuf) {
             CompositeByteBuf composite = (CompositeByteBuf) current;
-            composite.addComponent(next);
-            composite.writerIndex(composite.writerIndex() + next.readableBytes());
+            composite.addComponent(true, next);
             return composite;
         }
         // Create a composite buffer to accumulate this pair and potentially all the buffers
         // in the queue. Using +2 as we have already dequeued current and next.
         CompositeByteBuf composite = channel.alloc().compositeBuffer(bufAndListenerPairs.size() + 2);
-        composite.addComponent(current);
-        composite.addComponent(next);
-        return composite.writerIndex(current.readableBytes() + next.readableBytes());
+        composite.addComponent(true, current);
+        composite.addComponent(true, next);
+        return composite;
     }
 
     /**
diff --git a/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java b/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
index 357055b7e820..c33f1f3b0109 100644
--- a/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
+++ b/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java
@@ -372,11 +372,6 @@ public EventExecutor executor() {
             return ctx.executor();
         }
 
-        @Override
-        public ChannelHandlerInvoker invoker() {
-            return ctx.invoker();
-        }
-
         @Override
         public String name() {
             return ctx.name();
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
index 8092cd55a14c..58454b817ac3 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java
@@ -15,13 +15,15 @@
 */
 package io.netty.channel;
 
+import io.netty.util.concurrent.EventExecutor;
+
 final class DefaultChannelHandlerContext extends AbstractChannelHandlerContext {
 
     private final ChannelHandler handler;
 
     DefaultChannelHandlerContext(
-            DefaultChannelPipeline pipeline, ChannelHandlerInvoker invoker, String name, ChannelHandler handler) {
-        super(pipeline, invoker, name, isInbound(handler), isOutbound(handler));
+            DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) {
+        super(pipeline, executor, name, isInbound(handler), isOutbound(handler));
         if (handler == null) {
             throw new NullPointerException("handler");
         }
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java
deleted file mode 100644
index 9a72c10e4cdd..000000000000
--- a/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java
+++ /dev/null
@@ -1,510 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.channel;
-
-import io.netty.util.Recycler;
-import io.netty.util.ReferenceCountUtil;
-import io.netty.util.concurrent.EventExecutor;
-import io.netty.util.internal.OneTimeTask;
-import io.netty.util.internal.RecyclableMpscLinkedQueueNode;
-import io.netty.util.internal.SystemPropertyUtil;
-
-import java.net.SocketAddress;
-
-import static io.netty.channel.ChannelHandlerInvokerUtil.*;
-import static io.netty.channel.DefaultChannelPipeline.*;
-
-public class DefaultChannelHandlerInvoker implements ChannelHandlerInvoker {
-
-    private final EventExecutor executor;
-
-    public DefaultChannelHandlerInvoker(EventExecutor executor) {
-        if (executor == null) {
-            throw new NullPointerException("executor");
-        }
-
-        this.executor = executor;
-    }
-
-    @Override
-    public EventExecutor executor() {
-        return executor;
-    }
-
-    @Override
-    public void invokeChannelRegistered(final ChannelHandlerContext ctx) {
-        if (executor.inEventLoop()) {
-            invokeChannelRegisteredNow(ctx);
-        } else {
-            executor.execute(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeChannelRegisteredNow(ctx);
-                }
-            });
-        }
-    }
-
-    @Override
-    public void invokeChannelUnregistered(final ChannelHandlerContext ctx) {
-        if (executor.inEventLoop()) {
-            invokeChannelUnregisteredNow(ctx);
-        } else {
-            executor.execute(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeChannelUnregisteredNow(ctx);
-                }
-            });
-        }
-    }
-
-    @Override
-    public void invokeChannelActive(final ChannelHandlerContext ctx) {
-        if (executor.inEventLoop()) {
-            invokeChannelActiveNow(ctx);
-        } else {
-            executor.execute(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeChannelActiveNow(ctx);
-                }
-            });
-        }
-    }
-
-    @Override
-    public void invokeChannelInactive(final ChannelHandlerContext ctx) {
-        if (executor.inEventLoop()) {
-            invokeChannelInactiveNow(ctx);
-        } else {
-            executor.execute(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeChannelInactiveNow(ctx);
-                }
-            });
-        }
-    }
-
-    @Override
-    public void invokeExceptionCaught(final ChannelHandlerContext ctx, final Throwable cause) {
-        if (cause == null) {
-            throw new NullPointerException("cause");
-        }
-
-        if (executor.inEventLoop()) {
-            invokeExceptionCaughtNow(ctx, cause);
-        } else {
-            try {
-                executor.execute(new OneTimeTask() {
-                    @Override
-                    public void run() {
-                        invokeExceptionCaughtNow(ctx, cause);
-                    }
-                });
-            } catch (Throwable t) {
-                if (logger.isWarnEnabled()) {
-                    logger.warn("Failed to submit an exceptionCaught() event.", t);
-                    logger.warn("The exceptionCaught() event that was failed to submit was:", cause);
-                }
-            }
-        }
-    }
-
-    @Override
-    public void invokeUserEventTriggered(final ChannelHandlerContext ctx, final Object event) {
-        if (event == null) {
-            throw new NullPointerException("event");
-        }
-
-        if (executor.inEventLoop()) {
-            invokeUserEventTriggeredNow(ctx, event);
-        } else {
-            safeExecuteInbound(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeUserEventTriggeredNow(ctx, event);
-                }
-            }, event);
-        }
-    }
-
-    @Override
-    public void invokeChannelRead(final ChannelHandlerContext ctx, final Object msg) {
-        if (msg == null) {
-            throw new NullPointerException("msg");
-        }
-
-        if (executor.inEventLoop()) {
-            invokeChannelReadNow(ctx, msg);
-        } else {
-            safeExecuteInbound(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeChannelReadNow(ctx, msg);
-                }
-            }, msg);
-        }
-    }
-
-    @Override
-    public void invokeChannelReadComplete(final ChannelHandlerContext ctx) {
-        if (executor.inEventLoop()) {
-            invokeChannelReadCompleteNow(ctx);
-        } else {
-            Runnable task;
-            if (ctx instanceof AbstractChannelHandlerContext) {
-                AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
-                task = dctx.invokeChannelReadCompleteTask;
-                if (task == null) {
-                    dctx.invokeChannelReadCompleteTask = task = new Runnable() {
-                        @Override
-                        public void run() {
-                            invokeChannelReadCompleteNow(ctx);
-                        }
-                    };
-                }
-            } else {
-                task = new OneTimeTask() {
-                    @Override
-                    public void run() {
-                        invokeChannelReadCompleteNow(ctx);
-                    }
-                };
-            }
-            executor.execute(task);
-        }
-    }
-
-    @Override
-    public void invokeChannelWritabilityChanged(final ChannelHandlerContext ctx) {
-        if (executor.inEventLoop()) {
-            invokeChannelWritabilityChangedNow(ctx);
-        } else {
-            Runnable task;
-            if (ctx instanceof AbstractChannelHandlerContext) {
-                AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
-                task = dctx.invokeChannelWritableStateChangedTask;
-                if (task == null) {
-                    dctx.invokeChannelWritableStateChangedTask = task = new Runnable() {
-                        @Override
-                        public void run() {
-                            invokeChannelWritabilityChangedNow(ctx);
-                        }
-                    };
-                }
-            } else {
-                task = new OneTimeTask() {
-                    @Override
-                    public void run() {
-                        invokeChannelWritabilityChangedNow(ctx);
-                    }
-                };
-            }
-            executor.execute(task);
-        }
-    }
-
-    @Override
-    public void invokeBind(
-            final ChannelHandlerContext ctx, final SocketAddress localAddress, final ChannelPromise promise) {
-        if (localAddress == null) {
-            throw new NullPointerException("localAddress");
-        }
-        if (!validatePromise(ctx, promise, false)) {
-            // promise cancelled
-            return;
-        }
-
-        if (executor.inEventLoop()) {
-            invokeBindNow(ctx, localAddress, promise);
-        } else {
-            safeExecuteOutbound(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeBindNow(ctx, localAddress, promise);
-                }
-            }, promise);
-        }
-    }
-
-    @Override
-    public void invokeConnect(
-            final ChannelHandlerContext ctx,
-            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
-        if (remoteAddress == null) {
-            throw new NullPointerException("remoteAddress");
-        }
-        if (!validatePromise(ctx, promise, false)) {
-            // promise cancelled
-            return;
-        }
-
-        if (executor.inEventLoop()) {
-            invokeConnectNow(ctx, remoteAddress, localAddress, promise);
-        } else {
-            safeExecuteOutbound(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeConnectNow(ctx, remoteAddress, localAddress, promise);
-                }
-            }, promise);
-        }
-    }
-
-    @Override
-    public void invokeDisconnect(final ChannelHandlerContext ctx, final ChannelPromise promise) {
-        if (!validatePromise(ctx, promise, false)) {
-            // promise cancelled
-            return;
-        }
-
-        if (executor.inEventLoop()) {
-            invokeDisconnectNow(ctx, promise);
-        } else {
-            safeExecuteOutbound(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeDisconnectNow(ctx, promise);
-                }
-            }, promise);
-        }
-    }
-
-    @Override
-    public void invokeClose(final ChannelHandlerContext ctx, final ChannelPromise promise) {
-        if (!validatePromise(ctx, promise, false)) {
-            // promise cancelled
-            return;
-        }
-
-        if (executor.inEventLoop()) {
-            invokeCloseNow(ctx, promise);
-        } else {
-            safeExecuteOutbound(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeCloseNow(ctx, promise);
-                }
-            }, promise);
-        }
-    }
-
-    @Override
-    public void invokeDeregister(final ChannelHandlerContext ctx, final ChannelPromise promise) {
-        if (!validatePromise(ctx, promise, false)) {
-            // promise cancelled
-            return;
-        }
-
-        if (executor.inEventLoop()) {
-            invokeDeregisterNow(ctx, promise);
-        } else {
-            safeExecuteOutbound(new OneTimeTask() {
-                @Override
-                public void run() {
-                    invokeDeregisterNow(ctx, promise);
-                }
-            }, promise);
-        }
-    }
-
-    @Override
-    public void invokeRead(final ChannelHandlerContext ctx) {
-        if (executor.inEventLoop()) {
-            invokeReadNow(ctx);
-        } else {
-            Runnable task;
-            if (ctx instanceof AbstractChannelHandlerContext) {
-                AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
-                task = dctx.invokeReadTask;
-                if (task == null) {
-                    dctx.invokeReadTask = task = new Runnable() {
-                        @Override
-                        public void run() {
-                            invokeReadNow(ctx);
-                        }
-                    };
-                }
-            } else {
-                task = new OneTimeTask() {
-                    @Override
-                    public void run() {
-                        invokeReadNow(ctx);
-                    }
-                };
-            }
-            executor.execute(task);
-        }
-    }
-
-    @Override
-    public void invokeWrite(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
-        if (msg == null) {
-            throw new NullPointerException("msg");
-        }
-        try {
-            if (!validatePromise(ctx, promise, true)) {
-                ReferenceCountUtil.release(msg);
-                return;
-            }
-        } catch (RuntimeException e) {
-            ReferenceCountUtil.release(msg);
-            throw e;
-        }
-
-        if (executor.inEventLoop()) {
-            invokeWriteNow(ctx, msg, promise);
-        } else {
-            safeExecuteOutbound(WriteTask.newInstance(ctx, msg, promise), promise, msg);
-        }
-    }
-
-    @Override
-    public void invokeFlush(final ChannelHandlerContext ctx) {
-        if (executor.inEventLoop()) {
-            invokeFlushNow(ctx);
-        } else {
-            Runnable task;
-            if (ctx instanceof AbstractChannelHandlerContext) {
-                AbstractChannelHandlerContext dctx = (AbstractChannelHandlerContext) ctx;
-                task = dctx.invokeFlushTask;
-                if (task == null) {
-                    dctx.invokeFlushTask = task = new Runnable() {
-                        @Override
-                        public void run() {
-                            invokeFlushNow(ctx);
-                        }
-                    };
-                }
-            } else {
-                task = new OneTimeTask() {
-                    @Override
-                    public void run() {
-                        invokeFlushNow(ctx);
-                    }
-                };
-            }
-            executor.execute(task);
-        }
-    }
-
-    private void safeExecuteInbound(Runnable task, Object msg) {
-        boolean success = false;
-        try {
-            executor.execute(task);
-            success = true;
-        } finally {
-            if (!success) {
-                ReferenceCountUtil.release(msg);
-            }
-        }
-    }
-
-    private void safeExecuteOutbound(Runnable task, ChannelPromise promise) {
-        try {
-            executor.execute(task);
-        } catch (Throwable cause) {
-            promise.setFailure(cause);
-        }
-    }
-    private void safeExecuteOutbound(Runnable task, ChannelPromise promise, Object msg) {
-        try {
-            executor.execute(task);
-        } catch (Throwable cause) {
-            try {
-                promise.setFailure(cause);
-            } finally {
-                ReferenceCountUtil.release(msg);
-            }
-        }
-    }
-
-    static final class WriteTask extends RecyclableMpscLinkedQueueNode<SingleThreadEventLoop.NonWakeupRunnable>
-            implements SingleThreadEventLoop.NonWakeupRunnable {
-
-        private static final boolean ESTIMATE_TASK_SIZE_ON_SUBMIT =
-                SystemPropertyUtil.getBoolean("io.netty.transport.estimateSizeOnSubmit", true);
-
-        // Assuming a 64-bit JVM, 16 bytes object header, 3 reference fields and one int field, plus alignment
-        private static final int WRITE_TASK_OVERHEAD =
-                SystemPropertyUtil.getInt("io.netty.transport.writeTaskSizeOverhead", 48);
-
-        private ChannelHandlerContext ctx;
-        private Object msg;
-        private ChannelPromise promise;
-        private int size;
-
-        private static final Recycler<WriteTask> RECYCLER = new Recycler<WriteTask>() {
-            @Override
-            protected WriteTask newObject(Handle<WriteTask> handle) {
-                return new WriteTask(handle);
-            }
-        };
-
-        private static WriteTask newInstance(
-                ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
-            WriteTask task = RECYCLER.get();
-            task.ctx = ctx;
-            task.msg = msg;
-            task.promise = promise;
-
-            if (ESTIMATE_TASK_SIZE_ON_SUBMIT) {
-                ChannelOutboundBuffer buffer = ctx.channel().unsafe().outboundBuffer();
-
-                // Check for null as it may be set to null if the channel is closed already
-                if (buffer != null) {
-                    task.size = ((AbstractChannel) ctx.channel()).estimatorHandle().size(msg) + WRITE_TASK_OVERHEAD;
-                    buffer.incrementPendingOutboundBytes(task.size);
-                } else {
-                    task.size = 0;
-                }
-            } else {
-                task.size = 0;
-            }
-
-            return task;
-        }
-
-        private WriteTask(Recycler.Handle<WriteTask> handle) {
-            super(handle);
-        }
-
-        @Override
-        public void run() {
-            try {
-                ChannelOutboundBuffer buffer = ctx.channel().unsafe().outboundBuffer();
-                // Check for null as it may be set to null if the channel is closed already
-                if (ESTIMATE_TASK_SIZE_ON_SUBMIT && buffer != null) {
-                    buffer.decrementPendingOutboundBytes(size);
-                }
-                invokeWriteNow(ctx, msg, promise);
-            } finally {
-                // Set to null so the GC can collect them directly
-                ctx = null;
-                msg = null;
-                promise = null;
-            }
-        }
-
-        @Override
-        public SingleThreadEventLoop.NonWakeupRunnable value() {
-            return this;
-        }
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
index 5e56a9740694..54e0b28b15df 100644
--- a/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java
@@ -21,8 +21,8 @@
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.EventExecutorGroup;
 import io.netty.util.concurrent.FastThreadLocal;
+import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.OneTimeTask;
-import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.StringUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
@@ -36,18 +36,19 @@
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.WeakHashMap;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Future;
 import java.util.concurrent.RejectedExecutionException;
 
 /**
  * The default {@link ChannelPipeline} implementation.  It is usually created
  * by a {@link Channel} implementation when the {@link Channel} is created.
  */
-final class DefaultChannelPipeline implements ChannelPipeline {
+public class DefaultChannelPipeline implements ChannelPipeline {
 
     static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultChannelPipeline.class);
 
+    private static final String HEAD_NAME = generateName0(HeadContext.class);
+    private static final String TAIL_NAME = generateName0(TailContext.class);
+
     private static final FastThreadLocal<Map<Class<?>, String>> nameCaches =
             new FastThreadLocal<Map<Class<?>, String>>() {
         @Override
@@ -56,17 +57,16 @@ protected Map<Class<?>, String> initialValue() throws Exception {
         }
     };
 
-    final AbstractChannel channel;
-
     final AbstractChannelHandlerContext head;
     final AbstractChannelHandlerContext tail;
 
+    private final Channel channel;
+    private final ChannelFuture succeededFuture;
+    private final VoidChannelPromise voidPromise;
     private final boolean touch = ResourceLeakDetector.isEnabled();
 
-    /**
-     * @see #findInvoker(EventExecutorGroup)
-     */
-    private Map<EventExecutorGroup, ChannelHandlerInvoker> childInvokers;
+    private Map<EventExecutorGroup, EventExecutor> childExecutors;
+    private MessageSizeEstimator.Handle estimatorHandle;
 
     /**
      * This is the head of a linked list that is processed by {@link #callHandlerAddedForAllHandlers()} and so process
@@ -84,11 +84,10 @@ protected Map<Class<?>, String> initialValue() throws Exception {
      */
     private boolean registered;
 
-    DefaultChannelPipeline(AbstractChannel channel) {
-        if (channel == null) {
-            throw new NullPointerException("channel");
-        }
-        this.channel = channel;
+    protected DefaultChannelPipeline(Channel channel) {
+        this.channel = ObjectUtil.checkNotNull(channel, "channel");
+        succeededFuture = new SucceededChannelFuture(channel, null);
+        voidPromise =  new VoidChannelPromise(channel, true);
 
         tail = new TailContext(this);
         head = new HeadContext(this);
@@ -97,72 +96,82 @@ protected Map<Class<?>, String> initialValue() throws Exception {
         tail.prev = head;
     }
 
-    Object touch(Object msg, AbstractChannelHandlerContext next) {
+    final MessageSizeEstimator.Handle estimatorHandle() {
+        if (estimatorHandle == null) {
+            estimatorHandle = channel.config().getMessageSizeEstimator().newHandle();
+        }
+        return estimatorHandle;
+    }
+
+    final Object touch(Object msg, AbstractChannelHandlerContext next) {
         return touch ? ReferenceCountUtil.touch(msg, next) : msg;
     }
 
-    @Override
-    public Channel channel() {
-        return channel;
+    private AbstractChannelHandlerContext newContext(EventExecutorGroup group, String name, ChannelHandler handler) {
+        return new DefaultChannelHandlerContext(this, childExecutor(group), name, handler);
     }
 
-    @Override
-    public ChannelPipeline addFirst(String name, ChannelHandler handler) {
-        return addFirst(null, null, name, handler);
+    private EventExecutor childExecutor(EventExecutorGroup group) {
+        if (group == null) {
+            return null;
+        }
+        Map<EventExecutorGroup, EventExecutor> childExecutors = this.childExecutors;
+        if (childExecutors == null) {
+            // Use size of 4 as most people only use one extra EventExecutor.
+            childExecutors = this.childExecutors = new IdentityHashMap<EventExecutorGroup, EventExecutor>(4);
+        }
+        // Pin one of the child executors once and remember it so that the same child executor
+        // is used to fire events for the same channel.
+        EventExecutor childExecutor = childExecutors.get(group);
+        if (childExecutor == null) {
+            childExecutor = group.next();
+            childExecutors.put(group, childExecutor);
+        }
+        return childExecutor;
     }
 
     @Override
-    public ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler) {
-        return addFirst(group, null, name, handler);
+    public final Channel channel() {
+        return channel;
     }
 
     @Override
-    public ChannelPipeline addFirst(ChannelHandlerInvoker invoker, String name, ChannelHandler handler) {
-        return addFirst(null, invoker, name, handler);
+    public final ChannelPipeline addFirst(String name, ChannelHandler handler) {
+        return addFirst(null, name, handler);
     }
 
-    private ChannelPipeline addFirst(
-            EventExecutorGroup group, ChannelHandlerInvoker invoker, String name, ChannelHandler handler) {
+    @Override
+    public final ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler) {
         final AbstractChannelHandlerContext newCtx;
         final EventExecutor executor;
-        final boolean inEventLoop;
         synchronized (this) {
             checkMultiplicity(handler);
+            name = filterName(name, handler);
 
-            if (group != null) {
-                invoker = findInvoker(group);
-            }
+            newCtx = newContext(group, name, handler);
+            executor = executorSafe(newCtx.executor);
 
-            newCtx = new DefaultChannelHandlerContext(this, invoker, filterName(name, handler), handler);
-            executor = executorSafe(invoker);
+            addFirst0(newCtx);
 
             // If the executor is null it means that the channel was not registered on an eventloop yet.
             // In this case we add the context to the pipeline and add a task that will call
             // ChannelHandler.handlerAdded(...) once the channel is registered.
             if (executor == null) {
-                addFirst0(newCtx);
                 callHandlerCallbackLater(newCtx, true);
                 return this;
             }
-            inEventLoop = executor.inEventLoop();
-            if (inEventLoop) {
-                addFirst0(newCtx);
-            }
-        }
 
-        if (inEventLoop) {
-            callHandlerAdded0(newCtx);
-        } else {
-            waitForFuture(executor.submit(new OneTimeTask() {
-                @Override
-                public void run() {
-                    synchronized (DefaultChannelPipeline.this) {
-                        addFirst0(newCtx);
+            if (!executor.inEventLoop()) {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        callHandlerAdded0(newCtx);
                     }
-                    callHandlerAdded0(newCtx);
-                }
-            }));
+                });
+                return this;
+            }
         }
+        callHandlerAdded0(newCtx);
         return this;
     }
 
@@ -175,63 +184,40 @@ private void addFirst0(AbstractChannelHandlerContext newCtx) {
     }
 
     @Override
-    public ChannelPipeline addLast(String name, ChannelHandler handler) {
-        return addLast(null, null, name, handler);
-    }
-
-    @Override
-    public ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
-        return addLast(group, null, name, handler);
+    public final ChannelPipeline addLast(String name, ChannelHandler handler) {
+        return addLast(null, name, handler);
     }
 
     @Override
-    public ChannelPipeline addLast(ChannelHandlerInvoker invoker, String name, ChannelHandler handler) {
-        return addLast(null, invoker, name, handler);
-    }
-
-    private ChannelPipeline addLast(EventExecutorGroup group, ChannelHandlerInvoker invoker,
-                                    String name, ChannelHandler handler) {
-        assertGroupAndInvoker(group, invoker);
-
+    public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
         final EventExecutor executor;
         final AbstractChannelHandlerContext newCtx;
-        final boolean inEventLoop;
         synchronized (this) {
             checkMultiplicity(handler);
 
-            if (group != null) {
-                invoker = findInvoker(group);
-            }
+            newCtx = newContext(group, filterName(name, handler), handler);
+            executor = executorSafe(newCtx.executor);
 
-            newCtx = new DefaultChannelHandlerContext(this, invoker, filterName(name, handler), handler);
-            executor = executorSafe(invoker);
+            addLast0(newCtx);
 
             // If the executor is null it means that the channel was not registered on an eventloop yet.
             // In this case we add the context to the pipeline and add a task that will call
             // ChannelHandler.handlerAdded(...) once the channel is registered.
             if (executor == null) {
-                addLast0(newCtx);
                 callHandlerCallbackLater(newCtx, true);
                 return this;
             }
-            inEventLoop = executor.inEventLoop();
-            if (inEventLoop) {
-                addLast0(newCtx);
-            }
-        }
-        if (inEventLoop) {
-            callHandlerAdded0(newCtx);
-        } else {
-            waitForFuture(executor.submit(new OneTimeTask() {
-                @Override
-                public void run() {
-                    synchronized (DefaultChannelPipeline.this) {
-                        addLast0(newCtx);
+            if (!executor.inEventLoop()) {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        callHandlerAdded0(newCtx);
                     }
-                    callHandlerAdded0(newCtx);
-                }
-            }));
+                });
+                return this;
+            }
         }
+        callHandlerAdded0(newCtx);
         return this;
     }
 
@@ -244,69 +230,45 @@ private void addLast0(AbstractChannelHandlerContext newCtx) {
     }
 
     @Override
-    public ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler) {
-        return addBefore(null, null, baseName, name, handler);
+    public final ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler) {
+        return addBefore(null, baseName, name, handler);
     }
 
     @Override
-    public ChannelPipeline addBefore(
+    public final ChannelPipeline addBefore(
             EventExecutorGroup group, String baseName, String name, ChannelHandler handler) {
-        return addBefore(group, null, baseName, name, handler);
-    }
-
-    @Override
-    public ChannelPipeline addBefore(
-            ChannelHandlerInvoker invoker, String baseName, String name, ChannelHandler handler) {
-        return addBefore(null, invoker, baseName, name, handler);
-    }
-
-    private ChannelPipeline addBefore(EventExecutorGroup group,
-            ChannelHandlerInvoker invoker, String baseName, String name, ChannelHandler handler) {
-        assertGroupAndInvoker(group, invoker);
-
         final EventExecutor executor;
         final AbstractChannelHandlerContext newCtx;
         final AbstractChannelHandlerContext ctx;
-        final boolean inEventLoop;
         synchronized (this) {
             checkMultiplicity(handler);
+            name = filterName(name, handler);
             ctx = getContextOrDie(baseName);
 
-            if (group != null) {
-                invoker = findInvoker(group);
-            }
+            newCtx = newContext(group, name, handler);
+            executor = executorSafe(newCtx.executor);
 
-            newCtx = new DefaultChannelHandlerContext(this, invoker, filterName(name, handler), handler);
-            executor = executorSafe(invoker);
+            addBefore0(ctx, newCtx);
 
             // If the executor is null it means that the channel was not registered on an eventloop yet.
             // In this case we add the context to the pipeline and add a task that will call
             // ChannelHandler.handlerAdded(...) once the channel is registered.
             if (executor == null) {
-                addBefore0(ctx, newCtx);
                 callHandlerCallbackLater(newCtx, true);
                 return this;
             }
 
-            inEventLoop = executor.inEventLoop();
-            if (inEventLoop) {
-                addBefore0(ctx, newCtx);
-            }
-        }
-
-        if (inEventLoop) {
-            callHandlerAdded0(newCtx);
-        } else {
-            waitForFuture(executor.submit(new OneTimeTask() {
-                @Override
-                public void run() {
-                    synchronized (DefaultChannelPipeline.this) {
-                        addBefore0(ctx, newCtx);
+            if (!executor.inEventLoop()) {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        callHandlerAdded0(newCtx);
                     }
-                    callHandlerAdded0(newCtx);
-                }
-            }));
+                });
+                return this;
+            }
         }
+        callHandlerAdded0(newCtx);
         return this;
     }
 
@@ -317,69 +279,54 @@ private static void addBefore0(AbstractChannelHandlerContext ctx, AbstractChanne
         ctx.prev = newCtx;
     }
 
-    @Override
-    public ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler) {
-        return addAfter(null, null, baseName, name, handler);
+    private String filterName(String name, ChannelHandler handler) {
+        if (name == null) {
+            return generateName(handler);
+        }
+        checkDuplicateName(name);
+        return name;
     }
 
     @Override
-    public ChannelPipeline addAfter(
-            EventExecutorGroup group, String baseName, String name, ChannelHandler handler) {
-        return addAfter(group, null, baseName, name, handler);
+    public final ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler) {
+        return addAfter(null, baseName, name, handler);
     }
 
     @Override
-    public ChannelPipeline addAfter(
-            ChannelHandlerInvoker invoker, String baseName, String name, ChannelHandler handler) {
-        return addAfter(null, invoker, baseName, name, handler);
-    }
-
-    private ChannelPipeline addAfter(EventExecutorGroup group,
-            ChannelHandlerInvoker invoker, String baseName, String name, ChannelHandler handler) {
-        assertGroupAndInvoker(group, invoker);
-
+    public final ChannelPipeline addAfter(
+            EventExecutorGroup group, String baseName, String name, ChannelHandler handler) {
         final EventExecutor executor;
         final AbstractChannelHandlerContext newCtx;
         final AbstractChannelHandlerContext ctx;
-        final boolean inEventLoop;
 
         synchronized (this) {
             checkMultiplicity(handler);
+            name = filterName(name, handler);
             ctx = getContextOrDie(baseName);
 
-            if (group != null) {
-                invoker = findInvoker(group);
-            }
+            newCtx = newContext(group, name, handler);
+            executor = executorSafe(newCtx.executor);
 
-            newCtx = new DefaultChannelHandlerContext(this, invoker, filterName(name, handler), handler);
-            executor = executorSafe(invoker);
+            addAfter0(ctx, newCtx);
 
             // If the executor is null it means that the channel was not registered on an eventloop yet.
             // In this case we remove the context from the pipeline and add a task that will call
             // ChannelHandler.handlerRemoved(...) once the channel is registered.
             if (executor == null) {
-                addAfter0(ctx, newCtx);
                 callHandlerCallbackLater(newCtx, true);
                 return this;
             }
-            inEventLoop = executor.inEventLoop();
-            if (inEventLoop) {
-                addAfter0(ctx, newCtx);
-            }
-        }
-        if (inEventLoop) {
-            callHandlerAdded0(newCtx);
-        } else {
-            waitForFuture(executor.submit(new OneTimeTask() {
-                @Override
-                public void run() {
-                    synchronized (DefaultChannelPipeline.this) {
-                        addAfter0(ctx, newCtx);
+            if (!executor.inEventLoop()) {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        callHandlerAdded0(newCtx);
                     }
-                    callHandlerAdded0(newCtx);
-                }
-            }));
+                });
+                return this;
+            }
         }
+        callHandlerAdded0(newCtx);
         return this;
     }
 
@@ -391,12 +338,12 @@ private static void addAfter0(AbstractChannelHandlerContext ctx, AbstractChannel
     }
 
     @Override
-    public ChannelPipeline addFirst(ChannelHandler... handlers) {
-        return addFirst((ChannelHandlerInvoker) null, handlers);
+    public final ChannelPipeline addFirst(ChannelHandler... handlers) {
+        return addFirst(null, handlers);
     }
 
     @Override
-    public ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler... handlers) {
+    public final ChannelPipeline addFirst(EventExecutorGroup executor, ChannelHandler... handlers) {
         if (handlers == null) {
             throw new NullPointerException("handlers");
         }
@@ -413,43 +360,19 @@ public ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler... hand
 
         for (int i = size - 1; i >= 0; i --) {
             ChannelHandler h = handlers[i];
-            addFirst(group, null, h);
+            addFirst(executor, null, h);
         }
 
         return this;
     }
 
     @Override
-    public ChannelPipeline addFirst(ChannelHandlerInvoker invoker, ChannelHandler... handlers) {
-        if (handlers == null) {
-            throw new NullPointerException("handlers");
-        }
-        if (handlers.length == 0 || handlers[0] == null) {
-            return this;
-        }
-
-        int size;
-        for (size = 1; size < handlers.length; size ++) {
-            if (handlers[size] == null) {
-                break;
-            }
-        }
-
-        for (int i = size - 1; i >= 0; i --) {
-            ChannelHandler h = handlers[i];
-            addFirst(invoker, null, h);
-        }
-
-        return this;
+    public final ChannelPipeline addLast(ChannelHandler... handlers) {
+        return addLast(null, handlers);
     }
 
     @Override
-    public ChannelPipeline addLast(ChannelHandler... handlers) {
-        return addLast((ChannelHandlerInvoker) null, handlers);
-    }
-
-    @Override
-    public ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers) {
+    public final ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) {
         if (handlers == null) {
             throw new NullPointerException("handlers");
         }
@@ -458,55 +381,12 @@ public ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handl
             if (h == null) {
                 break;
             }
-            addLast(group, null, h);
+            addLast(executor, null, h);
         }
 
         return this;
     }
 
-    @Override
-    public ChannelPipeline addLast(ChannelHandlerInvoker invoker, ChannelHandler... handlers) {
-        if (handlers == null) {
-            throw new NullPointerException("handlers");
-        }
-
-        for (ChannelHandler h: handlers) {
-            if (h == null) {
-                break;
-            }
-            addLast(invoker, null, h);
-        }
-
-        return this;
-    }
-
-    private ChannelHandlerInvoker findInvoker(EventExecutorGroup group) {
-        if (group == null) {
-            return null;
-        }
-
-        // Lazily initialize the data structure that maps an EventExecutorGroup to a ChannelHandlerInvoker.
-        Map<EventExecutorGroup, ChannelHandlerInvoker> childInvokers = this.childInvokers;
-        if (childInvokers == null) {
-            childInvokers = this.childInvokers = new IdentityHashMap<EventExecutorGroup, ChannelHandlerInvoker>(4);
-        }
-
-        // Pick one of the child executors and remember its invoker
-        // so that the same invoker is used to fire events for the same channel.
-        ChannelHandlerInvoker  invoker = childInvokers.get(group);
-        if (invoker == null) {
-            EventExecutor executor = group.next();
-            if (executor instanceof EventLoop) {
-                invoker = ((EventLoop) executor).asInvoker();
-            } else {
-                invoker = new DefaultChannelHandlerInvoker(executor);
-            }
-            childInvokers.put(group, invoker);
-        }
-
-        return invoker;
-    }
-
     private String generateName(ChannelHandler handler) {
         Map<Class<?>, String> cache = nameCaches.get();
         Class<?> handlerType = handler.getClass();
@@ -536,19 +416,19 @@ private static String generateName0(Class<?> handlerType) {
     }
 
     @Override
-    public ChannelPipeline remove(ChannelHandler handler) {
+    public final ChannelPipeline remove(ChannelHandler handler) {
         remove(getContextOrDie(handler));
         return this;
     }
 
     @Override
-    public ChannelHandler remove(String name) {
+    public final ChannelHandler remove(String name) {
         return remove(getContextOrDie(name)).handler();
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public <T extends ChannelHandler> T remove(Class<T> handlerType) {
+    public final <T extends ChannelHandler> T remove(Class<T> handlerType) {
         return (T) remove(getContextOrDie(handlerType)).handler();
     }
 
@@ -556,36 +436,30 @@ private AbstractChannelHandlerContext remove(final AbstractChannelHandlerContext
         assert ctx != head && ctx != tail;
 
         final EventExecutor executor;
-        final boolean inEventLoop;
         synchronized (this) {
-            executor = executorSafe(ctx.invoker);
+            executor = executorSafe(ctx.executor);
+
+            remove0(ctx);
 
             // If the executor is null it means that the channel was not registered on an eventloop yet.
             // In this case we remove the context from the pipeline and add a task that will call
             // ChannelHandler.handlerRemoved(...) once the channel is registered.
             if (executor == null) {
-                remove0(ctx);
                 callHandlerCallbackLater(ctx, false);
                 return ctx;
             }
-            inEventLoop = executor.inEventLoop();
-            if (inEventLoop) {
-                remove0(ctx);
-            }
-        }
-        if (inEventLoop) {
-            callHandlerRemoved0(ctx);
-        } else {
-            waitForFuture(executor.submit(new OneTimeTask() {
-                @Override
-                public void run() {
-                    synchronized (DefaultChannelPipeline.this) {
-                        remove0(ctx);
+
+            if (!executor.inEventLoop()) {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        callHandlerRemoved0(ctx);
                     }
-                    callHandlerRemoved0(ctx);
-                }
-            }));
+                });
+                return ctx;
+            }
         }
+        callHandlerRemoved0(ctx);
         return ctx;
     }
 
@@ -597,7 +471,7 @@ private static void remove0(AbstractChannelHandlerContext ctx) {
     }
 
     @Override
-    public ChannelHandler removeFirst() {
+    public final ChannelHandler removeFirst() {
         if (head.next == tail) {
             throw new NoSuchElementException();
         }
@@ -605,7 +479,7 @@ public ChannelHandler removeFirst() {
     }
 
     @Override
-    public ChannelHandler removeLast() {
+    public final ChannelHandler removeLast() {
         if (head.next == tail) {
             throw new NoSuchElementException();
         }
@@ -613,19 +487,19 @@ public ChannelHandler removeLast() {
     }
 
     @Override
-    public ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler) {
+    public final ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler) {
         replace(getContextOrDie(oldHandler), newName, newHandler);
         return this;
     }
 
     @Override
-    public ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler) {
+    public final ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler) {
         return replace(getContextOrDie(oldName), newName, newHandler);
     }
 
     @Override
     @SuppressWarnings("unchecked")
-    public <T extends ChannelHandler> T replace(
+    public final <T extends ChannelHandler> T replace(
             Class<T> oldHandlerType, String newName, ChannelHandler newHandler) {
         return (T) replace(getContextOrDie(oldHandlerType), newName, newHandler);
     }
@@ -636,55 +510,50 @@ private ChannelHandler replace(
 
         final AbstractChannelHandlerContext newCtx;
         final EventExecutor executor;
-        final boolean inEventLoop;
         synchronized (this) {
             checkMultiplicity(newHandler);
-
             if (newName == null) {
-                newName = ctx.name();
-            } else if (!ctx.name().equals(newName)) {
-                newName = filterName(newName, newHandler);
+                newName = generateName(newHandler);
+            } else {
+                boolean sameName = ctx.name().equals(newName);
+                if (!sameName) {
+                    checkDuplicateName(newName);
+                }
             }
 
-            newCtx = new DefaultChannelHandlerContext(this, ctx.invoker, newName, newHandler);
-            executor = executorSafe(ctx.invoker);
+            newCtx = newContext(ctx.executor, newName, newHandler);
+            executor = executorSafe(ctx.executor);
+
+            replace0(ctx, newCtx);
 
             // If the executor is null it means that the channel was not registered on an eventloop yet.
             // In this case we replace the context in the pipeline
             // and add a task that will call ChannelHandler.handlerAdded(...) and
             // ChannelHandler.handlerRemoved(...) once the channel is registered.
             if (executor == null) {
-                replace0(ctx, newCtx);
                 callHandlerCallbackLater(newCtx, true);
                 callHandlerCallbackLater(ctx, false);
                 return ctx.handler();
             }
-            inEventLoop = executor.inEventLoop();
-            if (inEventLoop) {
-                replace0(ctx, newCtx);
-            }
-        }
-        if (inEventLoop) {
-            // Invoke newHandler.handlerAdded() first (i.e. before oldHandler.handlerRemoved() is invoked)
-            // because callHandlerRemoved() will trigger channelRead() or flush() on newHandler and those
-            // event handlers must be called after handlerAdded().
-            callHandlerAdded0(newCtx);
-            callHandlerRemoved0(ctx);
-        } else {
-            waitForFuture(executor.submit(new OneTimeTask() {
-                @Override
-                public void run() {
-                    synchronized (DefaultChannelPipeline.this) {
-                        replace0(ctx, newCtx);
+            if (!executor.inEventLoop()) {
+                executor.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        // Invoke newHandler.handlerAdded() first (i.e. before oldHandler.handlerRemoved() is invoked)
+                        // because callHandlerRemoved() will trigger channelRead() or flush() on newHandler and
+                        // those event handlers must be called after handlerAdded().
+                        callHandlerAdded0(newCtx);
+                        callHandlerRemoved0(ctx);
                     }
-                    // Invoke newHandler.handlerAdded() first (i.e. before oldHandler.handlerRemoved() is invoked)
-                    // because callHandlerRemoved() will trigger channelRead() or flush() on newHandler and
-                    // those event handlers must be called after handlerAdded().
-                    callHandlerAdded0(newCtx);
-                    callHandlerRemoved0(ctx);
-                }
-            }));
+                });
+                return ctx.handler();
+            }
         }
+        // Invoke newHandler.handlerAdded() first (i.e. before oldHandler.handlerRemoved() is invoked)
+        // because callHandlerRemoved() will trigger channelRead() or flush() on newHandler and those
+        // event handlers must be called after handlerAdded().
+        callHandlerAdded0(newCtx);
+        callHandlerRemoved0(ctx);
         return ctx.handler();
     }
 
@@ -721,6 +590,7 @@ private static void checkMultiplicity(ChannelHandler handler) {
     private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
         try {
             ctx.handler().handlerAdded(ctx);
+            ctx.setAdded();
         } catch (Throwable t) {
             boolean removed = false;
             try {
@@ -763,35 +633,8 @@ private void callHandlerRemoved0(final AbstractChannelHandlerContext ctx) {
         }
     }
 
-    /**
-     * Waits for a future to finish.  If the task is interrupted, then the current thread will be interrupted.
-     * It is expected that the task performs any appropriate locking.
-     * <p>
-     * If the internal call throws a {@link Throwable}, but it is not an instance of {@link Error} or
-     * {@link RuntimeException}, then it is wrapped inside a {@link ChannelPipelineException} and that is
-     * thrown instead.</p>
-     *
-     * @param future wait for this future
-     * @see Future#get()
-     * @throws Error if the task threw this.
-     * @throws RuntimeException if the task threw this.
-     * @throws ChannelPipelineException with a {@link Throwable} as a cause, if the task threw another type of
-     *         {@link Throwable}.
-     */
-    private static void waitForFuture(Future<?> future) {
-        try {
-            future.get();
-        } catch (ExecutionException ex) {
-            // In the arbitrary case, we can throw Error, RuntimeException, and Exception
-            PlatformDependent.throwException(ex.getCause());
-        } catch (InterruptedException ex) {
-            // Interrupt the calling thread (note that this method is not called from the event loop)
-            Thread.currentThread().interrupt();
-        }
-    }
-
     @Override
-    public ChannelHandler first() {
+    public final ChannelHandler first() {
         ChannelHandlerContext first = firstContext();
         if (first == null) {
             return null;
@@ -800,7 +643,7 @@ public ChannelHandler first() {
     }
 
     @Override
-    public ChannelHandlerContext firstContext() {
+    public final ChannelHandlerContext firstContext() {
         AbstractChannelHandlerContext first = head.next;
         if (first == tail) {
             return null;
@@ -809,7 +652,7 @@ public ChannelHandlerContext firstContext() {
     }
 
     @Override
-    public ChannelHandler last() {
+    public final ChannelHandler last() {
         AbstractChannelHandlerContext last = tail.prev;
         if (last == head) {
             return null;
@@ -818,7 +661,7 @@ public ChannelHandler last() {
     }
 
     @Override
-    public ChannelHandlerContext lastContext() {
+    public final ChannelHandlerContext lastContext() {
         AbstractChannelHandlerContext last = tail.prev;
         if (last == head) {
             return null;
@@ -827,7 +670,7 @@ public ChannelHandlerContext lastContext() {
     }
 
     @Override
-    public ChannelHandler get(String name) {
+    public final ChannelHandler get(String name) {
         ChannelHandlerContext ctx = context(name);
         if (ctx == null) {
             return null;
@@ -838,7 +681,7 @@ public ChannelHandler get(String name) {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <T extends ChannelHandler> T get(Class<T> handlerType) {
+    public final <T extends ChannelHandler> T get(Class<T> handlerType) {
         ChannelHandlerContext ctx = context(handlerType);
         if (ctx == null) {
             return null;
@@ -848,7 +691,7 @@ public <T extends ChannelHandler> T get(Class<T> handlerType) {
     }
 
     @Override
-    public ChannelHandlerContext context(String name) {
+    public final ChannelHandlerContext context(String name) {
         if (name == null) {
             throw new NullPointerException("name");
         }
@@ -857,7 +700,7 @@ public ChannelHandlerContext context(String name) {
     }
 
     @Override
-    public ChannelHandlerContext context(ChannelHandler handler) {
+    public final ChannelHandlerContext context(ChannelHandler handler) {
         if (handler == null) {
             throw new NullPointerException("handler");
         }
@@ -878,7 +721,7 @@ public ChannelHandlerContext context(ChannelHandler handler) {
     }
 
     @Override
-    public ChannelHandlerContext context(Class<? extends ChannelHandler> handlerType) {
+    public final ChannelHandlerContext context(Class<? extends ChannelHandler> handlerType) {
         if (handlerType == null) {
             throw new NullPointerException("handlerType");
         }
@@ -896,7 +739,7 @@ public ChannelHandlerContext context(Class<? extends ChannelHandler> handlerType
     }
 
     @Override
-    public List<String> names() {
+    public final List<String> names() {
         List<String> list = new ArrayList<String>();
         AbstractChannelHandlerContext ctx = head.next;
         for (;;) {
@@ -909,7 +752,7 @@ public List<String> names() {
     }
 
     @Override
-    public Map<String, ChannelHandler> toMap() {
+    public final Map<String, ChannelHandler> toMap() {
         Map<String, ChannelHandler> map = new LinkedHashMap<String, ChannelHandler>();
         AbstractChannelHandlerContext ctx = head.next;
         for (;;) {
@@ -922,7 +765,7 @@ public Map<String, ChannelHandler> toMap() {
     }
 
     @Override
-    public Iterator<Map.Entry<String, ChannelHandler>> iterator() {
+    public final Iterator<Map.Entry<String, ChannelHandler>> iterator() {
         return toMap().entrySet().iterator();
     }
 
@@ -930,7 +773,7 @@ public Iterator<Map.Entry<String, ChannelHandler>> iterator() {
      * Returns the {@link String} representation of this pipeline.
      */
     @Override
-    public String toString() {
+    public final String toString() {
         StringBuilder buf = new StringBuilder()
             .append(StringUtil.simpleClassName(this))
             .append('{');
@@ -958,19 +801,14 @@ public String toString() {
     }
 
     @Override
-    public ChannelPipeline fireChannelRegistered() {
-        head.fireChannelRegistered();
+    public final ChannelPipeline fireChannelRegistered() {
+        AbstractChannelHandlerContext.invokeChannelRegistered(head);
         return this;
     }
 
     @Override
-    public ChannelPipeline fireChannelUnregistered() {
-        head.fireChannelUnregistered();
-
-        // Remove all handlers sequentially if channel is closed and unregistered.
-        if (!channel.isOpen()) {
-            destroy();
-        }
+    public final ChannelPipeline fireChannelUnregistered() {
+        AbstractChannelHandlerContext.invokeChannelUnregistered(head);
         return this;
     }
 
@@ -1045,157 +883,169 @@ public void run() {
     }
 
     @Override
-    public ChannelPipeline fireChannelActive() {
-        head.fireChannelActive();
-
-        if (channel.config().isAutoRead()) {
-            channel.read();
-        }
-
+    public final ChannelPipeline fireChannelActive() {
+        AbstractChannelHandlerContext.invokeChannelActive(head);
         return this;
     }
 
     @Override
-    public ChannelPipeline fireChannelInactive() {
-        head.fireChannelInactive();
+    public final ChannelPipeline fireChannelInactive() {
+        AbstractChannelHandlerContext.invokeChannelInactive(head);
         return this;
     }
 
     @Override
-    public ChannelPipeline fireExceptionCaught(Throwable cause) {
-        head.fireExceptionCaught(cause);
+    public final ChannelPipeline fireExceptionCaught(Throwable cause) {
+        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);
         return this;
     }
 
     @Override
-    public ChannelPipeline fireUserEventTriggered(Object event) {
-        head.fireUserEventTriggered(event);
+    public final ChannelPipeline fireUserEventTriggered(Object event) {
+        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);
         return this;
     }
 
     @Override
-    public ChannelPipeline fireChannelRead(Object msg) {
-        head.fireChannelRead(msg);
+    public final ChannelPipeline fireChannelRead(Object msg) {
+        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
         return this;
     }
 
     @Override
-    public ChannelPipeline fireChannelReadComplete() {
-        head.fireChannelReadComplete();
-        if (channel.config().isAutoRead()) {
-            read();
-        }
+    public final ChannelPipeline fireChannelReadComplete() {
+        AbstractChannelHandlerContext.invokeChannelReadComplete(head);
         return this;
     }
 
     @Override
-    public ChannelPipeline fireChannelWritabilityChanged() {
-        head.fireChannelWritabilityChanged();
+    public final ChannelPipeline fireChannelWritabilityChanged() {
+        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);
         return this;
     }
 
     @Override
-    public ChannelFuture bind(SocketAddress localAddress) {
+    public final ChannelFuture bind(SocketAddress localAddress) {
         return tail.bind(localAddress);
     }
 
     @Override
-    public ChannelFuture connect(SocketAddress remoteAddress) {
+    public final ChannelFuture connect(SocketAddress remoteAddress) {
         return tail.connect(remoteAddress);
     }
 
     @Override
-    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {
+    public final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {
         return tail.connect(remoteAddress, localAddress);
     }
 
     @Override
-    public ChannelFuture disconnect() {
+    public final ChannelFuture disconnect() {
         return tail.disconnect();
     }
 
     @Override
-    public ChannelFuture close() {
+    public final ChannelFuture close() {
         return tail.close();
     }
 
     @Override
-    public ChannelFuture deregister() {
+    public final ChannelFuture deregister() {
         return tail.deregister();
     }
 
     @Override
-    public ChannelPipeline flush() {
+    public final ChannelPipeline flush() {
         tail.flush();
         return this;
     }
 
     @Override
-    public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
+    public final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
         return tail.bind(localAddress, promise);
     }
 
     @Override
-    public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
+    public final ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
         return tail.connect(remoteAddress, promise);
     }
 
     @Override
-    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
+    public final ChannelFuture connect(
+            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
         return tail.connect(remoteAddress, localAddress, promise);
     }
 
     @Override
-    public ChannelFuture disconnect(ChannelPromise promise) {
+    public final ChannelFuture disconnect(ChannelPromise promise) {
         return tail.disconnect(promise);
     }
 
     @Override
-    public ChannelFuture close(ChannelPromise promise) {
+    public final ChannelFuture close(ChannelPromise promise) {
         return tail.close(promise);
     }
 
     @Override
-    public ChannelFuture deregister(ChannelPromise promise) {
+    public final ChannelFuture deregister(final ChannelPromise promise) {
         return tail.deregister(promise);
     }
 
     @Override
-    public ChannelPipeline read() {
+    public final ChannelPipeline read() {
         tail.read();
         return this;
     }
 
     @Override
-    public ChannelFuture write(Object msg) {
+    public final ChannelFuture write(Object msg) {
         return tail.write(msg);
     }
 
     @Override
-    public ChannelFuture write(Object msg, ChannelPromise promise) {
+    public final ChannelFuture write(Object msg, ChannelPromise promise) {
         return tail.write(msg, promise);
     }
 
     @Override
-    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
+    public final ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
         return tail.writeAndFlush(msg, promise);
     }
 
     @Override
-    public ChannelFuture writeAndFlush(Object msg) {
+    public final ChannelFuture writeAndFlush(Object msg) {
         return tail.writeAndFlush(msg);
     }
 
-    private String filterName(String name, ChannelHandler handler) {
-        if (name == null) {
-            return generateName(handler);
-        }
+    @Override
+    public final ChannelPromise newPromise() {
+        return new DefaultChannelPromise(channel);
+    }
 
-        if (context0(name) == null) {
-            return name;
-        }
+    @Override
+    public final ChannelProgressivePromise newProgressivePromise() {
+        return new DefaultChannelProgressivePromise(channel);
+    }
+
+    @Override
+    public final ChannelFuture newSucceededFuture() {
+        return succeededFuture;
+    }
+
+    @Override
+    public final ChannelFuture newFailedFuture(Throwable cause) {
+        return new FailedChannelFuture(channel, null, cause);
+    }
+
+    @Override
+    public final ChannelPromise voidPromise() {
+        return voidPromise;
+    }
 
-        throw new IllegalArgumentException("Duplicate handler name: " + name);
+    private void checkDuplicateName(String name) {
+        if (context0(name) != null) {
+            throw new IllegalArgumentException("Duplicate handler name: " + name);
+        }
     }
 
     private AbstractChannelHandlerContext context0(String name) {
@@ -1236,13 +1086,7 @@ private AbstractChannelHandlerContext getContextOrDie(Class<? extends ChannelHan
         }
     }
 
-    /**
-     * Should be called before {@link #fireChannelRegistered()} is called the first time.
-     */
-    void callHandlerAddedForAllHandlers() {
-        // This should only called from within the EventLoop.
-        assert channel.eventLoop().inEventLoop();
-
+    private void callHandlerAddedForAllHandlers() {
         final PendingHandlerCallback pendingHandlerCallbackHead;
         synchronized (this) {
             assert !registered;
@@ -1281,27 +1125,52 @@ private void callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean
         }
     }
 
-    private EventExecutor executorSafe(ChannelHandlerInvoker invoker) {
-        if (invoker == null) {
+    private EventExecutor executorSafe(EventExecutor eventExecutor) {
+        if (eventExecutor == null) {
             // We check for channel().isRegistered and handlerAdded because even if isRegistered() is false we
-            // can safely access the invoker() if handlerAdded is true. This is because in this case the Channel
+            // can safely access the eventLoop() if handlerAdded is true. This is because in this case the Channel
             // was previously registered and so we can still access the old EventLoop to dispatch things.
-            return channel.isRegistered() || registered ? channel.unsafe().invoker().executor() : null;
+            return channel.isRegistered() || registered ? channel.eventLoop() : null;
         }
-        return invoker.executor();
+        return eventExecutor;
     }
 
-    private static void assertGroupAndInvoker(EventExecutorGroup group, ChannelHandlerInvoker invoker) {
-        assert group == null || invoker == null : "either group or invoker must be null";
+    /**
+     * Called once a {@link Throwable} hit the end of the {@link ChannelPipeline} without been handled by the user
+     * in {@link ChannelHandler#exceptionCaught(ChannelHandlerContext, Throwable)}.
+     */
+    protected void onUnhandledInboundException(Throwable cause) {
+        try {
+            logger.warn(
+                    "An exceptionCaught() event was fired, and it reached at the tail of the pipeline. " +
+                            "It usually means the last handler in the pipeline did not handle the exception.",
+                    cause);
+        } finally {
+            ReferenceCountUtil.release(cause);
+        }
     }
 
-    // A special catch-all handler that handles both bytes and messages.
-    static final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
+    /**
+     * Called once a message hit the end of the {@link ChannelPipeline} without been handled by the user
+     * in {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)}. This method is responsible
+     * to call {@link ReferenceCountUtil#release(Object)} on the given msg at some point.
+     */
+    protected void onUnhandledInboundMessage(Object msg) {
+        try {
+            logger.debug(
+                    "Discarded inbound message {} that reached at the tail of the pipeline. " +
+                            "Please check your pipeline configuration.", msg);
+        } finally {
+            ReferenceCountUtil.release(msg);
+        }
+    }
 
-        private static final String TAIL_NAME = generateName0(TailContext.class);
+    // A special catch-all handler that handles both bytes and messages.
+    final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
 
         TailContext(DefaultChannelPipeline pipeline) {
             super(pipeline, null, TAIL_NAME, true, false);
+            setAdded();
         }
 
         @Override
@@ -1339,40 +1208,28 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
 
         @Override
         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-            try {
-                logger.warn(
-                        "An exceptionCaught() event was fired, and it reached at the tail of the pipeline. " +
-                                "It usually means the last handler in the pipeline did not handle the exception.",
-                                cause);
-            } finally {
-                ReferenceCountUtil.release(cause);
-            }
+            onUnhandledInboundException(cause);
         }
 
         @Override
         public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-            try {
-                logger.debug(
-                        "Discarded inbound message {} that reached at the tail of the pipeline. " +
-                                "Please check your pipeline configuration.", msg);
-            } finally {
-                ReferenceCountUtil.release(msg);
-            }
+            onUnhandledInboundMessage(msg);
         }
 
         @Override
         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { }
     }
 
-    static final class HeadContext extends AbstractChannelHandlerContext implements ChannelOutboundHandler {
-
-        private static final String HEAD_NAME = generateName0(HeadContext.class);
+    final class HeadContext extends AbstractChannelHandlerContext
+            implements ChannelOutboundHandler, ChannelInboundHandler {
 
         private final Unsafe unsafe;
+        private boolean firstRegistration = true;
 
         HeadContext(DefaultChannelPipeline pipeline) {
             super(pipeline, null, HEAD_NAME, false, true);
             unsafe = pipeline.channel().unsafe();
+            setAdded();
         }
 
         @Override
@@ -1381,14 +1238,13 @@ public ChannelHandler handler() {
         }
 
         @Override
-        public void handlerAdded(ChannelHandlerContext ctx) throws Exception { }
-
-        @Override
-        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception { }
+        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+            // NOOP
+        }
 
         @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-            ctx.fireExceptionCaught(cause);
+        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+            // NOOP
         }
 
         @Override
@@ -1435,6 +1291,73 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         public void flush(ChannelHandlerContext ctx) throws Exception {
             unsafe.flush();
         }
+
+        @Override
+        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+            ctx.fireExceptionCaught(cause);
+        }
+
+        @Override
+        public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
+            if (firstRegistration) {
+                firstRegistration = false;
+                // We are now registered to the EventLoop. It's time to call the callbacks for the ChannelHandlers,
+                // that were added before the registration was done.
+                callHandlerAddedForAllHandlers();
+            }
+
+            ctx.fireChannelRegistered();
+        }
+
+        @Override
+        public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
+            ctx.fireChannelUnregistered();
+
+            // Remove all handlers sequentially if channel is closed and unregistered.
+            if (!channel.isOpen()) {
+                destroy();
+            }
+        }
+
+        @Override
+        public void channelActive(ChannelHandlerContext ctx) throws Exception {
+            ctx.fireChannelActive();
+
+            readIfIsAutoRead();
+        }
+
+        @Override
+        public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+            ctx.fireChannelInactive();
+        }
+
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            ctx.fireChannelRead(msg);
+        }
+
+        @Override
+        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+            ctx.fireChannelReadComplete();
+
+            readIfIsAutoRead();
+        }
+
+        private void readIfIsAutoRead() {
+            if (channel.config().isAutoRead()) {
+                channel.read();
+            }
+        }
+
+        @Override
+        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
+            ctx.fireUserEventTriggered(evt);
+        }
+
+        @Override
+        public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
+            ctx.fireChannelWritabilityChanged();
+        }
     }
 
     private abstract static class PendingHandlerCallback extends OneTimeTask {
diff --git a/transport/src/main/java/io/netty/channel/EventLoop.java b/transport/src/main/java/io/netty/channel/EventLoop.java
index e0dccf43bc8f..f434209a058d 100644
--- a/transport/src/main/java/io/netty/channel/EventLoop.java
+++ b/transport/src/main/java/io/netty/channel/EventLoop.java
@@ -27,10 +27,4 @@
 public interface EventLoop extends EventExecutor, EventLoopGroup {
     @Override
     EventLoopGroup parent();
-
-    /**
-     * Creates a new default {@link ChannelHandlerInvoker} implementation that uses this {@link EventLoop} to
-     * invoke event handler methods.
-     */
-    ChannelHandlerInvoker asInvoker();
 }
diff --git a/transport/src/main/java/io/netty/channel/EventLoopGroup.java b/transport/src/main/java/io/netty/channel/EventLoopGroup.java
index e2bf7c2c0af0..3e390e822300 100644
--- a/transport/src/main/java/io/netty/channel/EventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/EventLoopGroup.java
@@ -35,9 +35,18 @@ public interface EventLoopGroup extends EventExecutorGroup {
      */
     ChannelFuture register(Channel channel);
 
+    /**
+     * Register a {@link Channel} with this {@link EventLoop} using a {@link ChannelFuture}. The passed
+     * {@link ChannelFuture} will get notified once the registration was complete and also will get returned.
+     */
+    ChannelFuture register(ChannelPromise promise);
+
     /**
      * Register a {@link Channel} with this {@link EventLoop}. The passed {@link ChannelFuture}
      * will get notified once the registration was complete and also will get returned.
+     *
+     * @deprecated Use {@link #register(ChannelPromise)} instead.
      */
+    @Deprecated
     ChannelFuture register(Channel channel, ChannelPromise promise);
 }
diff --git a/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
index aae17b4505ed..327bc16dd58f 100644
--- a/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java
@@ -75,6 +75,12 @@ public ChannelFuture register(Channel channel) {
         return next().register(channel);
     }
 
+    @Override
+    public ChannelFuture register(ChannelPromise promise) {
+        return next().register(promise);
+    }
+
+    @Deprecated
     @Override
     public ChannelFuture register(Channel channel, ChannelPromise promise) {
         return next().register(channel, promise);
diff --git a/transport/src/main/java/io/netty/channel/PendingWriteQueue.java b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java
index 3a49baaaa3ca..40566f249f64 100644
--- a/transport/src/main/java/io/netty/channel/PendingWriteQueue.java
+++ b/transport/src/main/java/io/netty/channel/PendingWriteQueue.java
@@ -280,18 +280,18 @@ private static void safeFail(ChannelPromise promise, Throwable cause) {
     static final class PendingWrite {
         private static final Recycler<PendingWrite> RECYCLER = new Recycler<PendingWrite>() {
             @Override
-            protected PendingWrite newObject(Handle handle) {
+            protected PendingWrite newObject(Handle<PendingWrite> handle) {
                 return new PendingWrite(handle);
             }
         };
 
-        private final Recycler.Handle handle;
+        private final Recycler.Handle<PendingWrite> handle;
         private PendingWrite next;
         private long size;
         private ChannelPromise promise;
         private Object msg;
 
-        private PendingWrite(Recycler.Handle handle) {
+        private PendingWrite(Recycler.Handle<PendingWrite> handle) {
             this.handle = handle;
         }
 
@@ -308,7 +308,7 @@ private void recycle() {
             next = null;
             msg = null;
             promise = null;
-            RECYCLER.recycle(this, handle);
+            handle.recycle(this);
         }
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
index 81cc3dbaefad..b041538ad7b7 100644
--- a/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java
@@ -16,6 +16,7 @@
 package io.netty.channel;
 
 import io.netty.util.concurrent.SingleThreadEventExecutor;
+import io.netty.util.internal.ObjectUtil;
 
 import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
@@ -26,8 +27,6 @@
  */
 public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop {
 
-    private final ChannelHandlerInvoker invoker = new DefaultChannelHandlerInvoker(this);
-
     protected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) {
         super(parent, threadFactory, addTaskWakesUp);
     }
@@ -47,15 +46,18 @@ public EventLoop next() {
     }
 
     @Override
-    public ChannelHandlerInvoker asInvoker() {
-        return invoker;
+    public ChannelFuture register(Channel channel) {
+        return register(new DefaultChannelPromise(channel, this));
     }
 
     @Override
-    public ChannelFuture register(Channel channel) {
-        return register(channel, new DefaultChannelPromise(channel, this));
+    public ChannelFuture register(final ChannelPromise promise) {
+        ObjectUtil.checkNotNull(promise, "promise");
+        promise.channel().unsafe().register(this, promise);
+        return promise;
     }
 
+    @Deprecated
     @Override
     public ChannelFuture register(final Channel channel, final ChannelPromise promise) {
         if (channel == null) {
diff --git a/transport/src/main/java/io/netty/channel/ThreadLocalPooledDirectByteBuf.java b/transport/src/main/java/io/netty/channel/ThreadLocalPooledDirectByteBuf.java
deleted file mode 100644
index 7790e1492205..000000000000
--- a/transport/src/main/java/io/netty/channel/ThreadLocalPooledDirectByteBuf.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright 2013 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-/*
- * Written by Josh Bloch of Google Inc. and released to the public domain,
- * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
- */
-package io.netty.channel;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.UnpooledByteBufAllocator;
-import io.netty.buffer.UnpooledDirectByteBuf;
-import io.netty.buffer.UnpooledUnsafeDirectByteBuf;
-import io.netty.util.Recycler;
-import io.netty.util.internal.PlatformDependent;
-import io.netty.util.internal.SystemPropertyUtil;
-import io.netty.util.internal.logging.InternalLogger;
-import io.netty.util.internal.logging.InternalLoggerFactory;
-
-final class ThreadLocalPooledDirectByteBuf {
-    private static final InternalLogger logger =
-            InternalLoggerFactory.getInstance(ThreadLocalPooledDirectByteBuf.class);
-    public static final int threadLocalDirectBufferSize;
-
-    static {
-        threadLocalDirectBufferSize = SystemPropertyUtil.getInt("io.netty.threadLocalDirectBufferSize", 64 * 1024);
-        logger.debug("-Dio.netty.threadLocalDirectBufferSize: {}", threadLocalDirectBufferSize);
-    }
-
-    public static ByteBuf newInstance() {
-        if (PlatformDependent.hasUnsafe()) {
-            return ThreadLocalUnsafeDirectByteBuf.newInstance();
-        } else {
-            return ThreadLocalDirectByteBuf.newInstance();
-        }
-    }
-
-    private ThreadLocalPooledDirectByteBuf() {
-        // utility
-    }
-
-    static final class ThreadLocalUnsafeDirectByteBuf extends UnpooledUnsafeDirectByteBuf {
-
-        private static final Recycler<ThreadLocalUnsafeDirectByteBuf> RECYCLER =
-                new Recycler<ThreadLocalUnsafeDirectByteBuf>() {
-            @Override
-            protected ThreadLocalUnsafeDirectByteBuf newObject(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {
-                return new ThreadLocalUnsafeDirectByteBuf(handle);
-            }
-        };
-
-        static ThreadLocalUnsafeDirectByteBuf newInstance() {
-            ThreadLocalUnsafeDirectByteBuf buf = RECYCLER.get();
-            buf.setRefCnt(1);
-            return buf;
-        }
-
-        private final Recycler.Handle<ThreadLocalUnsafeDirectByteBuf> handle;
-
-        private ThreadLocalUnsafeDirectByteBuf(Recycler.Handle<ThreadLocalUnsafeDirectByteBuf> handle) {
-            super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);
-            this.handle = handle;
-        }
-
-        @Override
-        protected void deallocate() {
-            if (capacity() > threadLocalDirectBufferSize) {
-                super.deallocate();
-            } else {
-                clear();
-                RECYCLER.recycle(this, handle);
-            }
-        }
-    }
-
-    static final class ThreadLocalDirectByteBuf extends UnpooledDirectByteBuf {
-
-        private static final Recycler<ThreadLocalDirectByteBuf> RECYCLER = new Recycler<ThreadLocalDirectByteBuf>() {
-            @Override
-            protected ThreadLocalDirectByteBuf newObject(Handle<ThreadLocalDirectByteBuf> handle) {
-                return new ThreadLocalDirectByteBuf(handle);
-            }
-        };
-
-        static ThreadLocalDirectByteBuf newInstance() {
-            ThreadLocalDirectByteBuf buf = RECYCLER.get();
-            buf.setRefCnt(1);
-            return buf;
-        }
-
-        private final Recycler.Handle<ThreadLocalDirectByteBuf> handle;
-
-        private ThreadLocalDirectByteBuf(Recycler.Handle<ThreadLocalDirectByteBuf> handle) {
-            super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);
-            this.handle = handle;
-        }
-
-        @Override
-        protected void deallocate() {
-            if (capacity() > threadLocalDirectBufferSize) {
-                super.deallocate();
-            } else {
-                clear();
-                RECYCLER.recycle(this, handle);
-            }
-        }
-    }
-}
diff --git a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
index c73f36a929c6..b10d79de7eb1 100644
--- a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java
@@ -30,6 +30,21 @@ public ThreadPerChannelEventLoop(ThreadPerChannelEventLoopGroup parent) {
         this.parent = parent;
     }
 
+    @Override
+    public ChannelFuture register(ChannelPromise promise) {
+        return super.register(promise).addListener(new ChannelFutureListener() {
+            @Override
+            public void operationComplete(ChannelFuture future) throws Exception {
+                if (future.isSuccess()) {
+                    ch = future.channel();
+                } else {
+                    deregister();
+                }
+            }
+        });
+    }
+
+    @Deprecated
     @Override
     public ChannelFuture register(Channel channel, ChannelPromise promise) {
         return super.register(channel, promise).addListener(new ChannelFutureListener() {
diff --git a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
index 700625506cc8..be425fdcc9ae 100644
--- a/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java
@@ -49,7 +49,6 @@ public class ThreadPerChannelEventLoopGroup extends AbstractEventExecutorGroup i
     final Executor executor;
     final Set<EventLoop> activeChildren =
             Collections.newSetFromMap(PlatformDependent.<EventLoop, Boolean>newConcurrentHashMap());
-    private final Set<EventLoop> readOnlyActiveChildren = Collections.unmodifiableSet(activeChildren);
     final Queue<EventLoop> idleChildren = new ConcurrentLinkedQueue<EventLoop>();
     private final ChannelException tooManyChannels;
 
@@ -78,7 +77,7 @@ protected ThreadPerChannelEventLoopGroup() {
      * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
      *                          a new {@link Channel} and the maximum is exceed it will throw an
      *                          {@link ChannelException}. on the {@link #register(Channel)} and
-     *                          {@link #register(Channel, ChannelPromise)} method.
+     *                          {@link #register(ChannelPromise)} method.
      *                          Use {@code 0} to use no limit
      */
     protected ThreadPerChannelEventLoopGroup(int maxChannels) {
@@ -91,7 +90,7 @@ protected ThreadPerChannelEventLoopGroup(int maxChannels) {
      * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
      *                          a new {@link Channel} and the maximum is exceed it will throw an
      *                          {@link ChannelException} on the {@link #register(Channel)} and
-     *                          {@link #register(Channel, ChannelPromise)} method.
+     *                          {@link #register(ChannelPromise)} method.
      *                          Use {@code 0} to use no limit
      * @param threadFactory     the {@link ThreadFactory} used to create new {@link Thread} instances that handle the
      *                          registered {@link Channel}s
@@ -107,7 +106,7 @@ protected ThreadPerChannelEventLoopGroup(int maxChannels, ThreadFactory threadFa
      * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
      *                          a new {@link Channel} and the maximum is exceed it will throw an
      *                          {@link ChannelException} on the {@link #register(Channel)} and
-     *                          {@link #register(Channel, ChannelPromise)} method.
+     *                          {@link #register(ChannelPromise)} method.
      *                          Use {@code 0} to use no limit
      * @param executor          the {@link Executor} used to create new {@link Thread} instances that handle the
      *                          registered {@link Channel}s
@@ -147,12 +146,6 @@ public Iterator<EventExecutor> iterator() {
         return new ReadOnlyIterator<EventExecutor>(activeChildren.iterator());
     }
 
-    @Override
-    @SuppressWarnings("unchecked")
-    public <E extends EventExecutor> Set<E> children() {
-        return (Set<E>) readOnlyActiveChildren;
-    }
-
     @Override
     public EventLoop next() {
         throw new UnsupportedOperationException();
@@ -281,12 +274,23 @@ public ChannelFuture register(Channel channel) {
         }
         try {
             EventLoop l = nextChild();
-            return l.register(channel, new DefaultChannelPromise(channel, l));
+            return l.register(new DefaultChannelPromise(channel, l));
         } catch (Throwable t) {
             return new FailedChannelFuture(channel, GlobalEventExecutor.INSTANCE, t);
         }
     }
 
+    @Override
+    public ChannelFuture register(ChannelPromise promise) {
+        try {
+            return nextChild().register(promise);
+        } catch (Throwable t) {
+            promise.setFailure(t);
+            return promise;
+        }
+    }
+
+    @Deprecated
     @Override
     public ChannelFuture register(Channel channel, ChannelPromise promise) {
         if (channel == null) {
diff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
index 9d2cecc9fde5..1dee69e8ed11 100644
--- a/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java
@@ -21,15 +21,14 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
-import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelId;
-import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelOutboundBuffer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.DefaultChannelPipeline;
 import io.netty.channel.EventLoop;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.internal.ObjectUtil;
@@ -154,7 +153,11 @@ protected void initChannel(Channel ch) throws Exception {
 
         ChannelFuture future = loop.register(this);
         assert future.isDone();
-        p.addLast(new LastInboundHandler());
+    }
+
+    @Override
+    protected final DefaultChannelPipeline newChannelPipeline() {
+        return new EmbeddedChannelPipeline(this);
     }
 
     @Override
@@ -548,15 +551,19 @@ public void connect(SocketAddress remoteAddress, SocketAddress localAddress, Cha
         }
     }
 
-    private final class LastInboundHandler extends ChannelInboundHandlerAdapter {
-        @Override
-        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-            inboundMessages().add(msg);
+    private final class EmbeddedChannelPipeline extends DefaultChannelPipeline {
+        public EmbeddedChannelPipeline(EmbeddedChannel channel) {
+            super(channel);
         }
 
         @Override
-        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
+        protected void onUnhandledInboundException(Throwable cause) {
             recordException(cause);
         }
+
+        @Override
+        protected void onUnhandledInboundMessage(Object msg) {
+            inboundMessages().add(msg);
+        }
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
index f88668cedaff..bd95fee7217d 100644
--- a/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java
@@ -17,24 +17,19 @@
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelHandlerInvoker;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.DefaultChannelPromise;
-import io.netty.util.concurrent.EventExecutor;
 import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.concurrent.AbstractScheduledEventExecutor;
 import io.netty.util.concurrent.Future;
+import io.netty.util.internal.ObjectUtil;
 
-import java.net.SocketAddress;
 import java.util.ArrayDeque;
 import java.util.Queue;
 import java.util.concurrent.TimeUnit;
 
-import static io.netty.channel.ChannelHandlerInvokerUtil.*;
-
-final class EmbeddedEventLoop extends AbstractScheduledEventExecutor implements ChannelHandlerInvoker, EventLoop {
+final class EmbeddedEventLoop extends AbstractScheduledEventExecutor implements EventLoop {
 
     private final Queue<Runnable> tasks = new ArrayDeque<Runnable>(2);
 
@@ -126,9 +121,17 @@ public boolean awaitTermination(long timeout, TimeUnit unit) {
 
     @Override
     public ChannelFuture register(Channel channel) {
-        return register(channel, new DefaultChannelPromise(channel, this));
+        return register(new DefaultChannelPromise(channel, this));
+    }
+
+    @Override
+    public ChannelFuture register(ChannelPromise promise) {
+        ObjectUtil.checkNotNull(promise, "promise");
+        promise.channel().unsafe().register(this, promise);
+        return promise;
     }
 
+    @Deprecated
     @Override
     public ChannelFuture register(Channel channel, ChannelPromise promise) {
         channel.unsafe().register(this, promise);
@@ -144,101 +147,4 @@ public boolean inEventLoop() {
     public boolean inEventLoop(Thread thread) {
         return true;
     }
-
-    @Override
-    public ChannelHandlerInvoker asInvoker() {
-        return this;
-    }
-
-    @Override
-    public EventExecutor executor() {
-        return this;
-    }
-
-    @Override
-    public void invokeChannelRegistered(ChannelHandlerContext ctx) {
-        invokeChannelRegisteredNow(ctx);
-    }
-
-    @Override
-    public void invokeChannelUnregistered(ChannelHandlerContext ctx) {
-        invokeChannelUnregisteredNow(ctx);
-    }
-
-    @Override
-    public void invokeChannelActive(ChannelHandlerContext ctx) {
-        invokeChannelActiveNow(ctx);
-    }
-
-    @Override
-    public void invokeChannelInactive(ChannelHandlerContext ctx) {
-        invokeChannelInactiveNow(ctx);
-    }
-
-    @Override
-    public void invokeExceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
-        invokeExceptionCaughtNow(ctx, cause);
-    }
-
-    @Override
-    public void invokeUserEventTriggered(ChannelHandlerContext ctx, Object event) {
-        invokeUserEventTriggeredNow(ctx, event);
-    }
-
-    @Override
-    public void invokeChannelRead(ChannelHandlerContext ctx, Object msg) {
-        invokeChannelReadNow(ctx, msg);
-    }
-
-    @Override
-    public void invokeChannelReadComplete(ChannelHandlerContext ctx) {
-        invokeChannelReadCompleteNow(ctx);
-    }
-
-    @Override
-    public void invokeChannelWritabilityChanged(ChannelHandlerContext ctx) {
-        invokeChannelWritabilityChangedNow(ctx);
-    }
-
-    @Override
-    public void invokeBind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) {
-        invokeBindNow(ctx, localAddress, promise);
-    }
-
-    @Override
-    public void invokeConnect(
-            ChannelHandlerContext ctx,
-            SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {
-        invokeConnectNow(ctx, remoteAddress, localAddress, promise);
-    }
-
-    @Override
-    public void invokeDisconnect(ChannelHandlerContext ctx, ChannelPromise promise) {
-        invokeDisconnectNow(ctx, promise);
-    }
-
-    @Override
-    public void invokeClose(ChannelHandlerContext ctx, ChannelPromise promise) {
-        invokeCloseNow(ctx, promise);
-    }
-
-    @Override
-    public void invokeDeregister(ChannelHandlerContext ctx, ChannelPromise promise) {
-        invokeDeregisterNow(ctx, promise);
-    }
-
-    @Override
-    public void invokeRead(ChannelHandlerContext ctx) {
-        invokeReadNow(ctx);
-    }
-
-    @Override
-    public void invokeWrite(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
-        invokeWriteNow(ctx, msg, promise);
-    }
-
-    @Override
-    public void invokeFlush(ChannelHandlerContext ctx) {
-        invokeFlushNow(ctx);
-    }
 }
diff --git a/transport/src/main/java/io/netty/channel/group/ChannelGroup.java b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
index c66022e1d083..8d6944f48531 100644
--- a/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java
@@ -121,7 +121,7 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
 
     /**
      * Writes the specified {@code message} to all {@link Channel}s in this
-     * group that match the given {@link ChannelMatcher}. If the specified {@code message} is an instance of
+     * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of
      * {@link ByteBuf}, it is automatically
      * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race
      * condition. The same is true for {@link ByteBufHolder}. Please note that this operation is asynchronous as
@@ -132,6 +132,22 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
      */
     ChannelGroupFuture write(Object message, ChannelMatcher matcher);
 
+    /**
+     * Writes the specified {@code message} to all {@link Channel}s in this
+     * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of
+     * {@link ByteBuf}, it is automatically
+     * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race
+     * condition. The same is true for {@link ByteBufHolder}. Please note that this operation is asynchronous as
+     * {@link Channel#write(Object)} is.
+     *
+     * If {@code voidPromise} is {@code true} {@link Channel#voidPromise()} is used for the writes and so the same
+     * restrictions to the returned {@link ChannelGroupFuture} apply as to a void promise.
+     *
+     * @return the {@link ChannelGroupFuture} instance that notifies when
+     *         the operation is done for all channels
+     */
+    ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean voidPromise);
+
     /**
      * Flush all {@link Channel}s in this
      * group. If the specified {@code messages} are an instance of
@@ -146,7 +162,7 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
     ChannelGroup flush();
 
     /**
-     * Flush all {@link Channel}s in this group that match the given {@link ChannelMatcher}.
+     * Flush all {@link Channel}s in this group that are matched by the given {@link ChannelMatcher}.
      * If the specified {@code messages} are an instance of
      * {@link ByteBuf}, it is automatically
      * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race
@@ -171,10 +187,16 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
 
     /**
      * Shortcut for calling {@link #write(Object)} and {@link #flush()} and only act on
-     * {@link Channel}s that match the {@link ChannelMatcher}.
+     * {@link Channel}s that are matched by the {@link ChannelMatcher}.
      */
     ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher);
 
+    /**
+     * Shortcut for calling {@link #write(Object, ChannelMatcher, boolean)} and {@link #flush()} and only act on
+     * {@link Channel}s that are matched by the {@link ChannelMatcher}.
+     */
+    ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher, boolean voidPromise);
+
     /**
      * @deprecated Use {@link #writeAndFlush(Object, ChannelMatcher)} instead.
      */
@@ -191,7 +213,7 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
 
     /**
      * Disconnects all {@link Channel}s in this group from their remote peers,
-     * that match the given {@link ChannelMatcher}.
+     * that are matched by the given {@link ChannelMatcher}.
      *
      * @return the {@link ChannelGroupFuture} instance that notifies when
      *         the operation is done for all channels
@@ -209,7 +231,7 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
     ChannelGroupFuture close();
 
     /**
-     * Closes all {@link Channel}s in this group that match the given {@link ChannelMatcher}.
+     * Closes all {@link Channel}s in this group that are matched by the given {@link ChannelMatcher}.
      * If the {@link Channel} is  connected to a remote peer or bound to a local address, it is
      * automatically disconnected and unbound.
      *
@@ -233,7 +255,7 @@ public interface ChannelGroup extends Set<Channel>, Comparable<ChannelGroup> {
     /**
      * @deprecated This method will be removed in the next major feature release.
      *
-     * Deregister all {@link Channel}s in this group from their {@link EventLoop} that match the given
+     * Deregister all {@link Channel}s in this group from their {@link EventLoop} that are matched by the given
      * {@link ChannelMatcher}. Please note that this operation is asynchronous as {@link Channel#deregister()} is.
      *
      * @return the {@link ChannelGroupFuture} instance that notifies when
diff --git a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
index 19d74d46edc7..9f64ad07caef 100644
--- a/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java
@@ -52,6 +52,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
             remove(future.channel());
         }
     };
+    private final VoidChannelGroupFuture voidFuture = new VoidChannelGroupFuture(this);
     private final boolean stayClosed;
     private volatile boolean closed;
 
@@ -244,9 +245,9 @@ public ChannelGroupFuture write(Object message) {
     // See https://github.com/netty/netty/issues/1461
     private static Object safeDuplicate(Object message) {
         if (message instanceof ByteBuf) {
-            return ((ByteBuf) message).duplicate().retain();
+            return ((ByteBuf) message).retainedDuplicate();
         } else if (message instanceof ByteBufHolder) {
-            return ((ByteBufHolder) message).duplicate().retain();
+            return ((ByteBufHolder) message).retainedDuplicate();
         } else {
             return ReferenceCountUtil.retain(message);
         }
@@ -254,6 +255,11 @@ private static Object safeDuplicate(Object message) {
 
     @Override
     public ChannelGroupFuture write(Object message, ChannelMatcher matcher) {
+        return write(message, matcher, false);
+    }
+
+    @Override
+    public ChannelGroupFuture write(Object message, ChannelMatcher matcher, boolean voidPromise) {
         if (message == null) {
             throw new NullPointerException("message");
         }
@@ -261,15 +267,25 @@ public ChannelGroupFuture write(Object message, ChannelMatcher matcher) {
             throw new NullPointerException("matcher");
         }
 
-        Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());
-        for (Channel c: nonServerChannels.values()) {
-            if (matcher.matches(c)) {
-                futures.put(c, c.write(safeDuplicate(message)));
+        final ChannelGroupFuture future;
+        if (voidPromise) {
+            for (Channel c: nonServerChannels.values()) {
+                if (matcher.matches(c)) {
+                    c.write(safeDuplicate(message), c.voidPromise());
+                }
             }
+            future = voidFuture;
+        } else {
+            Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());
+            for (Channel c: nonServerChannels.values()) {
+                if (matcher.matches(c)) {
+                    futures.put(c, c.write(safeDuplicate(message)));
+                }
+            }
+            future = new DefaultChannelGroupFuture(this, futures, executor);
         }
-
         ReferenceCountUtil.release(message);
-        return new DefaultChannelGroupFuture(this, futures, executor);
+        return future;
     }
 
     @Override
@@ -383,21 +399,34 @@ public ChannelGroupFuture flushAndWrite(Object message, ChannelMatcher matcher)
 
     @Override
     public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher) {
+        return writeAndFlush(message, matcher, false);
+    }
+
+    @Override
+    public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher, boolean voidPromise) {
         if (message == null) {
             throw new NullPointerException("message");
         }
 
-        Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());
-
-        for (Channel c: nonServerChannels.values()) {
-            if (matcher.matches(c)) {
-                futures.put(c, c.writeAndFlush(safeDuplicate(message)));
+        final ChannelGroupFuture future;
+        if (voidPromise) {
+            for (Channel c: nonServerChannels.values()) {
+                if (matcher.matches(c)) {
+                    c.writeAndFlush(safeDuplicate(message), c.voidPromise());
+                }
             }
+            future = voidFuture;
+        } else {
+            Map<Channel, ChannelFuture> futures = new LinkedHashMap<Channel, ChannelFuture>(size());
+            for (Channel c: nonServerChannels.values()) {
+                if (matcher.matches(c)) {
+                    futures.put(c, c.writeAndFlush(safeDuplicate(message)));
+                }
+            }
+            future = new DefaultChannelGroupFuture(this, futures, executor);
         }
-
         ReferenceCountUtil.release(message);
-
-        return new DefaultChannelGroupFuture(this, futures, executor);
+        return future;
     }
 
     @Override
diff --git a/transport/src/main/java/io/netty/channel/group/VoidChannelGroupFuture.java b/transport/src/main/java/io/netty/channel/group/VoidChannelGroupFuture.java
new file mode 100644
index 000000000000..e8fa84266b46
--- /dev/null
+++ b/transport/src/main/java/io/netty/channel/group/VoidChannelGroupFuture.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.group;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.concurrent.TimeUnit;
+
+final class VoidChannelGroupFuture implements ChannelGroupFuture {
+
+    private static final Iterator<ChannelFuture> EMPTY = Collections.<ChannelFuture>emptyList().iterator();
+    private final ChannelGroup group;
+
+    VoidChannelGroupFuture(ChannelGroup group) {
+        this.group = group;
+    }
+
+    @Override
+    public ChannelGroup group() {
+        return group;
+    }
+
+    @Override
+    public ChannelFuture find(Channel channel) {
+        return null;
+    }
+
+    @Override
+    public boolean isSuccess() {
+        return false;
+    }
+
+    @Override
+    public ChannelGroupException cause() {
+        return null;
+    }
+
+    @Override
+    public boolean isPartialSuccess() {
+        return false;
+    }
+
+    @Override
+    public boolean isPartialFailure() {
+        return false;
+    }
+
+    @Override
+    public ChannelGroupFuture addListener(GenericFutureListener<? extends Future<? super Void>> listener) {
+        throw reject();
+    }
+
+    @Override
+    public ChannelGroupFuture addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
+        throw reject();
+    }
+
+    @Override
+    public ChannelGroupFuture removeListener(GenericFutureListener<? extends Future<? super Void>> listener) {
+        throw reject();
+    }
+
+    @Override
+    public ChannelGroupFuture removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {
+        throw reject();
+    }
+
+    @Override
+    public ChannelGroupFuture await() {
+        throw reject();
+    }
+
+    @Override
+    public ChannelGroupFuture awaitUninterruptibly() {
+        throw reject();
+    }
+
+    @Override
+    public ChannelGroupFuture syncUninterruptibly() {
+        throw reject();
+    }
+
+    @Override
+    public ChannelGroupFuture sync() {
+        throw reject();
+    }
+
+    @Override
+    public Iterator<ChannelFuture> iterator() {
+        return EMPTY;
+    }
+
+    @Override
+    public boolean isCancellable() {
+        return false;
+    }
+
+    @Override
+    public boolean await(long timeout, TimeUnit unit) {
+        throw reject();
+    }
+
+    @Override
+    public boolean await(long timeoutMillis) {
+        throw reject();
+    }
+
+    @Override
+    public boolean awaitUninterruptibly(long timeout, TimeUnit unit) {
+        throw reject();
+    }
+
+    @Override
+    public boolean awaitUninterruptibly(long timeoutMillis) {
+        throw reject();
+    }
+
+    @Override
+    public Void getNow() {
+        return null;
+    }
+
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        return false;
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return false;
+    }
+
+    @Override
+    public boolean isDone() {
+        return false;
+    }
+
+    @Override
+    public Void get() {
+        throw reject();
+    }
+
+    @Override
+    public Void get(long timeout, TimeUnit unit)  {
+        throw reject();
+    }
+
+    private static RuntimeException reject() {
+        return new IllegalStateException("void future");
+    }
+}
diff --git a/transport/src/main/java/io/netty/channel/local/LocalChannel.java b/transport/src/main/java/io/netty/channel/local/LocalChannel.java
index f37b37a33783..518783925a74 100644
--- a/transport/src/main/java/io/netty/channel/local/LocalChannel.java
+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java
@@ -34,6 +34,7 @@
 import io.netty.util.internal.OneTimeTask;
 import io.netty.util.internal.PlatformDependent;
 
+import java.net.ConnectException;
 import java.net.SocketAddress;
 import java.nio.channels.AlreadyConnectedException;
 import java.nio.channels.ClosedChannelException;
@@ -481,7 +482,7 @@ public void connect(final SocketAddress remoteAddress,
 
             Channel boundChannel = LocalChannelRegistry.get(remoteAddress);
             if (!(boundChannel instanceof LocalServerChannel)) {
-                Exception cause = new ChannelException("connection refused");
+                Exception cause = new ConnectException("connection refused: " + remoteAddress);
                 safeSetFailure(promise, cause);
                 close(voidPromise());
                 return;
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
index 69f99b15758d..cc59b84d8a73 100644
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelConfig;
+import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelOutboundBuffer;
 import io.netty.channel.ChannelPipeline;
@@ -52,6 +53,11 @@ protected AbstractNioByteChannel(Channel parent, SelectableChannel ch) {
         super(parent, ch, SelectionKey.OP_READ);
     }
 
+    /**
+     * Shutdown the input side of the channel.
+     */
+    protected abstract ChannelFuture shutdownInput();
+
     @Override
     protected AbstractNioUnsafe newUnsafe() {
         return new NioByteUnsafe();
@@ -60,10 +66,10 @@ protected AbstractNioUnsafe newUnsafe() {
     protected class NioByteUnsafe extends AbstractNioUnsafe {
 
         private void closeOnRead(ChannelPipeline pipeline) {
-            SelectionKey key = selectionKey();
-            setInputShutdown();
             if (isOpen()) {
                 if (Boolean.TRUE.equals(config().getOption(ChannelOption.ALLOW_HALF_CLOSURE))) {
+                    shutdownInput();
+                    SelectionKey key = selectionKey();
                     key.interestOps(key.interestOps() & ~readInterestOp);
                     pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
                 } else {
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
index 582e6ae6fafb..8de66aba187a 100644
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java
@@ -60,7 +60,6 @@ public abstract class AbstractNioChannel extends AbstractChannel {
     private final SelectableChannel ch;
     protected final int readInterestOp;
     volatile SelectionKey selectionKey;
-    private volatile boolean inputShutdown;
     boolean readPending;
     private final Runnable clearReadPendingRunnable = new Runnable() {
         @Override
@@ -197,20 +196,6 @@ private void clearReadPending0() {
         ((AbstractNioUnsafe) unsafe()).removeReadOp();
     }
 
-    /**
-     * Return {@code true} if the input of this {@link Channel} is shutdown
-     */
-    protected boolean isInputShutdown() {
-        return inputShutdown;
-    }
-
-    /**
-     * Shutdown the input of this {@link Channel}.
-     */
-    void setInputShutdown() {
-        inputShutdown = true;
-    }
-
     /**
      * Special {@link Unsafe} sub-type which allows to access the underlying {@link SelectableChannel}
      */
@@ -422,10 +407,6 @@ protected void doDeregister() throws Exception {
     @Override
     protected void doBeginRead() throws Exception {
         // Channel.read() or ChannelHandlerContext.read() was called
-        if (inputShutdown) {
-            return;
-        }
-
         final SelectionKey selectionKey = this.selectionKey;
         if (!selectionKey.isValid()) {
             return;
diff --git a/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
index 1d606e075b15..1c7f92aa2b16 100644
--- a/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java
@@ -33,6 +33,7 @@
  * {@link AbstractNioChannel} base class for {@link Channel}s that operate on messages.
  */
 public abstract class AbstractNioMessageChannel extends AbstractNioChannel {
+    boolean inputShutdown;
 
     /**
      * @see {@link AbstractNioChannel#AbstractNioChannel(Channel, SelectableChannel, int)}
@@ -46,6 +47,14 @@ protected AbstractNioUnsafe newUnsafe() {
         return new NioMessageUnsafe();
     }
 
+    @Override
+    protected void doBeginRead() throws Exception {
+        if (inputShutdown) {
+            return;
+        }
+        super.doBeginRead();
+    }
+
     private final class NioMessageUnsafe extends AbstractNioUnsafe {
 
         private final List<Object> readBuf = new ArrayList<Object>();
@@ -98,7 +107,7 @@ public void read() {
                 }
 
                 if (closed) {
-                    setInputShutdown();
+                    inputShutdown = true;
                     if (isOpen()) {
                         close(voidPromise());
                     }
diff --git a/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
index 20dd7c363673..b06b5bf63099 100644
--- a/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
+++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java
@@ -17,6 +17,7 @@
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelException;
+import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopException;
 import io.netty.channel.SelectStrategy;
 import io.netty.channel.SingleThreadEventLoop;
@@ -511,9 +512,25 @@ private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) {
         }
     }
 
-    private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
+    private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
         final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
         if (!k.isValid()) {
+            final EventLoop eventLoop;
+            try {
+                eventLoop = ch.eventLoop();
+            } catch (Throwable ignored) {
+                // If the channel implementation throws an exception because there is no event loop, we ignore this
+                // because we are only trying to determine if ch is registered to this event loop and thus has authority
+                // to close ch.
+                return;
+            }
+            // Only close ch if ch is still registerd to this EventLoop. ch could have deregistered from the event loop
+            // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
+            // still healthy and should not be closed.
+            // See https://github.com/netty/netty/issues/5125
+            if (eventLoop != this || eventLoop == null) {
+                return;
+            }
             // close the channel if the key is not valid anymore
             unsafe.close(unsafe.voidPromise());
             return;
@@ -635,6 +652,16 @@ private void select(boolean oldWakenUp) throws IOException {
                     break;
                 }
 
+                // If a task was submitted when wakenUp value was true, the task didn't get a chance to call
+                // Selector#wakeup. So we need to check task queue again before executing select operation.
+                // If we don't, the task might be pended until select operation was timed out.
+                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.
+                if (hasTasks() && wakenUp.compareAndSet(false, true)) {
+                    selector.selectNow();
+                    selectCnt = 1;
+                    break;
+                }
+
                 int selectedKeys = selector.select(timeoutMillis);
                 selectCnt ++;
 
diff --git a/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java b/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
index 98a7dac49738..d23ae83ebba7 100644
--- a/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java
@@ -89,7 +89,7 @@ public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider
      * {@code 50}, which means the event loop will try to spend the same amount of time for I/O as for non-I/O tasks.
      */
     public void setIoRatio(int ioRatio) {
-        for (EventExecutor e: children()) {
+        for (EventExecutor e: this) {
             ((NioEventLoop) e).setIoRatio(ioRatio);
         }
     }
@@ -99,7 +99,7 @@ public void setIoRatio(int ioRatio) {
      * around the  infamous epoll 100% CPU bug.
      */
     public void rebuildSelectors() {
-        for (EventExecutor e: children()) {
+        for (EventExecutor e: this) {
             ((NioEventLoop) e).rebuildSelector();
         }
     }
diff --git a/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
index 8c10cf2b206c..15da4099b6b7 100644
--- a/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java
@@ -19,6 +19,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelConfig;
+import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelMetadata;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelOutboundBuffer;
@@ -40,8 +41,6 @@ public abstract class AbstractOioByteChannel extends AbstractOioChannel {
             " (expected: " + StringUtil.simpleClassName(ByteBuf.class) + ", " +
             StringUtil.simpleClassName(FileRegion.class) + ')';
 
-    private volatile boolean inputShutdown;
-
     /**
      * @see AbstractOioByteChannel#AbstractOioByteChannel(Channel)
      */
@@ -49,39 +48,27 @@ protected AbstractOioByteChannel(Channel parent) {
         super(parent);
     }
 
-    protected boolean isInputShutdown() {
-        return inputShutdown;
-    }
-
     @Override
     public ChannelMetadata metadata() {
         return METADATA;
     }
 
     /**
-     * Check if the input was shutdown and if so return {@code true}. The default implementation sleeps also for
-     * {@link #SO_TIMEOUT} milliseconds to simulate some blocking.
+     * Determine if the input side of this channel is shutdown.
+     * @return {@code true} if the input side of this channel is shutdown.
      */
-    protected boolean checkInputShutdown() {
-        if (inputShutdown) {
-            try {
-                Thread.sleep(SO_TIMEOUT);
-            } catch (InterruptedException e) {
-                // ignore
-            }
-            return true;
-        }
-        return false;
-    }
+    protected abstract boolean isInputShutdown();
 
-    void setInputShutdown() {
-        inputShutdown = true;
-    }
+    /**
+     * Shutdown the input side of this channel.
+     * @return A channel future that will complete when the shutdown is complete.
+     */
+    protected abstract ChannelFuture shutdownInput();
 
     private void closeOnRead(ChannelPipeline pipeline) {
-        setInputShutdown();
         if (isOpen()) {
             if (Boolean.TRUE.equals(config().getOption(ChannelOption.ALLOW_HALF_CLOSURE))) {
+                shutdownInput();
                 pipeline.fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);
             } else {
                 unsafe().close(unsafe().voidPromise());
diff --git a/transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java b/transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java
index e803f8b325e3..684af4098396 100644
--- a/transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java
+++ b/transport/src/main/java/io/netty/channel/oio/OioEventLoopGroup.java
@@ -46,7 +46,7 @@ public OioEventLoopGroup() {
      * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
      *                          a new {@link Channel} and the maximum is exceed it will throw an
      *                          {@link ChannelException} on the {@link #register(Channel)} and
-     *                          {@link #register(Channel, ChannelPromise)} method.
+     *                          {@link #register(ChannelPromise)} method.
      *                          Use {@code 0} to use no limit
      */
     public OioEventLoopGroup(int maxChannels) {
@@ -59,7 +59,7 @@ public OioEventLoopGroup(int maxChannels) {
      * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
      *                          a new {@link Channel} and the maximum is exceed it will throw an
      *                          {@link ChannelException} on the {@link #register(Channel)} and
-     *                          {@link #register(Channel, ChannelPromise)} method.
+     *                          {@link #register(ChannelPromise)} method.
      *                          Use {@code 0} to use no limit
      * @param executor     the {@link Executor} used to create new {@link Thread} instances that handle the
      *                          registered {@link Channel}s
@@ -74,7 +74,7 @@ public OioEventLoopGroup(int maxChannels, Executor executor) {
      * @param maxChannels       the maximum number of channels to handle with this instance. Once you try to register
      *                          a new {@link Channel} and the maximum is exceed it will throw an
      *                          {@link ChannelException} on the {@link #register(Channel)} and
-     *                          {@link #register(Channel, ChannelPromise)} method.
+     *                          {@link #register(ChannelPromise)} method.
      *                          Use {@code 0} to use no limit
      * @param threadFactory     the {@link ThreadFactory} used to create new {@link Thread} instances that handle the
      *                          registered {@link Channel}s
diff --git a/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java b/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java
index 475285199a7f..05ccca969bd8 100644
--- a/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java
+++ b/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java
@@ -44,12 +44,22 @@ public DatagramPacket(ByteBuf data, InetSocketAddress recipient, InetSocketAddre
 
     @Override
     public DatagramPacket copy() {
-        return new DatagramPacket(content().copy(), recipient(), sender());
+        return replace(content().copy());
     }
 
     @Override
     public DatagramPacket duplicate() {
-        return new DatagramPacket(content().duplicate(), recipient(), sender());
+        return replace(content().duplicate());
+    }
+
+    @Override
+    public DatagramPacket retainedDuplicate() {
+        return replace(content().retainedDuplicate());
+    }
+
+    @Override
+    public DatagramPacket replace(ByteBuf content) {
+        return new DatagramPacket(content, recipient(), sender());
     }
 
     @Override
diff --git a/transport/src/main/java/io/netty/channel/socket/DuplexChannel.java b/transport/src/main/java/io/netty/channel/socket/DuplexChannel.java
index d34ec36bff14..4770d22511aa 100644
--- a/transport/src/main/java/io/netty/channel/socket/DuplexChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/DuplexChannel.java
@@ -32,6 +32,18 @@ public interface DuplexChannel extends Channel {
      */
     boolean isInputShutdown();
 
+    /**
+     * @see Socket#shutdownInput()
+     */
+    ChannelFuture shutdownInput();
+
+    /**
+     * Will shutdown the input and notify {@link ChannelPromise}.
+     *
+     * @see Socket#shutdownInput()
+     */
+    ChannelFuture shutdownInput(ChannelPromise promise);
+
     /**
      * @see Socket#isOutputShutdown()
      */
@@ -43,9 +55,27 @@ public interface DuplexChannel extends Channel {
     ChannelFuture shutdownOutput();
 
     /**
-     * @see Socket#shutdownOutput()
+     * Will shutdown the output and notify {@link ChannelPromise}.
      *
-     * Will notify the given {@link ChannelPromise}
+     * @see Socket#shutdownOutput()
      */
     ChannelFuture shutdownOutput(ChannelPromise promise);
+
+    /**
+     * Determine if both the input and output of this channel have been shutdown.
+     */
+    boolean isShutdown();
+
+    /**
+     * Will shutdown the input and output sides of this channel.
+     * @return will be completed when both shutdown operations complete.
+     */
+    ChannelFuture shutdown();
+
+    /**
+     * Will shutdown the input and output sides of this channel.
+     * @param promise will be completed when both shutdown operations complete.
+     * @return will be completed when both shutdown operations complete.
+     */
+    ChannelFuture shutdown(ChannelPromise promise);
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
index 21b9e375c5c6..5d1c9f84c3ed 100644
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java
@@ -25,7 +25,6 @@
 import java.net.NetworkInterface;
 import java.net.SocketException;
 import java.nio.channels.DatagramChannel;
-import java.nio.channels.NetworkChannel;
 import java.util.Enumeration;
 
 /**
@@ -78,16 +77,28 @@ class NioDatagramChannelConfig extends DefaultDatagramChannelConfig {
                 throw new Error("cannot locate the IP_MULTICAST_LOOP field", e);
             }
 
+            Class<?> networkChannelClass = null;
             try {
-                getOption = NetworkChannel.class.getDeclaredMethod("getOption", socketOptionType);
-            } catch (Exception e) {
-                throw new Error("cannot locate the getOption() method", e);
+                networkChannelClass = Class.forName("java.nio.channels.NetworkChannel", true, classLoader);
+            } catch (Throwable ignore) {
+                // Not Java 7+
             }
 
-            try {
-                setOption = NetworkChannel.class.getDeclaredMethod("setOption", socketOptionType, Object.class);
-            } catch (Exception e) {
-                throw new Error("cannot locate the setOption() method", e);
+            if (networkChannelClass == null) {
+                getOption = null;
+                setOption = null;
+            } else {
+                try {
+                    getOption = networkChannelClass.getDeclaredMethod("getOption", socketOptionType);
+                } catch (Exception e) {
+                    throw new Error("cannot locate the getOption() method", e);
+                }
+
+                try {
+                    setOption = networkChannelClass.getDeclaredMethod("setOption", socketOptionType, Object.class);
+                } catch (Exception e) {
+                    throw new Error("cannot locate the setOption() method", e);
+                }
             }
         }
         IP_MULTICAST_TTL = ipMulticastTtl;
@@ -173,7 +184,7 @@ protected void autoReadCleared() {
     }
 
     private Object getOption0(Object option) {
-        if (PlatformDependent.javaVersion() < 7) {
+        if (GET_OPTION == null) {
             throw new UnsupportedOperationException();
         } else {
             try {
@@ -185,7 +196,7 @@ private Object getOption0(Object option) {
     }
 
     private void setOption0(Object option, Object value) {
-        if (PlatformDependent.javaVersion() < 7) {
+        if (SET_OPTION == null) {
             throw new UnsupportedOperationException();
         } else {
             try {
@@ -195,5 +206,4 @@ private void setOption0(Object option, Object value) {
             }
         }
     }
-
 }
diff --git a/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
index 86253ab85105..dc1cbe1cae27 100644
--- a/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java
@@ -31,6 +31,8 @@
 import io.netty.channel.socket.SocketChannelConfig;
 import io.netty.util.concurrent.GlobalEventExecutor;
 import io.netty.util.internal.OneTimeTask;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
@@ -46,7 +48,7 @@
  * {@link io.netty.channel.socket.SocketChannel} which uses NIO selector based implementation.
  */
 public class NioSocketChannel extends AbstractNioByteChannel implements io.netty.channel.socket.SocketChannel {
-
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(NioSocketChannel.class);
     private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);
     private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();
 
@@ -124,9 +126,20 @@ public boolean isActive() {
         return ch.isOpen() && ch.isConnected();
     }
 
+    @Override
+    public boolean isOutputShutdown() {
+        return javaChannel().socket().isOutputShutdown() || !isActive();
+    }
+
     @Override
     public boolean isInputShutdown() {
-        return super.isInputShutdown();
+        return javaChannel().socket().isInputShutdown() || !isActive();
+    }
+
+    @Override
+    public boolean isShutdown() {
+        Socket socket = javaChannel().socket();
+        return socket.isInputShutdown() && socket.isOutputShutdown() || !isActive();
     }
 
     @Override
@@ -139,11 +152,6 @@ public InetSocketAddress remoteAddress() {
         return (InetSocketAddress) super.remoteAddress();
     }
 
-    @Override
-    public boolean isOutputShutdown() {
-        return javaChannel().socket().isOutputShutdown() || !isActive();
-    }
-
     @Override
     public ChannelFuture shutdownOutput() {
         return shutdownOutput(newPromise());
@@ -175,6 +183,68 @@ public void run() {
         return promise;
     }
 
+    @Override
+    public ChannelFuture shutdownInput() {
+        return shutdownInput(newPromise());
+    }
+
+    @Override
+    public ChannelFuture shutdownInput(final ChannelPromise promise) {
+        Executor closeExecutor = ((NioSocketChannelUnsafe) unsafe()).prepareToClose();
+        if (closeExecutor != null) {
+            closeExecutor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    shutdownInput0(promise);
+                }
+            });
+        } else {
+            EventLoop loop = eventLoop();
+            if (loop.inEventLoop()) {
+                shutdownInput0(promise);
+            } else {
+                loop.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        shutdownInput0(promise);
+                    }
+                });
+            }
+        }
+        return promise;
+    }
+
+    @Override
+    public ChannelFuture shutdown() {
+        return shutdown(newPromise());
+    }
+
+    @Override
+    public ChannelFuture shutdown(final ChannelPromise promise) {
+        Executor closeExecutor = ((NioSocketChannelUnsafe) unsafe()).prepareToClose();
+        if (closeExecutor != null) {
+            closeExecutor.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    shutdown0(promise);
+                }
+            });
+        } else {
+            EventLoop loop = eventLoop();
+            if (loop.inEventLoop()) {
+                shutdown0(promise);
+            } else {
+                loop.execute(new OneTimeTask() {
+                    @Override
+                    public void run() {
+                        shutdown0(promise);
+                    }
+                });
+            }
+        }
+        return promise;
+    }
+
     private void shutdownOutput0(final ChannelPromise promise) {
         try {
             javaChannel().socket().shutdownOutput();
@@ -184,6 +254,41 @@ private void shutdownOutput0(final ChannelPromise promise) {
         }
     }
 
+    private void shutdownInput0(final ChannelPromise promise) {
+        try {
+            javaChannel().socket().shutdownInput();
+            promise.setSuccess();
+        } catch (Throwable t) {
+            promise.setFailure(t);
+        }
+    }
+
+    private void shutdown0(final ChannelPromise promise) {
+        Socket socket = javaChannel().socket();
+        Throwable cause = null;
+        try {
+            socket.shutdownOutput();
+        } catch (Throwable t) {
+            cause = t;
+        }
+        try {
+            socket.shutdownInput();
+        } catch (Throwable t) {
+            if (cause == null) {
+                promise.setFailure(t);
+            } else {
+                logger.debug("Exception suppressed because a previous exception occurred.", t);
+                promise.setFailure(cause);
+            }
+            return;
+        }
+        if (cause == null) {
+            promise.setSuccess();
+        } else {
+            promise.setFailure(cause);
+        }
+    }
+
     @Override
     protected SocketAddress localAddress0() {
         return javaChannel().socket().getLocalSocketAddress();
diff --git a/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
index 3b34e213eccd..3e6cef632e4b 100644
--- a/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java
@@ -38,11 +38,9 @@
 /**
  * A {@link SocketChannel} which is using Old-Blocking-IO
  */
-public class OioSocketChannel extends OioByteStreamChannel
-                              implements SocketChannel {
+public class OioSocketChannel extends OioByteStreamChannel implements SocketChannel {
 
-    private static final InternalLogger logger =
-            InternalLoggerFactory.getInstance(OioSocketChannel.class);
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(OioSocketChannel.class);
 
     private final Socket socket;
     private final OioSocketChannelConfig config;
@@ -115,14 +113,19 @@ public boolean isActive() {
         return !socket.isClosed() && socket.isConnected();
     }
 
+    @Override
+    public boolean isOutputShutdown() {
+        return socket.isOutputShutdown() || !isActive();
+    }
+
     @Override
     public boolean isInputShutdown() {
-        return super.isInputShutdown();
+        return socket.isInputShutdown() || !isActive();
     }
 
     @Override
-    public boolean isOutputShutdown() {
-        return socket.isOutputShutdown() || !isActive();
+    public boolean isShutdown() {
+        return socket.isInputShutdown() && socket.isOutputShutdown() || !isActive();
     }
 
     @Override
@@ -130,6 +133,16 @@ public ChannelFuture shutdownOutput() {
         return shutdownOutput(newPromise());
     }
 
+    @Override
+    public ChannelFuture shutdownInput() {
+        return shutdownInput(newPromise());
+    }
+
+    @Override
+    public ChannelFuture shutdown() {
+        return shutdown(newPromise());
+    }
+
     @Override
     protected int doReadBytes(ByteBuf buf) throws Exception {
         if (socket.isClosed()) {
@@ -143,24 +156,94 @@ protected int doReadBytes(ByteBuf buf) throws Exception {
     }
 
     @Override
-    public ChannelFuture shutdownOutput(final ChannelPromise future) {
+    public ChannelFuture shutdownOutput(final ChannelPromise promise) {
         EventLoop loop = eventLoop();
         if (loop.inEventLoop()) {
-            try {
-                socket.shutdownOutput();
-                future.setSuccess();
-            } catch (Throwable t) {
-                future.setFailure(t);
-            }
+            shutdownOutput0(promise);
         } else {
             loop.execute(new OneTimeTask() {
                 @Override
                 public void run() {
-                    shutdownOutput(future);
+                    shutdownOutput0(promise);
                 }
             });
         }
-        return future;
+        return promise;
+    }
+
+    private void shutdownOutput0(ChannelPromise promise) {
+        try {
+            socket.shutdownOutput();
+            promise.setSuccess();
+        } catch (Throwable t) {
+            promise.setFailure(t);
+        }
+    }
+
+    @Override
+    public ChannelFuture shutdownInput(final ChannelPromise promise) {
+        EventLoop loop = eventLoop();
+        if (loop.inEventLoop()) {
+            shutdownInput0(promise);
+        } else {
+            loop.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    shutdownInput0(promise);
+                }
+            });
+        }
+        return promise;
+    }
+
+    private void shutdownInput0(ChannelPromise promise) {
+        try {
+            socket.shutdownInput();
+            promise.setSuccess();
+        } catch (Throwable t) {
+            promise.setFailure(t);
+        }
+    }
+
+    @Override
+    public ChannelFuture shutdown(final ChannelPromise promise) {
+        EventLoop loop = eventLoop();
+        if (loop.inEventLoop()) {
+            shutdown0(promise);
+        } else {
+            loop.execute(new OneTimeTask() {
+                @Override
+                public void run() {
+                    shutdown0(promise);
+                }
+            });
+        }
+        return promise;
+    }
+
+    private void shutdown0(ChannelPromise promise) {
+        Throwable cause = null;
+        try {
+            socket.shutdownOutput();
+        } catch (Throwable t) {
+            cause = t;
+        }
+        try {
+            socket.shutdownInput();
+        } catch (Throwable t) {
+            if (cause == null) {
+                promise.setFailure(t);
+            } else {
+                logger.debug("Exception suppressed because a previous exception occurred.", t);
+                promise.setFailure(cause);
+            }
+            return;
+        }
+        if (cause == null) {
+            promise.setSuccess();
+        } else {
+            promise.setFailure(cause);
+        }
     }
 
     @Override
@@ -221,7 +304,6 @@ protected void doClose() throws Exception {
         socket.close();
     }
 
-    @Override
     protected boolean checkInputShutdown() {
         if (isInputShutdown()) {
             try {
diff --git a/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
index 53a15004ed81..ea6faeaceff2 100644
--- a/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
+++ b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java
@@ -17,6 +17,7 @@
 package io.netty.bootstrap;
 
 import io.netty.channel.Channel;
+import io.netty.channel.ChannelException;
 import io.netty.channel.ChannelFactory;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
@@ -24,6 +25,7 @@
 import io.netty.channel.ChannelInboundHandler;
 import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
+import io.netty.channel.DefaultEventLoop;
 import io.netty.channel.DefaultEventLoopGroup;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.ServerChannel;
@@ -40,6 +42,7 @@
 import org.junit.AfterClass;
 import org.junit.Test;
 
+import java.net.ConnectException;
 import java.net.SocketAddress;
 import java.net.SocketException;
 import java.net.UnknownHostException;
@@ -217,6 +220,20 @@ public void operationComplete(ChannelFuture future) throws Exception {
         }
     }
 
+    @Test(expected = ConnectException.class, timeout = 10000)
+    public void testLateRegistrationConnect() throws Exception {
+        EventLoopGroup group = new DelayedEventLoopGroup();
+        try {
+            final Bootstrap bootstrapA = new Bootstrap();
+            bootstrapA.group(group);
+            bootstrapA.channel(LocalChannel.class);
+            bootstrapA.handler(dummyHandler);
+            bootstrapA.connect(LocalAddress.ANY).syncUninterruptibly();
+        } finally {
+            group.shutdownGracefully();
+        }
+    }
+
     @Test
     public void testAsyncResolutionSuccess() throws Exception {
 
@@ -260,6 +277,20 @@ public void testAsyncResolutionFailure() throws Exception {
         assertThat(connectFuture.channel().isOpen(), is(false));
     }
 
+    private static final class DelayedEventLoopGroup extends DefaultEventLoop {
+        @Override
+        public ChannelFuture register(final Channel channel, final ChannelPromise promise) {
+            // Delay registration
+            execute(new Runnable() {
+                @Override
+                public void run() {
+                    DelayedEventLoopGroup.super.register(channel, promise);
+                }
+            });
+            return promise;
+        }
+    }
+
     private static final class TestEventLoopGroup extends DefaultEventLoopGroup {
 
         ChannelPromise promise;
@@ -275,6 +306,11 @@ public ChannelFuture register(Channel channel) {
             return promise;
         }
 
+        @Override
+        public ChannelFuture register(ChannelPromise promise) {
+            throw new UnsupportedOperationException();
+        }
+
         @Override
         public ChannelFuture register(Channel channel, final ChannelPromise promise) {
             throw new UnsupportedOperationException();
diff --git a/transport/src/test/java/io/netty/channel/AbstractChannelTest.java b/transport/src/test/java/io/netty/channel/AbstractChannelTest.java
index a788f76a2b22..b535f2b19943 100644
--- a/transport/src/test/java/io/netty/channel/AbstractChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/AbstractChannelTest.java
@@ -32,8 +32,6 @@ public void ensureInitialRegistrationFiresActive() throws Throwable {
         EventLoop eventLoop = createNiceMock(EventLoop.class);
         // This allows us to have a single-threaded test
         expect(eventLoop.inEventLoop()).andReturn(true).anyTimes();
-        ChannelHandlerInvoker invoker = new DefaultChannelHandlerInvoker(eventLoop);
-        expect(eventLoop.asInvoker()).andReturn(invoker).anyTimes();
 
         TestChannel channel = new TestChannel();
         ChannelInboundHandler handler = createMock(ChannelInboundHandler.class);
@@ -65,8 +63,6 @@ public Object answer() throws Throwable {
                 return null;
             }
         }).once();
-        ChannelHandlerInvoker invoker = new DefaultChannelHandlerInvoker(eventLoop);
-        expect(eventLoop.asInvoker()).andReturn(invoker).anyTimes();
 
         final TestChannel channel = new TestChannel();
         ChannelInboundHandler handler = createMock(ChannelInboundHandler.class);
diff --git a/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java b/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java
index 23ee48ab23c1..00cff791de81 100644
--- a/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java
+++ b/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java
@@ -99,7 +99,7 @@ public void testNioBuffersExpand2() {
         CompositeByteBuf comp = compositeBuffer(256);
         ByteBuf buf = directBuffer().writeBytes("buf1".getBytes(CharsetUtil.US_ASCII));
         for (int i = 0; i < 65; i++) {
-            comp.addComponent(buf.copy()).writerIndex(comp.writerIndex() + buf.readableBytes());
+            comp.addComponent(true, buf.copy());
         }
         buffer.addMessage(comp, comp.readableBytes(), channel.voidPromise());
 
diff --git a/transport/src/test/java/io/netty/channel/CombinedChannelDuplexHandlerTest.java b/transport/src/test/java/io/netty/channel/CombinedChannelDuplexHandlerTest.java
index f5b57869ed2d..27f9b8d11c28 100644
--- a/transport/src/test/java/io/netty/channel/CombinedChannelDuplexHandlerTest.java
+++ b/transport/src/test/java/io/netty/channel/CombinedChannelDuplexHandlerTest.java
@@ -363,11 +363,11 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         ChannelPipeline pipeline = ch.pipeline();
 
         ChannelPromise promise = ch.newPromise();
-        pipeline.connect(null, null, promise);
+        pipeline.connect(new InetSocketAddress(0), null, promise);
         promise.syncUninterruptibly();
 
         promise = ch.newPromise();
-        pipeline.bind(null, promise);
+        pipeline.bind(new InetSocketAddress(0), promise);
         promise.syncUninterruptibly();
 
         promise = ch.newPromise();
diff --git a/transport/src/test/java/io/netty/channel/DefaultChannelHandlerInvokerTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelHandlerInvokerTest.java
deleted file mode 100644
index 1ba5d19bf8e3..000000000000
--- a/transport/src/test/java/io/netty/channel/DefaultChannelHandlerInvokerTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2016 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.channel;
-
-import io.netty.util.ReferenceCounted;
-import io.netty.util.concurrent.ImmediateEventExecutor;
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-public class DefaultChannelHandlerInvokerTest {
-    @Mock
-    private ReferenceCounted msg;
-    @Mock
-    private ChannelHandlerContext ctx;
-    @Mock
-    private ChannelPromise promise;
-
-    @Before
-    public void setup() {
-        MockitoAnnotations.initMocks(this);
-    }
-
-    @Test
-    public void writeWithInvalidPromiseStillReleasesMessage() {
-        when(promise.isDone()).thenReturn(true);
-        DefaultChannelHandlerInvoker invoker = new DefaultChannelHandlerInvoker(ImmediateEventExecutor.INSTANCE);
-        try {
-            invoker.invokeWrite(ctx, msg, promise);
-        } catch (IllegalArgumentException e) {
-            verify(msg).release();
-            return;
-        }
-        fail();
-    }
-
-    @Test
-    public void writeWithNullPromiseStillReleasesMessage() {
-        when(promise.isDone()).thenReturn(true);
-        DefaultChannelHandlerInvoker invoker = new DefaultChannelHandlerInvoker(ImmediateEventExecutor.INSTANCE);
-        try {
-            invoker.invokeWrite(ctx, msg, null);
-        } catch (NullPointerException e) {
-            verify(msg).release();
-            return;
-        }
-        fail();
-    }
-}
diff --git a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
index 6380805b8a72..a6466709a131 100644
--- a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
+++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java
@@ -33,6 +33,7 @@
 import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.EventExecutorGroup;
 import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
 import org.junit.After;
 import org.junit.AfterClass;
@@ -700,16 +701,19 @@ public void testHandlerAddedAndRemovedCalledInCorrectOrder() throws Throwable {
 
             assertTrue(removedQueue.isEmpty());
             pipeline.channel().close().syncUninterruptibly();
-            assertHandler(handler1, addedQueue.take());
-            assertHandler(handler2, addedQueue.take());
-            assertHandler(handler3, addedQueue.take());
-            assertHandler(handler4, addedQueue.take());
+            assertHandler(addedQueue.take(), handler1);
+
+            // Depending on timing this can be handler2 or handler3 as these use different EventExecutorGroups.
+            assertHandler(addedQueue.take(), handler2, handler3, handler4);
+            assertHandler(addedQueue.take(), handler2, handler3, handler4);
+            assertHandler(addedQueue.take(), handler2, handler3, handler4);
+
             assertTrue(addedQueue.isEmpty());
 
-            assertHandler(handler4, removedQueue.take());
-            assertHandler(handler3, removedQueue.take());
-            assertHandler(handler2, removedQueue.take());
-            assertHandler(handler1, removedQueue.take());
+            assertHandler(removedQueue.take(), handler4);
+            assertHandler(removedQueue.take(), handler3);
+            assertHandler(removedQueue.take(), handler2);
+            assertHandler(removedQueue.take(), handler1);
             assertTrue(removedQueue.isEmpty());
         } finally {
             group1.shutdownGracefully();
@@ -765,9 +769,10 @@ public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
     }
 
     @Test(timeout = 3000)
-    public void testHandlerAddedThrowsAndRemovedThrowsException() {
+    public void testHandlerAddedThrowsAndRemovedThrowsException() throws InterruptedException {
         final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
         try {
+            final CountDownLatch latch = new CountDownLatch(1);
             final Promise<Void> promise = group1.next().newPromise();
             final Exception exceptionAdded = new RuntimeException();
             final Exception exceptionRemoved = new RuntimeException();
@@ -781,11 +786,13 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
 
                 @Override
                 public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+                    latch.countDown();
                     throw exceptionRemoved;
                 }
             });
             pipeline.addLast(group1, new CheckExceptionHandler(exceptionAdded, promise));
             group.register(pipeline.channel()).syncUninterruptibly();
+            latch.await();
             assertNull(pipeline.context(handlerName));
             promise.syncUninterruptibly();
         } finally {
@@ -793,39 +800,7 @@ public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
         }
     }
 
-    @Test(timeout = 3000)
-    public void testHandlerAddBlocksUntilHandlerAddedCalled() {
-        final EventExecutorGroup group1 = new DefaultEventExecutorGroup(1);
-        try {
-            final Promise<Void> promise = group1.next().newPromise();
-            ChannelPipeline pipeline = new LocalChannel().pipeline();
-            group.register(pipeline.channel()).syncUninterruptibly();
-
-            pipeline.addLast(new ChannelHandlerAdapter() {
-                @Override
-                public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-                    final AtomicBoolean handlerAddedCalled = new AtomicBoolean();
-                    ctx.pipeline().addLast(group1, new ChannelHandlerAdapter() {
-                        @Override
-                        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-                            handlerAddedCalled.set(true);
-                        }
-                    });
-                    if (handlerAddedCalled.get()) {
-                        promise.setSuccess(null);
-                    } else {
-                        promise.setFailure(new AssertionError("handlerAdded(...) was not called yet"));
-                    }
-                }
-            });
-
-            promise.syncUninterruptibly();
-        } finally {
-            group1.shutdownGracefully();
-        }
-    }
-
-    @Test
+    @Test(timeout = 2000)
     public void testAddRemoveHandlerCalledOnceRegistered() throws Throwable {
         ChannelPipeline pipeline = new LocalChannel().pipeline();
         CallbackCheckHandler handler = new CallbackCheckHandler();
@@ -833,8 +808,8 @@ public void testAddRemoveHandlerCalledOnceRegistered() throws Throwable {
         pipeline.addFirst(handler);
         pipeline.remove(handler);
 
-        assertFalse(handler.addedHandler.get());
-        assertFalse(handler.removedHandler.get());
+        assertNull(handler.addedHandler.getNow());
+        assertNull(handler.removedHandler.getNow());
 
         group.register(pipeline.channel()).syncUninterruptibly();
         Throwable cause = handler.error.get();
@@ -846,7 +821,7 @@ public void testAddRemoveHandlerCalledOnceRegistered() throws Throwable {
         assertTrue(handler.removedHandler.get());
     }
 
-    @Test
+    @Test(timeout = 3000)
     public void testAddReplaceHandlerCalledOnceRegistered() throws Throwable {
         ChannelPipeline pipeline = new LocalChannel().pipeline();
         CallbackCheckHandler handler = new CallbackCheckHandler();
@@ -855,10 +830,10 @@ public void testAddReplaceHandlerCalledOnceRegistered() throws Throwable {
         pipeline.addFirst(handler);
         pipeline.replace(handler, null, handler2);
 
-        assertFalse(handler.addedHandler.get());
-        assertFalse(handler.removedHandler.get());
-        assertFalse(handler2.addedHandler.get());
-        assertFalse(handler2.removedHandler.get());
+        assertNull(handler.addedHandler.getNow());
+        assertNull(handler.removedHandler.getNow());
+        assertNull(handler2.addedHandler.getNow());
+        assertNull(handler2.removedHandler.getNow());
 
         group.register(pipeline.channel()).syncUninterruptibly();
         Throwable cause = handler.error.get();
@@ -875,30 +850,85 @@ public void testAddReplaceHandlerCalledOnceRegistered() throws Throwable {
         }
 
         assertTrue(handler2.addedHandler.get());
-        assertFalse(handler2.removedHandler.get());
+        assertNull(handler2.removedHandler.getNow());
         pipeline.remove(handler2);
         assertTrue(handler2.removedHandler.get());
     }
 
+    @Test(timeout = 3000)
+    public void testAddBefore() throws Throwable {
+        ChannelPipeline pipeline1 = new LocalChannel().pipeline();
+        ChannelPipeline pipeline2 = new LocalChannel().pipeline();
+
+        EventLoopGroup defaultGroup = new DefaultEventLoopGroup(2);
+        try {
+            EventLoop eventLoop1 = defaultGroup.next();
+            EventLoop eventLoop2 = defaultGroup.next();
+
+            eventLoop1.register(pipeline1.channel()).syncUninterruptibly();
+            eventLoop2.register(pipeline2.channel()).syncUninterruptibly();
+
+            CountDownLatch latch = new CountDownLatch(2 * 10);
+            for (int i = 0; i < 10; i++) {
+                eventLoop1.execute(new TestTask(pipeline2, latch));
+                eventLoop2.execute(new TestTask(pipeline1, latch));
+            }
+            latch.await();
+        } finally {
+            defaultGroup.shutdownGracefully();
+        }
+    }
+
+    @Test
+    public void testNullName() {
+        ChannelPipeline pipeline = new LocalChannel().pipeline();
+        pipeline.addLast(newHandler());
+        pipeline.addLast(null, newHandler());
+        pipeline.addFirst(newHandler());
+        pipeline.addFirst(null, newHandler());
+
+        pipeline.addLast("test", newHandler());
+        pipeline.addAfter("test", null, newHandler());
+
+        pipeline.addBefore("test", null, newHandler());
+    }
+
+    private static final class TestTask implements Runnable {
+
+        private final ChannelPipeline pipeline;
+        private final CountDownLatch latch;
+
+        TestTask(ChannelPipeline pipeline, CountDownLatch latch) {
+            this.pipeline = pipeline;
+            this.latch = latch;
+        }
+
+        @Override
+        public void run() {
+            pipeline.addLast(new ChannelInboundHandlerAdapter());
+            latch.countDown();
+        }
+    }
+
     private static final class CallbackCheckHandler extends ChannelHandlerAdapter {
-        final AtomicBoolean addedHandler = new AtomicBoolean();
-        final AtomicBoolean removedHandler = new AtomicBoolean();
+        final Promise<Boolean> addedHandler = ImmediateEventExecutor.INSTANCE.newPromise();
+        final Promise<Boolean> removedHandler = ImmediateEventExecutor.INSTANCE.newPromise();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
 
         @Override
         public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-            if (!addedHandler.compareAndSet(false, true)) {
+            if (!addedHandler.trySuccess(true)) {
                 error.set(new AssertionError("handlerAdded(...) called multiple times: " + ctx.name()));
-            } else if (removedHandler.get()) {
+            } else if (removedHandler.getNow() == Boolean.TRUE) {
                 error.set(new AssertionError("handlerRemoved(...) called before handlerAdded(...): " + ctx.name()));
             }
         }
 
         @Override
         public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
-            if (!removedHandler.compareAndSet(false, true)) {
+            if (!removedHandler.trySuccess(true)) {
                 error.set(new AssertionError("handlerRemoved(...) called multiple times: " + ctx.name()));
-            } else if (!addedHandler.get()) {
+            } else if (addedHandler.getNow() == Boolean.FALSE) {
                 error.set(new AssertionError("handlerRemoved(...) called before handlerAdded(...): " + ctx.name()));
             }
         }
@@ -923,9 +953,14 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
         }
     }
 
-    private static void assertHandler(CheckOrderHandler expected, CheckOrderHandler actual) throws Throwable {
-        assertSame(expected, actual);
-        actual.checkError();
+    private static void assertHandler(CheckOrderHandler actual, CheckOrderHandler... handlers) throws Throwable {
+        for (CheckOrderHandler h : handlers) {
+            if (h == actual) {
+                actual.checkError();
+                return;
+            }
+        }
+        fail("handler was not one of the expected handlers");
     }
 
     private static final class CheckOrderHandler extends ChannelHandlerAdapter {
diff --git a/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java
index 260cd218f31f..03fbd1c37d00 100644
--- a/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java
+++ b/transport/src/test/java/io/netty/channel/PendingWriteQueueTest.java
@@ -150,7 +150,7 @@ private static void assertWrite(ChannelHandler handler, int count) {
 
         ByteBuf[] buffers = new ByteBuf[count];
         for (int i = 0; i < buffers.length; i++) {
-            buffers[i] = buffer.duplicate().retain();
+            buffers[i] = buffer.retainedDuplicate();
         }
         assertTrue(channel.writeOutbound(buffers));
         assertTrue(channel.finish());
@@ -182,7 +182,7 @@ private static void assertWriteFails(ChannelHandler handler, int count) {
         final EmbeddedChannel channel = new EmbeddedChannel(handler);
         ByteBuf[] buffers = new ByteBuf[count];
         for (int i = 0; i < buffers.length; i++) {
-            buffers[i] = buffer.duplicate().retain();
+            buffers[i] = buffer.retainedDuplicate();
         }
         try {
             assertFalse(channel.writeOutbound(buffers));
@@ -197,9 +197,14 @@ private static void assertWriteFails(ChannelHandler handler, int count) {
         assertNull(channel.readOutbound());
     }
 
+    private static EmbeddedChannel newChannel() {
+        // Add a handler so we can access a ChannelHandlerContext via the ChannelPipeline.
+        return new EmbeddedChannel(new ChannelHandlerAdapter() { });
+    }
+
     @Test
     public void testRemoveAndFailAllReentrantFailAll() {
-        EmbeddedChannel channel = new EmbeddedChannel();
+        EmbeddedChannel channel = newChannel();
         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
 
         ChannelPromise promise = channel.newPromise();
@@ -224,7 +229,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     @Test
     public void testRemoveAndFailAllReentrantWrite() {
         final List<Integer> failOrder = Collections.synchronizedList(new ArrayList<Integer>());
-        EmbeddedChannel channel = new EmbeddedChannel();
+        EmbeddedChannel channel = newChannel();
         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
 
         ChannelPromise promise = channel.newPromise();
@@ -267,7 +272,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
 
     @Test
     public void testRemoveAndWriteAllReentrance() {
-        EmbeddedChannel channel = new EmbeddedChannel();
+        EmbeddedChannel channel = newChannel();
         final PendingWriteQueue queue = new PendingWriteQueue(channel.pipeline().firstContext());
 
         ChannelPromise promise = channel.newPromise();
@@ -296,7 +301,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
     // See https://github.com/netty/netty/issues/3967
     @Test
     public void testCloseChannelOnCreation() {
-        EmbeddedChannel channel = new EmbeddedChannel(new ChannelInboundHandlerAdapter());
+        EmbeddedChannel channel = newChannel();
         ChannelHandlerContext context = channel.pipeline().firstContext();
         channel.close().syncUninterruptibly();
 
diff --git a/transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java b/transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java
index fd862cd5675e..41b53d90c0ec 100644
--- a/transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java
+++ b/transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java
@@ -381,7 +381,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
         }
 
         try {
-            ChannelFuture f = loopA.register(ch, promise);
+            ChannelFuture f = loopA.register(promise);
             f.awaitUninterruptibly();
             assertFalse(f.isSuccess());
             assertThat(f.cause(), is(instanceOf(RejectedExecutionException.class)));
diff --git a/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java b/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
index 2c936bd23339..cf02b18090cb 100644
--- a/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
+++ b/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java
@@ -82,7 +82,7 @@ private static void runTest(ThreadPerChannelEventLoopGroup loopGroup) throws Int
         ChannelGroup channelGroup = new DefaultChannelGroup(testExecutor);
         while (taskCount-- > 0) {
             Channel channel = new EmbeddedChannel(NOOP_HANDLER);
-            loopGroup.register(channel, new DefaultChannelPromise(channel, testExecutor));
+            loopGroup.register(new DefaultChannelPromise(channel, testExecutor));
             channelGroup.add(channel);
         }
         channelGroup.close().sync();
diff --git a/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
index 5d35360d14ba..658e46bc2f4e 100644
--- a/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/embedded/EmbeddedChannelTest.java
@@ -19,6 +19,7 @@
 import io.netty.buffer.Unpooled;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerAdapter;
 import io.netty.channel.ChannelHandlerContext;
@@ -39,10 +40,27 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 
 public class EmbeddedChannelTest {
 
+    @Test(timeout = 2000)
+    public void promiseDoesNotInfiniteLoop() throws InterruptedException {
+        EmbeddedChannel channel = new EmbeddedChannel();
+        channel.closeFuture().addListener(new ChannelFutureListener() {
+            @Override
+            public void operationComplete(ChannelFuture future) throws Exception {
+                future.channel().close();
+            }
+        });
+
+        channel.close().syncUninterruptibly();
+    }
+
     @Test
     public void testConstructWithChannelInitializer() {
         final Integer first = 1;
diff --git a/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
index 72985d573151..ca54718f1c11 100644
--- a/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
+++ b/transport/src/test/java/io/netty/channel/local/LocalChannelTest.java
@@ -42,6 +42,7 @@
 import org.junit.BeforeClass;
 import org.junit.Test;
 
+import java.net.ConnectException;
 import java.nio.channels.ClosedChannelException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
@@ -375,7 +376,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                                 ccCpy.pipeline().lastContext().close();
                             }
                         });
-                        ccCpy.writeAndFlush(data.duplicate().retain(), promise);
+                        ccCpy.writeAndFlush(data.retainedDuplicate(), promise);
                     }
                 });
 
@@ -436,10 +437,10 @@ public void run() {
                         promise.addListener(new ChannelFutureListener() {
                             @Override
                             public void operationComplete(ChannelFuture future) throws Exception {
-                                ccCpy.writeAndFlush(data2.duplicate().retain(), ccCpy.newPromise());
+                                ccCpy.writeAndFlush(data2.retainedDuplicate(), ccCpy.newPromise());
                             }
                         });
-                        ccCpy.writeAndFlush(data.duplicate().retain(), promise);
+                        ccCpy.writeAndFlush(data.retainedDuplicate(), promise);
                     }
                 });
 
@@ -519,10 +520,10 @@ public void run() {
                         @Override
                         public void operationComplete(ChannelFuture future) throws Exception {
                             Channel serverChannelCpy = serverChannelRef.get();
-                            serverChannelCpy.writeAndFlush(data2.duplicate().retain(), serverChannelCpy.newPromise());
+                            serverChannelCpy.writeAndFlush(data2.retainedDuplicate(), serverChannelCpy.newPromise());
                         }
                     });
-                    ccCpy.writeAndFlush(data.duplicate().retain(), promise);
+                    ccCpy.writeAndFlush(data.retainedDuplicate(), promise);
                 }
             });
 
@@ -601,11 +602,11 @@ public void run() {
                             @Override
                             public void operationComplete(ChannelFuture future) throws Exception {
                                 Channel serverChannelCpy = serverChannelRef.get();
-                                serverChannelCpy.writeAndFlush(data2.duplicate().retain(),
-                                        serverChannelCpy.newPromise());
+                                serverChannelCpy.writeAndFlush(
+                                        data2.retainedDuplicate(), serverChannelCpy.newPromise());
                             }
                         });
-                        ccCpy.writeAndFlush(data.duplicate().retain(), promise);
+                        ccCpy.writeAndFlush(data.retainedDuplicate(), promise);
                     }
                 });
 
@@ -683,7 +684,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                                 serverChannelRef.get().close();
                             }
                         });
-                        ccCpy.writeAndFlush(data.duplicate().retain(), promise);
+                        ccCpy.writeAndFlush(data.retainedDuplicate(), promise);
                     }
                 });
 
@@ -757,7 +758,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
                 cc.pipeline().lastContext().executor().execute(new OneTimeTask() {
                     @Override
                     public void run() {
-                        ccCpy.writeAndFlush(data.duplicate().retain(), ccCpy.newPromise())
+                        ccCpy.writeAndFlush(data.retainedDuplicate(), ccCpy.newPromise())
                         .addListener(new ChannelFutureListener() {
                             @Override
                             public void operationComplete(ChannelFuture future) throws Exception {
@@ -777,7 +778,7 @@ public void run() {
                                                 fail();
                                             }
                                         }
-                                        serverChannelCpy.writeAndFlush(data2.duplicate().retain(),
+                                        serverChannelCpy.writeAndFlush(data2.retainedDuplicate(),
                                                                        serverChannelCpy.newPromise())
                                             .addListener(new ChannelFutureListener() {
                                             @Override
@@ -863,8 +864,17 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
         }
     }
 
+    @Test(expected = ConnectException.class)
+    public void testConnectionRefused() {
+        Bootstrap sb = new Bootstrap();
+        sb.group(group1)
+        .channel(LocalChannel.class)
+        .handler(new TestHandler())
+        .connect(LocalAddress.ANY).syncUninterruptibly();
+    }
+
     private static final class LatchChannelFutureListener extends CountDownLatch implements ChannelFutureListener {
-        public LatchChannelFutureListener(int count) {
+        private LatchChannelFutureListener(int count) {
             super(count);
         }
 
diff --git a/transport/src/test/java/io/netty/channel/pool/AbstractChannelPoolMapTest.java b/transport/src/test/java/io/netty/channel/pool/AbstractChannelPoolMapTest.java
index 07268704eea5..9f9f3ebce985 100644
--- a/transport/src/test/java/io/netty/channel/pool/AbstractChannelPoolMapTest.java
+++ b/transport/src/test/java/io/netty/channel/pool/AbstractChannelPoolMapTest.java
@@ -25,12 +25,14 @@
 import io.netty.channel.local.LocalEventLoopGroup;
 import org.junit.Test;
 
+import java.net.ConnectException;
+
 import static org.junit.Assert.*;
 
 public class AbstractChannelPoolMapTest {
     private static final String LOCAL_ADDR_ID = "test.id";
 
-    @Test(expected = ChannelException.class)
+    @Test(expected = ConnectException.class)
     public void testMap() throws Exception {
         EventLoopGroup group = new LocalEventLoopGroup();
         LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);