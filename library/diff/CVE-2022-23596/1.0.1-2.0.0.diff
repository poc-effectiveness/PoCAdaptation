diff --git a/pom.xml b/pom.xml
index d7b9c404b..9dcf3a914 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,7 +3,7 @@
 	<groupId>com.github.junrar</groupId>
 	<artifactId>junrar</artifactId>
 	<packaging>jar</packaging>
-	<version>1.0.1</version>
+	<version>2.0.0</version>
 	<name>Java UnRar</name>
 	<description>rar decompression library in plain java</description>
 	<url>https://github.com/junrar/junrar</url>
diff --git a/readme.md b/readme.md
index 142a7b375..91f3f3036 100644
--- a/readme.md
+++ b/readme.md
@@ -1,22 +1,40 @@
 Junrar
 =====
 
-Adds support to read and extract a rar.
+Read and extracts from a .rar file. This is a fork of the junrar codebase, formerly on sourceforge.
+
+Code may not be used to develop a RAR (WinRAR) compatible archiver.
 
-Usage:
-```
 
-final File rar = new File("foo.rar");  
-final File destinationFolder = new File("destinationFolder");  
-ExtractArchive extractArchive = new ExtractArchive();  
-extractArchive.extractArchive(rar, destinationFolder);  
-```
 Dependency on maven:  
 ```
 
 <dependency>  
   <groupId>com.github.junrar</groupId>  
   <artifactId>junrar</artifactId>
-  <version>1.0.0</version>  
+  <version>1.0.1</version>  
 </dependency>  
 ```
+
+
+Extract from files:
+```java
+Junrar.extract("/tmp/foo.rar", "/tmp");
+//or
+final File rar = new File("foo.rar");  
+final File destinationFolder = new File("destinationFolder");
+Junrar.extract(rar, destinationFolder);    
+//or
+final InputStream resourceAsStream = Foo.class.getResourceAsStream("foo.rar");//only for a single rar file
+Junrar.extract(resourceAsStream, tempFolder);
+```
+
+List files:
+```java
+final List<ContentDescription> contentDescriptions = Junrar.getContentsDescription(testDocuments);    
+```
+
+
+
+
+
diff --git a/src/main/java/com/github/junrar/Archive.java b/src/main/java/com/github/junrar/Archive.java
index ec09f8877..96f4b6e53 100644
--- a/src/main/java/com/github/junrar/Archive.java
+++ b/src/main/java/com/github/junrar/Archive.java
@@ -27,6 +27,7 @@
 import java.io.PipedOutputStream;
 import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.logging.Level;
@@ -35,6 +36,7 @@
 import com.github.junrar.exception.RarException;
 import com.github.junrar.exception.RarException.RarExceptionType;
 import com.github.junrar.impl.FileVolumeManager;
+import com.github.junrar.impl.InputStreamVolumeManager;
 import com.github.junrar.io.IReadOnlyAccess;
 import com.github.junrar.rarfile.AVHeader;
 import com.github.junrar.rarfile.BaseBlock;
@@ -57,11 +59,12 @@
 
 /**
  * The Main Rar Class; represents a rar Archive
- * 
+ *
  * @author $LastChangedBy$
  * @version $LastChangedRevision$
  */
-public class Archive implements Closeable {
+public class Archive implements Closeable, Iterable<FileHeader> {
+
 	private static Logger logger = Logger.getLogger(Archive.class.getName());
 
 	private static int MAX_HEADER_SIZE = 20971520;//20MB
@@ -91,34 +94,40 @@ public class Archive implements Closeable {
 	private VolumeManager volumeManager;
 	private Volume volume;
 
-	public Archive(VolumeManager volumeManager) throws RarException,
-			IOException {
+	private FileHeader nextFileHeader;
+
+	public Archive(final VolumeManager volumeManager) throws RarException, IOException {
 		this(volumeManager, null);
 	}
 
 	/**
 	 * create a new archive object using the given {@link VolumeManager}
-	 * 
+	 *
 	 * @param volumeManager
 	 *            the the {@link VolumeManager} that will provide volume stream
 	 *            data
-	 * @throws RarException
+	 * @param unrarCallback
+	 * 			gets feedback on the extraction progress            
+	 *            
+	 * @throws RarException .
+	 * @throws IOException .
 	 */
-	public Archive(VolumeManager volumeManager, UnrarCallback unrarCallback)
-			throws RarException, IOException {
+	public Archive(
+		final VolumeManager volumeManager,
+		final UnrarCallback unrarCallback
+	) throws RarException, IOException {
+
 		this.volumeManager = volumeManager;
 		this.unrarCallback = unrarCallback;
 
 		setVolume(this.volumeManager.nextArchive(this, null));
-		dataIO = new ComprDataIO(this);
-	}
-
-	public Archive(File firstVolume) throws RarException, IOException {
-		this(new FileVolumeManager(firstVolume), null);
+		this.dataIO = new ComprDataIO(this);
 	}
 
-	public Archive(File firstVolume, UnrarCallback unrarCallback)
-			throws RarException, IOException {
+	public Archive(
+		final File firstVolume,
+		final UnrarCallback unrarCallback
+	) throws RarException, IOException {
 		this(new FileVolumeManager(firstVolume), unrarCallback);
 	}
 
@@ -131,14 +140,18 @@ public Archive(File firstVolume, UnrarCallback unrarCallback)
 	// setFile(new ReadOnlyAccessFile(file), file.length());
 	// }
 
-	private void setFile(IReadOnlyAccess file, long length) throws IOException {
-		totalPackedSize = 0L;
-		totalPackedRead = 0L;
+	public Archive(final InputStream rarAsStream) throws RarException, IOException{
+		this(new InputStreamVolumeManager(rarAsStream), null);
+	}
+
+	private void setFile(final IReadOnlyAccess file, final long length) throws IOException {
+		this.totalPackedSize = 0L;
+		this.totalPackedRead = 0L;
 		close();
-		rof = file;
+		this.rof = file;
 		try {
 			readHeaders(length);
-		} catch (Exception e) {
+		} catch (final Exception e) {
 			logger.log(Level.WARNING,
 					"exception in archive constructor maybe file is encrypted "
 							+ "or currupt", e);
@@ -146,29 +159,29 @@ private void setFile(IReadOnlyAccess file, long length) throws IOException {
 			// corrupt archive
 		}
 		// Calculate size of packed data
-		for (BaseBlock block : headers) {
+		for (final BaseBlock block : this.headers) {
 			if (block.getHeaderType() == UnrarHeadertype.FileHeader) {
-				totalPackedSize += ((FileHeader) block).getFullPackSize();
+				this.totalPackedSize += ((FileHeader) block).getFullPackSize();
 			}
 		}
-		if (unrarCallback != null) {
-			unrarCallback.volumeProgressChanged(totalPackedRead,
-					totalPackedSize);
+		if (this.unrarCallback != null) {
+			this.unrarCallback.volumeProgressChanged(this.totalPackedRead,
+					this.totalPackedSize);
 		}
 	}
 
-	public void bytesReadRead(int count) {
+	public void bytesReadRead(final int count) {
 		if (count > 0) {
-			totalPackedRead += count;
-			if (unrarCallback != null) {
-				unrarCallback.volumeProgressChanged(totalPackedRead,
-						totalPackedSize);
+			this.totalPackedRead += count;
+			if (this.unrarCallback != null) {
+				this.unrarCallback.volumeProgressChanged(this.totalPackedRead,
+						this.totalPackedSize);
 			}
 		}
 	}
 
 	public IReadOnlyAccess getRof() {
-		return rof;
+		return this.rof;
 	}
 
 	/**
@@ -177,15 +190,15 @@ public IReadOnlyAccess getRof() {
 	 * @return returns the headers.
 	 */
 	public List<BaseBlock> getHeaders() {
-		return new ArrayList<BaseBlock>(headers);
+		return new ArrayList<BaseBlock>(this.headers);
 	}
 
 	/**
 	 * @return returns all file headers of the archive
 	 */
 	public List<FileHeader> getFileHeaders() {
-		List<FileHeader> list = new ArrayList<FileHeader>();
-		for (BaseBlock block : headers) {
+		final List<FileHeader> list = new ArrayList<FileHeader>();
+		for (final BaseBlock block : this.headers) {
 			if (block.getHeaderType().equals(UnrarHeadertype.FileHeader)) {
 				list.add((FileHeader) block);
 			}
@@ -194,9 +207,9 @@ public List<FileHeader> getFileHeaders() {
 	}
 
 	public FileHeader nextFileHeader() {
-		int n = headers.size();
-		while (currentHeaderIndex < n) {
-			BaseBlock block = headers.get(currentHeaderIndex++);
+		final int n = this.headers.size();
+		while (this.currentHeaderIndex < n) {
+			final BaseBlock block = this.headers.get(this.currentHeaderIndex++);
 			if (block.getHeaderType() == UnrarHeadertype.FileHeader) {
 				return (FileHeader) block;
 			}
@@ -205,16 +218,16 @@ public FileHeader nextFileHeader() {
 	}
 
 	public UnrarCallback getUnrarCallback() {
-		return unrarCallback;
+		return this.unrarCallback;
 	}
 
 	/**
-	 * 
+	 *
 	 * @return whether the archive is encrypted
 	 */
 	public boolean isEncrypted() {
-		if (newMhd != null) {
-			return newMhd.isEncrypted();
+		if (this.newMhd != null) {
+			return this.newMhd.isEncrypted();
 		} else {
 			throw new NullPointerException("mainheader is null");
 		}
@@ -222,26 +235,26 @@ public boolean isEncrypted() {
 
 	/**
 	 * Read the headers of the archive
-	 * 
+	 *
 	 * @param fileLength
 	 *            Length of file.
 	 * @throws RarException
 	 */
-	private void readHeaders(long fileLength) throws IOException, RarException {
-		markHead = null;
-		newMhd = null;
-		headers.clear();
-		currentHeaderIndex = 0;
+	private void readHeaders(final long fileLength) throws IOException, RarException {
+		this.markHead = null;
+		this.newMhd = null;
+		this.headers.clear();
+		this.currentHeaderIndex = 0;
 		int toRead = 0;
 		//keep track of positions already processed for
 		//more robustness against corrupt files
-		Set<Long> processedPositions = new HashSet<Long>();
+		final Set<Long> processedPositions = new HashSet<Long>();
 		while (true) {
 			int size = 0;
 			long newpos = 0;
-			byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);
+			final byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);
 
-			long position = rof.getPosition();
+			final long position = this.rof.getPosition();
 
 			// Weird, but is trying to read beyond the end of the file
 			if (position >= fileLength) {
@@ -249,35 +262,35 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 			}
 
 			// logger.info("\n--------reading header--------");
-			size = rof.readFully(baseBlockBuffer, BaseBlock.BaseBlockSize);
+			size = this.rof.readFully(baseBlockBuffer, BaseBlock.BaseBlockSize);
 			if (size == 0) {
 				break;
 			}
-			BaseBlock block = new BaseBlock(baseBlockBuffer);
+			final BaseBlock block = new BaseBlock(baseBlockBuffer);
 
 			block.setPositionInFile(position);
 
 			switch (block.getHeaderType()) {
 
 			case MarkHeader:
-				markHead = new MarkHeader(block);
-				if (!markHead.isSignature()) {
+				this.markHead = new MarkHeader(block);
+				if (!this.markHead.isSignature()) {
 					throw new RarException(
 							RarException.RarExceptionType.badRarArchive);
 				}
-				headers.add(markHead);
+				this.headers.add(this.markHead);
 				// markHead.print();
 				break;
 
 			case MainHeader:
 				toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc
 						: MainHeader.mainHeaderSize;
-				byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
-				rof.readFully(mainbuff, toRead);
-				MainHeader mainhead = new MainHeader(block, mainbuff);
-				headers.add(mainhead);
+				final byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
+				this.rof.readFully(mainbuff, toRead);
+				final MainHeader mainhead = new MainHeader(block, mainbuff);
+				this.headers.add(mainhead);
 				this.newMhd = mainhead;
-				if (newMhd.isEncrypted()) {
+				if (this.newMhd.isEncrypted()) {
 					throw new RarException(
 							RarExceptionType.rarEncryptedException);
 				}
@@ -286,29 +299,29 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 
 			case SignHeader:
 				toRead = SignHeader.signHeaderSize;
-				byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
-				rof.readFully(signBuff, toRead);
-				SignHeader signHead = new SignHeader(block, signBuff);
-				headers.add(signHead);
+				final byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
+				this.rof.readFully(signBuff, toRead);
+				final SignHeader signHead = new SignHeader(block, signBuff);
+				this.headers.add(signHead);
 				// logger.info("HeaderType: SignHeader");
 
 				break;
 
 			case AvHeader:
 				toRead = AVHeader.avHeaderSize;
-				byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
-				rof.readFully(avBuff, toRead);
-				AVHeader avHead = new AVHeader(block, avBuff);
-				headers.add(avHead);
+				final byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
+				this.rof.readFully(avBuff, toRead);
+				final AVHeader avHead = new AVHeader(block, avBuff);
+				this.headers.add(avHead);
 				// logger.info("headertype: AVHeader");
 				break;
 
 			case CommHeader:
 				toRead = CommentHeader.commentHeaderSize;
-				byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
-				rof.readFully(commBuff, toRead);
-				CommentHeader commHead = new CommentHeader(block, commBuff);
-				headers.add(commHead);
+				final byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
+				this.rof.readFully(commBuff, toRead);
+				final CommentHeader commHead = new CommentHeader(block, commBuff);
+				this.headers.add(commHead);
 				// logger.info("method: "+commHead.getUnpMethod()+"; 0x"+
 				// Integer.toHexString(commHead.getUnpMethod()));
 				newpos = commHead.getPositionInFile()
@@ -317,7 +330,7 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 					throw new RarException(RarExceptionType.badRarArchive);
 				}
 				processedPositions.add(newpos);
-				rof.setPosition(newpos);
+				this.rof.setPosition(newpos);
 
 				break;
 			case EndArcHeader:
@@ -331,8 +344,8 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 				}
 				EndArcHeader endArcHead;
 				if (toRead > 0) {
-					byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
-					rof.readFully(endArchBuff, toRead);
+					final byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);
+					this.rof.readFully(endArchBuff, toRead);
 					endArcHead = new EndArcHeader(block, endArchBuff);
 					// logger.info("HeaderType: endarch\ndatacrc:"+
 					// endArcHead.getArchiveDataCRC());
@@ -340,14 +353,14 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 					// logger.info("HeaderType: endarch - no Data");
 					endArcHead = new EndArcHeader(block, null);
 				}
-				headers.add(endArcHead);
+				this.headers.add(endArcHead);
 				// logger.info("\n--------end header--------");
 				return;
 
 			default:
-				byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);
-				rof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);
-				BlockHeader blockHead = new BlockHeader(block,
+				final byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);
+				this.rof.readFully(blockHeaderBuffer, BlockHeader.blockHeaderSize);
+				final BlockHeader blockHead = new BlockHeader(block,
 						blockHeaderBuffer);
 
 				switch (blockHead.getHeaderType()) {
@@ -356,27 +369,27 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 					toRead = blockHead.getHeaderSize()
 							- BlockHeader.BaseBlockSize
 							- BlockHeader.blockHeaderSize;
-					byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
-					rof.readFully(fileHeaderBuffer, toRead);
+					final byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
+					this.rof.readFully(fileHeaderBuffer, toRead);
 
-					FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);
-					headers.add(fh);
+					final FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);
+					this.headers.add(fh);
 					newpos = fh.getPositionInFile() + fh.getHeaderSize()
 							+ fh.getFullPackSize();
 					if (processedPositions.contains(newpos)) {
 						throw new RarException(RarExceptionType.badRarArchive);
 					}
 					processedPositions.add(newpos);
-					rof.setPosition(newpos);
+					this.rof.setPosition(newpos);
 					break;
 
 				case ProtectHeader:
 					toRead = blockHead.getHeaderSize()
 							- BlockHeader.BaseBlockSize
 							- BlockHeader.blockHeaderSize;
-					byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
-					rof.readFully(protectHeaderBuffer, toRead);
-					ProtectHeader ph = new ProtectHeader(blockHead,
+					final byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
+					this.rof.readFully(protectHeaderBuffer, toRead);
+					final ProtectHeader ph = new ProtectHeader(blockHead,
 							protectHeaderBuffer);
 					newpos = ph.getPositionInFile() + ph.getHeaderSize()
 							+ ph.getDataSize();
@@ -384,25 +397,25 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 						throw new RarException(RarExceptionType.badRarArchive);
 					}
 					processedPositions.add(newpos);
-					rof.setPosition(newpos);
+					this.rof.setPosition(newpos);
 					break;
 
 				case SubHeader: {
-					byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);
-					rof.readFully(subHeadbuffer,
+					final byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);
+					this.rof.readFully(subHeadbuffer,
 							SubBlockHeader.SubBlockHeaderSize);
-					SubBlockHeader subHead = new SubBlockHeader(blockHead,
+					final SubBlockHeader subHead = new SubBlockHeader(blockHead,
 							subHeadbuffer);
 					subHead.print();
 					switch (subHead.getSubType()) {
 					case MAC_HEAD: {
-						byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);
-						rof.readFully(macHeaderbuffer,
+						final byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);
+						this.rof.readFully(macHeaderbuffer,
 								MacInfoHeader.MacInfoHeaderSize);
-						MacInfoHeader macHeader = new MacInfoHeader(subHead,
+						final MacInfoHeader macHeader = new MacInfoHeader(subHead,
 								macHeaderbuffer);
 						macHeader.print();
-						headers.add(macHeader);
+						this.headers.add(macHeader);
 
 						break;
 					}
@@ -410,12 +423,12 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 					case BEEA_HEAD:
 						break;
 					case EA_HEAD: {
-						byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);
-						rof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);
-						EAHeader eaHeader = new EAHeader(subHead,
+						final byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);
+						this.rof.readFully(eaHeaderBuffer, EAHeader.EAHeaderSize);
+						final EAHeader eaHeader = new EAHeader(subHead,
 								eaHeaderBuffer);
 						eaHeader.print();
-						headers.add(eaHeader);
+						this.headers.add(eaHeader);
 
 						break;
 					}
@@ -428,12 +441,12 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 						toRead -= BaseBlock.BaseBlockSize;
 						toRead -= BlockHeader.blockHeaderSize;
 						toRead -= SubBlockHeader.SubBlockHeaderSize;
-						byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
-						rof.readFully(uoHeaderBuffer, toRead);
-						UnixOwnersHeader uoHeader = new UnixOwnersHeader(
+						final byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);
+						this.rof.readFully(uoHeaderBuffer, toRead);
+						final UnixOwnersHeader uoHeader = new UnixOwnersHeader(
 								subHead, uoHeaderBuffer);
 						uoHeader.print();
-						headers.add(uoHeader);
+						this.headers.add(uoHeader);
 						break;
 					default:
 						break;
@@ -451,11 +464,11 @@ private void readHeaders(long fileLength) throws IOException, RarException {
 		}
 	}
 
-	private static byte[] safelyAllocate(long len, int maxSize) throws RarException {
+	private static byte[] safelyAllocate(final long len, final int maxSize) throws RarException {
 		if (maxSize < 0) {
 			throw new IllegalArgumentException("maxsize must be >= 0");
 		}
-		if (len < 0 || len > (long)maxSize) {
+		if (len < 0 || len > maxSize) {
 			throw new RarException(RarExceptionType.badRarArchive);
 		}
 		return new byte[(int)len];
@@ -464,20 +477,20 @@ private static byte[] safelyAllocate(long len, int maxSize) throws RarException
 	/**
 	 * Extract the file specified by the given header and write it to the
 	 * supplied output stream
-	 * 
+	 *
 	 * @param hd
 	 *            the header to be extracted
 	 * @param os
 	 *            the outputstream
-	 * @throws RarException
+	 * @throws RarException .
 	 */
-	public void extractFile(FileHeader hd, OutputStream os) throws RarException {
-		if (!headers.contains(hd)) {
+	public void extractFile(final FileHeader hd, final OutputStream os) throws RarException {
+		if (!this.headers.contains(hd)) {
 			throw new RarException(RarExceptionType.headerNotInArchive);
 		}
 		try {
 			doExtractFile(hd, os);
-		} catch (Exception e) {
+		} catch (final Exception e) {
 			if (e instanceof RarException) {
 				throw (RarException) e;
 			} else {
@@ -490,12 +503,14 @@ public void extractFile(FileHeader hd, OutputStream os) throws RarException {
 	 * Returns an {@link InputStream} that will allow to read the file and
 	 * stream it. Please note that this method will create a new Thread and an a
 	 * pair of Pipe streams.
-	 * 
+	 *
 	 * @param hd
 	 *            the header to be extracted
-	 * @throws RarException
+	 * @throws RarException .
 	 * @throws IOException
 	 *             if any IO error occur
+	 *             
+	 * @return inputstream
 	 */
 	public InputStream getInputStream(final FileHeader hd) throws RarException,
 			IOException {
@@ -505,14 +520,15 @@ public InputStream getInputStream(final FileHeader hd) throws RarException,
 		// creates a new thread that will write data to the pipe. Data will be
 		// available in another InputStream, connected to the OutputStream.
 		new Thread(new Runnable() {
+			@Override
 			public void run() {
 				try {
 					extractFile(hd, out);
-				} catch (RarException e) {
+				} catch (final RarException e) {
 				} finally {
 					try {
 						out.close();
-					} catch (IOException e) {
+					} catch (final IOException e) {
 					}
 				}
 			}
@@ -521,25 +537,25 @@ public void run() {
 		return in;
 	}
 
-	private void doExtractFile(FileHeader hd, OutputStream os)
+	private void doExtractFile(FileHeader hd, final OutputStream os)
 			throws RarException, IOException {
-		dataIO.init(os);
-		dataIO.init(hd);
-		dataIO.setUnpFileCRC(this.isOldFormat() ? 0 : 0xffFFffFF);
-		if (unpack == null) {
-			unpack = new Unpack(dataIO);
+		this.dataIO.init(os);
+		this.dataIO.init(hd);
+		this.dataIO.setUnpFileCRC(this.isOldFormat() ? 0 : 0xffFFffFF);
+		if (this.unpack == null) {
+			this.unpack = new Unpack(this.dataIO);
 		}
 		if (!hd.isSolid()) {
-			unpack.init(null);
+			this.unpack.init(null);
 		}
-		unpack.setDestSize(hd.getFullUnpackSize());
+		this.unpack.setDestSize(hd.getFullUnpackSize());
 		try {
-			unpack.doUnpack(hd.getUnpVersion(), hd.isSolid());
+			this.unpack.doUnpack(hd.getUnpVersion(), hd.isSolid());
 			// Verify file CRC
-			hd = dataIO.getSubHeader();
-			long actualCRC = hd.isSplitAfter() ? ~dataIO.getPackedCRC()
-					: ~dataIO.getUnpFileCRC();
-			int expectedCRC = hd.getFileCRC();
+			hd = this.dataIO.getSubHeader();
+			final long actualCRC = hd.isSplitAfter() ? ~this.dataIO.getPackedCRC()
+					: ~this.dataIO.getUnpFileCRC();
+			final int expectedCRC = hd.getFileCRC();
 			if (actualCRC != expectedCRC) {
 				throw new RarException(RarExceptionType.crcError);
 			}
@@ -549,8 +565,8 @@ private void doExtractFile(FileHeader hd, OutputStream os)
 			// throw new RarException(RarExceptionType.crcError);
 			// }
 			// }
-		} catch (Exception e) {
-			unpack.cleanUp();
+		} catch (final Exception e) {
+			this.unpack.cleanUp();
 			if (e instanceof RarException) {
 				// throw new RarException((RarException)e);
 				throw (RarException) e;
@@ -564,24 +580,25 @@ private void doExtractFile(FileHeader hd, OutputStream os)
 	 * @return returns the main header of this archive
 	 */
 	public MainHeader getMainHeader() {
-		return newMhd;
+		return this.newMhd;
 	}
 
 	/**
 	 * @return whether the archive is old format
 	 */
 	public boolean isOldFormat() {
-		return markHead.isOldFormat();
+		return this.markHead.isOldFormat();
 	}
 
 	/** Close the underlying compressed file. */
+	@Override
 	public void close() throws IOException {
-		if (rof != null) {
-			rof.close();
-			rof = null;
+		if (this.rof != null) {
+			this.rof.close();
+			this.rof = null;
 		}
-		if (unpack != null) {
-			unpack.cleanUp();
+		if (this.unpack != null) {
+			this.unpack.cleanUp();
 		}
 	}
 
@@ -589,14 +606,14 @@ public void close() throws IOException {
 	 * @return the volumeManager
 	 */
 	public VolumeManager getVolumeManager() {
-		return volumeManager;
+		return this.volumeManager;
 	}
 
 	/**
 	 * @param volumeManager
 	 *            the volumeManager to set
 	 */
-	public void setVolumeManager(VolumeManager volumeManager) {
+	public void setVolumeManager(final VolumeManager volumeManager) {
 		this.volumeManager = volumeManager;
 	}
 
@@ -604,16 +621,40 @@ public void setVolumeManager(VolumeManager volumeManager) {
 	 * @return the volume
 	 */
 	public Volume getVolume() {
-		return volume;
+		return this.volume;
 	}
 
 	/**
 	 * @param volume
 	 *            the volume to set
-	 * @throws IOException
+	 * @throws IOException .
 	 */
-	public void setVolume(Volume volume) throws IOException {
+	public void setVolume(final Volume volume) throws IOException {
 		this.volume = volume;
 		setFile(volume.getReadOnlyAccess(), volume.getLength());
 	}
+
+	@Override
+	public Iterator<FileHeader> iterator() {
+		return new Iterator<FileHeader>() {
+
+			@Override
+			public FileHeader next() {
+				FileHeader next;
+				if(Archive.this.nextFileHeader != null) {
+					next =  Archive.this.nextFileHeader;
+				}else {
+					next = nextFileHeader();
+				}
+				return next;
+			}
+
+			@Override
+			public boolean hasNext() {
+				Archive.this.nextFileHeader = nextFileHeader();
+				return Archive.this.nextFileHeader != null;
+			}
+		};
+	}
+
 }
diff --git a/src/main/java/com/github/junrar/ContentDescription.java b/src/main/java/com/github/junrar/ContentDescription.java
new file mode 100644
index 000000000..7f143458f
--- /dev/null
+++ b/src/main/java/com/github/junrar/ContentDescription.java
@@ -0,0 +1,46 @@
+package com.github.junrar;
+
+public class ContentDescription {
+	public String path;
+	public long size;
+	
+	public ContentDescription(String path, long size) {
+		this.path = path;
+		this.size = size;
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((path == null) ? 0 : path.hashCode());
+		result = prime * result + (int) (size ^ (size >>> 32));
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		ContentDescription other = (ContentDescription) obj;
+		if (path == null) {
+			if (other.path != null)
+				return false;
+		} else if (!path.equals(other.path))
+			return false;
+		if (size != other.size)
+			return false;
+		return true;
+	}
+	
+	@Override
+	public String toString() {
+		return path + ": "+size;
+	}
+	
+	
+}
diff --git a/src/main/java/com/github/junrar/ExtractDestination.java b/src/main/java/com/github/junrar/ExtractDestination.java
new file mode 100644
index 000000000..80a597709
--- /dev/null
+++ b/src/main/java/com/github/junrar/ExtractDestination.java
@@ -0,0 +1,17 @@
+package com.github.junrar;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import com.github.junrar.exception.RarException;
+import com.github.junrar.rarfile.FileHeader;
+
+public interface ExtractDestination {
+	
+	public void createDirectory(FileHeader fileHeader);
+	
+	public void extract(
+		final Archive arch, 
+		final FileHeader fileHeader
+	) throws FileNotFoundException, RarException, IOException;
+}
diff --git a/src/main/java/com/github/junrar/Junrar.java b/src/main/java/com/github/junrar/Junrar.java
new file mode 100644
index 000000000..71c34957a
--- /dev/null
+++ b/src/main/java/com/github/junrar/Junrar.java
@@ -0,0 +1,165 @@
+package com.github.junrar;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import com.github.junrar.exception.RarException;
+import com.github.junrar.impl.FileVolumeManager;
+import com.github.junrar.rarfile.FileHeader;
+
+public class Junrar {
+
+	private static Log logger = LogFactory.getLog(Junrar.class.getName());
+
+	public static void extract(final String rarPath, final String destinationPath) throws IOException, RarException {
+		if (rarPath == null || destinationPath == null) {
+			throw new RuntimeException("archive and destination must me set");
+		}
+		final File arch = new File(rarPath);
+		final File dest = new File(destinationPath);
+		extract(arch, dest);
+	}
+
+	public static void extract(final File rar, final File destinationFolder) throws RarException, IOException {
+		validateRarPath(rar);
+		validateDestinationPath(destinationFolder);
+		
+		final Archive archive = createArchiveOrThrowException(logger, rar);
+		LocalFolderExtractor lfe = new LocalFolderExtractor(destinationFolder);
+		extractArchiveTo(archive, lfe);
+	}
+	
+	public static void extract(final InputStream resourceAsStream, final File destinationFolder) throws RarException, IOException {
+		validateDestinationPath(destinationFolder);
+		
+		final Archive arch = createArchiveOrThrowException(logger, resourceAsStream);
+		LocalFolderExtractor lfe = new LocalFolderExtractor(destinationFolder);
+		extractArchiveTo(arch, lfe);
+	}
+	
+	public static void extract(
+		final ExtractDestination destination, 
+		final VolumeManager volumeManager
+	) throws RarException, IOException {
+		final Archive archive = new Archive(volumeManager);
+		extractArchiveTo(archive, destination);
+	}
+
+	public static List<ContentDescription> getContentsDescription(final File rar) throws RarException, IOException {
+		validateRarPath(rar);
+
+		final Archive arch = createArchiveOrThrowException(logger, rar);
+
+		final List<ContentDescription> contents = new ArrayList<ContentDescription>();
+		try{
+			if (arch.isEncrypted()) {
+				logger.warn("archive is encrypted cannot extract");
+				return new ArrayList<ContentDescription>();
+			}
+			for(final FileHeader fileHeader : arch ) {
+				contents.add(new ContentDescription(fileHeader.getFileNameString(), fileHeader.getUnpSize()));
+			}
+		}finally {
+			arch.close();
+		}
+		return contents;
+	}
+
+	private static Archive createArchiveOrThrowException(final Log logger, final InputStream rarAsStream) throws RarException, IOException {
+		try {
+			return new Archive(rarAsStream);
+		} catch (final RarException e) {
+			logger.error(e);
+			throw e;
+		} catch (final IOException e1) {
+			logger.error(e1);
+			throw e1;
+		}
+	}
+
+	private static Archive createArchiveOrThrowException(
+		final Log logger, 
+		final File file
+	) throws RarException, IOException {
+		try {
+			return new Archive(new FileVolumeManager(file));
+		} catch (final RarException e) {
+			logger.error(e);
+			throw e;
+		} catch (final IOException e1) {
+			logger.error(e1);
+			throw e1;
+		}
+	}
+
+	private static void validateDestinationPath(final File destinationFolder) {
+		if (destinationFolder == null) {
+			throw new RuntimeException("archive and destination must me set");
+		}
+		if (!destinationFolder.exists() || !destinationFolder.isDirectory()) {
+			throw new IllegalArgumentException("the destination must exist and point to a directory: " + destinationFolder);
+		}
+	}
+
+	private static void validateRarPath(final File rar) {
+		if (rar == null) {
+			throw new RuntimeException("archive and destination must me set");
+		}
+		if (!rar.exists()) {
+			throw new IllegalArgumentException("the archive does not exit: " + rar);
+		}
+		if(!rar.isFile()) {
+			throw new IllegalArgumentException("First argument should be a file but was "+rar.getAbsolutePath());
+		}
+	}
+
+	private static void extractArchiveTo(final Archive arch, final ExtractDestination destination) throws IOException, RarException {
+		if (arch.isEncrypted()) {
+			logger.warn("archive is encrypted cannot extract");
+			arch.close();
+			return;
+		}
+
+		try{
+			for(final FileHeader fh : arch ) {
+				try {
+					tryToExtract(logger, destination, arch, fh);
+				} catch (final IOException e) {
+					logger.error("error extracting the file", e);
+					throw e;
+				} catch (final RarException e) {
+					logger.error("error extraction the file", e);
+					throw e;
+				}
+			}
+		}finally {
+			arch.close();
+		}
+	}
+
+	private static void tryToExtract(
+		final Log logger,
+		final ExtractDestination destination, 
+		final Archive arch, 
+		final FileHeader fileHeader
+	) throws IOException, RarException {
+		final String fileNameString = fileHeader.getFileNameString();
+		if (fileHeader.isEncrypted()) {
+			logger.warn("file is encrypted cannot extract: "+ fileNameString);
+			return;
+		}
+		logger.info("extracting: " + fileNameString);
+		if (fileHeader.isDirectory()) {
+			destination.createDirectory(fileHeader);
+		} else {
+			destination.extract(arch, fileHeader);
+		}
+	}		
+
+}
diff --git a/src/main/java/com/github/junrar/LocalFolderExtractor.java b/src/main/java/com/github/junrar/LocalFolderExtractor.java
new file mode 100644
index 000000000..4c1d7b96d
--- /dev/null
+++ b/src/main/java/com/github/junrar/LocalFolderExtractor.java
@@ -0,0 +1,107 @@
+package com.github.junrar;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import com.github.junrar.exception.RarException;
+import com.github.junrar.rarfile.FileHeader;
+
+public class LocalFolderExtractor implements ExtractDestination{
+
+	private File folderDestination;
+	private static Log logger = LogFactory.getLog(LocalFolderExtractor.class.getName());
+
+	public LocalFolderExtractor(final File destination) {
+		this.folderDestination = destination;
+	}
+	
+	@Override
+	public void createDirectory(final FileHeader fh) {
+		File f = null;
+		if (fh.isDirectory() && fh.isUnicode()) {
+			f = new File(folderDestination, fh.getFileNameW());
+			if (!f.exists()) {
+				makeDirectory(folderDestination, fh.getFileNameW());
+			}
+		} else if (fh.isDirectory() && !fh.isUnicode()) {
+			f = new File(folderDestination, fh.getFileNameString());
+			if (!f.exists()) {
+				makeDirectory(folderDestination, fh.getFileNameString());
+			}
+		}
+	}
+	
+	@Override
+	public void extract(
+		final Archive arch, 
+		final FileHeader fileHeader
+	) throws FileNotFoundException, RarException, IOException {
+		final File f = createFile(fileHeader, folderDestination);
+		final OutputStream stream = new FileOutputStream(f);
+		arch.extractFile(fileHeader, stream);
+		stream.close();
+	}
+	
+	private void makeDirectory(final File destination, final String fileName) {
+		final String[] dirs = fileName.split("\\\\");
+		if (dirs == null) {
+			return;
+		}
+		String path = "";
+		for (final String dir : dirs) {
+			path = path + File.separator + dir;
+			new File(destination, path).mkdir();
+		}
+
+	}
+	
+	private File createFile(final FileHeader fh, final File destination) {
+		File f = null;
+		String name = null;
+		if (fh.isFileHeader() && fh.isUnicode()) {
+			name = fh.getFileNameW();
+		} else {
+			name = fh.getFileNameString();
+		}
+		f = new File(destination, name);
+		if (!f.exists()) {
+			try {
+				f = makeFile(destination, name);
+			} catch (final IOException e) {
+				logger.error("error creating the new file: " + f.getName(), e);
+			}
+		}
+		return f;
+	}
+	
+	private File makeFile(final File destination, final String name) throws IOException {
+		final String[] dirs = name.split("\\\\");
+		if (dirs == null) {
+			return null;
+		}
+		String path = "";
+		final int size = dirs.length;
+		if (size == 1) {
+			return new File(destination, name);
+		} else if (size > 1) {
+			for (int i = 0; i < dirs.length - 1; i++) {
+				path = path + File.separator + dirs[i];
+				new File(destination, path).mkdir();
+			}
+			path = path + File.separator + dirs[dirs.length - 1];
+			final File f = new File(destination, path);
+			f.createNewFile();
+			return f;
+		} else {
+			return null;
+		}
+	}
+	
+
+}
diff --git a/src/main/java/com/github/junrar/UnrarCallback.java b/src/main/java/com/github/junrar/UnrarCallback.java
index 06bc08893..88c7799b5 100755
--- a/src/main/java/com/github/junrar/UnrarCallback.java
+++ b/src/main/java/com/github/junrar/UnrarCallback.java
@@ -8,14 +8,22 @@
 public interface UnrarCallback {
 
     /**
-     * Return <tt>true</tt> if the next volume is ready to be processed,
+     * @param nextVolume ,
+     * 
+     * @return <tt>true</tt> if the next volume is ready to be processed,
      * <tt>false</tt> otherwise.
+     * 
+     * 
      */
     boolean isNextVolumeReady(Volume nextVolume);
 
     /**
      * This method is invoked each time the progress of the current
      * volume changes.
+     * 
+     * @param current .
+     * @param total .
+     * 
      */
     void volumeProgressChanged(long current, long total);
 }
diff --git a/src/main/java/com/github/junrar/Volume.java b/src/main/java/com/github/junrar/Volume.java
index 1acb91a7c..988d0f3e7 100644
--- a/src/main/java/com/github/junrar/Volume.java
+++ b/src/main/java/com/github/junrar/Volume.java
@@ -11,8 +11,9 @@
  */
 public interface Volume {
 	/**
-	 * @return the access
-	 * @throws IOException
+	 * @throws IOException .
+	 * 
+	 * @return IReadOnlyAccess the access
 	 */
 	IReadOnlyAccess getReadOnlyAccess() throws IOException;
 
diff --git a/src/main/java/com/github/junrar/VolumeManager.java b/src/main/java/com/github/junrar/VolumeManager.java
index 6507ec10a..c104b28cf 100644
--- a/src/main/java/com/github/junrar/VolumeManager.java
+++ b/src/main/java/com/github/junrar/VolumeManager.java
@@ -4,9 +4,8 @@
 
 /**
  * @author <a href="http://www.rogiel.com">Rogiel</a>
- * 
+ *
  */
 public interface VolumeManager {
-	public Volume nextArchive(Archive archive, Volume lastVolume)
-			throws IOException;
+	public Volume nextArchive(Archive archive, Volume lastVolume) throws IOException;
 }
diff --git a/src/main/java/com/github/junrar/extract/ExtractArchive.java b/src/main/java/com/github/junrar/extract/ExtractArchive.java
index eccaed57a..076c2b00a 100644
--- a/src/main/java/com/github/junrar/extract/ExtractArchive.java
+++ b/src/main/java/com/github/junrar/extract/ExtractArchive.java
@@ -1,15 +1,10 @@
 package com.github.junrar.extract;
 
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 
-import org.apache.commons.logging.Log;
-
-import com.github.junrar.Archive;
+import com.github.junrar.Junrar;
 import com.github.junrar.exception.RarException;
-import com.github.junrar.rarfile.FileHeader;
 
 /**
  * extract an archive to the given location
@@ -18,153 +13,18 @@
  * 
  */
 public class ExtractArchive {
-
-	private Log logger;
-
-	public void setLogger(Log logger) {
-		this.logger = logger;
-	}
 	
+	/**
+	 * @deprecated  As of release 1.0.2, replaced by { @link #Junrar.extract(final String rarPath, final String destinationPath) }
+	 * 
+	 * @param archive rar file path
+	 * @param destination folder where the files will be extracted
+	 * 
+	 * @throws IOException .
+	 * @throws RarException .
+	 */
+	@Deprecated 
 	public void extractArchive(File archive, File destination) throws RarException, IOException {
-		Archive arch = null;
-		try {
-			arch = new Archive(archive);
-		} catch (RarException e) {
-			logError(e);
-			throw e;
-		} catch (IOException e1) {
-			logError(e1);
-			throw e1;
-		}
-		if (arch != null) {
-			if (arch.isEncrypted()) {
-				logWarn("archive is encrypted cannot extract");
-				return;
-			}
-			try{
-				FileHeader fh = null;
-				while (true) {
-					fh = arch.nextFileHeader();
-					if (fh == null) {
-						break;
-					}
-					String fileNameString = fh.getFileNameString();
-					if (fh.isEncrypted()) {
-						logWarn("file is encrypted cannot extract: "+ fileNameString);
-						continue;
-					}
-					logInfo("extracting: " + fileNameString);
-					try {
-						if (fh.isDirectory()) {
-							createDirectory(fh, destination);
-						} else {
-							File f = createFile(fh, destination);
-							OutputStream stream = new FileOutputStream(f);
-							arch.extractFile(fh, stream);
-							stream.close();
-						}
-					} catch (IOException e) {
-						logError(e, "error extracting the file");
-						throw e;
-					} catch (RarException e) {
-						logError(e,"error extraction the file");
-						throw e;
-					}
-				}
-			}finally {
-				try {
-					arch.close();
-				} catch (IOException e) {
-					logError(e);
-				}
-			}
-		}
-	}
-
-	private void logWarn(String warning) {
-		if(logger!=null) logger.warn(warning);
-	}
-
-	private void logInfo(String info) {
-		if(logger!=null) logger.info(info);
-	}
-
-	private void logError(Exception e, String errorMessage) {
-		if(logger!=null) logger.error(errorMessage, e);
-	}
-
-	private void logError(Exception e) {
-		if(logger!=null) logger.error(e);
-	}
-
-	private File createFile(FileHeader fh, File destination) {
-		File f = null;
-		String name = null;
-		if (fh.isFileHeader() && fh.isUnicode()) {
-			name = fh.getFileNameW();
-		} else {
-			name = fh.getFileNameString();
-		}
-		f = new File(destination, name);
-		if (!f.exists()) {
-			try {
-				f = makeFile(destination, name);
-			} catch (IOException e) {
-				logError(e, "error creating the new file: " + f.getName());
-			}
-		}
-		return f;
-	}
-
-	private static File makeFile(File destination, String name)
-			throws IOException {
-		String[] dirs = name.split("\\\\");
-		if (dirs == null) {
-			return null;
-		}
-		String path = "";
-		int size = dirs.length;
-		if (size == 1) {
-			return new File(destination, name);
-		} else if (size > 1) {
-			for (int i = 0; i < dirs.length - 1; i++) {
-				path = path + File.separator + dirs[i];
-				new File(destination, path).mkdir();
-			}
-			path = path + File.separator + dirs[dirs.length - 1];
-			File f = new File(destination, path);
-			f.createNewFile();
-			return f;
-		} else {
-			return null;
-		}
-	}
-
-	private static void createDirectory(FileHeader fh, File destination) {
-		File f = null;
-		if (fh.isDirectory() && fh.isUnicode()) {
-			f = new File(destination, fh.getFileNameW());
-			if (!f.exists()) {
-				makeDirectory(destination, fh.getFileNameW());
-			}
-		} else if (fh.isDirectory() && !fh.isUnicode()) {
-			f = new File(destination, fh.getFileNameString());
-			if (!f.exists()) {
-				makeDirectory(destination, fh.getFileNameString());
-			}
-		}
-	}
-
-	private static void makeDirectory(File destination, String fileName) {
-		String[] dirs = fileName.split("\\\\");
-		if (dirs == null) {
-			return;
-		}
-		String path = "";
-		for (String dir : dirs) {
-			path = path + File.separator + dir;
-			new File(destination, path).mkdir();
-		}
-
+		Junrar.extract(archive, destination);	
 	}
 }
diff --git a/src/main/java/com/github/junrar/impl/FileVolume.java b/src/main/java/com/github/junrar/impl/FileVolume.java
index dfa464e57..c8fe055f9 100644
--- a/src/main/java/com/github/junrar/impl/FileVolume.java
+++ b/src/main/java/com/github/junrar/impl/FileVolume.java
@@ -18,7 +18,8 @@ public class FileVolume implements Volume {
 	private final File file;
 
 	/**
-	 * @param file
+	 * @param archive .
+	 * @param file .
 	 */
 	public FileVolume(Archive archive, File file) {
 		this.archive = archive;
diff --git a/src/main/java/com/github/junrar/impl/FileVolumeManager.java b/src/main/java/com/github/junrar/impl/FileVolumeManager.java
index 874dc0935..723d41131 100644
--- a/src/main/java/com/github/junrar/impl/FileVolumeManager.java
+++ b/src/main/java/com/github/junrar/impl/FileVolumeManager.java
@@ -11,27 +11,25 @@
 
 /**
  * @author <a href="http://www.rogiel.com">Rogiel</a>
- * 
+ *
  */
 public class FileVolumeManager implements VolumeManager {
 	private final File firstVolume;
 
-	public FileVolumeManager(File firstVolume) {
+	public FileVolumeManager(final File firstVolume) {
 		this.firstVolume = firstVolume;
 	}
 
 	@Override
-	public Volume nextArchive(Archive archive, Volume last)
-			throws IOException {
-		if (last == null)
-			return new FileVolume(archive, firstVolume);
+	public Volume nextArchive(final Archive archive, final Volume last) throws IOException {
+		if (last == null) return new FileVolume(archive, this.firstVolume);
 
-		FileVolume lastFileVolume = (FileVolume) last;
-		boolean oldNumbering = !archive.getMainHeader().isNewNumbering()
+		final FileVolume lastFileVolume = (FileVolume) last;
+		final boolean oldNumbering = !archive.getMainHeader().isNewNumbering()
 				|| archive.isOldFormat();
-		String nextName = VolumeHelper.nextVolumeName(lastFileVolume.getFile()
+		final String nextName = VolumeHelper.nextVolumeName(lastFileVolume.getFile()
 				.getAbsolutePath(), oldNumbering);
-		File nextVolume = new File(nextName);
+		final File nextVolume = new File(nextName);
 
 		return new FileVolume(archive, nextVolume);
 	}
diff --git a/src/main/java/com/github/junrar/impl/InputStreamVolume.java b/src/main/java/com/github/junrar/impl/InputStreamVolume.java
new file mode 100644
index 000000000..9a91835b3
--- /dev/null
+++ b/src/main/java/com/github/junrar/impl/InputStreamVolume.java
@@ -0,0 +1,36 @@
+package com.github.junrar.impl;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import com.github.junrar.Archive;
+import com.github.junrar.Volume;
+import com.github.junrar.io.IReadOnlyAccess;
+import com.github.junrar.io.InputStreamReadOnlyAccessFile;
+
+public class InputStreamVolume implements Volume {
+
+	private final Archive archive;
+	private final InputStream inputStream;
+
+	public InputStreamVolume(final Archive archive, final InputStream inputStream) {
+		this.archive = archive;
+		this.inputStream = inputStream;
+	}
+
+	@Override
+	public IReadOnlyAccess getReadOnlyAccess() throws IOException {
+		return new InputStreamReadOnlyAccessFile(this.inputStream);
+	}
+
+	@Override
+	public long getLength() {
+		return Long.MAX_VALUE;
+	}
+
+	@Override
+	public Archive getArchive() {
+		return this.archive;
+	}
+
+}
diff --git a/src/main/java/com/github/junrar/impl/InputStreamVolumeManager.java b/src/main/java/com/github/junrar/impl/InputStreamVolumeManager.java
new file mode 100644
index 000000000..9a5bdb46c
--- /dev/null
+++ b/src/main/java/com/github/junrar/impl/InputStreamVolumeManager.java
@@ -0,0 +1,23 @@
+package com.github.junrar.impl;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import com.github.junrar.Archive;
+import com.github.junrar.Volume;
+import com.github.junrar.VolumeManager;
+
+public class InputStreamVolumeManager implements VolumeManager {
+
+	private final InputStream is;
+
+	public InputStreamVolumeManager(final InputStream is) {
+		this.is = is;
+	}
+
+	@Override
+	public Volume nextArchive(final Archive archive, final Volume lastVolume) throws IOException {
+		return new InputStreamVolume(archive, this.is);
+	}
+
+}
diff --git a/src/main/java/com/github/junrar/io/IReadOnlyAccess.java b/src/main/java/com/github/junrar/io/IReadOnlyAccess.java
index 6da7ce9ea..02d9ed9c5 100644
--- a/src/main/java/com/github/junrar/io/IReadOnlyAccess.java
+++ b/src/main/java/com/github/junrar/io/IReadOnlyAccess.java
@@ -30,19 +30,39 @@ public interface IReadOnlyAccess {
 
 	/**
 	 * @return the current position in the file
+	 * 
+	 * @throws IOException .
+	 * 
 	 */
 	public long getPosition() throws IOException;
 		
 	/**
 	 * @param pos the position in the file 
+	 * 
+	 * @throws IOException .
 	 */
 	public void setPosition(long pos) throws IOException;
 
-    /** Read a single byte of data. */
+    /** 
+     * Read a single byte of data.
+     * 
+     * @return read read
+     *  
+	 * @throws IOException .
+     */
     public int read() throws IOException;
 
 	/**
      * Read up to <tt>count</tt> bytes to the specified buffer.
+     * 
+     * @param buffer .
+     * @param off .
+     * @param count .
+     * 
+     * @return read read
+     * 
+     * @throws IOException .
+     * 
      */
     public int read(byte[] buffer, int off, int count) throws IOException;
 
@@ -51,10 +71,15 @@ public interface IReadOnlyAccess {
      *
 	 * @param buffer where to store the read data
 	 * @param count how many bytes to read
-	 * @return bytes read || -1 if  IO problem 
+	 * @return bytes read || -1 if  IO problem
+	 * 
+     * @throws IOException . 
 	 */
 	public int readFully(byte[] buffer, int count) throws IOException;
 
-    /** Close this file. */
+    /** 
+     * Close this file.
+     * @throws IOException . 
+     */
     public void close() throws IOException;
 }
diff --git a/src/main/java/com/github/junrar/io/RandomAccessStream.java b/src/main/java/com/github/junrar/io/RandomAccessStream.java
index 49442bff8..fa84a41b4 100644
--- a/src/main/java/com/github/junrar/io/RandomAccessStream.java
+++ b/src/main/java/com/github/junrar/io/RandomAccessStream.java
@@ -29,6 +29,9 @@ public final class RandomAccessStream extends InputStream {
 	/**
 	 * Constructs a RandomAccessStream from an InputStream. Seeking backwards is
 	 * supported using a memory cache.
+	 * 
+	 * @param inputstream .
+	 * 
 	 */
 	public RandomAccessStream(InputStream inputstream) {
 		pointer = 0L;
@@ -38,7 +41,12 @@ public RandomAccessStream(InputStream inputstream) {
 		src = inputstream;
 	}
 
-	/** Constructs a RandomAccessStream from an RandomAccessFile. */
+	/** 
+	 * Constructs a RandomAccessStream from an RandomAccessFile.
+	 * 
+	 * @param ras ras
+	 *  
+	 */
 	public RandomAccessStream(RandomAccessFile ras) {
 		this.ras = ras;
 	}
diff --git a/src/main/java/com/github/junrar/io/Raw.java b/src/main/java/com/github/junrar/io/Raw.java
index 013d4a4e6..c7863d97d 100644
--- a/src/main/java/com/github/junrar/io/Raw.java
+++ b/src/main/java/com/github/junrar/io/Raw.java
@@ -129,9 +129,9 @@ public static final int readIntLittleEndian(byte[] array, int pos) {
      * Read an long value(unsigned int) from the byte array at the given
      * position (little Endian)
      * 
-     * @param array
-     * @param pos
-     * @return
+     * @param array .
+     * @param pos .
+     * @return .
      */
     public static final long readIntLittleEndianAsLong(byte[] array, int pos) {
 	return (((long) array[pos + 3] & 0xff) << 24)
@@ -250,6 +250,11 @@ public static final void writeShortLittleEndian(byte[] array, int pos,
     /**
      * Increment a short value at the specified position by the specified amount
      * (little endian).
+     * 
+     * @param array .
+	 * @param pos .
+	 * @param dv .
+     * 
      */
     public static final void incShortLittleEndian(byte[] array, int pos, int dv) {
 	int c = ((array[pos] & 0xff) + (dv & 0xff)) >>> 8;
diff --git a/src/main/java/com/github/junrar/io/ReadOnlyAccessFile.java b/src/main/java/com/github/junrar/io/ReadOnlyAccessFile.java
index 77ad35a1d..ad19546ec 100644
--- a/src/main/java/com/github/junrar/io/ReadOnlyAccessFile.java
+++ b/src/main/java/com/github/junrar/io/ReadOnlyAccessFile.java
@@ -5,15 +5,15 @@
  *
  * Source: $HeadURL$
  * Last changed: $LastChangedDate$
- * 
- * the unrar licence applies to all junrar source and binary distributions 
+ *
+ * the unrar licence applies to all junrar source and binary distributions
  * you are not allowed to use this source to re-create the RAR compression algorithm
- * 
+ *
  * Here some html entities which can be used for escaping javadoc tags:
  * "&":  "&#038;" or "&amp;"
  * "<":  "&#060;" or "&lt;"
  * ">":  "&#062;" or "&gt;"
- * "@":  "&#064;" 
+ * "@":  "&#064;"
  */
 package com.github.junrar.io;
 
@@ -28,28 +28,30 @@
  * @author $LastChangedBy$
  * @version $LastChangedRevision$
  */
-public class ReadOnlyAccessFile extends RandomAccessFile
-        implements IReadOnlyAccess{
+public class ReadOnlyAccessFile extends RandomAccessFile implements IReadOnlyAccess{
 
 	/**
 	 * @param file the file
-	 * @throws FileNotFoundException
+	 * @throws FileNotFoundException .
 	 */
-	public ReadOnlyAccessFile(File file) throws FileNotFoundException {
+	public ReadOnlyAccessFile(final File file) throws FileNotFoundException {
 		super(file, "r");
 	}
 
-	public int readFully(byte[] buffer, int count) throws IOException {
-        assert (count > 0) : count;
+	@Override
+	public int readFully(final byte[] buffer, final int count) throws IOException {
+        assert count > 0 : count;
         this.readFully(buffer, 0, count);
         return count;
     }
 
+	@Override
 	public long getPosition() throws IOException {
         return this.getFilePointer();
 	}
 
-	public void setPosition(long pos) throws IOException {
+	@Override
+	public void setPosition(final long pos) throws IOException {
         this.seek(pos);
 	}
 }
diff --git a/src/main/java/com/github/junrar/rarfile/FileHeader.java b/src/main/java/com/github/junrar/rarfile/FileHeader.java
index 7a3666bee..7dbefd6cb 100644
--- a/src/main/java/com/github/junrar/rarfile/FileHeader.java
+++ b/src/main/java/com/github/junrar/rarfile/FileHeader.java
@@ -357,7 +357,7 @@ public String toString() {
     /**
      * the file will be continued in the next archive part
      * 
-     * @return
+     * @return isSplitAfter
      */
     public boolean isSplitAfter() {
 	return (this.flags & BlockHeader.LHD_SPLIT_AFTER) != 0;
@@ -366,7 +366,7 @@ public boolean isSplitAfter() {
     /**
      * the file is continued in this archive
      * 
-     * @return
+     * @return isSplitBefore
      */
     public boolean isSplitBefore() {
 	return (this.flags & LHD_SPLIT_BEFORE) != 0;
@@ -375,7 +375,7 @@ public boolean isSplitBefore() {
     /**
      * this file is compressed as solid (all files handeled as one)
      * 
-     * @return
+     * @return isSolid
      */
     public boolean isSolid() {
 	return (this.flags & LHD_SOLID) != 0;
@@ -384,7 +384,7 @@ public boolean isSolid() {
     /**
      * the file is encrypted
      * 
-     * @return
+     * @return isEncrypted
      */
     public boolean isEncrypted() {
 	return (this.flags & BlockHeader.LHD_PASSWORD) != 0;
@@ -393,7 +393,7 @@ public boolean isEncrypted() {
     /**
      * the filename is also present in unicode
      * 
-     * @return
+     * @return isUnicode
      */
     public boolean isUnicode() {
 	return (flags & LHD_UNICODE) != 0;
@@ -414,7 +414,7 @@ public boolean isLargeBlock() {
     /**
      * whether this fileheader represents a directory
      * 
-     * @return
+     * @return isDirectory
      */
     public boolean isDirectory() {
 	return (flags & LHD_WINDOWMASK) == LHD_DIRECTORY;
diff --git a/src/main/java/com/github/junrar/rarfile/MainHeader.java b/src/main/java/com/github/junrar/rarfile/MainHeader.java
index f09e2b3cf..b13000a65 100644
--- a/src/main/java/com/github/junrar/rarfile/MainHeader.java
+++ b/src/main/java/com/github/junrar/rarfile/MainHeader.java
@@ -60,7 +60,7 @@ public boolean hasArchCmt(){
 	}
 	/**
 	 * the version the the encryption 
-	 * @return
+	 * @return . 
 	 */
 	public byte getEncryptVersion() {
 		return encryptVersion;
@@ -76,23 +76,23 @@ public int getPosAv() {
 	
 	/**
 	 * returns whether the archive is encrypted 
-	 * @return
+	 * @return .
 	 */
 	public boolean isEncrypted(){
 		return (this.flags & BaseBlock.MHD_PASSWORD)!=0;
 	}
 	
 	/**
-	 * return whether the archive is a multivolume archive
-	 * @return
+	 * 
+	 * @return whether the archive is a multivolume archive
 	 */
 	public boolean isMultiVolume(){
 		return (this.flags & BaseBlock.MHD_VOLUME)!=0;
 	}
 	
 	/**
-	 * if the archive is a multivolume archive this method returns whether this instance is the first part of the multivolume archive
-	 * @return
+	 * 
+	 * @return if the archive is a multivolume archive this method returns whether this instance is the first part of the multivolume archive
 	 */
 	public boolean isFirstVolume(){
 		return (this.flags & BaseBlock.MHD_FIRSTVOLUME)!=0;
@@ -116,8 +116,7 @@ public void print(){
 	}
 	
 	/**
-	 * returns whether this archive is solid. in this case you can only extract all file at once
-	 * @return
+	 * @return whether this archive is solid. in this case you can only extract all file at once
 	 */
 	public boolean isSolid(){
 		return (this.flags&MHD_SOLID)!=0;
@@ -135,8 +134,8 @@ public boolean isAV(){
 		return (this.flags&MHD_AV)!=0;
 	}
 	/**
-	 * the numbering format a multivolume archive
-	 * @return
+	 * 
+	 * @return the numbering format a multivolume archive
 	 */
 	public boolean isNewNumbering(){
 		return (this.flags&MHD_NEWNUMBERING)!=0;
diff --git a/src/main/java/com/github/junrar/rarfile/NewSubHeaderType.java b/src/main/java/com/github/junrar/rarfile/NewSubHeaderType.java
index e0096f7c4..acca3864f 100644
--- a/src/main/java/com/github/junrar/rarfile/NewSubHeaderType.java
+++ b/src/main/java/com/github/junrar/rarfile/NewSubHeaderType.java
@@ -28,52 +28,28 @@
  */
 public class NewSubHeaderType {
     
-    /**
-     * comment subheader
-     */
+
     public static final NewSubHeaderType SUBHEAD_TYPE_CMT = new NewSubHeaderType(new byte[]{'C','M','T'});
-    /**
-     * 
-     */
     public static final NewSubHeaderType SUBHEAD_TYPE_ACL = new NewSubHeaderType(new byte[]{'A','C','L'});
-    /**
-     * 
-     */
     public static final NewSubHeaderType SUBHEAD_TYPE_STREAM = new NewSubHeaderType(new byte[]{'S','T','M'});
-    /**
-     * 
-     */
     public static final NewSubHeaderType SUBHEAD_TYPE_UOWNER = new NewSubHeaderType(new byte[]{'U','O','W'});
-    /**
-     * 
-     */
     public static final NewSubHeaderType SUBHEAD_TYPE_AV = new NewSubHeaderType(new byte[]{'A','V'});
     /**
      * recovery record subheader
      */
     public static final NewSubHeaderType SUBHEAD_TYPE_RR = new NewSubHeaderType(new byte[]{'R','R'});
-    /**
-     * 
-     */
     public static final NewSubHeaderType SUBHEAD_TYPE_OS2EA = new NewSubHeaderType(new byte[]{'E','A','2'});
-    /**
-     * 
-     */
     public static final NewSubHeaderType SUBHEAD_TYPE_BEOSEA = new NewSubHeaderType(new byte[]{'E','A','B','E'});
     
     private byte[] headerTypes;
     
-    /**
-     * Private constructor
-     * @param headerTypes
-     */
     private NewSubHeaderType(byte[] headerTypes)
     {
         this.headerTypes = headerTypes;
     }
     
     /**
-     * @param toCompare
+     * @param toCompare .
      * @return Returns true if the given byte array matches to the internal byte array of this header.
      */
     public boolean byteEquals(byte[] toCompare)
diff --git a/src/main/java/com/github/junrar/rarfile/SubBlockHeader.java b/src/main/java/com/github/junrar/rarfile/SubBlockHeader.java
index 004970cdf..ca5d76273 100644
--- a/src/main/java/com/github/junrar/rarfile/SubBlockHeader.java
+++ b/src/main/java/com/github/junrar/rarfile/SubBlockHeader.java
@@ -50,16 +50,10 @@ public SubBlockHeader(BlockHeader bh, byte[] subblock)
 		level |= subblock[position]&0xff;
 	}
 
-	/**
-	 * @return
-	 */
 	public byte getLevel() {
 		return level;
 	}
 
-	/**
-	 * @return
-	 */
 	public SubBlockHeaderType getSubType() {
 		return SubBlockHeaderType.findSubblockHeaderType(subType);
 	}
diff --git a/src/main/java/com/github/junrar/rarfile/SubBlockHeaderType.java b/src/main/java/com/github/junrar/rarfile/SubBlockHeaderType.java
index 9696e9c43..b210fcf20 100644
--- a/src/main/java/com/github/junrar/rarfile/SubBlockHeaderType.java
+++ b/src/main/java/com/github/junrar/rarfile/SubBlockHeaderType.java
@@ -37,7 +37,7 @@ private SubBlockHeaderType(short subblocktype)
 	
 	/**
 	 * Return true if the given value is equal to the enum's value
-	 * @param subblocktype
+	 * @param subblocktype .
 	 * @return true if the given value is equal to the enum's value
 	 */
 	public boolean equals(short subblocktype)
diff --git a/src/main/java/com/github/junrar/rarfile/UnrarHeadertype.java b/src/main/java/com/github/junrar/rarfile/UnrarHeadertype.java
index 9214759ab..c4c1ec998 100644
--- a/src/main/java/com/github/junrar/rarfile/UnrarHeadertype.java
+++ b/src/main/java/com/github/junrar/rarfile/UnrarHeadertype.java
@@ -27,54 +27,15 @@
 public enum UnrarHeadertype {
 	
 	
-	/**
-	 * 
-	 */
 	MainHeader		((byte)0x73),
-	
-	/**
-	 * 
-	 */
 	MarkHeader		((byte)0x72),
-	
-	/**
-	 * 
-	 */
 	FileHeader 		((byte) 0x74),
-	
-	/**
-	 * 
-	 */
 	CommHeader  	((byte) 0x75),
-	
-	/**
-	 * 
-	 */
 	AvHeader 		((byte) 0x76),
-	
-	/**
-	 * 
-	 */
 	SubHeader 		((byte)  0x77),
-	
-	/**
-	 * 
-	 */
 	ProtectHeader  	((byte) 0x78),
-	
-	/**
-	 * 
-	 */
 	SignHeader 		((byte)  0x79),
-	
-	/**
-	 * 
-	 */
 	NewSubHeader 	((byte) 0x7a),
-	
-	/**
-	 * 
-	 */
 	EndArcHeader 	((byte)  0x7b);
 	
 	/**
@@ -128,8 +89,6 @@ public static UnrarHeadertype findType(byte headerType)
 		}
 		return null;
 	}
-
-	
 	
 	private byte headerByte;
 	
@@ -137,11 +96,10 @@ private UnrarHeadertype(byte headerByte)
 	{
 		this.headerByte = headerByte;
 	}
-
 	
 	/**
 	 * Return true if the given byte is equal to the enum's byte
-	 * @param header
+	 * @param header header
 	 * @return true if the given byte is equal to the enum's byte
 	 */
 	public boolean equals(byte header)
@@ -149,16 +107,12 @@ public boolean equals(byte header)
 		return headerByte == header;
 	}
 
-
 	/**
 	 * the header byte of this enum
 	 * @return the header byte of this enum
 	 */
 	public byte getHeaderByte() {
 		return headerByte;
-	}
-
-
-	
+	}	
 	
 }
diff --git a/src/main/java/com/github/junrar/testutil/ExtractArchive.java b/src/main/java/com/github/junrar/testutil/ExtractArchive.java
index fa7c91cb5..215217998 100644
--- a/src/main/java/com/github/junrar/testutil/ExtractArchive.java
+++ b/src/main/java/com/github/junrar/testutil/ExtractArchive.java
@@ -1,10 +1,9 @@
 package com.github.junrar.testutil;
 
-import java.io.File;
 import java.io.IOException;
 
+import com.github.junrar.Junrar;
 import com.github.junrar.exception.RarException;
-import org.apache.commons.logging.LogFactory;
 
 /**
  * extract an archive to the given location
@@ -22,24 +21,17 @@ public static void main(String[] args) throws IOException, RarException {
 		}
 	}
 	
+	/**
+	 * @deprecated  As of release 1.0.2, replaced by { @link #Junrar.extract(final String rarPath, final String destinationPath) }
+	 * 
+	 * @param archive rar file path
+	 * @param destination folder where the files will be extracted
+	 * 
+	 * @throws IOException .
+	 * @throws RarException .
+	 */
+	@Deprecated
 	public static void extractArchive(String archive, String destination) throws IOException, RarException {
-		if (archive == null || destination == null) {
-			throw new RuntimeException("archive and destination must me set");
-		}
-		File arch = new File(archive);
-		if (!arch.exists()) {
-			throw new RuntimeException("the archive does not exit: " + archive);
-		}
-		File dest = new File(destination);
-		if (!dest.exists() || !dest.isDirectory()) {
-			throw new RuntimeException("the destination must exist and point to a directory: " + destination);
-		}
-		ExtractArchive.extractArchive(arch, dest);
-	}
-	
-	public static void extractArchive(File archive, File destination) throws IOException, RarException {
-		com.github.junrar.extract.ExtractArchive extractArchive = new com.github.junrar.extract.ExtractArchive();
-		extractArchive.setLogger(LogFactory.getLog(ExtractArchive.class.getName()));
-		extractArchive.extractArchive(archive, destination);
+		Junrar.extract(archive, destination);
 	}
 }
diff --git a/src/main/java/com/github/junrar/unpack/ComprDataIO.java b/src/main/java/com/github/junrar/unpack/ComprDataIO.java
index fc3324883..4f6cb4231 100644
--- a/src/main/java/com/github/junrar/unpack/ComprDataIO.java
+++ b/src/main/java/com/github/junrar/unpack/ComprDataIO.java
@@ -102,8 +102,11 @@ public void init(OutputStream outputStream) {
 	public void init(FileHeader hd) throws IOException {
 		long startPos = hd.getPositionInFile() + hd.getHeaderSize();
 		unpPackedSize = hd.getFullPackSize();
-		inputStream = new ReadOnlyAccessInputStream(archive.getRof(), startPos,
-				startPos + unpPackedSize);
+		inputStream = new ReadOnlyAccessInputStream(
+			archive.getRof(), 
+			startPos,
+			startPos + unpPackedSize
+		);
 		subHead = hd;
 		curUnpRead = 0;
 		curPackWrite = 0;
@@ -132,8 +135,7 @@ public int unpRead(byte[] addr, int offset, int count) throws IOException,
 			unpPackedSize -= retCode;
 			archive.bytesReadRead(retCode);
 			if (unpPackedSize == 0 && subHead.isSplitAfter()) {
-				Volume nextVolume = archive.getVolumeManager().nextArchive(
-						archive, archive.getVolume());
+				Volume nextVolume = archive.getVolumeManager().nextArchive(archive, archive.getVolume());
 				if (nextVolume == null) {
 					nextVolumeMissing = true;
 					return -1;
diff --git a/src/main/java/com/github/junrar/unpack/vm/BitInput.java b/src/main/java/com/github/junrar/unpack/vm/BitInput.java
index 603cb7793..e3ddfd54b 100644
--- a/src/main/java/com/github/junrar/unpack/vm/BitInput.java
+++ b/src/main/java/com/github/junrar/unpack/vm/BitInput.java
@@ -24,6 +24,7 @@
  * @version $LastChangedRevision$
  */
 public class BitInput {
+	
 	/**
 	 * the max size of the input
 	 */
@@ -32,16 +33,14 @@ public class BitInput {
 	protected int inBit;
 	protected byte[] inBuf;
 	
-	/**
-	 * 
-	 */
+
 	public void InitBitInput()
     {
       inAddr=0;
       inBit=0;
     }
     /**
-     * @param Bits 
+     * @param Bits .
      */
     public void addbits(int Bits)
     {
diff --git a/src/main/java/com/github/junrar/unpack/vm/VMFlags.java b/src/main/java/com/github/junrar/unpack/vm/VMFlags.java
index d2b997b91..40f786b9a 100644
--- a/src/main/java/com/github/junrar/unpack/vm/VMFlags.java
+++ b/src/main/java/com/github/junrar/unpack/vm/VMFlags.java
@@ -24,17 +24,8 @@
  * @version $LastChangedRevision$
  */
 public enum VMFlags {
-	/**
-	 * 
-	 */
 	VM_FC (1),
-	/**
-	 * 
-	 */
 	VM_FZ (2),
-	/**
-	 * 
-	 */
 	VM_FS (0x80000000);
 	
 	private int flag;
@@ -63,12 +54,13 @@ public static VMFlags findFlag(int flag){
 	
 	/**
 	 * Returns true if the flag provided as int is equal to the enum
-	 * @param flag
+	 * @param flag .
 	 * @return returns true if the flag is equal to the enum
 	 */
 	public boolean equals(int flag){
 		return this.flag == flag;
 	}
+	
 	/**
 	 * @return the flag as int
 	 */
diff --git a/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileObject.java b/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileObject.java
index 6d2adf8d6..660b8dd72 100644
--- a/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileObject.java
+++ b/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileObject.java
@@ -111,9 +111,6 @@ public void attachChild(FileName childName) {
 		children.add(childName.getBaseName());
 	}
 
-	/**
-	 * @param header
-	 */
 	public void setHeader(FileHeader header) {
 		this.header = header;
 	}
diff --git a/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileProvider.java b/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileProvider.java
index 43b6040a6..ac744ef8e 100644
--- a/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileProvider.java
+++ b/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileProvider.java
@@ -34,22 +34,21 @@
 
 /**
  * A file system provider for RAR files. Provides read-only file systems.
- * 
+ *
  * @author <a href="http://www.rogiel.com">Rogiel</a>
  */
-public class RARFileProvider extends AbstractLayeredFileProvider implements
-		FileProvider {
+public class RARFileProvider extends AbstractLayeredFileProvider implements FileProvider {
 	/** The list of capabilities this provider supports */
 	protected static final Collection<Capability> capabilities = Collections
-			.unmodifiableCollection(Arrays.asList(new Capability[] {
-					Capability.GET_LAST_MODIFIED,
-					Capability.GET_TYPE,
-					Capability.LIST_CHILDREN,
-					Capability.READ_CONTENT,
-					Capability.URI,
-					Capability.COMPRESS,
-					Capability.VIRTUAL
-				}));
+		.unmodifiableCollection(Arrays.asList(new Capability[] {
+			Capability.GET_LAST_MODIFIED,
+			Capability.GET_TYPE,
+			Capability.LIST_CHILDREN,
+			Capability.READ_CONTENT,
+			Capability.URI,
+			Capability.COMPRESS,
+			Capability.VIRTUAL
+		}));
 
 	public RARFileProvider() {
 		super();
@@ -58,7 +57,7 @@ public RARFileProvider() {
 	/**
 	 * Creates a layered file system. This method is called if the file system
 	 * is not cached.
-	 * 
+	 *
 	 * @param scheme
 	 *            The URI scheme.
 	 * @param file
@@ -66,14 +65,27 @@ public RARFileProvider() {
 	 * @return The file system.
 	 */
 	@Override
-	protected FileSystem doCreateFileSystem(final String scheme,
-			final FileObject file, final FileSystemOptions fileSystemOptions)
-			throws FileSystemException {
-		final AbstractFileName rootName = new LayeredFileName(scheme,
-				file.getName(), FileName.ROOT_PATH, FileType.FOLDER);
-		return new RARFileSystem(rootName, file, fileSystemOptions);
+	protected FileSystem doCreateFileSystem(
+		final String scheme,
+		final FileObject file,
+		final FileSystemOptions fileSystemOptions
+	) throws FileSystemException {
+
+		final AbstractFileName rootName = new LayeredFileName(
+			scheme,
+			file.getName(),
+			FileName.ROOT_PATH,
+			FileType.FOLDER
+		);
+
+		return new RARFileSystem(
+			rootName,
+			file,
+			fileSystemOptions
+		);
 	}
 
+	@Override
 	public Collection<Capability> getCapabilities() {
 		return capabilities;
 	}
diff --git a/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileSystem.java b/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileSystem.java
index 8e789a4aa..bf9be95bf 100644
--- a/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileSystem.java
+++ b/src/main/java/com/github/junrar/vfs2/provider/rar/RARFileSystem.java
@@ -39,19 +39,20 @@
 
 /**
  * A read-only file system for RAR files.
- * 
+ *
  * @author <a href="http://www.rogiel.com">Rogiel</a>
  */
 public class RARFileSystem extends AbstractFileSystem implements FileSystem {
 	private final FileObject parentLayer;
 
 	private Archive archive;
-	private Map<String, FileHeader> files = new HashMap<String, FileHeader>();
+	private final Map<String, FileHeader> files = new HashMap<String, FileHeader>();
 
-	public RARFileSystem(final AbstractFileName rootName,
-			final FileObject parentLayer,
-			final FileSystemOptions fileSystemOptions)
-			throws FileSystemException {
+	public RARFileSystem(
+		final AbstractFileName rootName,
+		final FileObject parentLayer,
+		final FileSystemOptions fileSystemOptions
+	) throws FileSystemException {
 		super(rootName, parentLayer, fileSystemOptions);
 		this.parentLayer = parentLayer;
 	}
@@ -62,12 +63,12 @@ public void init() throws FileSystemException {
 
 		try {
 			try {
-				archive = new Archive(new VFSVolumeManager(parentLayer));
+				this.archive = new Archive(new VFSVolumeManager(this.parentLayer));
 				// Build the index
-				List<RARFileObject> strongRef = new ArrayList<RARFileObject>(
+				final List<RARFileObject> strongRef = new ArrayList<RARFileObject>(
 						100);
-				for (final FileHeader header : archive.getFileHeaders()) {
-					AbstractFileName name = (AbstractFileName) getFileSystemManager()
+				for (final FileHeader header : this.archive.getFileHeaders()) {
+					final AbstractFileName name = (AbstractFileName) getFileSystemManager()
 							.resolveName(
 									getRootName(),
 									UriParser.encode(header.getFileNameString()));
@@ -104,9 +105,9 @@ public void init() throws FileSystemException {
 					}
 				}
 
-			} catch (RarException e) {
+			} catch (final RarException e) {
 				throw new FileSystemException(e);
-			} catch (IOException e) {
+			} catch (final IOException e) {
 				throw new FileSystemException(e);
 			}
 		} finally {
@@ -116,16 +117,16 @@ public void init() throws FileSystemException {
 
 	protected RARFileObject createRARFileObject(final AbstractFileName name,
 			final FileHeader header) throws FileSystemException {
-		return new RARFileObject(name, archive, header, this);
+		return new RARFileObject(name, this.archive, header, this);
 	}
 
 	@Override
 	protected void doCloseCommunicationLink() {
 		try {
-			archive.close();
-		} catch (FileSystemException e) {
+			this.archive.close();
+		} catch (final FileSystemException e) {
 			throw new RuntimeException(e);
-		} catch (IOException e) {
+		} catch (final IOException e) {
 			throw new RuntimeException(e);
 		}
 	}
@@ -144,11 +145,11 @@ protected void addCapabilities(final Collection<Capability> caps) {
 	@Override
 	protected FileObject createFile(final AbstractFileName name)
 			throws FileSystemException {
-		String path = name.getPath().substring(1);
+		final String path = name.getPath().substring(1);
 		if (path.length() == 0) {
-			return new RARFileObject(name, archive, null, this);
-		} else if (files.containsKey(name.getPath())) {
-			return new RARFileObject(name, archive, files.get(name.getPath()),
+			return new RARFileObject(name, this.archive, null, this);
+		} else if (this.files.containsKey(name.getPath())) {
+			return new RARFileObject(name, this.archive, this.files.get(name.getPath()),
 					this);
 		}
 		return null;
@@ -157,6 +158,7 @@ protected FileObject createFile(final AbstractFileName name)
 	/**
 	 * will be called after all file-objects closed their streams.
 	 */
+	@Override
 	protected void notifyAllStreamsClosed() {
 		closeCommunicationLink();
 	}
diff --git a/src/main/java/com/github/junrar/vfs2/provider/rar/RandomAccessContentAccess.java b/src/main/java/com/github/junrar/vfs2/provider/rar/RandomAccessContentAccess.java
index a90ae2bc6..7a76a277a 100644
--- a/src/main/java/com/github/junrar/vfs2/provider/rar/RandomAccessContentAccess.java
+++ b/src/main/java/com/github/junrar/vfs2/provider/rar/RandomAccessContentAccess.java
@@ -17,17 +17,10 @@
 public class RandomAccessContentAccess implements IReadOnlyAccess {
 	private final RandomAccessContent rac;
 
-	/**
-	 * @param rac
-	 */
 	public RandomAccessContentAccess(RandomAccessContent rac) {
 		this.rac = rac;
 	}
 
-	/**
-	 * @param file
-	 * @throws FileSystemException
-	 */
 	public RandomAccessContentAccess(FileObject file)
 			throws FileSystemException {
 		this(file.getContent().getRandomAccessContent(RandomAccessMode.READ));
diff --git a/src/main/java/com/github/junrar/vfs2/provider/rar/VFSVolume.java b/src/main/java/com/github/junrar/vfs2/provider/rar/VFSVolume.java
index 8e4cc2d72..ed4830337 100644
--- a/src/main/java/com/github/junrar/vfs2/provider/rar/VFSVolume.java
+++ b/src/main/java/com/github/junrar/vfs2/provider/rar/VFSVolume.java
@@ -21,10 +21,10 @@ public class VFSVolume implements Volume {
 	private final FileObject file;
 
 	/**
-	 * @param archive
-	 * @param file
+	 * @param archive .
+	 * @param file .
 	 */
-	public VFSVolume(Archive archive, FileObject file) {
+	public VFSVolume(final Archive archive, final FileObject file) {
 		this.archive = archive;
 		this.file = file;
 	}
@@ -33,12 +33,10 @@ public VFSVolume(Archive archive, FileObject file) {
 	public IReadOnlyAccess getReadOnlyAccess() throws IOException {
 		IReadOnlyAccess input = null;
 		try {
-			RandomAccessContent rac = file.getContent().getRandomAccessContent(
-					RandomAccessMode.READ);
+			final RandomAccessContent rac = this.file.getContent().getRandomAccessContent(RandomAccessMode.READ);
 			input = new RandomAccessContentAccess(rac);
-		} catch (Exception e) {
-			input = new InputStreamReadOnlyAccessFile(file.getContent()
-					.getInputStream());
+		} catch (final Exception e) {
+			input = new InputStreamReadOnlyAccessFile(this.file.getContent().getInputStream());
 		}
 		return input;
 	}
@@ -46,21 +44,21 @@ public IReadOnlyAccess getReadOnlyAccess() throws IOException {
 	@Override
 	public long getLength() {
 		try {
-			return file.getContent().getSize();
-		} catch (FileSystemException e) {
+			return this.file.getContent().getSize();
+		} catch (final FileSystemException e) {
 			return -1;
 		}
 	}
 
 	@Override
 	public Archive getArchive() {
-		return archive;
+		return this.archive;
 	}
 
 	/**
 	 * @return the file
 	 */
 	public FileObject getFile() {
-		return file;
+		return this.file;
 	}
 }
diff --git a/src/main/java/com/github/junrar/vfs2/provider/rar/VFSVolumeManager.java b/src/main/java/com/github/junrar/vfs2/provider/rar/VFSVolumeManager.java
index 9342c624b..5301795ab 100644
--- a/src/main/java/com/github/junrar/vfs2/provider/rar/VFSVolumeManager.java
+++ b/src/main/java/com/github/junrar/vfs2/provider/rar/VFSVolumeManager.java
@@ -14,26 +14,23 @@
  * @author <a href="http://www.rogiel.com">Rogiel</a>
  */
 public class VFSVolumeManager implements VolumeManager {
+
 	private final FileObject firstVolume;
 
-	/**
-	 * @param firstVolume
-	 */
-	public VFSVolumeManager(FileObject firstVolume) {
+	public VFSVolumeManager(final FileObject firstVolume) {
 		this.firstVolume = firstVolume;
 	}
 
 	@Override
-	public Volume nextArchive(Archive archive, Volume last) throws IOException {
-		if (last == null)
-			return new VFSVolume(archive, firstVolume);
+	public Volume nextArchive(final Archive archive, final Volume last) throws IOException {
+		if (last == null) return new VFSVolume(archive, this.firstVolume);
 
-		VFSVolume vfsVolume = (VFSVolume) last;
-		boolean oldNumbering = !archive.getMainHeader().isNewNumbering()
+		final VFSVolume vfsVolume = (VFSVolume) last;
+		final boolean oldNumbering = !archive.getMainHeader().isNewNumbering()
 				|| archive.isOldFormat();
-		String nextName = VolumeHelper.nextVolumeName(vfsVolume.getFile()
+		final String nextName = VolumeHelper.nextVolumeName(vfsVolume.getFile()
 				.getName().getBaseName(), oldNumbering);
-		FileObject nextVolumeFile = firstVolume.getParent().resolveFile(
+		final FileObject nextVolumeFile = this.firstVolume.getParent().resolveFile(
 				nextName);
 
 		return new VFSVolume(archive, nextVolumeFile);
diff --git a/src/test/java/com/github/junrar/JunrarTests.java b/src/test/java/com/github/junrar/JunrarTests.java
new file mode 100644
index 000000000..6014e373d
--- /dev/null
+++ b/src/test/java/com/github/junrar/JunrarTests.java
@@ -0,0 +1,113 @@
+package com.github.junrar;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+import org.apache.commons.io.FileUtils;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import com.github.junrar.exception.RarException;
+import com.github.junrar.impl.FileVolumeManager;
+import com.github.junrar.testUtil.JUnRarTestUtil;
+
+public class JunrarTests {
+	private static File tempFolder;
+
+	@BeforeClass
+	public static void setupFunctionalTests() throws IOException{
+		tempFolder = TestCommons.createTempDir();
+	}
+
+	@AfterClass
+	public static void tearDownFunctionalTests() throws IOException{
+		FileUtils.deleteDirectory(tempFolder);
+	}
+
+	@Test
+	public void extractionFromFileHappyDay() throws RarException, IOException {
+		final File rarFileOnTemp = TestCommons.writeTestRarToFolder(tempFolder);
+
+		Junrar.extract(rarFileOnTemp, tempFolder);
+
+		final File fooDir = new File(tempFolder,"foo");
+		assertTrue(fooDir.exists());
+		assertEquals("baz\n", FileUtils.readFileToString(new File(fooDir,"bar.txt")));
+	}
+	
+	@Test
+	public void extractionFromFileWithVolumeManagerAndExtractorHappyDay() throws RarException, IOException {
+		final File rarFileOnTemp = TestCommons.writeTestRarToFolder(tempFolder);
+
+		Junrar.extract(new LocalFolderExtractor(tempFolder), new FileVolumeManager(rarFileOnTemp));
+
+		final File fooDir = new File(tempFolder,"foo");
+		assertTrue(fooDir.exists());
+		assertEquals("baz\n", FileUtils.readFileToString(new File(fooDir,"bar.txt")));
+	}
+
+	@Test
+	public void extractionFromStreamHappyDay() throws IOException, RarException {
+		final InputStream resourceAsStream = JUnRarTestUtil.class.getResourceAsStream(TestCommons.SIMPLE_RAR_RESOURCE_PATH);
+		Junrar.extract(resourceAsStream, tempFolder);
+
+		final File fooDir = new File(tempFolder,"foo");
+		assertTrue(fooDir.exists());
+		assertEquals("baz\n", FileUtils.readFileToString(new File(fooDir,"bar.txt")));
+	}
+
+	@Test
+	public void listContents() throws IOException, RarException {
+		final File testDocuments = TestCommons.writeResourceToFolder(tempFolder, "test-documents.rar");
+		final List<ContentDescription> contentDescriptions = Junrar.getContentsDescription(testDocuments);
+
+		final ContentDescription[] expected = {
+			c("test-documents\\testEXCEL.xls", 13824),
+            c("test-documents\\testHTML.html", 167),
+            c("test-documents\\testOpenOffice2.odt", 26448),
+            c("test-documents\\testPDF.pdf", 34824),
+            c("test-documents\\testPPT.ppt", 16384),
+            c("test-documents\\testRTF.rtf", 3410),
+            c("test-documents\\testTXT.txt", 49),
+            c("test-documents\\testWORD.doc", 19456),
+            c("test-documents\\testXML.xml", 766)
+		};
+
+		assertArrayEquals(expected, contentDescriptions.toArray());
+	}
+
+	@Test
+	public void ifIsDirInsteadOfFile_ThrowException() throws RarException, IOException {
+		try {
+			Junrar.extract(tempFolder, tempFolder);
+		}catch (final IllegalArgumentException e) {
+			assertEquals("First argument should be a file but was "+tempFolder.getAbsolutePath(), e.getMessage());
+			return;
+		}
+		fail();
+	}
+
+	@Test
+	public void ifIsFileInsteadOfDir_ThrowException() throws RarException, IOException {
+		final File rarFileOnTemp = TestCommons.writeTestRarToFolder(tempFolder);
+		try {
+			Junrar.extract(rarFileOnTemp, rarFileOnTemp);
+		}catch (final IllegalArgumentException e) {
+			assertEquals("the destination must exist and point to a directory: "+rarFileOnTemp.getAbsolutePath(), e.getMessage());
+			return;
+		}
+		fail();
+	}
+
+	private static ContentDescription c(final String name, final long size) {
+		return new ContentDescription(name, size);
+	}
+}
diff --git a/src/test/java/com/github/junrar/TestCommons.java b/src/test/java/com/github/junrar/TestCommons.java
new file mode 100644
index 000000000..17e85c684
--- /dev/null
+++ b/src/test/java/com/github/junrar/TestCommons.java
@@ -0,0 +1,34 @@
+package com.github.junrar;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.IOUtils;
+
+import com.github.junrar.testUtil.JUnRarTestUtil;
+
+public class TestCommons {
+
+	public static String SIMPLE_RAR_RESOURCE_PATH = "test.rar";
+	
+	public static File createTempDir() throws IOException {
+		final File tmp = File.createTempFile("Junrar", "test");
+		tmp.delete();
+		tmp.mkdir();
+		return tmp;
+	}
+
+	public static File writeTestRarToFolder(File tmp) throws IOException {
+		return writeResourceToFolder(tmp, SIMPLE_RAR_RESOURCE_PATH);
+	}
+
+	public static File writeResourceToFolder(File destination, String resourcePath) throws IOException {
+		InputStream resourceAsStream = JUnRarTestUtil.class.getResourceAsStream(resourcePath);
+		File testRar = new File(destination, resourcePath);
+	    FileUtils.writeByteArrayToFile(testRar, IOUtils.toByteArray(resourceAsStream));
+		return testRar;
+	}
+
+}
diff --git a/src/test/java/com/github/junrar/testUtil/JUnRarTestUtil.java b/src/test/java/com/github/junrar/testUtil/JUnRarTestUtil.java
index 6a2b6cf91..eadd88002 100644
--- a/src/test/java/com/github/junrar/testUtil/JUnRarTestUtil.java
+++ b/src/test/java/com/github/junrar/testUtil/JUnRarTestUtil.java
@@ -25,13 +25,11 @@
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 
 import org.apache.commons.io.FileUtils;
-import org.apache.commons.io.IOUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.junit.AfterClass;
@@ -39,8 +37,10 @@
 import org.junit.Test;
 
 import com.github.junrar.Archive;
+import com.github.junrar.TestCommons;
 import com.github.junrar.exception.RarException;
 import com.github.junrar.exception.RarException.RarExceptionType;
+import com.github.junrar.impl.FileVolumeManager;
 import com.github.junrar.io.ReadOnlyAccessFile;
 import com.github.junrar.rarfile.FileHeader;
 import com.github.junrar.testutil.ExtractArchive;
@@ -87,31 +87,34 @@ public static void main(String[] args)
 	
 	@BeforeClass
 	public static void setupFunctionalTests() throws IOException{
-		tempFolder = File.createTempFile("FOOOOOOO", "BAAAARRRR");
-		tempFolder.delete();
-		tempFolder.mkdir();
+		tempFolder = TestCommons.createTempDir();
 	}
-	
+
 	@Test
 	public void unrarFile_FileContentsShouldMatchExpected() throws IOException, RarException {
-		InputStream resourceAsStream = JUnRarTestUtil.class.getResourceAsStream("test.rar");
-		File testRar = new File(tempFolder,"test.rar");
-        FileUtils.writeByteArrayToFile(testRar, IOUtils.toByteArray(resourceAsStream));
+		File testRar = TestCommons.writeTestRarToFolder(tempFolder);
+        
         String[] args = new String[]{tempFolder.getAbsolutePath()};
+        
         JUnRarTestUtil.errorsOcurred = false;
+        
         ExtractArchive.main(new String[]{testRar.getAbsolutePath(), tempFolder.getAbsolutePath() });
 		JUnRarTestUtil.main(args);
+		
 		File fooDir = new File(tempFolder,"foo");
 		assertTrue(fooDir.exists());
+		
 		File barFile = new File(fooDir,"bar.txt");
-		assertTrue(fooDir.exists());
+		assertTrue(barFile.exists());
+		
 		String barTxtContents = FileUtils.readFileToString(barFile);
 		assertEquals("baz\n", barTxtContents);
+		
 		if(errorsOcurred){
 			fail("Test failed, see output for details...");
 		}
 	}
-	
+
 	@AfterClass
 	public static void tearDownFunctionalTests() throws IOException{
 		FileUtils.deleteDirectory(tempFolder);
@@ -158,7 +161,7 @@ private static void testFile(File file)
 			try {
 //				readFile = new ReadOnlyAccessFile(file);
 				try {
-					arc = new Archive(file);
+					arc = new Archive(new FileVolumeManager(file));
 				} catch (RarException e) {
 					error("archive consturctor error",e);
 					errorFiles.add(file.toString());
@@ -168,6 +171,7 @@ private static void testFile(File file)
 					if(arc.isEncrypted()){
 						logger.warn("archive is encrypted cannot extreact");
 						unsupportedFiles.add(file.toString());
+						arc.close();
 						return;
 					}
 					List<FileHeader> files = arc.getFileHeaders();
diff --git a/src/test/java/com/github/junrar/testUtil/SimpleTest.java b/src/test/java/com/github/junrar/testUtil/SimpleTest.java
index 24b2cf9df..c3594bbd7 100644
--- a/src/test/java/com/github/junrar/testUtil/SimpleTest.java
+++ b/src/test/java/com/github/junrar/testUtil/SimpleTest.java
@@ -17,6 +17,7 @@
 package com.github.junrar.testUtil;
 
 import com.github.junrar.Archive;
+import com.github.junrar.impl.FileVolumeManager;
 import com.github.junrar.rarfile.FileHeader;
 import org.junit.Test;
 
@@ -43,7 +44,7 @@ public void testTikaDocs() throws Exception {
         File f = new File(getClass().getResource("test-documents.rar").toURI());
         Archive archive = null;
         try {
-            archive = new Archive(f);
+            archive = new Archive(new FileVolumeManager(f));
 
             FileHeader fileHeader = archive.nextFileHeader();
             int i = 0;